{
  "file_path": "/home/kathirks_gc/v8_go/codebase/include/v8-isolate.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/codebase/include/v8-isolate.h\",\n        \"file_name\": \"v8-isolate.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the v8::Isolate class, which represents an isolated instance of the V8 engine, along with related classes and enums for resource constraints, memory management, and callbacks.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers and V8-specific headers for data types, memory management, callbacks, and internal functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stddef.h>\n            #include <stdint.h>\n\n            #include <memory>\n            #include <string>\n            #include <utility>\n\n            #include \"cppgc/common.h\"\n            #include \"v8-array-buffer.h\"       // NOLINT(build/include_directory)\n            #include \"v8-callbacks.h\"          // NOLINT(build/include_directory)\n            #include \"v8-data.h\"               // NOLINT(build/include_directory)\n            #include \"v8-debug.h\"              // NOLINT(build/include_directory)\n            #include \"v8-embedder-heap.h\"      // NOLINT(build/include_directory)\n            #include \"v8-exception.h\"          // NOLINT(build/include_directory)\n            #include \"v8-function-callback.h\"  // NOLINT(build/include_directory)\n            #include \"v8-internal.h\"           // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"       // NOLINT(build/include_directory)\n            #include \"v8-microtask.h\"          // NOLINT(build/include_directory)\n            #include \"v8-persistent-handle.h\"  // NOLINT(build/include_directory)\n            #include \"v8-primitive.h\"          // NOLINT(build/include_directory)\n            #include \"v8-statistics.h\"         // NOLINT(build/include_directory)\n            #include \"v8-unwinder.h\"           // NOLINT(build/include_directory)\n            #include \"v8config.h\"              // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ResourceConstraints\",\n            \"about\": \"Defines limits on the runtime's memory usage, including heap size and stack size.\",\n            \"attributes\": [\n                {\n                    \"name\": \"code_range_size_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The amount of virtual memory reserved for generated code.\"\n                },\n                {\n                    \"name\": \"max_old_generation_size_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The maximum size of the old generation heap.\"\n                },\n                {\n                    \"name\": \"max_young_generation_size_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The maximum size of the young generation heap.\"\n                },\n                {\n                    \"name\": \"initial_old_generation_size_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The initial size of the old generation heap.\"\n                },\n                {\n                    \"name\": \"initial_young_generation_size_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The initial size of the young generation heap.\"\n                },\n                {\n                    \"name\": \"stack_limit_\",\n                    \"type\": \"uint32_t*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The address beyond which the VM's stack may not grow.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT ResourceConstraints {\n            public:\n                /**\n                 * Configures the constraints with reasonable default values based on the\n                 * provided heap size limit. The heap size includes both the young and\n                 * the old generation.\n                 *\n                 * \\param initial_heap_size_in_bytes The initial heap size or zero.\n                 *    By default V8 starts with a small heap and dynamically grows it to\n                 *    match the set of live objects. This may lead to ineffective\n                 *    garbage collections at startup if the live set is large.\n                 *    Setting the initial heap size avoids such garbage collections.\n                 *    Note that this does not affect young generation garbage collections.\n                 *\n                 * \\param maximum_heap_size_in_bytes The hard limit for the heap size.\n                 *    When the heap size approaches this limit, V8 will perform series of\n                 *    garbage collections and invoke the NearHeapLimitCallback. If the garbage\n                 *    collections do not help and the callback does not increase the limit,\n                 *    then V8 will crash with V8::FatalProcessOutOfMemory.\n                 */\n                void ConfigureDefaultsFromHeapSize(size_t initial_heap_size_in_bytes,\n                                                    size_t maximum_heap_size_in_bytes);\n\n                /**\n                 * Configures the constraints with reasonable default values based on the\n                 * capabilities of the current device the VM is running on.\n                 *\n                 * \\param physical_memory The total amount of physical memory on the current\n                 *   device, in bytes.\n                 * \\param virtual_memory_limit The amount of virtual memory on the current\n                 *   device, in bytes, or zero, if there is no limit.\n                 */\n                void ConfigureDefaults(uint64_t physical_memory,\n                                        uint64_t virtual_memory_limit);\n\n                /**\n                 * The address beyond which the VM's stack may not grow.\n                 */\n                uint32_t* stack_limit() const { return stack_limit_; }\n                void set_stack_limit(uint32_t* value) { stack_limit_ = value; }\n\n                /**\n                 * The amount of virtual memory reserved for generated code. This is relevant\n                 * for 64-bit architectures that rely on code range for calls in code.\n                 *\n                 * When V8_COMPRESS_POINTERS_IN_SHARED_CAGE is defined, there is a shared\n                 * process-wide code range that is lazily initialized. This value is used to\n                 * configure that shared code range when the first Isolate is\n                 * created. Subsequent Isolates ignore this value.\n                 */\n                size_t code_range_size_in_bytes() const { return code_range_size_; }\n                void set_code_range_size_in_bytes(size_t limit) { code_range_size_ = limit; }\n\n                /**\n                 * The maximum size of the old generation.\n                 * When the old generation approaches this limit, V8 will perform series of\n                 * garbage collections and invoke the NearHeapLimitCallback.\n                 * If the garbage collections do not help and the callback does not\n                 * increase the limit, then V8 will crash with V8::FatalProcessOutOfMemory.\n                 */\n                size_t max_old_generation_size_in_bytes() const {\n                    return max_old_generation_size_;\n                }\n                void set_max_old_generation_size_in_bytes(size_t limit) {\n                    max_old_generation_size_ = limit;\n                }\n\n                /**\n                 * The maximum size of the young generation, which consists of two semi-spaces\n                 * and a large object space. This affects frequency of Scavenge garbage\n                 * collections and should be typically much smaller that the old generation.\n                 */\n                size_t max_young_generation_size_in_bytes() const {\n                    return max_young_generation_size_;\n                }\n                void set_max_young_generation_size_in_bytes(size_t limit) {\n                    max_young_generation_size_ = limit;\n                }\n\n                size_t initial_old_generation_size_in_bytes() const {\n                    return initial_old_generation_size_;\n                }\n                void set_initial_old_generation_size_in_bytes(size_t initial_size) {\n                    initial_old_generation_size_ = initial_size;\n                }\n\n                size_t initial_young_generation_size_in_bytes() const {\n                    return initial_young_generation_size_;\n                }\n                void set_initial_young_generation_size_in_bytes(size_t initial_size) {\n                    initial_young_generation_size_ = initial_size;\n                }\n\n            private:\n                static constexpr size_t kMB = 1048576u;\n                size_t code_range_size_ = 0;\n                size_t max_old_generation_size_ = 0;\n                size_t max_young_generation_size_ = 0;\n                size_t initial_old_generation_size_ = 0;\n                size_t initial_young_generation_size_ = 0;\n                uint32_t* stack_limit_ = nullptr;\n            };\n        ]]></code>\n    </class>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"MemoryPressureLevel\",\n            \"about\": \"Defines memory pressure levels for memory management.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class MemoryPressureLevel { kNone, kModerate, kCritical };\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"ContextDependants\",\n            \"about\": \"Signal for dependants of contexts. Useful for `ContextDisposedNotification()` to implement different strategies.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class ContextDependants {\n            /** Context has no dependants. These are usually top-level contexts. */\n            kNoDependants,\n            /** Context has some dependants, i.e., it may depend on other contexts. This\n                is usually the case for inner contexts.  */\n            kSomeDependants\n            };\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"StackState\",\n            \"about\": \"Indicator for the stack state\",\n            \"dependencies\": [\"cppgc::EmbedderStackState\"]\n        }\n        </metadata>\n        <code><![CDATA[\n            using StackState = cppgc::EmbedderStackState;\n        ]]></code>\n    </typedef>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IsolateGroup\",\n            \"about\": \"Represents a group of V8 isolates sharing a sandbox and pointer-compression cage.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_group_\",\n                    \"type\": \"internal::IsolateGroup*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the internal IsolateGroup representation.\"\n                }\n            ],\n            \"dependencies\": [\"internal::IsolateGroup\"]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT IsolateGroup {\n            public:\n                /**\n                 * Get the default isolate group. If this V8's build configuration only\n                 * supports a single group, this is a reference to that single group.\n                 * Otherwise this is a group like any other, distinguished only\n                 * in that it is the first group.\n                 */\n                static IsolateGroup GetDefault();\n\n                /**\n                 * Return true if new isolate groups can be created at run-time, or false if\n                 * all isolates must be in the same group.\n                 */\n                static bool CanCreateNewGroups();\n\n                /**\n                 * Create a new isolate group. If this V8's build configuration only supports\n                 * a single group, abort.\n                 */\n                static IsolateGroup Create();\n\n                IsolateGroup(IsolateGroup&& other);\n                IsolateGroup& operator=(IsolateGroup&& other);\n\n                IsolateGroup(const IsolateGroup&) = delete;\n                IsolateGroup& operator=(const IsolateGroup&) = delete;\n\n                ~IsolateGroup();\n\n                bool operator==(const IsolateGroup& other) const {\n                    return isolate_group_ == other.isolate_group_;\n                }\n\n                bool operator!=(const IsolateGroup& other) const {\n                    return !operator==(other);\n                }\n\n            private:\n                friend class Isolate;\n                friend class ArrayBuffer::Allocator;\n\n                // The isolate_group pointer should be already acquired.\n                explicit IsolateGroup(internal::IsolateGroup*&& isolate_group);\n\n                internal::IsolateGroup* isolate_group_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Isolate\",\n            \"about\": \"Represents an isolated instance of the V8 engine.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CreateParams\",\n                \"IsolateGroup\",\n                \"CppHeap\",\n                \"HeapProfiler\",\n                \"MicrotaskQueue\",\n                \"StartupData\",\n                \"ScriptOrModule\",\n                \"SharedArrayBuffer\",\n                \"internal::MicrotaskQueue\",\n                \"internal::ThreadLocalTop\",\n                \"metrics::Recorder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Isolate {\n            public:\n                /**\n                 * Initial configuration parameters for a new Isolate.\n                 */\n                struct V8_EXPORT CreateParams {\n                    CreateParams();\n                    ~CreateParams();\n\n                    ALLOW_COPY_AND_MOVE_WITH_DEPRECATED_FIELDS(CreateParams)\n\n                    /**\n                     * Allows the host application to provide the address of a function that is\n                     * notified each time code is added, moved or removed.\n                     */\n                    JitCodeEventHandler code_event_handler = nullptr;\n\n                    /**\n                     * ResourceConstraints to use for the new Isolate.\n                     */\n                    ResourceConstraints constraints;\n\n                    /**\n                     * Explicitly specify a startup snapshot blob. The embedder owns the blob.\n                     * The embedder *must* ensure that the snapshot is from a trusted source.\n                     */\n                    const StartupData* snapshot_blob = nullptr;\n\n                    /**\n                     * Enables the host application to provide a mechanism for recording\n                     * statistics counters.\n                     */\n                    CounterLookupCallback counter_lookup_callback = nullptr;\n\n                    /**\n                     * Enables the host application to provide a mechanism for recording\n                     * histograms. The CreateHistogram function returns a\n                     * histogram which will later be passed to the AddHistogramSample\n                     * function.\n                     */\n                    CreateHistogramCallback create_histogram_callback = nullptr;\n                    AddHistogramSampleCallback add_histogram_sample_callback = nullptr;\n\n                    /**\n                     * The ArrayBuffer::Allocator to use for allocating and freeing the backing\n                     * store of ArrayBuffers.\n                     *\n                     * If the shared_ptr version is used, the Isolate instance and every\n                     * |BackingStore| allocated using this allocator hold a std::shared_ptr\n                     * to the allocator, in order to facilitate lifetime\n                     * management for the allocator instance.\n                     */\n                    ArrayBuffer::Allocator* array_buffer_allocator = nullptr;\n                    std::shared_ptr<ArrayBuffer::Allocator> array_buffer_allocator_shared;\n\n                    /**\n                     * Specifies an optional nullptr-terminated array of raw addresses in the\n                     * embedder that V8 can match against during serialization and use for\n                     * deserialization. This array and its content must stay valid for the\n                     * entire lifetime of the isolate.\n                     */\n                    const intptr_t* external_references = nullptr;\n\n                    /**\n                     * Whether calling Atomics.wait (a function that may block) is allowed in\n                     * this isolate. This can also be configured via SetAllowAtomicsWait.\n                     */\n                    bool allow_atomics_wait = true;\n\n                    /**\n                     * The following parameters describe the offsets for addressing type info\n                     * for wrapped API objects and are used by the fast C API\n                     * (for details see v8-fast-api-calls.h).\n                     */\n                    int embedder_wrapper_type_index = -1;\n                    int embedder_wrapper_object_index = -1;\n\n                    /**\n                     * Callbacks to invoke in case of fatal or OOM errors.\n                     */\n                    FatalErrorCallback fatal_error_callback = nullptr;\n                    OOMErrorCallback oom_error_callback = nullptr;\n\n                    /**\n                     * A CppHeap used to construct the Isolate. V8 takes ownership of the\n                     * CppHeap passed this way.\n                     */\n                    CppHeap* cpp_heap = nullptr;\n                };\n\n                /**\n                 * Stack-allocated class which sets the isolate for all operations\n                 * executed within a local scope.\n                 */\n                class V8_EXPORT V8_NODISCARD Scope {\n                public:\n                    explicit Scope(Isolate* isolate) : v8_isolate_(isolate) {\n                    v8_isolate_->Enter();\n                    }\n\n                    ~Scope() { v8_isolate_->Exit(); }\n\n                    // Prevent copying of Scope objects.\n                    Scope(const Scope&) = delete;\n                    Scope& operator=(const Scope&) = delete;\n\n                private:\n                    Isolate* const v8_isolate_;\n                };\n\n                /**\n                 * Assert that no Javascript code is invoked.\n                 */\n                class V8_EXPORT V8_NODISCARD DisallowJavascriptExecutionScope {\n                public:\n                    enum OnFailure { CRASH_ON_FAILURE, THROW_ON_FAILURE, DUMP_ON_FAILURE };\n\n                    DisallowJavascriptExecutionScope(Isolate* isolate, OnFailure on_failure);\n                    ~DisallowJavascriptExecutionScope();\n\n                    // Prevent copying of Scope objects.\n                    DisallowJavascriptExecutionScope(const DisallowJavascriptExecutionScope&) =\n                        delete;\n                    DisallowJavascriptExecutionScope& operator=(\n                        const DisallowJavascriptExecutionScope&) = delete;\n\n                private:\n                    v8::Isolate* const v8_isolate_;\n                    const OnFailure on_failure_;\n                    bool was_execution_allowed_;\n                };\n\n                /**\n                 * Introduce exception to DisallowJavascriptExecutionScope.\n                 */\n                class V8_EXPORT V8_NODISCARD AllowJavascriptExecutionScope {\n                public:\n                    explicit AllowJavascriptExecutionScope(Isolate* isolate);\n                    ~AllowJavascriptExecutionScope();\n\n                    // Prevent copying of Scope objects.\n                    AllowJavascriptExecutionScope(const AllowJavascriptExecutionScope&) =\n                        delete;\n                    AllowJavascriptExecutionScope& operator=(\n                        const AllowJavascriptExecutionScope&) = delete;\n\n                private:\n                    Isolate* const v8_isolate_;\n                    bool was_execution_allowed_assert_;\n                    bool was_execution_allowed_throws_;\n                    bool was_execution_allowed_dump_;\n                };\n\n                /**\n                 * Do not run microtasks while this scope is active, even if microtasks are\n                 * automatically executed otherwise.\n                 */\n                class V8_EXPORT V8_NODISCARD SuppressMicrotaskExecutionScope {\n                public:\n                    explicit SuppressMicrotaskExecutionScope(\n                        Isolate* isolate, MicrotaskQueue* microtask_queue = nullptr);\n                    ~SuppressMicrotaskExecutionScope();\n\n                    // Prevent copying of Scope objects.\n                    SuppressMicrotaskExecutionScope(const SuppressMicrotaskExecutionScope&) =\n                        delete;\n                    SuppressMicrotaskExecutionScope& operator=(\n                        const SuppressMicrotaskExecutionScope&) = delete;\n\n                private:\n                    internal::Isolate* const i_isolate_;\n                    internal::MicrotaskQueue* const microtask_queue_;\n                    internal::Address previous_stack_height_;\n\n                    friend class internal::ThreadLocalTop;\n                };\n\n                /**\n                 * Types of garbage collections that can be requested via\n                 * RequestGarbageCollectionForTesting.\n                 */\n                enum GarbageCollectionType {\n                    kFullGarbageCollection,\n                    kMinorGarbageCollection\n                };\n\n                /**\n                 * Features reported via the SetUseCounterCallback callback. Do not change\n                 * assigned numbers of existing items; add new features to the end of this\n                 * list.\n                 * Dead features can be marked `V8_DEPRECATE_SOON`, then `V8_DEPRECATED`, and\n                 * then finally be renamed to `kOBSOLETE_...` to stop embedders from using\n                 * them.\n                 */\n                enum UseCounterFeature {\n                    kUseAsm = 0,\n                    kBreakIterator = 1,\n                    kOBSOLETE_LegacyConst = 2,\n                    kOBSOLETE_MarkDequeOverflow = 3,\n                    kOBSOLETE_StoreBufferOverflow = 4,\n                    kOBSOLETE_SlotsBufferOverflow = 5,\n                    kOBSOLETE_ObjectObserve = 6,\n                    kForcedGC = 7,\n                    kSloppyMode = 8,\n                    kStrictMode = 9,\n                    kOBSOLETE_StrongMode = 10,\n                    kRegExpPrototypeStickyGetter = 11,\n                    kRegExpPrototypeToString = 12,\n                    kRegExpPrototypeUnicodeGetter = 13,\n                    kOBSOLETE_IntlV8Parse = 14,\n                    kOBSOLETE_IntlPattern = 15,\n                    kOBSOLETE_IntlResolved = 16,\n                    kOBSOLETE_PromiseChain = 17,\n                    kOBSOLETE_PromiseAccept = 18,\n                    kOBSOLETE_PromiseDefer = 19,\n                    kHtmlCommentInExternalScript = 20,\n                    kHtmlComment = 21,\n                    kSloppyModeBlockScopedFunctionRedefinition = 22,\n                    kForInInitializer = 23,\n                    kOBSOLETE_ArrayProtectorDirtied = 24,\n                    kArraySpeciesModified = 25,\n                    kArrayPrototypeConstructorModified = 26,\n                    kOBSOLETE_ArrayInstanceProtoModified = 27,\n                    kArrayInstanceConstructorModified = 28,\n                    kOBSOLETE_LegacyFunctionDeclaration = 29,\n                    kOBSOLETE_RegExpPrototypeSourceGetter = 30,\n                    kOBSOLETE_RegExpPrototypeOldFlagGetter = 31,\n                    kDecimalWithLeadingZeroInStrictMode = 32,\n                    kLegacyDateParser = 33,\n                    kDefineGetterOrSetterWouldThrow = 34,\n                    kFunctionConstructorReturnedUndefined = 35,\n                    kAssigmentExpressionLHSIsCallInSloppy = 36,\n                    kAssigmentExpressionLHSIsCallInStrict = 37,\n                    kPromiseConstructorReturnedUndefined = 38,\n                    kOBSOLETE_ConstructorNonUndefinedPrimitiveReturn = 39,\n                    kOBSOLETE_LabeledExpressionStatement = 40,\n                    kOBSOLETE_LineOrParagraphSeparatorAsLineTerminator = 41,\n                    kIndexAccessor = 42,\n                    kErrorCaptureStackTrace = 43,\n                    kErrorPrepareStackTrace = 44,\n                    kErrorStackTraceLimit = 45,\n                    kWebAssemblyInstantiation = 46,\n                    kDeoptimizerDisableSpeculation = 47,\n                    kOBSOLETE_ArrayPrototypeSortJSArrayModifiedPrototype = 48,\n                    kFunctionTokenOffsetTooLongForToString = 49,\n                    kWasmSharedMemory = 50,\n                    kWasmThreadOpcodes = 51,\n                    kOBSOLETE_AtomicsNotify = 52,\n                    kOBSOLETE_AtomicsWake = 53,\n                    kCollator = 54,\n                    kNumberFormat = 55,\n                    kDateTimeFormat = 56,\n                    kPluralRules = 57,\n                    kRelativeTimeFormat = 58,\n                    kLocale = 59,\n                    kListFormat = 60,\n                    kSegmenter = 61,\n                    kStringLocaleCompare = 62,\n                    kOBSOLETE_StringToLocaleUpperCase = 63,\n                    kStringToLocaleLowerCase = 64,\n                    kNumberToLocaleString = 65,\n                    kDateToLocaleString = 66,\n                    kDateToLocaleDateString = 67,\n                    kDateToLocaleTimeString = 68,\n                    kAttemptOverrideReadOnlyOnPrototypeSloppy = 69,\n                    kAttemptOverrideReadOnlyOnPrototypeStrict = 70,\n                    kOBSOLETE_OptimizedFunctionWithOneShotBytecode = 71,\n                    kRegExpMatchIsTrueishOnNonJSRegExp = 72,\n                    kRegExpMatchIsFalseishOnJSRegExp = 73,\n                    kOBSOLETE_DateGetTimezoneOffset = 74,\n                    kStringNormalize = 75,\n                    kCallSiteAPIGetFunctionSloppyCall = 76,\n                    kCallSiteAPIGetThisSloppyCall = 77,\n                    kOBSOLETE_RegExpMatchAllWithNonGlobalRegExp = 78,\n                    kRegExpExecCalledOnSlowRegExp = 79,\n                    kRegExpReplaceCalledOnSlowRegExp = 80,\n                    kDisplayNames = 81,\n                    kSharedArrayBufferConstructed = 82,\n                    kArrayPrototypeHasElements = 83,\n                    kObjectPrototypeHasElements = 84,\n                    kNumberFormatStyleUnit = 85,\n                    kDateTimeFormatRange = 86,\n                    kDateTimeFormatDateTimeStyle = 87,\n                    kBreakIteratorTypeWord = 88,\n                    kBreakIteratorTypeLine = 89,\n                    kInvalidatedArrayBufferDetachingProtector = 90,\n                    kInvalidatedArrayConstructorProtector = 91,\n                    kInvalidatedArrayIteratorLookupChainProtector = 92,\n                    kInvalidatedArraySpeciesLookupChainProtector = 93,\n                    kInvalidatedIsConcatSpreadableLookupChainProtector = 94,\n                    kInvalidatedMapIteratorLookupChainProtector = 95,\n                    kInvalidatedNoElementsProtector = 96,\n                    kInvalidatedPromiseHookProtector = 97,\n                    kInvalidatedPromiseResolveLookupChainProtector = 98,\n                    kInvalidatedPromiseSpeciesLookupChainProtector = 99,\n                    kInvalidatedPromiseThenLookupChainProtector = 100,\n                    kInvalidatedRegExpSpeciesLookupChainProtector = 101,\n                    kInvalidatedSetIteratorLookupChainProtector = 102,\n                    kInvalidatedStringIteratorLookupChainProtector = 103,\n                    kInvalidatedStringLengthOverflowLookupChainProtector = 104,\n                    kInvalidatedTypedArraySpeciesLookupChainProtector = 105,\n                    kWasmSimdOpcodes = 106,\n                    kVarRedeclaredCatchBinding = 107,\n                    kWasmRefTypes = 108,\n                    kOBSOLETE_WasmBulkMemory = 109,\n                    kOBSOLETE_WasmMultiValue = 110,\n                    kWasmExceptionHandling = 111,\n                    kInvalidatedMegaDOMProtector = 112,\n                    kFunctionPrototypeArguments = 113,\n                    kFunctionPrototypeCaller = 114,\n                    kTurboFanOsrCompileStarted = 115,\n                    kAsyncStackTaggingCreateTaskCall = 116,\n                    kDurationFormat = 117,\n                    kInvalidatedNumberStringNotRegexpLikeProtector = 118,\n                    kOBSOLETE_RegExpUnicodeSetIncompatibilitiesWithUnicodeMode = 119,\n                    kOBSOLETE_ImportAssertionDeprecatedSyntax = 120,\n                    kLocaleInfoObsoletedGetters = 121,\n                    kLocaleInfoFunctions = 122,\n                    kCompileHintsMagicAll = 123,\n                    kInvalidatedNoProfilingProtector = 124,\n                    kWasmMemory64 = 125,\n                    kWasmMultiMemory = 126,\n                    kWasmGC = 127,\n                    kWasmImportedStrings = 128,\n                    kSourceMappingUrlMagicCommentAtSign = 129,\n                    kTemporalObject = 130,\n                    kWasmModuleCompilation = 131,\n                    kInvalidatedNoUndetectableObjectsProtector = 132,\n                    kWasmJavaScriptPromiseIntegration = 133,\n                    kWasmReturnCall = 134,\n                    kWasmExtendedConst = 135,\n                    kWasmRelaxedSimd = 136,\n                    kWasmTypeReflection = 137,\n                    kWasmExnRef = 138,\n                    kWasmTypedFuncRef = 139,\n                    kInvalidatedStringWrapperToPrimitiveProtector = 140,\n                    kDocumentAllLegacyCall = 141,\n                    kDocumentAllLegacyConstruct = 142,\n                    kConsoleContext = 143,\n                    kWasmImportedStringsUtf8 = 144,\n                    kResizableArrayBuffer = 145,\n                    kGrowableSharedArrayBuffer = 146,\n                    kArrayByCopy = 147,\n                    kArrayFromAsync = 148,\n                    kIteratorMethods = 149,\n                    kPromiseAny = 150,\n                    kSetMethods = 151,\n                    kArrayFindLast = 152,\n                    kArrayGroup = 153,\n                    kArrayBufferTransfer = 154,\n                    kPromiseWithResolvers = 155,\n                    kAtomicsWaitAsync = 156,\n                    kExtendingNonExtensibleWithPrivate = 157,\n                    kPromiseTry = 158,\n                    kStringReplaceAll = 159,\n                    kStringWellFormed = 160,\n                    kWeakReferences = 161,\n                    kErrorIsError = 162,\n                    kInvalidatedTypedArrayLengthLookupChainProtector = 163,\n                    kRegExpEscape = 164,\n                    kFloat16Array = 165,\n                    kExplicitResourceManagement = 166,\n                    kWasmBranchHinting = 167,\n\n                    // If you add new values here, you'll also need to update Chromium's:\n                    // web_feature.mojom, use_counter_callback.cc, and enums.xml. V8 changes to\n                    // this list need to be landed first, then changes on the Chromium side.\n                    kUseCounterFeatureCount  // This enum value must be last.\n                };\n\n                enum MessageErrorLevel {\n                    kMessageLog = (1 << 0),\n                    kMessageDebug = (1 << 1),\n                    kMessageInfo = (1 << 2),\n                    kMessageError = (1 << 3),\n                    kMessageWarning = (1 << 4),\n                    kMessageAll = kMessageLog | kMessageDebug | kMessageInfo | kMessageError |\n                                    kMessageWarning,\n                };\n\n                // The different priorities that an isolate can have.\n                enum class Priority {\n                    // The isolate does not relate to content that is currently important\n                    // to the user. Lowest priority.\n                    kBestEffort,\n\n                    // The isolate contributes to content that is visible to the user, like a\n                    // visible iframe that's not interacted directly with. High priority.\n                    kUserVisible,\n\n                    // The isolate contributes to content that is of the utmost importance to\n                    // the user, like visible content in the focused window. Highest priority.\n                    kUserBlocking,\n                };\n\n                using UseCounterCallback = void (*)(Isolate* isolate,\n                                                    UseCounterFeature feature);\n\n                /**\n                 * Allocates a new isolate but does not initialize it. Does not change the\n                 * currently entered isolate.\n                 *\n                 * Only Isolate::GetData() and Isolate::SetData(), which access the\n                 * embedder-controlled parts of the isolate, as well as Isolate::GetGroup(),\n                 * are allowed to be called on the uninitialized isolate. To initialize the\n                 * isolate, call `Isolate::Initialize()` or initialize a `SnapshotCreator`.\n                 *\n                 * When an isolate is no longer used its resources should be freed\n                 * by calling Dispose().  Using the delete operator is not allowed.\n                 *\n                 * V8::Initialize() must have run prior to this.\n                 */\n                static Isolate* Allocate();\n                static Isolate* Allocate(const IsolateGroup& group);\n\n                /**\n                 * Return the group for this isolate.\n                 */\n                IsolateGroup GetGroup() const;\n\n                /**\n                 * Initialize an Isolate previously allocated by Isolate::Allocate().\n                 */\n                static void Initialize(Isolate* isolate, const CreateParams& params);\n\n                /**\n                 * Creates a new isolate.  Does not change the currently entered\n                 * isolate.\n                 *\n                 * When an isolate is no longer used its resources should be freed\n                 * by calling Dispose().  Using the delete operator is not allowed.\n                 *\n                 * V8::Initialize() must have run prior to this.\n                 */\n                static Isolate* New(const CreateParams& params);\n                static Isolate* New(const IsolateGroup& group, const CreateParams& params);\n\n                /**\n                 * Returns the entered isolate for the current thread or NULL in\n                 * case there is no current isolate.\n                 *\n                 * This method must not be invoked before V8::Initialize() was invoked.\n                 */\n                static Isolate* GetCurrent();\n\n                /**\n                 * Returns the entered isolate for the current thread or NULL in\n                 * case there is no current isolate.\n                 *\n                 * No checks are performed by this method.\n                 */\n                static Isolate* TryGetCurrent();\n\n                /**\n                 * Return true if this isolate is currently active.\n                 **/\n                bool IsCurrent() const;\n\n                /**\n                 * Clears the set of objects held strongly by the heap. This set of\n                 * objects are originally built when a WeakRef is created or\n                 * successfully dereferenced.\n                 *\n                 * This is invoked automatically after microtasks are run. See\n                 * MicrotasksPolicy for when microtasks are run.\n                 *\n                 * This needs to be manually invoked only if the embedder is manually running\n                 * microtasks via a custom MicrotaskQueue class's PerformCheckpoint. In that\n                 * case, it is the embedder's responsibility to make this call at a time which\n                 "
}