{
  "file_path": "/home/kathirks_gc/v8_go/codebase/include/v8-internal.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/codebase/include/v8-internal.h\",\n            \"file_name\": \"v8-internal.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines internal data structures, constants, and inline functions used within the V8 JavaScript engine. This header file is not part of the public V8 API and is intended for internal use only.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers for basic functionalities like standard definitions, integer types, string manipulation, atomic operations, iterators, limits, memory management, optional values, and type traits.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n\n#include <atomic>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <optional>\n#include <type_traits>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes the V8 configuration header, which defines various build-time settings and feature flags.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"v8config.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Conditionally includes headers related to three-way comparison and concepts based on compiler and library support.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#if __has_include(<version>)\n#include <version>\n#endif\n#if defined(__cpp_lib_three_way_comparison) &&   \\\n    __cpp_lib_three_way_comparison >= 201711L && \\\n    defined(__cpp_lib_concepts) && __cpp_lib_concepts >= 202002L\n#include <compare>\n#include <concepts>\n\n#define V8_HAVE_SPACESHIP_OPERATOR 1\n#else\n#define V8_HAVE_SPACESHIP_OPERATOR 0\n#endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Array\",\n                \"about\": \"Forward declaration for the v8::Array class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Array;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Context\",\n                \"about\": \"Forward declaration for the v8::Context class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Context;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Data\",\n                \"about\": \"Forward declaration for the v8::Data class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Data;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Forward declaration for the v8::Isolate class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Isolate;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Heap\",\n                \"about\": \"Forward declaration for the internal v8::internal::Heap class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Heap;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalHeap\",\n                \"about\": \"Forward declaration for the internal v8::internal::LocalHeap class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass LocalHeap;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Forward declaration for the internal v8::internal::Isolate class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Isolate;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"IsolateGroup\",\n                \"about\": \"Forward declaration for the internal v8::internal::IsolateGroup class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass IsolateGroup;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalIsolate\",\n                \"about\": \"Forward declaration for the internal v8::internal::LocalIsolate class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass LocalIsolate;\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"Address\",\n                \"about\": \"Defines a type alias 'Address' as an unsigned integer type that can hold a pointer.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntypedef uintptr_t Address;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kNullAddress\",\n                \"about\": \"Defines a constant representing the null address.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstatic constexpr Address kNullAddress = 0;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"KB\",\n                \"about\": \"Defines a constant for Kilobyte.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr int KB = 1024;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"MB\",\n                \"about\": \"Defines a constant for Megabyte.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr int MB = KB * 1024;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"GB\",\n                \"about\": \"Defines a constant for Gigabyte.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr int GB = MB * 1024;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"TB\",\n                \"about\": \"Defines a constant for Terabyte on x64 architecture.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_TARGET_ARCH_X64\nconstexpr size_t TB = size_t{GB} * 1024;\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kApiSystemPointerSize\",\n                \"about\": \"Defines the size of a system pointer (void*).\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kApiSystemPointerSize = sizeof(void*);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kApiDoubleSize\",\n                \"about\": \"Defines the size of a double.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kApiDoubleSize = sizeof(double);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kApiInt32Size\",\n                \"about\": \"Defines the size of a 32-bit integer.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kApiInt32Size = sizeof(int32_t);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kApiInt64Size\",\n                \"about\": \"Defines the size of a 64-bit integer.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kApiInt64Size = sizeof(int64_t);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kApiSizetSize\",\n                \"about\": \"Defines the size of a size_t.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kApiSizetSize = sizeof(size_t);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kHeapObjectTag\",\n                \"about\": \"Defines a tag for HeapObject.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kHeapObjectTag = 1;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kWeakHeapObjectTag\",\n                \"about\": \"Defines a tag for WeakHeapObject.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kWeakHeapObjectTag = 3;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kHeapObjectTagSize\",\n                \"about\": \"Defines the size of the HeapObject tag.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kHeapObjectTagSize = 2;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kHeapObjectTagMask\",\n                \"about\": \"Defines a mask for extracting the HeapObject tag.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst intptr_t kHeapObjectTagMask = (1 << kHeapObjectTagSize) - 1;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kHeapObjectReferenceTagMask\",\n                \"about\": \"Defines a mask for HeapObject reference tag.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst intptr_t kHeapObjectReferenceTagMask = 1 << (kHeapObjectTagSize - 1);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kForwardingTag\",\n                \"about\": \"Tag for forwarding pointers.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kForwardingTag = 0;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kForwardingTagSize\",\n                \"about\": \"Size of the forwarding tag.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kForwardingTagSize = 2;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kForwardingTagMask\",\n                \"about\": \"Mask for the forwarding tag.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst intptr_t kForwardingTagMask = (1 << kForwardingTagSize) - 1;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSmiTag\",\n                \"about\": \"Tag for Smis (Small Integers).\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kSmiTag = 0;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSmiTagSize\",\n                \"about\": \"Size of the Smi tag.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kSmiTagSize = 1;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSmiTagMask\",\n                \"about\": \"Mask for extracting the Smi tag.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst intptr_t kSmiTagMask = (1 << kSmiTagSize) - 1;\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"SmiTagging\",\n                \"about\": \"Template struct for handling Smi tagging based on pointer size.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <size_t tagged_ptr_size>\nstruct SmiTagging;\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kIntptrAllBitsSet\",\n                \"about\": \"Constant with all bits set for intptr_t.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr intptr_t kIntptrAllBitsSet = intptr_t{-1};\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kUintptrAllBitsSet\",\n                \"about\": \"Constant with all bits set for uintptr_t.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr uintptr_t kUintptrAllBitsSet =\n    static_cast<uintptr_t>(kIntptrAllBitsSet);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"SmiTagging<4>\",\n                \"about\": \"Specialization of SmiTagging struct for 32-bit tagged pointers.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nstruct SmiTagging<4> {\n  enum { kSmiShiftSize = 0, kSmiValueSize = 31 };\n\n  static constexpr intptr_t kSmiMinValue =\n      static_cast<intptr_t>(kUintptrAllBitsSet << (kSmiValueSize - 1));\n  static constexpr intptr_t kSmiMaxValue = -(kSmiMinValue + 1);\n\n  V8_INLINE static constexpr int SmiToInt(Address value) {\n    int shift_bits = kSmiTagSize + kSmiShiftSize;\n    // Truncate and shift down (requires >> to be sign extending).\n    return static_cast<int32_t>(static_cast<uint32_t>(value)) >> shift_bits;\n  }\n\n  template <class T, typename std::enable_if_t<std::is_integral_v<T> &&\n                                               std::is_signed_v<T>>* = nullptr>\n  V8_INLINE static constexpr bool IsValidSmi(T value) {\n    // Is value in range [kSmiMinValue, kSmiMaxValue].\n    // Use unsigned operations in order to avoid undefined behaviour in case of\n    // signed integer overflow.\n    return (static_cast<uintptr_t>(value) -\n            static_cast<uintptr_t>(kSmiMinValue)) <=\n           (static_cast<uintptr_t>(kSmiMaxValue) -\n            static_cast<uintptr_t>(kSmiMinValue));\n  }\n\n  template <class T,\n            typename std::enable_if_t<std::is_integral_v<T> &&\n                                      std::is_unsigned_v<T>>* = nullptr>\n  V8_INLINE static constexpr bool IsValidSmi(T value) {\n    static_assert(kSmiMaxValue <= std::numeric_limits<uintptr_t>::max());\n    return value <= static_cast<uintptr_t>(kSmiMaxValue);\n  }\n\n  // Same as the `intptr_t` version but works with int64_t on 32-bit builds\n  // without slowing down anything else.\n  V8_INLINE static constexpr bool IsValidSmi(int64_t value) {\n    return (static_cast<uint64_t>(value) -\n            static_cast<uint64_t>(kSmiMinValue)) <=\n           (static_cast<uint64_t>(kSmiMaxValue) -\n            static_cast<uint64_t>(kSmiMinValue));\n  }\n\n  V8_INLINE static constexpr bool IsValidSmi(uint64_t value) {\n    static_assert(kSmiMaxValue <= std::numeric_limits<uint64_t>::max());\n    return value <= static_cast<uint64_t>(kSmiMaxValue);\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"SmiTagging<8>\",\n                \"about\": \"Specialization of SmiTagging struct for 64-bit tagged pointers.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nstruct SmiTagging<8> {\n  enum { kSmiShiftSize = 31, kSmiValueSize = 32 };\n\n  static constexpr intptr_t kSmiMinValue =\n      static_cast<intptr_t>(kUintptrAllBitsSet << (kSmiValueSize - 1));\n  static constexpr intptr_t kSmiMaxValue = -(kSmiMinValue + 1);\n\n  V8_INLINE static constexpr int SmiToInt(Address value) {\n    int shift_bits = kSmiTagSize + kSmiShiftSize;\n    // Shift down and throw away top 32 bits.\n    return static_cast<int>(static_cast<intptr_t>(value) >> shift_bits);\n  }\n\n  template <class T, typename std::enable_if_t<std::is_integral_v<T> &&\n                                               std::is_signed_v<T>>* = nullptr>\n  V8_INLINE static constexpr bool IsValidSmi(T value) {\n    // To be representable as a long smi, the value must be a 32-bit integer.\n    return std::numeric_limits<int32_t>::min() <= value &&\n           value <= std::numeric_limits<int32_t>::max();\n  }\n\n  template <class T,\n            typename std::enable_if_t<std::is_integral_v<T> &&\n                                      std::is_unsigned_v<T>>* = nullptr>\n  V8_INLINE static constexpr bool IsValidSmi(T value) {\n    return value <= std::numeric_limits<int32_t>::max();\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kPtrComprCageReservationSize\",\n                \"about\": \"The size of the virtual memory reservation for the pointer compression cage.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_COMPRESS_POINTERS\n// See v8:7703 or src/common/ptr-compr-inl.h for details about pointer\n// compression.\nconstexpr size_t kPtrComprCageReservationSize = size_t{1} << 32;\nconstexpr size_t kPtrComprCageBaseAlignment = size_t{1} << 32;\n\nstatic_assert(\n    kApiSystemPointerSize == kApiInt64Size,\n    \"Pointer compression can be enabled only for 64-bit architectures\");\nconst int kApiTaggedSize = kApiInt32Size;\n#else\nconst int kApiTaggedSize = kApiSystemPointerSize;\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"PointerCompressionIsEnabled\",\n                \"about\": \"Determines if pointer compression is enabled.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr bool PointerCompressionIsEnabled() {\n  return kApiTaggedSize != kApiSystemPointerSize;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"using\",\n                \"name\": \"PlatformSmiTagging\",\n                \"about\": \"Chooses the SmiTagging struct based on whether 31-bit Smis are used on 64-bit architectures.\",\n                \"dependencies\": [\n                    \"SmiTagging\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_31BIT_SMIS_ON_64BIT_ARCH\nusing PlatformSmiTagging = SmiTagging<kApiInt32Size>;\n#else\nusing PlatformSmiTagging = SmiTagging<kApiTaggedSize>;\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSmiShiftSize\",\n                \"about\": \"Shift size for Smi values.\",\n                \"dependencies\": [\n                    \"PlatformSmiTagging\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kSmiShiftSize = PlatformSmiTagging::kSmiShiftSize;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSmiValueSize\",\n                \"about\": \"Size of Smi values.\",\n                \"dependencies\": [\n                    \"PlatformSmiTagging\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kSmiValueSize = PlatformSmiTagging::kSmiValueSize;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSmiMinValue\",\n                \"about\": \"Minimum Smi value.\",\n                \"dependencies\": [\n                    \"PlatformSmiTagging\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kSmiMinValue = static_cast<int>(PlatformSmiTagging::kSmiMinValue);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSmiMaxValue\",\n                \"about\": \"Maximum Smi value.\",\n                \"dependencies\": [\n                    \"PlatformSmiTagging\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconst int kSmiMaxValue = static_cast<int>(PlatformSmiTagging::kSmiMaxValue);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"SmiValuesAre31Bits\",\n                \"about\": \"Determines if Smi values are 31 bits.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr bool SmiValuesAre31Bits() { return kSmiValueSize == 31; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"SmiValuesAre32Bits\",\n                \"about\": \"Determines if Smi values are 32 bits.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr bool SmiValuesAre32Bits() { return kSmiValueSize == 32; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"Is64\",\n                \"about\": \"Determines if the architecture is 64-bit.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr bool Is64() { return kApiSystemPointerSize == sizeof(int64_t); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"IntToSmi\",\n                \"about\": \"Converts an integer to a Smi.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The integer value to convert\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Address\",\n                    \"description\": \"The Smi representation of the integer.\"\n                },\n                \"dependencies\": [\n                    \"kSmiTagSize\",\n                    \"kSmiShiftSize\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE static constexpr Address IntToSmi(int value) {\n  return (static_cast<Address>(value) << (kSmiTagSize + kSmiShiftSize)) |\n         kSmiTag;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"SandboxIsEnabled\",\n                \"about\": \"Determines if the sandbox is enabled based on preprocessor definitions.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr bool SandboxIsEnabled() {\n#ifdef V8_ENABLE_SANDBOX\n  return true;\n#else\n  return false;\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"SandboxedPointer_t\",\n                \"about\": \"Type alias for sandboxed pointers.\",\n                \"dependencies\": [\n                    \"Address\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing SandboxedPointer_t = Address;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSandboxSizeLog2\",\n                \"about\": \"Log2 of sandbox size.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_ENABLE_SANDBOX\n\n// Size of the sandbox, excluding the guard regions surrounding it.\n#if defined(V8_TARGET_OS_ANDROID)\n// On Android, most 64-bit devices seem to be configured with only 39 bits of\n// virtual address space for userspace. As such, limit the sandbox to 128GB (a\n// quarter of the total available address space).\nconstexpr size_t kSandboxSizeLog2 = 37;  // 128 GB\n#else\n// Everywhere else use a 1TB sandbox.\nconstexpr size_t kSandboxSizeLog2 = 40;  // 1 TB\n#endif  // V8_TARGET_OS_ANDROID\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSandboxSize\",\n                \"about\": \"Size of the sandbox in bytes.\",\n                \"dependencies\": [\n                    \"kSandboxSizeLog2\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr size_t kSandboxSize = 1ULL << kSandboxSizeLog2;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSandboxAlignment\",\n                \"about\": \"Required alignment of the sandbox.\",\n                \"dependencies\": [\n                    \"kPtrComprCageBaseAlignment\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// Required alignment of the sandbox. For simplicity, we require the\n// size of the guard regions to be a multiple of this, so that this specifies\n// the alignment of the sandbox including and excluding surrounding guard\n// regions. The alignment requirement is due to the pointer compression cage\n// being located at the start of the sandbox.\nconstexpr size_t kSandboxAlignment = kPtrComprCageBaseAlignment;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSandboxedPointerShift\",\n                \"about\": \"Shift amount for sandboxed pointers.\",\n                \"dependencies\": [\n                    \"kSandboxSizeLog2\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// Sandboxed pointers are stored inside the heap as offset from the sandbox\n// base shifted to the left. This way, it is guaranteed that the offset is\n// smaller than the sandbox size after shifting it to the right again. This\n// constant specifies the shift amount.\nconstexpr uint64_t kSandboxedPointerShift = 64 - kSandboxSizeLog2;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSandboxGuardRegionSize\",\n                \"about\": \"Size of the guard regions surrounding the sandbox.\",\n                \"dependencies\": [\n                    \"GB\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// Size of the guard regions surrounding the sandbox. This assumes a worst-case\n// scenario of a 32-bit unsigned index used to access an array of 64-bit values\n// with an additional 4GB (compressed pointer) offset. In particular, accesses\n// to TypedArrays are effectively computed as\n// `entry_pointer = array->base + array->offset + index * array->element_size`.\n// See also https://crbug.com/40070746 for more details.\nconstexpr size_t kSandboxGuardRegionSize = 32ULL * GB + 4ULL * GB;\n\nstatic_assert((kSandboxGuardRegionSize % kSandboxAlignment) == 0,\n              \"The size of the guard regions around the sandbox must be a \"\n              \"multiple of its required alignment.\");\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constexpr\",\n                \"name\": \"kSandboxMinimumReservationSize\",\n                \"about\": \"Minimum reservation size for partially reserved sandbox.\",\n                \"dependencies\": [\n                    \"kPtrComprCageReservationSize\",\n                    \"GB\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// On OSes where reserving virtual memory is too expensive to reserve the"
}