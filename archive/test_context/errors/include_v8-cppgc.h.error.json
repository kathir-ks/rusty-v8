{
  "file_path": "/home/kathirks_gc/v8_go/codebase/include/v8-cppgc.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 42, column 49",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/codebase/include/v8-cppgc.h\",\n            \"file_name\": \"v8-cppgc.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the CppHeap class and related interfaces for managed C++ object allocation within the V8 JavaScript engine using cppgc.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers and cppgc headers for memory management and data structures, and v8 headers for integration with the V8 engine.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cstdint>\n            #include <memory>\n            #include <vector>\n\n            #include \"cppgc/common.h\"\n            #include \"cppgc/custom-space.h\"\n            #include \"cppgc/heap-statistics.h\"\n            #include \"cppgc/visitor.h\"\n            #include \"v8-internal.h\"       // NOLINT(build/include_directory)\n            #include \"v8-platform.h\"       // NOLINT(build/include_directory)\n            #include \"v8-traced-handle.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"CppHeapCreateParams\",\n                \"about\": \"Parameters for creating a CppHeap, including custom spaces and marking/sweeping support.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"custom_spaces\",\n                        \"type\": \"std::vector<std::unique_ptr<cppgc::CustomSpaceBase>>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Custom memory spaces to be used by the heap.\"\n                    },\n                    {\n                        \"name\": \"marking_support\",\n                        \"type\": \"cppgc::Heap::MarkingType\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Specifies the type of marking supported by the heap (incremental and concurrent by default).\"\n                    },\n                    {\n                        \"name\": \"sweeping_support\",\n                        \"type\": \"cppgc::Heap::SweepingType\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Specifies the type of sweeping supported by the heap (incremental and concurrent by default).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"cppgc::CustomSpaceBase\",\n                    \"cppgc::Heap::MarkingType\",\n                    \"cppgc::Heap::SweepingType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct V8_EXPORT CppHeapCreateParams {\n            explicit CppHeapCreateParams(\n                std::vector<std::unique_ptr<cppgc::CustomSpaceBase>> custom_spaces)\n                : custom_spaces(std::move(custom_spaces)) {}\n\n            CppHeapCreateParams(const CppHeapCreateParams&) = delete;\n            CppHeapCreateParams& operator=(const CppHeapCreateParams&) = delete;\n\n            std::vector<std::unique_ptr<cppgc::CustomSpaceBase>> custom_spaces;\n            /**\n            * Specifies which kind of marking are supported by the heap. The type may be\n            * further reduced via runtime flags when attaching the heap to an Isolate.\n            */\n            cppgc::Heap::MarkingType marking_support =\n                cppgc::Heap::MarkingType::kIncrementalAndConcurrent;\n            /**\n            * Specifies which kind of sweeping is supported by the heap. The type may be\n            * further reduced via runtime flags when attaching the heap to an Isolate.\n            */\n            cppgc::Heap::SweepingType sweeping_support =\n                cppgc::Heap::SweepingType::kIncrementalAndConcurrent;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CppHeap\",\n                \"about\": \"A heap for allocating managed C++ objects, similar to v8::Isolate.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"v8::Platform\",\n                    \"CppHeapCreateParams\",\n                    \"cppgc::AllocationHandle\",\n                    \"cppgc::HeapHandle\",\n                    \"cppgc::HeapStatistics\",\n                    \"cppgc::CustomSpaceIndex\",\n                    \"CustomSpaceStatisticsReceiver\",\n                    \"cppgc::EmbedderStackState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT CppHeap {\n            public:\n            static std::unique_ptr<CppHeap> Create(v8::Platform* platform,\n                                                const CppHeapCreateParams& params);\n\n            virtual ~CppHeap() = default;\n\n            /**\n            * \\returns the opaque handle for allocating objects using\n            * `MakeGarbageCollected()`.\n            */\n            cppgc::AllocationHandle& GetAllocationHandle();\n\n            /**\n            * \\returns the opaque heap handle which may be used to refer to this heap in\n            *   other APIs. Valid as long as the underlying `CppHeap` is alive.\n            */\n            cppgc::HeapHandle& GetHeapHandle();\n\n            /**\n            * Terminate clears all roots and performs multiple garbage collections to\n            * reclaim potentially newly created objects in destructors.\n            *\n            * After this call, object allocation is prohibited.\n            */\n            V8_DEPRECATED(\"Terminate gets automatically called in the CppHeap destructor\")\n            void Terminate();\n\n            /**\n            * \\param detail_level specifies whether should return detailed\n            *   statistics or only brief summary statistics.\n            * \\returns current CppHeap statistics regarding memory consumption\n            *   and utilization.\n            */\n            cppgc::HeapStatistics CollectStatistics(\n                cppgc::HeapStatistics::DetailLevel detail_level);\n\n            /**\n            * Collects statistics for the given spaces and reports them to the receiver.\n            *\n            * \\param custom_spaces a collection of custom space indices.\n            * \\param receiver an object that gets the results.\n            */\n            void CollectCustomSpaceStatisticsAtLastGC(\n                std::vector<cppgc::CustomSpaceIndex> custom_spaces,\n                std::unique_ptr<CustomSpaceStatisticsReceiver> receiver);\n\n            /**\n            * Enables a detached mode that allows testing garbage collection using\n            * `cppgc::testing` APIs. Once used, the heap cannot be attached to an\n            * `Isolate` anymore.\n            */\n            void EnableDetachedGarbageCollectionsForTesting();\n\n            /**\n            * Performs a stop-the-world garbage collection for testing purposes.\n            *\n            * \\param stack_state The stack state to assume for the garbage collection.\n            */\n            void CollectGarbageForTesting(cppgc::EmbedderStackState stack_state);\n\n            /**\n            * Performs a stop-the-world minor garbage collection for testing purposes.\n            *\n            * \\param stack_state The stack state to assume for the garbage collection.\n            */\n            void CollectGarbageInYoungGenerationForTesting(\n                cppgc::EmbedderStackState stack_state);\n\n            private:\n            CppHeap() = default;\n\n            friend class internal::CppHeap;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSVisitor\",\n                \"extends\": \"cppgc::Visitor\",\n                \"about\": \"A visitor class used for tracing references from JavaScript objects during garbage collection.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"cppgc::Visitor\",\n                    \"TracedReferenceBase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class JSVisitor : public cppgc::Visitor {\n            public:\n            explicit JSVisitor(cppgc::Visitor::Key key) : cppgc::Visitor(key) {}\n            ~JSVisitor() override = default;\n\n            void Trace(const TracedReferenceBase& ref) {\n                if (ref.IsEmptyThreadSafe()) return;\n                Visit(ref);\n            }\n\n            protected:\n            using cppgc::Visitor::Visit;\n\n            virtual void Visit(const TracedReferenceBase& ref) {}\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CustomSpaceStatisticsReceiver\",\n                \"about\": \"An interface for receiving statistics about custom memory spaces within the CppHeap.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"cppgc::CustomSpaceIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class CustomSpaceStatisticsReceiver {\n            public:\n            virtual ~CustomSpaceStatisticsReceiver() = default;\n            /**\n            * Reports the size of a space at the last GC. It is called for each space\n            * that was requested in `CollectCustomSpaceStatisticsAtLastGC()`.\n            *\n            * \\param space_index The index of the space.\n            * \\param bytes The total size of live objects in the space at the last GC.\n            *    It is zero if there was no GC yet.\n            */\n            virtual void AllocatedBytes(cppgc::CustomSpaceIndex space_index,\n                                        size_t bytes) = 0;\n            };\n        ]]></code>\n    </class>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TracedReferenceBase\",\n                \"about\": \"Base class for traced references, likely used for garbage collection.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TracedReferenceBase {\n                public:\n                    bool IsEmptyThreadSafe() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"v8::Platform\",\n                \"about\": \"Abstract interface representing the underlying platform.  Used for task scheduling and other platform-specific operations.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 {\n                class Platform {};\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::AllocationHandle\",\n                \"about\": \"Opaque handle for allocating objects using cppgc.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                class AllocationHandle {};\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::HeapHandle\",\n                \"about\": \"Opaque handle which may be used to refer to a cppgc heap in other APIs.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                class HeapHandle {};\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"cppgc::HeapStatistics::DetailLevel\",\n                \"about\": \"Enum that specifies the level of detail of the statistics.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                struct HeapStatistics {\n                    enum class DetailLevel {\n                        kBrief,\n                        kDetailed\n                    };\n                };\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::CustomSpaceIndex\",\n                \"about\": \"Type representing the index of a custom space.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                using CustomSpaceIndex = size_t;\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"cppgc::EmbedderStackState\",\n                \"about\": \"Enum describing the state of the stack during garbage collection.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                enum class EmbedderStackState {\n                    kNoHeapPointersOnStack,\n                    kMayContainHeapPointers\n                };\n                }\n            ]]></code>\n        </class>\n         <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"v8::TracedReference\",\n                \"about\": \"Smart pointer that allows the garbage collector to trace references.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 {\n                template <typename T> class TracedReference {};\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::CustomSpaceBase\",\n                \"about\": \"Abstract base class for custom memory spaces managed by cppgc.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    class CustomSpaceBase {};\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::Heap\",\n                \"about\": \"Represents a garbage collected heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    class Heap {\n                        public:\n                            enum class MarkingType { kIncrementalAndConcurrent };\n                            enum class SweepingType { kIncrementalAndConcurrent };\n                    };\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}