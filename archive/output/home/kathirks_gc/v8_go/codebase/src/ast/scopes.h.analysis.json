{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/ast/scopes.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/ast/scopes.h\",\n  \"imports\": [\n    \"src/ast/ast.h\",\n    \"src/base/compiler-specific.h\",\n    \"src/base/hashmap.h\",\n    \"src/base/pointer-with-payload.h\",\n    \"src/base/threaded-list.h\",\n    \"src/common/globals.h\",\n    \"src/objects/function-kind.h\",\n    \"src/zone/zone-hashmap.h\",\n    \"src/zone/zone.h\",\n    \"<numeric>\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"VariableMap\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"VariableMap\",\n          \"parameters\": [\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"explicit\",\n          \"logic\": \"Constructor for VariableMap, takes a Zone pointer.\"\n        },\n        {\n          \"name\": \"VariableMap\",\n          \"parameters\": [\n            \"const VariableMap& other\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"\",\n          \"logic\": \"Copy constructor for VariableMap\"\n        },\n        {\n          \"name\": \"VariableMap\",\n          \"parameters\": [\n            \"VariableMap&& other\"\n          ],\n          \"return_type\": \"\",\n          \"logic\": \"Move constructor for VariableMap.\"\n        },\n        {\n          \"name\": \"operator=\",\n          \"parameters\": [\n            \"VariableMap&& other\"\n          ],\n          \"return_type\": \"VariableMap&\",\n          \"logic\": \"Move assignment operator for VariableMap.\"\n        },\n        {\n          \"name\": \"Declare\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"Scope* scope\",\n            \"const AstRawString* name\",\n            \"VariableMode mode\",\n            \"VariableKind kind\",\n            \"InitializationFlag initialization_flag\",\n            \"MaybeAssignedFlag maybe_assigned_flag\",\n            \"IsStaticFlag is_static_flag\",\n            \"bool* was_added\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Declares a new variable in the map. If the variable already exists, it returns the existing variable. was_added indicates if the variable was newly added.\"\n        },\n        {\n          \"name\": \"Lookup\",\n          \"parameters\": [\n            \"const AstRawString* name\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Looks up a variable in the map by its name. Returns nullptr if not found.\"\n        },\n        {\n          \"name\": \"Remove\",\n          \"parameters\": [\n            \"Variable* var\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Removes a variable from the map.\"\n        },\n        {\n          \"name\": \"Add\",\n          \"parameters\": [\n            \"Variable* var\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds a variable to the map.\"\n        },\n        {\n          \"name\": \"zone\",\n          \"parameters\": [],\n          \"return_type\": \"Zone*\",\n          \"logic\": \"Returns the zone associated with the variable map.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Scope\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"Scope\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"Scope* outer_scope\",\n            \"ScopeType scope_type\"\n          ],\n          \"return_type\": \"\",\n          \"logic\": \"Constructor for Scope, takes a Zone, the outer scope, and the scope type.\"\n        },\n        {\n          \"name\": \"SetScopeName\",\n          \"parameters\": [\n            \"const AstRawString* scope_name\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the name of the scope (only used for debugging).\"\n        },\n        {\n          \"name\": \"UniqueIdInScript\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns a unique ID for this scope within the script.\"\n        },\n        {\n          \"name\": \"AsDeclarationScope\",\n          \"parameters\": [],\n          \"return_type\": \"DeclarationScope*\",\n          \"logic\": \"Casts this scope to a DeclarationScope, returning nullptr if it is not a DeclarationScope.\"\n        },\n        {\n          \"name\": \"AsDeclarationScope\",\n          \"parameters\": [],\n          \"return_type\": \"const DeclarationScope*\",\n          \"logic\": \"Casts this scope to a const DeclarationScope, returning nullptr if it is not a DeclarationScope.\"\n        },\n        {\n          \"name\": \"AsModuleScope\",\n          \"parameters\": [],\n          \"return_type\": \"ModuleScope*\",\n          \"logic\": \"Casts this scope to a ModuleScope, returning nullptr if it is not a ModuleScope.\"\n        },\n        {\n          \"name\": \"AsModuleScope\",\n          \"parameters\": [],\n          \"return_type\": \"const ModuleScope*\",\n          \"logic\": \"Casts this scope to a const ModuleScope, returning nullptr if it is not a ModuleScope.\"\n        },\n        {\n          \"name\": \"AsClassScope\",\n          \"parameters\": [],\n          \"return_type\": \"ClassScope*\",\n          \"logic\": \"Casts this scope to a ClassScope, returning nullptr if it is not a ClassScope.\"\n        },\n        {\n          \"name\": \"AsClassScope\",\n          \"parameters\": [],\n          \"return_type\": \"const ClassScope*\",\n          \"logic\": \"Casts this scope to a const ClassScope, returning nullptr if it is not a ClassScope.\"\n        },\n        {\n          \"name\": \"is_reparsed\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this scope is reparsed using ScopeInfo.\"\n        },\n        {\n          \"name\": \"RewriteReplGlobalVariables\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Re-writes the {VariableLocation} of top-level 'let' bindings from CONTEXT to REPL_GLOBAL. Should only be called on REPL scripts.\"\n        },\n        {\n          \"name\": \"Snapshot\",\n          \"parameters\": [\n            \"Scope* scope\"\n          ],\n          \"return_type\": \"inline explicit\",\n          \"logic\": \"Constructor for the Snapshot class.  Takes a Scope.\"\n        },\n        {\n          \"name\": \"Reparent\",\n          \"parameters\": [\n            \"DeclarationScope* new_parent\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Changes the declaration scope parent of the snapshot.\"\n        },\n        {\n          \"name\": \"DeserializeScopeChain\",\n          \"parameters\": [\n            \"IsolateT* isolate\",\n            \"Zone* zone\",\n            \"Tagged<ScopeInfo> scope_info\",\n            \"DeclarationScope* script_scope\",\n            \"AstValueFactory* ast_value_factory\",\n            \"DeserializationMode deserialization_mode\",\n            \"ParseInfo* info\"\n          ],\n          \"return_type\": \"static Scope*\",\n          \"logic\": \"Deserializes a scope chain from ScopeInfo.\"\n        },\n        {\n          \"name\": \"SetScriptScopeInfo\",\n          \"parameters\": [\n            \"IsolateT* isolate\",\n            \"DeclarationScope* script_scope\"\n          ],\n          \"return_type\": \"static void\",\n          \"logic\": \"Sets the scope info for a script scope.\"\n        },\n        {\n          \"name\": \"FinalizeBlockScope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Checks if the block scope is redundant, and if so, removes it.\"\n        },\n        {\n          \"name\": \"zone\",\n          \"parameters\": [],\n          \"return_type\": \"Zone*\",\n          \"logic\": \"Returns the zone for this scope.\"\n        },\n        {\n          \"name\": \"SetMustUsePreparseData\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a flag indicating that preparse data must be used.\"\n        },\n        {\n          \"name\": \"must_use_preparsed_scope_data\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if preparse data must be used.\"\n        },\n        {\n          \"name\": \"LookupLocal\",\n          \"parameters\": [\n            \"const AstRawString* name\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Looks up a local variable in this scope.\"\n        },\n        {\n          \"name\": \"LookupInScopeInfo\",\n          \"parameters\": [\n            \"const AstRawString* name\",\n            \"Scope* cache\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Looks up variable info from scope information.\"\n        },\n        {\n          \"name\": \"DeclareLocal\",\n          \"parameters\": [\n            \"const AstRawString* name\",\n            \"VariableMode mode\",\n            \"VariableKind kind\",\n            \"bool* was_added\",\n            \"InitializationFlag init_flag\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Declares a local variable in this scope.\"\n        },\n        {\n          \"name\": \"DeclareVariable\",\n          \"parameters\": [\n            \"Declaration* declaration\",\n            \"const AstRawString* name\",\n            \"int pos\",\n            \"VariableMode mode\",\n            \"VariableKind kind\",\n            \"InitializationFlag init\",\n            \"bool* was_added\",\n            \"bool* sloppy_mode_block_scope_function_redefinition\",\n            \"bool* ok\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Declares a variable based on the provided parameters.\"\n        },\n        {\n          \"name\": \"DeclareVariableName\",\n          \"parameters\": [\n            \"const AstRawString* name\",\n            \"VariableMode mode\",\n            \"bool* was_added\",\n            \"VariableKind kind\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Declares a variable based on name and mode.\"\n        },\n        {\n          \"name\": \"DeclareCatchVariableName\",\n          \"parameters\": [\n            \"const AstRawString* name\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Declares a catch variable.\"\n        },\n        {\n          \"name\": \"DeclareHomeObjectVariable\",\n          \"parameters\": [\n            \"AstValueFactory* ast_value_factory\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Declares a home object variable.\"\n        },\n        {\n          \"name\": \"DeclareStaticHomeObjectVariable\",\n          \"parameters\": [\n            \"AstValueFactory* ast_value_factory\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Declares a static home object variable.\"\n        },\n        {\n          \"name\": \"declarations\",\n          \"parameters\": [],\n          \"return_type\": \"base::ThreadedList<Declaration>*\",\n          \"logic\": \"Returns the list of declarations in this scope.\"\n        },\n        {\n          \"name\": \"locals\",\n          \"parameters\": [],\n          \"return_type\": \"base::ThreadedList<Variable>*\",\n          \"logic\": \"Returns the list of local variables in this scope.\"\n        },\n        {\n          \"name\": \"NewUnresolved\",\n          \"parameters\": [\n            \"AstNodeFactory* factory\",\n            \"const AstRawString* name\",\n            \"int start_pos\",\n            \"VariableKind kind\"\n          ],\n          \"return_type\": \"VariableProxy*\",\n          \"logic\": \"Creates a new unresolved variable proxy.\"\n        },\n        {\n          \"name\": \"AddUnresolved\",\n          \"parameters\": [\n            \"VariableProxy* proxy\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds an unresolved variable proxy to the unresolved list.\"\n        },\n        {\n          \"name\": \"DeleteUnresolved\",\n          \"parameters\": [\n            \"VariableProxy* var\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Deletes an unresolved variable from the unresolved list.\"\n        },\n        {\n          \"name\": \"NewTemporary\",\n          \"parameters\": [\n            \"const AstRawString* name\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Creates a new temporary variable.\"\n        },\n        {\n          \"name\": \"FindVariableDeclaredIn\",\n          \"parameters\": [\n            \"Scope* scope\",\n            \"VariableMode mode_limit\"\n          ],\n          \"return_type\": \"const AstRawString*\",\n          \"logic\": \"Finds a variable with mode <= mode_limit declared in the given scope.\"\n        },\n        {\n          \"name\": \"RecordEvalCall\",\n          \"parameters\": [],\n          \"return_type\": \"inline void\",\n          \"logic\": \"Records an eval call in the scope and its outer scopes.\"\n        },\n        {\n          \"name\": \"RecordInnerScopeEvalCall\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Records that an inner scope calls eval.\"\n        },\n        {\n          \"name\": \"SetLanguageMode\",\n          \"parameters\": [\n            \"LanguageMode language_mode\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the language mode of the scope.\"\n        },\n        {\n          \"name\": \"SetNonlinear\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks the scope as nonlinear.\"\n        },\n        {\n          \"name\": \"start_position\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the start position of the scope in the source code.\"\n        },\n        {\n          \"name\": \"set_start_position\",\n          \"parameters\": [\n            \"int statement_pos\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the start position of the scope.\"\n        },\n        {\n          \"name\": \"end_position\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the end position of the scope in the source code.\"\n        },\n        {\n          \"name\": \"set_end_position\",\n          \"parameters\": [\n            \"int statement_pos\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the end position of the scope.\"\n        },\n        {\n          \"name\": \"is_hidden\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is hidden (for desugaring scopes).\"\n        },\n        {\n          \"name\": \"set_is_hidden\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the scope as hidden.\"\n        },\n        {\n          \"name\": \"ForceContextAllocationForParameters\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Forces context allocation for parameters.\"\n        },\n        {\n          \"name\": \"has_forced_context_allocation_for_parameters\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if context allocation is forced for parameters.\"\n        },\n        {\n          \"name\": \"is_eval_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is an eval scope.\"\n        },\n        {\n          \"name\": \"is_function_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a function scope.\"\n        },\n        {\n          \"name\": \"is_module_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a module scope.\"\n        },\n        {\n          \"name\": \"is_script_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a script scope.\"\n        },\n        {\n          \"name\": \"is_catch_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a catch scope.\"\n        },\n        {\n          \"name\": \"is_block_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a block scope.\"\n        },\n        {\n          \"name\": \"is_with_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a with scope.\"\n        },\n        {\n          \"name\": \"is_declaration_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a declaration scope.\"\n        },\n        {\n          \"name\": \"is_class_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a class scope.\"\n        },\n        {\n          \"name\": \"is_home_object_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a home object scope.\"\n        },\n        {\n          \"name\": \"is_block_scope_for_object_literal\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a block scope for an object literal.\"\n        },\n        {\n          \"name\": \"set_is_block_scope_for_object_literal\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the block scope to be for object literal.\"\n        },\n        {\n          \"name\": \"inner_scope_calls_eval\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if an inner scope calls eval.\"\n        },\n        {\n          \"name\": \"private_name_lookup_skips_outer_class\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if private name lookup skips outer class.\"\n        },\n        {\n          \"name\": \"has_using_declaration\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if there is a using declaration.\"\n        },\n        {\n          \"name\": \"has_await_using_declaration\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if there is an await using declaration.\"\n        },\n        {\n          \"name\": \"is_wrapped_function\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is a wrapped function.\"\n        },\n        {\n          \"name\": \"set_is_wrapped_function\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets that the scope is wrapped function.\"\n        },\n        {\n          \"name\": \"IsAsmModule\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check whether current scope represents asm module\"\n        },\n        {\n          \"name\": \"ContainsAsmModule\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if this scope or any inner scopes that might be eagerly compiled are asm modules.\"\n        },\n        {\n          \"name\": \"is_nonlinear\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is nonlinear.\"\n        },\n        {\n          \"name\": \"ForceContextForLanguageMode\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a context is forced due to language mode.\"\n        },\n        {\n          \"name\": \"NeedsContext\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this scope needs to be represented by a runtime context.\"\n        },\n        {\n          \"name\": \"ForEach\",\n          \"parameters\": [\n            \"FunctionType callback\"\n          ],\n          \"return_type\": \"V8_INLINE void\",\n          \"logic\": \"Performs a depth-first traversal of the scope tree, executing callback on each scope.  The callback can return kContinue or kDescend to control traversal.\"\n        },\n        {\n          \"name\": \"IsConstructorScope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this scope is a constructor scope.\"\n        },\n        {\n          \"name\": \"IsOuterScopeOf\",\n          \"parameters\": [\n            \"Scope* other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this scope is an outer scope of the given scope.\"\n        },\n        {\n          \"name\": \"scope_type\",\n          \"parameters\": [],\n          \"return_type\": \"ScopeType\",\n          \"logic\": \"Returns the type of the scope.\"\n        },\n        {\n          \"name\": \"language_mode\",\n          \"parameters\": [],\n          \"return_type\": \"LanguageMode\",\n          \"logic\": \"Returns the language mode of the scope.\"\n        },\n        {\n          \"name\": \"inner_scope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Returns the inner scope of this scope.\"\n        },\n        {\n          \"name\": \"sibling\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Returns the sibling scope of this scope.\"\n        },\n        {\n          \"name\": \"outer_scope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Returns the outer scope of this scope.\"\n        },\n        {\n          \"name\": \"catch_variable\",\n          \"parameters\": [],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Returns the catch variable (only for catch scopes).\"\n        },\n        {\n          \"name\": \"ShouldBanArguments\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines whether arguments object is not allowed\"\n        },\n        {\n          \"name\": \"num_stack_slots\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the number of stack slots used by variables in this scope.\"\n        },\n        {\n          \"name\": \"num_heap_slots\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the number of heap slots used by variables in this scope.\"\n        },\n        {\n          \"name\": \"HasContextExtensionSlot\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if a context extension slot must be included\"\n        },\n        {\n          \"name\": \"ContextHeaderLength\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the required length of a context if this scope requires one.\"\n        },\n        {\n          \"name\": \"ContextLocalCount\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the number of context locals.\"\n        },\n        {\n          \"name\": \"AllowsLazyParsingWithoutUnresolvedVariables\",\n          \"parameters\": [\n            \"const Scope* outer\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determine if we can parse function literal in this scope lazily without care of unresolved variables within\"\n        },\n        {\n          \"name\": \"ContextChainLength\",\n          \"parameters\": [\n            \"Scope* scope\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the number of contexts between this scope and the given scope.\"\n        },\n        {\n          \"name\": \"ContextChainLengthUntilOutermostSloppyEval\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"The number of contexts between this and the outermost context that has a sloppy eval call.\"\n        },\n        {\n          \"name\": \"GetDeclarationScope\",\n          \"parameters\": [],\n          \"return_type\": \"DeclarationScope*\",\n          \"logic\": \"Finds the first function, script, eval or block scope (DeclarationScope).\"\n        },\n        {\n          \"name\": \"GetNonEvalDeclarationScope\",\n          \"parameters\": [],\n          \"return_type\": \"DeclarationScope*\",\n          \"logic\": \"Finds the first function, script or block scope.\"\n        },\n        {\n          \"name\": \"GetClosureScope\",\n          \"parameters\": [],\n          \"return_type\": \"DeclarationScope*\",\n          \"logic\": \"Finds the first non-block declaration scope.\"\n        },\n        {\n          \"name\": \"GetClosureScope\",\n          \"parameters\": [],\n          \"return_type\": \"const DeclarationScope*\",\n          \"logic\": \"Finds the first non-block declaration scope (const version).\"\n        },\n        {\n          \"name\": \"GetReceiverScope\",\n          \"parameters\": [],\n          \"return_type\": \"DeclarationScope*\",\n          \"logic\": \"Finds the first function or script scope for receiver binding ('this').\"\n        },\n        {\n          \"name\": \"GetConstructorScope\",\n          \"parameters\": [],\n          \"return_type\": \"DeclarationScope*\",\n          \"logic\": \"Finds the first constructor scope.\"\n        },\n        {\n          \"name\": \"GetHomeObjectScope\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Finds the first class scope or object literal block scope for home object ('super').\"\n        },\n        {\n          \"name\": \"GetScriptScope\",\n          \"parameters\": [],\n          \"return_type\": \"DeclarationScope*\",\n          \"logic\": \"Finds the script scope.\"\n        },\n        {\n          \"name\": \"GetOuterScopeWithContext\",\n          \"parameters\": [],\n          \"return_type\": \"Scope*\",\n          \"logic\": \"Finds the innermost outer scope that needs a context.\"\n        },\n        {\n          \"name\": \"HasReceiverToDeserialize\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Check if this scope has receiver information to deserialize\"\n        },\n        {\n          \"name\": \"HasThisReference\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope has a 'this' reference.\"\n        },\n        {\n          \"name\": \"scope_info\",\n          \"parameters\": [],\n          \"return_type\": \"Handle<ScopeInfo>\",\n          \"logic\": \"Returns the serialized scope information. Analyze() must have been called.\"\n        },\n        {\n          \"name\": \"num_var\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the number of variables declared in this scope.\"\n        },\n        {\n          \"name\": \"Print\",\n          \"parameters\": [\n            \"int n\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints the scope tree (debugging).\"\n        },\n        {\n          \"name\": \"CheckScopePositions\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Checks that the scope has positions assigned (debugging).\"\n        },\n        {\n          \"name\": \"CheckZones\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Checks that all Scopes in the scope tree use the same Zone (debugging).\"\n        },\n        {\n          \"name\": \"MarkReparsingForClassInitializer\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks this scope as reparsing for class initializer.\"\n        },\n        {\n          \"name\": \"HasSimpleParameters\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Retrieve `IsSimpleParameterList` of current or outer function.\"\n        },\n        {\n          \"name\": \"set_is_debug_evaluate_scope\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"set debug evaluate scope flag\"\n        },\n        {\n          \"name\": \"is_debug_evaluate_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"check debug evaluate scope flag\"\n        },\n        {\n          \"name\": \"IsSkippableFunctionScope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the function scope is skippable.\"\n        },\n        {\n          \"name\": \"is_repl_mode_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"check if the scope is repl mode scope\"\n        },\n        {\n          \"name\": \"needs_home_object\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope needs a home object\"\n        },\n        {\n          \"name\": \"set_needs_home_object\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets that the scope needs a home object.\"\n        },\n        {\n          \"name\": \"RemoveInnerScope\",\n          \"parameters\": [\n            \"Scope* inner_scope\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Removes an inner scope from this scope.\"\n        },\n        {\n          \"name\": \"LookupInScopeOrScopeInfo\",\n          \"parameters\": [\n            \"const AstRawString* name\",\n            \"Scope* cache\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Looks up the variable in current scope and its scope_info\"\n        },\n        {\n          \"name\": \"LookupForTesting\",\n          \"parameters\": [\n            \"const AstRawString* name\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Lookup variable in any scope for testing\"\n        },\n        {\n          \"name\": \"ForceDynamicLookup\",\n          \"parameters\": [\n            \"VariableProxy* proxy\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Force dynamic lookup of variable by proxy\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DeclarationScope\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"DeclarationScope\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"Scope* outer_scope\",\n            \"ScopeType scope_type\",\n            \"FunctionKind function_kind\"\n          ],\n          \"return_type\": \"\",\n          \"logic\": \"Constructor for DeclarationScope, inheriting from Scope.  Takes a Zone, the outer scope, scope type, and function kind.\"\n        },\n        {\n          \"name\": \"DeclarationScope\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"ScopeType scope_type\",\n            \"AstValueFactory* ast_value_factory\",\n            \"Handle<ScopeInfo> scope_info\"\n          ],\n          \"return_type\": \"\",\n          \"logic\": \"Constructor for DeclarationScope, used when deserializing ScopeInfo\"\n        },\n        {\n          \"name\": \"DeclarationScope\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"AstValueFactory* ast_value_factory\",\n            \"REPLMode repl_mode\"\n          ],\n          \"return_type\": \"\",\n          \"logic\": \"Constructor for creating a script scope.\"\n        },\n        {\n          \"name\": \"function_kind\",\n          \"parameters\": [],\n          \"return_type\": \"FunctionKind\",\n          \"logic\": \"Returns the function kind of the scope.\"\n        },\n        {\n          \"name\": \"RecordSuperPropertyUsage\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Inform the scope that the corresponding code uses \\\"super\\\".\"\n        },\n        {\n          \"name\": \"uses_super_property\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Return whether the corresponding code uses \\\"super\\\".\"\n        },\n        {\n          \"name\": \"TakeUnresolvedReferencesFromParent\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Takes unresolved references from parent scope.\"\n        },\n        {\n          \"name\": \"is_arrow_scope\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is an arrow function scope.\"\n        },\n        {\n          \"name\": \"RecordDeclarationScopeEvalCall\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Records that this declaration scope contains an eval call.\"\n        },\n        {\n          \"name\": \"sloppy_eval_can_extend_vars\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if sloppy eval can extend vars in this scope.\"\n        },\n        {\n          \"name\": \"was_lazily_parsed\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope was lazily parsed.\"\n        },\n        {\n          \"name\": \"LookupInModule\",\n          \"parameters\": [\n            \"const AstRawString* name\"\n          ],\n          \"return_type\": \"Variable*\",\n          \"logic\": \"Looks up a variable in the module scope.\"\n        },\n        {\n          \"name\": \"set_is_being_lazily_parsed\",\n          \"parameters\": [\n            \"bool is_being_lazily_parsed\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets whether the scope is being lazily parsed (debugging).\"\n        },\n        {\n          \"name\": \"is_being_lazily_parsed\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the scope is being lazily parsed (debugging).\"\n        },\n        {\n          \"name\": \"set_zone\",\n          \"parameters\": [\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets zone"
}