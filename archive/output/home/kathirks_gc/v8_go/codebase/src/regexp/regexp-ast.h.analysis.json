{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/regexp/regexp-ast.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/regexp/regexp-ast.h\",\n  \"imports\": [\n    \"<optional>\",\n    \"src/base/strings.h\",\n    \"src/regexp/regexp-flags.h\",\n    \"src/zone/zone-containers.h\",\n    \"src/zone/zone-list.h\",\n    \"src/zone/zone.h\",\n    \"unicode/uniset.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"RegExpVisitor\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"~RegExpVisitor\",\n          \"parameters\": [],\n          \"return_type\": \"virtual\",\n          \"logic\": \"Virtual destructor.\"\n        },\n        {\n          \"name\": \"VisitDisjunction\",\n          \"parameters\": [\n            \"RegExpDisjunction*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a Disjunction node.\"\n        },\n        {\n          \"name\": \"VisitAlternative\",\n          \"parameters\": [\n            \"RegExpAlternative*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit an Alternative node.\"\n        },\n        {\n          \"name\": \"VisitAssertion\",\n          \"parameters\": [\n            \"RegExpAssertion*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit an Assertion node.\"\n        },\n        {\n          \"name\": \"VisitClassRanges\",\n          \"parameters\": [\n            \"RegExpClassRanges*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a ClassRanges node.\"\n        },\n        {\n          \"name\": \"VisitClassSetOperand\",\n          \"parameters\": [\n            \"RegExpClassSetOperand*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a ClassSetOperand node.\"\n        },\n        {\n          \"name\": \"VisitClassSetExpression\",\n          \"parameters\": [\n            \"RegExpClassSetExpression*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a ClassSetExpression node.\"\n        },\n        {\n          \"name\": \"VisitAtom\",\n          \"parameters\": [\n            \"RegExpAtom*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit an Atom node.\"\n        },\n        {\n          \"name\": \"VisitQuantifier\",\n          \"parameters\": [\n            \"RegExpQuantifier*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a Quantifier node.\"\n        },\n        {\n          \"name\": \"VisitCapture\",\n          \"parameters\": [\n            \"RegExpCapture*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a Capture node.\"\n        },\n        {\n          \"name\": \"VisitGroup\",\n          \"parameters\": [\n            \"RegExpGroup*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a Group node.\"\n        },\n        {\n          \"name\": \"VisitLookaround\",\n          \"parameters\": [\n            \"RegExpLookaround*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a Lookaround node.\"\n        },\n        {\n          \"name\": \"VisitBackReference\",\n          \"parameters\": [\n            \"RegExpBackReference*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a BackReference node.\"\n        },\n        {\n          \"name\": \"VisitEmpty\",\n          \"parameters\": [\n            \"RegExpEmpty*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit an Empty node.\"\n        },\n        {\n          \"name\": \"VisitText\",\n          \"parameters\": [\n            \"RegExpText*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Virtual method to visit a Text node.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Interval\",\n      \"properties\": [\n        \"from_\",\n        \"to_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Interval\",\n          \"parameters\": [],\n          \"return_type\": \"Interval\",\n          \"logic\": \"Default constructor, initializes an empty interval.\"\n        },\n        {\n          \"name\": \"Interval\",\n          \"parameters\": [\n            \"int\",\n            \"int\"\n          ],\n          \"return_type\": \"Interval\",\n          \"logic\": \"Constructor, initializes an interval with given from and to values.\"\n        },\n        {\n          \"name\": \"Union\",\n          \"parameters\": [\n            \"Interval\"\n          ],\n          \"return_type\": \"Interval\",\n          \"logic\": \"Calculates the union of two intervals.\"\n        },\n        {\n          \"name\": \"Empty\",\n          \"parameters\": [],\n          \"return_type\": \"static Interval\",\n          \"logic\": \"Returns an empty interval.\"\n        },\n        {\n          \"name\": \"Contains\",\n          \"parameters\": [\n            \"int\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a value is within the interval.\"\n        },\n        {\n          \"name\": \"is_empty\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the interval is empty.\"\n        },\n        {\n          \"name\": \"from\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the lower bound of the interval.\"\n        },\n        {\n          \"name\": \"to\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the upper bound of the interval.\"\n        },\n        {\n          \"name\": \"size\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the size of the interval.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CharacterRange\",\n      \"properties\": [\n        \"from_\",\n        \"to_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"CharacterRange\",\n          \"parameters\": [],\n          \"return_type\": \"CharacterRange\",\n          \"logic\": \"Default constructor.\"\n        },\n        {\n          \"name\": \"CharacterRange\",\n          \"parameters\": [\n            \"void*\"\n          ],\n          \"return_type\": \"CharacterRange\",\n          \"logic\": \"Constructor for compatibility with CHECK_OK macro.\"\n        },\n        {\n          \"name\": \"Singleton\",\n          \"parameters\": [\n            \"base::uc32\"\n          ],\n          \"return_type\": \"static inline CharacterRange\",\n          \"logic\": \"Creates a CharacterRange representing a single code point.\"\n        },\n        {\n          \"name\": \"Range\",\n          \"parameters\": [\n            \"base::uc32\",\n            \"base::uc32\"\n          ],\n          \"return_type\": \"static inline CharacterRange\",\n          \"logic\": \"Creates a CharacterRange representing a range of code points.\"\n        },\n        {\n          \"name\": \"Everything\",\n          \"parameters\": [],\n          \"return_type\": \"static inline CharacterRange\",\n          \"logic\": \"Creates a CharacterRange that matches everything.\"\n        },\n        {\n          \"name\": \"List\",\n          \"parameters\": [\n            \"Zone*\",\n            \"CharacterRange\"\n          ],\n          \"return_type\": \"static inline ZoneList<CharacterRange>*\",\n          \"logic\": \"Creates a ZoneList containing a single CharacterRange.\"\n        },\n        {\n          \"name\": \"AddClassEscape\",\n          \"parameters\": [\n            \"StandardCharacterSet\",\n            \"ZoneList<CharacterRange>*\",\n            \"bool\",\n            \"Zone*\"\n          ],\n          \"return_type\": \"static V8_EXPORT_PRIVATE void\",\n          \"logic\": \"Adds character ranges corresponding to standard character set escapes like \\\\w, \\\\d, \\\\s.\"\n        },\n        {\n          \"name\": \"AddCaseEquivalents\",\n          \"parameters\": [\n            \"Isolate*\",\n            \"Zone*\",\n            \"ZoneList<CharacterRange>*\",\n            \"bool\"\n          ],\n          \"return_type\": \"static V8_EXPORT_PRIVATE void\",\n          \"logic\": \"Adds case equivalents for the ranges (for /i flag).\"\n        },\n        {\n          \"name\": \"AddUnicodeCaseEquivalents\",\n          \"parameters\": [\n            \"ZoneList<CharacterRange>*\",\n            \"Zone*\"\n          ],\n          \"return_type\": \"static void\",\n          \"logic\": \"Adds unicode case equivalents for the ranges (for /ui or /vi flags).\"\n        },\n        {\n          \"name\": \"Contains\",\n          \"parameters\": [\n            \"base::uc32\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a code point is contained within the range.\"\n        },\n        {\n          \"name\": \"from\",\n          \"parameters\": [],\n          \"return_type\": \"base::uc32\",\n          \"logic\": \"Returns the lower bound of the range.\"\n        },\n        {\n          \"name\": \"to\",\n          \"parameters\": [],\n          \"return_type\": \"base::uc32\",\n          \"logic\": \"Returns the upper bound of the range.\"\n        },\n        {\n          \"name\": \"IsEverything\",\n          \"parameters\": [\n            \"base::uc32\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the range matches everything up to the specified max code point.\"\n        },\n        {\n          \"name\": \"IsSingleton\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the range represents a single code point.\"\n        },\n        {\n          \"name\": \"IsCanonical\",\n          \"parameters\": [\n            \"const ZoneList<CharacterRange>*\"\n          ],\n          \"return_type\": \"static V8_EXPORT_PRIVATE bool\",\n          \"logic\": \"Checks if a list of ranges is in canonical form (ordered, non-overlapping, non-adjacent).\"\n        },\n        {\n          \"name\": \"Canonicalize\",\n          \"parameters\": [\n            \"ZoneList<CharacterRange>*\"\n          ],\n          \"return_type\": \"static void\",\n          \"logic\": \"Converts a list of ranges to canonical form.\"\n        },\n        {\n          \"name\": \"Negate\",\n          \"parameters\": [\n            \"const ZoneList<CharacterRange>*\",\n            \"ZoneList<CharacterRange>*\",\n            \"Zone*\"\n          ],\n          \"return_type\": \"static void\",\n          \"logic\": \"Negates the contents of a character range in canonical form.\"\n        },\n        {\n          \"name\": \"Intersect\",\n          \"parameters\": [\n            \"const ZoneList<CharacterRange>*\",\n            \"const ZoneList<CharacterRange>*\",\n            \"ZoneList<CharacterRange>*\",\n            \"Zone*\"\n          ],\n          \"return_type\": \"static void\",\n          \"logic\": \"Intersects the contents of two character ranges in canonical form.\"\n        },\n        {\n          \"name\": \"Subtract\",\n          \"parameters\": [\n            \"const ZoneList<CharacterRange>*\",\n            \"const ZoneList<CharacterRange>*\",\n            \"ZoneList<CharacterRange>*\",\n            \"Zone*\"\n          ],\n          \"return_type\": \"static void\",\n          \"logic\": \"Subtracts one character range from another.\"\n        },\n        {\n          \"name\": \"ClampToOneByte\",\n          \"parameters\": [\n            \"ZoneList<CharacterRange>*\"\n          ],\n          \"return_type\": \"static void\",\n          \"logic\": \"Removes all ranges outside the one-byte range.\"\n        },\n        {\n          \"name\": \"Equals\",\n          \"parameters\": [\n            \"const ZoneList<CharacterRange>*\",\n            \"const ZoneList<CharacterRange>*\"\n          ],\n          \"return_type\": \"static bool\",\n          \"logic\": \"Checks if two canonical ranges are equal.\"\n        },\n                {\n                    \"name\": \"CharacterRange\",\n                    \"parameters\": [\n                        \"base::uc32\",\n                        \"base::uc32\"\n                    ],\n                    \"return_type\": \"\",\n                    \"logic\": \"Private constructor.  Initializes from and to.\"\n                }\n      ]\n    },\n    {\n      \"name\": \"RegExpTree\",\n      \"properties\": [\n          \"kInfinity\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"~RegExpTree\",\n          \"parameters\": [],\n          \"return_type\": \"virtual\",\n          \"logic\": \"Virtual destructor.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"RegExpVisitor*\",\n            \"void*\"\n          ],\n          \"return_type\": \"virtual void*\",\n          \"logic\": \"Accepts a visitor and data.\"\n        },\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler*\",\n            \"RegExpNode*\"\n          ],\n          \"return_type\": \"virtual RegExpNode*\",\n          \"logic\": \"Converts the tree to a node for compilation.\"\n        },\n        {\n          \"name\": \"IsTextElement\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if the tree is a text element.\"\n        },\n        {\n          \"name\": \"IsAnchoredAtStart\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if the tree is anchored at the start.\"\n        },\n        {\n          \"name\": \"IsAnchoredAtEnd\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if the tree is anchored at the end.\"\n        },\n        {\n          \"name\": \"min_match\",\n          \"parameters\": [],\n          \"return_type\": \"virtual int\",\n          \"logic\": \"Returns the minimum match length.\"\n        },\n        {\n          \"name\": \"max_match\",\n          \"parameters\": [],\n          \"return_type\": \"virtual int\",\n          \"logic\": \"Returns the maximum match length.\"\n        },\n        {\n          \"name\": \"CaptureRegisters\",\n          \"parameters\": [],\n          \"return_type\": \"virtual Interval\",\n          \"logic\": \"Returns the interval of registers used for captures within this expression.\"\n        },\n        {\n          \"name\": \"AppendToText\",\n          \"parameters\": [\n            \"RegExpText*\",\n            \"Zone*\"\n          ],\n          \"return_type\": \"virtual void\",\n          \"logic\": \"Appends the tree to a text element.\"\n        },\n        {\n          \"name\": \"Print\",\n          \"parameters\": [\n            \"std::ostream&\",\n            \"Zone*\"\n          ],\n          \"return_type\": \"V8_EXPORT_PRIVATE std::ostream&\",\n          \"logic\": \"Prints the tree to an output stream.\"\n        },\n        {\n          \"name\": \"AsDisjunction\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpDisjunction*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpDisjunction. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsDisjunction\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpDisjunction.\"\n        },\n        {\n          \"name\": \"AsAlternative\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpAlternative*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpAlternative. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsAlternative\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpAlternative.\"\n        },\n        {\n          \"name\": \"AsAssertion\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpAssertion*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpAssertion. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsAssertion\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpAssertion.\"\n        },\n        {\n          \"name\": \"AsClassRanges\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpClassRanges*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpClassRanges. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsClassRanges\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpClassRanges.\"\n        },\n        {\n          \"name\": \"AsClassSetOperand\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpClassSetOperand*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpClassSetOperand. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsClassSetOperand\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpClassSetOperand.\"\n        },\n        {\n          \"name\": \"AsClassSetExpression\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpClassSetExpression*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpClassSetExpression. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsClassSetExpression\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpClassSetExpression.\"\n        },\n        {\n          \"name\": \"AsAtom\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpAtom*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpAtom. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsAtom\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpAtom.\"\n        },\n        {\n          \"name\": \"AsQuantifier\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpQuantifier*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpQuantifier. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsQuantifier\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpQuantifier.\"\n        },\n        {\n          \"name\": \"AsCapture\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpCapture*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpCapture. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsCapture\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpCapture.\"\n        },\n        {\n          \"name\": \"AsGroup\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpGroup*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpGroup. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsGroup\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpGroup.\"\n        },\n        {\n          \"name\": \"AsLookaround\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpLookaround*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpLookaround. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsLookaround\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpLookaround.\"\n        },\n        {\n          \"name\": \"AsBackReference\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpBackReference*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpBackReference. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsBackReference\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpBackReference.\"\n        },\n        {\n          \"name\": \"AsEmpty\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpEmpty*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpEmpty. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsEmpty\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpEmpty.\"\n        },\n        {\n          \"name\": \"AsText\",\n          \"parameters\": [],\n          \"return_type\": \"virtual RegExpText*\",\n          \"logic\": \"Returns a pointer to this node as a RegExpText. Returns nullptr if the node is not of the correct type.\"\n        },\n        {\n          \"name\": \"IsText\",\n          \"parameters\": [],\n          \"return_type\": \"virtual bool\",\n          \"logic\": \"Checks if this node is a RegExpText.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpDisjunction\",\n      \"properties\": [\n        \"alternatives_\",\n        \"min_match_\",\n        \"max_match_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"RegExpDisjunction\",\n          \"parameters\": [\n            \"ZoneList<RegExpTree*>*\"\n          ],\n          \"return_type\": \"explicit\",\n          \"logic\": \"Constructor for RegExpDisjunction. Initializes the list of alternatives.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"RegExpVisitor*\",\n            \"void*\"\n          ],\n          \"return_type\": \"void*\",\n          \"logic\": \"Accepts a visitor and data.\"\n        },\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler*\",\n            \"RegExpNode*\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the disjunction to a node.\"\n        },\n        {\n          \"name\": \"AsDisjunction\",\n          \"parameters\": [],\n          \"return_type\": \"RegExpDisjunction*\",\n          \"logic\": \"Returns itself as a RegExpDisjunction.\"\n        },\n        {\n          \"name\": \"IsDisjunction\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true since this is a RegExpDisjunction.\"\n        },\n        {\n          \"name\": \"CaptureRegisters\",\n          \"parameters\": [],\n          \"return_type\": \"Interval\",\n          \"logic\": \"Returns the union of the capture register intervals of its alternatives.\"\n        },\n        {\n          \"name\": \"IsAnchoredAtStart\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if all alternatives are anchored at the start.\"\n        },\n        {\n          \"name\": \"IsAnchoredAtEnd\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if all alternatives are anchored at the end.\"\n        },\n        {\n          \"name\": \"min_match\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the minimum match length (minimum of all alternatives).\"\n        },\n        {\n          \"name\": \"max_match\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the maximum match length (maximum of all alternatives).\"\n        },\n        {\n          \"name\": \"alternatives\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneList<RegExpTree*>*\",\n          \"logic\": \"Returns the list of alternatives.\"\n        },\n        {\n          \"name\": \"SortConsecutiveAtoms\",\n          \"parameters\": [\n            \"RegExpCompiler*\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Sorts consecutive atoms.\"\n        },\n        {\n          \"name\": \"RationalizeConsecutiveAtoms\",\n          \"parameters\": [\n            \"RegExpCompiler*\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Rationalizes consecutive atoms.\"\n        },\n        {\n          \"name\": \"FixSingleCharacterDisjunctions\",\n          \"parameters\": [\n            \"RegExpCompiler*\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Fixes single-character disjunctions.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpAlternative\",\n      \"properties\": [\n        \"nodes_\",\n        \"min_match_\",\n        \"max_match_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"RegExpAlternative\",\n          \"parameters\": [\n            \"ZoneList<RegExpTree*>*\"\n          ],\n          \"return_type\": \"explicit\",\n          \"logic\": \"Constructor for RegExpAlternative. Initializes the list of nodes.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"RegExpVisitor*\",\n            \"void*\"\n          ],\n          \"return_type\": \"void*\",\n          \"logic\": \"Accepts a visitor and data.\"\n        },\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler*\",\n            \"RegExpNode*\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the alternative to a node.\"\n        },\n        {\n          \"name\": \"AsAlternative\",\n          \"parameters\": [],\n          \"return_type\": \"RegExpAlternative*\",\n          \"logic\": \"Returns itself as a RegExpAlternative.\"\n        },\n        {\n          \"name\": \"IsAlternative\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true since this is a RegExpAlternative.\"\n        },\n        {\n          \"name\": \"CaptureRegisters\",\n          \"parameters\": [],\n          \"return_type\": \"Interval\",\n          \"logic\": \"Calculates the combined capture register interval of all nodes.\"\n        },\n        {\n          \"name\": \"IsAnchoredAtStart\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the alternative is anchored at the start.\"\n        },\n        {\n          \"name\": \"IsAnchoredAtEnd\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the alternative is anchored at the end.\"\n        },\n        {\n          \"name\": \"min_match\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the minimum match length (sum of all nodes).\"\n        },\n        {\n          \"name\": \"max_match\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the maximum match length (sum of all nodes).\"\n        },\n        {\n          \"name\": \"nodes\",\n          \"parameters\": [],\n          \"return_type\": \"ZoneList<RegExpTree*>*\",\n          \"logic\": \"Returns the list of nodes.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpAssertion\",\n      \"properties\": [\n        \"assertion_type_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"RegExpAssertion\",\n          \"parameters\": [\n            \"Type\"\n          ],\n          \"return_type\": \"explicit\",\n          \"logic\": \"Constructor for RegExpAssertion. Initializes the assertion type.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"RegExpVisitor*\",\n            \"void*\"\n          ],\n          \"return_type\": \"void*\",\n          \"logic\": \"Accepts a visitor and data.\"\n        },\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler*\",\n            \"RegExpNode*\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts the assertion to a node.\"\n        },\n        {\n          \"name\": \"AsAssertion\",\n          \"parameters\": [],\n          \"return_type\": \"RegExpAssertion*\",\n          \"logic\": \"Returns itself as a RegExpAssertion.\"\n        },\n        {\n          \"name\": \"IsAssertion\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true since this is a RegExpAssertion.\"\n        },\n        {\n          \"name\": \"IsAnchoredAtStart\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the assertion is anchored at the start.\"\n        },\n        {\n          \"name\": \"IsAnchoredAtEnd\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the assertion is anchored at the end.\"\n        },\n        {\n          \"name\": \"min_match\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns 0 since assertions don't consume input.\"\n        },\n        {\n          \"name\": \"max_match\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns 0 since assertions don't consume input.\"\n        },\n        {\n          \"name\": \"assertion_type\",\n          \"parameters\": [],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type of the assertion.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CharacterSet\",\n      \"properties\": [\n        \"ranges_\",\n        \"standard_set_type_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"CharacterSet\",\n          \"parameters\": [\n            \"StandardCharacterSet\"\n          ],\n          \"return_type\": \"explicit\",\n          \"logic\": \"Constructor for standard character set types.\"\n        },\n        {\n          \"name\": \"CharacterSet\",\n          \"parameters\": [\n            \"ZoneList<CharacterRange>*\"\n          ],\n          \"return_type\": \"explicit\",\n          \"logic\": \"Constructor with given ranges.\"\n        },\n        {\n          \"name\": \"ranges\",\n          \"parameters\": [\n            \"Zone*\"\n          ],\n          \"return_type\": \"ZoneList<CharacterRange>*\",\n          \"logic\": \"Returns character ranges. If standard character set type is specified, it initializes the ranges according to the standard set type.\"\n        },\n        {\n          \"name\": \"standard_set_type\",\n          \"parameters\": [],\n          \"return_type\": \"StandardCharacterSet\",\n          \"logic\": \"Returns the standard set type if one is specified.\"\n        },\n        {\n          \"name\": \"set_standard_set_type\",\n          \"parameters\": [\n            \"StandardCharacterSet\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the standard set type.\"\n        },\n        {\n          \"name\": \"is_standard\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this represents a standard set.\"\n        },\n        {\n          \"name\": \"Canonicalize\",\n          \"parameters\": [],\n          \"return_type\": \"V8_EXPORT_PRIVATE void\",\n          \"logic\": \"Canonicalizes the CharacterSet.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpClassRanges\",\n      \"properties\": [\n        \"set_\",\n        \"class_ranges_flags_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"RegExpClassRanges\",\n          \"parameters\": [\n            \"Zone*\",\n            \"ZoneList<CharacterRange>*\",\n            \"ClassRangesFlags\"\n          ],\n          \"return_type\": \"\",\n          \"logic\": \"Constructs a RegExpClassRanges object with given ranges and flags.\"\n        },\n        {\n          \"name\": \"RegExpClassRanges\",\n          \"parameters\": [\n            \"StandardCharacterSet\"\n          ],\n          \"return_type\": \"explicit\",\n          \"logic\": \"Constructs a RegExpClassRanges object with a standard character set.\"\n        },\n        {\n          \"name\": \"Accept\",\n          \"parameters\": [\n            \"RegExpVisitor*\",\n            \"void*\"\n          ],\n          \"return_type\": \"void*\",\n          \"logic\": \"Accepts a visitor and data.\"\n        },\n        {\n          \"name\": \"ToNode\",\n          \"parameters\": [\n            \"RegExpCompiler*\",\n            \"RegExpNode*\"\n          ],\n          \"return_type\": \"RegExpNode*\",\n          \"logic\": \"Converts this ClassRanges node to an executable node.\"\n        },\n        {\n          \"name\": \"AsClassRanges\",\n          \"parameters\": [],\n          \"return_type\": \"RegExpClassRanges*\",\n          \"logic\": \"Returns itself as a RegExpClassRanges object.\"\n        },\n        {\n          \"name\": \"IsClassRanges\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this node is a RegExpClassRanges.\"\n        },\n        {\n          \"name\": \"IsTextElement\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true, this is a text element.\"\n        },\n        {\n          \"name\": \"min_match\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns 1, representing minimum 1 character match.\"\n        },\n        {\n          \"name\": \"max_match\",\n          \"parameters\": [],\n          \"return_type\": \"int\","
}