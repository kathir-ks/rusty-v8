{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/regexp/regexp-compiler.cc",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/regexp/regexp-compiler.cc\",\n  \"imports\": [\n    \"src/regexp/regexp-compiler.h\",\n    \"<optional>\",\n    \"src/base/safe_conversions.h\",\n    \"src/execution/isolate.h\",\n    \"src/objects/fixed-array-inl.h\",\n    \"src/regexp/regexp-macro-assembler-arch.h\",\n    \"src/strings/unicode-inl.h\",\n    \"src/zone/zone-list-inl.h\",\n    \"src/regexp/special-case.h\",\n    \"unicode/locid.h\",\n    \"unicode/uniset.h\",\n    \"unicode/utypes.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"RecursionCheck\",\n      \"properties\": [\n        \"compiler_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"RecursionCheck\",\n          \"parameters\": [\n            \"RegExpCompiler* compiler\"\n          ],\n          \"return_type\": \"explicit\",\n          \"logic\": \"Constructor that increments the compiler's recursion depth.\"\n        },\n        {\n          \"name\": \"~RecursionCheck\",\n          \"parameters\": [],\n          \"return_type\": \"\",\n          \"logic\": \"Destructor that decrements the compiler's recursion depth.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DynamicBitSet\",\n      \"properties\": [\n        \"first_\",\n        \"remaining_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Get\",\n          \"parameters\": [\n            \"unsigned value\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a value is present in the bitset.\"\n        },\n        {\n          \"name\": \"Set\",\n          \"parameters\": [\n            \"unsigned value\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds a value to the bitset.  May do zone allocation.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Trace\",\n      \"properties\": [\n        \"actions_\",\n        \"cp_offset_\",\n        \"backtrack_\",\n        \"quick_check_performed_\",\n        \"characters_preloaded_\",\n        \"stop_node_\",\n        \"at_start_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Mentions\",\n          \"parameters\": [\"int that\"],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a deferred action mentions a specific register.\"\n        },\n        {\n          \"name\": \"mentions_reg\",\n          \"parameters\": [\"int reg\"],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if any deferred action mentions a specific register.\"\n        },\n        {\n          \"name\": \"GetStoredPosition\",\n          \"parameters\": [\"int reg\", \"int* cp_offset\"],\n          \"return_type\": \"bool\",\n          \"logic\": \"Gets the stored position for a register from the deferred actions.\"\n        },\n        {\n          \"name\": \"FindAffectedRegisters\",\n          \"parameters\": [\"DynamicBitSet* affected_registers\", \"Zone* zone\"],\n          \"return_type\": \"int\",\n          \"logic\": \"Finds all affected registers in the trace's actions and stores them in a DynamicBitSet.\"\n        },\n        {\n          \"name\": \"RestoreAffectedRegisters\",\n          \"parameters\": [\"RegExpMacroAssembler* assembler\", \"int max_register\", \"const DynamicBitSet& registers_to_pop\", \"const DynamicBitSet& registers_to_clear\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Restores the values of affected registers from the stack, clearing some as needed.\"\n        },\n        {\n          \"name\": \"PerformDeferredActions\",\n          \"parameters\": [\"RegExpMacroAssembler* assembler\", \"int max_register\", \"const DynamicBitSet& affected_registers\", \"DynamicBitSet* registers_to_pop\", \"DynamicBitSet* registers_to_clear\", \"Zone* zone\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Performs the deferred actions in the trace, such as setting or incrementing registers.\"\n        },\n        {\n          \"name\": \"Flush\",\n          \"parameters\": [\"RegExpCompiler* compiler\", \"RegExpNode* successor\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Flushes the trace, emitting code to bring the actual state into line with the virtual state.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpCompiler\",\n      \"properties\": [\n        \"next_register_\",\n        \"unicode_lookaround_stack_register_\",\n        \"unicode_lookaround_position_register_\",\n        \"work_list_\",\n        \"recursion_depth_\",\n        \"flags_\",\n        \"one_byte_\",\n        \"reg_exp_too_big_\",\n        \"limiting_recursion_\",\n        \"optimize_\",\n        \"read_backward_\",\n        \"current_expansion_factor_\",\n        \"frequency_collator_\",\n        \"isolate_\",\n        \"zone_\",\n        \"macro_assembler_\",\n        \"accept_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"RegExpCompiler\",\n          \"parameters\": [\n            \"Isolate* isolate\",\n            \"Zone* zone\",\n            \"int capture_count\",\n            \"RegExpFlags flags\",\n            \"bool one_byte\"\n          ],\n          \"return_type\": \"explicit\",\n          \"logic\": \"Constructor for RegExpCompiler. Initializes the compiler's state.\"\n        },\n        {\n          \"name\": \"Assemble\",\n          \"parameters\": [\n            \"Isolate* isolate\",\n            \"RegExpMacroAssembler* macro_assembler\",\n            \"RegExpNode* start\",\n            \"int capture_count\",\n            \"DirectHandle<String> pattern\"\n          ],\n          \"return_type\": \"CompilationResult\",\n          \"logic\": \"Assembles the regular expression into bytecodes or native code.\"\n        },\n        {\n          \"name\": \"AddWork\",\n          \"parameters\": [\n            \"RegExpNode* node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Adds a node to the work list for later code generation.\"\n        },\n        {\n          \"name\": \"IncrementRecursionDepth\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Increments the recursion depth.\"\n        },\n        {\n          \"name\": \"DecrementRecursionDepth\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Decrements the recursion depth.\"\n        },\n        {\n          \"name\": \"set_limiting_recursion\",\n          \"parameters\": [\n            \"bool limiting_recursion\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the limiting_recursion flag.\"\n        },\n        {\n          \"name\": \"limiting_recursion\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Gets the value of the limiting_recursion flag.\"\n        },\n        {\n          \"name\": \"optimize\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Gets the optimization flag.\"\n        },\n        {\n          \"name\": \"set_flags\",\n          \"parameters\": [\"RegExpFlags flags\"],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the flags.\"\n        },\n        {\n          \"name\": \"flags\",\n          \"parameters\": [],\n          \"return_type\": \"RegExpFlags\",\n          \"logic\": \"Gets the flags.\"\n        },\n        {\n          \"name\": \"one_byte\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Gets whether the subject is one byte.\"\n        },\n        {\n            \"name\": \"zone\",\n            \"parameters\": [],\n            \"return_type\": \"Zone*\",\n            \"logic\": \"Returns the zone.\"\n        },\n                {\n            \"name\": \"macro_assembler\",\n            \"parameters\": [],\n            \"return_type\": \"RegExpMacroAssembler*\",\n            \"logic\": \"Returns the macro assembler.\"\n        },\n        {\n            \"name\": \"isolate\",\n            \"parameters\": [],\n            \"return_type\": \"Isolate*\",\n            \"logic\": \"Returns the isolate.\"\n        },\n        {\n            \"name\": \"recursion_depth\",\n            \"parameters\": [],\n            \"return_type\": \"int\",\n            \"logic\": \"Returns the current recursion depth.\"\n        },\n      ]\n    },\n    {\n      \"name\": \"RegExpTree\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"AppendToText\",\n          \"parameters\": [\n            \"RegExpText* text\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the text of this node to a RegExpText object.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpAtom\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"AppendToText\",\n          \"parameters\": [\n            \"RegExpText* text\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the text of this atom to a RegExpText object.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpClassRanges\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"AppendToText\",\n          \"parameters\": [\n            \"RegExpText* text\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the text of this class ranges to a RegExpText object.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"RegExpText\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"AppendToText\",\n          \"parameters\": [\n            \"RegExpText* text\",\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Appends the text of this text node to another RegExpText object.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"TextElement\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"length\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the length of the text element.\"\n        }\n      ]\n    },\n        {\n            \"name\": \"GuardedAlternative\",\n            \"properties\": [],\n            \"methods\": [\n                {\n                    \"name\": \"AddGuard\",\n                    \"parameters\": [\"Guard* guard\", \"Zone* zone\"],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Adds a guard to the alternative.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"ActionNode\",\n            \"properties\": [],\n            \"methods\": [\n                {\n                    \"name\": \"SetRegisterForLoop\",\n                    \"parameters\": [\"int reg\", \"int val\", \"RegExpNode* on_success\"],\n                    \"return_type\": \"ActionNode*\",\n                    \"logic\": \"Creates an ActionNode that sets a register for a loop.\"\n                },\n                {\n                    \"name\": \"IncrementRegister\",\n                    \"parameters\": [\"int reg\", \"RegExpNode* on_success\"],\n                    \"return_type\": \"ActionNode*\",\n                    \"logic\": \"Creates an ActionNode that increments a register.\"\n                },\n                {\n                    \"name\": \"StorePosition\",\n                    \"parameters\": [\"int reg\", \"bool is_capture\", \"RegExpNode* on_success\"],\n                    \"return_type\": \"ActionNode*\",\n                    \"logic\": \"Creates an ActionNode that stores the current position to a register.\"\n                },\n                {\n                    \"name\": \"ClearCaptures\",\n                    \"parameters\": [\"Interval range\", \"RegExpNode* on_success\"],\n                    \"return_type\": \"ActionNode*\",\n                    \"logic\": \"Creates an ActionNode that clears captures.\"\n                },\n                {\n                  \"name\": \"BeginPositiveSubmatch\",\n                  \"parameters\": [\"int stack_reg\", \"int position_reg\", \"RegExpNode* body\", \"ActionNode* success_node\"],\n                  \"return_type\": \"ActionNode*\",\n                  \"logic\": \"Creates an ActionNode to mark the beginning of a positive submatch.\"\n                },\n                {\n                  \"name\": \"BeginNegativeSubmatch\",\n                  \"parameters\": [\"int stack_reg\", \"int position_reg\", \"RegExpNode* on_success\"],\n                  \"return_type\": \"ActionNode*\",\n                  \"logic\": \"Creates an ActionNode to mark the beginning of a negative submatch.\"\n                },\n                {\n                  \"name\": \"PositiveSubmatchSuccess\",\n                  \"parameters\": [\"int stack_reg\", \"int position_reg\", \"int clear_register_count\", \"int clear_register_from\", \"RegExpNode* on_success\"],\n                  \"return_type\": \"ActionNode*\",\n                  \"logic\": \"Creates an ActionNode to mark the success of a positive submatch.\"\n                },\n                {\n                  \"name\": \"EmptyMatchCheck\",\n                  \"parameters\": [\"int start_register\", \"int repetition_register\", \"int repetition_limit\", \"RegExpNode* on_success\"],\n                  \"return_type\": \"ActionNode*\",\n                  \"logic\": \"Creates an ActionNode to perform an empty match check.\"\n                },\n                {\n                  \"name\": \"ModifyFlags\",\n                  \"parameters\": [\"RegExpFlags flags\", \"RegExpNode* on_success\"],\n                  \"return_type\": \"ActionNode*\",\n                  \"logic\": \"Creates an ActionNode that modifies the regexp flags.\"\n                }\n            ]\n        },\n        {\n          \"name\": \"NegativeSubmatchSuccess\",\n          \"properties\": [],\n          \"methods\": [\n            {\n              \"name\": \"Emit\",\n              \"parameters\": [\"RegExpCompiler* compiler\", \"Trace* trace\"],\n              \"return_type\": \"void\",\n              \"logic\": \"Emits code to handle success of negative lookahead.\"\n            }\n          ]\n        },\n        {\n          \"name\": \"EndNode\",\n          \"properties\": [],\n          \"methods\": [\n            {\n              \"name\": \"Emit\",\n              \"parameters\": [\"RegExpCompiler* compiler\", \"Trace* trace\"],\n              \"return_type\": \"void\",\n              \"logic\": \"Emits code to handle the end of a regexp.\"\n            }\n          ]\n        },\n                {\n            \"name\": \"RegExpNode\",\n            \"properties\": [],\n            \"methods\": [\n                {\n                  \"name\": \"LimitVersions\",\n                  \"parameters\": [\"RegExpCompiler* compiler\", \"Trace* trace\"],\n                  \"return_type\": \"LimitResult\",\n                  \"logic\": \"Limits the number of versions of code generated for a node to avoid code bloat.\"\n                },\n                                {\n                  \"name\": \"KeepRecursing\",\n                  \"parameters\": [\"RegExpCompiler* compiler\"],\n                  \"return_type\": \"bool\",\n                  \"logic\": \"Checks if recursion can continue or should be limited.\"\n                }\n            ]\n        }\n  ],\n  \"functions\": [\n    {\n      \"name\": \"MaxCodeUnit\",\n      \"parameters\": [\n        \"const bool one_byte\"\n      ],\n      \"return_type\": \"base::uc32\",\n      \"logic\": \"Returns the maximum code unit based on whether it's a one-byte or two-byte string.\"\n    },\n    {\n      \"name\": \"CharMask\",\n      \"parameters\": [\n        \"const bool one_byte\"\n      ],\n      \"return_type\": \"uint32_t\",\n      \"logic\": \"Returns the character mask based on whether it's a one-byte or two-byte string.\"\n    },\n    {\n      \"name\": \"GetCaseIndependentLetters\",\n      \"parameters\": [\n        \"Isolate* isolate\",\n        \"base::uc16 character\",\n        \"RegExpCompiler* compiler\",\n        \"unibrow::uchar* letters\",\n        \"int letter_length\"\n      ],\n      \"return_type\": \"int\",\n      \"logic\": \"Gets case-independent letters for a character.\"\n    },\n    {\n      \"name\": \"EmitSimpleCharacter\",\n      \"parameters\": [\n        \"Isolate* isolate\",\n        \"RegExpCompiler* compiler\",\n        \"base::uc16 c\",\n        \"Label* on_failure\",\n        \"int cp_offset\",\n        \"bool check\",\n        \"bool preloaded\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Emits code to check for a simple character match.\"\n    },\n    {\n      \"name\": \"EmitAtomNonLetter\",\n      \"parameters\": [\n        \"Isolate* isolate\",\n        \"RegExpCompiler* compiler\",\n        \"base::uc16 c\",\n        \"Label* on_failure\",\n        \"int cp_offset\",\n        \"bool check\",\n        \"bool preloaded\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Emits code to check for a non-letter atom match (case-insensitive).\"\n    },\n    {\n      \"name\": \"ShortCutEmitCharacterPair\",\n      \"parameters\": [\n        \"RegExpMacroAssembler* macro_assembler\",\n        \"bool one_byte\",\n        \"base::uc16 c1\",\n        \"base::uc16 c2\",\n        \"Label* on_failure\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Emits optimized code to check for a character pair with simple differences.\"\n    },\n    {\n      \"name\": \"EmitAtomLetter\",\n      \"parameters\": [\n        \"Isolate* isolate\",\n        \"RegExpCompiler* compiler\",\n        \"base::uc16 c\",\n        \"Label* on_failure\",\n        \"int cp_offset\",\n        \"bool check\",\n        \"bool preloaded\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Emits code to check for a letter atom match (case-insensitive).\"\n    },\n    {\n      \"name\": \"EmitBoundaryTest\",\n      \"parameters\": [\n        \"RegExpMacroAssembler* masm\",\n        \"int border\",\n        \"Label* fall_through\",\n        \"Label* above_or_equal\",\n        \"Label* below\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Emits code to test character against a single boundary.\"\n    },\n    {\n      \"name\": \"EmitDoubleBoundaryTest\",\n      \"parameters\": [\n        \"RegExpMacroAssembler* masm\",\n        \"int first\",\n        \"int last\",\n        \"Label* fall_through\",\n        \"Label* in_range\",\n        \"Label* out_of_range\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Emits code to test character against an inclusive range.\"\n    },\n    {\n      \"name\": \"EmitUseLookupTable\",\n      \"parameters\": [\n        \"RegExpMacroAssembler* masm\",\n        \"ZoneList<base::uc32>* ranges\",\n        \"uint32_t start_index\",\n        \"uint32_t end_index\",\n        \"base::uc32 min_char\",\n        \"Label* fall_through\",\n        \"Label* even_label\",\n        \"Label* odd_label\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Emits code to use a lookup table for character class testing.\"\n    },\n    {\n      \"name\": \"CutOutRange\",\n      \"parameters\": [\n        \"RegExpMacroAssembler* masm\",\n        \"ZoneList<base::uc32>* ranges\",\n        \"uint32_t start_index\",\n        \"uint32_t end_index\",\n        \"uint32_t cut_index\",\n        \"Label* even_label\",\n        \"Label* odd_label\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Cuts out a range within a range list used for character class matching.\"\n    },\n    {\n      \"name\": \"SplitSearchSpace\",\n      \"parameters\": [\n        \"ZoneList<base::uc32>* ranges\",\n        \"uint32_t start_index\",\n        \"uint32_t end_index\",\n        \"uint32_t* new_start_index\",\n        \"uint32_t* new_end_index\",\n        \"base::uc32* border\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Splits the search space into smaller ranges for character class matching.\"\n    },\n    {\n      \"name\": \"GenerateBranches\",\n      \"parameters\": [\n        \"RegExpMacroAssembler* masm\",\n        \"ZoneList<base::uc32>* ranges\",\n        \"uint32_t start_index\",\n        \"uint32_t end_index\",\n        \"base::uc32 min_char\",\n        \"base::uc32 max_char\",\n        \"Label* fall_through\",\n        \"Label* even_label\",\n        \"Label* odd_label\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Generates branches to handle character class matching based on ranges.\"\n    },\n    {\n      \"name\": \"EmitClassRanges\",\n      \"parameters\": [\n        \"RegExpMacroAssembler* macro_assembler\",\n        \"RegExpClassRanges* cr\",\n        \"bool one_byte\",\n        \"Label* on_failure\",\n        \"int cp_offset\",\n        \"bool check_offset\",\n        \"bool preloaded\",\n        \"Zone* zone\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Emits code to check for character ranges (character classes).\"\n    },\n    {\n      \"name\": \"SmearBitsRight\",\n      \"parameters\": [\n        \"uint32_t v\"\n      ],\n      \"return_type\": \"uint32_t\",\n      \"logic\": \"Takes the left-most 1-bit and smears it out, setting all bits to its right.\"\n    },\n    {\n      \"name\": \"RangeContainsLatin1Equivalents\",\n      \"parameters\": [\n        \"CharacterRange range\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"We need to check for the following characters: 0x39C 0x3BC 0x178.\"\n    },\n    {\n      \"name\": \"RangesContainLatin1Equivalents\",\n      \"parameters\": [\n        \"ZoneList<CharacterRange>* ranges\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Checks if a character range contains latin 1 equivalents.\"\n    },\n    {\n      \"name\": \"EmitWordCheck\",\n      \"parameters\": [\n        \"RegExpMacroAssembler* assembler\",\n        \"Label* word\",\n        \"Label* non_word\",\n        \"bool fall_through_on_word\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Emit code to check if a character is a word character or not\"\n    },\n    {\n      \"name\": \"EmitHat\",\n      \"parameters\": [\n        \"RegExpCompiler* compiler\",\n        \"RegExpNode* on_success\",\n        \"Trace* trace\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Emit code to check if we are at the start or end of a line.\"\n    },\n    {\n      \"name\": \"DeterminedAlready\",\n      \"parameters\": [\n        \"QuickCheckDetails* quick_check\",\n        \"int offset\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Checks if the position is determined in a quick check.\"\n    },\n    {\n      \"name\": \"UpdateBoundsCheck\",\n      \"parameters\": [\n        \"int index\",\n        \"int* checked_up_to\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Updates the bounds check.\"\n    }\n  ]\n}\n```"
}