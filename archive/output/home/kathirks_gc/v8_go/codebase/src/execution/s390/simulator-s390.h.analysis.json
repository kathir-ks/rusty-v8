{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/execution/s390/simulator-s390.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/execution/s390/simulator-s390.h\",\n  \"imports\": [\n    \"src/common/globals.h\",\n    \"src/base/hashmap.h\",\n    \"src/codegen/assembler.h\",\n    \"src/codegen/s390/constants-s390.h\",\n    \"src/execution/simulator-base.h\",\n    \"src/utils/allocation.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"CachePage\",\n      \"properties\": [\n        \"data_[kPageSize]\",\n        \"validity_map_[kValidityMapSize]\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"CachePage\",\n          \"parameters\": [],\n          \"return_type\": \"CachePage\",\n          \"logic\": \"Constructor. Initializes the validity_map_ to LINE_INVALID, effectively invalidating all cache lines.\"\n        },\n        {\n          \"name\": \"ValidityByte\",\n          \"parameters\": [\n            \"int offset\"\n          ],\n          \"return_type\": \"char*\",\n          \"logic\": \"Returns a pointer to the validity byte for the given offset.\"\n        },\n        {\n          \"name\": \"CachedData\",\n          \"parameters\": [\n            \"int offset\"\n          ],\n          \"return_type\": \"char*\",\n          \"logic\": \"Returns a pointer to the cached data for the given offset.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Simulator\",\n      \"properties\": [\n        \"instruction_tracing_\",\n        \"registers_[kNumGPRs]\",\n        \"fp_registers_[kNumFPRs]\",\n        \"condition_reg_\",\n        \"special_reg_pc_\",\n        \"stack_\",\n        \"pc_modified_\",\n        \"icount_\",\n        \"last_debugger_input_\",\n        \"break_pc_\",\n        \"break_instr_\",\n        \"isolate_\",\n        \"watched_stops_[kNumOfWatchedStops]\",\n        \"EvalTable[MAX_NUM_OPCODES]\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Simulator\",\n          \"parameters\": [\n            \"Isolate* isolate\"\n          ],\n          \"return_type\": \"Simulator\",\n          \"logic\": \"Constructor for the S390 simulator, taking an Isolate pointer as input.\"\n        },\n        {\n          \"name\": \"~Simulator\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Destructor for the simulator class.\"\n        },\n        {\n          \"name\": \"current\",\n          \"parameters\": [\n            \"v8::internal::Isolate* isolate\"\n          ],\n          \"return_type\": \"Simulator*\",\n          \"logic\": \"Returns the currently executing Simulator instance for a given Isolate.\"\n        },\n        {\n          \"name\": \"set_register\",\n          \"parameters\": [\n            \"int reg\",\n            \"uint64_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the value of a general-purpose register.\"\n        },\n        {\n          \"name\": \"get_register\",\n          \"parameters\": [\n            \"int reg\"\n          ],\n          \"return_type\": \"const uint64_t&\",\n          \"logic\": \"Returns a constant reference to the value of a general-purpose register.\"\n        },\n        {\n          \"name\": \"get_register\",\n          \"parameters\": [\n            \"int reg\"\n          ],\n          \"return_type\": \"uint64_t&\",\n          \"logic\": \"Returns a modifiable reference to the value of a general-purpose register.\"\n        },\n        {\n          \"name\": \"get_low_register\",\n          \"parameters\": [\n            \"int reg\"\n          ],\n          \"return_type\": \"T\",\n          \"logic\": \"Returns the low 32 bits of a register.\"\n        },\n        {\n          \"name\": \"get_high_register\",\n          \"parameters\": [\n            \"int reg\"\n          ],\n          \"return_type\": \"T\",\n          \"logic\": \"Returns the high 32 bits of a register.\"\n        },\n        {\n          \"name\": \"set_low_register\",\n          \"parameters\": [\n            \"int reg\",\n            \"uint32_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the low 32 bits of a register.\"\n        },\n        {\n          \"name\": \"set_high_register\",\n          \"parameters\": [\n            \"int reg\",\n            \"uint32_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the high 32 bits of a register.\"\n        },\n        {\n          \"name\": \"get_double_from_register_pair\",\n          \"parameters\": [\n            \"int reg\"\n          ],\n          \"return_type\": \"double\",\n          \"logic\": \"Gets a double value from a register pair.\"\n        },\n        {\n          \"name\": \"get_fpr\",\n          \"parameters\": [\n            \"int dreg\"\n          ],\n          \"return_type\": \"T\",\n          \"logic\": \"Gets a floating-point value from a floating-point register.\"\n        },\n        {\n          \"name\": \"set_fpr\",\n          \"parameters\": [\n            \"int dreg\",\n            \"const T val\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a floating-point value in a floating-point register.\"\n        },\n        {\n          \"name\": \"set_pc\",\n          \"parameters\": [\n            \"intptr_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the program counter (PC) register.\"\n        },\n        {\n          \"name\": \"get_pc\",\n          \"parameters\": [],\n          \"return_type\": \"intptr_t\",\n          \"logic\": \"Returns the value of the program counter (PC) register.\"\n        },\n        {\n          \"name\": \"get_sp\",\n          \"parameters\": [],\n          \"return_type\": \"Address\",\n          \"logic\": \"Returns the stack pointer (SP) register.\"\n        },\n        {\n          \"name\": \"StackLimit\",\n          \"parameters\": [\n            \"uintptr_t c_limit\"\n          ],\n          \"return_type\": \"uintptr_t\",\n          \"logic\": \"Returns the stack limit, adding a safety margin to prevent overflows.\"\n        },\n        {\n          \"name\": \"StackBase\",\n          \"parameters\": [],\n          \"return_type\": \"uintptr_t\",\n          \"logic\": \"Returns the stack base address.\"\n        },\n        {\n          \"name\": \"GetCentralStackView\",\n          \"parameters\": [],\n          \"return_type\": \"base::Vector<uint8_t>\",\n          \"logic\": \"Returns a central stack view without additional safety margins.\"\n        },\n        {\n          \"name\": \"IterateRegistersAndStack\",\n          \"parameters\": [\n            \"::heap::base::StackVisitor* visitor\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates through the registers and stack, calling a visitor function for each.\"\n        },\n        {\n          \"name\": \"Execute\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Executes S390 instructions until the PC reaches end_sim_pc.\"\n        },\n        {\n          \"name\": \"Call\",\n          \"parameters\": [\n            \"Address entry\",\n            \"Args... args\"\n          ],\n          \"return_type\": \"Return\",\n          \"logic\": \"Calls a function at a given entry point with variable arguments.\"\n        },\n        {\n          \"name\": \"CallFP\",\n          \"parameters\": [\n            \"Address entry\",\n            \"double d0\",\n            \"double d1\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Calls a 2-argument double function at a given entry point.\"\n        },\n        {\n          \"name\": \"CallFPReturnsInt\",\n          \"parameters\": [\n            \"Address entry\",\n            \"double d0\",\n            \"double d1\"\n          ],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Calls a 2-argument double function that returns an integer value.\"\n        },\n        {\n          \"name\": \"CallFPReturnsDouble\",\n          \"parameters\": [\n            \"Address entry\",\n            \"double d0\",\n            \"double d1\"\n          ],\n          \"return_type\": \"double\",\n          \"logic\": \"Calls a 2-argument double function that returns a double value.\"\n        },\n        {\n          \"name\": \"PushAddress\",\n          \"parameters\": [\n            \"uintptr_t address\"\n          ],\n          \"return_type\": \"uintptr_t\",\n          \"logic\": \"Pushes an address onto the JS stack.\"\n        },\n        {\n          \"name\": \"PopAddress\",\n          \"parameters\": [],\n          \"return_type\": \"uintptr_t\",\n          \"logic\": \"Pops an address from the JS stack.\"\n        },\n        {\n          \"name\": \"set_last_debugger_input\",\n          \"parameters\": [\n            \"char* input\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the last debugger input string.\"\n        },\n        {\n          \"name\": \"last_debugger_input\",\n          \"parameters\": [],\n          \"return_type\": \"char*\",\n          \"logic\": \"Returns the last debugger input string.\"\n        },\n        {\n          \"name\": \"SetRedirectInstruction\",\n          \"parameters\": [\n            \"Instruction* instruction\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets an instruction to be redirected.\"\n        },\n        {\n          \"name\": \"ICacheMatch\",\n          \"parameters\": [\n            \"void* one\",\n            \"void* two\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if two addresses match in the ICache.\"\n        },\n        {\n          \"name\": \"FlushICache\",\n          \"parameters\": [\n            \"base::CustomMatcherHashMap* i_cache\",\n            \"void* start\",\n            \"size_t size\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Flushes a range of addresses from the ICache.\"\n        },\n        {\n          \"name\": \"has_bad_pc\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the PC register contains a 'special_values' defined pc value.\"\n        },\n        {\n          \"name\": \"InstructionTracingEnabled\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if instruction tracing is enabled.\"\n        },\n        {\n          \"name\": \"ToggleInstructionTracing\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Toggles the instruction tracing flag.\"\n        },\n        {\n          \"name\": \"CallImpl\",\n          \"parameters\": [\n            \"Address entry\",\n            \"int argument_count\",\n            \"const intptr_t* arguments\"\n          ],\n          \"return_type\": \"intptr_t\",\n          \"logic\": \"Internal function call implementation.\"\n        },\n        {\n          \"name\": \"Format\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"const char* format\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints an error message and stops execution for unsupported instructions.\"\n        },\n        {\n          \"name\": \"CarryFrom\",\n          \"parameters\": [\n            \"int32_t left\",\n            \"int32_t right\",\n            \"int32_t carry\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a carry occurs during addition.\"\n        },\n        {\n          \"name\": \"BorrowFrom\",\n          \"parameters\": [\n            \"int32_t left\",\n            \"int32_t right\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a borrow occurs during subtraction.\"\n        },\n        {\n          \"name\": \"OverflowFromSigned\",\n          \"parameters\": [\n            \"T1 alu_out\",\n            \"T1 left\",\n            \"T1 right\",\n            \"bool addition\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks for overflow in signed arithmetic.\"\n        },\n        {\n          \"name\": \"GetShiftRm\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"bool* carry_out\"\n          ],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Gets the shift amount from the Rm field in the instruction.\"\n        },\n        {\n          \"name\": \"GetImm\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"bool* carry_out\"\n          ],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Gets the immediate value from the instruction.\"\n        },\n        {\n          \"name\": \"ProcessPUW\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"int num_regs\",\n            \"int operand_size\",\n            \"intptr_t* start_address\",\n            \"intptr_t* end_address\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Processes the Push/Pop Multiple with Writeback (PUW) instruction.\"\n        },\n        {\n          \"name\": \"HandleRList\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"bool load\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Handles RList instructions (Load/Store Multiple). \"\n        },\n        {\n          \"name\": \"HandleVList\",\n          \"parameters\": [\n            \"Instruction* inst\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Handles VList instructions.\"\n        },\n        {\n          \"name\": \"SoftwareInterrupt\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Handles software interrupt instructions.\"\n        },\n        {\n          \"name\": \"DebugAtNextPC\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a breakpoint at the next PC.\"\n        },\n        {\n          \"name\": \"isStopInstruction\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the instruction is a stop instruction.\"\n        },\n        {\n          \"name\": \"isWatchedStop\",\n          \"parameters\": [\n            \"uint32_t bkpt_code\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the given breakpoint code refers to a watched stop instruction.\"\n        },\n        {\n          \"name\": \"isEnabledStop\",\n          \"parameters\": [\n            \"uint32_t bkpt_code\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a watched stop is enabled.\"\n        },\n        {\n          \"name\": \"EnableStop\",\n          \"parameters\": [\n            \"uint32_t bkpt_code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Enables a watched stop.\"\n        },\n        {\n          \"name\": \"DisableStop\",\n          \"parameters\": [\n            \"uint32_t bkpt_code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Disables a watched stop.\"\n        },\n        {\n          \"name\": \"IncreaseStopCounter\",\n          \"parameters\": [\n            \"uint32_t bkpt_code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Increases the counter for a watched stop.\"\n        },\n        {\n          \"name\": \"PrintStopInfo\",\n          \"parameters\": [\n            \"uint32_t code\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints information about a stop instruction.\"\n        },\n        {\n          \"name\": \"ReadBU\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"uint8_t\",\n          \"logic\": \"Reads an unsigned byte from memory.\"\n        },\n        {\n          \"name\": \"ReadB\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"int8_t\",\n          \"logic\": \"Reads a signed byte from memory.\"\n        },\n        {\n          \"name\": \"WriteB\",\n          \"parameters\": [\n            \"intptr_t addr\",\n            \"uint8_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes an unsigned byte to memory.\"\n        },\n        {\n          \"name\": \"WriteB\",\n          \"parameters\": [\n            \"intptr_t addr\",\n            \"int8_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes a signed byte to memory.\"\n        },\n        {\n          \"name\": \"ReadHU\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"uint16_t\",\n          \"logic\": \"Reads an unsigned half-word (2 bytes) from memory.\"\n        },\n        {\n          \"name\": \"ReadH\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"int16_t\",\n          \"logic\": \"Reads a signed half-word (2 bytes) from memory.\"\n        },\n        {\n          \"name\": \"WriteH\",\n          \"parameters\": [\n            \"intptr_t addr\",\n            \"uint16_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes an unsigned half-word (2 bytes) to memory.\"\n        },\n        {\n          \"name\": \"WriteH\",\n          \"parameters\": [\n            \"intptr_t addr\",\n            \"int16_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes a signed half-word (2 bytes) to memory.\"\n        },\n        {\n          \"name\": \"ReadWU\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"uint32_t\",\n          \"logic\": \"Reads an unsigned word (4 bytes) from memory.\"\n        },\n        {\n          \"name\": \"ReadW\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Reads a signed word (4 bytes) from memory.\"\n        },\n        {\n          \"name\": \"ReadW64\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"int64_t\",\n          \"logic\": \"Reads a 64-bit word (8 bytes) from memory.\"\n        },\n        {\n          \"name\": \"WriteW\",\n          \"parameters\": [\n            \"intptr_t addr\",\n            \"uint32_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes an unsigned word (4 bytes) to memory.\"\n        },\n        {\n          \"name\": \"WriteW\",\n          \"parameters\": [\n            \"intptr_t addr\",\n            \"int32_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes a signed word (4 bytes) to memory.\"\n        },\n        {\n          \"name\": \"ReadDW\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"int64_t\",\n          \"logic\": \"Reads a double word (8 bytes) from memory.\"\n        },\n        {\n          \"name\": \"ReadDouble\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"double\",\n          \"logic\": \"Reads a double-precision floating-point value from memory.\"\n        },\n        {\n          \"name\": \"ReadFloat\",\n          \"parameters\": [\n            \"intptr_t addr\"\n          ],\n          \"return_type\": \"float\",\n          \"logic\": \"Reads a single-precision floating-point value from memory.\"\n        },\n        {\n          \"name\": \"WriteDW\",\n          \"parameters\": [\n            \"intptr_t addr\",\n            \"int64_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Writes a double word (8 bytes) to memory.\"\n        },\n        {\n          \"name\": \"Trace\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Traces the execution of an instruction.\"\n        },\n        {\n          \"name\": \"SetS390ConditionCode\",\n          \"parameters\": [\n            \"T lhs\",\n            \"T rhs\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the condition code based on the comparison of two values.\"\n        },\n        {\n          \"name\": \"SetS390ConditionCodeCarry\",\n          \"parameters\": [\n            \"T result\",\n            \"bool overflow\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the condition code for instructions using carry.\"\n        },\n        {\n          \"name\": \"isNaN\",\n          \"parameters\": [\n            \"double value\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if a double value is NaN.\"\n        },\n        {\n          \"name\": \"SetS390BitWiseConditionCode\",\n          \"parameters\": [\n            \"T value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the S390 condition code for bitwise operations.\"\n        },\n        {\n          \"name\": \"SetS390OverflowCode\",\n          \"parameters\": [\n            \"bool isOF\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the overflow condition code for S390.\"\n        },\n        {\n          \"name\": \"TestConditionCode\",\n          \"parameters\": [\n            \"Condition mask\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Tests the condition code against a given mask.\"\n        },\n        {\n          \"name\": \"ExecuteInstruction\",\n          \"parameters\": [\n            \"Instruction* instr\",\n            \"bool auto_incr_pc\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Executes a single S390 instruction.\"\n        },\n        {\n          \"name\": \"CheckICache\",\n          \"parameters\": [\n            \"base::CustomMatcherHashMap* i_cache\",\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Checks the instruction cache for a given instruction.\"\n        },\n        {\n          \"name\": \"FlushOnePage\",\n          \"parameters\": [\n            \"base::CustomMatcherHashMap* i_cache\",\n            \"intptr_t start\",\n            \"int size\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Flushes one page from the instruction cache.\"\n        },\n        {\n          \"name\": \"GetCachePage\",\n          \"parameters\": [\n            \"base::CustomMatcherHashMap* i_cache\",\n            \"void* page\"\n          ],\n          \"return_type\": \"CachePage*\",\n          \"logic\": \"Gets a cache page from the instruction cache.\"\n        },\n        {\n          \"name\": \"GetFpArgs\",\n          \"parameters\": [\n            \"double* x\",\n            \"double* y\",\n            \"intptr_t* z\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Retrieves floating-point arguments for runtime functions.\"\n        },\n        {\n          \"name\": \"SetFpResult\",\n          \"parameters\": [\n            \"const double& result\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the floating-point result of a runtime function call.\"\n        },\n        {\n          \"name\": \"TrashCallerSaveRegisters\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Overwrites the caller-saved registers\"\n        },\n        {\n          \"name\": \"CallInternal\",\n          \"parameters\": [\n            \"Address entry\",\n            \"int reg_arg_count\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Internal function to call the C entry\"\n        },\n        {\n          \"name\": \"get_simd_register\",\n          \"parameters\": [\n            \"int reg\"\n          ],\n          \"return_type\": \"fpr_t\",\n          \"logic\": \"Returns the SIMD register at the given index\"\n        },\n        {\n          \"name\": \"set_simd_register\",\n          \"parameters\": [\n            \"int reg\",\n            \"const fpr_t& value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the SIMD register at the given index with the given value\"\n        },\n        {\n          \"name\": \"get_simd_register_by_lane\",\n          \"parameters\": [\n            \"int reg\",\n            \"int lane\",\n            \"bool force_ibm_lane_numbering\"\n          ],\n          \"return_type\": \"T\",\n          \"logic\": \"Gets a specific lane of a SIMD register, reversing the lane number for IBM architectures.\"\n        },\n        {\n          \"name\": \"set_simd_register_by_lane\",\n          \"parameters\": [\n            \"int reg\",\n            \"int lane\",\n            \"const T& value\",\n            \"bool force_ibm_lane_numbering\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets a specific lane of a SIMD register, reversing the lane number for IBM architectures.\"\n        },\n        {\n          \"name\": \"DebugStart\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Starts the debugging process.\"\n        },\n        {\n          \"name\": \"DecodeInstructionOriginal\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Decodes an instruction (original decoding method).\"\n        },\n        {\n          \"name\": \"DecodeInstruction\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Decodes an instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_Unknown\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Handles unknown instructions.\"\n        },\n        {\n          \"name\": \"Evaluate_DUMY\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates DUMY Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_BKPT\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates BKPT Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_SPM\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates SPM Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_BALR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates BALR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_BCTR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates BCTR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_BCR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates BCR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_SVC\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates SVC Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_BSM\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates BSM Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_BASSM\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates BASSM Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_BASR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates BASR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_MVCL\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates MVCL Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_CLCL\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates CLCL Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_LPR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates LPR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_LNR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates LNR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_LTR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates LTR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_LCR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates LCR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_NR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates NR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_CLR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates CLR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_OR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates OR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_XR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates XR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_LR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates LR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_CR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates CR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_AR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates AR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_SR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates SR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_MR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates MR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_DR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates DR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_ALR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates ALR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_SLR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates SLR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_LDR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates LDR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_CDR\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates CDR Instruction.\"\n        },\n        {\n          \"name\": \"Evaluate_LER\",\n          \"parameters\": [\n            \"Instruction* instr\"\n          ],\n          \"return_type\": \"int\",\n          \"logic\": \"Evaluates LER Instruction.\"\n        },\n"
}