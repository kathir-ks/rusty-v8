{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/torque/torque-parser.cc",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/torque/torque-parser.cc\",\n  \"imports\": [\n    \"<algorithm>\",\n    \"<cctype>\",\n    \"<optional>\",\n    \"<set>\",\n    \"<stdexcept>\",\n    \"<unordered_map>\",\n    \"include/v8config.h\",\n    \"src/common/globals.h\",\n    \"src/flags/flags.h\",\n    \"src/torque/ast.h\",\n    \"src/torque/constants.h\",\n    \"src/torque/declarations.h\",\n    \"src/torque/earley-parser.h\",\n    \"src/torque/global-context.h\",\n    \"src/torque/utils.h\",\n    \"src/torque/torque-parser.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"BuildFlags\",\n      \"properties\": [\n        \"build_flags_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"BuildFlags\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that initializes the build_flags_ map with various V8 configuration options and feature flags.\"\n        },\n        {\n          \"name\": \"GetFlag\",\n          \"parameters\": [\n            \"const std::string& name\",\n            \"const char* production\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Retrieves the value of a build flag from the build_flags_ map. Reports an error if the flag is unknown.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AnnotationSet\",\n      \"properties\": [\n        \"set_\",\n        \"map_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"AnnotationSet\",\n          \"parameters\": [\n            \"ParseResultIterator* iter\",\n            \"const std::set<std::string>& allowed_without_param\",\n            \"const std::set<std::string>& allowed_with_param\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that parses a list of annotations from a ParseResultIterator, validating them based on provided allowed annotation lists and storing them into internal sets and maps.\"\n        },\n        {\n          \"name\": \"Contains\",\n          \"parameters\": [\n            \"const std::string& s\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if an annotation with the given name is present in the set_.\"\n        },\n        {\n          \"name\": \"GetStringParam\",\n          \"parameters\": [\n            \"const std::string& s\"\n          ],\n          \"return_type\": \"std::optional<std::string>\",\n          \"logic\": \"Retrieves the string parameter associated with a given annotation name from the map_. Returns an empty optional if the annotation is not found or the parameter type is incorrect.\"\n        },\n        {\n          \"name\": \"GetIntParam\",\n          \"parameters\": [\n            \"const std::string& s\"\n          ],\n          \"return_type\": \"std::optional<int32_t>\",\n          \"logic\": \"Retrieves the int parameter associated with a given annotation name from the map_. Returns an empty optional if the annotation is not found or the parameter type is incorrect.\"\n        }\n      ]\n    }\n  ],\n  \"functions\": [\n    {\n      \"name\": \"AddGlobalDeclarations\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Retrieves a list of declarations from the ParseResultIterator and adds them to the global declarations list in CurrentAst.\"\n    },\n    {\n      \"name\": \"NamingConventionError\",\n      \"parameters\": [\n        \"const std::string& type\",\n        \"const std::string& name\",\n        \"const std::string& convention\",\n        \"SourcePosition pos\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Reports a linting error when a name does not follow a specified naming convention.\"\n    },\n    {\n      \"name\": \"NamingConventionError\",\n      \"parameters\": [\n        \"const std::string& type\",\n        \"const Identifier* name\",\n        \"const std::string& convention\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Overload of NamingConventionError that takes an Identifier* as input.\"\n    },\n    {\n      \"name\": \"LintGenericParameters\",\n      \"parameters\": [\n        \"const GenericParameters& parameters\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Lints the provided GenericParameters, checking naming conventions of generic parameters.\"\n    },\n    {\n      \"name\": \"ConcatList\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Concatenates a list of declaration lists into a single list of declarations.\"\n    },\n    {\n      \"name\": \"CheckNotDeferredStatement\",\n      \"parameters\": [\n        \"Statement* statement\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Checks if a given statement is a deferred BlockStatement and reports a linting error if so, since it will have no effect in that context.\"\n    },\n    {\n      \"name\": \"AddConstexpr\",\n      \"parameters\": [\n        \"TypeExpression* type\"\n      ],\n      \"return_type\": \"TypeExpression*\",\n      \"logic\": \"Adds the constexpr prefix to a given BasicTypeExpression, creating a new TypeExpression representing the constexpr version of the type.\"\n    },\n    {\n      \"name\": \"MakeCall\",\n      \"parameters\": [\n        \"IdentifierExpression* callee\",\n        \"std::optional<Expression*> target\",\n        \"std::vector<Expression*> arguments\",\n        \"const std::vector<Statement*>& otherwise\"\n      ],\n      \"return_type\": \"Expression*\",\n      \"logic\": \"Constructs a CallExpression or CallMethodExpression depending on the presence of a target and handles the otherwise statements by creating temporary labels and try-label blocks.\"\n    },\n    {\n      \"name\": \"MakeCall\",\n      \"parameters\": [\n        \"Identifier* callee\",\n        \"const std::vector<TypeExpression*>& generic_arguments\",\n        \"const std::vector<Expression*>& arguments\",\n        \"const std::vector<Statement*>& otherwise\"\n      ],\n      \"return_type\": \"Expression*\",\n      \"logic\": \"Overload of MakeCall that takes an Identifier* and generic arguments.\"\n    },\n    {\n      \"name\": \"MakeCall\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Retrieves callee, arguments, and otherwise statements from ParseResultIterator and creates a CallExpression.\"\n    },\n    {\n      \"name\": \"MakeMethodCall\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Retrieves the 'this' argument, callee, arguments, and otherwise statements from the ParseResultIterator and creates a CallMethodExpression.\"\n    },\n    {\n      \"name\": \"MakeNewExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a NewExpression with pretenuring, clear padding, type, and initializers.\"\n    },\n    {\n      \"name\": \"MakeBinaryOperator\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates a call to a binary operator function based on left and right expressions and an operator identifier.\"\n    },\n    {\n      \"name\": \"MakeIntrinsicCallExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs an IntrinsicCallExpression from callee, generic arguments, and arguments.\"\n    },\n    {\n      \"name\": \"MakeUnaryOperator\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates a call to a unary operator function based on the operator identifier and an expression.\"\n    },\n    {\n      \"name\": \"MakeSpreadExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates a SpreadExpression from an expression.\"\n    },\n    {\n      \"name\": \"MakeImplicitParameterList\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs an ImplicitParameters structure from a kind identifier and a list of name and type expressions.\"\n    },\n    {\n      \"name\": \"AddParameter\",\n      \"parameters\": [\n        \"ParameterList* parameter_list\",\n        \"const NameAndTypeExpression& param\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Adds a parameter (name and type) to a given ParameterList. Reports an error if naming conventions are violated.\"\n    },\n    {\n      \"name\": \"MakeParameterList\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a ParameterList from implicit and explicit parameters, taking into account varargs and whether explicit parameter names are available.\"\n    },\n    {\n      \"name\": \"MakeAssertStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs an AssertStatement based on kind (dcheck, check, etc.) and an expression with its source code.\"\n    },\n    {\n      \"name\": \"MakeDebugStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a DebugStatement for unreachable code or general debugging.\"\n    },\n    {\n      \"name\": \"DeprecatedMakeVoidType\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Reports an error that default void return types are deprecated. Constructs a BasicTypeExpression for void.\"\n    },\n    {\n      \"name\": \"MakeExternalMacro\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs an ExternalMacroDeclaration based on annotations, transitioning, operator name, external assembler name, name, generic parameters, arguments, return type, and labels. Returns a list containing the declaration.\"\n    },\n    {\n      \"name\": \"MakeIntrinsicDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs an IntrinsicDeclaration or TorqueMacroDeclaration based on name, generic parameters, arguments, return type, and an optional body.\"\n    },\n    {\n      \"name\": \"HasAnnotation\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\",\n        \"const char* annotation\",\n        \"const char* declaration\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Checks whether an annotation is present within the ParseResultIterator's annotations. It also enforces that if the annotation exists only a single one is allowed.\"\n    },\n    {\n      \"name\": \"HasExportAnnotation\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\",\n        \"const char* declaration\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Helper function to check for an export annotation.\"\n    },\n    {\n      \"name\": \"ProcessIfAnnotation\",\n      \"parameters\": [\n        \"const AnnotationSet& annotations\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Processes the @if and @ifnot annotations and checks the current build flags against the conditions provided in the annotation. Returns false if any @if/ @ifnot conditions aren't satisfied.\"\n    },\n    {\n      \"name\": \"ProcessIfAnnotation\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"bool\",\n      \"logic\": \"Processes the @if and @ifnot annotations and checks the current build flags against the conditions provided in the annotation. Returns false if any @if/ @ifnot conditions aren't satisfied.\"\n    },\n    {\n      \"name\": \"MakeTorqueMacroDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a TorqueMacroDeclaration based on annotations, transitioning, operator name, name, generic parameters, arguments, return type, labels, and body. Creates GenericCallableDeclaration when the Macro is generic.\"\n    },\n    {\n      \"name\": \"MakeConstDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a ConstDeclaration based on name, type and expression, only if enabled with an annotation. Returns a list containing the declaration.\"\n    },\n    {\n      \"name\": \"MakeExternConstDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs an ExternConstDeclaration based on name, type and literal.\"\n    },\n    {\n      \"name\": \"MakeTypeAliasDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a TypeAliasDeclaration based on name and type only if enabled by an annotation. Returns a list containing the declaration.\"\n    },\n    {\n      \"name\": \"MakeAbstractTypeDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs an AbstractTypeDeclaration based on annotations, transient, name, generic parameters, extends, and generates. Creates a GenericTypeDeclaration if type is generic. Also handles generation of associated constexpr version of the type declaration.\"\n    },\n    {\n      \"name\": \"MakeMethodDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a TorqueMacroDeclaration to be treated as a method. The constructed macro declaration is based on transitioning, operator_name, name, args, return_type, labels, and body. Does not create GenericCallableDeclaration as methods cannot be generic in this case.\"\n    },\n    {\n      \"name\": \"YieldInt32\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Parses a string representation of an integer from the matched input and returns an int32_t.\"\n    },\n    {\n      \"name\": \"YieldDouble\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Parses a string representation of a double from the matched input and returns a double.\"\n    },\n    {\n      \"name\": \"YieldIntegerLiteral\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Parses a string representation of an integer literal (allowing for negatives and various bases) and returns an IntegerLiteral.\"\n    },\n    {\n      \"name\": \"MakeStringAnnotationParameter\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates an AnnotationParameter with a string value from the ParseResultIterator.\"\n    },\n    {\n      \"name\": \"MakeIntAnnotationParameter\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates an AnnotationParameter with an integer value from the ParseResultIterator.\"\n    },\n    {\n      \"name\": \"GetAnnotationValue\",\n      \"parameters\": [\n        \"const AnnotationSet& annotations\",\n        \"const char* name\",\n        \"int default_value\"\n      ],\n      \"return_type\": \"int\",\n      \"logic\": \"Tries to retrieve an integer value from an AnnotationSet for a given annotation name. Returns the specified default_value if the annotation is not found.\"\n    },\n    {\n      \"name\": \"MakeTorqueBuiltinDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a TorqueBuiltinDeclaration from provided elements, generic parameters etc. Adds a GenericCallableDeclaration if builtin is generic\"\n    },\n    {\n      \"name\": \"MakeInstanceTypeConstraints\",\n      \"parameters\": [\n        \"const AnnotationSet& annotations\"\n      ],\n      \"return_type\": \"InstanceTypeConstraints\",\n      \"logic\": \"Retrieves InstanceType constraints from the Annotation set\"\n    },\n    {\n      \"name\": \"MakeClassBody\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates a ClassBody containing methods and fields taken from child_results.\"\n    },\n    {\n      \"name\": \"MakeClassDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a ClassDeclaration with various flags and constraints extracted from annotations and child results, including extern/transient specifiers. Additionally, handles the constexpr type generation for the class.\"\n    },\n    {\n      \"name\": \"MakeNamespaceDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a NamespaceDeclaration with given name and a list of declarations.\"\n    },\n    {\n      \"name\": \"MakeSpecializationDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a SpecializationDeclaration with provided properties.\"\n    },\n    {\n      \"name\": \"MakeStructDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs StructDeclaration given a name, generic parameters and methods.\"\n    },\n    {\n      \"name\": \"MakeBitFieldStructDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a BitFieldStructDeclaration based on the given components.\"\n    },\n    {\n      \"name\": \"MakeCppIncludeDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a CppIncludeDeclaration based on the provided include path.\"\n    },\n    {\n      \"name\": \"ProcessTorqueImportDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Declares the source id of the imported file for the current file.\"\n    },\n    {\n      \"name\": \"MakeExternalBuiltin\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a ExternalBuiltinDeclaration based on transitioning, javascript_linkage, name, arguments and return type.\"\n    },\n    {\n      \"name\": \"MakeExternalRuntime\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a ExternalRuntimeDeclaration based on transitioning, name, arguments and return type.\"\n    },\n    {\n      \"name\": \"StringLiteralUnquoteAction\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Unquotes the string literal captured in Torque.\"\n    },\n    {\n      \"name\": \"MakeBasicTypeExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a BasicTypeExpression using provided parameters.\"\n    },\n    {\n      \"name\": \"MakeFunctionTypeExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a FunctionTypeExpression based on the provided parameters and return type.\"\n    },\n    {\n      \"name\": \"MakeReferenceTypeExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a BasicTypeExpression for a reference type (mutable or const) wrapping the referenced type.\"\n    },\n    {\n      \"name\": \"MakeUnionTypeExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a UnionTypeExpression based on type A and type B.\"\n    },\n    {\n      \"name\": \"MakeGenericParameter\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a GenericParameter based on the given name and the optional constraint.\"\n    },\n    {\n      \"name\": \"MakeExpressionStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs an ExpressionStatement given an Expression.\"\n    },\n    {\n      \"name\": \"MakeIfStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs an IfStatement with conditional, ifTrue, and ifFalse branches.\"\n    },\n    {\n      \"name\": \"MakeEnumDeclaration\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a EnumDeclaration. Creates non-constexpr and constexpr types, and namespace const externs entries.\"\n    },\n    {\n      \"name\": \"MakeTypeswitchStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Desugars a typeswitch statement to nested try-label blocks to implement type-based dispatch.\"\n    },\n    {\n      \"name\": \"MakeTypeswitchCase\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a TypeswitchCase structure from its name, type, and block.\"\n    },\n    {\n      \"name\": \"MakeWhileStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a WhileStatement with given condition and body.\"\n    },\n    {\n      \"name\": \"MakeReturnStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a ReturnStatement with an optional return value.\"\n    },\n    {\n      \"name\": \"MakeTailCallStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a TailCallStatement with a specified CallExpression.\"\n    },\n    {\n      \"name\": \"MakeVarDeclarationStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a VarDeclarationStatement with const/let specifier, name, optional type, and optional initializer.\"\n    },\n    {\n      \"name\": \"MakeBreakStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a BreakStatement.\"\n    },\n    {\n      \"name\": \"MakeContinueStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a ContinueStatement.\"\n    },\n    {\n      \"name\": \"MakeGotoStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a GotoStatement to a particular label.\"\n    },\n    {\n      \"name\": \"MakeBlockStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a BlockStatement with an optional 'deferred' modifier, which defines an ordered list of statements\"\n    },\n    {\n      \"name\": \"MakeTryLabelExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a TryLabelExpression, implementing label and catch try_blocks, by nesting them inside a TryHandler.\"\n    },\n    {\n      \"name\": \"MakeForLoopStatement\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates a ForLoopStatement, based on initializer/variable declaration, test condition, action and a body.\"\n    },\n    {\n      \"name\": \"MakeLabelBlock\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates label to support goto operation in Torque\"\n    },\n    {\n      \"name\": \"MakeCatchBlock\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates a Catch block\"\n    },\n    {\n      \"name\": \"MakeExpressionWithSource\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates ExpressionWithSource from a parsed Expression, saving matched expression in source field\"\n    },\n    {\n      \"name\": \"MakeIdentifier\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates an identifier, based on provided parsed identifier name\"\n    },\n    {\n      \"name\": \"MakeIdentifierFromMatchedInput\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates an Identifier, based on the matched input in parser\"\n    },\n    {\n      \"name\": \"MakeRightShiftIdentifier\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates a Identifier, where matched input is validated as a right-shift\"\n    },\n    {\n      \"name\": \"MakeNamespaceQualification\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates a vector of qualified namespaces.\"\n    },\n    {\n      \"name\": \"MakeIdentifierExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs IdentifierExpression given a name space qualified name.\"\n    },\n    {\n      \"name\": \"MakeFieldAccessExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a field access expression given an object and a field.\"\n    },\n    {\n      \"name\": \"MakeReferenceFieldAccessExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a field access expression via a reference: transform a->b into (*a).b\"\n    },\n    {\n      \"name\": \"MakeElementAccessExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a element access expression.\"\n    },\n    {\n      \"name\": \"MakeDereferenceExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a Deference Expression\"\n    },\n    {\n      \"name\": \"MakeStructExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a StructExpression from its name and initializer.\"\n    },\n    {\n      \"name\": \"MakeAssignmentExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Creates an assignment expression based on an location, an optional operator and a expression\"\n    },\n    {\n      \"name\": \"MakeFloatingPointLiteralExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a FloatingPointLiteralExpression based on the given value.\"\n    },\n    {\n      \"name\": \"MakeIntegerLiteralExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a IntegerLiteralExpression based on IntegerLiteral parameter.\"\n    },\n    {\n      \"name\": \"MakeStringLiteralExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a StringLiteralExpression based on provided parsed string.\"\n    },\n    {\n      \"name\": \"MakeIncrementDecrementExpressionPostfix\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Makes an increment-decrement expression. This will be a postfix operator.\"\n    },\n    {\n      \"name\": \"MakeIncrementDecrementExpressionPrefix\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Makes an increment-decrement expression. This will be a prefix operator.\"\n    },\n    {\n      \"name\": \"MakeLogicalOrExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a logical-or expression\"\n    },\n    {\n      \"name\": \"MakeLogicalAndExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a logical-and expression\"\n    },\n    {\n      \"name\": \"MakeConditionalExpression\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs a conditional expression based on condition, ifTrue, and ifFalse expressions.\"\n    },\n    {\n      \"name\": \"MakeLabelAndTypes\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs LabelAndTypes given the Identifier name and vector of type_expressions\"\n    },\n    {\n      \"name\": \"MakeNameAndType\",\n      \"parameters\": [\n        \"ParseResultIterator* child_results\"\n      ],\n      \"return_type\": \"std::optional<ParseResult>\",\n      \"logic\": \"Constructs NameAndType given the Identifier name and type_expression\"\n    },\n    {"
}