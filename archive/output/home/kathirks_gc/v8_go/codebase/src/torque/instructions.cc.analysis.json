{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/torque/instructions.cc",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/torque/instructions.cc\",\n  \"imports\": [\n    \"src/torque/instructions.h\",\n    \"<optional>\",\n    \"src/torque/cfg.h\",\n    \"src/torque/type-oracle.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"InstructionBase\",\n      \"properties\": [\n        \"pos\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"InvalidateTransientTypes\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Iterates through the stack and if a type is transient, it invalidates it by replacing it with a TopType, including the position of the current instruction in the reason.\"\n        },\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Virtual function determining if an instruction ends a block of code. The base InstructionBase always return false, the function is redefined at the CallRuntimeInstruction.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PeekInstruction\",\n      \"properties\": [\n        \"slot\",\n        \"widened_type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Peeks a type from the stack at a specific slot. If widened_type is present it expects that the peeked type is a subtype. Then it pushes the type (widened if present) on the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Peeks a DefinitionLocation from the stack at the specified slot and pushes it back onto the stack.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PokeInstruction\",\n      \"properties\": [\n        \"slot\",\n        \"widened_type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops a type from the stack. If widened_type is present it expects that the popped type is a subtype. Then it pokes the type (widened if present) into the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops a DefinitionLocation from the stack and pokes it back into the stack at a specified slot.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"DeleteRangeInstruction\",\n      \"properties\": [\n        \"range\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Deletes a range of types from the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Deletes a range of DefinitionLocations from the stack.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PushUninitializedInstruction\",\n      \"properties\": [\n        \"type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pushes a specified type onto the stack (representing an uninitialized value).\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pushes the DefinitionLocation associated with this instruction onto the stack.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns a DefinitionLocation object that represents the definition of the value pushed by this instruction.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PushBuiltinPointerInstruction\",\n      \"properties\": [\n        \"type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pushes a specified type onto the stack (representing a builtin pointer).\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pushes the DefinitionLocation associated with this instruction onto the stack.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns a DefinitionLocation object that represents the definition of the value pushed by this instruction.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"NamespaceConstantInstruction\",\n      \"properties\": [\n        \"constant\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pushes multiple types onto the stack, based on the lowered type of the constant.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pushes multiple definition locations onto the stack, one for each type produced by LowerType.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the number of values defined by this instruction (equal to the size of the lowered type).\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns a DefinitionLocation object for the given index, representing a specific lowered type of the constant.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallIntrinsicInstruction\",\n      \"properties\": [\n        \"intrinsic\",\n        \"specialization_types\",\n        \"constexpr_arguments\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops argument types from the stack based on the intrinsic's parameter types, checks if they match the expected types, invalidates transient types if the intrinsic is transitioning, and pushes the intrinsic's return type onto the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops DefinitionLocations for the parameters and pushes new DefinitionLocations for the return values produced by the instruction.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the number of values defined by this instruction (equal to the size of the lowered return type).\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation object at the provided index.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallCsaMacroInstruction\",\n      \"properties\": [\n        \"macro\",\n        \"constexpr_arguments\",\n        \"catch_block\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops argument types from the stack based on the macro's parameter types, checks if they match, invalidates transient types if the macro is transitioning, sets the catch block input type if present, and pushes the macro's return type onto the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops DefinitionLocations for parameters and pushes the return value DefinitionLocations. Handles the definition location for the exception object in the catch block if present.\"\n        },\n        {\n          \"name\": \"GetExceptionObjectDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<DefinitionLocation>\",\n          \"logic\": \"Returns the DefinitionLocation of the exception object, or std::nullopt if there is no catch block.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the number of values defined by this instruction based on the size of the lowered type.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation object at a specified index.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallCsaMacroAndBranchInstruction\",\n      \"properties\": [\n        \"macro\",\n        \"constexpr_arguments\",\n        \"return_continuation\",\n        \"label_blocks\",\n        \"catch_block\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops parameters from the stack, type checks them, sets the input types for the continuation blocks (labels, return, catch). Invalidates transient types if the macro is transitioning.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops locations for the parameters. Pushes locations for the labels and the return continuation and catch block. Merges input definitions for the continuations and catch blocks.\"\n        },\n        {\n          \"name\": \"GetLabelCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the number of label blocks associated with this instruction.\"\n        },\n        {\n          \"name\": \"GetLabelValueDefinitionCount\",\n          \"parameters\": [\n            \"std::size_t label\"\n          ],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the number of values defined by the specified label (the number of types in the label's signature).\"\n        },\n        {\n          \"name\": \"GetLabelValueDefinition\",\n          \"parameters\": [\n            \"std::size_t label\",\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation for a value defined by the specified label at the given index.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the number of values defined by this instruction, based on the size of the lowered return type.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation object at a specified index.\"\n        },\n        {\n          \"name\": \"GetExceptionObjectDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<DefinitionLocation>\",\n          \"logic\": \"Returns an optional DefinitionLocation for the exception object if the instruction has a catch block; otherwise, returns std::nullopt.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallBuiltinInstruction\",\n      \"properties\": [\n        \"builtin\",\n        \"argc\",\n        \"is_tailcall\",\n        \"catch_block\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops argument types from the stack, checks if they match the expected types from the builtin signature, invalidates transient types if builtin is transitioning, sets the catch block input type if present, and pushes the builtin's return type onto the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops DefinitionLocations for the arguments, merges input defs for catch, and pushes new DefinitionLocations for the return values produced by the instruction.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the number of values defined by this instruction.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation object at the given index.\"\n        },\n        {\n          \"name\": \"GetExceptionObjectDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<DefinitionLocation>\",\n          \"logic\": \"Returns the definition location of the exception object, if a catch block is present.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallBuiltinPointerInstruction\",\n      \"properties\": [\n        \"type\",\n        \"argc\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the argument types and the function pointer type from the stack, type checks arguments based on the function pointer's signature, invalidates transient types, and pushes the return type of the function pointer onto the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops DefinitionLocations for arguments and the function pointer. Pushes new locations for return values.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the number of values defined by this instruction (the number of types in the function pointer's lowered return type).\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the definition location at the given index.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CallRuntimeInstruction\",\n      \"properties\": [\n        \"runtime_function\",\n        \"argc\",\n        \"is_tailcall\",\n        \"catch_block\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops arguments, type checks them, invalidates transient types if the runtime function is transitioning, sets catch block input type if present, and pushes the return type onto the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops definitions for the arguments and pushes locations for the return values. Handles definitions for the exception object.\"\n        },\n        {\n          \"name\": \"GetValueDefinitionCount\",\n          \"parameters\": [],\n          \"return_type\": \"std::size_t\",\n          \"logic\": \"Returns the number of values defined by this instruction.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [\n            \"std::size_t index\"\n          ],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation object at the given index.\"\n        },\n        {\n          \"name\": \"GetExceptionObjectDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"std::optional<DefinitionLocation>\",\n          \"logic\": \"Returns an optional DefinitionLocation for the exception object if the instruction has a catch block; otherwise, returns std::nullopt.\"\n        },\n        {\n          \"name\": \"IsBlockTerminator\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the CallRuntimeInstruction terminates the block because it is either a tailcall or never returns.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"BranchInstruction\",\n      \"properties\": [\n        \"if_true\",\n        \"if_false\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the condition from the stack and checks if it is a boolean. Then sets the input types of the if_true and if_false blocks using the current stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the DefinitionLocation for the condition. Merges the definition locations to the if_true and if_false destination blocks.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ConstexprBranchInstruction\",\n      \"properties\": [\n        \"condition\",\n        \"if_true\",\n        \"if_false\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the input types of the if_true and if_false blocks using the current stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Merges the definition locations to the if_true and if_false destination blocks.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"GotoInstruction\",\n      \"properties\": [\n        \"destination\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the input types of the destination block using the current stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Merges the definition locations to the destination block.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"GotoExternalInstruction\",\n      \"properties\": [\n        \"variable_names\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Validates that the stack size matches the number of variable names associated with the external label.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Does nothing as external gotos have no definition location information\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ReturnInstruction\",\n      \"properties\": [\n        \"count\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops a specified number of values from the stack and sets them as the return type for the control flow graph.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops a specified number of DefinitionLocations from the stack.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PrintErrorInstruction\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Does nothing to the stack, just prints an error message.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Does nothing to the definition locations.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AbortInstruction\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Does nothing to the stack, just aborts execution.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Does nothing to the definition locations.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"UnsafeCastInstruction\",\n      \"properties\": [\n        \"destination_type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Replaces the type on the top of the stack with the destination type, without type checking.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Replaces the DefinitionLocation on top of the stack with one based on the unsafe cast instruction.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation object for this instruction.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"LoadReferenceInstruction\",\n      \"properties\": [\n        \"type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops an IntPtr and a HeapObject or TaggedZeroPattern from the stack, checks their types, and pushes the value from the reference onto the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the DefinitionLocations for the IntPtr and HeapObject/TaggedZeroPattern, and pushes the DefinitionLocation of the load result.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation for the load instruction.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"StoreReferenceInstruction\",\n      \"properties\": [\n        \"type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the value, IntPtr, and the HeapObject or TaggedZeroPattern from the stack and checks their types to store into the reference.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the DefinitionLocations for the value, IntPtr and the HeapObject or TaggedZeroPattern being stored.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"LoadBitFieldInstruction\",\n      \"properties\": [\n        \"bit_field_struct_type\",\n        \"bit_field\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the struct type containing the bitfield and pushes the type of the bitfield onto the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the DefinitionLocation of the structure and pushes the definition location of the loaded bit field.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation of the load instruction.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"StoreBitFieldInstruction\",\n      \"properties\": [\n        \"bit_field_struct_type\",\n        \"bit_field\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the bitfield value, the struct type containing the bitfield and pushes the updated struct type back onto the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops the DefinitionLocation of the bitfield and the structure and pushes the definition location of the resulting structure.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns the DefinitionLocation of the modified structure type\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MakeLazyNodeInstruction\",\n      \"properties\": [\n        \"macro\",\n        \"constexpr_arguments\",\n        \"result_type\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"TypeInstruction\",\n          \"parameters\": [\n            \"Stack<const Type*>* stack\",\n            \"ControlFlowGraph* cfg\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops argument types from the stack based on the macro's parameter types, checks if they match, and pushes the result type onto the stack.\"\n        },\n        {\n          \"name\": \"RecomputeDefinitionLocations\",\n          \"parameters\": [\n            \"Stack<DefinitionLocation>* locations\",\n            \"Worklist<Block*>* worklist\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Pops definitions for the parameters. Pushes a new definition for the LazyNode result.\"\n        },\n        {\n          \"name\": \"GetValueDefinition\",\n          \"parameters\": [],\n          \"return_type\": \"DefinitionLocation\",\n          \"logic\": \"Returns a DefinitionLocation object representing the definition of the LazyNode.\"\n        }\n      ]\n    }\n  ],\n  \"functions\": [\n    {\n      \"name\": \"ExpectType\",\n      \"parameters\": [\n        \"const Type* expected\",\n        \"const Type* actual\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Reports an error if the expected type is not the same as the actual type.\"\n    },\n    {\n      \"name\": \"ExpectSubtype\",\n      \"parameters\": [\n        \"const Type* subtype\",\n        \"const Type* supertype\"\n      ],\n      \"return_type\": \"void\",\n      \"logic\": \"Reports an error if the subtype is not a subtype of the supertype.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const NamespaceConstantInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator to print the name of the NamespaceConstantInstruction's constant.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallIntrinsicInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator to print the details of the CallIntrinsicInstruction, including name, specialization types, and constexpr arguments.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallCsaMacroInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator to print the details of the CallCsaMacroInstruction, including name, arguments, and catch block ID.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallCsaMacroAndBranchInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator to print the details of the CallCsaMacroAndBranchInstruction, including name, arguments, and IDs of the return, label, and catch blocks.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallBuiltinInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator to print the details of the CallBuiltinInstruction, including name, argument count, and flags.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const CallRuntimeInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator to print the details of the CallRuntimeInstruction, including name, argument count, and flags.\"\n    },\n    {\n      \"name\": \"operator<<\",\n      \"parameters\": [\n        \"std::ostream& os\",\n        \"const BranchInstruction& instruction\"\n      ],\n      \"return_type\": \"std::ostream&\",\n      \"logic\": \"Overloads the << operator to print the IDs of the true and"
}