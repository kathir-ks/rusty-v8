{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/compiler/backend/instruction.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/compiler/backend/instruction.h\",\n  \"imports\": [\n    \"<iosfwd>\",\n    \"<map>\",\n    \"<optional>\",\n    \"src/base/compiler-specific.h\",\n    \"src/base/numbers/double.h\",\n    \"src/codegen/external-reference.h\",\n    \"src/codegen/register.h\",\n    \"src/codegen/source-position.h\",\n    \"src/common/globals.h\",\n    \"src/compiler/backend/instruction-codes.h\",\n    \"src/compiler/common-operator.h\",\n    \"src/compiler/feedback-source.h\",\n    \"src/compiler/frame.h\",\n    \"src/compiler/opcodes.h\",\n    \"src/zone/zone-allocator.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"InstructionOperand\",\n      \"properties\": [\n        \"static const int kInvalidVirtualRegister\",\n        \"enum Kind\",\n        \"Kind kind() const\",\n        \"uint64_t value_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"InstructionOperand\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Default constructor, initializes to INVALID kind.\"\n        },\n        {\n          \"name\": \"kind\",\n          \"parameters\": [],\n          \"return_type\": \"Kind\",\n          \"logic\": \"Returns the kind of the operand.\"\n        },\n        {\n          \"name\": \"IsInvalid\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is of INVALID kind.\"\n        },\n        {\n          \"name\": \"IsUnallocated\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is of UNALLOCATED kind.\"\n        },\n        {\n          \"name\": \"IsConstant\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is of CONSTANT kind.\"\n        },\n        {\n          \"name\": \"IsImmediate\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is of IMMEDIATE kind.\"\n        },\n        {\n          \"name\": \"IsPending\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is of PENDING kind.\"\n        },\n        {\n          \"name\": \"IsAllocated\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is of ALLOCATED kind.\"\n        },\n        {\n          \"name\": \"IsAnyLocationOperand\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is any type of location (register or stack slot).\"\n        },\n        {\n          \"name\": \"IsLocationOperand\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a location (register or stack slot) and not floating point.\"\n        },\n        {\n          \"name\": \"IsFPLocationOperand\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a floating-point location (register or stack slot).\"\n        },\n        {\n          \"name\": \"IsAnyRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is any type of register.\"\n        },\n        {\n          \"name\": \"IsRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a register and not floating point.\"\n        },\n        {\n          \"name\": \"IsFPRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a floating-point register.\"\n        },\n        {\n          \"name\": \"IsFloatRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a float32 register.\"\n        },\n        {\n          \"name\": \"IsDoubleRegister\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a float64 register.\"\n        },\n        {\n          \"name\": \"IsSimd128Register\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a SIMD128 register.\"\n        },\n        {\n          \"name\": \"IsSimd256Register\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a SIMD256 register.\"\n        },\n        {\n          \"name\": \"IsAnyStackSlot\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is any type of stack slot.\"\n        },\n        {\n          \"name\": \"IsStackSlot\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a stack slot and not floating point.\"\n        },\n        {\n          \"name\": \"IsFPStackSlot\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a floating-point stack slot.\"\n        },\n        {\n          \"name\": \"IsFloatStackSlot\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a float32 stack slot.\"\n        },\n        {\n          \"name\": \"IsDoubleStackSlot\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a float64 stack slot.\"\n        },\n        {\n          \"name\": \"IsSimd128StackSlot\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a SIMD128 stack slot.\"\n        },\n        {\n          \"name\": \"IsSimd256StackSlot\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand is a SIMD256 stack slot.\"\n        },\n        {\n          \"name\": \"New\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"const SubKindOperand& op\"\n          ],\n          \"return_type\": \"SubKindOperand*\",\n          \"logic\": \"Allocates a new operand of the specified type in the given zone.\"\n        },\n        {\n          \"name\": \"ReplaceWith\",\n          \"parameters\": [\n            \"InstructionOperand* dest\",\n            \"const InstructionOperand* src\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Replaces the destination operand with a copy of the source operand.\"\n        },\n        {\n          \"name\": \"Equals\",\n          \"parameters\": [\n            \"const InstructionOperand& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two operands for equality, handling pending operands specially.\"\n        },\n        {\n          \"name\": \"Compare\",\n          \"parameters\": [\n            \"const InstructionOperand& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two operands, for use in maps.\"\n        },\n        {\n          \"name\": \"EqualsCanonicalized\",\n          \"parameters\": [\n            \"const InstructionOperand& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two operands for equality after canonicalizing them.\"\n        },\n        {\n          \"name\": \"CompareCanonicalized\",\n          \"parameters\": [\n            \"const InstructionOperand& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Compares two operands after canonicalization, for use in maps.\"\n        },\n        {\n          \"name\": \"InterferesWith\",\n          \"parameters\": [\n            \"const InstructionOperand& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Determines if two operands interfere with each other (e.g., they occupy the same register).\"\n        },\n        {\n          \"name\": \"Print\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints the operand to the console (for debugging).\"\n        },\n        {\n          \"name\": \"operator==\",\n          \"parameters\": [\n            \"const InstructionOperand& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Equality operator.\"\n        },\n        {\n          \"name\": \"operator!=\",\n          \"parameters\": [\n            \"const InstructionOperand& other\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Inequality operator.\"\n        },\n        {\n          \"name\": \"InstructionOperand\",\n          \"parameters\": [\n            \"Kind kind\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Protected constructor, initializes the operand with the given kind.\"\n        },\n        {\n          \"name\": \"GetCanonicalizedValue\",\n          \"parameters\": [],\n          \"return_type\": \"uint64_t\",\n          \"logic\": \"Returns a canonicalized value of the operand, used for comparing registers ignoring their original MachineType when they alias.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"UnallocatedOperand\",\n      \"properties\": [\n        \"enum BasicPolicy\",\n        \"enum ExtendedPolicy\",\n        \"enum Lifetime\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"UnallocatedOperand\",\n          \"parameters\": [\n            \"ExtendedPolicy policy\",\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for extended policies with default lifetime.\"\n        },\n        {\n          \"name\": \"UnallocatedOperand\",\n          \"parameters\": [\n            \"int virtual_register\",\n            \"int input_index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for SAME_AS_INPUT policy.\"\n        },\n        {\n          \"name\": \"UnallocatedOperand\",\n          \"parameters\": [\n            \"BasicPolicy policy\",\n            \"int index\",\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for FIXED_SLOT policy.\"\n        },\n        {\n          \"name\": \"UnallocatedOperand\",\n          \"parameters\": [\n            \"ExtendedPolicy policy\",\n            \"int index\",\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for FIXED_REGISTER and FIXED_FP_REGISTER policies.\"\n        },\n        {\n          \"name\": \"UnallocatedOperand\",\n          \"parameters\": [\n            \"ExtendedPolicy policy\",\n            \"Lifetime lifetime\",\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor to specify the lifetime of an operand.\"\n        },\n        {\n          \"name\": \"UnallocatedOperand\",\n          \"parameters\": [\n            \"int reg_id\",\n            \"int slot_id\",\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for fixed register policy with secondary storage\"\n        },\n        {\n          \"name\": \"UnallocatedOperand\",\n          \"parameters\": [\n            \"const UnallocatedOperand& other\",\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Copy constructor that updates the virtual register.\"\n        },\n        {\n          \"name\": \"HasRegisterOrSlotPolicy\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has REGISTER_OR_SLOT policy.\"\n        },\n        {\n          \"name\": \"HasRegisterOrSlotOrConstantPolicy\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has REGISTER_OR_SLOT_OR_CONSTANT policy.\"\n        },\n        {\n          \"name\": \"HasFixedPolicy\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has a fixed policy (FIXED_SLOT, FIXED_REGISTER, or FIXED_FP_REGISTER).\"\n        },\n        {\n          \"name\": \"HasRegisterPolicy\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has MUST_HAVE_REGISTER policy.\"\n        },\n        {\n          \"name\": \"HasSlotPolicy\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has MUST_HAVE_SLOT policy.\"\n        },\n        {\n          \"name\": \"HasSameAsInputPolicy\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has SAME_AS_INPUT policy.\"\n        },\n        {\n          \"name\": \"HasFixedSlotPolicy\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has FIXED_SLOT policy.\"\n        },\n        {\n          \"name\": \"HasFixedRegisterPolicy\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has FIXED_REGISTER policy.\"\n        },\n        {\n          \"name\": \"HasFixedFPRegisterPolicy\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has FIXED_FP_REGISTER policy.\"\n        },\n        {\n          \"name\": \"HasSecondaryStorage\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the operand has secondary storage\"\n        },\n        {\n          \"name\": \"GetSecondaryStorage\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the ID for the secondary storage.\"\n        },\n        {\n          \"name\": \"basic_policy\",\n          \"parameters\": [],\n          \"return_type\": \"BasicPolicy\",\n          \"logic\": \"Returns the basic policy of the operand.\"\n        },\n        {\n          \"name\": \"extended_policy\",\n          \"parameters\": [],\n          \"return_type\": \"ExtendedPolicy\",\n          \"logic\": \"Returns the extended policy of the operand.\"\n        },\n        {\n          \"name\": \"input_index\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the input index if SAME_AS_INPUT policy is used.\"\n        },\n        {\n          \"name\": \"fixed_slot_index\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the fixed slot index if FIXED_SLOT policy is used.\"\n        },\n        {\n          \"name\": \"fixed_register_index\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the fixed register index if FIXED_REGISTER or FIXED_FP_REGISTER policy is used.\"\n        },\n        {\n          \"name\": \"virtual_register\",\n          \"parameters\": [],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Returns the virtual register ID for this operand.\"\n        },\n        {\n          \"name\": \"IsUsedAtStart\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns true if operand is marked as used at start.\"\n        },\n                {\n          \"name\": \"UnallocatedOperand\",\n          \"parameters\": [\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Private constructor for setting the virtual register during other initializations.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ConstantOperand\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ConstantOperand\",\n          \"parameters\": [\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that sets the virtual register.\"\n        },\n        {\n          \"name\": \"virtual_register\",\n          \"parameters\": [],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Returns the virtual register ID.\"\n        },\n        {\n          \"name\": \"New\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"int virtual_register\"\n          ],\n          \"return_type\": \"ConstantOperand*\",\n          \"logic\": \"Allocates a new ConstantOperand in the specified zone.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ImmediateOperand\",\n      \"properties\": [\n        \"enum ImmediateType\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"ImmediateOperand\",\n          \"parameters\": [\n            \"ImmediateType type\",\n            \"int32_t value\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that sets the type and value.\"\n        },\n        {\n          \"name\": \"type\",\n          \"parameters\": [],\n          \"return_type\": \"ImmediateType\",\n          \"logic\": \"Returns the type of the immediate operand.\"\n        },\n        {\n          \"name\": \"inline_int32_value\",\n          \"parameters\": [],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Returns the value of an INLINE_INT32 immediate operand.\"\n        },\n        {\n          \"name\": \"inline_int64_value\",\n          \"parameters\": [],\n          \"return_type\": \"int64_t\",\n          \"logic\": \"Returns the value of an INLINE_INT64 immediate operand.\"\n        },\n        {\n          \"name\": \"indexed_value\",\n          \"parameters\": [],\n          \"return_type\": \"int32_t\",\n          \"logic\": \"Returns the indexed value for RPO and immediate types.\"\n        },\n        {\n          \"name\": \"New\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"ImmediateType type\",\n            \"int32_t value\"\n          ],\n          \"return_type\": \"ImmediateOperand*\",\n          \"logic\": \"Allocates a new ImmediateOperand in the specified zone.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"PendingOperand\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"PendingOperand\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Default constructor.\"\n        },\n        {\n          \"name\": \"PendingOperand\",\n          \"parameters\": [\n            \"PendingOperand* next_operand\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor with setting a next operand\"\n        },\n        {\n          \"name\": \"set_next\",\n          \"parameters\": [\n            \"PendingOperand* next\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Sets the next pending operand in the chain.\"\n        },\n        {\n          \"name\": \"next\",\n          \"parameters\": [],\n          \"return_type\": \"PendingOperand*\",\n          \"logic\": \"Returns the next pending operand in the chain.\"\n        },\n        {\n          \"name\": \"New\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"PendingOperand* previous_operand\"\n          ],\n          \"return_type\": \"PendingOperand*\",\n          \"logic\": \"Allocates a new PendingOperand in the specified zone, attached to the provided operand.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"LocationOperand\",\n      \"properties\": [\n        \"enum LocationKind\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"LocationOperand\",\n          \"parameters\": [\n            \"InstructionOperand::Kind operand_kind\",\n            \"LocationOperand::LocationKind location_kind\",\n            \"MachineRepresentation rep\",\n            \"int index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that sets the kind, location kind, representation, and index.\"\n        },\n        {\n          \"name\": \"index\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the index (for stack slots).\"\n        },\n        {\n          \"name\": \"register_code\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Returns the register code (for registers).\"\n        },\n        {\n          \"name\": \"GetRegister\",\n          \"parameters\": [],\n          \"return_type\": \"Register\",\n          \"logic\": \"Returns the Register object.\"\n        },\n        {\n          \"name\": \"GetFloatRegister\",\n          \"parameters\": [],\n          \"return_type\": \"FloatRegister\",\n          \"logic\": \"Returns the FloatRegister object.\"\n        },\n        {\n          \"name\": \"GetDoubleRegister\",\n          \"parameters\": [],\n          \"return_type\": \"DoubleRegister\",\n          \"logic\": \"Returns the DoubleRegister object.\"\n        },\n        {\n          \"name\": \"GetSimd128Register\",\n          \"parameters\": [],\n          \"return_type\": \"Simd128Register\",\n          \"logic\": \"Returns the Simd128Register object.\"\n        },\n        {\n          \"name\": \"GetSimd256RegisterAsSimd128\",\n          \"parameters\": [],\n          \"return_type\": \"Simd128Register\",\n          \"logic\": \"Returns the Simd256Register object (as Simd128).\"\n        },\n        {\n          \"name\": \"GetSimd256Register\",\n          \"parameters\": [],\n          \"return_type\": \"Simd256Register\",\n          \"logic\": \"Returns the Simd256Register object.\"\n        },\n        {\n          \"name\": \"location_kind\",\n          \"parameters\": [],\n          \"return_type\": \"LocationKind\",\n          \"logic\": \"Returns the location kind (register or stack slot).\"\n        },\n        {\n          \"name\": \"representation\",\n          \"parameters\": [],\n          \"return_type\": \"MachineRepresentation\",\n          \"logic\": \"Returns the machine representation.\"\n        },\n        {\n          \"name\": \"IsSupportedRepresentation\",\n          \"parameters\": [\n            \"MachineRepresentation rep\"\n          ],\n          \"return_type\": \"static bool\",\n          \"logic\": \"Checks if a given machine representation is supported for locations.\"\n        },\n        {\n          \"name\": \"IsCompatible\",\n          \"parameters\": [\n            \"LocationOperand* op\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Return true if the locations can be moved to one another.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"AllocatedOperand\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"AllocatedOperand\",\n          \"parameters\": [\n            \"LocationKind kind\",\n            \"MachineRepresentation rep\",\n            \"int index\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that sets the location kind, machine representation, and index.\"\n        },\n        {\n          \"name\": \"New\",\n          \"parameters\": [\n            \"Zone* zone\",\n            \"LocationKind kind\",\n            \"MachineRepresentation rep\",\n            \"int index\"\n          ],\n          \"return_type\": \"AllocatedOperand*\",\n          \"logic\": \"Allocates a new AllocatedOperand in the specified zone.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"CompareOperandModuloType\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"operator()\",\n          \"parameters\": [\n            \"const InstructionOperand& a\",\n            \"const InstructionOperand& b\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Comparator used for map keys which compares instruction operands, ignoring MachineType.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"MoveOperands\",\n      \"properties\": [\n        \"InstructionOperand source_\",\n        \"InstructionOperand destination_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"MoveOperands\",\n          \"parameters\": [\n            \"const InstructionOperand& source\",\n            \"const InstructionOperand& destination\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that stores the source and destination of a move.\"\n        },\n        {\n          \"name\": \"CheckPointerCompressionConsistency\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Checks that the pointer compression configurations of the source and destination are consistent.\"\n        },\n        {\n          \"name\": \"source\",\n          \"parameters\": [],\n          \"return_type\": \"const InstructionOperand&\",\n          \"logic\": \"Getter for source.\"\n        },\n        {\n          \"name\": \"source\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionOperand&\",\n          \"logic\": \"Getter for source.\"\n        },\n        {\n          \"name\": \"set_source\",\n          \"parameters\": [\n            \"const InstructionOperand& operand\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Setter for source.\"\n        },\n        {\n          \"name\": \"destination\",\n          \"parameters\": [],\n          \"return_type\": \"const InstructionOperand&\",\n          \"logic\": \"Getter for destination.\"\n        },\n        {\n          \"name\": \"destination\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionOperand&\",\n          \"logic\": \"Getter for destination.\"\n        },\n        {\n          \"name\": \"set_destination\",\n          \"parameters\": [\n            \"const InstructionOperand& operand\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Setter for destination.\"\n        },\n        {\n          \"name\": \"IsPending\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the move is pending (destination is cleared).\"\n        },\n        {\n          \"name\": \"SetPending\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Marks the move as pending by clearing the destination.\"\n        },\n        {\n          \"name\": \"IsRedundant\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the move is redundant (eliminated or source equals destination).\"\n        },\n        {\n          \"name\": \"Eliminate\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Eliminates the move by clearing both operands.\"\n        },\n        {\n          \"name\": \"IsEliminated\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the move has been eliminated.\"\n        },\n        {\n          \"name\": \"Print\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Prints the move operands to the console (for debugging).\"\n        },\n        {\n          \"name\": \"Equals\",\n          \"parameters\": [\n            \"const MoveOperands& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if this MoveOperands is equal to `that`\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ParallelMove\",\n      \"properties\": [],\n      \"methods\": [\n        {\n          \"name\": \"ParallelMove\",\n          \"parameters\": [\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that initializes the vector.\"\n        },\n        {\n          \"name\": \"AddMove\",\n          \"parameters\": [\n            \"const InstructionOperand& from\",\n            \"const InstructionOperand& to\"\n          ],\n          \"return_type\": \"MoveOperands*\",\n          \"logic\": \"Adds a move to the parallel move, allocating the MoveOperands in this zone. If the to and from operands are identical the move is skipped and nullptr is returned.\"\n        },\n        {\n          \"name\": \"AddMove\",\n          \"parameters\": [\n            \"const InstructionOperand& from\",\n            \"const InstructionOperand& to\",\n            \"Zone* operand_allocation_zone\"\n          ],\n          \"return_type\": \"MoveOperands*\",\n          \"logic\": \"Adds a move to the parallel move, allocating the MoveOperands in a specified zone. If the to and from operands are identical the move is skipped and nullptr is returned.\"\n        },\n        {\n          \"name\": \"IsRedundant\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if all contained moves are redundant.\"\n        },\n        {\n          \"name\": \"PrepareInsertAfter\",\n          \"parameters\": [\n            \"MoveOperands* move\",\n            \"ZoneVector<MoveOperands*>* to_eliminate\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Prepare this ParallelMove to insert move as if it happened in a subsequent ParallelMove. move->source() may be changed. Any MoveOperands added to to_eliminate must be Eliminated.\"\n        },\n        {\n          \"name\": \"Equals\",\n          \"parameters\": [\n            \"const ParallelMove& that\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if two ParallelMoves are equal.\"\n        },\n        {\n          \"name\": \"Eliminate\",\n          \"parameters\": [],\n          \"return_type\": \"void\",\n          \"logic\": \"Eliminates all MoveOperands in this ParallelMove.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"ReferenceMap\",\n      \"properties\": [\n        \"ZoneVector<InstructionOperand> reference_operands_\",\n        \"int instruction_position_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"ReferenceMap\",\n          \"parameters\": [\n            \"Zone* zone\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor that initializes an empty reference map.\"\n        },\n        {\n          \"name\": \"reference_operands\",\n          \"parameters\": [],\n          \"return_type\": \"const ZoneVector<InstructionOperand>&\",\n          \"logic\": \"Getter for the reference operands.\"\n        },\n        {\n          \"name\": \"instruction_position\",\n          \"parameters\": [],\n          \"return_type\": \"int\",\n          \"logic\": \"Getter for the instruction position.\"\n        },\n        {\n          \"name\": \"set_instruction_position\",\n          \"parameters\": [\n            \"int pos\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Setter for the instruction position.\"\n        },\n        {\n          \"name\": \"RecordReference\",\n          \"parameters\": [\n            \"const AllocatedOperand& op\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Records a reference for the given allocated operand.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Instruction\",\n      \"properties\": [\n        \"InstructionCode opcode_\",\n        \"uint32_t bit_field_\",\n        \"ParallelMove* parallel_moves_[2]\",\n        \"ReferenceMap* reference_map_\",\n        \"InstructionBlock* block_\",\n        \"InstructionOperand operands_[1]\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"OutputCount\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the number of output operands.\"\n        },\n        {\n          \"name\": \"OutputAt\",\n          \"parameters\": [\n            \"size_t i\"\n          ],\n          \"return_type\": \"const InstructionOperand*\",\n          \"logic\": \"Returns the output operand at the given index (const).\"\n        },\n        {\n          \"name\": \"OutputAt\",\n          \"parameters\": [\n            \"size_t i\"\n          ],\n          \"return_type\": \"InstructionOperand*\",\n          \"logic\": \"Returns the output operand at the given index.\"\n        },\n        {\n          \"name\": \"HasOutput\",\n          \"parameters\": [],\n          \"return_type\": \"bool\",\n          \"logic\": \"Returns whether the instruction has any output operands.\"\n        },\n        {\n          \"name\": \"Output\",\n          \"parameters\": [],\n          \"return_type\": \"const InstructionOperand*\",\n          \"logic\": \"Returns the first output operand (const).\"\n        },\n        {\n          \"name\": \"Output\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionOperand*\",\n          \"logic\": \"Returns the first output operand.\"\n        },\n        {\n          \"name\": \"InputCount\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the number of input operands.\"\n        },\n        {\n          \"name\": \"InputAt\",\n          \"parameters\": [\n            \"size_t i\"\n          ],\n          \"return_type\": \"const InstructionOperand*\",\n          \"logic\": \"Returns the input operand at the given index (const).\"\n        },\n        {\n          \"name\": \"InputAt\",\n          \"parameters\": [\n            \"size_t i\"\n          ],\n          \"return_type\": \"InstructionOperand*\",\n          \"logic\": \"Returns the input operand at the given index.\"\n        },\n        {\n          \"name\": \"TempCount\",\n          \"parameters\": [],\n          \"return_type\": \"size_t\",\n          \"logic\": \"Returns the number of temporary operands.\"\n        },\n        {\n          \"name\": \"TempAt\",\n          \"parameters\": [\n            \"size_t i\"\n          ],\n          \"return_type\": \"const InstructionOperand*\",\n          \"logic\": \"Returns the temporary operand at the given index (const).\"\n        },\n        {\n          \"name\": \"TempAt\",\n          \"parameters\": [\n            \"size_t i\"\n          ],\n          \"return_type\": \"InstructionOperand*\",\n          \"logic\": \"Returns the temporary operand at the given index.\"\n        },\n        {\n          \"name\": \"opcode\",\n          \"parameters\": [],\n          \"return_type\": \"InstructionCode\",\n          \"logic\": \"Returns the opcode of the instruction.\"\n        },\n        {\n          \"name\": \"arch_opcode\",\n          \"parameters\": [],\n          \"return_type\": \"ArchOpcode\","
}