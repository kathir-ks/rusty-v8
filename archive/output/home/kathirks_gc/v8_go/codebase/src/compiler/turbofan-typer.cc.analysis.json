{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/compiler/turbofan-typer.cc",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n  \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/compiler/turbofan-typer.cc\",\n  \"imports\": [\n    \"src/compiler/turbofan-typer.h\",\n    \"iomanip\",\n    \"src/base/flags.h\",\n    \"src/codegen/tick-counter.h\",\n    \"src/compiler/common-operator.h\",\n    \"src/compiler/graph-reducer.h\",\n    \"src/compiler/js-heap-broker.h\",\n    \"src/compiler/js-operator.h\",\n    \"src/compiler/linkage.h\",\n    \"src/compiler/loop-variable-optimizer.h\",\n    \"src/compiler/node-properties.h\",\n    \"src/compiler/node.h\",\n    \"src/compiler/opcodes.h\",\n    \"src/compiler/operation-typer.h\",\n    \"src/compiler/simplified-operator.h\",\n    \"src/compiler/type-cache.h\",\n    \"src/objects/objects-inl.h\"\n  ],\n  \"classes\": [\n    {\n      \"name\": \"Typer::Decorator\",\n      \"properties\": [\n        \"typer_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Decorator\",\n          \"parameters\": [\n            \"Typer* typer\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for the Decorator class, initializes the typer_ member.\"\n        },\n        {\n          \"name\": \"Decorate\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Decorates a node by inferring and setting its type.  Only decorates nodes with ValueOutputCount > 0 and known input types.\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Typer::Visitor\",\n      \"properties\": [\n        \"typer_\",\n        \"induction_vars_\",\n        \"weakened_nodes_\"\n      ],\n      \"methods\": [\n        {\n          \"name\": \"Visitor\",\n          \"parameters\": [\n            \"Typer* typer\",\n            \"LoopVariableOptimizer* induction_vars\"\n          ],\n          \"return_type\": \"void\",\n          \"logic\": \"Constructor for the Visitor class, initializes the typer_, induction_vars_, and weakened_nodes_ members.\"\n        },\n        {\n          \"name\": \"reducer_name\",\n          \"parameters\": [],\n          \"return_type\": \"const char*\",\n          \"logic\": \"Returns the name of the reducer, which is \\\"Typer\\\".\"\n        },\n        {\n          \"name\": \"Reduce\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Reduction\",\n          \"logic\": \"Reduces a node by updating its type. If the node doesn't have a value output, it returns NoChange(). Otherwise, it calls UpdateType with the node and TypeNode(node).\"\n        },\n        {\n          \"name\": \"TypeNode\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determines the type of a node based on its opcode. Contains a large switch statement to handle different opcodes and returns the corresponding type using functions like TypeStart, TypeIfException, TypeJSAdd, etc.\"\n        },\n        {\n          \"name\": \"TypeConstant\",\n          \"parameters\": [\n            \"Handle<Object> value\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determines the type of a constant value.\"\n        },\n        {\n          \"name\": \"InductionVariablePhiTypeIsPrefixedPoint\",\n          \"parameters\": [\n            \"InductionVariable* induction_var\"\n          ],\n          \"return_type\": \"bool\",\n          \"logic\": \"Checks if the type computed for an induction variable phi is a prefixed point.\"\n        },\n        {\n          \"name\": \"TypeStart\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Internal() for Start nodes.\"\n        },\n        {\n          \"name\": \"TypeIfException\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::NonInternal() for IfException nodes.\"\n        },\n        {\n          \"name\": \"TypeParameter\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determines the type of a parameter node based on its index.\"\n        },\n        {\n          \"name\": \"TypeOsrValue\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determines the type of an osr value.\"\n        },\n        {\n          \"name\": \"TypeRetain\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeInt32Constant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Machine() for Int32Constant nodes.\"\n        },\n        {\n          \"name\": \"TypeInt64Constant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Machine() for Int64Constant nodes.\"\n        },\n        {\n          \"name\": \"TypeTaggedIndexConstant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeRelocatableInt32Constant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeRelocatableInt64Constant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeFloat32Constant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeFloat64Constant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeNumberConstant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Constant for NumberConstant nodes.\"\n        },\n        {\n          \"name\": \"TypeHeapConstant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type of a heap constant.\"\n        },\n        {\n          \"name\": \"TypeCompressedHeapConstant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeTrustedHeapConstant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type of a trusted heap constant.\"\n        },\n        {\n          \"name\": \"TypeExternalConstant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::ExternalPointer() for ExternalConstant nodes.\"\n        },\n        {\n          \"name\": \"TypePointerConstant\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::ExternalPointer() for PointerConstant nodes.\"\n        },\n        {\n          \"name\": \"TypeSelect\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns a union of the types of the true and false branches of a Select node.\"\n        },\n        {\n          \"name\": \"TypePhi\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns a union of all input types to a Phi node.\"\n        },\n                {\n          \"name\": \"TypeEnterMachineGraph\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Machine() for EnterMachineGraph nodes.\"\n        },\n        {\n          \"name\": \"TypeExitMachineGraph\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the output type specified in the ExitMachineGraph node.\"\n        },\n        {\n          \"name\": \"TypeInductionVariablePhi\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Computes the type of an induction variable phi node based on its initial value, increment, and loop bounds. Attempts to create a range type if all values are integer types.  If not, it falls back to using Union.\"\n        },\n        {\n          \"name\": \"TypeEffectPhi\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeLoopExit\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeLoopExitValue\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type of the input to a LoopExitValue node.\"\n        },\n        {\n          \"name\": \"TypeLoopExitEffect\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeEnsureWritableFastElements\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type of the second input, which represents the array after ensuring its elements are writable.\"\n        },\n        {\n          \"name\": \"TypeMaybeGrowFastElements\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type of the second input, which represents the array after possibly growing its elements.\"\n        },\n        {\n          \"name\": \"TypeTransitionElementsKind\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeTransitionElementsKindOrCheckMap\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeCheckpoint\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeBeginRegion\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeFinishRegion\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type of the input to the FinishRegion node.\"\n        },\n        {\n          \"name\": \"TypeFrameState\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Internal() for FrameState nodes.\"\n        },\n        {\n          \"name\": \"TypeStateValues\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Internal() for StateValues nodes.\"\n        },\n        {\n          \"name\": \"TypeTypedStateValues\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Internal() for TypedStateValues nodes.\"\n        },\n        {\n          \"name\": \"TypeObjectId\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeArgumentsElementsState\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Internal() for TypeArgumentsElementsState nodes.\"\n        },\n        {\n          \"name\": \"TypeArgumentsLengthState\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Internal() for TypeArgumentsLengthState nodes.\"\n        },\n        {\n          \"name\": \"TypeObjectState\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Internal() for TypeObjectState nodes.\"\n        },\n        {\n          \"name\": \"TypeTypedObjectState\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Internal() for TypeTypedObjectState nodes.\"\n        },\n        {\n          \"name\": \"TypeCall\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Any() for Call nodes.\"\n        },\n        {\n          \"name\": \"TypeFastApiCall\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the type based on the return CTypeInfo of the FastApiCall.\"\n        },\n                {\n          \"name\": \"TypeGetContinuationPreservedEmbedderData\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::Any().\"\n        },\n        {\n          \"name\": \"TypeSetContinuationPreservedEmbedderData\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeJSWasmCall\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type based on wasm signature.\"\n        },\n        {\n          \"name\": \"TypeProjection\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the element of the tuple at projection index if the type is tuple. Otherwise, returns Any.\"\n        },\n        {\n          \"name\": \"TypeMapGuard\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeTypeGuard\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns the narrowed type based on the TypeGuard node's type and the input type.\"\n        },\n        {\n          \"name\": \"TypeDead\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::None() for Dead nodes.\"\n        },\n        {\n          \"name\": \"TypeDeadValue\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::None() for DeadValue nodes.\"\n        },\n        {\n          \"name\": \"TypeUnreachable\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Returns Type::None() for Unreachable nodes.\"\n        },\n        {\n          \"name\": \"TypePlug\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeStaticAssert\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"TypeSLVerifierHint\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Should not be called. UNREACHABLE.\"\n        },\n        {\n          \"name\": \"JSEqualTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Equal.\"\n        },\n        {\n          \"name\": \"JSStrictEqualTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Strict Equal.\"\n        },\n        {\n          \"name\": \"JSCompareTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"ComparisonOutcome\",\n          \"logic\": \"The ECMAScript specification defines the four relational comparison operators with the help of a single abstract one. It behaves like < but returns undefined when the inputs cannot be compared. We implement the typing analogously.\"\n        },\n        {\n          \"name\": \"NumberCompareTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"ComparisonOutcome\",\n          \"logic\": \"Determine the comparison outcome for Number types.\"\n        },\n        {\n          \"name\": \"JSLessThanTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Less Than.\"\n        },\n        {\n          \"name\": \"JSGreaterThanTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Greater Than.\"\n        },\n        {\n          \"name\": \"JSLessThanOrEqualTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Less Than Or Equal.\"\n        },\n        {\n          \"name\": \"JSGreaterThanOrEqualTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Greater Than Or Equal.\"\n        },\n        {\n          \"name\": \"JSBitwiseOrTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Bitwise Or.\"\n        },\n        {\n          \"name\": \"JSBitwiseAndTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Bitwise And.\"\n        },\n        {\n          \"name\": \"JSBitwiseXorTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Bitwise Xor.\"\n        },\n        {\n          \"name\": \"JSShiftLeftTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Shift Left.\"\n        },\n        {\n          \"name\": \"JSShiftRightTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Shift Right.\"\n        },\n        {\n          \"name\": \"JSShiftRightLogicalTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Shift Right Logical.\"\n        },\n        {\n          \"name\": \"JSAddTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Add.\"\n        },\n        {\n          \"name\": \"JSSubtractTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Subtract.\"\n        },\n        {\n          \"name\": \"JSMultiplyTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Multiply.\"\n        },\n        {\n          \"name\": \"JSDivideTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Divide.\"\n        },\n        {\n          \"name\": \"JSModulusTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Modulus.\"\n        },\n        {\n          \"name\": \"JSExponentiateTyper\",\n          \"parameters\": [\n            \"Type lhs\",\n            \"Type rhs\",\n            \"Typer* t\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type of JS Exponentiate.\"\n        },\n        {\n          \"name\": \"TypeJSBitwiseNot\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Bitwise Not.\"\n        },\n        {\n          \"name\": \"TypeJSDecrement\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Decrement.\"\n        },\n        {\n          \"name\": \"TypeJSIncrement\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Increment.\"\n        },\n        {\n          \"name\": \"TypeJSNegate\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Negate.\"\n        },\n        {\n          \"name\": \"TypeJSToLength\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS ToLength.\"\n        },\n        {\n          \"name\": \"TypeJSToName\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS ToName.\"\n        },\n        {\n          \"name\": \"TypeJSToNumber\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS ToNumber.\"\n        },\n        {\n          \"name\": \"TypeJSToNumberConvertBigInt\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS ToNumberConvertBigInt.\"\n        },\n        {\n          \"name\": \"TypeJSToBigInt\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS ToBigInt.\"\n        },\n        {\n          \"name\": \"TypeJSToBigIntConvertNumber\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS ToBigIntConvertNumber.\"\n        },\n        {\n          \"name\": \"TypeJSToNumeric\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS ToNumeric.\"\n        },\n        {\n          \"name\": \"TypeJSToObject\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS ToObject.\"\n        },\n        {\n          \"name\": \"TypeJSToString\",\n          \"parameters\": [\n            \"Type input\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS ToString.\"\n        },\n        {\n          \"name\": \"TypeTypeOf\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS TypeOf.\"\n        },\n        {\n          \"name\": \"TypeToBoolean\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for ToBoolean.\"\n        },\n        {\n          \"name\": \"TypeJSCreate\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create.\"\n        },\n        {\n          \"name\": \"TypeJSCreateArguments\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Arguments.\"\n        },\n        {\n          \"name\": \"TypeJSCreateArray\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Array.\"\n        },\n        {\n          \"name\": \"TypeJSCreateArrayIterator\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Array Iterator.\"\n        },\n        {\n          \"name\": \"TypeJSCreateAsyncFunctionObject\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Async Function Object.\"\n        },\n        {\n          \"name\": \"TypeJSCreateCollectionIterator\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Collection Iterator.\"\n        },\n        {\n          \"name\": \"TypeJSCreateBoundFunction\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Bound Function.\"\n        },\n        {\n          \"name\": \"TypeJSCreateGeneratorObject\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Generator Object.\"\n        },\n        {\n          \"name\": \"TypeJSCreateClosure\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Closure.\"\n        },\n        {\n          \"name\": \"TypeJSCreateIterResultObject\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Iter Result Object.\"\n        },\n        {\n          \"name\": \"TypeJSCreateStringIterator\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create String Iterator.\"\n        },\n        {\n          \"name\": \"TypeJSCreateKeyValueArray\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Key Value Array.\"\n        },\n        {\n          \"name\": \"TypeJSCreateObject\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Object.\"\n        },\n        {\n          \"name\": \"TypeJSCreateStringWrapper\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create String Wrapper.\"\n        },\n        {\n          \"name\": \"TypeJSCreatePromise\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Promise.\"\n        },\n        {\n          \"name\": \"TypeJSCreateTypedArray\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Typed Array.\"\n        },\n        {\n          \"name\": \"TypeJSCreateLiteralArray\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Literal Array.\"\n        },\n        {\n          \"name\": \"TypeJSCreateEmptyLiteralArray\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Empty Literal Array.\"\n        },\n        {\n          \"name\": \"TypeJSCreateArrayFromIterable\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Array From Iterable.\"\n        },\n        {\n          \"name\": \"TypeJSCreateLiteralObject\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Literal Object.\"\n        },\n        {\n          \"name\": \"TypeJSCreateEmptyLiteralObject\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Empty Literal Object.\"\n        },\n        {\n          \"name\": \"TypeJSCloneObject\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Clone Object.\"\n        },\n        {\n          \"name\": \"TypeJSCreateLiteralRegExp\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Create Literal RegExp.\"\n        },\n        {\n          \"name\": \"TypeJSGetTemplateObject\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Get Template Object.\"\n        },\n        {\n          \"name\": \"TypeJSLoadProperty\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Load Property.\"\n        },\n        {\n          \"name\": \"TypeJSLoadNamed\",\n          \"parameters\": [\n            \"Node* node\"\n          ],\n          \"return_type\": \"Type\",\n          \"logic\": \"Determine the type for JS Load Named.\"\n        },\n        {\n          \"name\": \"TypeJS"
}