{
  "file_path": "/home/kathirks_gc/v8_go/codebase/src/compiler/turboshaft/graph.h",
  "error": "JSON parsing error",
  "raw_response": "```json\n{\n    \"file_path\": \"/home/kathirks_gc/v8_go/codebase/src/compiler/turboshaft/graph.h\",\n    \"imports\": [\n        \"<algorithm>\",\n        \"<iterator>\",\n        \"<limits>\",\n        \"<memory>\",\n        \"<tuple>\",\n        \"<type_traits>\",\n        \"src/base/iterator.h\",\n        \"src/base/logging.h\",\n        \"src/base/small-vector.h\",\n        \"src/base/vector.h\",\n        \"src/codegen/source-position.h\",\n        \"src/compiler/turboshaft/operations.h\",\n        \"src/compiler/turboshaft/sidetable.h\",\n        \"src/compiler/turboshaft/types.h\",\n        \"src/zone/zone-containers.h\"\n    ],\n    \"classes\": [\n        {\n            \"name\": \"OperationBuffer\",\n            \"properties\": [\n                \"zone_\",\n                \"begin_\",\n                \"end_\",\n                \"end_cap_\",\n                \"operation_sizes_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"OperationBuffer\",\n                    \"parameters\": [\n                        \"Zone* zone\",\n                        \"size_t initial_capacity\"\n                    ],\n                    \"return_type\": \"N/A (Constructor)\",\n                    \"logic\": \"Constructor that initializes the buffer with a given zone and initial capacity.\"\n                },\n                {\n                    \"name\": \"Allocate\",\n                    \"parameters\": [\n                        \"size_t slot_count\"\n                    ],\n                    \"return_type\": \"OperationStorageSlot*\",\n                    \"logic\": \"Allocates a given number of slots in the buffer and returns a pointer to the allocated memory. Grows the buffer if necessary.\"\n                },\n                {\n                    \"name\": \"RemoveLast\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Removes the last operation added to the buffer by decrementing the end pointer.\"\n                },\n                {\n                    \"name\": \"Index\",\n                    \"parameters\": [\n                        \"const Operation& op\"\n                    ],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of an operation in the buffer. Accepts Operation as parameter.\"\n                },\n                {\n                    \"name\": \"Index\",\n                    \"parameters\": [\n                        \"const OperationStorageSlot* ptr\"\n                    ],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of an operation in the buffer. Accepts OperationStorageSlot* as parameter.\"\n                },\n                {\n                    \"name\": \"Get\",\n                    \"parameters\": [\n                        \"OpIndex idx\"\n                    ],\n                    \"return_type\": \"OperationStorageSlot*\",\n                    \"logic\": \"Returns a pointer to the operation at the given index.\"\n                },\n                {\n                    \"name\": \"SlotCount\",\n                    \"parameters\": [\n                        \"OpIndex idx\"\n                    ],\n                    \"return_type\": \"uint16_t\",\n                    \"logic\": \"Returns the number of slots occupied by the operation at the given index.\"\n                },\n                {\n                    \"name\": \"Get\",\n                    \"parameters\": [\n                        \"OpIndex idx\"\n                    ],\n                    \"return_type\": \"const OperationStorageSlot*\",\n                    \"logic\": \"Returns a const pointer to the operation at the given index.\"\n                },\n                {\n                    \"name\": \"Next\",\n                    \"parameters\": [\n                        \"OpIndex idx\"\n                    ],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of the next operation in the buffer, given the current index.\"\n                },\n                {\n                    \"name\": \"Previous\",\n                    \"parameters\": [\n                        \"OpIndex idx\"\n                    ],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of the previous operation in the buffer, given the current index.\"\n                },\n                {\n                    \"name\": \"BeginIndex\",\n                    \"parameters\": [],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of the first operation in the buffer.\"\n                },\n                {\n                    \"name\": \"EndIndex\",\n                    \"parameters\": [],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of the end of the buffer (one-past-the-end).\"\n                },\n                {\n                    \"name\": \"size\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Returns the current size of the buffer (number of slots used).\"\n                },\n                {\n                    \"name\": \"capacity\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Returns the current capacity of the buffer (number of slots allocated).\"\n                },\n                {\n                    \"name\": \"Grow\",\n                    \"parameters\": [\n                        \"size_t min_capacity\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Grows the buffer to at least the given minimum capacity.\"\n                },\n                {\n                    \"name\": \"Reset\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Resets the buffer by setting the end pointer to the begin pointer.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"OperationBuffer::ReplaceScope\",\n            \"properties\": [\n                \"buffer_\",\n                \"replaced_\",\n                \"old_end_\",\n                \"old_slot_count_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"ReplaceScope\",\n                    \"parameters\": [\n                        \"OperationBuffer* buffer\",\n                        \"OpIndex replaced\"\n                    ],\n                    \"return_type\": \"N/A (Constructor)\",\n                    \"logic\": \"Constructor that prepares for overwriting an operation by moving the end pointer. Saves the old values so the scope can restore them.\"\n                },\n                {\n                    \"name\": \"~ReplaceScope\",\n                    \"parameters\": [],\n                    \"return_type\": \"N/A (Destructor)\",\n                    \"logic\": \"Destructor that restores the end pointer after overwriting an operation.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"DominatorForwardTreeNode\",\n            \"properties\": [\n                \"neighboring_child_\",\n                \"last_child_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"AddChild\",\n                    \"parameters\": [\n                        \"Derived* next\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Adds a child node to the dominator tree.\"\n                },\n                {\n                    \"name\": \"LastChild\",\n                    \"parameters\": [],\n                    \"return_type\": \"Derived*\",\n                    \"logic\": \"Returns the last child node.\"\n                },\n                {\n                    \"name\": \"NeighboringChild\",\n                    \"parameters\": [],\n                    \"return_type\": \"Derived*\",\n                    \"logic\": \"Returns the neighboring child node.\"\n                },\n                {\n                    \"name\": \"HasChildren\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Returns true if the node has children, false otherwise.\"\n                },\n                {\n                    \"name\": \"Children\",\n                    \"parameters\": [],\n                    \"return_type\": \"base::SmallVector<Derived*, 8>\",\n                    \"logic\": \"Returns a vector of all child nodes.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"RandomAccessStackDominatorNode\",\n            \"properties\": [\n                \"jmp_len_\",\n                \"len_\",\n                \"nxt_\",\n                \"jmp_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"SetDominator\",\n                    \"parameters\": [\n                        \"Derived* dominator\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets the dominator of the node.\"\n                },\n                {\n                    \"name\": \"SetAsDominatorRoot\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets the node as the dominator root.\"\n                },\n                {\n                    \"name\": \"GetDominator\",\n                    \"parameters\": [],\n                    \"return_type\": \"Derived*\",\n                    \"logic\": \"Returns the dominator of the node.\"\n                },\n                {\n                    \"name\": \"GetCommonDominator\",\n                    \"parameters\": [\n                        \"RandomAccessStackDominatorNode<Derived>* other\"\n                    ],\n                    \"return_type\": \"Derived*\",\n                    \"logic\": \"Returns the lowest common dominator of this and another node.\"\n                },\n                {\n                    \"name\": \"IsDominatedBy\",\n                    \"parameters\": [\n                        \"const Derived* other\"\n                    ],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the node is dominated by another node.\"\n                },\n                {\n                    \"name\": \"Depth\",\n                    \"parameters\": [],\n                    \"return_type\": \"int\",\n                    \"logic\": \"Returns the depth of the node in the dominator tree.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"PredecessorIterator\",\n            \"properties\": [\n                \"current_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"PredecessorIterator\",\n                    \"parameters\": [\n                        \"const Block* block\"\n                    ],\n                    \"return_type\": \"N/A (Constructor)\",\n                    \"logic\": \"Constructor that initializes the iterator with a given block.\"\n                },\n                {\n                    \"name\": \"operator++\",\n                    \"parameters\": [],\n                    \"return_type\": \"PredecessorIterator&\",\n                    \"logic\": \"Increments the iterator to the next predecessor.\"\n                },\n                {\n                    \"name\": \"operator==\",\n                    \"parameters\": [\n                        \"const PredecessorIterator& other\"\n                    ],\n                    \"return_type\": \"constexpr bool\",\n                    \"logic\": \"Checks if the iterator is equal to another iterator.\"\n                },\n                {\n                    \"name\": \"operator!=\",\n                    \"parameters\": [\n                        \"const PredecessorIterator& other\"\n                    ],\n                    \"return_type\": \"constexpr bool\",\n                    \"logic\": \"Checks if the iterator is not equal to another iterator.\"\n                },\n                {\n                    \"name\": \"operator*\",\n                    \"parameters\": [],\n                    \"return_type\": \"const Block*\",\n                    \"logic\": \"Returns the current block.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"NeighboringPredecessorIterable\",\n            \"properties\": [\n                \"begin_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"NeighboringPredecessorIterable\",\n                    \"parameters\": [\n                        \"const Block* begin\"\n                    ],\n                    \"return_type\": \"N/A (Constructor)\",\n                    \"logic\": \"Constructor that initializes the iterable with a starting block.\"\n                },\n                {\n                    \"name\": \"begin\",\n                    \"parameters\": [],\n                    \"return_type\": \"PredecessorIterator\",\n                    \"logic\": \"Returns an iterator to the first predecessor.\"\n                },\n                {\n                    \"name\": \"end\",\n                    \"parameters\": [],\n                    \"return_type\": \"PredecessorIterator\",\n                    \"logic\": \"Returns an iterator to the end of the predecessors.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Block\",\n            \"properties\": [\n                \"kind_\",\n                \"begin_\",\n                \"end_\",\n                \"index_\",\n                \"last_predecessor_\",\n                \"neighboring_predecessor_\",\n                \"single_loop_predecessor_\",\n                \"predecessor_count_\",\n                \"origin_\",\n                \"custom_data_\",\n                \"custom_data_kind_for_debug_check_\",\n                \"graph_generation_\",\n                \"has_peeled_iteration_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"Block\",\n                    \"parameters\": [\n                        \"Kind kind\"\n                    ],\n                    \"return_type\": \"N/A (Constructor)\",\n                    \"logic\": \"Constructor that initializes the block with a given kind.\"\n                },\n                {\n                    \"name\": \"IsLoopOrMerge\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Returns true if the block is a loop header or a merge block, false otherwise.\"\n                },\n                {\n                    \"name\": \"IsLoop\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Returns true if the block is a loop header, false otherwise.\"\n                },\n                {\n                    \"name\": \"IsMerge\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Returns true if the block is a merge block, false otherwise.\"\n                },\n                {\n                    \"name\": \"IsBranchTarget\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Returns true if the block is a branch target, false otherwise.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"parameters\": [],\n                    \"return_type\": \"Kind\",\n                    \"logic\": \"Returns the kind of the block.\"\n                },\n                {\n                    \"name\": \"SetKind\",\n                    \"parameters\": [\n                        \"Kind kind\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets the kind of the block.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"parameters\": [],\n                    \"return_type\": \"BlockIndex\",\n                    \"logic\": \"Returns the index of the block.\"\n                },\n                {\n                    \"name\": \"Contains\",\n                    \"parameters\": [\n                        \"OpIndex op_idx\"\n                    ],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the block contains the operation at the given index.\"\n                },\n                {\n                    \"name\": \"IsBound\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Returns true if the block is bound to a graph, false otherwise.\"\n                },\n                {\n                    \"name\": \"Predecessors\",\n                    \"parameters\": [],\n                    \"return_type\": \"base::SmallVector<Block*, 8>\",\n                    \"logic\": \"Returns a vector of all predecessor blocks.\"\n                },\n                {\n                    \"name\": \"PredecessorsIterable\",\n                    \"parameters\": [],\n                    \"return_type\": \"NeighboringPredecessorIterable\",\n                    \"logic\": \"Returns an iterable object to iterate over the block's predecessors.\"\n                },\n                {\n                    \"name\": \"PredecessorCount\",\n                    \"parameters\": [],\n                    \"return_type\": \"int\",\n                    \"logic\": \"Returns the number of predecessor blocks.\"\n                },\n                {\n                    \"name\": \"CheckPredecessorCount\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Checks that the predecessor_count_ is equal to the number of predecessors reachable through last_predecessor_.\"\n                },\n                {\n                    \"name\": \"GetPredecessorIndex\",\n                    \"parameters\": [\n                        \"const Block* target\"\n                    ],\n                    \"return_type\": \"int\",\n                    \"logic\": \"Returns the index of a target block in the predecessors. Returns -1 if target is not a direct predecessor\"\n                },\n                {\n                    \"name\": \"LastPredecessor\",\n                    \"parameters\": [],\n                    \"return_type\": \"Block*\",\n                    \"logic\": \"Returns the last predecessor block.\"\n                },\n                {\n                    \"name\": \"NeighboringPredecessor\",\n                    \"parameters\": [],\n                    \"return_type\": \"Block*\",\n                    \"logic\": \"Returns the neighboring predecessor block.\"\n                },\n                {\n                    \"name\": \"HasPredecessors\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Returns true if the block has predecessors, false otherwise.\"\n                },\n                {\n                    \"name\": \"ResetLastPredecessor\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Resets the last_predecessor_ to null and predecessor_count_ to 0.\"\n                },\n                {\n                    \"name\": \"ResetAllPredecessors\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Resets last_predecessor_ and all neighboring predecessors to null and predecessor_count_ to 0.\"\n                },\n                {\n                    \"name\": \"single_loop_predecessor\",\n                    \"parameters\": [],\n                    \"return_type\": \"Block*\",\n                    \"logic\": \"Returns the single loop predecessor of the block.\"\n                },\n                {\n                    \"name\": \"SetSingleLoopPredecessor\",\n                    \"parameters\": [\n                        \"Block* single_loop_predecessor\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets the single loop predecessor of the block.\"\n                },\n                {\n                    \"name\": \"SetOrigin\",\n                    \"parameters\": [\n                        \"const Block* origin\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets the origin block of the current block. This is the equivalent block from the previous graph.\"\n                },\n                {\n                    \"name\": \"OriginForBlockEnd\",\n                    \"parameters\": [],\n                    \"return_type\": \"const Block*\",\n                    \"logic\": \"Returns the origin block for the block end.\"\n                },\n                {\n                    \"name\": \"OriginForLoopHeader\",\n                    \"parameters\": [],\n                    \"return_type\": \"const Block*\",\n                    \"logic\": \"Returns the origin block for the loop header.\"\n                },\n                {\n                    \"name\": \"IsComplete\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Returns true if the block is complete, false otherwise (if end_ is valid)\"\n                },\n                {\n                    \"name\": \"begin\",\n                    \"parameters\": [],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the begin index of the block.\"\n                },\n                {\n                    \"name\": \"end\",\n                    \"parameters\": [],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the end index of the block.\"\n                },\n                {\n                    \"name\": \"OpCountUpperBound\",\n                    \"parameters\": [],\n                    \"return_type\": \"int\",\n                    \"logic\": \"Returns an approximation of the number of operations contained in this block by subtracting the begin and end indices\"\n                },\n                {\n                    \"name\": \"FirstOperation\",\n                    \"parameters\": [\n                        \"const Graph& graph\"\n                    ],\n                    \"return_type\": \"const Operation&\",\n                    \"logic\": \"Returns the first operation in the block.\"\n                },\n                {\n                    \"name\": \"LastOperation\",\n                    \"parameters\": [\n                        \"const Graph& graph\"\n                    ],\n                    \"return_type\": \"const Operation&\",\n                    \"logic\": \"Returns the last operation in the block.\"\n                },\n                {\n                    \"name\": \"LastOperation\",\n                    \"parameters\": [\n                        \"Graph& graph\"\n                    ],\n                    \"return_type\": \"Operation&\",\n                    \"logic\": \"Returns the last operation in the block (mutable).\"\n                },\n                {\n                    \"name\": \"EndsWithBranchingOp\",\n                    \"parameters\": [\n                        \"const Graph& graph\"\n                    ],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the block ends with a branching operation.\"\n                },\n                {\n                    \"name\": \"HasPhis\",\n                    \"parameters\": [\n                        \"const Graph& graph\"\n                    ],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the block contains any phi operations.\"\n                },\n                {\n                    \"name\": \"HasBackedge\",\n                    \"parameters\": [\n                        \"const Graph& graph\"\n                    ],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if the last operation in the block is a goto operation with a backedge.\"\n                },\n                {\n                    \"name\": \"has_peeled_iteration\",\n                    \"parameters\": [],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Returns true if this loop has a peeled iteration.\"\n                },\n                {\n                    \"name\": \"set_has_peeled_iteration\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets the has_peeled_iteration flag to true.\"\n                },\n                {\n                    \"name\": \"ComputeDominator\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Computes the dominator of the block.\"\n                },\n                {\n                    \"name\": \"PrintDominatorTree\",\n                    \"parameters\": [\n                        \"std::vector<const char*> tree_symbols\",\n                        \"bool has_next\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Prints the dominator tree.\"\n                },\n                {\n                    \"name\": \"set_custom_data\",\n                    \"parameters\": [\n                        \"uint32_t data\",\n                        \"CustomDataKind kind_for_debug_check\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets custom data for the block.\"\n                },\n                {\n                    \"name\": \"get_custom_data\",\n                    \"parameters\": [\n                        \"CustomDataKind kind_for_debug_check\"\n                    ],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Gets custom data for the block.\"\n                },\n                {\n                    \"name\": \"clear_custom_data\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Clears the custom data for the block.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Graph\",\n            \"properties\": [\n                \"operations_\",\n                \"bound_blocks_\",\n                \"all_blocks_\",\n                \"op_to_block_\",\n                \"block_permutation_\",\n                \"graph_zone_\",\n                \"source_positions_\",\n                \"operation_origins_\",\n                \"operation_types_\",\n                \"block_type_refinement_\",\n                \"stack_checks_to_remove_\",\n                \"dominator_tree_depth_\",\n                \"companion_\",\n                \"generation_\",\n                \"graph_created_from_turbofan_\",\n                \"loop_unrolling_analyzer_\"\n            ],\n            \"methods\": [\n                {\n                    \"name\": \"Graph\",\n                    \"parameters\": [\n                        \"Zone* graph_zone\",\n                        \"size_t initial_capacity\"\n                    ],\n                    \"return_type\": \"N/A (Constructor)\",\n                    \"logic\": \"Constructor that initializes the graph with a given zone and initial capacity.\"\n                },\n                {\n                    \"name\": \"Reset\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Resets the graph to recycle its memory.\"\n                },\n                {\n                    \"name\": \"Get\",\n                    \"parameters\": [\n                        \"OpIndex i\"\n                    ],\n                    \"return_type\": \"const Operation&\",\n                    \"logic\": \"Returns the operation at the given index (const version).\"\n                },\n                {\n                    \"name\": \"Get\",\n                    \"parameters\": [\n                        \"OpIndex i\"\n                    ],\n                    \"return_type\": \"Operation&\",\n                    \"logic\": \"Returns the operation at the given index (mutable version).\"\n                },\n                {\n                    \"name\": \"KillOperation\",\n                    \"parameters\": [\n                        \"OpIndex i\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Replaces an operation with a DeadOp to mark it as invalid or to be removed.\"\n                },\n                {\n                    \"name\": \"StartBlock\",\n                    \"parameters\": [],\n                    \"return_type\": \"Block&\",\n                    \"logic\": \"Returns the start block of the graph (mutable).\"\n                },\n                {\n                    \"name\": \"StartBlock\",\n                    \"parameters\": [],\n                    \"return_type\": \"const Block&\",\n                    \"logic\": \"Returns the start block of the graph (const version).\"\n                },\n                {\n                    \"name\": \"Get\",\n                    \"parameters\": [\n                        \"BlockIndex i\"\n                    ],\n                    \"return_type\": \"Block&\",\n                    \"logic\": \"Returns the block at the given index (mutable).\"\n                },\n                {\n                    \"name\": \"Get\",\n                    \"parameters\": [\n                        \"BlockIndex i\"\n                    ],\n                    \"return_type\": \"const Block&\",\n                    \"logic\": \"Returns the block at the given index (const version).\"\n                },\n                {\n                    \"name\": \"Index\",\n                    \"parameters\": [\n                        \"const Operation& op\"\n                    ],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of a given operation.\"\n                },\n                {\n                    \"name\": \"BlockOf\",\n                    \"parameters\": [\n                        \"OpIndex index\"\n                    ],\n                    \"return_type\": \"BlockIndex\",\n                    \"logic\": \"Determines the block that owns a given operation index.\"\n                },\n                {\n                    \"name\": \"SetBlockOf\",\n                    \"parameters\": [\n                        \"BlockIndex block\",\n                        \"OpIndex op\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Sets the block of an operation.\"\n                },\n                {\n                    \"name\": \"BlockIndexOf\",\n                    \"parameters\": [\n                        \"OpIndex op\"\n                    ],\n                    \"return_type\": \"BlockIndex\",\n                    \"logic\": \"Returns the block index for a given OpIndex.\"\n                },\n                {\n                    \"name\": \"BlockIndexOf\",\n                    \"parameters\": [\n                        \"const Operation& op\"\n                    ],\n                    \"return_type\": \"BlockIndex\",\n                    \"logic\": \"Returns the block index for a given Operation.\"\n                },\n                {\n                    \"name\": \"NextIndex\",\n                    \"parameters\": [\n                        \"const OpIndex idx\"\n                    ],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of the next operation.\"\n                },\n                {\n                    \"name\": \"PreviousIndex\",\n                    \"parameters\": [\n                        \"const OpIndex idx\"\n                    ],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of the previous operation.\"\n                },\n                {\n                    \"name\": \"LastOperation\",\n                    \"parameters\": [],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of the last operation.\"\n                },\n                {\n                    \"name\": \"Allocate\",\n                    \"parameters\": [\n                        \"size_t slot_count\"\n                    ],\n                    \"return_type\": \"OperationStorageSlot*\",\n                    \"logic\": \"Allocates memory for operation storage.\"\n                },\n                {\n                    \"name\": \"RemoveLast\",\n                    \"parameters\": [],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Removes the last added operation from the graph.\"\n                },\n                {\n                    \"name\": \"Add\",\n                    \"parameters\": [\n                        \"Args... args\"\n                    ],\n                    \"return_type\": \"Op&\",\n                    \"logic\": \"Adds an operation to the graph.\"\n                },\n                {\n                    \"name\": \"Replace\",\n                    \"parameters\": [\n                        \"OpIndex replaced\",\n                        \"Args... args\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Replaces an existing operation with a new one.\"\n                },\n                {\n                    \"name\": \"NewLoopHeader\",\n                    \"parameters\": [\n                        \"const Block* origin\"\n                    ],\n                    \"return_type\": \"Block*\",\n                    \"logic\": \"Creates a new loop header block.\"\n                },\n                {\n                    \"name\": \"NewBlock\",\n                    \"parameters\": [\n                        \"const Block* origin\"\n                    ],\n                    \"return_type\": \"Block*\",\n                    \"logic\": \"Creates a new merge block.\"\n                },\n                {\n                    \"name\": \"NewBlock\",\n                    \"parameters\": [\n                        \"Block::Kind kind\",\n                        \"const Block* origin\"\n                    ],\n                    \"return_type\": \"Block*\",\n                    \"logic\": \"Creates a new block of a specified kind.\"\n                },\n                {\n                    \"name\": \"Add\",\n                    \"parameters\": [\n                        \"Block* block\"\n                    ],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Adds a block to the graph.\"\n                },\n                {\n                    \"name\": \"Finalize\",\n                    \"parameters\": [\n                        \"Block* block\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Finalizes a block by setting its end index and populating the op_to_block_ mapping for its operations.\"\n                },\n                {\n                    \"name\": \"TurnLoopIntoMerge\",\n                    \"parameters\": [\n                        \"Block* loop\"\n                    ],\n                    \"return_type\": \"void\",\n                    \"logic\": \"Turns a loop header block into a merge block.\"\n                },\n                {\n                    \"name\": \"next_operation_index\",\n                    \"parameters\": [],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index where the next operation will be placed.\"\n                },\n                {\n                    \"name\": \"next_block_index\",\n                    \"parameters\": [],\n                    \"return_type\": \"BlockIndex\",\n                    \"logic\": \"Returns the index where the next block will be placed.\"\n                },\n                {\n                    \"name\": \"last_block\",\n                    \"parameters\": [],\n                    \"return_type\": \"Block*\",\n                    \"logic\": \"Returns the last block added to the graph.\"\n                },\n                {\n                    \"name\": \"graph_zone\",\n                    \"parameters\": [],\n                    \"return_type\": \"Zone*\",\n                    \"logic\": \"Returns the zone associated with the graph.\"\n                },\n                {\n                    \"name\": \"block_count\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Returns the number of blocks in the graph.\"\n                },\n                {\n                    \"name\": \"op_id_count\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Returns the number of operation ids in the graph.\"\n                },\n                {\n                    \"name\": \"NumberOfOperationsForDebugging\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Returns the number of operations present in the graph.\"\n                },\n                {\n                    \"name\": \"op_id_capacity\",\n                    \"parameters\": [],\n                    \"return_type\": \"uint32_t\",\n                    \"logic\": \"Returns the maximum operation id the graph can support.\"\n                },\n                {\n                    \"name\": \"BeginIndex\",\n                    \"parameters\": [],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of the first operation.\"\n                },\n                {\n                    \"name\": \"EndIndex\",\n                    \"parameters\": [],\n                    \"return_type\": \"OpIndex\",\n                    \"logic\": \"Returns the index of the end of operations.\"\n                },\n                {\n                    \"name\": \"AllOperations\",\n                    \"parameters\": [],\n                    \"return_type\": \"base::iterator_range<MutableOperationIterator>\",\n                    \"logic\": \"Returns a range for all operations in the graph. (mutable)\"\n                },\n                {\n                    \"name\": \"AllOperations\",\n                    \"parameters\": [],\n                    \"return_type\": \"base::iterator_range<ConstOperationIterator>\",\n                    \"logic\": \"Returns a range for all operations in the graph. (const)\"\n                },\n                {\n                    \"name\": \"AllOperationIndices\",\n                    \"parameters\": [],\n                    \"return_type\": \"base::iterator_range<OpIndexIterator>\",\n                    \"logic\": \"Returns a range of OpIndices for all operations in the graph\"\n                },\n                {\n                    \"name\": \"operations\",\n                    \"parameters\": [\n                        \"const Block& block\"\n                    ],\n                    \"return_type\": \"base::iterator_range<MutableOperationIterator>\",\n                    \"logic\": \"Returns a range for operations in a block (mutable).\"\n                },\n                {\n                    \"name\": \"operations\",\n                    \"parameters\": [\n                        \"const Block& block\"\n                    ],\n                    \"return_type\": \"base::iterator_range<ConstOperationIterator>\",\n                    \"logic\": \"Returns a range for operations in a block (const).\"\n                },\n                {\n                    \"name\": \"OperationIndices\",\n                    \"parameters\": [\n                        \"const Block& block\"\n                    ],\n                    \"return_type\": \"base::iterator_range<OpIndexIterator>\",\n                    \"logic\": \"Returns a range of OpIndices in a block.\"\n                },\n                {\n                    \"name\": \"operations\",\n                    \"parameters\": [\n                        \"OpIndex begin\",\n                        \"OpIndex end\"\n                    ],\n                    \"return_type\": \"base::iterator_range<ConstOperationIterator>\",\n                    \"logic\": \"Returns a range for operations between two indices (const).\"\n                },\n                {\n                    \"name\": \"operations\",\n                    \"parameters\": [\n                        \"OpIndex begin\",\n                        \"OpIndex end\"\n                    ],\n                    \"return_type\": \"base::iterator_range<MutableOperationIterator>\",\n                    \"logic\": \"Returns a range for operations between two indices (mutable).\"\n                },\n                {\n                    \"name\": \"OperationIndices\",\n                    \"parameters\": [\n                        \"OpIndex begin\",\n                        \"OpIndex end\"\n                    ],\n                    \"return_type\": \"base::iterator_range<OpIndexIterator>\",\n                    \"logic\": \"Returns a range of OpIndices between two indices.\"\n                },\n                {\n                    \"name\": \"blocks\",\n                    \"parameters\": [],\n                    \"return_type\": \"base::iterator_range<base::DerefPtrIterator<Block>>\",\n                    \"logic\": \"Returns a range of all blocks in the graph (mutable).\"\n                },\n                {\n                    \"name\": \"blocks\",\n                    \"parameters\": [],\n                    \"return_type\": \"base::iterator_range<base::DerefPtrIterator<const Block>>\",\n                    \"logic\": \"Returns a range of all blocks in the graph (const).\"\n                },\n                {\n                    \"name\": \"blocks_vector\",\n                    \"parameters\": [],\n                    \"return_type\": \"const ZoneVector<Block*>&\",\n                    \"logic\": \"Returns the vector of blocks.\"\n                },\n                {\n                    \"name\": \"IsLoopBackedge\",\n                    \"parameters\": [\n                        \"const GotoOp& op\"\n                    ],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Determines if a GotoOp is a loop back edge.\"\n                },\n                {\n                    \"name\": \"IsValid\",\n                    \"parameters\": [\n                        \"OpIndex i\"\n                    ],\n                    \"return_type\": \"bool\",\n                    \"logic\": \"Checks if an Op"
}