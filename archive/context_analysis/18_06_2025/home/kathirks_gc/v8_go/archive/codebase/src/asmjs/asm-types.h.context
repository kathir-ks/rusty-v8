{
  "metadata": {
    "path": "/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-types.h",
    "file_name": "asm-types.h",
    "language": "cpp",
    "purpose": "Defines the type system for asm.js within the V8 JavaScript engine, including value types and callable types (functions)."
  },
  "imports": {
    "metadata": {
      "language": "cpp",
      "purpose": "Includes standard library headers and V8-specific headers for string manipulation, compiler specifics, macros, zone management (memory allocation)."
    },
    "code": "#include <string>\n\n#include \"src/base/compiler-specific.h\"\n#include \"src/base/macros.h\"\n#include \"src/zone/zone-containers.h\"\n#include \"src/zone/zone.h\""
  },
  "classes": [
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "AsmValueType",
        "extends": null,
        "implements": [],
        "about": "Represents value types in asm.js, using a bitset for efficient type representation and querying.",
        "attributes": [],
        "dependencies": []
      },
      "code": "class AsmValueType {\n public:\n  using bitset_t = uint32_t;\n\n  enum : uint32_t {\n#define DEFINE_TAG(CamelName, string_name, number, parent_types) \\\n  kAsm##CamelName = ((1u << (number)) | (parent_types)),\n    FOR_EACH_ASM_VALUE_TYPE_LIST(DEFINE_TAG)\n#undef DEFINE_TAG\n        kAsmUnknown = 0,\n    kAsmValueTypeTag = 1u\n  };\n\n private:\n  friend class AsmType;\n\n  static AsmValueType* AsValueType(AsmType* type) {\n    if ((reinterpret_cast<uintptr_t>(type) & kAsmValueTypeTag) ==\n        kAsmValueTypeTag) {\n      return reinterpret_cast<AsmValueType*>(type);\n    }\n    return nullptr;\n  }\n\n  bitset_t Bitset() const {\n    DCHECK_EQ(reinterpret_cast<uintptr_t>(this) & kAsmValueTypeTag,\n              kAsmValueTypeTag);\n    return static_cast<bitset_t>(reinterpret_cast<uintptr_t>(this) &\n                                 ~kAsmValueTypeTag);\n  }\n\n  static AsmType* New(bitset_t bits) {\n    DCHECK_EQ((bits & kAsmValueTypeTag), 0u);\n    return reinterpret_cast<AsmType*>(\n        static_cast<uintptr_t>(bits | kAsmValueTypeTag));\n  }\n\n  // AsmValueTypes can't be created except through AsmValueType::New.\n  DISALLOW_IMPLICIT_CONSTRUCTORS(AsmValueType);\n};"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "AsmCallableType",
        "extends": "ZoneObject",
        "implements": [],
        "about": "Base class for callable types in asm.js (e.g., functions).  Manages the interface for function-like types.",
        "attributes": [],
        "dependencies": [
          "AsmType"
        ]
      },
      "code": "class V8_EXPORT_PRIVATE AsmCallableType : public NON_EXPORTED_BASE(ZoneObject) {\n public:\n  AsmCallableType(const AsmCallableType&) = delete;\n  AsmCallableType& operator=(const AsmCallableType&) = delete;\n\n  virtual std::string Name() = 0;\n\n  virtual bool CanBeInvokedWith(AsmType* return_type,\n                                const ZoneVector<AsmType*>& args) = 0;\n\n#define DECLARE_CAST(CamelName) \\\n  virtual Asm##CamelName* As##CamelName() { return nullptr; }\n  FOR_EACH_ASM_CALLABLE_TYPE_LIST(DECLARE_CAST)\n#undef DECLARE_CAST\n\n protected:\n  AsmCallableType() = default;\n  virtual ~AsmCallableType() = default;\n  virtual bool IsA(AsmType* other);\n\n private:\n  friend class AsmType;\n};"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "AsmFunctionType",
        "extends": "AsmCallableType",
        "implements": [],
        "about": "Represents a function type in asm.js, including its return type and argument types.",
        "attributes": [],
        "dependencies": [
          "AsmType"
        ]
      },
      "code": "class V8_EXPORT_PRIVATE AsmFunctionType final : public AsmCallableType {\n public:\n  AsmFunctionType(const AsmFunctionType&) = delete;\n  AsmFunctionType& operator=(const AsmFunctionType&) = delete;\n\n  AsmFunctionType* AsFunctionType() final { return this; }\n\n  void AddArgument(AsmType* type) { args_.push_back(type); }\n  const ZoneVector<AsmType*>& Arguments() const { return args_; }\n  AsmType* ReturnType() const { return return_type_; }\n\n  bool CanBeInvokedWith(AsmType* return_type,\n                        const ZoneVector<AsmType*>& args) override;\n\n protected:\n  AsmFunctionType(Zone* zone, AsmType* return_type)\n      : return_type_(return_type), args_(zone) {}\n\n private:\n  friend AsmType;\n  friend Zone;\n\n  std::string Name() override;\n  bool IsA(AsmType* other) override;\n\n  AsmType* return_type_;\n  ZoneVector<AsmType*> args_;\n};"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "AsmOverloadedFunctionType",
        "extends": "AsmCallableType",
        "implements": [],
        "about": "Represents an overloaded function type in asm.js, allowing for multiple function signatures under the same name.",
        "attributes": [],
        "dependencies": [
          "AsmType"
        ]
      },
      "code": "class V8_EXPORT_PRIVATE AsmOverloadedFunctionType final\n    : public AsmCallableType {\n public:\n  AsmOverloadedFunctionType* AsOverloadedFunctionType() override {\n    return this;\n  }\n\n  void AddOverload(AsmType* overload);\n\n private:\n  friend AsmType;\n  friend Zone;\n\n  explicit AsmOverloadedFunctionType(Zone* zone) : overloads_(zone) {}\n\n  std::string Name() override;\n  bool CanBeInvokedWith(AsmType* return_type,\n                        const ZoneVector<AsmType*>& args) override;\n\n  ZoneVector<AsmType*> overloads_;\n\n  DISALLOW_IMPLICIT_CONSTRUCTORS(AsmOverloadedFunctionType);\n};"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "AsmType",
        "extends": null,
        "implements": [],
        "about": "Represents a type in asm.js, serving as the base class for both value types and callable types.  Provides methods for type creation, casting, and comparison.",
        "attributes": [],
        "dependencies": [
          "AsmValueType",
          "AsmCallableType",
          "AsmFunctionType",
          "AsmOverloadedFunctionType"
        ]
      },
      "code": "class V8_EXPORT_PRIVATE AsmType {\n public:\n#define DEFINE_CONSTRUCTOR(CamelName, string_name, number, parent_types) \\\n  static AsmType* CamelName() {                                          \\\n    return AsmValueType::New(AsmValueType::kAsm##CamelName);             \\\n  }\n  FOR_EACH_ASM_VALUE_TYPE_LIST(DEFINE_CONSTRUCTOR)\n#undef DEFINE_CONSTRUCTOR\n\n#define DEFINE_CAST(CamelCase)                                        \\\n  Asm##CamelCase* As##CamelCase() {                                   \\\n    if (AsValueType() != nullptr) {                                   \\\n      return nullptr;                                                 \\\n    }                                                                 \\\n    return reinterpret_cast<AsmCallableType*>(this)->As##CamelCase(); \\\n  }\n  FOR_EACH_ASM_CALLABLE_TYPE_LIST(DEFINE_CAST)\n#undef DEFINE_CAST\n  AsmValueType* AsValueType() { return AsmValueType::AsValueType(this); }\n  AsmCallableType* AsCallableType();\n\n  // A function returning ret. Callers still need to invoke AddArgument with the\n  // returned type to fully create this type.\n  static AsmType* Function(Zone* zone, AsmType* ret) {\n    AsmFunctionType* f = zone->New<AsmFunctionType>(zone, ret);\n    return reinterpret_cast<AsmType*>(f);\n  }\n\n  // Overloaded function types. Not creatable by asm source, but useful to\n  // represent the overloaded stdlib functions.\n  static AsmType* OverloadedFunction(Zone* zone) {\n    auto* f = zone->New<AsmOverloadedFunctionType>(zone);\n    return reinterpret_cast<AsmType*>(f);\n  }\n\n  // The type for fround(src).\n  static AsmType* FroundType(Zone* zone);\n\n  // The (variadic) type for min and max.\n  static AsmType* MinMaxType(Zone* zone, AsmType* dest, AsmType* src);\n\n  std::string Name();\n  // IsExactly returns true if x is the exact same type as y. For\n  // non-value types (e.g., callables), this returns x == y.\n  static bool IsExactly(AsmType* x, AsmType* y);\n  // IsA is used to query whether this is an instance of that (i.e., if this is\n  // a type derived from that.) For non-value types (e.g., callables), this\n  // returns this == that.\n  bool IsA(AsmType* that);\n\n  // The following methods are meant to be used for inspecting the traits of\n  // element types for the heap view types.\n  enum : int32_t { kNotHeapType = -1 };\n\n  // Returns the element size if this is a heap type. Otherwise returns\n  // kNotHeapType.\n  int32_t ElementSizeInBytes();\n  // Returns the load type if this is a heap type. AsmType::None is returned if\n  // this is not a heap type.\n  AsmType* LoadType();\n  // Returns the store type if this is a heap type. AsmType::None is returned if\n  // this is not a heap type.\n  AsmType* StoreType();\n};"
    }
  ],
  "dependencies": [
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "ZoneObject",
        "about": "Base class for objects allocated in a Zone (V8's memory management system)."
      },
      "code": "class ZoneObject {};",
      "type": "class"
    }
  ],
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-types.h"
}