{
  "metadata": {
    "path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-properties.h",
    "file_name": "node-properties.h",
    "language": "cpp",
    "purpose": "Defines the NodeProperties class, which provides utility functions for accessing and manipulating node inputs and properties in the Turbofan compiler graph."
  },
  "imports": {
    "metadata": {
      "language": "cpp",
      "purpose": "Includes necessary headers for code generation, global definitions, heap references, node representation, operator properties, and turbofan types."
    },
    "code": "#include \"src/codegen/machine-type.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/heap-refs.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/turbofan-types.h\""
  },
  "classes": [
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "NodeProperties",
        "extends": null,
        "implements": [],
        "about": "A facade that simplifies access to the different kinds of inputs to a node in the Turbofan graph.",
        "attributes": [],
        "dependencies": [
          "TFGraph",
          "Operator",
          "CommonOperatorBuilder",
          "Node",
          "OperatorProperties",
          "Type",
          "Edge",
          "IrOpcode",
          "JSHeapBroker",
          "Effect",
          "ZoneRefSet",
          "Map",
          "OptionalMapRef",
          "MachineRepresentation"
        ]
      },
      "code": "class V8_EXPORT_PRIVATE NodeProperties {\n public:\n  // ---------------------------------------------------------------------------\n  // Input layout.\n  // Inputs are always arranged in order as follows:\n  //     0 [ values, context, frame state, effects, control ] node->InputCount()\n\n  static int FirstValueIndex(const Node* node) { return 0; }\n  static int FirstContextIndex(Node* node) { return PastValueIndex(node); }\n  static int FirstFrameStateIndex(Node* node) { return PastContextIndex(node); }\n  static int FirstEffectIndex(Node* node) { return PastFrameStateIndex(node); }\n  static int FirstControlIndex(Node* node) { return PastEffectIndex(node); }\n\n  static int PastValueIndex(Node* node) {\n    return FirstValueIndex(node) + node->op()->ValueInputCount();\n  }\n\n  static int PastContextIndex(Node* node) {\n    return FirstContextIndex(node) +\n           OperatorProperties::GetContextInputCount(node->op());\n  }\n\n  static int PastFrameStateIndex(Node* node) {\n    return FirstFrameStateIndex(node) +\n           OperatorProperties::GetFrameStateInputCount(node->op());\n  }\n\n  static int PastEffectIndex(Node* node) {\n    return FirstEffectIndex(node) + node->op()->EffectInputCount();\n  }\n\n  static int PastControlIndex(Node* node) {\n    return FirstControlIndex(node) + node->op()->ControlInputCount();\n  }\n\n  // ---------------------------------------------------------------------------\n  // Input accessors.\n\n  static Node* GetValueInput(Node* node, int index) {\n    CHECK_LE(0, index);\n    CHECK_LT(index, node->op()->ValueInputCount());\n    return node->InputAt(FirstValueIndex(node) + index);\n  }\n\n  static const Node* GetValueInput(const Node* node, int index) {\n    CHECK_LE(0, index);\n    CHECK_LT(index, node->op()->ValueInputCount());\n    return node->InputAt(FirstValueIndex(node) + index);\n  }\n\n  static Node* GetContextInput(Node* node) {\n    CHECK(OperatorProperties::HasContextInput(node->op()));\n    return node->InputAt(FirstContextIndex(node));\n  }\n\n  static Node* GetFrameStateInput(Node* node) {\n    CHECK(OperatorProperties::HasFrameStateInput(node->op()));\n    return node->InputAt(FirstFrameStateIndex(node));\n  }\n\n  static Node* GetEffectInput(Node* node, int index = 0) {\n    CHECK_LE(0, index);\n    CHECK_LT(index, node->op()->EffectInputCount());\n    return node->InputAt(FirstEffectIndex(node) + index);\n  }\n\n  static Node* GetControlInput(Node* node, int index = 0) {\n    CHECK_LE(0, index);\n    CHECK_LT(index, node->op()->ControlInputCount());\n    return node->InputAt(FirstControlIndex(node) + index);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Edge kinds.\n\n  static bool IsValueEdge(Edge edge);\n  static bool IsContextEdge(Edge edge);\n  static bool IsFrameStateEdge(Edge edge);\n  static bool IsEffectEdge(Edge edge);\n  static bool IsControlEdge(Edge edge);\n\n  // ---------------------------------------------------------------------------\n  // Miscellaneous predicates.\n\n  static bool IsCommon(Node* node) {\n    return IrOpcode::IsCommonOpcode(node->opcode());\n  }\n  static bool IsControl(Node* node) {\n    return IrOpcode::IsControlOpcode(node->opcode());\n  }\n  static bool IsConstant(Node* node) {\n    return IrOpcode::IsConstantOpcode(node->opcode());\n  }\n  static bool IsPhi(Node* node) {\n    return IrOpcode::IsPhiOpcode(node->opcode());\n  }\n#if V8_ENABLE_WEBASSEMBLY\n  static bool IsSimd128Operation(Node* node) {\n    return IrOpcode::IsSimd128Opcode(node->opcode());\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n  // Determines whether exceptions thrown by the given node are handled locally\n  // within the graph (i.e. an IfException projection is present). Optionally\n  // the present IfException projection is returned via {out_exception}.\n  static bool IsExceptionalCall(Node* node, Node** out_exception = nullptr);\n\n  // Returns the node producing the successful control output of {node}. This is\n  // the IfSuccess projection of {node} if present and {node} itself otherwise.\n  static Node* FindSuccessfulControlProjection(Node* node);\n\n  // Returns whether the node acts as the identity function on a value\n  // input. The input that is passed through is returned via {out_value}.\n  static bool IsValueIdentity(Node* node, Node** out_value) {\n    switch (node->opcode()) {\n      case IrOpcode::kTypeGuard:\n        *out_value = GetValueInput(node, 0);\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // ----------------------------------------------------------------\u6c93\n  // Miscellaneous mutators.\n\n  static void ReplaceValueInput(Node* node, Node* value, int index);\n  static void ReplaceContextInput(Node* node, Node* context);\n  static void ReplaceControlInput(Node* node, Node* control, int index = 0);\n  static void ReplaceEffectInput(Node* node, Node* effect, int index = 0);\n  static void ReplaceFrameStateInput(Node* node, Node* frame_state);\n  static void RemoveNonValueInputs(Node* node);\n  static void RemoveValueInputs(Node* node);\n\n  // Replaces all value inputs of {node} with the single input {value}.\n  static void ReplaceValueInputs(Node* node, Node* value);\n\n  // Merge the control node {node} into the end of the graph, introducing a\n  // merge node or expanding an existing merge node if necessary.\n  static void MergeControlToEnd(TFGraph* graph, CommonOperatorBuilder* common,\n                                Node* node);\n\n  // Removes the control node {node} from the end of the graph, reducing the\n  // existing merge node's input count.\n  static void RemoveControlFromEnd(TFGraph* graph,\n                                   CommonOperatorBuilder* common, Node* node);\n\n  // Replace all uses of {node} with the given replacement nodes. All occurring\n  // use kinds need to be replaced, {nullptr} is only valid if a use kind is\n  // guaranteed not to exist.\n  static void ReplaceUses(Node* node, Node* value, Node* effect = nullptr,\n                          Node* success = nullptr, Node* exception = nullptr);\n\n  // Safe wrapper to mutate the operator of a node. Checks that the node is\n  // currently in a state that satisfies constraints of the new operator.\n  static void ChangeOp(Node* node, const Operator* new_op);\n  // Like `ChangeOp`, but without checking constraints.\n  static void ChangeOpUnchecked(Node* node, const Operator* new_op);\n\n  // ---------------------------------------------------------------------------\n  // Miscellaneous utilities.\n\n  // Find the last frame state that is effect-wise before the given node. This\n  // assumes a linear effect-chain up to a {CheckPoint} node in the graph.\n  // Returns {unreachable_sentinel} if {node} is determined to be unreachable.\n  static Node* FindFrameStateBefore(Node* node, Node* unreachable_sentinel);\n\n  // Collect the output-value projection for the given output index.\n  static Node* FindProjection(Node* node, size_t projection_index);\n\n  // Collect the value projections from a node.\n  static void CollectValueProjections(Node* node, Node** proj, size_t count);\n\n  // Collect the branch-related projections from a node, such as IfTrue,\n  // IfFalse, IfSuccess, IfException, IfValue and IfDefault.\n  //  - Branch: [ IfTrue, IfFalse ]\n  //  - Call  : [ IfSuccess, IfException ]\n  //  - Switch: [ IfValue, ..., IfDefault ]\n  static void CollectControlProjections(Node* node, Node** proj, size_t count);\n\n  // Return the MachineRepresentation of a Projection based on its input.\n  static MachineRepresentation GetProjectionType(Node const* projection);\n\n  // Checks if two nodes are the same, looking past {CheckHeapObject}.\n  static bool IsSame(Node* a, Node* b);\n\n  // Check if two nodes have equal operators and reference-equal inputs. Used\n  // for value numbering/hash-consing.\n  static bool Equals(Node* a, Node* b);\n  // A corresponding hash function.\n  static size_t HashCode(Node* node);\n\n  // Walks up the {effect} chain to find a witness that provides map\n  // information about the {receiver}. Can look through potentially\n  // side effecting nodes.\n  enum InferMapsResult {\n    kNoMaps,         // No maps inferred.\n    kReliableMaps,   // Maps can be trusted.\n    kUnreliableMaps  // Maps might have changed (side-effect).\n  };\n  // DO NOT USE InferMapsUnsafe IN NEW CODE. Use MapInference instead.\n  static InferMapsResult InferMapsUnsafe(JSHeapBroker* broker, Node* receiver,\n                                         Effect effect,\n                                         ZoneRefSet<Map>* maps_out);\n\n  // Return the initial map of the new-target if the allocation can be inlined.\n  static OptionalMapRef GetJSCreateMap(JSHeapBroker* broker, Node* receiver);\n\n  // Walks up the {effect} chain to check that there's no observable side-effect\n  // between the {effect} and it's {dominator}. Aborts the walk if there's join\n  // in the effect chain.\n  static bool NoObservableSideEffectBetween(Node* effect, Node* dominator);\n\n  // Returns true if the {receiver} can be a primitive value (i.e. is not\n  // definitely a JavaScript object); might walk up the {effect} chain to\n  // find map checks on {receiver}.\n  static bool CanBePrimitive(JSHeapBroker* broker, Node* receiver,\n                             Effect effect);\n\n  // Returns true if the {receiver} can be null or undefined. Might walk\n  // up the {effect} chain to find map checks for {receiver}.\n  static bool CanBeNullOrUndefined(JSHeapBroker* broker, Node* receiver,\n                                   Effect effect);\n\n  // ---------------------------------------------------------------------------\n  // Context.\n\n  // Walk up the context chain from the given {node} until we reduce the {depth}\n  // to 0 or hit a node that does not extend the context chain ({depth} will be\n  // updated accordingly).\n  static Node* GetOuterContext(Node* node, size_t* depth);\n\n  // ---------------------------------------------------------------------------\n  // Type.\n\n  static bool IsTyped(const Node* node) { return !node->type().IsInvalid(); }\n  static Type GetType(const Node* node) {\n    DCHECK(IsTyped(node));\n    return node->type();\n  }\n  static Type GetTypeOrAny(const Node* node);\n  static void SetType(Node* node, Type type) {\n    DCHECK(!type.IsInvalid());\n    node->set_type(type);\n  }\n  static void RemoveType(Node* node) { node->set_type(Type::Invalid()); }\n  static bool AllValueInputsAreTyped(Node* node);\n\n private:\n  static inline bool IsInputRange(Edge edge, int first, int count);\n};"
    }
  ],
  "dependencies": [
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "MachineRepresentation",
        "about": "Represents the machine representation of a value."
      },
      "code": "class MachineRepresentation {};",
      "type": "class"
    }
  ],
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-properties.h"
}