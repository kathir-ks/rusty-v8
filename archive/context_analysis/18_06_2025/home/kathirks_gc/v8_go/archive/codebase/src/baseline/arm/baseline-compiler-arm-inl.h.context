{
  "metadata": {
    "path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/arm/baseline-compiler-arm-inl.h",
    "file_name": "baseline-compiler-arm-inl.h",
    "language": "cpp",
    "purpose": "Provides ARM-specific inline implementations for the BaselineCompiler in V8."
  },
  "imports": {
    "metadata": {
      "language": "cpp",
      "purpose": "Includes logging utilities and the BaselineCompiler class definition."
    },
    "code": "#include \"src/base/logging.h\"\n#include \"src/baseline/baseline-compiler.h\""
  },
  "functions": [
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "Prologue",
        "parent": "BaselineCompiler",
        "about": "Generates the function prologue for baseline code on ARM.",
        "logic": "Enters a BASELINE stack frame, calls the out-of-line prologue builtin, and then calls PrologueFillFrame.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value"
        },
        "dependencies": [
          "CallBuiltin",
          "PrologueFillFrame"
        ]
      },
      "code": "void BaselineCompiler::Prologue() {\n  // Enter the frame here, since CallBuiltin will override lr.\n  __ masm()->EnterFrame(StackFrame::BASELINE);\n  DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);\n  int max_frame_size = bytecode_->max_frame_size();\n  CallBuiltin<Builtin::kBaselineOutOfLinePrologue>(\n      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,\n      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);\n\n  PrologueFillFrame();\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "PrologueFillFrame",
        "parent": "BaselineCompiler",
        "about": "Fills the register portion of the baseline frame with the accumulator register's value.",
        "logic": "Initializes registers in the frame. Optimizes for small frames by unrolling. Uses a loop for larger frames to improve code size.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value"
        },
        "dependencies": [
          "BaselineAssembler",
          "bytecode_"
        ]
      },
      "code": "void BaselineCompiler::PrologueFillFrame() {\n  ASM_CODE_COMMENT(&masm_);\n  // Inlined register frame fill\n  interpreter::Register new_target_or_generator_register =\n      bytecode_->incoming_new_target_or_generator_register();\n  if (v8_flags.debug_code) {\n    __ masm()->CompareRoot(kInterpreterAccumulatorRegister,\n                           RootIndex::kUndefinedValue);\n    __ masm()->Assert(eq, AbortReason::kUnexpectedValue);\n  }\n  int register_count = bytecode_->register_count();\n  // Magic value\n  const int kLoopUnrollSize = 8;\n  const int new_target_index = new_target_or_generator_register.index();\n  const bool has_new_target = new_target_index != kMaxInt;\n  if (has_new_target) {\n    DCHECK_LE(new_target_index, register_count);\n    for (int i = 0; i < new_target_index; i++) {\n      __ Push(kInterpreterAccumulatorRegister);\n    }\n    // Push new_target_or_generator.\n    __ Push(kJavaScriptCallNewTargetRegister);\n    register_count -= new_target_index + 1;\n  }\n  if (register_count < 2 * kLoopUnrollSize) {\n    // If the frame is small enough, just unroll the frame fill completely.\n    for (int i = 0; i < register_count; ++i) {\n      __ Push(kInterpreterAccumulatorRegister);\n    }\n\n  } else {\n    // Extract the first few registers to round to the unroll size.\n    int first_registers = register_count % kLoopUnrollSize;\n    for (int i = 0; i < first_registers; ++i) {\n      __ Push(kInterpreterAccumulatorRegister);\n    }\n    BaselineAssembler::ScratchRegisterScope temps(&basm_);\n    Register scratch = temps.AcquireScratch();\n\n    __ Move(scratch, register_count / kLoopUnrollSize);\n    // We enter the loop unconditionally, so make sure we need to loop at least\n    // once.\n    DCHECK_GT(register_count / kLoopUnrollSize, 0);\n    Label loop;\n    __ Bind(&loop);\n    for (int i = 0; i < kLoopUnrollSize; ++i) {\n      __ Push(kInterpreterAccumulatorRegister);\n    }\n    __ masm()->sub(scratch, scratch, Operand(1), SetCC);\n    __ masm()->b(gt, &loop);\n  }\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "VerifyFrameSize",
        "parent": "BaselineCompiler",
        "about": "Verifies the frame size against the expected frame size based on the bytecode.",
        "logic": "Calculates the expected stack pointer based on the frame size and compares it with the frame pointer, asserting if they are not equal.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value"
        },
        "dependencies": [
          "BaselineAssembler",
          "bytecode_"
        ]
      },
      "code": "void BaselineCompiler::VerifyFrameSize() {\n  BaselineAssembler::ScratchRegisterScope temps(&basm_);\n  Register scratch = temps.AcquireScratch();\n\n  __ masm()->add(scratch, sp,\n                 Operand(InterpreterFrameConstants::kFixedFrameSizeFromFp +\n                         bytecode_->frame_size()));\n  __ masm()->cmp(scratch, fp);\n  __ masm()->Assert(eq, AbortReason::kUnexpectedStackPointer);\n}"
    }
  ],
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/arm/baseline-compiler-arm-inl.h"
}