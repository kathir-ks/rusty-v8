{
  "metadata": {
    "path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/x64/baseline-compiler-x64-inl.h",
    "file_name": "baseline-compiler-x64-inl.h",
    "language": "cpp",
    "purpose": "Inline implementation details for the x64 BaselineCompiler in V8"
  },
  "imports": {
    "metadata": {
      "language": "cpp",
      "purpose": "Includes necessary headers for macros, baseline compilation, and interface descriptors"
    },
    "code": "#include \"src/base/macros.h\"\n#include \"src/baseline/baseline-compiler.h\"\n#include \"src/codegen/interface-descriptors.h\""
  },
  "functions": [
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "Prologue",
        "parent": "BaselineCompiler",
        "about": "Generates the function prologue for baseline-compiled code on x64.",
        "logic": "Calls the BaselineOutOfLinePrologue builtin and fills the stack frame.  Includes a placeholder for deoptimization if CET shadow stack is enabled.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value"
        },
        "dependencies": [
          "Builtin::kBaselineOutOfLinePrologue",
          "PrologueFillFrame",
          "kContextRegister",
          "kJSFunctionRegister",
          "kJavaScriptCallArgCountRegister",
          "kJavaScriptCallNewTargetRegister",
          "bytecode_"
        ]
      },
      "code": "void BaselineCompiler::Prologue() {\n  ASM_CODE_COMMENT(&masm_);\n  DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);\n  int max_frame_size = bytecode_->max_frame_size();\n  CallBuiltin<Builtin::kBaselineOutOfLinePrologue>(\n      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,\n      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);\n#ifdef V8_ENABLE_CET_SHADOW_STACK\n  __ MaybeEmitPlaceHolderForDeopt();\n#endif  // V8_ENABLE_CET_SHADOW_STACK\n\n  PrologueFillFrame();\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "PrologueFillFrame",
        "parent": "BaselineCompiler",
        "about": "Fills the stack frame with the accumulator register value during the function prologue.",
        "logic": "Initializes the registers in the stack frame by pushing the accumulator register onto the stack. Uses loop unrolling for efficiency.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value"
        },
        "dependencies": [
          "bytecode_",
          "kInterpreterAccumulatorRegister",
          "kJavaScriptCallNewTargetRegister",
          "ReadOnlyRoots",
          "handle"
        ]
      },
      "code": "void BaselineCompiler::PrologueFillFrame() {\n  ASM_CODE_COMMENT(&masm_);\n  // Inlined register frame fill\n  interpreter::Register new_target_or_generator_register =\n      bytecode_->incoming_new_target_or_generator_register();\n  if (v8_flags.debug_code) {\n    __ masm()->Cmp(kInterpreterAccumulatorRegister,\n                   handle(ReadOnlyRoots(local_isolate_).undefined_value(),\n                          local_isolate_));\n    __ masm()->Assert(equal, AbortReason::kUnexpectedValue);\n  }\n  int register_count = bytecode_->register_count();\n  // Magic value\n  const int kLoopUnrollSize = 8;\n  const int new_target_index = new_target_or_generator_register.index();\n  const bool has_new_target = new_target_index != kMaxInt;\n  if (has_new_target) {\n    DCHECK_LE(new_target_index, register_count);\n    for (int i = 0; i < new_target_index; i++) {\n      __ Push(kInterpreterAccumulatorRegister);\n    }\n    // Push new_target_or_generator.\n    __ Push(kJavaScriptCallNewTargetRegister);\n    register_count -= new_target_index + 1;\n  }\n  if (register_count < 2 * kLoopUnrollSize) {\n    // If the frame is small enough, just unroll the frame fill completely.\n    for (int i = 0; i < register_count; ++i) {\n      __ Push(kInterpreterAccumulatorRegister);\n    }\n  } else {\n    // Extract the first few registers to round to the unroll size.\n    int first_registers = register_count % kLoopUnrollSize;\n    for (int i = 0; i < first_registers; ++i) {\n      __ Push(kInterpreterAccumulatorRegister);\n    }\n    BaselineAssembler::ScratchRegisterScope scope(&basm_);\n    Register scratch = scope.AcquireScratch();\n    __ Move(scratch, register_count / kLoopUnrollSize);\n    // We enter the loop unconditionally, so make sure we need to loop at least\n    // once.\n    DCHECK_GT(register_count / kLoopUnrollSize, 0);\n    Label loop;\n    __ Bind(&loop);\n    for (int i = 0; i < kLoopUnrollSize; ++i) {\n      __ Push(kInterpreterAccumulatorRegister);\n    }\n    __ masm()->decl(scratch);\n    __ masm()->j(greater, &loop);\n  }\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "VerifyFrameSize",
        "parent": "BaselineCompiler",
        "about": "Verifies that the stack frame size matches the expected size.",
        "logic": "Compares the calculated stack pointer based on frame size and the frame pointer to ensure the frame size is correct.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value"
        },
        "dependencies": [
          "kScratchRegister",
          "rsp",
          "InterpreterFrameConstants::kFixedFrameSizeFromFp",
          "bytecode_",
          "rbp"
        ]
      },
      "code": "void BaselineCompiler::VerifyFrameSize() {\n  ASM_CODE_COMMENT(&masm_);\n  __ Move(kScratchRegister, rsp);\n  __ masm()->addq(kScratchRegister,\n                  Immediate(InterpreterFrameConstants::kFixedFrameSizeFromFp +\n                            bytecode_->frame_size()));\n  __ masm()->cmpq(kScratchRegister, rbp);\n  __ masm()->Assert(equal, AbortReason::kUnexpectedStackPointer);\n}"
    }
  ],
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/x64/baseline-compiler-x64-inl.h"
}