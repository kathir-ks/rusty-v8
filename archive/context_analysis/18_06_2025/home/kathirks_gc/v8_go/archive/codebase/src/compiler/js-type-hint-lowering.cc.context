{
  "metadata": {
    "path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-type-hint-lowering.cc",
    "file_name": "js-type-hint-lowering.cc",
    "language": "cpp",
    "purpose": "Implements type hint lowering for JavaScript operations in the V8 compiler. It uses feedback from the runtime to specialize operations based on observed types, improving performance."
  },
  "imports": {
    "metadata": {
      "language": "cpp",
      "purpose": "Includes necessary header files for logging, graph manipulation, heap access, opcodes, operator properties, simplified operators, and type hints."
    },
    "code": "#include \"src/compiler/js-type-hint-lowering.h\"\n\n#include \"src/base/logging.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/objects/type-hints.h\""
  },
  "functions": [
    {
      "metadata": {
        "language": "cpp",
        "type": "function",
        "name": "BinaryOperationHintToNumberOperationHint",
        "about": "Converts a BinaryOperationHint to a NumberOperationHint.",
        "logic": "Maps BinaryOperationHint values to corresponding NumberOperationHint values. Returns true if a conversion is possible, false otherwise.",
        "parameters": [
          {
            "name": "binop_hint",
            "type": "BinaryOperationHint",
            "purpose": "The binary operation hint to convert."
          },
          {
            "name": "number_hint",
            "type": "NumberOperationHint*",
            "purpose": "A pointer to the NumberOperationHint to store the result in."
          }
        ],
        "return": {
          "type": "bool",
          "description": "True if the conversion was successful, false otherwise."
        },
        "dependencies": []
      },
      "code": "bool BinaryOperationHintToNumberOperationHint(\n    BinaryOperationHint binop_hint, NumberOperationHint* number_hint) {\n  switch (binop_hint) {\n    case BinaryOperationHint::kSignedSmall:\n      *number_hint = NumberOperationHint::kSignedSmall;\n      return true;\n    case BinaryOperationHint::kSignedSmallInputs:\n      *number_hint = NumberOperationHint::kSignedSmallInputs;\n      return true;\n    case BinaryOperationHint::kAdditiveSafeInteger:\n      *number_hint = NumberOperationHint::kAdditiveSafeInteger;\n      return true;\n    case BinaryOperationHint::kNumber:\n      *number_hint = NumberOperationHint::kNumber;\n      return true;\n    case BinaryOperationHint::kNumberOrOddball:\n      *number_hint = NumberOperationHint::kNumberOrOddball;\n      return true;\n    case BinaryOperationHint::kAny:\n    case BinaryOperationHint::kNone:\n    case BinaryOperationHint::kString:\n    case BinaryOperationHint::kStringOrStringWrapper:\n    case BinaryOperationHint::kBigInt:\n    case BinaryOperationHint::kBigInt64:\n      break;\n  }\n  return false;\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "function",
        "name": "BinaryOperationHintToBigIntOperationHint",
        "about": "Converts a BinaryOperationHint to a BigIntOperationHint.",
        "logic": "Maps BinaryOperationHint values to corresponding BigIntOperationHint values. Returns true if a conversion is possible, false otherwise.",
        "parameters": [
          {
            "name": "binop_hint",
            "type": "BinaryOperationHint",
            "purpose": "The binary operation hint to convert."
          },
          {
            "name": "bigint_hint",
            "type": "BigIntOperationHint*",
            "purpose": "A pointer to the BigIntOperationHint to store the result in."
          }
        ],
        "return": {
          "type": "bool",
          "description": "True if the conversion was successful, false otherwise."
        },
        "dependencies": []
      },
      "code": "bool BinaryOperationHintToBigIntOperationHint(\n    BinaryOperationHint binop_hint, BigIntOperationHint* bigint_hint) {\n  switch (binop_hint) {\n    case BinaryOperationHint::kSignedSmall:\n    case BinaryOperationHint::kSignedSmallInputs:\n    case BinaryOperationHint::kAdditiveSafeInteger:\n    case BinaryOperationHint::kNumber:\n    case BinaryOperationHint::kNumberOrOddball:\n    case BinaryOperationHint::kAny:\n    case BinaryOperationHint::kNone:\n    case BinaryOperationHint::kString:\n    case BinaryOperationHint::kStringOrStringWrapper:\n      return false;\n    case BinaryOperationHint::kBigInt64:\n      *bigint_hint = BigIntOperationHint::kBigInt64;\n      return true;\n    case BinaryOperationHint::kBigInt:\n      *bigint_hint = BigIntOperationHint::kBigInt;\n      return true;\n  }\n  UNREACHABLE();\n}"
    }
  ],
  "classes": [
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "JSSpeculativeBinopBuilder",
        "about": "A helper class for building speculative binary operations based on type feedback.",
        "attributes": [],
        "dependencies": [
          "JSTypeHintLowering",
          "Operator",
          "Node",
          "FeedbackSlot"
        ]
      },
      "code": "class JSSpeculativeBinopBuilder final {\n public:\n  JSSpeculativeBinopBuilder(const JSTypeHintLowering* lowering,\n                            const Operator* op, Node* left, Node* right,\n                            Node* effect, Node* control, FeedbackSlot slot)\n      : lowering_(lowering),\n        op_(op),\n        left_(left),\n        right_(right),\n        effect_(effect),\n        control_(control),\n        slot_(slot) {}\n\n  bool GetBinaryNumberOperationHint(NumberOperationHint* hint) {\n    return BinaryOperationHintToNumberOperationHint(GetBinaryOperationHint(),\n                                                    hint);\n  }\n\n  bool GetBinaryBigIntOperationHint(BigIntOperationHint* hint) {\n    return BinaryOperationHintToBigIntOperationHint(GetBinaryOperationHint(),\n                                                    hint);\n  }\n\n  bool GetCompareNumberOperationHint(NumberOperationHint* hint) {\n    switch (GetCompareOperationHint()) {\n      case CompareOperationHint::kSignedSmall:\n        *hint = NumberOperationHint::kSignedSmall;\n        return true;\n      case CompareOperationHint::kNumber:\n        *hint = NumberOperationHint::kNumber;\n        return true;\n      case CompareOperationHint::kNumberOrBoolean:\n        *hint = NumberOperationHint::kNumberOrBoolean;\n        return true;\n      case CompareOperationHint::kNumberOrOddball:\n        *hint = NumberOperationHint::kNumberOrOddball;\n        return true;\n      case CompareOperationHint::kAny:\n      case CompareOperationHint::kNone:\n      case CompareOperationHint::kString:\n      case CompareOperationHint::kSymbol:\n      case CompareOperationHint::kBigInt:\n      case CompareOperationHint::kBigInt64:\n      case CompareOperationHint::kReceiver:\n      case CompareOperationHint::kReceiverOrNullOrUndefined:\n      case CompareOperationHint::kInternalizedString:\n        break;\n    }\n    return false;\n  }\n\n  bool GetCompareBigIntOperationHint(BigIntOperationHint* hint) {\n    switch (GetCompareOperationHint()) {\n      case CompareOperationHint::kSignedSmall:\n      case CompareOperationHint::kNumber:\n      case CompareOperationHint::kNumberOrBoolean:\n      case CompareOperationHint::kNumberOrOddball:\n      case CompareOperationHint::kAny:\n      case CompareOperationHint::kNone:\n      case CompareOperationHint::kString:\n      case CompareOperationHint::kSymbol:\n      case CompareOperationHint::kReceiver:\n      case CompareOperationHint::kReceiverOrNullOrUndefined:\n      case CompareOperationHint::kInternalizedString:\n        return false;\n      case CompareOperationHint::kBigInt:\n        *hint = BigIntOperationHint::kBigInt;\n        return true;\n      case CompareOperationHint::kBigInt64:\n        *hint = BigIntOperationHint::kBigInt64;\n        return true;\n    }\n  }\n\n  const Operator* SpeculativeNumberOp(NumberOperationHint hint) {\n    switch (op_->opcode()) {\n      case IrOpcode::kJSAdd:\n        if (hint == NumberOperationHint::kSignedSmall) {\n          return simplified()->SpeculativeSmallIntegerAdd(hint);\n        } else if (hint == NumberOperationHint::kAdditiveSafeInteger) {\n          return simplified()->SpeculativeAdditiveSafeIntegerAdd(hint);\n        } else {\n          return simplified()->SpeculativeNumberAdd(hint);\n        }\n      case IrOpcode::kJSSubtract:\n        if (hint == NumberOperationHint::kSignedSmall) {\n          return simplified()->SpeculativeSmallIntegerSubtract(hint);\n        } else if (hint == NumberOperationHint::kAdditiveSafeInteger) {\n          return simplified()->SpeculativeAdditiveSafeIntegerSubtract(hint);\n        } else {\n          return simplified()->SpeculativeNumberSubtract(hint);\n        }\n      case IrOpcode::kJSMultiply:\n        return simplified()->SpeculativeNumberMultiply(hint);\n      case IrOpcode::kJSExponentiate:\n        return simplified()->SpeculativeNumberPow(hint);\n      case IrOpcode::kJSDivide:\n        return simplified()->SpeculativeNumberDivide(hint);\n      case IrOpcode::kJSModulus:\n        return simplified()->SpeculativeNumberModulus(hint);\n      case IrOpcode::kJSBitwiseAnd:\n        return simplified()->SpeculativeNumberBitwiseAnd(hint);\n      case IrOpcode::kJSBitwiseOr:\n        return simplified()->SpeculativeNumberBitwiseOr(hint);\n      case IrOpcode::kJSBitwiseXor:\n        return simplified()->SpeculativeNumberBitwiseXor(hint);\n      case IrOpcode::kJSShiftLeft:\n        return simplified()->SpeculativeNumberShiftLeft(hint);\n      case IrOpcode::kJSShiftRight:\n        return simplified()->SpeculativeNumberShiftRight(hint);\n      case IrOpcode::kJSShiftRightLogical:\n        return simplified()->SpeculativeNumberShiftRightLogical(hint);\n      default:\n        break;\n    }\n    UNREACHABLE();\n  }\n\n  const Operator* SpeculativeBigIntOp(BigIntOperationHint hint) {\n    switch (op_->opcode()) {\n      case IrOpcode::kJSAdd:\n        return simplified()->SpeculativeBigIntAdd(hint);\n      case IrOpcode::kJSSubtract:\n        return simplified()->SpeculativeBigIntSubtract(hint);\n      case IrOpcode::kJSMultiply:\n        return simplified()->SpeculativeBigIntMultiply(hint);\n      case IrOpcode::kJSDivide:\n        return simplified()->SpeculativeBigIntDivide(hint);\n      case IrOpcode::kJSModulus:\n        return simplified()->SpeculativeBigIntModulus(hint);\n      case IrOpcode::kJSBitwiseAnd:\n        return simplified()->SpeculativeBigIntBitwiseAnd(hint);\n      case IrOpcode::kJSBitwiseOr:\n        return simplified()->SpeculativeBigIntBitwiseOr(hint);\n      case IrOpcode::kJSBitwiseXor:\n        return simplified()->SpeculativeBigIntBitwiseXor(hint);\n      case IrOpcode::kJSShiftLeft:\n        return simplified()->SpeculativeBigIntShiftLeft(hint);\n      case IrOpcode::kJSShiftRight:\n        return simplified()->SpeculativeBigIntShiftRight(hint);\n      default:\n        break;\n    }\n    UNREACHABLE();\n  }\n\n  const Operator* SpeculativeNumberCompareOp(NumberOperationHint hint) {\n    switch (op_->opcode()) {\n      case IrOpcode::kJSEqual:\n        return simplified()->SpeculativeNumberEqual(hint);\n      case IrOpcode::kJSLessThan:\n        return simplified()->SpeculativeNumberLessThan(hint);\n      case IrOpcode::kJSGreaterThan:\n        std::swap(left_, right_);  // a > b => b < a\n        return simplified()->SpeculativeNumberLessThan(hint);\n      case IrOpcode::kJSLessThanOrEqual:\n        return simplified()->SpeculativeNumberLessThanOrEqual(hint);\n      case IrOpcode::kJSGreaterThanOrEqual:\n        std::swap(left_, right_);  // a >= b => b <= a\n        return simplified()->SpeculativeNumberLessThanOrEqual(hint);\n      default:\n        break;\n    }\n    UNREACHABLE();\n  }\n\n  const Operator* SpeculativeBigIntCompareOp(BigIntOperationHint hint) {\n    switch (op_->opcode()) {\n      case IrOpcode::kJSEqual:\n        return simplified()->SpeculativeBigIntEqual(hint);\n      case IrOpcode::kJSLessThan:\n        return simplified()->SpeculativeBigIntLessThan(hint);\n      case IrOpcode::kJSGreaterThan:\n        std::swap(left_, right_);\n        return simplified()->SpeculativeBigIntLessThan(hint);\n      case IrOpcode::kJSLessThanOrEqual:\n        return simplified()->SpeculativeBigIntLessThanOrEqual(hint);\n      case IrOpcode::kJSGreaterThanOrEqual:\n        std::swap(left_, right_);\n        return simplified()->SpeculativeBigIntLessThanOrEqual(hint);\n      default:\n        break;\n    }\n    UNREACHABLE();\n  }\n\n  Node* BuildSpeculativeOperation(const Operator* op) {\n    DCHECK_EQ(2, op->ValueInputCount());\n    DCHECK_EQ(1, op->EffectInputCount());\n    DCHECK_EQ(1, op->ControlInputCount());\n    DCHECK_EQ(false, OperatorProperties::HasFrameStateInput(op));\n    DCHECK_EQ(false, OperatorProperties::HasContextInput(op));\n    DCHECK_EQ(1, op->EffectOutputCount());\n    DCHECK_EQ(0, op->ControlOutputCount());\n    return graph()->NewNode(op, left_, right_, effect_, control_);\n  }\n\n  Node* TryBuildNumberBinop() {\n    NumberOperationHint hint;\n    if (GetBinaryNumberOperationHint(&hint)) {\n      const Operator* op = SpeculativeNumberOp(hint);\n      Node* node = BuildSpeculativeOperation(op);\n      return node;\n    }\n    return nullptr;\n  }\n\n  Node* TryBuildBigIntBinop() {\n    BigIntOperationHint hint;\n    if (GetBinaryBigIntOperationHint(&hint)) {\n      const Operator* op = SpeculativeBigIntOp(hint);\n      Node* node = BuildSpeculativeOperation(op);\n      return node;\n    }\n    return nullptr;\n  }\n\n  Node* TryBuildNumberCompare() {\n    NumberOperationHint hint;\n    if (GetCompareNumberOperationHint(&hint)) {\n      const Operator* op = SpeculativeNumberCompareOp(hint);\n      Node* node = BuildSpeculativeOperation(op);\n      return node;\n    }\n    return nullptr;\n  }\n\n  Node* TryBuildBigIntCompare() {\n    BigIntOperationHint hint;\n    if (GetCompareBigIntOperationHint(&hint)) {\n      const Operator* op = SpeculativeBigIntCompareOp(hint);\n      Node* node = BuildSpeculativeOperation(op);\n      return node;\n    }\n    return nullptr;\n  }\n\n  JSGraph* jsgraph() const { return lowering_->jsgraph(); }\n  Isolate* isolate() const { return jsgraph()->isolate(); }\n  TFGraph* graph() const { return jsgraph()->graph(); }\n  JSOperatorBuilder* javascript() { return jsgraph()->javascript(); }\n  SimplifiedOperatorBuilder* simplified() { return jsgraph()->simplified(); }\n  CommonOperatorBuilder* common() { return jsgraph()->common(); }\n\n private:\n  BinaryOperationHint GetBinaryOperationHint() {\n    return lowering_->GetBinaryOperationHint(slot_);\n  }\n\n  CompareOperationHint GetCompareOperationHint() {\n    return lowering_->GetCompareOperationHint(slot_);\n  }\n\n  JSTypeHintLowering const* const lowering_;\n  Operator const* const op_;\n  Node* left_;\n  Node* right_;\n  Node* const effect_;\n  Node* const control_;\n  FeedbackSlot const slot_;\n};"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "JSTypeHintLowering",
        "about": "Performs type hint lowering for JavaScript operations, specializing them based on runtime feedback.",
        "attributes": [],
        "dependencies": [
          "JSHeapBroker",
          "JSGraph",
          "FeedbackVectorRef",
          "FeedbackSlot"
        ]
      },
      "code": "class JSTypeHintLowering final {\n public:\n  JSTypeHintLowering(JSHeapBroker* broker, JSGraph* jsgraph,\n                                       FeedbackVectorRef feedback_vector,\n                                       Flags flags)\n    : broker_(broker),\n      jsgraph_(jsgraph),\n      flags_(flags),\n      feedback_vector_(feedback_vector) {}\n\n  Isolate* isolate() const { return jsgraph()->isolate(); }\n\n  BinaryOperationHint GetBinaryOperationHint(\n    FeedbackSlot slot) const {\n  FeedbackSource source(feedback_vector(), slot);\n  return broker()->GetFeedbackForBinaryOperation(source);\n}\n\nCompareOperationHint GetCompareOperationHint(\n    FeedbackSlot slot) const {\n  FeedbackSource source(feedback_vector(), slot);\n  return broker()->GetFeedbackForCompareOperation(source);\n}\n\nJSTypeHintLowering::LoweringResult ReduceUnaryOperation(\n    const Operator* op, Node* operand, Node* effect, Node* control,\n    FeedbackSlot slot) const {\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForUnaryOperation)) {\n    return LoweringResult::Exit(node);\n  }\n\n  // Note: Unary and binary operations collect the same kind of feedback.\n  FeedbackSource feedback(feedback_vector(), slot);\n\n  Node* node;\n  Node* check = nullptr;\n  switch (op->opcode()) {\n    case IrOpcode::kJSBitwiseNot: {\n      // Lower to a speculative xor with -1 if we have some kind of Number\n      // feedback.\n      JSSpeculativeBinopBuilder b(\n          this, jsgraph()->javascript()->BitwiseXor(feedback), operand,\n          jsgraph()->SmiConstant(-1), effect, control, slot);\n      node = b.TryBuildNumberBinop();\n      break;\n    }\n    case IrOpcode::kJSDecrement: {\n      // Lower to a speculative subtraction of 1 if we have some kind of Number\n      // feedback.\n      JSSpeculativeBinopBuilder b(\n          this, jsgraph()->javascript()->Subtract(feedback), operand,\n          jsgraph()->SmiConstant(1), effect, control, slot);\n      node = b.TryBuildNumberBinop();\n      break;\n    }\n    case IrOpcode::kJSIncrement: {\n      // Lower to a speculative addition of 1 if we have some kind of Number\n      // feedback.\n      JSSpeculativeBinopBuilder b(this, jsgraph()->javascript()->Add(feedback),\n                                  operand, jsgraph()->SmiConstant(1), effect,\n                                  control, slot);\n      node = b.TryBuildNumberBinop();\n      break;\n    }\n    case IrOpcode::kJSNegate: {\n      // Lower to a speculative multiplication with -1 if we have some kind of\n      // Number feedback.\n      JSSpeculativeBinopBuilder b(\n          this, jsgraph()->javascript()->Multiply(feedback), operand,\n          jsgraph()->SmiConstant(-1), effect, control, slot);\n      node = b.TryBuildNumberBinop();\n      if (!node) {\n        if (jsgraph()->machine()->Is64()) {\n          if (GetBinaryOperationHint(slot) == BinaryOperationHint::kBigInt) {\n            op = jsgraph()->simplified()->SpeculativeBigIntNegate(\n                BigIntOperationHint::kBigInt);\n            node = jsgraph()->graph()->NewNode(op, operand, effect, control);\n          }\n        }\n      }\n      break;\n    }\n    case IrOpcode::kTypeOf: {\n      TypeOfFeedback::Result hint = broker()->GetFeedbackForTypeOf(feedback);\n      switch (hint) {\n        case TypeOfFeedback::kNumber:\n          check = jsgraph()->graph()->NewNode(\n              jsgraph()->simplified()->CheckNumber(FeedbackSource()), operand,\n              effect, control);\n          node = jsgraph()->ConstantNoHole(broker()->number_string(), broker());\n          break;\n        case TypeOfFeedback::kString:\n          check = jsgraph()->graph()->NewNode(\n              jsgraph()->simplified()->CheckString(FeedbackSource()), operand,\n              effect, control);\n          node = jsgraph()->ConstantNoHole(broker()->string_string(), broker());\n          break;\n        case TypeOfFeedback::kFunction: {\n          Node* condition = jsgraph()->graph()->NewNode(\n              jsgraph()->simplified()->ObjectIsDetectableCallable(), operand);\n          check = jsgraph()->graph()->NewNode(\n              jsgraph()->simplified()->CheckIf(\n                  DeoptimizeReason::kNotDetectableReceiver, FeedbackSource()),\n              condition, effect, control);\n          node =\n              jsgraph()->ConstantNoHole(broker()->function_string(), broker());\n          break;\n        }\n        default:\n          node = nullptr;\n          break;\n      }\n      break;\n    }\n    default:\n      UNREACHABLE();\n  }\n\n  if (node != nullptr) {\n    return LoweringResult::SideEffectFree(node, check ? check : node, control);\n  } else {\n    return LoweringResult::NoChange();\n  }\n}\n\nJSTypeHintLowering::LoweringResult ReduceBinaryOperation(\n    const Operator* op, Node* left, Node* right, Node* effect, Node* control,\n    FeedbackSlot slot) const {\n  switch (op->opcode()) {\n    case IrOpcode::kJSStrictEqual: {\n      if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n              slot, effect, control,\n              DeoptimizeReason::kInsufficientTypeFeedbackForCompareOperation)) {\n        return LoweringResult::Exit(node);\n      }\n      // TODO(turbofan): Should we generally support early lowering of\n      // JSStrictEqual operators here?\n      break;\n    }\n    case IrOpcode::kJSEqual:\n    case IrOpcode::kJSLessThan:\n    case IrOpcode::kJSGreaterThan:\n    case IrOpcode::kJSLessThanOrEqual:\n    case IrOpcode::kJSGreaterThanOrEqual: {\n      if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n              slot, effect, control,\n              DeoptimizeReason::kInsufficientTypeFeedbackForCompareOperation)) {\n        return LoweringResult::Exit(node);\n      }\n      JSSpeculativeBinopBuilder b(this, op, left, right, effect, control, slot);\n      if (Node* node = b.TryBuildNumberCompare()) {\n        return LoweringResult::SideEffectFree(node, node, control);\n      }\n      if (Node* node = b.TryBuildBigIntCompare()) {\n        return LoweringResult::SideEffectFree(node, node, control);\n      }\n      break;\n    }\n    case IrOpcode::kJSInstanceOf: {\n      if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n              slot, effect, control,\n              DeoptimizeReason::kInsufficientTypeFeedbackForCompareOperation)) {\n        return LoweringResult::Exit(node);\n      }\n      // TODO(turbofan): Should we generally support early lowering of\n      // JSInstanceOf operators here?\n      break;\n    }\n    case IrOpcode::kJSBitwiseOr:\n    case IrOpcode::kJSBitwiseXor:\n    case IrOpcode::kJSBitwiseAnd:\n    case IrOpcode::kJSShiftLeft:\n    case IrOpcode::kJSShiftRight:\n    case IrOpcode::kJSShiftRightLogical:\n    case IrOpcode::kJSAdd:\n    case IrOpcode::kJSSubtract:\n    case IrOpcode::kJSMultiply:\n    case IrOpcode::kJSDivide:\n    case IrOpcode::kJSModulus:\n    case IrOpcode::kJSExponentiate: {\n      if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n              slot, effect, control,\n              DeoptimizeReason::kInsufficientTypeFeedbackForBinaryOperation)) {\n        return LoweringResult::Exit(node);\n      }\n      JSSpeculativeBinopBuilder b(this, op, left, right, effect, control, slot);\n      if (Node* node = b.TryBuildNumberBinop()) {\n        return LoweringResult::SideEffectFree(node, node, control);\n      }\n      if (op->opcode() != IrOpcode::kJSShiftRightLogical &&\n          op->opcode() != IrOpcode::kJSExponentiate) {\n        if (Node* node = b.TryBuildBigIntBinop()) {\n          return LoweringResult::SideEffectFree(node, node, control);\n        }\n      }\n      break;\n    }\n    default:\n      UNREACHABLE();\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult ReduceForInNextOperation(\n    Node* receiver, Node* cache_array, Node* cache_type, Node* index,\n    Node* effect, Node* control, FeedbackSlot slot) const {\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForForIn)) {\n    return LoweringResult::Exit(node);\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult\nJSTypeHintLowering::ReduceForInPrepareOperation(Node* enumerator, Node* effect,\n                                                Node* control,\n                                                FeedbackSlot slot) const {\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForForIn)) {\n    return LoweringResult::Exit(node);\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult ReduceToNumberOperation(\n    Node* input, Node* effect, Node* control, FeedbackSlot slot) const {\n  DCHECK(!slot.IsInvalid());\n  NumberOperationHint hint;\n  if (BinaryOperationHintToNumberOperationHint(GetBinaryOperationHint(slot),\n                                               &hint)) {\n    Node* node = jsgraph()->graph()->NewNode(\n        jsgraph()->simplified()->SpeculativeToNumber(hint, FeedbackSource()),\n        input, effect, control);\n    return LoweringResult::SideEffectFree(node, node, control);\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult ReduceCallOperation(\n    const Operator* op, Node* const* args, int arg_count, Node* effect,\n    Node* control, FeedbackSlot slot) const {\n  DCHECK(op->opcode() == IrOpcode::kJSCall ||\n         op->opcode() == IrOpcode::kJSCallWithSpread);\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForCall)) {\n    return LoweringResult::Exit(node);\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult ReduceConstructOperation(\n    const Operator* op, Node* const* args, int arg_count, Node* effect,\n    Node* control, FeedbackSlot slot) const {\n  DCHECK(op->opcode() == IrOpcode::kJSConstruct ||\n         op->opcode() == IrOpcode::kJSConstructWithSpread ||\n         op->opcode() == IrOpcode::kJSConstructForwardAllArgs);\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForConstruct)) {\n    return LoweringResult::Exit(node);\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult\nJSTypeHintLowering::ReduceGetIteratorOperation(const Operator* op,\n                                               Node* receiver, Node* effect,\n                                               Node* control,\n                                               FeedbackSlot load_slot,\n                                               FeedbackSlot call_slot) const {\n  DCHECK_EQ(IrOpcode::kJSGetIterator, op->opcode());\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          load_slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForGenericNamedAccess)) {\n    return LoweringResult::Exit(node);\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult ReduceLoadNamedOperation(\n    const Operator* op, Node* effect, Node* control, FeedbackSlot slot) const {\n  DCHECK(op->opcode() == IrOpcode::kJSLoadNamed ||\n         op->opcode() == IrOpcode::kJSLoadNamedFromSuper);\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForGenericNamedAccess)) {\n    return LoweringResult::Exit(node);\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult ReduceLoadKeyedOperation(\n    const Operator* op, Node* obj, Node* key, Node* effect, Node* control,\n    FeedbackSlot slot) const {\n  DCHECK_EQ(IrOpcode::kJSLoadProperty, op->opcode());\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForGenericKeyedAccess)) {\n    return LoweringResult::Exit(node);\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult\nJSTypeHintLowering::ReduceStoreNamedOperation(const Operator* op, Node* obj,\n                                              Node* val, Node* effect,\n                                              Node* control,\n                                              FeedbackSlot slot) const {\n  DCHECK(op->opcode() == IrOpcode::kJSSetNamedProperty ||\n         op->opcode() == IrOpcode::kJSDefineNamedOwnProperty);\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForGenericNamedAccess)) {\n    return LoweringResult::Exit(node);\n  }\n  return LoweringResult::NoChange();\n}\n\nJSTypeHintLowering::LoweringResult\nJSTypeHintLowering::ReduceStoreKeyedOperation(const Operator* op, Node* obj,\n                                              Node* key, Node* val,\n                                              Node* effect, Node* control,\n                                              FeedbackSlot slot) const {\n  DCHECK(op->opcode() == IrOpcode::kJSSetKeyedProperty ||\n         op->opcode() == IrOpcode::kJSStoreInArrayLiteral ||\n         op->opcode() == IrOpcode::kJSDefineKeyedOwnPropertyInLiteral ||\n         op->opcode() == IrOpcode::kJSDefineKeyedOwnProperty);\n  if (Node* node = BuildDeoptIfFeedbackIsInsufficient(\n          slot, effect, control,\n          DeoptimizeReason::kInsufficientTypeFeedbackForGenericKeyedAccess)) {\n    return LoweringResult::Exit(node);\n  }\n  return LoweringResult::NoChange();\n}\n\nNode* JSTypeHintLowering::BuildDeoptIfFeedbackIsInsufficient(\n    FeedbackSlot slot, Node* effect, Node* control,\n    DeoptimizeReason reason) const {\n  if (!(flags() & kBailoutOnUninitialized)) return nullptr;\n\n  FeedbackSource source(feedback_vector(), slot);\n  if (!broker()->FeedbackIsInsufficient(source)) return nullptr;\n\n  Node* deoptimize = jsgraph()->graph()->NewNode(\n      jsgraph()->common()->Deoptimize(reason, FeedbackSource()),\n      jsgraph()->Dead(), effect, control);\n  Node* frame_state =\n      NodeProperties::FindFrameStateBefore(deoptimize, jsgraph()->Dead());\n  deoptimize->ReplaceInput(0, frame_state);\n  return deoptimize;\n}\n\n private:\n  JSHeapBroker* broker_;\n  JSGraph* jsgraph_;\n  Flags flags_;\n  FeedbackVectorRef feedback_vector_;\n};"
    }
  ],
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-type-hint-lowering.cc"
}