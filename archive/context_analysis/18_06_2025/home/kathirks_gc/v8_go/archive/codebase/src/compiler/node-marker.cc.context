{
  "metadata": {
    "path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-marker.cc",
    "file_name": "node-marker.cc",
    "language": "cpp",
    "purpose": "Implements the NodeMarkerBase class for marking nodes in a Turbofan graph, used in compiler optimizations."
  },
  "imports": {
    "metadata": {
      "language": "cpp",
      "purpose": "Includes necessary headers for NodeMarkerBase and Turbofan graph functionality."
    },
    "code": "#include \"src/compiler/node-marker.h\"\n\n#include \"src/compiler/turbofan-graph.h\""
  },
  "classes": [
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "NodeMarkerBase",
        "about": "Base class for marking nodes in a graph.  Allocates a range of unique marks within the graph's marking space.",
        "attributes": [
          {
            "name": "mark_min_",
            "type": "uint32_t",
            "access": "private",
            "purpose": "The minimum mark value allocated to this marker."
          },
          {
            "name": "mark_max_",
            "type": "uint32_t",
            "access": "private",
            "purpose": "The maximum mark value allocated to this marker."
          }
        ],
        "dependencies": [
          "TFGraph"
        ]
      },
      "code": "class NodeMarkerBase {\n public:\n  NodeMarkerBase(TFGraph* graph, uint32_t num_states)\n      : mark_min_(graph->mark_max_), mark_max_(graph->mark_max_ += num_states) {\n    DCHECK_NE(0u, num_states);        // user error!\n    DCHECK_LT(mark_min_, mark_max_);  // check for wraparound.\n  }\n\n private:\n  uint32_t mark_min_;\n  uint32_t mark_max_;\n};"
    }
  ],
  "functions": [
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "NodeMarkerBase",
        "parent": "NodeMarkerBase",
        "about": "Constructor for the NodeMarkerBase class.",
        "logic": "The constructor takes a TFGraph pointer and the number of states required. It assigns a range of mark values to the NodeMarkerBase instance.  It obtains the initial minimum mark from the graph's current maximum, and updates the graph's maximum to allocate the states.  Includes checks to ensure the provided state count is non-zero and that a wraparound does not occur when updating the graph's mark_max_.",
        "parameters": [
          {
            "name": "graph",
            "type": "TFGraph*",
            "purpose": "A pointer to the Turbofan graph."
          },
          {
            "name": "num_states",
            "type": "uint32_t",
            "purpose": "The number of states to allocate for marking."
          }
        ],
        "return": {
          "type": "void",
          "description": "Constructor - no return value."
        },
        "dependencies": [
          "TFGraph"
        ]
      },
      "code": "NodeMarkerBase::NodeMarkerBase(TFGraph* graph, uint32_t num_states)\n    : mark_min_(graph->mark_max_), mark_max_(graph->mark_max_ += num_states) {\n  DCHECK_NE(0u, num_states);        // user error!\n  DCHECK_LT(mark_min_, mark_max_);  // check for wraparound.\n}"
    }
  ],
  "dependencies": [
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "TFGraph",
        "about": "Represents the Turbofan graph data structure.",
        "attributes": [
          {
            "name": "mark_max_",
            "type": "uint32_t",
            "access": "public",
            "purpose": "Keeps track of the maximum mark value used in the graph."
          }
        ]
      },
      "code": "class TFGraph {\n            public:\n                uint32_t mark_max_;\n            };",
      "type": "class"
    }
  ],
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-marker.cc"
}