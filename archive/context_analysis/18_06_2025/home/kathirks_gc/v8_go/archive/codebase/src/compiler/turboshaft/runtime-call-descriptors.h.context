{
  "metadata": {
    "path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/runtime-call-descriptors.h",
    "file_name": "runtime-call-descriptors.h",
    "language": "cpp",
    "purpose": "Defines RuntimeCallDescriptors for Turboshaft compiler, which describe the interface to runtime functions."
  },
  "imports": {
    "metadata": {
      "language": "cpp",
      "purpose": "Includes necessary headers for compiler globals, operator definitions, turboshaft operations, and runtime functions."
    },
    "code": "#include \"src/compiler/globals.h\"\n#include \"src/compiler/operator.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/runtime/runtime.h\""
  },
  "classes": [
    {
      "metadata": {
        "language": "cpp",
        "type": "struct",
        "name": "RuntimeCallDescriptor",
        "extends": null,
        "implements": [],
        "about": "Describes the calling convention and properties of runtime functions.",
        "attributes": [],
        "dependencies": [
          "TSCallDescriptor",
          "Runtime",
          "Linkage",
          "Zone",
          "LazyDeoptOnThrow",
          "CallDescriptor",
          "Operator",
          "CanThrow",
          "V",
          "Any",
          "Object",
          "Smi",
          "BigInt",
          "Number",
          "String",
          "Boolean",
          "SharedFunctionInfo",
          "FeedbackCell",
          "JSFunction",
          "HeapObject",
          "Map",
          "Symbol"
        ]
      },
      "code": "struct RuntimeCallDescriptor {\n private:\n  template <typename Derived>\n  struct Descriptor {\n    static const TSCallDescriptor* Create(\n        Zone* zone, LazyDeoptOnThrow lazy_deopt_on_throw) {\n      DCHECK_IMPLIES(lazy_deopt_on_throw == LazyDeoptOnThrow::kYes,\n                     Derived::kNeedsFrameState);\n      auto descriptor = Linkage::GetRuntimeCallDescriptor(\n          zone, Derived::kFunction,\n          std::tuple_size_v<typename Derived::arguments_t>,\n          Derived::kProperties,\n          Derived::kNeedsFrameState ? CallDescriptor::kNeedsFrameState\n                                    : CallDescriptor::kNoFlags);\n#ifdef DEBUG\n      Derived::Verify(descriptor);\n#endif  // DEBUG\n      CanThrow can_throw = (Derived::kProperties & Operator::kNoThrow)\n                               ? CanThrow::kNo\n                               : CanThrow::kYes;\n      return TSCallDescriptor::Create(descriptor, can_throw,\n                                      lazy_deopt_on_throw, zone);\n    }\n\n#ifdef DEBUG\n    static void Verify(const CallDescriptor* desc) {\n      using result_t = typename Derived::result_t;\n      using arguments_t = typename Derived::arguments_t;\n      if constexpr (std::is_same_v<result_t, void>) {\n        DCHECK_EQ(desc->ReturnCount(), 0);\n      } else {\n        DCHECK_EQ(desc->ReturnCount(), 1);\n        DCHECK(result_t::allows_representation(\n            RegisterRepresentation::FromMachineRepresentation(\n                desc->GetReturnType(0).representation())));\n      }\n      DCHECK_EQ(desc->NeedsFrameState(), Derived::kNeedsFrameState);\n      DCHECK_EQ(desc->properties(), Derived::kProperties);\n      constexpr int additional_stub_arguments =\n          3;  // function id, argument count, context (or NoContextConstant)\n      DCHECK_EQ(desc->ParameterCount(),\n                std::tuple_size_v<arguments_t> + additional_stub_arguments);\n      DCHECK(VerifyArguments<arguments_t>(desc));\n    }\n\n    template <typename Arguments>\n    static bool VerifyArguments(const CallDescriptor* desc) {\n      return VerifyArgumentsImpl<Arguments>(\n          desc, std::make_index_sequence<std::tuple_size_v<Arguments>>());\n    }\n\n   private:\n    template <typename Arguments, size_t... Indices>\n    static bool VerifyArgumentsImpl(const CallDescriptor* desc,\n                                    std::index_sequence<Indices...>) {\n      return (std::tuple_element_t<Indices, Arguments>::allows_representation(\n                  RegisterRepresentation::FromMachineRepresentation(\n                      desc->GetParameterType(Indices).representation())) &&\n              ...);\n    }\n#endif  // DEBUG\n  };\n\n  // TODO(nicohartmann@): Unfortunately, we cannot define builtins with\n  // void/never return types properly (e.g. in Torque), but they typically have\n  // a JSAny dummy return type. Use Void/Never sentinels to express that in\n  // Turboshaft's descriptors. We should find a better way to model this.\n  using Void = V<Any>;\n  using Never = V<Any>;\n\n public:\n  struct Abort : public Descriptor<Abort> {\n    static constexpr auto kFunction = Runtime::kAbort;\n    using arguments_t = std::tuple<V<Smi>>;\n    using result_t = V<Object>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct BigIntUnaryOp : public Descriptor<BigIntUnaryOp> {\n    static constexpr auto kFunction = Runtime::kBigIntUnaryOp;\n    using arguments_t = std::tuple<V<BigInt>, V<Smi>>;\n    using result_t = V<BigInt>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct DateCurrentTime : public Descriptor<DateCurrentTime> {\n    static constexpr auto kFunction = Runtime::kDateCurrentTime;\n    using arguments_t = std::tuple<>;\n    using result_t = V<Number>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct DebugPrint : public Descriptor<DebugPrint> {\n    static constexpr auto kFunction = Runtime::kDebugPrint;\n    using arguments_t = std::tuple<V<Object>>;\n    using result_t = Void;  // No actual result\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct StackGuard : public Descriptor<StackGuard> {\n    static constexpr auto kFunction = Runtime::kStackGuard;\n    using arguments_t = std::tuple<>;\n    using result_t = V<Object>;\n\n    static constexpr bool kNeedsFrameState = false;\n    // TODO(nicohartmann@): Verify this.\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct StackGuardWithGap : public Descriptor<StackGuardWithGap> {\n    static constexpr auto kFunction = Runtime::kStackGuardWithGap;\n    using arguments_t = std::tuple<V<Smi>>;\n    using result_t = V<Object>;\n\n    static constexpr bool kNeedsFrameState = true;\n    // TODO(nicohartmann@): Verify this.\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct HandleNoHeapWritesInterrupts\n      : public Descriptor<HandleNoHeapWritesInterrupts> {\n    static constexpr auto kFunction = Runtime::kHandleNoHeapWritesInterrupts;\n    using arguments_t = std::tuple<>;\n    using result_t = V<Object>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoWrite;\n  };\n\n  struct PropagateException : public Descriptor<PropagateException> {\n    static constexpr auto kFunction = Runtime::kPropagateException;\n    using arguments_t = std::tuple<>;\n    using result_t = V<Object>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct ReThrow : public Descriptor<ReThrow> {\n    static constexpr auto kFunction = Runtime::kReThrow;\n    using arguments_t = std::tuple<V<Object>>;\n    using result_t = Never;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties = Operator::kNoThrow;\n  };\n\n  struct StringCharCodeAt : public Descriptor<StringCharCodeAt> {\n    static constexpr auto kFunction = Runtime::kStringCharCodeAt;\n    using arguments_t = std::tuple<V<String>, V<Number>>;\n    using result_t = V<Smi>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n#ifdef V8_INTL_SUPPORT\n  struct StringToUpperCaseIntl : public Descriptor<StringToUpperCaseIntl> {\n    static constexpr auto kFunction = Runtime::kStringToUpperCaseIntl;\n    using arguments_t = std::tuple<V<String>>;\n    using result_t = V<String>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n#endif  // V8_INTL_SUPPORT\n\n  struct SymbolDescriptiveString : public Descriptor<SymbolDescriptiveString> {\n    static constexpr auto kFunction = Runtime::kSymbolDescriptiveString;\n    using arguments_t = std::tuple<V<Symbol>>;\n    using result_t = V<String>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoDeopt;\n  };\n\n  struct TerminateExecution : public Descriptor<TerminateExecution> {\n    static constexpr auto kFunction = Runtime::kTerminateExecution;\n    using arguments_t = std::tuple<>;\n    using result_t = V<Object>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoDeopt;\n  };\n\n  struct TransitionElementsKind : public Descriptor<TransitionElementsKind> {\n    static constexpr auto kFunction = Runtime::kTransitionElementsKind;\n    using arguments_t = std::tuple<V<HeapObject>, V<Map>>;\n    using result_t = V<Object>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct TryMigrateInstance : public Descriptor<TryMigrateInstance> {\n    static constexpr auto kFunction = Runtime::kTryMigrateInstance;\n    using arguments_t = std::tuple<V<HeapObject>>;\n    using result_t = V<Object>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct TryMigrateInstanceAndMarkMapAsMigrationTarget\n      : public Descriptor<TryMigrateInstanceAndMarkMapAsMigrationTarget> {\n    static constexpr auto kFunction =\n        Runtime::kTryMigrateInstanceAndMarkMapAsMigrationTarget;\n    using arguments_t = std::tuple<V<HeapObject>>;\n    using result_t = V<Object>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties =\n        Operator::kNoDeopt | Operator::kNoThrow;\n  };\n\n  struct ThrowAccessedUninitializedVariable\n      : public Descriptor<ThrowAccessedUninitializedVariable> {\n    static constexpr auto kFunction =\n        Runtime::kThrowAccessedUninitializedVariable;\n    using arguments_t = std::tuple<V<Object>>;\n    // Doesn't actually return something, but the actual runtime call descriptor\n    // (returned by Linkage::GetRuntimeCallDescriptor) returns 1 instead of 0.\n    using result_t = Never;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct ThrowConstructorReturnedNonObject\n      : public Descriptor<ThrowConstructorReturnedNonObject> {\n    static constexpr auto kFunction =\n        Runtime::kThrowConstructorReturnedNonObject;\n    using arguments_t = std::tuple<>;\n    // Doesn't actually return something, but the actual runtime call descriptor\n    // (returned by Linkage::GetRuntimeCallDescriptor) returns 1 instead of 0.\n    using result_t = Never;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct ThrowNotSuperConstructor\n      : public Descriptor<ThrowNotSuperConstructor> {\n    static constexpr auto kFunction = Runtime::kThrowNotSuperConstructor;\n    using arguments_t = std::tuple<V<Object>, V<Object>>;\n    // Doesn't actually return something, but the actual runtime call descriptor\n    // (returned by Linkage::GetRuntimeCallDescriptor) returns 1 instead of 0.\n    using result_t = Never;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct ThrowSuperAlreadyCalledError\n      : public Descriptor<ThrowSuperAlreadyCalledError> {\n    static constexpr auto kFunction = Runtime::kThrowSuperAlreadyCalledError;\n    using arguments_t = std::tuple<>;\n    // Doesn't actually return something, but the actual runtime call descriptor\n    // (returned by Linkage::GetRuntimeCallDescriptor) returns 1 instead of 0.\n    using result_t = Never;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct ThrowSuperNotCalled : public Descriptor<ThrowSuperNotCalled> {\n    static constexpr auto kFunction = Runtime::kThrowSuperNotCalled;\n    using arguments_t = std::tuple<>;\n    // Doesn't actually return something, but the actual runtime call descriptor\n    // (returned by Linkage::GetRuntimeCallDescriptor) returns 1 instead of 0.\n    using result_t = Never;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct ThrowCalledNonCallable : public Descriptor<ThrowCalledNonCallable> {\n    static constexpr auto kFunction = Runtime::kThrowCalledNonCallable;\n    using arguments_t = std::tuple<V<Object>>;\n    // Doesn't actually return something, but the actual runtime call descriptor\n    // (returned by Linkage::GetRuntimeCallDescriptor) returns 1 instead of 0.\n    using result_t = Never;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct ThrowInvalidStringLength\n      : public Descriptor<ThrowInvalidStringLength> {\n    static constexpr auto kFunction = Runtime::kThrowInvalidStringLength;\n    using arguments_t = std::tuple<>;\n    // Doesn't actually return something, but the actual runtime call descriptor\n    // (returned by Linkage::GetRuntimeCallDescriptor) returns 1 instead of 0.\n    using result_t = Never;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n\n  struct NewClosure : public Descriptor<NewClosure> {\n    static constexpr auto kFunction = Runtime::kNewClosure;\n    using arguments_t = std::tuple<V<SharedFunctionInfo>, V<FeedbackCell>>;\n    using result_t = V<JSFunction>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties = Operator::kNoThrow;\n  };\n\n  struct NewClosure_Tenured : public Descriptor<NewClosure_Tenured> {\n    static constexpr auto kFunction = Runtime::kNewClosure_Tenured;\n    using arguments_t = std::tuple<V<SharedFunctionInfo>, V<FeedbackCell>>;\n    using result_t = V<JSFunction>;\n\n    static constexpr bool kNeedsFrameState = false;\n    static constexpr Operator::Properties kProperties = Operator::kNoThrow;\n  };\n\n  struct HasInPrototypeChain : public Descriptor<HasInPrototypeChain> {\n    static constexpr auto kFunction = Runtime::kHasInPrototypeChain;\n    using arguments_t = std::tuple<V<Object>, V<HeapObject>>;\n    using result_t = V<Boolean>;\n\n    static constexpr bool kNeedsFrameState = true;\n    static constexpr Operator::Properties kProperties = Operator::kNoProperties;\n  };\n};"
    }
  ],
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/runtime-call-descriptors.h"
}