{
  "metadata": {
    "path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/platform-embedded-file-writer-aix.cc",
    "file_name": "platform-embedded-file-writer-aix.cc",
    "language": "cpp",
    "purpose": "Platform-specific implementation for writing embedded snapshot files on AIX systems. This file provides functionality to generate assembly code compatible with the AIX operating system, primarily used for embedding V8's snapshot data directly into the executable."
  },
  "imports": {
    "metadata": {
      "language": "cpp",
      "purpose": "Includes necessary headers for platform-specific file writing and instruction stream handling."
    },
    "code": "#include \"src/snapshot/embedded/platform-embedded-file-writer-aix.h\"\n\n#include \"src/objects/instruction-stream.h\""
  },
  "classes": [
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "PlatformEmbeddedFileWriterAIX",
        "extends": "PlatformEmbeddedFileWriter",
        "about": "Platform-specific file writer for embedding snapshots on AIX.",
        "attributes": [],
        "dependencies": [
          "PlatformEmbeddedFileWriter"
        ]
      },
      "code": "namespace v8 {\nnamespace internal {\n\n#define SYMBOL_PREFIX \"\"\n\nnamespace {\n\nconst char* DirectiveAsString(DataDirective directive) {\n  switch (directive) {\n    case kByte:\n      return \".byte\";\n    case kLong:\n      return \".long\";\n    case kQuad:\n      return \".llong\";\n    default:\n      UNREACHABLE();\n  }\n}\n\n}  // namespace\n\nclass PlatformEmbeddedFileWriterAIX : public PlatformEmbeddedFileWriter {\n public:\n  void SectionText() override;\n  void SectionRoData() override;\n  void DeclareUint32(const char* name, uint32_t value) override;\n  void DeclareSymbolGlobal(const char* name) override;\n  void AlignToCodeAlignment() override;\n  void AlignToDataAlignment() override;\n  void Comment(const char* string) override;\n  void DeclareLabel(const char* name) override;\n  void SourceInfo(int fileid, const char* filename, int line) override;\n  void DeclareFunctionBegin(const char* name, uint32_t size) override;\n  void DeclareFunctionEnd(const char* name) override;\n  void FilePrologue() override;\n  void DeclareExternalFilename(int fileid, const char* filename) override;\n  void FileEpilogue() override;\n  int IndentedDataDirective(DataDirective directive) override;\n  DataDirective ByteChunkDataDirective() const override;\n};\n\n#undef SYMBOL_PREFIX\n\n}  // namespace internal\n}  // namespace v8"
    }
  ],
  "functions": [
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "SectionText",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Writes assembly directives to switch to the text section.",
        "logic": "Prints the '.csect [GL], 6' directive to the file stream.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::SectionText() {\n  fprintf(fp_, \".csect [GL], 6\\n\");\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "SectionRoData",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Writes assembly directives to switch to the read-only data section.",
        "logic": "Prints the '.csect[RO]' directive to the file stream.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::SectionRoData() {\n  fprintf(fp_, \".csect[RO]\\n\");\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "DeclareUint32",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Declares a 32-bit unsigned integer symbol in the assembly code.",
        "logic": "Declares the symbol as global, aligns the data, defines the symbol, and outputs the value using the '.long' directive.",
        "parameters": [
          {
            "name": "name",
            "type": "const char*",
            "purpose": "The name of the symbol to declare."
          },
          {
            "name": "value",
            "type": "uint32_t",
            "purpose": "The value of the symbol."
          }
        ],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::DeclareUint32(const char* name,\n                                                  uint32_t value) {\n  DeclareSymbolGlobal(name);\n  fprintf(fp_, \".align 2\\n\");\n  fprintf(fp_, \"%s:\\n\", name);\n  IndentedDataDirective(kLong);\n  fprintf(fp_, \"%d\\n\", value);\n  Newline();\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "DeclareSymbolGlobal",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Declares a symbol as global in the assembly code.",
        "logic": "Prints the '.globl' directive with the 'hidden' attribute for reduced binary size.",
        "parameters": [
          {
            "name": "name",
            "type": "const char*",
            "purpose": "The name of the symbol to declare as global."
          }
        ],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::DeclareSymbolGlobal(const char* name) {\n  // These symbols are not visible outside of the final binary, this allows for\n  // reduced binary size, and less work for the dynamic linker.\n  fprintf(fp_, \".globl %s, hidden\\n\", name);\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "AlignToCodeAlignment",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Aligns the code to the target architecture's code alignment boundary.",
        "logic": "Outputs an assembly '.align' directive based on the target architecture (x64, PPC64, or others).",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::AlignToCodeAlignment() {\n#if V8_TARGET_ARCH_X64\n  // On x64 use 64-bytes code alignment to allow 64-bytes loop header alignment.\n  static_assert((1 << 6) >= kCodeAlignment);\n  fprintf(fp_, \".align 6\\n\");\n#elif V8_TARGET_ARCH_PPC64\n  // 64 byte alignment is needed on ppc64 to make sure p10 prefixed instructions\n  // don't cross 64-byte boundaries.\n  static_assert((1 << 6) >= kCodeAlignment);\n  fprintf(fp_, \".align 6\\n\");\n#else\n  static_assert((1 << 5) >= kCodeAlignment);\n  fprintf(fp_, \".align 5\\n\");\n#endif\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "AlignToDataAlignment",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Aligns the data section to the metadata alignment boundary.",
        "logic": "Outputs an assembly '.align' directive based on the metadata alignment requirement.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": [
          "InstructionStream"
        ]
      },
      "code": "void PlatformEmbeddedFileWriterAIX::AlignToDataAlignment() {\n  static_assert((1 << 3) >= InstructionStream::kMetadataAlignment);\n  fprintf(fp_, \".align 3\\n\");\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "Comment",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Writes a comment to the assembly code.",
        "logic": "Prints the comment string prefixed with '//'.",
        "parameters": [
          {
            "name": "string",
            "type": "const char*",
            "purpose": "The comment string to write."
          }
        ],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::Comment(const char* string) {\n  fprintf(fp_, \"// %s\\n\", string);\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "DeclareLabel",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Declares a label in the assembly code.",
        "logic": "Prints the '.globl' directive to make the label global and then defines the label.",
        "parameters": [
          {
            "name": "name",
            "type": "const char*",
            "purpose": "The name of the label to declare."
          }
        ],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::DeclareLabel(const char* name) {\n  // .global is required on AIX, if the label is used/referenced in another file\n  // later to be linked.\n  fprintf(fp_, \".globl %s\\n\", name);\n  fprintf(fp_, \"%s:\\n\", name);\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "SourceInfo",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Writes source file information to the assembly code for debugging purposes.",
        "logic": "Prints the '.xline' directive with the file ID, filename, and line number.",
        "parameters": [
          {
            "name": "fileid",
            "type": "int",
            "purpose": "The file ID."
          },
          {
            "name": "filename",
            "type": "const char*",
            "purpose": "The name of the source file."
          },
          {
            "name": "line",
            "type": "int",
            "purpose": "The line number in the source file."
          }
        ],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::SourceInfo(int fileid, const char* filename,\n                                               int line) {\n  fprintf(fp_, \".xline %d, \\\"%s\\\"\\n\", line, filename);\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "DeclareFunctionBegin",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Declares the beginning of a function in the assembly code.",
        "logic": "If CFI is enabled, the function symbol is declared global; then a csect for the function descriptor is opened, followed by the actual code section.",
        "parameters": [
          {
            "name": "name",
            "type": "const char*",
            "purpose": "The name of the function."
          },
          {
            "name": "size",
            "type": "uint32_t",
            "purpose": "The size of the function (not directly used in this implementation)."
          }
        ],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::DeclareFunctionBegin(const char* name,\n                                                         uint32_t size) {\n  Newline();\n  if (ENABLE_CONTROL_FLOW_INTEGRITY_BOOL) {\n    DeclareSymbolGlobal(name);\n  }\n  fprintf(fp_, \".csect %s[DS]\\n\", name);  // function descriptor\n  fprintf(fp_, \"%s:\\n\", name);\n  fprintf(fp_, \".llong .%s, 0, 0\\n\", name);\n  SectionText();\n  fprintf(fp_, \".%s:\\n\", name);\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "DeclareFunctionEnd",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Declares the end of a function in the assembly code (currently a no-op).",
        "logic": "This method is currently empty.",
        "parameters": [
          {
            "name": "name",
            "type": "const char*",
            "purpose": "The name of the function."
          }
        ],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::DeclareFunctionEnd(const char* name) {}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "FilePrologue",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Writes the file prologue to the assembly code (currently a no-op).",
        "logic": "This method is currently empty.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::FilePrologue() {}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "DeclareExternalFilename",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Declares an external filename (currently uses SourceInfo instead).",
        "logic": "This method is not used on AIX; SourceInfo is used instead to emit debug info in .xline format.",
        "parameters": [
          {
            "name": "fileid",
            "type": "int",
            "purpose": "The file ID."
          },
          {
            "name": "filename",
            "type": "const char*",
            "purpose": "The name of the external file."
          }
        ],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::DeclareExternalFilename(\n    int fileid, const char* filename) {\n  // File name cannot be declared with an identifier on AIX.\n  // We use the SourceInfo method to emit debug info in\n  //.xline <line-number> <file-name> format.\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "FileEpilogue",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Writes the file epilogue to the assembly code (currently a no-op).",
        "logic": "This method is currently empty.",
        "parameters": [],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": []
      },
      "code": "void PlatformEmbeddedFileWriterAIX::FileEpilogue() {}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "IndentedDataDirective",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Writes a data directive with indentation.",
        "logic": "Writes the provided DataDirective to the file stream, prefixed with indentation.",
        "parameters": [
          {
            "name": "directive",
            "type": "DataDirective",
            "purpose": "The data directive to write."
          }
        ],
        "return": {
          "type": "int",
          "description": "Return value of fprintf."
        },
        "dependencies": [
          "DirectiveAsString"
        ]
      },
      "code": "int PlatformEmbeddedFileWriterAIX::IndentedDataDirective(\n    DataDirective directive) {\n  return fprintf(fp_, \"  %s \", DirectiveAsString(directive));\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "ByteChunkDataDirective",
        "parent": "PlatformEmbeddedFileWriterAIX",
        "about": "Returns the data directive to use for byte chunks.",
        "logic": "On PPC, returns kLong to prevent unnecessary padding.",
        "parameters": [],
        "return": {
          "type": "DataDirective",
          "description": "The data directive to use (kLong for PPC)."
        },
        "dependencies": []
      },
      "code": "DataDirective PlatformEmbeddedFileWriterAIX::ByteChunkDataDirective() const {\n  // PPC uses a fixed 4 byte instruction set, using .long\n  // to prevent any unnecessary padding.\n  return kLong;\n}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "function",
        "name": "DirectiveAsString",
        "about": "Converts a DataDirective enum value to its string representation.",
        "logic": "Uses a switch statement to return the appropriate assembly directive string based on the DataDirective enum value.",
        "parameters": [
          {
            "name": "directive",
            "type": "DataDirective",
            "purpose": "The DataDirective enum value to convert."
          }
        ],
        "return": {
          "type": "const char*",
          "description": "The string representation of the DataDirective."
        },
        "dependencies": []
      },
      "code": "namespace {\n\nconst char* DirectiveAsString(DataDirective directive) {\n  switch (directive) {\n    case kByte:\n      return \".byte\";\n    case kLong:\n      return \".long\";\n    case kQuad:\n      return \".llong\";\n    default:\n      UNREACHABLE();\n  }\n}\n\n}  // namespace"
    }
  ],
  "interfaces": [
    {
      "metadata": {
        "language": "cpp",
        "type": "enum",
        "name": "DataDirective",
        "about": "Enumerates the different data directives supported.",
        "methods": [],
        "dependencies": []
      },
      "code": "enum DataDirective {\n  kByte,\n  kLong,\n  kQuad,\n};"
    }
  ],
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/platform-embedded-file-writer-aix.cc"
}