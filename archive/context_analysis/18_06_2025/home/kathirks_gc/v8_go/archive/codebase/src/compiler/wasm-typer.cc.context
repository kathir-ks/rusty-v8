{
  "metadata": {
    "path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-typer.cc",
    "file_name": "wasm-typer.cc",
    "language": "cpp",
    "purpose": "Performs type inference on the Wasm graph nodes during compilation."
  },
  "imports": {
    "metadata": {
      "language": "cpp",
      "purpose": "Includes necessary headers for WasmTyper class, including logging, graph manipulation, node properties, operator definitions, Wasm-specific definitions, and utilities."
    },
    "code": "#include \"src/compiler/wasm-typer.h\"\n\n#include \"src/base/logging.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/wasm-compiler-definitions.h\"\n#include \"src/utils/utils.h\"\n#include \"src/wasm/object-access.h\"\n#include \"src/wasm/wasm-objects.h\"\n#include \"src/wasm/wasm-subtyping.h\""
  },
  "classes": [
    {
      "metadata": {
        "language": "cpp",
        "type": "class",
        "name": "WasmTyper",
        "extends": "AdvancedReducer",
        "about": "Infers and propagates Wasm types through the compilation graph.",
        "attributes": [
          {
            "name": "function_index_",
            "type": "uint32_t",
            "access": "private",
            "purpose": "Index of the Wasm function being processed."
          },
          {
            "name": "graph_zone_",
            "type": "Zone*",
            "access": "private",
            "purpose": "Memory zone used for allocating graph data structures."
          }
        ],
        "dependencies": [
          "Editor",
          "MachineGraph",
          "AdvancedReducer"
        ]
      },
      "code": "class WasmTyper : public AdvancedReducer {\n public:\n  WasmTyper(Editor* editor, MachineGraph* mcgraph,\n                     uint32_t function_index);\n\n private:\n  Reduction Reduce(Node* node) override;\n\n  uint32_t function_index_;\n  Zone* graph_zone_;\n};"
    }
  ],
  "functions": [
    {
      "metadata": {
        "language": "cpp",
        "type": "function",
        "name": "WasmTyper",
        "parent": "WasmTyper",
        "about": "Constructor for the WasmTyper class.",
        "logic": "Initializes the WasmTyper with the editor, machine graph, and function index.",
        "parameters": [
          {
            "name": "editor",
            "type": "Editor*",
            "purpose": "The editor used for graph modifications."
          },
          {
            "name": "mcgraph",
            "type": "MachineGraph*",
            "purpose": "The machine graph being typed."
          },
          {
            "name": "function_index",
            "type": "uint32_t",
            "purpose": "The index of the Wasm function."
          }
        ],
        "return": {
          "type": "void",
          "description": "No return value."
        },
        "dependencies": [
          "AdvancedReducer"
        ]
      },
      "code": "WasmTyper::WasmTyper(Editor* editor, MachineGraph* mcgraph,\n                     uint32_t function_index)\n    : AdvancedReducer(editor),\n      function_index_(function_index),\n      graph_zone_(mcgraph->graph()->zone()) {}"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "function",
        "name": "AllInputsTyped",
        "parent": "anonymous namespace",
        "about": "Checks if all value inputs of a node are typed.",
        "logic": "Iterates through the value inputs of the node and returns false if any of them are not typed; otherwise, returns true.",
        "parameters": [
          {
            "name": "node",
            "type": "Node*",
            "purpose": "The node to check."
          }
        ],
        "return": {
          "type": "bool",
          "description": "True if all value inputs are typed, false otherwise."
        },
        "dependencies": [
          "Node",
          "NodeProperties"
        ]
      },
      "code": "namespace {\nbool AllInputsTyped(Node* node) {\n  for (int i = 0; i < node->op()->ValueInputCount(); i++) {\n    if (!NodeProperties::IsTyped(NodeProperties::GetValueInput(node, i))) {\n      return false;\n    }\n  }\n  return true;\n}\n}  // namespace"
    },
    {
      "metadata": {
        "language": "cpp",
        "type": "method",
        "name": "Reduce",
        "parent": "WasmTyper",
        "about": "Reduces a node by inferring its Wasm type.",
        "logic": "Determines the Wasm type of the node based on its opcode and input types. Implements type inference rules for various Wasm operations such as TypeGuard, WasmTypeCast, AssertNotNull, Phi, WasmArrayGet, and WasmStructGet. Handles type unions and intersections, as well as nullability.",
        "parameters": [
          {
            "name": "node",
            "type": "Node*",
            "purpose": "The node to reduce."
          }
        ],
        "return": {
          "type": "Reduction",
          "description": "The result of the reduction, indicating whether the node was changed and potentially replacing it."
        },
        "dependencies": [
          "Node",
          "NodeProperties",
          "Type",
          "TypeGuardTypeOf",
          "AllInputsTyped",
          "wasm::Intersection",
          "wasm::Union",
          "wasm::IsSubtypeOf",
          "wasm::EquivalentTypes",
          "wasm::ToNullSentinel",
          "OpParameter",
          "WasmTypeCheckConfig",
          "WasmFieldInfo"
        ]
      },
      "code": "Reduction WasmTyper::Reduce(Node* node) {\n  using TypeInModule = wasm::TypeInModule;\n  TypeInModule computed_type;\n  switch (node->opcode()) {\n    case IrOpcode::kTypeGuard: {\n      if (!AllInputsTyped(node)) return NoChange();\n      Type guarded_type = TypeGuardTypeOf(node->op());\n      if (!guarded_type.IsWasm()) return NoChange();\n      Type input_type =\n          NodeProperties::GetType(NodeProperties::GetValueInput(node, 0));\n      if (!input_type.IsWasm()) return NoChange();\n      TypeInModule guarded_wasm_type = guarded_type.AsWasm();\n      TypeInModule input_wasm_type = input_type.AsWasm();\n      // Note: The intersection type might be bottom. In this case, we are in a\n      // dead branch: Type this node as bottom and wait for the\n      // WasmGCOperatorReducer to remove it.\n      computed_type = wasm::Intersection(guarded_wasm_type, input_wasm_type);\n      break;\n    }\n    case IrOpcode::kWasmTypeCast:\n    case IrOpcode::kWasmTypeCastAbstract: {\n      if (!AllInputsTyped(node)) return NoChange();\n      TypeInModule object_type =\n          NodeProperties::GetType(NodeProperties::GetValueInput(node, 0))\n              .AsWasm();\n      wasm::ValueType to_type = OpParameter<WasmTypeCheckConfig>(node->op()).to;\n      // TODO(12166): Change module parameters if we have cross-module inlining.\n      computed_type = wasm::Intersection(\n          object_type.type, to_type, object_type.module, object_type.module);\n      break;\n    }\n    case IrOpcode::kAssertNotNull: {\n      if (!AllInputsTyped(node)) return NoChange();\n      TypeInModule object_type =\n          NodeProperties::GetType(NodeProperties::GetValueInput(node, 0))\n              .AsWasm();\n      computed_type = {object_type.type.AsNonNull(), object_type.module};\n      break;\n    }\n    case IrOpcode::kPhi: {\n      if (!AllInputsTyped(node)) {\n        bool is_loop_phi =\n            NodeProperties::GetControlInput(node)->opcode() == IrOpcode::kLoop;\n        // For a merge phi, we need all inputs to be typed.\n        if (!is_loop_phi) return NoChange();\n        // For a loop phi, we can forward the non-recursive-input type. We can\n        // recompute the type when the rest of the inputs' types are computed.\n        Node* non_recursive_input = NodeProperties::GetValueInput(node, 0);\n        if (!NodeProperties::IsTyped(non_recursive_input) ||\n            !NodeProperties::GetType(non_recursive_input).IsWasm()) {\n          return NoChange();\n        }\n        computed_type = NodeProperties::GetType(non_recursive_input).AsWasm();\n        TRACE(\"function: %d, loop phi node: %d, type: %s\\n\", function_index_,\n              node->id(), computed_type.type.name().c_str());\n        break;\n      }\n\n      Type first_input_type =\n          NodeProperties::GetType(NodeProperties::GetValueInput(node, 0));\n      if (!first_input_type.IsWasm()) return NoChange();\n      computed_type = first_input_type.AsWasm();\n      for (int i = 1; i < node->op()->ValueInputCount(); i++) {\n        Node* input = NodeProperties::GetValueInput(node, i);\n        Type input_type = NodeProperties::GetType(input);\n        if (!input_type.IsWasm()) return NoChange();\n        TypeInModule wasm_type = input_type.AsWasm();\n        if (computed_type.type.is_bottom()) {\n          // We have not found a non-bottom branch yet.\n          computed_type = wasm_type;\n        } else if (!wasm_type.type.is_bottom()) {\n          // We do not want union of types from unreachable branches.\n          computed_type = wasm::Union(computed_type, wasm_type);\n        }\n      }\n      TRACE(\n          \"function: %d, phi node: %d, input#: %d, input0:%d:%s, input1:%d:%s, \"\n          \"type: %s\\n\",\n          function_index_, node->id(), node->op()->ValueInputCount(),\n          node->InputAt(0)->id(),\n          NodeProperties::GetType(node->InputAt(0))\n              .AsWasm()\n              .type.name()\n              .c_str(),\n          node->InputAt(1)->id(),\n          node->op()->ValueInputCount() > 1\n              ? NodeProperties::GetType(node->InputAt(1))\n                    .AsWasm()\n                    .type.name()\n                    .c_str()\n              : \"<control>\",\n          computed_type.type.name().c_str());\n      break;\n    }\n    case IrOpcode::kWasmArrayGet: {\n      Node* object = NodeProperties::GetValueInput(node, 0);\n      // This can happen either because the object has not been typed yet, or\n      // because it is an internal VM object (e.g. the instance).\n      if (!NodeProperties::IsTyped(object)) return NoChange();\n      TypeInModule object_type = NodeProperties::GetType(object).AsWasm();\n      // {is_uninhabited} can happen in unreachable branches.\n      if (object_type.type.is_uninhabited() ||\n          object_type.type == wasm::kWasmNullRef) {\n        computed_type = {wasm::kWasmBottom, object_type.module};\n        break;\n      }\n      wasm::ModuleTypeIndex ref_index = object_type.type.ref_index();\n      DCHECK(object_type.module->has_array(ref_index));\n      const wasm::ArrayType* type_from_object =\n          object_type.module->type(ref_index).array_type;\n      computed_type = {type_from_object->element_type().Unpacked(),\n                       object_type.module};\n      break;\n    }\n    case IrOpcode::kWasmStructGet: {\n      Node* object = NodeProperties::GetValueInput(node, 0);\n      // This can happen either because the object has not been typed yet.\n      if (!NodeProperties::IsTyped(object)) return NoChange();\n      TypeInModule object_type = NodeProperties::GetType(object).AsWasm();\n      // {is_uninhabited} can happen in unreachable branches.\n      if (object_type.type.is_uninhabited() ||\n          object_type.type == wasm::kWasmNullRef) {\n        computed_type = {wasm::kWasmBottom, object_type.module};\n        break;\n      }\n      WasmFieldInfo info = OpParameter<WasmFieldInfo>(node->op());\n\n      wasm::ModuleTypeIndex ref_index = object_type.type.ref_index();\n\n      DCHECK(object_type.module->has_struct(ref_index));\n\n      const wasm::StructType* struct_type_from_object =\n          object_type.module->type(ref_index).struct_type;\n\n      computed_type = {\n          struct_type_from_object->field(info.field_index).Unpacked(),\n          object_type.module};\n      break;\n    }\n    case IrOpcode::kNull: {\n      TypeInModule from_node = NodeProperties::GetType(node).AsWasm();\n      computed_type = {wasm::ToNullSentinel(from_node), from_node.module};\n      break;\n    }\n    default:\n      return NoChange();\n  }\n\n  if (NodeProperties::IsTyped(node) && NodeProperties::GetType(node).IsWasm()) {\n    TypeInModule current_type = NodeProperties::GetType(node).AsWasm();\n    if (!(current_type.type.is_bottom() || computed_type.type.is_bottom() ||\n          wasm::IsSubtypeOf(current_type.type, computed_type.type,\n                            current_type.module, computed_type.module) ||\n          wasm::IsSubtypeOf(computed_type.type, current_type.type,\n                            computed_type.module, current_type.module) ||\n          // Imported strings can have more precise types.\n          (current_type.type.heap_representation() == wasm::HeapType::kExtern &&\n           computed_type.type.heap_representation() ==\n               wasm::HeapType::kString))) {\n      FATAL(\n          \"Error - Incompatible types. function: %d, node: %d:%s, input0:%d, \"\n          \"current %s, computed %s\\n\",\n          function_index_, node->id(), node->op()->mnemonic(),\n          node->InputAt(0)->id(), current_type.type.name().c_str(),\n          computed_type.type.name().c_str());\n    }\n\n    if (wasm::EquivalentTypes(current_type.type, computed_type.type,\n                              current_type.module, computed_type.module)) {\n      return NoChange();\n    }\n  }\n\n  TRACE(\"function: %d, node: %d:%s, from: %s, to: %s\\n\", function_index_,\n        node->id(), node->op()->mnemonic(),\n        NodeProperties::IsTyped(node)\n            ? NodeProperties::GetType(node).AsWasm().type.name().c_str()\n            : \"<untyped>\",\n        computed_type.type.name().c_str());\n\n  NodeProperties::SetType(node, Type::Wasm(computed_type, graph_zone_));\n  return Changed(node);\n}"
    }
  ],
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-typer.cc"
}