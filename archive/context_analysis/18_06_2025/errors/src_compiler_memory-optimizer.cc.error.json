{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/memory-optimizer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/memory-optimizer.cc\",\n        \"file_name\": \"memory-optimizer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Optimizes memory-related operations in the compiler graph, such as allocation and stores, to reduce write barriers and improve performance.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for logging, code generation, compiler components, and root access.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/memory-optimizer.h\"\n\n#include \"src/base/logging.h\"\n#include \"src/codegen/tick-counter.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/roots/roots-inl.h\"\n        ]]></code>\n    </imports>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8::internal::compiler\",\n            \"purpose\": \"Groups the memory optimizer related classes and functions.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n        ]]></code>\n\n        <namespace>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"<anonymous>\",\n                \"purpose\": \"Contains helper functions with file scope, specifically for determining if a node can allocate and searching for allocating nodes in the graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\nnamespace {\n            ]]></code>\n\n            <func>\n                <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"CanAllocate\",\n                    \"about\": \"Determines whether a given node can potentially trigger garbage collection by allocating memory.\",\n                    \"logic\": \"Checks the opcode of the node against a list of opcodes that are known not to allocate memory.  The 'Call' opcode is special-cased to check the call descriptor flags for kNoAllocate. This function lists all the opcodes that can appear in the effect chain and explicitly returns false if they cannot allocate, otherwise it returns true.  This covers both memory operations and pure control operations.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"node\",\n                            \"type\": \"const Node*\",\n                            \"purpose\": \"The node to check for allocation potential.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"bool\",\n                        \"description\": \"True if the node can allocate memory, false otherwise.\"\n                    },\n                    \"dependencies\": [\n                        \"IrOpcode\",\n                        \"CallDescriptorOf\",\n                        \"CallDescriptor\"\n                    ]\n                }\n                </metadata>\n                <code><![CDATA[\nbool CanAllocate(const Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kAbortCSADcheck:\n    case IrOpcode::kBitcastTaggedToWord:\n    case IrOpcode::kBitcastWordToTagged:\n    case IrOpcode::kCheckTurboshaftTypeOf:\n    case IrOpcode::kComment:\n    case IrOpcode::kDebugBreak:\n    case IrOpcode::kDeoptimizeIf:\n    case IrOpcode::kDeoptimizeUnless:\n    case IrOpcode::kEffectPhi:\n    case IrOpcode::kIfException:\n    case IrOpcode::kLoad:\n    case IrOpcode::kLoadImmutable:\n    case IrOpcode::kLoadElement:\n    case IrOpcode::kLoadField:\n    case IrOpcode::kLoadFromObject:\n    case IrOpcode::kLoadImmutableFromObject:\n    case IrOpcode::kMemoryBarrier:\n    case IrOpcode::kProtectedLoad:\n    case IrOpcode::kLoadTrapOnNull:\n    case IrOpcode::kProtectedStore:\n    case IrOpcode::kStoreTrapOnNull:\n    case IrOpcode::kRetain:\n    case IrOpcode::kStackPointerGreaterThan:\n#if V8_ENABLE_WEBASSEMBLY\n    case IrOpcode::kLoadLane:\n    case IrOpcode::kLoadTransform:\n    case IrOpcode::kStoreLane:\n    case IrOpcode::kLoadStackPointer:\n    case IrOpcode::kSetStackPointer:\n#endif  // V8_ENABLE_WEBASSEMBLY\n    case IrOpcode::kStaticAssert:\n    // TODO(turbofan): Store nodes might do a bump-pointer allocation.\n    //              We should introduce a special bump-pointer store node to\n    //              differentiate that.\n    case IrOpcode::kStore:\n    case IrOpcode::kStoreElement:\n    case IrOpcode::kStoreField:\n    case IrOpcode::kStoreToObject:\n    case IrOpcode::kTraceInstruction:\n    case IrOpcode::kInitializeImmutableInObject:\n    case IrOpcode::kTrapIf:\n    case IrOpcode::kTrapUnless:\n    case IrOpcode::kUnalignedLoad:\n    case IrOpcode::kUnalignedStore:\n    case IrOpcode::kUnreachable:\n    case IrOpcode::kWord32AtomicAdd:\n    case IrOpcode::kWord32AtomicAnd:\n    case IrOpcode::kWord32AtomicCompareExchange:\n    case IrOpcode::kWord32AtomicExchange:\n    case IrOpcode::kWord32AtomicLoad:\n    case IrOpcode::kWord32AtomicOr:\n    case IrOpcode::kWord32AtomicPairAdd:\n    case IrOpcode::kWord32AtomicPairAnd:\n    case IrOpcode::kWord32AtomicPairCompareExchange:\n    case IrOpcode::kWord32AtomicPairExchange:\n    case IrOpcode::kWord32AtomicPairLoad:\n    case IrOpcode::kWord32AtomicPairOr:\n    case IrOpcode::kWord32AtomicPairStore:\n    case IrOpcode::kWord32AtomicPairSub:\n    case IrOpcode::kWord32AtomicPairXor:\n    case IrOpcode::kWord32AtomicStore:\n    case IrOpcode::kWord32AtomicSub:\n    case IrOpcode::kWord32AtomicXor:\n    case IrOpcode::kWord64AtomicAdd:\n    case IrOpcode::kWord64AtomicAnd:\n    case IrOpcode::kWord64AtomicCompareExchange:\n    case IrOpcode::kWord64AtomicExchange:\n    case IrOpcode::kWord64AtomicLoad:\n    case IrOpcode::kWord64AtomicOr:\n    case IrOpcode::kWord64AtomicStore:\n    case IrOpcode::kWord64AtomicSub:\n    case IrOpcode::kWord64AtomicXor:\n      return false;\n\n    case IrOpcode::kCall:\n      return !(CallDescriptorOf(node->op())->flags() &\n               CallDescriptor::kNoAllocate);\n    default:\n      break;\n  }\n  return true;\n}\n                ]]></code>\n            </func>\n\n            <func>\n                <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"SearchAllocatingNode\",\n                    \"about\": \"Searches for a node in the effect chain that can allocate memory, starting from a given start node and traversing backwards until a limit node is reached.\",\n                    \"logic\": \"Uses a breadth-first search to traverse the effect chain.  It maintains a queue of nodes to visit and a set of visited nodes to avoid cycles.  For each node, it checks if it can allocate using the `CanAllocate` function. If it can, the node is returned.  Otherwise, the function adds the node's effect inputs to the queue and continues the search.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"start\",\n                            \"type\": \"Node*\",\n                            \"purpose\": \"The node to start the search from.\"\n                        },\n                        {\n                            \"name\": \"limit\",\n                            \"type\": \"Node*\",\n                            \"purpose\": \"The node to stop the search at.\"\n                        },\n                        {\n                            \"name\": \"temp_zone\",\n                            \"type\": \"Zone*\",\n                            \"purpose\": \"A temporary zone for allocating the queue and set.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"Node*\",\n                        \"description\": \"The first allocating node found, or nullptr if no allocating node is found before reaching the limit.\"\n                    },\n                    \"dependencies\": [\n                        \"ZoneQueue\",\n                        \"ZoneSet\",\n                        \"CanAllocate\",\n                        \"NodeProperties\",\n                        \"IrOpcode\"\n                    ]\n                }\n                </metadata>\n                <code><![CDATA[\nNode* SearchAllocatingNode(Node* start, Node* limit, Zone* temp_zone) {\n  ZoneQueue<Node*> queue(temp_zone);\n  ZoneSet<Node*> visited(temp_zone);\n  visited.insert(limit);\n  queue.push(start);\n\n  while (!queue.empty()) {\n    Node* const current = queue.front();\n    queue.pop();\n    if (visited.find(current) == visited.end()) {\n      visited.insert(current);\n\n      if (CanAllocate(current)) {\n        return current;\n      }\n\n      for (int i = 0; i < current->op()->EffectInputCount(); ++i) {\n        queue.push(NodeProperties::GetEffectInput(current, i));\n      }\n    }\n  }\n  return nullptr;\n}\n                ]]></code>\n            </func>\n\n            <func>\n                <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"CanLoopAllocate\",\n                    \"about\": \"Determines whether a loop can allocate memory by checking the loop's back edges for allocating nodes.\",\n                    \"logic\": \"Iterates through the control inputs of the loop's effect phi node (excluding the first input, which is the loop header). For each back edge, it calls `SearchAllocatingNode` to check if there is an allocating node between the back edge and the loop's effect phi node. If any back edge contains an allocating node, the function returns true, indicating that the loop can allocate.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"loop_effect_phi\",\n                            \"type\": \"Node*\",\n                            \"purpose\": \"The effect phi node representing the loop.\"\n                        },\n                        {\n                            \"name\": \"temp_zone\",\n                            \"type\": \"Zone*\",\n                            \"purpose\": \"A temporary zone for allocating the search structures.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"bool\",\n                        \"description\": \"True if the loop can allocate memory, false otherwise.\"\n                    },\n                    \"dependencies\": [\n                        \"NodeProperties\",\n                        \"SearchAllocatingNode\",\n                        \"IrOpcode\"\n                    ]\n                }\n                </metadata>\n                <code><![CDATA[\nbool CanLoopAllocate(Node* loop_effect_phi, Zone* temp_zone) {\n  Node* const control = NodeProperties::GetControlInput(loop_effect_phi);\n  // Start the effect chain walk from the loop back edges.\n  for (int i = 1; i < control->InputCount(); ++i) {\n    if (SearchAllocatingNode(loop_effect_phi->InputAt(i), loop_effect_phi,\n                             temp_zone) != nullptr) {\n      return true;\n    }\n  }\n  return false;\n}\n                ]]></code>\n            </func>\n\n            <func>\n                <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"EffectPhiForPhi\",\n                    \"about\": \"Finds the EffectPhi node corresponding to a given Phi node.\",\n                    \"logic\": \"Iterates through the uses of the control input of the Phi node. If a use is an EffectPhi node, it is returned.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"phi\",\n                            \"type\": \"Node*\",\n                            \"purpose\": \"The Phi node to find the corresponding EffectPhi for.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"Node*\",\n                        \"description\": \"The EffectPhi node corresponding to the Phi node, or nullptr if not found.\"\n                    },\n                    \"dependencies\": [\n                        \"NodeProperties\",\n                        \"IrOpcode\"\n                    ]\n                }\n                </metadata>\n                <code><![CDATA[\nNode* EffectPhiForPhi(Node* phi) {\n  Node* control = NodeProperties::GetControlInput(phi);\n  for (Node* use : control->uses()) {\n    if (use->opcode() == IrOpcode::kEffectPhi) {\n      return use;\n    }\n  }\n  return nullptr;\n}\n                ]]></code>\n            </func>\n\n            <func>\n                <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"WriteBarrierAssertFailed\",\n                    \"about\": \"Reports a fatal error when a write barrier removal fails, providing debugging information.\",\n                    \"logic\": \"Constructs an error message containing the node ID, instructions on how to use mksnapshot to break in CSA code, and information about potentially allocating nodes between the store and the allocation.  If such a node is found, its ID and instructions on how to break there are included. If the allocating node is a call, it suggests adding an exception to Runtime::MayAllocate if the call is known to never allocate.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"node\",\n                            \"type\": \"Node*\",\n                            \"purpose\": \"The node for which the write barrier removal failed.\"\n                        },\n                        {\n                            \"name\": \"object\",\n                            \"type\": \"Node*\",\n                            \"purpose\": \"The object being written to.\"\n                        },\n                        {\n                            \"name\": \"name\",\n                            \"type\": \"const char*\",\n                            \"purpose\": \"The name of the pass or function where the failure occurred.\"\n                        },\n                        {\n                            \"name\": \"temp_zone\",\n                            \"type\": \"Zone*\",\n                            \"purpose\": \"A temporary zone for allocating strings.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"void\",\n                        \"description\": \"This function does not return; it terminates the program.\"\n                    },\n                    \"dependencies\": [\n                        \"std::stringstream\",\n                        \"FATAL\",\n                        \"EffectPhiForPhi\",\n                        \"SearchAllocatingNode\",\n                        \"IrOpcode\"\n                    ]\n                }\n                </metadata>\n                <code><![CDATA[\nvoid WriteBarrierAssertFailed(Node* node, Node* object, const char* name,\n                              Zone* temp_zone) {\n  std::stringstream str;\n  str << \"MemoryOptimizer could not remove write barrier for node #\"\n      << node->id() << \"\\n\";\n  str << \"  Run mksnapshot with --csa-trap-on-node=\" << name << \",\"\n      << node->id() << \" to break in CSA code.\\n\";\n  Node* object_position = object;\n  if (object_position->opcode() == IrOpcode::kPhi) {\n    object_position = EffectPhiForPhi(object_position);\n  }\n  Node* allocating_node = nullptr;\n  if (object_position && object_position->op()->EffectOutputCount() > 0) {\n    allocating_node = SearchAllocatingNode(node, object_position, temp_zone);\n  }\n  if (allocating_node) {\n    str << \"\\n  There is a potentially allocating node in between:\\n\";\n    str << \"    \" << *allocating_node << \"\\n\";\n    str << \"  Run mksnapshot with --csa-trap-on-node=\" << name << \",\"\n        << allocating_node->id() << \" to break there.\\n\";\n    if (allocating_node->opcode() == IrOpcode::kCall) {\n      str << \"  If this is a never-allocating runtime call, you can add an \"\n             \"exception to Runtime::MayAllocate.\\n\";\n    }\n  } else {\n    str << \"\\n  It seems the store happened to something different than a \"\n           \"direct \"\n           \"allocation:\\n\";\n    str << \"    \" << *object << \"\\n\";\n    str << \"  Run mksnapshot with --csa-trap-on-node=\" << name << \",\"\n        << object->id() << \" to break there.\\n\";\n  }\n  FATAL(\"%s\", str.str().c_str());\n}\n                ]]></code>\n            </func>\n\n            <code><![CDATA[\n}  // namespace\n            ]]></code>\n        </namespace>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MemoryOptimizer\",\n                \"about\": \"The main class responsible for optimizing memory operations in the compiler graph. It performs allocation folding and reduces write barriers to improve performance.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_assembler_\",\n                        \"type\": \"GraphAssembler\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Used for building graph fragments.\"\n                    },\n                    {\n                        \"name\": \"memory_lowering_\",\n                        \"type\": \"MemoryLowering\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Performs the actual lowering of memory operations.\"\n                    },\n                    {\n                        \"name\": \"wasm_address_reassociation_\",\n                        \"type\": \"WasmAddressReassociation\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reassociates wasm addresses for better optimization.\"\n                    },\n                    {\n                        \"name\": \"jsgraph_\",\n                        \"type\": \"JSGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Provides access to the JavaScript graph.\"\n                    },\n                    {\n                        \"name\": \"empty_state_\",\n                        \"type\": \"AllocationState const*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents an empty allocation state.\"\n                    },\n                    {\n                        \"name\": \"pending_\",\n                        \"type\": \"std::unordered_map<NodeId, AllocationStates>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores pending effect merges.\"\n                    },\n                    {\n                        \"name\": \"tokens_\",\n                        \"type\": \"std::queue<Token>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Queue of nodes to visit.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The zone for allocating temporary data structures.\"\n                    },\n                    {\n                        \"name\": \"tick_counter_\",\n                        \"type\": \"TickCounter*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A tick counter to allow interruption for safepoints.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"JSGraph\",\n                    \"Zone\",\n                    \"MemoryLowering\",\n                    \"GraphAssembler\",\n                    \"WasmAddressReassociation\",\n                    \"AllocationState\",\n                    \"TFGraph\",\n                    \"Token\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nclass MemoryOptimizer {\n public:\n  MemoryOptimizer(\n      JSHeapBroker* broker, JSGraph* jsgraph, Zone* zone,\n      MemoryLowering::AllocationFolding allocation_folding,\n      const char* function_debug_name, TickCounter* tick_counter, bool is_wasm)\n      : graph_assembler_(broker, jsgraph, zone, BranchSemantics::kMachine),\n        memory_lowering_(jsgraph, zone, &graph_assembler_, is_wasm,\n                         allocation_folding, WriteBarrierAssertFailed,\n                         function_debug_name),\n        wasm_address_reassociation_(jsgraph, zone),\n        jsgraph_(jsgraph),\n        empty_state_(AllocationState::Empty(zone)),\n        pending_(zone),\n        tokens_(zone),\n        zone_(zone),\n        tick_counter_(tick_counter) {}\n\n  void Optimize();\n\n private:\n  struct Token {\n    Node* node;\n    AllocationState const* state;\n    NodeId effect_chain;\n  };\n\n  void VisitNode(Node* node, AllocationState const* state,\n                                  NodeId effect_chain);\n  bool AllocationTypeNeedsUpdateToOld(Node* const node,\n                                                     const Edge edge);\n  void ReplaceUsesAndKillNode(Node* node, Node* replacement);\n\n  void VisitAllocateRaw(Node* node, AllocationState const* state,\n                                       NodeId effect_chain);\n  void VisitLoadFromObject(Node* node,\n                                          AllocationState const* state,\n                                          NodeId effect_chain);\n  void VisitStoreToObject(Node* node,\n                                         AllocationState const* state,\n                                         NodeId effect_chain);\n  void VisitLoadElement(Node* node, AllocationState const* state,\n                                       NodeId effect_chain);\n  void VisitLoadField(Node* node, AllocationState const* state,\n                                     NodeId effect_chain);\n  void VisitProtectedLoad(Node* node,\n                                         AllocationState const* state,\n                                         NodeId effect_chain);\n  void VisitProtectedStore(Node* node,\n                                          AllocationState const* state,\n                                          NodeId effect_chain);\n  void VisitStoreElement(Node* node,\n                                        AllocationState const* state,\n                                        NodeId effect_chain);\n  void VisitStoreField(Node* node, AllocationState const* state,\n                                      NodeId effect_chain);\n  void VisitStore(Node* node, AllocationState const* state,\n                                 NodeId effect_chain);\n  void VisitCall(Node* node, AllocationState const* state,\n                                NodeId effect_chain);\n  void VisitOtherEffect(Node* node, AllocationState const* state,\n                                       NodeId effect_chain);\n\n  AllocationState const* MergeStates(AllocationStates const& states);\n  void EnqueueMerge(Node* node, int index,\n                                   AllocationState const* state);\n  void EnqueueUses(Node* node, AllocationState const* state,\n                                  NodeId effect_chain);\n  void EnqueueUse(Node* node, int index,\n                                 AllocationState const* state,\n                                 NodeId effect_chain);\n\n  MemoryLowering* memory_lowering() { return &memory_lowering_; }\n  WasmAddressReassociation* wasm_address_reassociation() {\n    return &wasm_address_reassociation_;\n  }\n  TFGraph* graph() const { return jsgraph()->graph(); }\n  JSGraph* jsgraph() const { return jsgraph_; }\n  Zone* zone() const { return zone_; }\n\n  GraphAssembler graph_assembler_;\n  MemoryLowering memory_lowering_;\n  WasmAddressReassociation wasm_address_reassociation_;\n  JSGraph* jsgraph_;\n  AllocationState const* empty_state_;\n  std::unordered_map<NodeId, AllocationStates> pending_;\n  std::queue<Token> tokens_;\n  Zone* zone_;\n  TickCounter* tick_counter_;\n};\n            ]]></code>\n        </class>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Optimize\",\n                \"parent\": \"MemoryOptimizer\",\n                \"about\": \"The main entry point for the memory optimization pass. It initializes the allocation state and traverses the graph, visiting each node and applying memory optimizations.\",\n                \"logic\": \"It initializes the traversal by enqueuing the start node of the graph with an empty allocation state. Then, it enters a loop that continues until the queue of nodes to visit (`tokens_`) is empty. In each iteration, it dequeues a node and calls `VisitNode` to perform optimizations specific to that node type. After the main loop, it calls `wasm_address_reassociation()->Optimize()` if wasm address reassociation is enabled, and then checks that the pending and tokens queues are empty.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"This method does not return a value.\"\n                },\n                \"dependencies\": [\n                    \"graph\",\n                    \"empty_state\",\n                    \"EnqueueUses\",\n                    \"VisitNode\",\n                    \"wasm_address_reassociation\",\n                    \"v8_flags.turbo_wasm_address_reassociation\",\n                    \"DCHECK\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nvoid MemoryOptimizer::Optimize() {\n  EnqueueUses(graph()->start(), empty_state(), graph()->start()->id());\n  while (!tokens_.empty()) {\n    Token const token = tokens_.front();\n    tokens_.pop();\n    VisitNode(token.node, token.state, token.effect_chain);\n  }\n  if (v8_flags.turbo_wasm_address_reassociation) {\n    wasm_address_reassociation()->Optimize();\n  }\n  DCHECK(pending_.empty());\n  DCHECK(tokens_.empty());\n}\n            ]]></code>\n        </func>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VisitNode\",\n                \"parent\": \"MemoryOptimizer\",\n                \"about\": \"Visits a node in the graph and performs memory-related optimizations based on the node's opcode.\",\n                \"logic\": \"This method uses a switch statement to handle different node opcodes. For each opcode, it calls a corresponding `Visit...` method to perform the specific optimization. If the node's opcode does not correspond to a memory operation, the `VisitOtherEffect` method is called. After visiting a node, `EnqueueUses` is called to enqueue the uses of the node for further processing.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to visit.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"AllocationState const*\",\n                        \"purpose\": \"The allocation state at the current node.\"\n                    },\n                    {\n                        \"name\": \"effect_chain\",\n                        \"type\": \"NodeId\",\n                        \"purpose\": \"The ID of the effect chain the node belongs to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"This method does not return a value.\"\n                },\n                \"dependencies\": [\n                    \"IrOpcode\",\n                    \"VisitAllocateRaw\",\n                    \"VisitCall\",\n                    \"VisitLoadFromObject\",\n                    \"VisitLoadElement\",\n                    \"VisitLoadField\",\n                    \"VisitProtectedLoad\",\n                    \"VisitProtectedStore\",\n                    \"VisitStoreToObject\",\n                    \"VisitStoreElement\",\n                    \"VisitStoreField\",\n                    \"VisitStore\",\n                    \"VisitOtherEffect\",\n                    \"CanAllocate\",\n                    \"DCHECK\",\n                    \"UNREACHABLE\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nvoid MemoryOptimizer::VisitNode(Node* node, AllocationState const* state,\n                                NodeId effect_chain) {\n  tick_counter_->TickAndMaybeEnterSafepoint();\n  DCHECK(!node->IsDead());\n  DCHECK_LT(0, node->op()->EffectInputCount());\n  switch (node->opcode()) {\n    case IrOpcode::kAllocate:\n      // Allocate nodes were purged from the graph in effect-control\n      // linearization.\n      UNREACHABLE();\n    case IrOpcode::kAllocateRaw:\n      return VisitAllocateRaw(node, state, effect_chain);\n    case IrOpcode::kCall:\n      return VisitCall(node, state, effect_chain);\n    case IrOpcode::kLoadFromObject:\n    case IrOpcode::kLoadImmutableFromObject:\n      return VisitLoadFromObject(node, state, effect_chain);\n    case IrOpcode::kLoadElement:\n      return VisitLoadElement(node, state, effect_chain);\n    case IrOpcode::kLoadField:\n      return VisitLoadField(node, state, effect_chain);\n    case IrOpcode::kProtectedLoad:\n      return VisitProtectedLoad(node, state, effect_chain);\n    case IrOpcode::kProtectedStore:\n      return VisitProtectedStore(node, state, effect_chain);\n    case IrOpcode::kStoreToObject:\n    case IrOpcode::kInitializeImmutableInObject:\n      return VisitStoreToObject(node, state, effect_chain);\n    case IrOpcode::kStoreElement:\n      return VisitStoreElement(node, state, effect_chain);\n    case IrOpcode::kStoreField:\n      return VisitStoreField(node, state, effect_chain);\n    case IrOpcode::kStore:\n      return VisitStore(node, state, effect_chain);\n    case IrOpcode::kStorePair:\n      // Store pairing should happen after this pass.\n      UNREACHABLE();\n    default:\n      if (!CanAllocate(node)) {\n        // These operations cannot trigger GC.\n        return VisitOtherEffect(node, state, effect_chain);\n      }\n  }\n  DCHECK_EQ(0, node->op()->EffectOutputCount());\n}\n            ]]></code>\n        </func>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocationTypeNeedsUpdateToOld\",\n                \"parent\": \"MemoryOptimizer\",\n                \"about\": \"Determines if the AllocationType needs to be updated to Old for a given store field node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node* const\",\n                        \"purpose\": \"The node to check.\"\n                    },\n                    {\n                        \"name\": \"edge\",\n                        \"type\": \"const Edge\",\n                        \"purpose\": \"The edge connecting the node to its user.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the AllocationType needs to be updated to Old, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"IrOpcode\",\n                    \"AllocationTypeOf\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nbool MemoryOptimizer::AllocationTypeNeedsUpdateToOld(Node* const node,\n                                                     const Edge edge) {\n  // Test to see if we need to update the AllocationType.\n  if (node->opcode() == IrOpcode::kStoreField && edge.index() == 1) {\n    Node* parent = node->InputAt(0);\n    if (parent->opcode() == IrOpcode::kAllocateRaw &&\n        AllocationTypeOf(parent->op()) == AllocationType::kOld) {\n      return true;\n    }\n  }\n\n  return false;\n}\n            ]]></code>\n        </func>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReplaceUsesAndKillNode\",\n                \"parent\": \"MemoryOptimizer\",\n                \"about\": \"Replaces all uses of a node with a replacement node and then kills the original node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to replace.\"\n                    },\n                    {\n                        \"name\": \"replacement\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to replace with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"This method does not return a value.\"\n                },\n                \"dependencies\": [\n                    \"NodeProperties\",\n                    \"graph_assembler_\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nvoid MemoryOptimizer::ReplaceUsesAndKillNode(Node* node, Node* replacement) {\n  // Replace all uses of node and kill the node to make sure we don't leave\n  // dangling dead uses.\n  DCHECK_NE(replacement, node);\n  NodeProperties::ReplaceUses(node, replacement, graph_assembler_.effect(),\n                              graph_assembler_.control());\n  node->Kill();\n}\n            ]]></code>\n        </func>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VisitAllocateRaw\",\n                \"parent\": \"MemoryOptimizer\",\n                \"about\": \"Visits an AllocateRaw node and performs allocation folding.\",\n                \"logic\": \"This method retrieves the allocation type from the AllocateRaw node. It propagates tenuring from outer allocations to inner allocations. It then calls `memory_lowering()->ReduceAllocateRaw` to perform the actual allocation folding. Finally, it replaces the AllocateRaw node with the result of the reduction and enqueues the uses of the new node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The AllocateRaw node to visit.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"AllocationState const*\",\n                        \"purpose\": \"The allocation state at the current node.\"\n                    },\n                    {\n                        \"name\": \"effect_chain\",\n                        \"type\": \"NodeId\",\n                        \"purpose\": \"The ID of the effect chain the node belongs to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"This method does not return a value.\"\n                },\n                \"dependencies\": [\n                    \"IrOpcode\",\n                    \"AllocateParametersOf\",\n                    \"AllocationType\",\n                    \"AllocationTypeOf\",\n                    \"memory_lowering\",\n                    \"ReduceAllocateRaw\",\n                    \"ReplaceUsesAndKillNode\",\n                    \"EnqueueUses\",\n                    \"DCHECK\",\n                    \"CHECK\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nvoid MemoryOptimizer::VisitAllocateRaw(Node* node, AllocationState const* state,\n                                       NodeId effect_chain) {\n  DCHECK_EQ(IrOpcode::kAllocateRaw, node->opcode());\n  const AllocateParameters& allocation = AllocateParametersOf(node->op());\n  AllocationType allocation_type = allocation.allocation_type();\n\n  // Propagate tenuring from outer allocations to inner allocations, i.e.\n  // when we allocate an object in old space and store a newly allocated\n  // child object into the pretenured object, then the newly allocated\n  // child object also should get pretenured to old space.\n  if (allocation_type == AllocationType::kOld) {\n    for (Edge const edge : node->use_edges()) {\n      Node* const user = edge.from();\n      if (user->"
}