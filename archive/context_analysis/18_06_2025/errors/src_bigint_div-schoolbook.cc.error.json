{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/bigint/div-schoolbook.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 205, column 73",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/bigint/div-schoolbook.cc\",\n            \"file_name\": \"div-schoolbook.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements schoolbook long division algorithm for BigIntegers.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library limits and project specific headers for BigInt operations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <limits>\n\n            #include \"src/bigint/bigint-internal.h\"\n            #include \"src/bigint/digit-arithmetic.h\"\n            #include \"src/bigint/div-helpers.h\"\n            #include \"src/bigint/util.h\"\n            #include \"src/bigint/vector-arithmetic.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DivideSingle\",\n                \"parent\": \"ProcessorImpl\",\n                \"about\": \"Divides a multi-digit number A by a single-digit number b, returning the quotient Q and remainder.\",\n                \"logic\": \"Iterates through the digits of A, performing division digit by digit and updating the remainder. If Q.len is 0, only computes the remainder.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Q\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The quotient (output).\"\n                    },\n                    {\n                        \"name\": \"remainder\",\n                        \"type\": \"digit_t*\",\n                        \"purpose\": \"Pointer to store the remainder (output).\"\n                    },\n                    {\n                        \"name\": \"A\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The dividend.\"\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"type\": \"digit_t\",\n                        \"purpose\": \"The divisor.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value. Quotient and remainder are passed via arguments.\"\n                },\n                \"dependencies\": [\n                    \"digit_div\",\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::DivideSingle(RWDigits Q, digit_t* remainder, Digits A,\n                                             digit_t b) {\n              DCHECK(b != 0);\n              DCHECK(A.len() > 0);\n              *remainder = 0;\n              int length = A.len();\n              if (Q.len() != 0) {\n                if (A[length - 1] >= b) {\n                  DCHECK(Q.len() >= A.len());\n                  for (int i = length - 1; i >= 0; i--) {\n                    Q[i] = digit_div(*remainder, A[i], b, remainder);\n                  }\n                  for (int i = length; i < Q.len(); i++) Q[i] = 0;\n                } else {\n                  DCHECK(Q.len() >= A.len() - 1);\n                  *remainder = A[length - 1];\n                  for (int i = length - 2; i >= 0; i--) {\n                    Q[i] = digit_div(*remainder, A[i], b, remainder);\n                  }\n                  for (int i = length - 1; i < Q.len(); i++) Q[i] = 0;\n                }\n              } else {\n                for (int i = length - 1; i >= 0; i--) {\n                  digit_div(*remainder, A[i], b, remainder);\n                }\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"InplaceAdd\",\n                \"about\": \"Adds the digits of X to Z, modifying Z in place. Returns the carry.\",\n                \"logic\": \"Uses AddAndReturnCarry to perform the addition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination and first operand (modified in place).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second operand.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"digit_t\",\n                    \"description\": \"The carry after the addition.\"\n                },\n                \"dependencies\": [\n                    \"AddAndReturnCarry\",\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline digit_t InplaceAdd(RWDigits Z, Digits X) {\n              return AddAndReturnCarry(Z, Z, X);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"InplaceSub\",\n                \"about\": \"Subtracts the digits of X from Z, modifying Z in place. Returns the borrow.\",\n                \"logic\": \"Uses SubtractAndReturnBorrow to perform the subtraction.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination and first operand (modified in place).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second operand.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"digit_t\",\n                    \"description\": \"The borrow after the subtraction.\"\n                },\n                \"dependencies\": [\n                    \"SubtractAndReturnBorrow\",\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline digit_t InplaceSub(RWDigits Z, Digits X) {\n              return SubtractAndReturnBorrow(Z, Z, X);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ProductGreaterThan\",\n                \"about\": \"Checks if the product of two single-digit numbers is greater than a two-digit number.\",\n                \"logic\": \"Calculates the product and compares the high and low digits with the given high and low digits.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"factor1\",\n                        \"type\": \"digit_t\",\n                        \"purpose\": \"The first factor.\"\n                    },\n                    {\n                        \"name\": \"factor2\",\n                        \"type\": \"digit_t\",\n                        \"purpose\": \"The second factor.\"\n                    },\n                    {\n                        \"name\": \"high\",\n                        \"type\": \"digit_t\",\n                        \"purpose\": \"The high digit of the number to compare against.\"\n                    },\n                    {\n                        \"name\": \"low\",\n                        \"type\": \"digit_t\",\n                        \"purpose\": \"The low digit of the number to compare against.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if (factor1 * factor2) > (high << kDigitBits) + low, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"digit_mul\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool ProductGreaterThan(digit_t factor1, digit_t factor2, digit_t high,\n                                    digit_t low) {\n              digit_t result_high;\n              digit_t result_low = digit_mul(factor1, factor2, &result_high);\n              return result_high > high || (result_high == high && result_low > low);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"QLengthOK\",\n                \"about\": \"Debug function to check if the quotient length is valid given the dividend and divisor lengths.\",\n                \"logic\": \"Determines if the top digits of A are greater or equal to B. Based on this condition calculates the expected Q length, and returns if the provided Q matches that size.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Q\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The Quotient digits.\"\n                    },\n                    {\n                        \"name\": \"A\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The Dividend digits.\"\n                    },\n                    {\n                        \"name\": \"B\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The Divisor digits.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if quotient length is ok, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"GreaterThanOrEqual\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool QLengthOK(Digits Q, Digits A, Digits B) {\n              // If A's top B.len digits are greater than or equal to B, then the division\n              // result will be greater than A.len - B.len, otherwise it will be that\n              // difference. Intuitively: 100/10 has 2 digits, 100/11 has 1.\n              if (GreaterThanOrEqual(Digits(A, A.len() - B.len(), B.len()), B)) {\n                return Q.len() >= A.len() - B.len() + 1;\n              }\n              return Q.len() >= A.len() - B.len();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DivideSchoolbook\",\n                \"parent\": \"ProcessorImpl\",\n                \"about\": \"Implements the schoolbook long division algorithm for BigIntegers.\",\n                \"logic\": \"This function performs long division using the classic schoolbook algorithm (Knuth's Algorithm D). It normalizes the divisor, shifts the dividend, estimates quotient digits, subtracts multiples of the divisor, and adjusts the quotient as needed. The algorithm is implemented based on Knuth and the Go implementation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Q\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The quotient (output).\"\n                    },\n                    {\n                        \"name\": \"R\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The remainder (output).\"\n                    },\n                    {\n                        \"name\": \"A\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The dividend.\"\n                    },\n                    {\n                        \"name\": \"B\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The divisor.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value. Quotient and remainder are passed via arguments.\"\n                },\n                \"dependencies\": [\n                    \"LeftShift\",\n                    \"MultiplySingle\",\n                    \"InplaceSub\",\n                    \"InplaceAdd\",\n                    \"RightShift\",\n                    \"digit_div\",\n                    \"GreaterThanOrEqual\",\n                    \"RWDigits\",\n                    \"Digits\",\n                    \"ScratchDigits\",\n                    \"ShiftedDigits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::DivideSchoolbook(RWDigits Q, RWDigits R, Digits A,\n                                                 Digits B) {\n              DCHECK(B.len() >= 2);        // Use DivideSingle otherwise.\n              DCHECK(A.len() >= B.len());  // No-op otherwise.\n              DCHECK(Q.len() == 0 || QLengthOK(Q, A, B));\n              DCHECK(R.len() == 0 || R.len() >= B.len());\n              // The unusual variable names inside this function are consistent with\n              // Knuth's book, as well as with Go's implementation of this algorithm.\n              // Maintaining this consistency is probably more useful than trying to\n              // come up with more descriptive names for them.\n              const int n = B.len();\n              const int m = A.len() - n;\n\n              // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.\n              // \"v\" is the book's name for {divisor}, \"qhat\" the current quotient digit.\n              ScratchDigits qhatv(n + 1);\n\n              // D1.\n              // Left-shift inputs so that the divisor's MSB is set. This is necessary\n              // to prevent the digit-wise divisions (see digit_div call below) from\n              // overflowing (they take a two digits wide input, and return a one digit\n              // result).\n              ShiftedDigits b_normalized(B);\n              B = b_normalized;\n              // U holds the (continuously updated) remaining part of the dividend, which\n              // eventually becomes the remainder.\n              ScratchDigits U(A.len() + 1);\n              LeftShift(U, A, b_normalized.shift());\n\n              // D2.\n              // Iterate over the dividend's digits (like the \"grad school\" algorithm).\n              // {vn1} is the divisor's most significant digit.\n              digit_t vn1 = B[n - 1];\n              for (int j = m; j >= 0; j--) {\n                // D3.\n                // Estimate the current iteration's quotient digit (see Knuth for details).\n                // {qhat} is the current quotient digit.\n                digit_t qhat = std::numeric_limits<digit_t>::max();\n                // {ujn} is the dividend's most significant remaining digit.\n                digit_t ujn = U[j + n];\n                if (ujn != vn1) {\n                  // {rhat} is the current iteration's remainder.\n                  digit_t rhat = 0;\n                  // Estimate the current quotient digit by dividing the most significant\n                  // digits of dividend and divisor. The result will not be too small,\n                  // but could be a bit too large.\n                  qhat = digit_div(ujn, U[j + n - 1], vn1, &rhat);\n\n                  // Decrement the quotient estimate as needed by looking at the next\n                  // digit, i.e. by testing whether\n                  // qhat * v_{n-2} > (rhat << kDigitBits) + u_{j+n-2}.\n                  digit_t vn2 = B[n - 2];\n                  digit_t ujn2 = U[j + n - 2];\n                  while (ProductGreaterThan(qhat, vn2, rhat, ujn2)) {\n                    qhat--;\n                    digit_t prev_rhat = rhat;\n                    rhat += vn1;\n                    // v[n-1] >= 0, so this tests for overflow.\n                    if (rhat < prev_rhat) break;\n                  }\n                }\n\n                // D4.\n                // Multiply the divisor with the current quotient digit, and subtract\n                // it from the dividend. If there was \"borrow\", then the quotient digit\n                // was one too high, so we must correct it and undo one subtraction of\n                // the (shifted) divisor.\n                if (qhat == 0) {\n                  qhatv.Clear();\n                } else {\n                  MultiplySingle(qhatv, B, qhat);\n                }\n                digit_t c = InplaceSub(U + j, qhatv);\n                if (c != 0) {\n                  c = InplaceAdd(U + j, B);\n                  U[j + n] = U[j + n] + c;\n                  qhat--;\n                }\n\n                if (Q.len() != 0) {\n                  if (j >= Q.len()) {\n                    DCHECK(qhat == 0);\n                  } else {\n                    Q[j] = qhat;\n                  }\n                }\n              }\n              if (R.len() != 0) {\n                RightShift(R, U, b_normalized.shift());\n              }\n              // If Q has extra storage, clear it.\n              for (int i = m + 1; i < Q.len(); i++) Q[i] = 0;\n            }\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ProcessorImpl\",\n                    \"about\": \"A class which contains implementations of the BigInt operations.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 {\n                namespace bigint {\n                class ProcessorImpl {\n                public:\n                  void DivideSingle(RWDigits Q, digit_t* remainder, Digits A, digit_t b);\n                  void DivideSchoolbook(RWDigits Q, RWDigits R, Digits A, Digits B);\n                };\n                }\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Digits\",\n                    \"about\": \"Represents a read-only sequence of digits (used for BigInt representation).\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Digits {\n                public:\n                    digit_t operator[](int i) const { return data_[i]; }\n                    int len() const { return len_; }\n                    Digits(const digit_t* data, int len) : data_(data), len_(len) {}\n                    Digits(const Digits& other, int offset, int len) : data_(other.data_ + offset), len_(len) {}\n                private:\n                    const digit_t* data_;\n                    int len_;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RWDigits\",\n                    \"about\": \"Represents a writable sequence of digits (used for BigInt representation).\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class RWDigits {\n                public:\n                    digit_t operator[](int i) const { return data_[i]; }\n                    digit_t& operator[](int i) { return data_[i]; }\n                    int len() const { return len_; }\n                private:\n                    digit_t* data_;\n                    int len_;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ScratchDigits\",\n                    \"about\": \"Represents a temporary, writable sequence of digits (used for intermediate calculations).\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ScratchDigits : public RWDigits {\n                public:\n                  void Clear();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ShiftedDigits\",\n                    \"about\": \"A wrapper around Digits that allows shifting its contents.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ShiftedDigits {\n                public:\n                  int shift() const { return shift_; }\n                };\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"digit_div\",\n                    \"about\": \"Divides a two-digit number by a single-digit number, returning the quotient and remainder.\",\n                    \"parameters\": [],\n                    \"return\": {}\n                }\n            </metadata>\n            <code><![CDATA[\n                digit_t digit_div(digit_t high, digit_t low, digit_t divisor, digit_t* remainder);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"AddAndReturnCarry\",\n                    \"about\": \"Adds two multi-digit numbers and returns the carry.\",\n                    \"parameters\": [],\n                    \"return\": {}\n                }\n            </metadata>\n            <code><![CDATA[\n                digit_t AddAndReturnCarry(RWDigits Z, Digits X, Digits Y);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"SubtractAndReturnBorrow\",\n                    \"about\": \"Subtracts one multi-digit number from another and returns the borrow.\",\n                    \"parameters\": [],\n                    \"return\": {}\n                }\n            </metadata>\n            <code><![CDATA[\n                digit_t SubtractAndReturnBorrow(RWDigits Z, Digits X, Digits Y);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"digit_mul\",\n                    \"about\": \"Multiplies two single-digit numbers, returning the low and high digits of the result.\",\n                    \"parameters\": [],\n                    \"return\": {}\n                }\n            </metadata>\n            <code><![CDATA[\n                digit_t digit_mul(digit_t factor1, digit_t factor2, digit_t* result_high);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"LeftShift\",\n                    \"about\": \"Shifts digits left.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                void LeftShift(RWDigits dst, Digits src, int shift);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"MultiplySingle\",\n                    \"about\": \"Multiplies digits by a single digit.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                void MultiplySingle(RWDigits dst, Digits src, digit_t factor);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"RightShift\",\n                    \"about\": \"Shifts digits right.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                void RightShift(RWDigits dst, Digits src, int shift);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"GreaterThanOrEqual\",\n                    \"about\": \"Compares two multi-digit numbers\"\n                }\n            </metadata>\n            <code><![CDATA[\n                bool GreaterThanOrEqual(Digits a, Digits b);\n            ]]></code>\n        </func>\n    </dependencies>\n</file>\n```"
}