{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/declarations.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 198, column 57",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/declarations.h\",\n        \"file_name\": \"declarations.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Declarations class and related functions for managing Torque language declarations, including macros, types, builtins, and namespaces.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary standard library headers and Torque-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <memory>\n            #include <optional>\n            #include <string>\n\n            #include \"src/torque/declarable.h\"\n            #include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Declarations\",\n            \"about\": \"Provides static methods for looking up and declaring various Torque language constructs.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Declarable\",\n                \"QualifiedName\",\n                \"TypeAlias\",\n                \"Type\",\n                \"Identifier\",\n                \"Builtin\",\n                \"BuiltinPointerType\",\n                \"Value\",\n                \"Macro\",\n                \"TypeVector\",\n                \"GenericCallable\",\n                \"GenericType\",\n                \"Namespace\",\n                \"TypeDeclaration\",\n                \"Signature\",\n                \"Statement\",\n                \"AggregateType\",\n                \"Expression\",\n                \"GenericCallableDeclaration\",\n                \"GenericTypeDeclaration\",\n                \"CurrentScope\",\n                \"TorqueMacro\",\n                \"ExternMacro\",\n                \"Method\",\n                \"Intrinsic\",\n                \"RuntimeFunction\",\n                \"ExternConstant\",\n                \"NamespaceConstant\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        class Declarations {\n        public:\n            static std::vector<Declarable*> TryLookup(const QualifiedName& name) {\n                return CurrentScope::Get()->Lookup(name);\n            }\n\n            static std::vector<Declarable*> TryLookupShallow(const QualifiedName& name) {\n                return CurrentScope::Get()->LookupShallow(name);\n            }\n\n            template <class T>\n            static std::vector<T*> TryLookup(const QualifiedName& name) {\n                return FilterDeclarables<T>(TryLookup(name));\n            }\n\n            static std::vector<Declarable*> Lookup(const QualifiedName& name) {\n                std::vector<Declarable*> d = TryLookup(name);\n                if (d.empty()) {\n                    ReportError(\"cannot find \\\"\", name, \"\\\"\");\n                }\n                return d;\n            }\n\n            static std::vector<Declarable*> LookupGlobalScope(const QualifiedName& name);\n\n            static const TypeAlias* LookupTypeAlias(const QualifiedName& name);\n            static const Type* LookupType(const QualifiedName& name);\n            static const Type* LookupType(const Identifier* identifier);\n            static std::optional<const Type*> TryLookupType(const QualifiedName& name);\n            static const Type* LookupGlobalType(const QualifiedName& name);\n\n            static Builtin* FindSomeInternalBuiltinWithType(\n                const BuiltinPointerType* type);\n\n            static Value* LookupValue(const QualifiedName& name);\n\n            static Macro* TryLookupMacro(const std::string& name,\n                                        const TypeVector& types);\n            static std::optional<Builtin*> TryLookupBuiltin(const QualifiedName& name);\n\n            static std::vector<GenericCallable*> LookupGeneric(const std::string& name);\n            static GenericCallable* LookupUniqueGeneric(const QualifiedName& name);\n\n            static GenericType* LookupUniqueGenericType(const QualifiedName& name);\n            static GenericType* LookupGlobalUniqueGenericType(const std::string& name);\n            static std::optional<GenericType*> TryLookupGenericType(\n                const QualifiedName& name);\n\n            static Namespace* DeclareNamespace(const std::string& name);\n            static TypeAlias* DeclareType(const Identifier* name, const Type* type);\n\n            static TypeAlias* PredeclareTypeAlias(const Identifier* name,\n                                                TypeDeclaration* type,\n                                                bool redeclaration);\n            static TorqueMacro* CreateTorqueMacro(std::string external_name,\n                                                std::string readable_name,\n                                                bool exported_to_csa,\n                                                Signature signature,\n                                                std::optional<Statement*> body,\n                                                bool is_user_defined);\n            static ExternMacro* CreateExternMacro(std::string name,\n                                                std::string external_assembler_name,\n                                                Signature signature);\n            static Macro* DeclareMacro(const std::string& name, bool accessible_from_csa,\n                                     std::optional<std::string> external_assembler_name,\n                                     const Signature& signature,\n                                     std::optional<Statement*> body,\n                                     std::optional<std::string> op = {},\n                                     bool is_user_defined = true);\n\n            static Method* CreateMethod(AggregateType* class_type,\n                                      const std::string& name, Signature signature,\n                                      Statement* body);\n\n            static Intrinsic* CreateIntrinsic(const std::string& name,\n                                                const Signature& signature);\n\n            static Intrinsic* DeclareIntrinsic(const std::string& name,\n                                                 const Signature& signature);\n\n            static Builtin* CreateBuiltin(std::string external_name,\n                                         std::string readable_name, Builtin::Kind kind,\n                                         Builtin::Flags flags, Signature signature,\n                                         std::optional<std::string> use_counter_name,\n                                         std::optional<Statement*> body);\n\n            static RuntimeFunction* DeclareRuntimeFunction(const std::string& name,\n                                                          const Signature& signature);\n\n            static ExternConstant* DeclareExternConstant(Identifier* name,\n                                                        const Type* type,\n                                                        std::string value);\n            static NamespaceConstant* DeclareNamespaceConstant(Identifier* name,\n                                                        const Type* type,\n                                                        Expression* body);\n\n            static GenericCallable* DeclareGenericCallable(\n                const std::string& name, GenericCallableDeclaration* ast_node);\n            static GenericType* DeclareGenericType(const std::string& name,\n                                                 GenericTypeDeclaration* ast_node);\n\n            template <class T>\n            static T* Declare(const std::string& name, T* d) {\n                CurrentScope::Get()->AddDeclarable(name, d);\n                return d;\n            }\n            template <class T>\n            static T* Declare(const std::string& name, std::unique_ptr<T> d) {\n                return CurrentScope::Get()->AddDeclarable(name,\n                                                          RegisterDeclarable(std::move(d)));\n            }\n            static Macro* DeclareOperator(const std::string& name, Macro* m);\n\n            static std::string GetGeneratedCallableName(\n                const std::string& name, const TypeVector& specialized_types);\n        };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FilterDeclarables\",\n            \"about\": \"Filters a vector of Declarable pointers and returns a vector of pointers to a specific derived type.\",\n            \"logic\": \"Iterates through the input vector, uses DynamicCast to check if each element is of type T, and adds it to the result vector if it is.\",\n            \"parameters\": [\n                {\n                    \"name\": \"list\",\n                    \"type\": \"const std::vector<Declarable*>\",\n                    \"purpose\": \"The input vector of Declarable pointers.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::vector<T*>\",\n                \"description\": \"A vector of pointers to objects of type T that were originally Declarables.\"\n            },\n            \"dependencies\": [\n                \"Declarable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        template <class T>\n        std::vector<T*> FilterDeclarables(const std::vector<Declarable*> list) {\n          std::vector<T*> result;\n          for (Declarable* declarable : list) {\n            if (T* t = T::DynamicCast(declarable)) {\n              result.push_back(t);\n            }\n          }\n          return result;\n        }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"UnwrapTNodeTypeName\",\n            \"about\": \"Unwraps the type name from a TNode type string.\",\n            \"logic\": \"Checks if the input string starts with 'TNode<' and ends with '>', then extracts the type name between them. Reports an error if the format is invalid.\",\n            \"parameters\": [\n                {\n                    \"name\": \"generates\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string representing the TNode type name.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The unwrapped type name.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        inline std::string UnwrapTNodeTypeName(const std::string& generates) {\n          if (generates.length() < 7 || generates.substr(0, 6) != \"TNode<\" ||\n              generates.substr(generates.length() - 1, 1) != \">\") {\n            ReportError(\"generated type \\\"\", generates,\n                        \"\\\" should be of the form \\\"TNode<...>\\\"\");\n          }\n          return generates.substr(6, generates.length() - 7);\n        }\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Declarable\",\n                \"about\": \"Base class for all declarable entities in Torque.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Declarable {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"QualifiedName\",\n                \"about\": \"Represents a qualified name in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class QualifiedName {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TypeAlias\",\n                \"about\": \"Represents a type alias in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TypeAlias {};\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Type\",\n                \"about\": \"Represents a type in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Type {};\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Identifier\",\n                \"about\": \"Represents an identifier in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Identifier {};\n            ]]></code>\n        </class>\n                        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Builtin\",\n                \"about\": \"Represents a builtin function in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Builtin {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BuiltinPointerType\",\n                \"about\": \"Represents the type of a builtin function pointer.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class BuiltinPointerType {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Value\",\n                \"about\": \"Represents a value in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Value {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Macro\",\n                \"about\": \"Represents a macro in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Macro {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TypeVector\",\n                \"about\": \"Represents a vector of types in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TypeVector {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GenericCallable\",\n                \"about\": \"Represents a generic callable in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class GenericCallable {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GenericType\",\n                \"about\": \"Represents a generic type in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class GenericType {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Namespace\",\n                \"about\": \"Represents a namespace in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Namespace {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TypeDeclaration\",\n                \"about\": \"Represents a type declaration in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TypeDeclaration {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Signature\",\n                \"about\": \"Represents a signature in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Signature {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Statement\",\n                \"about\": \"Represents a statement in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Statement {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AggregateType\",\n                \"about\": \"Represents an aggregate type in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class AggregateType {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Expression\",\n                \"about\": \"Represents an expression in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Expression {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GenericCallableDeclaration\",\n                \"about\": \"Represents a generic callable declaration in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class GenericCallableDeclaration {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GenericTypeDeclaration\",\n                \"about\": \"Represents a generic type declaration in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class GenericTypeDeclaration {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CurrentScope\",\n                \"about\": \"Provides access to the current scope in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class CurrentScope {\n                public:\n                    static CurrentScope* Get();\n                    std::vector<Declarable*> Lookup(const QualifiedName& name);\n                    std::vector<Declarable*> LookupShallow(const QualifiedName& name);\n                    Declarable* AddDeclarable(const std::string& name, Declarable* d);\n                };\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TorqueMacro\",\n                \"about\": \"Represents a torque macro in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TorqueMacro {};\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ExternMacro\",\n                \"about\": \"Represents a extern macro in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ExternMacro {};\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Method\",\n                \"about\": \"Represents a method in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Method {};\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Intrinsic\",\n                \"about\": \"Represents an intrinsic function in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Intrinsic {};\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RuntimeFunction\",\n                \"about\": \"Represents a runtime function in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class RuntimeFunction {};\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ExternConstant\",\n                \"about\": \"Represents an extern constant in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ExternConstant {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NamespaceConstant\",\n                \"about\": \"Represents a namespace constant in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class NamespaceConstant {};\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RegisterDeclarable\",\n                \"about\": \"Registers a declarable object.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                Declarable* RegisterDeclarable(std::unique_ptr<Declarable> d) { return d.release(); }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ReportError\",\n                \"about\": \"Reports an error during Torque compilation.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                void ReportError(const std::string& message);\n                template <typename T>\n                void ReportError(const std::string& message, const T& arg) {}\n            ]]></code>\n        </func>\n    </dependencies>\n\n    <constants>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines constant strings for special names used in Torque.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            static constexpr const char* const kFromConstexprMacroName = \"FromConstexpr\";\n            static constexpr const char* kMacroEndLabelName = \"__macro_end\";\n            static constexpr const char* kBreakLabelName = \"__break\";\n            static constexpr const char* kContinueLabelName = \"__continue\";\n            static constexpr const char* kCatchLabelName = \"__catch\";\n            static constexpr const char* kNextCaseLabelName = \"__NextCase\";\n        ]]></code>\n    </constants>\n</file>\n```"
}