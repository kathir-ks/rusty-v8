{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-load-elimination-reducer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-load-elimination-reducer.h\",\n        \"file_name\": \"wasm-load-elimination-reducer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the WasmLoadEliminationReducer, which eliminates redundant loads from WebAssembly code within the Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard and V8-specific headers for various functionalities such as optional values, doubly-linked lists, compiler phases, graph manipulation, and WebAssembly support.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#if !V8_ENABLE_WEBASSEMBLY\n#error This header should only be included if WebAssembly is enabled.\n#endif  // !V8_ENABLE_WEBASSEMBLY\n\n#include \"src/base/doubly-threaded-list.h\"\n#include \"src/compiler/turboshaft/analyzer-iterator.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/loop-finder.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/snapshot-table-opindex.h\"\n#include \"src/compiler/turboshaft/utils.h\"\n#include \"src/wasm/wasm-subtyping.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmLoadEliminationAnalyzer\",\n            \"about\": \"Analyzes the Turboshaft graph to identify and eliminate redundant loads in WebAssembly code.\",\n            \"attributes\": [\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"Graph&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Reference to the Turboshaft graph being analyzed.\"\n                },\n                {\n                    \"name\": \"phase_zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory zone for allocating data during the analysis phase.\"\n                },\n                {\n                    \"name\": \"replacements_\",\n                    \"type\": \"FixedOpIndexSidetable<OpIndex>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the replacement OpIndex for each OpIndex where load elimination is possible.\"\n                },\n                {\n                    \"name\": \"non_aliasing_objects_\",\n                    \"type\": \"AliasTable\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Table to track which objects are known to be non-aliasing.\"\n                },\n                {\n                    \"name\": \"memory_\",\n                    \"type\": \"wle::WasmMemoryContentTable\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Table to track the contents of memory locations for load elimination.\"\n                },\n                {\n                    \"name\": \"block_to_snapshot_mapping_\",\n                    \"type\": \"FixedBlockSidetable<std::optional<Snapshot>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores snapshots of the alias and memory tables at the end of each block.\"\n                },\n                {\n                    \"name\": \"predecessor_alias_snapshots_\",\n                    \"type\": \"ZoneVector<AliasSnapshot>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Temporary storage for alias snapshots of predecessor blocks during block processing.\"\n                },\n                {\n                    \"name\": \"predecessor_memory_snapshots_\",\n                    \"type\": \"ZoneVector<MemorySnapshot>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Temporary storage for memory snapshots of predecessor blocks during block processing.\"\n                }\n            ],\n            \"dependencies\": [\n                \"PipelineData\",\n                \"Graph\",\n                \"Zone\",\n                \"FixedOpIndexSidetable\",\n                \"SparseOpIndexSnapshotTable\",\n                \"wle::WasmMemoryContentTable\",\n                \"LoopFinder\",\n                \"AnalyzerIterator\",\n                \"Block\",\n                \"Snapshot\",\n                \"OpIndex\",\n                \"AliasTable\",\n                \"AliasSnapshot\",\n                \"MemorySnapshot\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass WasmLoadEliminationAnalyzer {\n public:\n  using AliasTable = SparseOpIndexSnapshotTable<bool>;\n  using AliasKey = AliasTable::Key;\n  using AliasSnapshot = AliasTable::Snapshot;\n\n  using MemoryKey = wle::WasmMemoryContentTable::Key;\n  using MemorySnapshot = wle::WasmMemoryContentTable::Snapshot;\n\n  WasmLoadEliminationAnalyzer(PipelineData* data, Graph& graph,\n                              Zone* phase_zone)\n      : graph_(graph),\n        phase_zone_(phase_zone),\n        replacements_(graph.op_id_count(), phase_zone, &graph),\n        non_aliasing_objects_(phase_zone),\n        memory_(data, phase_zone, non_aliasing_objects_, replacements_, graph_),\n        block_to_snapshot_mapping_(graph.block_count(), phase_zone),\n        predecessor_alias_snapshots_(phase_zone),\n        predecessor_memory_snapshots_(phase_zone) {}\n\n  void Run() {\n    LoopFinder loop_finder(phase_zone_, &graph_);\n    AnalyzerIterator iterator(phase_zone_, graph_, loop_finder);\n\n    bool compute_start_snapshot = true;\n    while (iterator.HasNext()) {\n      const Block* block = iterator.Next();\n\n      ProcessBlock(*block, compute_start_snapshot);\n      compute_start_snapshot = true;\n\n      // Consider re-processing for loops.\n      if (const GotoOp* last = block->LastOperation(graph_).TryCast<GotoOp>()) {\n        if (last->destination->IsLoop() &&\n            last->destination->LastPredecessor() == block) {\n          const Block* loop_header = last->destination;\n          // {block} is the backedge of a loop. We recompute the loop header's\n          // initial snapshots, and if they differ from its original snapshot,\n          // then we revisit the loop.\n          if (BeginBlock<true>(loop_header)) {\n            // We set the snapshot of the loop's 1st predecessor to the newly\n            // computed snapshot. It's not quite correct, but this predecessor\n            // is guaranteed to end with a Goto, and we are now visiting the\n            // loop, which means that we don't really care about this\n            // predecessor anymore.\n            // The reason for saving this snapshot is to prevent infinite\n            // looping, since the next time we reach this point, the backedge\n            // snapshot could still invalidate things from the forward edge\n            // snapshot. By restricting the forward edge snapshot, we prevent\n            // this.\n            const Block* loop_1st_pred =\n                loop_header->LastPredecessor()->NeighboringPredecessor();\n            FinishBlock(loop_1st_pred);\n            // And we start a new fresh snapshot from this predecessor.\n            auto pred_snapshots =\n                block_to_snapshot_mapping_[loop_1st_pred->index()];\n            non_aliasing_objects_.StartNewSnapshot(\n                pred_snapshots->alias_snapshot);\n            memory_.StartNewSnapshot(pred_snapshots->memory_snapshot);\n\n            iterator.MarkLoopForRevisit();\n            compute_start_snapshot = false;\n          } else {\n            SealAndDiscard();\n          }\n        }\n      }\n    }\n  }\n\n  OpIndex Replacement(OpIndex index) { return replacements_[index]; }\n\n private:\n  void ProcessBlock(const Block& block, bool compute_start_snapshot);\n  void ProcessStructGet(OpIndex op_idx, const StructGetOp& op);\n  void ProcessStructSet(OpIndex op_idx, const StructSetOp& op);\n  void ProcessArrayLength(OpIndex op_idx, const ArrayLengthOp& op);\n  void ProcessWasmAllocateArray(OpIndex op_idx, const WasmAllocateArrayOp& op);\n  void ProcessStringAsWtf16(OpIndex op_idx, const StringAsWtf16Op& op);\n  void ProcessStringPrepareForGetCodeUnit(\n      OpIndex op_idx, const StringPrepareForGetCodeUnitOp& op);\n  void ProcessAnyConvertExtern(OpIndex op_idx, const AnyConvertExternOp& op);\n  void ProcessAssertNotNull(OpIndex op_idx, const AssertNotNullOp& op);\n  void ProcessAllocate(OpIndex op_idx, const AllocateOp& op);\n  void ProcessCall(OpIndex op_idx, const CallOp& op);\n  void ProcessPhi(OpIndex op_idx, const PhiOp& op);\n\n  void DcheckWordBinop(OpIndex op_idx, const WordBinopOp& binop);\n\n  // BeginBlock initializes the various SnapshotTables for {block}, and returns\n  // true if {block} is a loop that should be revisited.\n  template <bool for_loop_revisit = false>\n  bool BeginBlock(const Block* block);\n  void FinishBlock(const Block* block);\n  // Seals the current snapshot, but discards it. This is used when considering\n  // whether a loop should be revisited or not: we recompute the loop header's\n  // snapshots, and then revisit the loop if the snapshots contain\n  // modifications. If the snapshots are unchanged, we discard them and don't\n  // revisit the loop.\n  void SealAndDiscard();\n  void StoreLoopSnapshotInForwardPredecessor(const Block& loop_header);\n\n  // Returns true if the loop's backedge already has snapshot data (meaning that\n  // it was already visited).\n  bool BackedgeHasSnapshot(const Block& loop_header) const;\n\n  void InvalidateAllNonAliasingInputs(const Operation& op);\n  void InvalidateIfAlias(OpIndex op_idx);\n\n  Graph& graph_;\n  Zone* phase_zone_;\n\n  FixedOpIndexSidetable<OpIndex> replacements_;\n\n  AliasTable non_aliasing_objects_;\n  wle::WasmMemoryContentTable memory_;\n\n  struct Snapshot {\n    AliasSnapshot alias_snapshot;\n    MemorySnapshot memory_snapshot;\n  };\n  FixedBlockSidetable<std::optional<Snapshot>> block_to_snapshot_mapping_;\n\n  // {predecessor_alias_napshots_}, {predecessor_maps_snapshots_} and\n  // {predecessor_memory_snapshots_} are used as temporary vectors when starting\n  // to process a block. We store them as members to avoid reallocation.\n  ZoneVector<AliasSnapshot> predecessor_alias_snapshots_;\n  ZoneVector<MemorySnapshot> predecessor_memory_snapshots_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmLoadEliminationReducer\",\n            \"about\": \"Reducer class that performs load elimination in the Turboshaft pipeline.\",\n            \"extends\": \"Next\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"WasmLoadEliminationAnalyzer\",\n                \"Assembler\",\n                \"StructGetOp\",\n                \"ArrayLengthOp\",\n                \"StringAsWtf16Op\",\n                \"StringPrepareForGetCodeUnitOp\",\n                \"AnyConvertExternOp\",\n                \"StructSetOp\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass WasmLoadEliminationReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(WasmLoadElimination)\n\n  void Analyze() {\n    if (v8_flags.turboshaft_wasm_load_elimination) {\n      DCHECK(AllowHandleDereference::IsAllowed());\n      analyzer_.Run();\n    }\n    Next::Analyze();\n  }\n\n#define EMIT_OP(Name)                                                          \\\n  OpIndex REDUCE_INPUT_GRAPH(Name)(OpIndex ig_index, const Name##Op& op) {     \\\n    if (v8_flags.turboshaft_wasm_load_elimination) {                           \\\n      OpIndex ig_replacement_index = analyzer_.Replacement(ig_index);          \\\n      if (ig_replacement_index.valid()) {                                      \\\n        OpIndex replacement = Asm().MapToNewGraph(ig_replacement_index);       \\\n        return replacement;                                                    \\\n      }                                                                        \\\n    }                                                                          \\\n    return Next::ReduceInputGraph##Name(ig_index, op);                         \\\n  }\n\n  EMIT_OP(StructGet)\n  EMIT_OP(ArrayLength)\n  EMIT_OP(StringAsWtf16)\n  EMIT_OP(StringPrepareForGetCodeUnit)\n  EMIT_OP(AnyConvertExtern)\n\n  OpIndex REDUCE_INPUT_GRAPH(StructSet)(OpIndex ig_index,\n                                        const StructSetOp& op) {\n    if (v8_flags.turboshaft_wasm_load_elimination) {\n      OpIndex ig_replacement_index = analyzer_.Replacement(ig_index);\n      if (ig_replacement_index.valid()) {\n        // For struct.set, \"replace with itself\" is a sentinel for\n        // \"unreachable\", and those are the only replacements we schedule for\n        // this operation.\n        DCHECK_EQ(ig_replacement_index, ig_index);\n        __ Unreachable();\n        return OpIndex::Invalid();\n      }\n    }\n    return Next::ReduceInputGraphStructSet(ig_index, op);\n  }\n\n private:\n  WasmLoadEliminationAnalyzer analyzer_{\n      Asm().data(), Asm().modifiable_input_graph(), Asm().phase_zone()};\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessBlock\",\n            \"parent\": \"WasmLoadEliminationAnalyzer\",\n            \"about\": \"Processes a block in the Turboshaft graph to perform load elimination.\",\n            \"logic\": \"Iterates through the operations in the block and calls specific processing methods for different operation types.  Invalidates the state and aliases based on the operations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const Block&\",\n                    \"purpose\": \"The block to process.\"\n                },\n                {\n                    \"name\": \"compute_start_snapshot\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether to compute the start snapshot for the block.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"graph_\",\n                \"ProcessStructGet\",\n                \"ProcessStructSet\",\n                \"ProcessArrayLength\",\n                \"ProcessWasmAllocateArray\",\n                \"ProcessStringAsWtf16\",\n                \"ProcessStringPrepareForGetCodeUnit\",\n                \"ProcessAnyConvertExtern\",\n                \"ProcessAssertNotNull\",\n                \"ProcessAllocate\",\n                \"ProcessCall\",\n                \"ProcessPhi\",\n                \"InvalidateAllNonAliasingInputs\",\n                \"InvalidateIfAlias\",\n                \"FinishBlock\",\n                \"BeginBlock\",\n                \"BackedgeHasSnapshot\",\n                \"DcheckWordBinop\",\n                \"StoreLoopSnapshotInForwardPredecessor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmLoadEliminationAnalyzer::ProcessBlock(const Block& block,\n                                               bool compute_start_snapshot) {\n  if (compute_start_snapshot) {\n    BeginBlock(&block);\n  }\n  if (block.IsLoop() && BackedgeHasSnapshot(block)) {\n    // Update the associated snapshot for the forward edge with the merged\n    // snapshot information from the forward- and backward edge.\n    // This will make sure that when evaluating whether a loop needs to be\n    // revisited, the inner loop compares the merged state with the backedge\n    // preventing us from exponential revisits for loops where the backedge\n    // invalidates loads which are eliminatable on the forward edge.\n    StoreLoopSnapshotInForwardPredecessor(block);\n  }\n\n  for (OpIndex op_idx : graph_.OperationIndices(block)) {\n    Operation& op = graph_.Get(op_idx);\n    if (ShouldSkipOptimizationStep()) continue;\n    if (ShouldSkipOperation(op)) continue;\n    switch (op.opcode) {\n      case Opcode::kStructGet:\n        ProcessStructGet(op_idx, op.Cast<StructGetOp>());\n        break;\n      case Opcode::kStructSet:\n        ProcessStructSet(op_idx, op.Cast<StructSetOp>());\n        break;\n      case Opcode::kArrayLength:\n        ProcessArrayLength(op_idx, op.Cast<ArrayLengthOp>());\n        break;\n      case Opcode::kWasmAllocateArray:\n        ProcessWasmAllocateArray(op_idx, op.Cast<WasmAllocateArrayOp>());\n        break;\n      case Opcode::kStringAsWtf16:\n        ProcessStringAsWtf16(op_idx, op.Cast<StringAsWtf16Op>());\n        break;\n      case Opcode::kStringPrepareForGetCodeUnit:\n        ProcessStringPrepareForGetCodeUnit(\n            op_idx, op.Cast<StringPrepareForGetCodeUnitOp>());\n        break;\n      case Opcode::kAnyConvertExtern:\n        ProcessAnyConvertExtern(op_idx, op.Cast<AnyConvertExternOp>());\n        break;\n      case Opcode::kAssertNotNull:\n        // TODO(14108): We'll probably want to handle WasmTypeCast as\n        // a \"load-like\" instruction too, to eliminate repeated casts.\n        ProcessAssertNotNull(op_idx, op.Cast<AssertNotNullOp>());\n        break;\n      case Opcode::kArraySet:\n        break;\n      case Opcode::kAllocate:\n        // Create new non-alias.\n        ProcessAllocate(op_idx, op.Cast<AllocateOp>());\n        break;\n      case Opcode::kCall:\n        // Invalidate state (+ maybe invalidate aliases).\n        ProcessCall(op_idx, op.Cast<CallOp>());\n        break;\n      case Opcode::kPhi:\n        // Invalidate aliases.\n        ProcessPhi(op_idx, op.Cast<PhiOp>());\n        break;\n      case Opcode::kLoad:\n        // Atomic loads have the \"can_write\" bit set, because they make\n        // writes on other threads visible. At any rate, we have to\n        // explicitly skip them here.\n      case Opcode::kStore:\n        // We rely on having no raw \"Store\" operations operating on Wasm\n        // objects at this point in the pipeline.\n        // TODO(jkummerow): Is there any way to DCHECK that?\n      case Opcode::kAssumeMap:\n      case Opcode::kCatchBlockBegin:\n      case Opcode::kRetain:\n      case Opcode::kDidntThrow:\n      case Opcode::kCheckException:\n      case Opcode::kAtomicRMW:\n      case Opcode::kAtomicWord32Pair:\n      case Opcode::kMemoryBarrier:\n      case Opcode::kJSStackCheck:\n      case Opcode::kWasmStackCheck:\n      case Opcode::kSimd128LaneMemory:\n      case Opcode::kGlobalSet:\n      case Opcode::kParameter:\n        // We explicitly break for those operations that have can_write effects\n        // but don't actually write, or cannot interfere with load elimination.\n        break;\n\n      case Opcode::kWordBinop:\n        // A WordBinop should never invalidate aliases (since the only time when\n        // it should take a non-aliasing object as input is for Smi checks).\n        DcheckWordBinop(op_idx, op.Cast<WordBinopOp>());\n        break;\n\n      case Opcode::kFrameState:\n      case Opcode::kDeoptimizeIf:\n      case Opcode::kComparison:\n      case Opcode::kTrapIf:\n        // We explicitly break for these opcodes so that we don't call\n        // InvalidateAllNonAliasingInputs on their inputs, since they don't\n        // really create aliases. (and also, they don't write so it's\n        // fine to break)\n        DCHECK(!op.Effects().can_write());\n        break;\n\n      case Opcode::kDeoptimize:\n      case Opcode::kReturn:\n        // We explicitly break for these opcodes so that we don't call\n        // InvalidateAllNonAliasingInputs on their inputs, since they are block\n        // terminators without successors, meaning that it's not useful for the\n        // rest of the analysis to invalidate anything here.\n        DCHECK(op.IsBlockTerminator() && SuccessorBlocks(op).empty());\n        break;\n\n      default:\n        // Operations that `can_write` should invalidate the state. All such\n        // operations should be already handled above, which means that we don't\n        // need a `if (can_write) { Invalidate(); }` here.\n        CHECK(!op.Effects().can_write());\n\n        // Even if the operation doesn't write, it could create an alias to its\n        // input by returning it. This happens for instance in Phis and in\n        // Change (although ChangeOp is already handled earlier by calling\n        // ProcessChange). We are conservative here by calling\n        // InvalidateAllNonAliasingInputs for all operations even though only\n        // few can actually create aliases to fresh allocations, the reason\n        // being that missing such a case would be a security issue, and it\n        // should be rare for fresh allocations to be used outside of\n        // Call/Store/Load/Change anyways.\n        InvalidateAllNonAliasingInputs(op);\n\n        break;\n    }\n  }\n\n  FinishBlock(&block);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RepIsCompatible\",\n            \"parent\": \"WasmLoadEliminationAnalyzer\",\n            \"about\": \"Checks if replacing a load with a given register representation and size is compatible with the expected representation.\",\n            \"logic\": \"Compares the actual register representation of the replacement value with the expected representation of the original load. Also verifies if the size in memory is the same.\",\n            \"parameters\": [\n                {\n                    \"name\": \"actual\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The register representation of the replacement value.\"\n                },\n                {\n                    \"name\": \"expected_reg_repr\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The expected register representation of the original load.\"\n                },\n                {\n                    \"name\": \"in_memory_size\",\n                    \"type\": \"uint8_t\",\n                    \"purpose\": \"The size in bytes of the value in memory.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the replacement is compatible, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"MemoryRepresentation\",\n                \"RegisterRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool RepIsCompatible(RegisterRepresentation actual,\n                     RegisterRepresentation expected_reg_repr,\n                     uint8_t in_memory_size) {\n  if (in_memory_size !=\n      MemoryRepresentation::FromRegisterRepresentation(actual, true)\n          .SizeInBytes()) {\n    // The replacement was truncated when being stored or should be truncated\n    // (or sign-extended) during the load. Since we don't have enough\n    // truncations operators in Turboshaft (eg, we don't have Int32 to Int8\n    // truncation), we just prevent load elimination in this case.\n\n    // TODO(jkummerow): support eliminating repeated loads of the same i8/i16\n    // field.\n    return false;\n  }\n\n  return expected_reg_repr == actual;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessStructGet\",\n            \"parent\": \"WasmLoadEliminationAnalyzer\",\n            \"about\": \"Processes a StructGet operation to check for load elimination opportunities.\",\n            \"logic\": \"Looks up the StructGet in the memory table. If a matching entry is found, replaces the current StructGet with the existing value if the types are compatible. Otherwise, inserts the StructGet into the memory table.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The OpIndex of the StructGet operation.\"\n                },\n                {\n                    \"name\": \"get\",\n                    \"type\": \"const StructGetOp&\",\n                    \"purpose\": \"The StructGet operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"memory_\",\n                \"graph_\",\n                \"replacements_\",\n                \"RepIsCompatible\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmLoadEliminationAnalyzer::ProcessStructGet(OpIndex op_idx,\n                                                   const StructGetOp& get) {\n  OpIndex existing = memory_.Find(get);\n  if (existing.valid()) {\n    const Operation& replacement = graph_.Get(existing);\n    DCHECK_EQ(replacement.outputs_rep().size(), 1);\n    DCHECK_EQ(get.outputs_rep().size(), 1);\n    uint8_t size = get.type->field(get.field_index).value_kind_size();\n    if (RepIsCompatible(replacement.outputs_rep()[0], get.outputs_rep()[0],\n                        size)) {\n      replacements_[op_idx] = existing;\n      return;\n    }\n  }\n  replacements_[op_idx] = OpIndex::Invalid();\n  memory_.Insert(get, op_idx);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessStructSet\",\n            \"parent\": \"WasmLoadEliminationAnalyzer\",\n            \"about\": \"Processes a StructSet operation to update the memory table and invalidate potentially aliasing objects.\",\n            \"logic\": \"Invalidates existing entries in the memory table that are affected by the StructSet. If an entry with incorrect mutability is found, marks the struct.set as unreachable by replacing with itself. Inserts the StructSet into the memory table. Updates alias information for the value being stored.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The OpIndex of the StructSet operation.\"\n                },\n                {\n                    \"name\": \"set\",\n                    \"type\": \"const StructSetOp&\",\n                    \"purpose\": \"The StructSet operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"memory_\",\n                \"non_aliasing_objects_\",\n                \"replacements_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmLoadEliminationAnalyzer::ProcessStructSet(OpIndex op_idx,\n                                                   const StructSetOp& set) {\n  if (memory_.HasValueWithIncorrectMutability(set)) {\n    // This struct.set is unreachable. We don't have a good way to annotate\n    // it as such, so we use \"replace with itself\" as a sentinel.\n    // TODO(jkummerow): Check how often this case is triggered in practice.\n    replacements_[op_idx] = op_idx;\n    return;\n  }\n\n  memory_.Invalidate(set);\n  memory_.Insert(set);\n\n  // Updating aliases if the value stored was known as non-aliasing.\n  OpIndex value = set.value();\n  if (non_aliasing_objects_.HasKeyFor(value)) {\n    non_aliasing_objects_.Set(value, false);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessArrayLength\",\n            \"parent\": \"WasmLoadEliminationAnalyzer\",\n            \"about\": \"Processes an ArrayLength operation to check for load elimination opportunities.\",\n            \"logic\": \"Looks up the ArrayLength in the memory table as a load-like operation.  If a matching entry is found, replaces the current ArrayLength with the existing value. Otherwise, inserts the ArrayLength into the memory table.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The OpIndex of the ArrayLength operation.\"\n                },\n                {\n                    \"name\": \"length\",\n                    \"type\": \"const ArrayLengthOp&\",\n                    \"purpose\": \"The ArrayLength operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"memory_\",\n                \"replacements_\",\n                \"graph_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmLoadEliminationAnalyzer::ProcessArrayLength(\n    OpIndex op_idx, const ArrayLengthOp& length) {\n  static constexpr int offset = wle::kArrayLengthFieldIndex;\n  OpIndex existing = memory_.FindLoadLike(length.array(), offset);\n  if (existing.valid()) {\n#if DEBUG\n    const Operation& replacement = graph_.Get(existing);\n    DCHECK_EQ(replacement.outputs_rep().size(), 1);\n    DCHECK_EQ(length.outputs_rep().size(), 1);\n    DCHECK_EQ(replacement.outputs_rep()[0], length.outputs_rep()[0]);\n#endif\n    replacements_[op_idx] = existing;\n    return;\n  }\n  replacements_[op_idx] = OpIndex::Invalid();\n  memory_.InsertLoadLike(length.array(), offset, op_idx);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessWasmAllocateArray\",\n            \"parent\": \"WasmLoadEliminationAnalyzer\",\n            \"about\": \"Processes a WasmAllocateArray operation.\",\n            \"logic\": \"Marks the allocated array as non-aliasing and inserts the array's length into the memory table as a load-like operation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The OpIndex of the WasmAllocateArray operation.\"\n                },\n                {\n                    \"name\": \"alloc\",\n                    \"type\": \"const WasmAllocateArrayOp&\",\n                    \"purpose\": \"The WasmAllocateArray operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"non_aliasing_objects_\",\n                \"memory_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmLoadEliminationAnalyzer::ProcessWasmAllocateArray(\n    OpIndex op_idx, const WasmAllocateArrayOp& alloc) {\n  non_aliasing_objects_.Set(op_idx, true);\n  static constexpr int offset = wle::kArrayLengthFieldIndex;\n  memory_.InsertLoadLike(op_idx, offset, alloc.length());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessStringAsWtf16\",\n            \"parent\": \"WasmLoadEliminationAnalyzer\",\n            \"about\": \"Processes a StringAsWtf16 operation to check for load elimination opportunities.\",\n            \"logic\": \"Looks up the StringAsWtf16 in the memory table as a load-like operation.  If a matching entry is found, replaces the current StringAsWtf16 with the existing value. Otherwise, inserts the StringAsWtf16 into the memory table.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The OpIndex of the StringAsWtf16 operation.\"\n                },\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const StringAsWtf16Op&\",\n                    \"purpose\": \"The StringAsWtf16 operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"memory_\",\n                \"replacements_\",\n                \"graph_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmLoadEliminationAnalyzer::ProcessStringAsWtf16(\n    OpIndex op_idx, const StringAsWtf16Op& op) {\n  static constexpr int offset = wle::kStringAsWtf16Index;\n  OpIndex existing = memory_.FindLoadLike(op.string(), offset);\n  if (existing.valid()) {\n    DCHECK_EQ(Opcode::kStringAsWtf16, graph_.Get(existing).opcode);\n    replacements_[op_idx] = existing;\n    return;\n  }\n  replacements_[op_idx] = OpIndex::Invalid();\n  memory_.InsertLoadLike(op.string(), offset, op_idx);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessStringPrepareForGetCodeUnit\",\n            \"parent\": \"WasmLoadEliminationAnalyzer\",\n            \"about\": \"Processes a StringPrepareForGetCodeUnit operation to check for load elimination opportunities.\",\n            \"logic\": \"Looks up the StringPrepareForGetCodeUnit in the memory table as a load-like operation.  If a matching entry is found, replaces the current operation with the existing value. Otherwise, inserts the current operation into the memory table.\",\n            \"parameters\": [\n                {\n                    "
}