{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/riscv/instruction-selector-riscv64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/riscv/instruction-selector-riscv64.cc\",\n        \"file_name\": \"instruction-selector-riscv64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the instruction selector for the RISC-V 64-bit architecture in the V8 compiler backend.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for base utilities, code generation, machine types, instruction selection, node matching, and turboshaft operations.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/bits.h\"\n#include \"src/base/logging.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/compiler/backend/instruction-selector-impl.h\"\n#include \"src/compiler/backend/riscv/instruction-selector-riscv.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CanBeImmediate\",\n            \"parent\": \"RiscvOperandGeneratorT\",\n            \"about\": \"Checks if a given value can be used as an immediate operand for a specific RISC-V instruction.\",\n            \"logic\": \"The function uses a switch statement to determine the allowed immediate range based on the instruction's opcode. It checks if the value falls within the specified bit range (e.g., is_uint5, is_uint6, is_int12, is_int32).\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The value to check for immediate suitability.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the RISC-V instruction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the value can be used as an immediate, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool RiscvOperandGeneratorT::CanBeImmediate(int64_t value,\n                                            InstructionCode opcode) {\n  switch (ArchOpcodeField::decode(opcode)) {\n    case kRiscvShl32:\n    case kRiscvSar32:\n    case kRiscvShr32:\n      return is_uint5(value);\n    case kRiscvShl64:\n    case kRiscvSar64:\n    case kRiscvShr64:\n      return is_uint6(value);\n    case kRiscvAdd32:\n    case kRiscvAnd32:\n    case kRiscvAnd:\n    case kRiscvAdd64:\n    case kRiscvOr32:\n    case kRiscvOr:\n    case kRiscvTst64:\n    case kRiscvTst32:\n    case kRiscvXor:\n      return is_int12(value);\n    case kRiscvLb:\n    case kRiscvLbu:\n    case kRiscvSb:\n    case kRiscvLh:\n    case kRiscvLhu:\n    case kRiscvSh:\n    case kRiscvLw:\n    case kRiscvSw:\n    case kRiscvLd:\n    case kRiscvSd:\n    case kRiscvLoadFloat:\n    case kRiscvStoreFloat:\n    case kRiscvLoadDouble:\n    case kRiscvStoreDouble:\n      return is_int32(value);\n    default:\n      return is_int12(value);\n  }\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ExtendingLoadMatcher\",\n            \"about\": \"A helper struct to match extending load patterns, particularly for sign-extending 32-bit values loaded into 64-bit registers.\",\n            \"attributes\": [\n                {\n                    \"name\": \"matches_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether a matching extending load pattern was found.\"\n                },\n                {\n                    \"name\": \"selector_\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the instruction selector.\"\n                },\n                {\n                    \"name\": \"base_\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Base address of the load.\"\n                },\n                {\n                    \"name\": \"immediate_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Immediate offset for the load.\"\n                },\n                {\n                    \"name\": \"opcode_\",\n                    \"type\": \"ArchOpcode\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The opcode of the extending load instruction.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ShiftOp\",\n                \"LoadOp\",\n                \"Operation\",\n                \"RiscvOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct ExtendingLoadMatcher {\n  ExtendingLoadMatcher(OpIndex node, InstructionSelectorT* selector)\n      : matches_(false), selector_(selector), immediate_(0) {\n    Initialize(node);\n  }\n\n  bool Matches() const { return matches_; }\n\n  OpIndex base() const {\n    DCHECK(Matches());\n    return base_;\n  }\n  int64_t immediate() const {\n    DCHECK(Matches());\n    return immediate_;\n  }\n  ArchOpcode opcode() const {\n    DCHECK(Matches());\n    return opcode_;\n  }\n\n private:\n  bool matches_;\n  InstructionSelectorT* selector_;\n  OpIndex base_{};\n  int64_t immediate_;\n  ArchOpcode opcode_;\n\n  void Initialize(turboshaft::OpIndex node) {\n    const ShiftOp& shift = selector_->Get(node).template Cast<ShiftOp>();\n    DCHECK(shift.kind == ShiftOp::Kind::kShiftRightArithmetic ||\n           shift.kind == ShiftOp::Kind::kShiftRightArithmeticShiftOutZeros);\n    // When loading a 64-bit value and shifting by 32, we should\n    // just load and sign-extend the interesting 4 bytes instead.\n    // This happens, for example, when we're loading and untagging SMIs.\n    const Operation& lhs = selector_->Get(shift.left());\n    int64_t constant_rhs;\n\n    if (lhs.Is<LoadOp>() &&\n        selector_->MatchIntegralWord64Constant(shift.right(), &constant_rhs) &&\n        constant_rhs == 32 && selector_->CanCover(node, shift.left())) {\n      RiscvOperandGeneratorT g(selector_);\n      const LoadOp& load = lhs.Cast<LoadOp>();\n      base_ = load.base();\n      opcode_ = kRiscvLw;\n      if (load.index().has_value()) {\n        int64_t index_constant;\n        if (selector_->MatchIntegralWord64Constant(load.index().value(),\n                                                   &index_constant)) {\n          DCHECK_EQ(load.element_size_log2, 0);\n          immediate_ = index_constant + 4;\n          matches_ = g.CanBeImmediate(immediate_, kRiscvLw);\n        }\n      } else {\n        immediate_ = load.offset + 4;\n        matches_ = g.CanBeImmediate(immediate_, kRiscvLw);\n      }\n    }\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryEmitExtendingLoad\",\n            \"about\": \"Attempts to emit an extending load instruction based on the given node.\",\n            \"logic\": \"It uses the ExtendingLoadMatcher to determine if the current node matches a pattern where a 32-bit value is loaded and then sign-extended to 64 bits.  If it matches, it emits the appropriate load instruction with sign extension.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the shift operation.\"\n                },\n                {\n                    \"name\": \"output_node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node where the result of the load should be placed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if an extending load was emitted, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ExtendingLoadMatcher\",\n                \"RiscvOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TryEmitExtendingLoad(InstructionSelectorT* selector, OpIndex node,\n                          OpIndex output_node) {\n  ExtendingLoadMatcher m(node, selector);\n  RiscvOperandGeneratorT g(selector);\n  if (m.Matches()) {\n    InstructionOperand inputs[2];\n    inputs[0] = g.UseRegister(m.base());\n    InstructionCode opcode =\n        m.opcode() | AddressingModeField::encode(kMode_MRI);\n    DCHECK(is_int32(m.immediate()));\n    inputs[1] = g.TempImmediate(static_cast<int32_t>(m.immediate()));\n    InstructionOperand outputs[] = {g.DefineAsRegister(output_node)};\n    selector->Emit(opcode, arraysize(outputs), outputs, arraysize(inputs),\n                   inputs);\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"EmitLoad\",\n            \"about\": \"Emits a load instruction.\",\n            \"logic\": \"Handles different addressing modes for loads, including root register addressing and immediate offsets. It checks if the index can be used as an immediate value; if not, it calculates the address in a temporary register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the load operation.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the load instruction.\"\n                },\n                {\n                    \"name\": \"output\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The output node, if any.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"LoadOp\",\n                \"ConstantOp\",\n                \"LoadRootRegisterOp\",\n                \"RiscvOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid EmitLoad(InstructionSelectorT* selector, OpIndex node,\n              InstructionCode opcode, OpIndex output = OpIndex()) {\n  RiscvOperandGeneratorT g(selector);\n\n  const Operation& op = selector->Get(node);\n  const LoadOp& load = op.Cast<LoadOp>();\n\n  // The LoadStoreSimplificationReducer transforms all loads into\n  // *(base + index).\n  OpIndex base = load.base();\n  OpIndex index = load.index().value();\n  DCHECK_EQ(load.offset, 0);\n  DCHECK_EQ(load.element_size_log2, 0);\n\n  InstructionOperand inputs[3];\n  size_t input_count = 0;\n  InstructionOperand output_op;\n\n  // If output is valid, use that as the output register. This is used when we\n  // merge a conversion into the load.\n  output_op = g.DefineAsRegister(output.valid() ? output : node);\n  int64_t index_value;\n  const Operation& base_op = selector->Get(base);\n  if (base_op.Is<Opmask::kExternalConstant>() &&\n      selector->MatchSignedIntegralConstant(index, &index_value)) {\n    const ConstantOp& constant_base = base_op.Cast<ConstantOp>();\n    if (selector->CanAddressRelativeToRootsRegister(\n            constant_base.external_reference())) {\n      ptrdiff_t const delta =\n          index_value +\n          MacroAssemblerBase::RootRegisterOffsetForExternalReference(\n              selector->isolate(), constant_base.external_reference());\n      input_count = 1;\n      // Check that the delta is a 32-bit integer due to the limitations of\n      // immediate operands.\n      if (is_int32(delta)) {\n        inputs[0] = g.UseImmediate(static_cast<int32_t>(delta));\n        opcode |= AddressingModeField::encode(kMode_Root);\n        selector->Emit(opcode, 1, &output_op, input_count, inputs);\n        return;\n      }\n    }\n  }\n\n  if (base_op.Is<LoadRootRegisterOp>()) {\n    int64_t index_value;\n    selector->MatchSignedIntegralConstant(index, &index_value);\n    input_count = 1;\n    inputs[0] = g.UseImmediate64(index_value);\n    opcode |= AddressingModeField::encode(kMode_Root);\n    selector->Emit(opcode, 1, &output_op, input_count, inputs);\n    return;\n  }\n\n  if (g.CanBeImmediate(index, opcode)) {\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                   g.DefineAsRegister(output.valid() ? output : node),\n                   g.UseRegister(base), g.UseImmediate(index));\n  } else {\n    InstructionOperand addr_reg = g.TempRegister();\n    selector->Emit(kRiscvAdd64 | AddressingModeField::encode(kMode_None),\n                   addr_reg, g.UseRegister(index), g.UseRegister(base));\n    // Emit desired load opcode, using temp addr_reg.\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                   g.DefineAsRegister(output.valid() ? output : node), addr_reg,\n                   g.TempImmediate(0));\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"EmitS128Load\",\n            \"about\": \"Emits a SIMD128 load instruction.\",\n            \"logic\": \"Similar to EmitLoad, but specific to SIMD128 loads. Handles address calculation with immediate offsets or temporary registers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the SIMD128 load operation.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the SIMD128 load instruction.\"\n                },\n                {\n                    \"name\": \"sew\",\n                    \"type\": \"VSew\",\n                    \"purpose\": \"Vector Static Element Width parameter.\"\n                },\n                {\n                    \"name\": \"lmul\",\n                    \"type\": \"Vlmul\",\n                    \"purpose\": \"Vector Lane Multiplier parameter.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"RiscvOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid EmitS128Load(InstructionSelectorT* selector, OpIndex node,\n                  InstructionCode opcode, VSew sew, Vlmul lmul) {\n  RiscvOperandGeneratorT g(selector);\n  OpIndex base = selector->input_at(node, 0);\n  OpIndex index = selector->input_at(node, 1);\n  if (g.CanBeImmediate(index, opcode)) {\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                   g.DefineAsRegister(node), g.UseRegister(base),\n                   g.UseImmediate(index), g.UseImmediate(sew),\n                   g.UseImmediate(lmul));\n  } else {\n    InstructionOperand addr_reg = g.TempRegister();\n    selector->Emit(kRiscvAdd64 | AddressingModeField::encode(kMode_None),\n                   addr_reg, g.UseRegister(index), g.UseRegister(base));\n    // Emit desired load opcode, using temp addr_reg.\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                   g.DefineAsRegister(node), addr_reg, g.TempImmediate(0),\n                   g.UseImmediate(sew), g.UseImmediate(lmul));\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitStoreLane\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Visits a StoreLane node and emits the corresponding RISC-V instruction.\",\n            \"logic\": \"Calculates the address by adding the base and index registers.  Then, emits the store lane instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The StoreLane node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Simd128LaneMemoryOp\",\n                \"RiscvOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitStoreLane(OpIndex node) {\n  const Simd128LaneMemoryOp& store = Get(node).Cast<Simd128LaneMemoryOp>();\n  InstructionCode opcode = kRiscvS128StoreLane;\n  opcode |= LaneSizeField::encode(store.lane_size() * kBitsPerByte);\n  if (store.kind.with_trap_handler) {\n    opcode |= AccessModeField::encode(kMemoryAccessProtectedMemOutOfBounds);\n  }\n\n  RiscvOperandGeneratorT g(this);\n  OpIndex base = this->input_at(node, 0);\n  OpIndex index = this->input_at(node, 1);\n  InstructionOperand addr_reg = g.TempRegister();\n  Emit(kRiscvAdd64, addr_reg, g.UseRegister(base), g.UseRegister(index));\n  InstructionOperand inputs[4] = {\n      g.UseRegister(input_at(node, 2)),\n      g.UseImmediate(store.lane),\n      addr_reg,\n      g.TempImmediate(0),\n  };\n  opcode |= AddressingModeField::encode(kMode_MRI);\n  Emit(opcode, 0, nullptr, 4, inputs);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitLoadLane\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Visits a LoadLane node and emits the corresponding RISC-V instruction.\",\n            \"logic\": \"Calculates the address by adding the base and index registers, then emits the load lane instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The LoadLane node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Simd128LaneMemoryOp\",\n                \"RiscvOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitLoadLane(OpIndex node) {\n  const Simd128LaneMemoryOp& load = this->Get(node).Cast<Simd128LaneMemoryOp>();\n  InstructionCode opcode = kRiscvS128LoadLane;\n  opcode |= LaneSizeField::encode(load.lane_size() * kBitsPerByte);\n  if (load.kind.with_trap_handler) {\n    opcode |= AccessModeField::encode(kMemoryAccessProtectedMemOutOfBounds);\n  }\n\n  RiscvOperandGeneratorT g(this);\n  OpIndex base = this->input_at(node, 0);\n  OpIndex index = this->input_at(node, 1);\n  InstructionOperand addr_reg = g.TempRegister();\n  Emit(kRiscvAdd64, addr_reg, g.UseRegister(base), g.UseRegister(index));\n  opcode |= AddressingModeField::encode(kMode_MRI);\n  Emit(opcode, g.DefineSameAsFirst(node),\n       g.UseRegister(this->input_at(node, 2)), g.UseImmediate(load.lane),\n       addr_reg, g.TempImmediate(0));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetLoadOpcode\",\n            \"about\": \"Determines the appropriate load opcode based on memory and register representations.\",\n            \"logic\": \"The function uses a switch statement to select the appropriate load instruction based on the MemoryRepresentation and RegisterRepresentation. It handles different data types (Int8, Uint8, Int16, Uint16, Int32, Uint32, Int64, Uint64, Float32, Float64, Tagged values) and compressed/uncompressed pointers. It also handles protected pointer loads.\",\n            \"parameters\": [\n                {\n                    \"name\": \"loaded_rep\",\n                    \"type\": \"MemoryRepresentation\",\n                    \"purpose\": \"The representation of the data in memory.\"\n                },\n                {\n                    \"name\": \"result_rep\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The representation of the data in the register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ArchOpcode\",\n                \"description\": \"The appropriate RISC-V load opcode.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\nArchOpcode GetLoadOpcode(MemoryRepresentation loaded_rep,\n                         RegisterRepresentation result_rep) {\n  // NOTE: The meaning of `loaded_rep` = `MemoryRepresentation::AnyTagged()` is\n  // we are loading a compressed tagged field, while `result_rep` =\n  // `RegisterRepresentation::Tagged()` refers to an uncompressed tagged value.\n\n  switch (loaded_rep) {\n    case MemoryRepresentation::Int8():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kRiscvLb;\n    case MemoryRepresentation::Uint8():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kRiscvLbu;\n    case MemoryRepresentation::Int16():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kRiscvLh;\n    case MemoryRepresentation::Uint16():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kRiscvLhu;\n    case MemoryRepresentation::Int32():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kRiscvLw;\n    case MemoryRepresentation::Uint32():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kRiscvLwu;\n    case MemoryRepresentation::Int64():\n    case MemoryRepresentation::Uint64():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word64());\n      return kRiscvLd;\n    case MemoryRepresentation::Float16():\n      UNIMPLEMENTED();\n    case MemoryRepresentation::Float32():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Float32());\n      return kRiscvLoadFloat;\n    case MemoryRepresentation::Float64():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Float64());\n      return kRiscvLoadDouble;\n#ifdef V8_COMPRESS_POINTERS\n    case MemoryRepresentation::AnyTagged():\n    case MemoryRepresentation::TaggedPointer():\n      if (result_rep == RegisterRepresentation::Compressed()) {\n        return kRiscvLwu;\n      }\n      DCHECK_EQ(result_rep, RegisterRepresentation::Tagged());\n      return kRiscvLoadDecompressTagged;\n    case MemoryRepresentation::TaggedSigned():\n      if (result_rep == RegisterRepresentation::Compressed()) {\n        return kRiscvLwu;\n      }\n      DCHECK_EQ(result_rep, RegisterRepresentation::Tagged());\n      return kRiscvLoadDecompressTaggedSigned;\n#else\n    case MemoryRepresentation::AnyTagged():\n    case MemoryRepresentation::TaggedPointer():\n    case MemoryRepresentation::TaggedSigned():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Tagged());\n      return kRiscvLd;\n#endif\n    case MemoryRepresentation::AnyUncompressedTagged():\n    case MemoryRepresentation::UncompressedTaggedPointer():\n    case MemoryRepresentation::UncompressedTaggedSigned():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Tagged());\n      return kRiscvLd;\n    case MemoryRepresentation::ProtectedPointer():\n      CHECK(V8_ENABLE_SANDBOX_BOOL);\n      return kRiscvLoadDecompressProtected;\n    case MemoryRepresentation::IndirectPointer():\n      UNREACHABLE();\n    case MemoryRepresentation::SandboxedPointer():\n      return kRiscvLoadDecodeSandboxedPointer;\n    case MemoryRepresentation::Simd128():\n      return kRiscvRvvLd;\n    case MemoryRepresentation::Simd256():\n      UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetStoreOpcode\",\n            \"about\": \"Determines the appropriate store opcode based on the memory representation.\",\n            \"logic\": \"The function uses a switch statement to select the appropriate store instruction based on the MemoryRepresentation. It handles different data types (Int8, Uint8, Int16, Uint16, Int32, Uint32, Int64, Uint64, Float32, Float64, Tagged values) and compressed/uncompressed pointers. It also handles protected and indirect pointer stores.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stored_rep\",\n                    \"type\": \"MemoryRepresentation\",\n                    \"purpose\": \"The representation of the data being stored.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ArchOpcode\",\n                \"description\": \"The appropriate RISC-V store opcode.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nArchOpcode GetStoreOpcode(MemoryRepresentation stored_rep) {\n  switch (stored_rep) {\n    case MemoryRepresentation::Int8():\n    case MemoryRepresentation::Uint8():\n      return kRiscvSb;\n    case MemoryRepresentation::Int16():\n    case MemoryRepresentation::Uint16():\n      return kRiscvSh;\n    case MemoryRepresentation::Int32():\n    case MemoryRepresentation::Uint32():\n      return kRiscvSw;\n    case MemoryRepresentation::Int64():\n    case MemoryRepresentation::Uint64():\n      return kRiscvSd;\n    case MemoryRepresentation::Float16():\n      UNIMPLEMENTED();\n    case MemoryRepresentation::Float32():\n      return kRiscvStoreFloat;\n    case MemoryRepresentation::Float64():\n      return kRiscvStoreDouble;\n    case MemoryRepresentation::AnyTagged():\n    case MemoryRepresentation::TaggedPointer():\n    case MemoryRepresentation::TaggedSigned():\n      return kRiscvStoreCompressTagged;\n    case MemoryRepresentation::AnyUncompressedTagged():\n    case MemoryRepresentation::UncompressedTaggedPointer():\n    case MemoryRepresentation::UncompressedTaggedSigned():\n      return kRiscvSd;\n    case MemoryRepresentation::ProtectedPointer():\n      // We never store directly to protected pointers from generated code.\n      UNREACHABLE();\n    case MemoryRepresentation::IndirectPointer():\n      return kRiscvStoreIndirectPointer;\n    case MemoryRepresentation::SandboxedPointer():\n      return kRiscvStoreEncodeSandboxedPointer;\n    case MemoryRepresentation::Simd128():\n      return kRiscvRvvSt;\n    case MemoryRepresentation::Simd256():\n      UNREACHABLE();\n  }\n}\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitLoad\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Visits a Load node and emits the corresponding RISC-V load instruction.\",\n            \"logic\": \"Retrieves the load opcode based on the load representation. It also takes into account protected loads. Then it emits the load instruction using the EmitLoad function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The Load node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"GetLoadOpcode\",\n                \"EmitLoad\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitLoad(OpIndex node) {\n  auto load = this->load_view(node);\n  InstructionCode opcode = kArchNop;\n  opcode = GetLoadOpcode(load.ts_loaded_rep(), load.ts_result_rep());\n  bool traps_on_null;\n  if (load.is_protected(&traps_on_null)) {\n    if (traps_on_null) {\n      opcode |= AccessModeField::encode(kMemoryAccessProtectedNullDereference);\n    } else {\n      opcode |= AccessModeField::encode(kMemoryAccessProtectedMemOutOfBounds);\n    }\n  }\n  EmitLoad(this, node, opcode);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitStorePair\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Visits a StorePair node.\",\n            \"logic\": \"Currently unimplemented, causing an UNREACHABLE.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The StorePair node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitStorePair(OpIndex node) { UNREACHABLE(); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitProtectedLoad\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Visits a ProtectedLoad node.\",\n            \"logic\": \"Calls the VisitLoad function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The ProtectedLoad node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitLoad\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitProtectedLoad(OpIndex node) { VisitLoad(node); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitStore\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Visits a Store node and emits the corresponding RISC-V store instruction.\",\n            \"logic\": \"Handles different scenarios, including write barriers, root register stores, and immediate offsets. It checks if the index can be used as an immediate value; if not, it calculates the address in a temporary register. It also handles store traps on null and memory access kinds.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The Store node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StoreView\",\n                "
}