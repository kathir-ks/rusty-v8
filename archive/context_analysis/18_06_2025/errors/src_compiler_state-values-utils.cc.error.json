{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/state-values-utils.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/state-values-utils.cc\",\n            \"file_name\": \"state-values-utils.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides utilities for managing and caching state values in the compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for the state values utilities, compiler common operators, and bytecode liveness analysis.\",\n                \"dependencies\": [\n                  \"src/compiler/state-values-utils.h\",\n                  \"src/compiler/bytecode-liveness-map.h\",\n                  \"src/compiler/common-operator.h\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/state-values-utils.h\"\n\n#include \"src/compiler/bytecode-liveness-map.h\"\n#include \"src/compiler/common-operator.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StateValuesCache\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Caches StateValues nodes to avoid creating duplicate nodes for the same set of input values.  This class is heavily used during code generation.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"js_graph_\",\n                        \"type\": \"JSGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSGraph, providing access to the graph data structure.\"\n                    },\n                    {\n                        \"name\": \"hash_map_\",\n                        \"type\": \"ZoneHashMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Hash map for caching StateValues nodes based on their input values.\"\n                    },\n                    {\n                        \"name\": \"working_space_\",\n                        \"type\": \"ZoneVector<WorkingBuffer*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of WorkingBuffer pointers, used as temporary storage during the construction of StateValues nodes.\"\n                    },\n                    {\n                        \"name\": \"empty_state_values_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Cached empty StateValues node representing a state with no input values.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"JSGraph\",\n                    \"ZoneHashMap\",\n                    \"ZoneAllocationPolicy\",\n                    \"Node\",\n                    \"StateValuesKey\",\n                    \"SparseInputMask\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass StateValuesCache {\n public:\n  explicit StateValuesCache(JSGraph* js_graph);\n\n  Node* GetEmptyStateValues();\n  Node* GetNodeForValues(Node** values, size_t count,\n                         const BytecodeLivenessState* liveness);\n\n private:\n  struct NodeKey {\n    Node* node;\n    explicit NodeKey(Node* node) : node(node) {}\n  };\n  struct StateValuesKey {\n    size_t count;\n    SparseInputMask mask;\n    Node** values;\n    StateValuesKey(size_t count, SparseInputMask mask, Node** values)\n        : count(count), mask(mask), values(values) {}\n  };\n\n  using WorkingBuffer = ZoneVector<Node*>;\n\n  JSGraph* js_graph_;\n  ZoneHashMap hash_map_;\n  ZoneVector<WorkingBuffer> working_space_;\n  Node* empty_state_values_;\n\n  static bool AreKeysEqual(void* key1, void* key2);\n  static bool IsKeysEqualToNode(StateValuesKey* key, Node* node);\n  static bool AreValueKeysEqual(StateValuesKey* key1, StateValuesKey* key2);\n\n  WorkingBuffer* GetWorkingSpace(size_t level);\n  Node* GetValuesNodeFromCache(Node** nodes, size_t count,\n                                               SparseInputMask mask);\n  SparseInputMask::BitMaskType FillBufferWithValues(\n    WorkingBuffer* node_buffer, size_t* node_count, size_t* values_idx,\n    Node** values, size_t count, const BytecodeLivenessState* liveness);\n  Node* BuildTree(size_t* values_idx, Node** values,\n                                  size_t count,\n                                  const BytecodeLivenessState* liveness,\n                                  size_t level);\n\n#if DEBUG\n  static void CheckTreeContainsValues(Node* tree, Node** values, size_t count,\n                             const BytecodeLivenessState* liveness);\n#endif\n\n  JSGraph* graph() const { return js_graph_; }\n  CommonOperatorBuilder* common() const { return js_graph_->common(); }\n  Zone* zone() const { return js_graph_->zone(); }\n\n  static const size_t kMaxInputCount = 16;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StateValuesCache::StateValuesCache\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Constructor for the StateValuesCache class.\",\n                \"logic\": \"Initializes the JSGraph pointer, hash map, working space, and empty state values.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"js_graph\",\n                        \"type\": \"JSGraph*\",\n                        \"purpose\": \"Pointer to the JSGraph.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"JSGraph\",\n                    \"ZoneHashMap\",\n                    \"ZoneAllocationPolicy\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nStateValuesCache::StateValuesCache(JSGraph* js_graph)\n    : js_graph_(js_graph),\n      hash_map_(AreKeysEqual, ZoneHashMap::kDefaultHashMapCapacity,\n                ZoneAllocationPolicy(zone())),\n      working_space_(zone()),\n      empty_state_values_(nullptr) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StateValuesCache::AreKeysEqual\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Static method to compare two keys for equality.\",\n                \"logic\": \"Compares two NodeKey or StateValuesKey objects for equality, handling cases where one or both keys represent existing nodes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"key1\",\n                        \"type\": \"void*\",\n                        \"purpose\": \"Pointer to the first key.\"\n                    },\n                    {\n                        \"name\": \"key2\",\n                        \"type\": \"void*\",\n                        \"purpose\": \"Pointer to the second key.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the keys are equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"NodeKey\",\n                    \"StateValuesKey\",\n                    \"IsKeysEqualToNode\",\n                    \"AreValueKeysEqual\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool StateValuesCache::AreKeysEqual(void* key1, void* key2) {\n  NodeKey* node_key1 = reinterpret_cast<NodeKey*>(key1);\n  NodeKey* node_key2 = reinterpret_cast<NodeKey*>(key2);\n\n  if (node_key1->node == nullptr) {\n    if (node_key2->node == nullptr) {\n      return AreValueKeysEqual(reinterpret_cast<StateValuesKey*>(key1),\n                               reinterpret_cast<StateValuesKey*>(key2));\n    } else {\n      return IsKeysEqualToNode(reinterpret_cast<StateValuesKey*>(key1),\n                               node_key2->node);\n    }\n  } else {\n    if (node_key2->node == nullptr) {\n      // If the nodes are already processed, they must be the same.\n      return IsKeysEqualToNode(reinterpret_cast<StateValuesKey*>(key2),\n                               node_key1->node);\n    } else {\n      return node_key1->node == node_key2->node;\n    }\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StateValuesCache::IsKeysEqualToNode\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Static method to compare a StateValuesKey with an existing Node for equality.\",\n                \"logic\": \"Compares a StateValuesKey's input values and mask with an existing Node's inputs and mask to determine if they represent the same state values.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"StateValuesKey*\",\n                        \"purpose\": \"Pointer to the StateValuesKey.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"Pointer to the Node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the key and node represent the same state values, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"StateValuesKey\",\n                    \"Node\",\n                    \"SparseInputMask\",\n                    \"IrOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool StateValuesCache::IsKeysEqualToNode(StateValuesKey* key, Node* node) {\n  if (key->count != static_cast<size_t>(node->InputCount())) {\n    return false;\n  }\n\n  DCHECK_EQ(IrOpcode::kStateValues, node->opcode());\n  SparseInputMask node_mask = SparseInputMaskOf(node->op());\n\n  if (node_mask != key->mask) {\n    return false;\n  }\n\n  // Comparing real inputs rather than sparse inputs, since we already know the\n  // sparse input masks are the same.\n  for (size_t i = 0; i < key->count; i++) {\n    if (key->values[i] != node->InputAt(static_cast<int>(i))) {\n      return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StateValuesCache::AreValueKeysEqual\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Static method to compare two StateValuesKey objects for equality.\",\n                \"logic\": \"Compares the input values and mask of two StateValuesKey objects to determine if they represent the same state values.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"key1\",\n                        \"type\": \"StateValuesKey*\",\n                        \"purpose\": \"Pointer to the first StateValuesKey.\"\n                    },\n                    {\n                        \"name\": \"key2\",\n                        \"type\": \"StateValuesKey*\",\n                        \"purpose\": \"Pointer to the second StateValuesKey.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the keys represent the same state values, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"StateValuesKey\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool StateValuesCache::AreValueKeysEqual(StateValuesKey* key1,\n                                         StateValuesKey* key2) {\n  if (key1->count != key2->count) {\n    return false;\n  }\n  if (key1->mask != key2->mask) {\n    return false;\n  }\n  for (size_t i = 0; i < key1->count; i++) {\n    if (key1->values[i] != key2->values[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StateValuesCache::GetEmptyStateValues\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Returns a cached empty StateValues node.\",\n                \"logic\": \"If the empty_state_values_ is null, it creates a new StateValues node with no inputs and caches it. Returns the cached or newly created empty StateValues node.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The empty StateValues node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"graph\",\n                    \"common\",\n                    \"CommonOperatorBuilder\",\n                    \"SparseInputMask\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* StateValuesCache::GetEmptyStateValues() {\n  if (empty_state_values_ == nullptr) {\n    empty_state_values_ =\n        graph()->NewNode(common()->StateValues(0, SparseInputMask::Dense()));\n  }\n  return empty_state_values_;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StateValuesCache::GetWorkingSpace\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Returns a WorkingBuffer from the working_space_ vector at the specified level.\",\n                \"logic\": \"If the working_space_ vector is smaller than the specified level, it resizes the vector. Returns a pointer to the WorkingBuffer at the specified level.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"level\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the WorkingBuffer to retrieve.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"StateValuesCache::WorkingBuffer*\",\n                    \"description\": \"Pointer to the WorkingBuffer at the specified level.\"\n                },\n                \"dependencies\": [\n                    \"ZoneVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nStateValuesCache::WorkingBuffer* StateValuesCache::GetWorkingSpace(\n    size_t level) {\n  if (working_space_.size() <= level) {\n    working_space_.resize(level + 1);\n  }\n  return &working_space_[level];\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StateValuesHashKey\",\n                \"parent\": null,\n                \"about\": \"Calculates a hash key for a set of nodes.\",\n                \"logic\": \"Iterates through the array of nodes, calculating a hash value based on the node IDs.  Uses a simple multiplicative hash.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"nodes\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Array of Node pointers.\"\n                    },\n                    {\n                        \"name\": \"count\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"Number of nodes in the array.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The calculated hash key.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nint StateValuesHashKey(Node** nodes, size_t count) {\n  size_t hash = count;\n  for (size_t i = 0; i < count; i++) {\n    hash = hash * 23 + (nodes[i] == nullptr ? 0 : nodes[i]->id());\n  }\n  return static_cast<int>(hash & 0x7FFFFFFF);\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StateValuesCache::GetValuesNodeFromCache\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Retrieves a StateValues node from the cache or creates a new one if it doesn't exist.\",\n                \"logic\": \"Looks up the StateValues node in the hash map using the provided nodes and mask. If the node is found, it returns the cached node. Otherwise, it creates a new StateValues node, adds it to the cache, and returns the new node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"nodes\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Array of Node pointers representing the input values.\"\n                    },\n                    {\n                        \"name\": \"count\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"Number of nodes in the array.\"\n                    },\n                    {\n                        \"name\": \"mask\",\n                        \"type\": \"SparseInputMask\",\n                        \"purpose\": \"Sparse input mask indicating which inputs are live.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The cached or newly created StateValues node.\"\n                },\n                \"dependencies\": [\n                    \"StateValuesKey\",\n                    \"StateValuesHashKey\",\n                    \"ZoneHashMap\",\n                    \"Node\",\n                    \"graph\",\n                    \"common\",\n                    \"CommonOperatorBuilder\",\n                    \"Zone\",\n                    \"NodeKey\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* StateValuesCache::GetValuesNodeFromCache(Node** nodes, size_t count,\n                                               SparseInputMask mask) {\n  StateValuesKey key(count, mask, nodes);\n  int hash = StateValuesHashKey(nodes, count);\n  ZoneHashMap::Entry* lookup = hash_map_.LookupOrInsert(&key, hash);\n  DCHECK_NOT_NULL(lookup);\n  Node* node;\n  if (lookup->value == nullptr) {\n    int node_count = static_cast<int>(count);\n    node = graph()->NewNode(common()->StateValues(node_count, mask), node_count,\n                            nodes);\n    NodeKey* new_key = zone()->New<NodeKey>(node);\n    lookup->key = new_key;\n    lookup->value = node;\n  } else {\n    node = reinterpret_cast<Node*>(lookup->value);\n  }\n  return node;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StateValuesCache::FillBufferWithValues\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Fills a WorkingBuffer with live values from an array of nodes, respecting liveness information.\",\n                \"logic\": \"Iterates through the input values array, adding live nodes to the WorkingBuffer.  Updates the sparse input mask to indicate which inputs are live. Skips optimized out values based on bytecode liveness state.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node_buffer\",\n                        \"type\": \"WorkingBuffer*\",\n                        \"purpose\": \"Pointer to the WorkingBuffer to fill.\"\n                    },\n                    {\n                        \"name\": \"node_count\",\n                        \"type\": \"size_t*\",\n                        \"purpose\": \"Pointer to the current number of nodes in the WorkingBuffer.\"\n                    },\n                    {\n                        \"name\": \"values_idx\",\n                        \"type\": \"size_t*\",\n                        \"purpose\": \"Pointer to the current index in the values array.\"\n                    },\n                    {\n                        \"name\": \"values\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Array of Node pointers representing the input values.\"\n                    },\n                    {\n                        \"name\": \"count\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"Number of nodes in the values array.\"\n                    },\n                    {\n                        \"name\": \"liveness\",\n                        \"type\": \"const BytecodeLivenessState*\",\n                        \"purpose\": \"Bytecode liveness state indicating which registers are live.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"SparseInputMask::BitMaskType\",\n                    \"description\": \"The sparse input mask representing the liveness of the inputs.\"\n                },\n                \"dependencies\": [\n                    \"WorkingBuffer\",\n                    \"Node\",\n                    \"BytecodeLivenessState\",\n                    \"SparseInputMask\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSparseInputMask::BitMaskType StateValuesCache::FillBufferWithValues(\n    WorkingBuffer* node_buffer, size_t* node_count, size_t* values_idx,\n    Node** values, size_t count, const BytecodeLivenessState* liveness) {\n  SparseInputMask::BitMaskType input_mask = 0;\n\n  // Virtual nodes are the live nodes plus the implicit optimized out nodes,\n  // which are implied by the liveness mask.\n  size_t virtual_node_count = *node_count;\n\n  while (*values_idx < count && *node_count < kMaxInputCount &&\n         virtual_node_count < SparseInputMask::kMaxSparseInputs) {\n    DCHECK_LE(*values_idx, static_cast<size_t>(INT_MAX));\n\n    if (liveness == nullptr ||\n        liveness->RegisterIsLive(static_cast<int>(*values_idx))) {\n      input_mask |= 1 << (virtual_node_count);\n      (*node_buffer)[(*node_count)++] = values[*values_idx];\n    }\n    virtual_node_count++;\n\n    (*values_idx)++;\n  }\n\n  DCHECK_GE(StateValuesCache::kMaxInputCount, *node_count);\n  DCHECK_GE(SparseInputMask::kMaxSparseInputs, virtual_node_count);\n\n  // Add the end marker at the end of the mask.\n  input_mask |= SparseInputMask::kEndMarker << virtual_node_count;\n\n  return input_mask;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StateValuesCache::BuildTree\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Builds a tree of StateValues nodes from an array of values, respecting liveness information.\",\n                \"logic\": \"Recursively builds a tree of StateValues nodes. At level 0, it fills a WorkingBuffer with live values. At higher levels, it either adds subtrees as inputs or fills the WorkingBuffer with remaining values. Elides single-input dense StateValue nodes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"values_idx\",\n                        \"type\": \"size_t*\",\n                        \"purpose\": \"Pointer to the current index in the values array.\"\n                    },\n                    {\n                        \"name\": \"values\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Array of Node pointers representing the input values.\"\n                    },\n                    {\n                        \"name\": \"count\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"Number of nodes in the values array.\"\n                    },\n                    {\n                        \"name\": \"liveness\",\n                        \"type\": \"const BytecodeLivenessState*\",\n                        \"purpose\": \"Bytecode liveness state indicating which registers are live.\"\n                    },\n                    {\n                        \"name\": \"level\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The current level of the tree being built.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The root of the StateValues node tree.\"\n                },\n                \"dependencies\": [\n                    \"WorkingBuffer\",\n                    \"GetWorkingSpace\",\n                    \"FillBufferWithValues\",\n                    \"BuildTree\",\n                    \"GetValuesNodeFromCache\",\n                    \"Node\",\n                    \"BytecodeLivenessState\",\n                    \"SparseInputMask\",\n                    \"IrOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* StateValuesCache::BuildTree(size_t* values_idx, Node** values,\n                                  size_t count,\n                                  const BytecodeLivenessState* liveness,\n                                  size_t level) {\n  WorkingBuffer* node_buffer = GetWorkingSpace(level);\n  size_t node_count = 0;\n  SparseInputMask::BitMaskType input_mask = SparseInputMask::kDenseBitMask;\n\n  if (level == 0) {\n    input_mask = FillBufferWithValues(node_buffer, &node_count, values_idx,\n                                      values, count, liveness);\n    // Make sure we returned a sparse input mask.\n    DCHECK_NE(input_mask, SparseInputMask::kDenseBitMask);\n  } else {\n    while (*values_idx < count && node_count < kMaxInputCount) {\n      if (count - *values_idx < kMaxInputCount - node_count) {\n        // If we have fewer values remaining than inputs remaining, dump the\n        // remaining values into this node.\n        // TODO(leszeks): We could optimise this further by only counting\n        // remaining live nodes.\n\n        size_t previous_input_count = node_count;\n        input_mask = FillBufferWithValues(node_buffer, &node_count, values_idx,\n                                          values, count, liveness);\n        // Make sure we have exhausted our values.\n        DCHECK_EQ(*values_idx, count);\n        // Make sure we returned a sparse input mask.\n        DCHECK_NE(input_mask, SparseInputMask::kDenseBitMask);\n\n        // Make sure we haven't touched inputs below previous_input_count in the\n        // mask.\n        DCHECK_EQ(input_mask & ((1 << previous_input_count) - 1), 0u);\n        // Mark all previous inputs as live.\n        input_mask |= ((1 << previous_input_count) - 1);\n\n        break;\n\n      } else {\n        // Otherwise, add the values to a subtree and add that as an input.\n        Node* subtree =\n            BuildTree(values_idx, values, count, liveness, level - 1);\n        (*node_buffer)[node_count++] = subtree;\n        // Don't touch the bitmask, so that it stays dense.\n      }\n    }\n  }\n\n  if (node_count == 1 && input_mask == SparseInputMask::kDenseBitMask) {\n    // Elide the StateValue node if there is only one, dense input. This will\n    // only happen if we built a single subtree (as nodes with values are always\n    // sparse), and so we can replace ourselves with it.\n    DCHECK_EQ((*node_buffer)[0]->opcode(), IrOpcode::kStateValues);\n    return (*node_buffer)[0];\n  } else {\n    return GetValuesNodeFromCache(node_buffer->data(), node_count,\n                                  SparseInputMask(input_mask));\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CheckTreeContainsValues\",\n                \"parent\": null,\n                \"about\": \"Debugging function to check that a StateValues tree contains the expected values.\",\n                \"logic\": \"Iterates through the StateValues tree and verifies that each node corresponds to the expected value in the input array, respecting the provided liveness information.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"tree\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The root of the StateValues tree to check.\"\n                    },\n                    {\n                        \"name\": \"values\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Array of Node pointers representing the expected values.\"\n                    },\n                    {\n                        \"name\": \"count\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"Number of nodes in the values array.\"\n                    },\n                    {\n                        \"name\": \"liveness\",\n                        \"type\": \"const BytecodeLivenessState*\",\n                        \"purpose\": \"Bytecode liveness state indicating which registers are live.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"BytecodeLivenessState\",\n                    \"StateValuesAccess\",\n                    \"IrOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if DEBUG\nnamespace {\n\nvoid CheckTreeContainsValues(Node* tree, Node** values, size_t count,\n                             const BytecodeLivenessState* liveness) {\n  DCHECK_EQ(count, StateValuesAccess(tree).size());\n\n  int i;\n  auto access = StateValuesAccess(tree);\n  auto it = access.begin();\n  auto itend = access.end();\n  for (i = 0; it != itend; ++it, ++i) {\n    if (liveness == nullptr || liveness->RegisterIsLive(i)) {\n      DCHECK_EQ(it.node(), values[i]);\n    } else {\n      DCHECK_NULL(it.node());\n    }\n  }\n  DCHECK_EQ(static_cast<size_t>(i), count);\n}\n\n}  // namespace\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StateValuesCache::GetNodeForValues\",\n                \"parent\": \"StateValuesCache\",\n                \"about\": \"Retrieves a StateValues node representing the given values, building a tree if necessary.\",\n                \"logic\": \"Checks if the input values represent actual values (not a tree of values). If the count is 0, it returns the empty StateValues node. Otherwise, it builds a tree of StateValues nodes using the BuildTree method and returns the root of the tree.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"values\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Array of Node pointers representing the input values.\"\n                    },\n                    {\n                        \"name\": \"count\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"Number of nodes in the values array.\"\n                    },\n                    {\n                        \"name\": \"liveness\",\n                        \"type\": \"const BytecodeLivenessState*\",\n                        \"purpose\": \"Bytecode liveness state indicating which registers are live.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The StateValues node representing the given values.\"\n                },\n                \"dependencies\": [\n                    \"GetEmptyStateValues\",\n                    \"BuildTree\",\n                    \"Node\",\n                    \"BytecodeLivenessState\",\n                    \"IrOpcode\",\n                    \"CheckTreeContainsValues\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* StateValuesCache::GetNodeForValues(\n    Node** values, size_t count, const BytecodeLivenessState* liveness) {\n#if DEBUG\n  // Check that the values represent actual values, and not a tree of values.\n  for (size_t i = 0; i < count; i++) {\n    if (values[i] != nullptr) {\n      DCHECK_NE(values[i]->opcode(), IrOpcode::kStateValues);\n      DCHECK_NE(values[i]->opcode(), IrOpcode::kTypedStateValues);\n    }\n  }\n  if (liveness != nullptr) {\n    DCHECK_LE(count, static_cast<size_t>(liveness->register_count()));\n\n    for (size_t i = 0; i < count; i++) {\n      if (liveness->RegisterIsLive(static_cast<int>(i))) {\n        DCHECK_NOT_NULL(values[i]);\n      }\n    }\n  }\n#endif\n\n  if (count == 0) {\n    return GetEmptyStateValues();\n  }\n\n  // This is a worst-case tree height estimate, assuming that all values are\n  // live. We could get a better estimate by counting zeroes in the liveness\n  // vector, but there's no point -- any excess height in the tree will be\n  // collapsed by the single-input elision at the end of BuildTree.\n  size_t height = 0;\n  size_t max_inputs = kMaxInputCount;\n  while (count > max_inputs) {\n    height++;\n    max_inputs *= kMaxInputCount;\n  }\n\n  size_t values_idx = 0;\n  Node* tree = BuildTree(&values_idx, values, count, liveness, height);\n  // The values should be exhausted by the end of BuildTree.\n  DCHECK_EQ(values_idx, count);\n\n  // The 'tree' must be rooted with a state value node.\n  DCHECK_EQ(tree->opcode(), IrOpcode::kStateValues);\n\n#if DEBUG\n  CheckTreeContainsValues(tree, values, count, liveness);\n#endif\n\n  return tree;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StateValuesAccess\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Provides access to the values stored in a StateValues node.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"node_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The StateValues node being accessed.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Node\",\n                    \"SparseInputMask\",\n                    \"MachineType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass StateValuesAccess {\n public:\n  explicit StateValuesAccess(Node* node) : node_(node) {}\n\n  class iterator {\n   public:\n    iterator() : current_depth_(-1) {}  // end()\n    explicit iterator(Node* node);\n\n    TypedNode operator*();\n    iterator& operator++();\n    bool operator!=(iterator const& other) const;\n\n    Node* node();\n    MachineType type();\n\n    bool done() const { return current_depth_ < 0; }\n\n   private:\n    static const int kMaxInlineDepth = 8;\n    int current_depth_;\n"
}