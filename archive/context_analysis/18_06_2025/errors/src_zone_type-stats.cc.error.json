{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/type-stats.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 170, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/type-stats.cc\",\n        \"file_name\": \"type-stats.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Collects and dumps statistics about the types allocated in Zones when V8_ENABLE_PRECISE_ZONE_STATS is defined.  Includes demangling support for better readability.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard library headers and V8 specific headers required for type demangling, integer types, standard input/output, base platform features, utils and zone type stats\"\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_ENABLE_PRECISE_ZONE_STATS\n\n#if (defined(__clang__) || defined(__GLIBCXX__)) && !defined(_MSC_VER)\n#include <cxxabi.h>\n#endif  // __GLIBCXX__\n#include <cinttypes>\n#include <cstdio>\n\n#include \"src/base/platform/memory.h\"\n#include \"src/base/platform/wrappers.h\"\n#include \"src/utils/utils.h\"\n#include \"src/zone/type-stats.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Demangler\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Demangles type names for better readability when printing type statistics. Uses the abi::__cxa_demangle function if available (clang or libstdc++), otherwise falls back to the raw type name.\",\n            \"attributes\": [\n                {\n                    \"name\": \"buffer_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Dynamically allocated buffer to store the demangled type name.  Owned by the Demangler class.\"\n                },\n                {\n                    \"name\": \"buffer_len_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Size of the buffer.\"\n                }\n            ],\n            \"dependencies\": [\n                \"std::type_index\",\n                \"base::Free\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass Demangler {\n public:\n  Demangler() = default;\n  ~Demangler() {\n    if (buffer_) base::Free(buffer_);\n    USE(buffer_len_);  // In case demangling is not supported.\n  }\n\n  const char* demangle(std::type_index type_id) {\n#if (defined(__clang__) || defined(__GLIBCXX__)) && !defined(_MSC_VER)\n    int status = -1;\n    char* result =\n        abi::__cxa_demangle(type_id.name(), buffer_, &buffer_len_, &status);\n    if (status == 0) {\n      // Upon success, the buffer_ may be reallocated.\n      buffer_ = result;\n      return buffer_;\n    }\n#endif\n    return type_id.name();\n  }\n\n private:\n  char* buffer_ = nullptr;\n  size_t buffer_len_ = 0;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"demangle\",\n            \"parent\": \"Demangler\",\n            \"about\": \"Demangles a type name using abi::__cxa_demangle if available, otherwise returns the raw type name.\",\n            \"logic\": \"Conditionally uses abi::__cxa_demangle if compiling with clang or libstdc++ and not on MSVC. If demangling succeeds, updates the internal buffer and returns a pointer to it. Otherwise, returns the original type name.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type_id\",\n                    \"type\": \"std::type_index\",\n                    \"purpose\": \"The type_index to demangle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const char*\",\n                \"description\": \"A pointer to the demangled type name (or the original name if demangling fails).\"\n            },\n            \"dependencies\": [\n                \"abi::__cxa_demangle\",\n                \"std::type_index\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  const char* Demangler::demangle(std::type_index type_id) {\n#if (defined(__clang__) || defined(__GLIBCXX__)) && !defined(_MSC_VER)\n    int status = -1;\n    char* result =\n        abi::__cxa_demangle(type_id.name(), buffer_, &buffer_len_, &status);\n    if (status == 0) {\n      // Upon success, the buffer_ may be reallocated.\n      buffer_ = result;\n      return buffer_;\n    }\n#endif\n    return type_id.name();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"~Demangler\",\n            \"parent\": \"Demangler\",\n            \"about\": \"Destructor for the Demangler class, freeing the allocated buffer.\",\n            \"logic\": \"Frees the memory allocated for the demangled type name if it was allocated.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"base::Free\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Demangler::~Demangler() {\n    if (buffer_) base::Free(buffer_);\n    USE(buffer_len_);  // In case demangling is not supported.\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MergeWith\",\n            \"parent\": \"TypeStats\",\n            \"about\": \"Merges the contents of another TypeStats object into the current one.\",\n            \"logic\": \"Iterates through the map of the other TypeStats object and adds each entry to the current object's map using the Add method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const TypeStats&\",\n                    \"purpose\": \"The TypeStats object to merge into the current one.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TypeStats::Add\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TypeStats::MergeWith(const TypeStats& other) {\n  for (auto const& item : other.map_) {\n    Add(item.first, item.second);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Dump\",\n            \"parent\": \"TypeStats\",\n            \"about\": \"Dumps the type statistics to the console in a formatted table.\",\n            \"logic\": \"Iterates through the map of type statistics, demangles the type names using the Demangler class, and prints the statistics to the console using PrintF. Also calculates and prints total statistics.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Demangler\",\n                \"PrintF\",\n                \"TypeStats::StatsEntry\",\n                \"std::type_index\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TypeStats::Dump() const {\n  Demangler d;\n  PrintF(\"===== TypeStats =====\\n\");\n  PrintF(\"-------------+--------------+------------+--------+--------------\\n\");\n  PrintF(\"       alloc |      dealloc |      count | sizeof | name\\n\");\n  PrintF(\"-------------+--------------+------------+--------+--------------\\n\");\n  uint64_t total_allocation_count = 0;\n  uint64_t total_allocated_bytes = 0;\n  uint64_t total_deallocated_bytes = 0;\n  for (auto const& item : map_) {\n    const StatsEntry& entry = item.second;\n    total_allocation_count += entry.allocation_count;\n    total_allocated_bytes += entry.allocated_bytes;\n    total_deallocated_bytes += entry.deallocated_bytes;\n    PrintF(\"%12zu | %12zu | %10zu | %6zu | %s\\n\", entry.allocated_bytes,\n           entry.deallocated_bytes, entry.allocation_count, entry.instance_size,\n           d.demangle(item.first));\n  }\n  PrintF(\"%12\" PRIu64 \" | %12\" PRIu64 \" | %10\" PRIu64\n         \" | ===== TOTAL STATS =====\\n\",\n         total_allocated_bytes, total_deallocated_bytes,\n         total_allocation_count);\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypeStats\",\n            \"about\": \"Collects allocation and deallocation statistics for different types allocated within a zone.  Precise stats collection enabled via preprocessor flag.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nclass TypeStats {\n public:\n  struct StatsEntry {\n    size_t allocated_bytes = 0;\n    size_t deallocated_bytes = 0;\n    size_t allocation_count = 0;\n    size_t instance_size = 0;\n  };\n\n  void Add(std::type_index type_id, size_t size) {\n    StatsEntry& entry = map_[type_id];\n    entry.allocated_bytes += size;\n    entry.allocation_count++;\n    entry.instance_size = size;\n  }\n\n  void Remove(std::type_index type_id, size_t size) {\n    StatsEntry& entry = map_[type_id];\n    entry.deallocated_bytes += size;\n  }\n\n  void MergeWith(const TypeStats& other);\n  void Dump() const;\n\n private:\n  std::map<std::type_index, StatsEntry> map_;\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"StatsEntry\",\n                \"about\": \"Inner struct for storing type statistics\"\n            }\n            </metadata>\n            <code><![CDATA[\n            struct StatsEntry {\n                size_t allocated_bytes = 0;\n                size_t deallocated_bytes = 0;\n                size_t allocation_count = 0;\n                size_t instance_size = 0;\n            };\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Add\",\n                \"parent\": \"TypeStats\",\n                \"about\": \"Adds allocation information for a given type.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                void Add(std::type_index type_id, size_t size) {\n                    StatsEntry& entry = map_[type_id];\n                    entry.allocated_bytes += size;\n                    entry.allocation_count++;\n                    entry.instance_size = size;\n                }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Remove\",\n                \"parent\": \"TypeStats\",\n                \"about\": \"Removes allocation information (deallocation) for a given type.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                void Remove(std::type_index type_id, size_t size) {\n                    StatsEntry& entry = map_[type_id];\n                    entry.deallocated_bytes += size;\n                }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PrintF\",\n                \"about\": \"Formatted print function\"\n            }\n            </metadata>\n            <code><![CDATA[\n            PrintF(\"===== TypeStats =====\\n\");\n            ]]></code>\n        </func>\n    </dependencies>\n</file>\n```"
}