{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler-dispatcher/lazy-compile-dispatcher.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler-dispatcher/lazy-compile-dispatcher.cc\",\n        \"file_name\": \"lazy-compile-dispatcher.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements a dispatcher for lazy compilation of JavaScript functions on background threads.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for functionality.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler-dispatcher/lazy-compile-dispatcher.h\"\n\n#include <atomic>\n\n#include \"include/v8-platform.h\"\n#include \"src/base/platform/mutex.h\"\n#include \"src/base/platform/time.h\"\n#include \"src/codegen/compiler.h\"\n#include \"src/common/globals.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/flags/flags.h\"\n#include \"src/heap/parked-scope.h\"\n#include \"src/logging/counters.h\"\n#include \"src/logging/runtime-call-stats-scope.h\"\n#include \"src/objects/instance-type.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/parsing/parse-info.h\"\n#include \"src/parsing/scanner.h\"\n#include \"src/tasks/cancelable-task.h\"\n#include \"src/tasks/task-utils.h\"\n#include \"src/zone/zone-list-inl.h\"  // crbug.com/v8/8816\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LazyCompileDispatcher::JobTask\",\n            \"extends\": \"v8::JobTask\",\n            \"about\": \"A JobTask implementation for running the background compilation job.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"LazyCompileDispatcher\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass LazyCompileDispatcher::JobTask : public v8::JobTask {\n public:\n  explicit JobTask(LazyCompileDispatcher* lazy_compile_dispatcher)\n      : lazy_compile_dispatcher_(lazy_compile_dispatcher) {}\n\n  void Run(JobDelegate* delegate) final {\n    lazy_compile_dispatcher_->DoBackgroundWork(delegate);\n  }\n\n  size_t GetMaxConcurrency(size_t worker_count) const final {\n    size_t n = lazy_compile_dispatcher_->num_jobs_for_background_.load(\n        std::memory_order_relaxed);\n    if (v8_flags.lazy_compile_dispatcher_max_threads == 0) return n;\n    return std::min(\n        n, static_cast<size_t>(v8_flags.lazy_compile_dispatcher_max_threads));\n  }\n\n private:\n  LazyCompileDispatcher* lazy_compile_dispatcher_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LazyCompileDispatcher::Job\",\n            \"about\": \"Represents a single lazy compilation job.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"BackgroundCompileTask\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nLazyCompileDispatcher::Job::Job(std::unique_ptr<BackgroundCompileTask> task)\n    : task(std::move(task)), state(Job::State::kPending) {}\n\nLazyCompileDispatcher::Job::~Job() = default;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LazyCompileDispatcher\",\n            \"about\": \"Dispatches lazy compilation tasks to background threads.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Platform\",\n                \"JobTask\",\n                \"BackgroundCompileTask\",\n                \"Utf16CharacterStream\",\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nLazyCompileDispatcher::LazyCompileDispatcher(Isolate* isolate,\n                                             Platform* platform,\n                                             size_t max_stack_size)\n    : isolate_(isolate),\n      worker_thread_runtime_call_stats_(\n          isolate->counters()->worker_thread_runtime_call_stats()),\n      background_compile_timer_(\n          isolate->counters()->compile_function_on_background()),\n      taskrunner_(platform->GetForegroundTaskRunner(\n          reinterpret_cast<v8::Isolate*>(isolate))),\n      platform_(platform),\n      max_stack_size_(max_stack_size),\n      trace_compiler_dispatcher_(v8_flags.trace_compiler_dispatcher),\n      idle_task_manager_(new CancelableTaskManager()),\n      idle_task_scheduled_(false),\n      num_jobs_for_background_(0),\n      main_thread_blocking_on_job_(nullptr),\n      block_for_testing_(false),\n      semaphore_for_testing_(0) {\n  job_handle_ = platform_->PostJob(TaskPriority::kUserVisible,\n                                   std::make_unique<JobTask>(this));\n}\n\nLazyCompileDispatcher::~LazyCompileDispatcher() {\n  // AbortAll must be called before LazyCompileDispatcher is destroyed.\n  CHECK(!job_handle_->IsValid());\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SetUncompiledDataJobPointer\",\n            \"about\": \"Sets the job pointer in the SharedFunctionInfo's UncompiledData.\",\n            \"logic\": \"Handles different UncompiledData types (with/without preparse data and job slots) by either writing to an existing job slot or allocating new UncompiledData with a job slot.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"LocalIsolate*\",\n                    \"purpose\": \"The isolate.\"\n                },\n                {\n                    \"name\": \"shared_info\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo.\"\n                },\n                {\n                    \"name\": \"job_address\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The address of the job.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"SharedFunctionInfo\",\n                \"UncompiledData\",\n                \"UncompiledDataWithPreparseDataAndJob\",\n                \"UncompiledDataWithoutPreparseDataWithJob\",\n                \"UncompiledDataWithPreparseData\",\n                \"UncompiledDataWithoutPreparseData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\n// If the SharedFunctionInfo's UncompiledData has a job slot, then write into\n// it. Otherwise, allocate a new UncompiledData with a job slot, and then write\n// into that. Since we have two optional slots (preparse data and job), this\n// gets a little messy.\nvoid SetUncompiledDataJobPointer(LocalIsolate* isolate,\n                                 DirectHandle<SharedFunctionInfo> shared_info,\n                                 Address job_address) {\n  Tagged<UncompiledData> uncompiled_data =\n      shared_info->uncompiled_data(isolate);\n  switch (uncompiled_data->map(isolate)->instance_type()) {\n    // The easy cases -- we already have a job slot, so can write into it and\n    // return.\n    case UNCOMPILED_DATA_WITH_PREPARSE_DATA_AND_JOB_TYPE:\n      Cast<UncompiledDataWithPreparseDataAndJob>(uncompiled_data)\n          ->set_job(job_address);\n      break;\n    case UNCOMPILED_DATA_WITHOUT_PREPARSE_DATA_WITH_JOB_TYPE:\n      Cast<UncompiledDataWithoutPreparseDataWithJob>(uncompiled_data)\n          ->set_job(job_address);\n      break;\n\n    // Otherwise, we'll have to allocate a new UncompiledData (with or without\n    // preparse data as appropriate), set the job pointer on that, and update\n    // the SharedFunctionInfo to use the new UncompiledData\n    case UNCOMPILED_DATA_WITH_PREPARSE_DATA_TYPE: {\n      Handle<String> inferred_name(uncompiled_data->inferred_name(), isolate);\n      Handle<PreparseData> preparse_data(\n          Cast<UncompiledDataWithPreparseData>(uncompiled_data)\n              ->preparse_data(),\n          isolate);\n      DirectHandle<UncompiledDataWithPreparseDataAndJob> new_uncompiled_data =\n          isolate->factory()->NewUncompiledDataWithPreparseDataAndJob(\n              inferred_name, uncompiled_data->start_position(),\n              uncompiled_data->end_position(), preparse_data);\n\n      new_uncompiled_data->set_job(job_address);\n      shared_info->set_uncompiled_data(*new_uncompiled_data);\n      break;\n    }\n    case UNCOMPILED_DATA_WITHOUT_PREPARSE_DATA_TYPE: {\n      DCHECK(IsUncompiledDataWithoutPreparseData(uncompiled_data));\n      Handle<String> inferred_name(uncompiled_data->inferred_name(), isolate);\n      DirectHandle<UncompiledDataWithoutPreparseDataWithJob>\n          new_uncompiled_data =\n              isolate->factory()->NewUncompiledDataWithoutPreparseDataWithJob(\n                  inferred_name, uncompiled_data->start_position(),\n                  uncompiled_data->end_position());\n\n      new_uncompiled_data->set_job(job_address);\n      shared_info->set_uncompiled_data(*new_uncompiled_data);\n      break;\n    }\n\n    default:\n      UNREACHABLE();\n  }\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Enqueue\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Enqueues a compilation job for a SharedFunctionInfo.\",\n            \"logic\": \"Creates a Job object, sets the job pointer in the SharedFunctionInfo, and adds the job to the pending queue. Notifies the job handle to increase concurrency.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"LocalIsolate*\",\n                    \"purpose\": \"The isolate.\"\n                },\n                {\n                    \"name\": \"shared_info\",\n                    \"type\": \"Handle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo to compile.\"\n                },\n                {\n                    \"name\": \"character_stream\",\n                    \"type\": \"std::unique_ptr<Utf16CharacterStream>\",\n                    \"purpose\": \"The character stream containing the source code.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Job\",\n                \"BackgroundCompileTask\",\n                \"SetUncompiledDataJobPointer\",\n                \"Utf16CharacterStream\",\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LazyCompileDispatcher::Enqueue(\n    LocalIsolate* isolate, Handle<SharedFunctionInfo> shared_info,\n    std::unique_ptr<Utf16CharacterStream> character_stream) {\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.compile\"),\n               \"V8.LazyCompilerDispatcherEnqueue\");\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kCompileEnqueueOnDispatcher);\n\n  Job* job = new Job(std::make_unique<BackgroundCompileTask>(\n      isolate_, shared_info, std::move(character_stream),\n      worker_thread_runtime_call_stats_, background_compile_timer_,\n      static_cast<int>(max_stack_size_)));\n\n  SetUncompiledDataJobPointer(isolate, shared_info,\n                              reinterpret_cast<Address>(job));\n\n  // Post a background worker task to perform the compilation on the worker\n  // thread.\n  {\n    base::MutexGuard lock(&mutex_);\n    if (trace_compiler_dispatcher_) {\n      PrintF(\"LazyCompileDispatcher: enqueued job for \");\n      ShortPrint(*shared_info);\n      PrintF(\"\\n\");\n    }\n\n#ifdef DEBUG\n    all_jobs_.insert(job);\n#endif\n    pending_background_jobs_.push_back(job);\n    NotifyAddedBackgroundJob(lock);\n  }\n  // This is not in NotifyAddedBackgroundJob to avoid being inside the mutex.\n  job_handle_->NotifyConcurrencyIncrease();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsEnqueued\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Checks if a SharedFunctionInfo is currently enqueued for compilation.\",\n            \"logic\": \"Checks if the SharedFunctionInfo has uncompiled data and if the uncompiled data contains a job pointer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"shared\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the SharedFunctionInfo is enqueued, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"SharedFunctionInfo\",\n                \"UncompiledData\",\n                \"UncompiledDataWithPreparseDataAndJob\",\n                \"UncompiledDataWithoutPreparseDataWithJob\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool LazyCompileDispatcher::IsEnqueued(\n    DirectHandle<SharedFunctionInfo> shared) const {\n  if (!shared->HasUncompiledData()) return false;\n  Job* job = nullptr;\n  Tagged<UncompiledData> data = shared->uncompiled_data(isolate_);\n  if (IsUncompiledDataWithPreparseDataAndJob(data)) {\n    job = reinterpret_cast<Job*>(\n        Cast<UncompiledDataWithPreparseDataAndJob>(data)->job());\n  } else if (IsUncompiledDataWithoutPreparseDataWithJob(data)) {\n    job = reinterpret_cast<Job*>(\n        Cast<UncompiledDataWithoutPreparseDataWithJob>(data)->job());\n  }\n  return job != nullptr;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WaitForJobIfRunningOnBackground\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Waits for a job to finish if it's running on the background thread.\",\n            \"logic\": \"If the job is running on the background thread, it blocks the main thread until the job is finished. If it is pending, it moves the job to a state where it will be run on the foreground. If it is ready to finalize it simply removes it from the finalizable jobs list.\",\n            \"parameters\": [\n                {\n                    \"name\": \"job\",\n                    \"type\": \"Job*\",\n                    \"purpose\": \"The job to wait for.\"\n                },\n                {\n                    \"name\": \"lock\",\n                    \"type\": \"const base::MutexGuard&\",\n                    \"purpose\": \"The mutex lock.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Job\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LazyCompileDispatcher::WaitForJobIfRunningOnBackground(\n    Job* job, const base::MutexGuard& lock) {\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.compile\"),\n               \"V8.LazyCompilerDispatcherWaitForBackgroundJob\");\n  RCS_SCOPE(isolate_, RuntimeCallCounterId::kCompileWaitForDispatcher);\n\n  if (!job->is_running_on_background()) {\n    if (job->state == Job::State::kPending) {\n      DCHECK_EQ(std::count(pending_background_jobs_.begin(),\n                           pending_background_jobs_.end(), job),\n                1);\n\n      // TODO(leszeks): Remove from pending jobs without walking the whole\n      // vector.\n      pending_background_jobs_.erase(\n          std::remove(pending_background_jobs_.begin(),\n                      pending_background_jobs_.end(), job),\n          pending_background_jobs_.end());\n      job->state = Job::State::kPendingToRunOnForeground;\n      NotifyRemovedBackgroundJob(lock);\n    } else {\n      DCHECK_EQ(job->state, Job::State::kReadyToFinalize);\n      DCHECK_EQ(\n          std::count(finalizable_jobs_.begin(), finalizable_jobs_.end(), job),\n          1);\n\n      // TODO(leszeks): Remove from finalizable jobs without walking the whole\n      // vector.\n      finalizable_jobs_.erase(\n          std::remove(finalizable_jobs_.begin(), finalizable_jobs_.end(), job),\n          finalizable_jobs_.end());\n      job->state = Job::State::kFinalizingNow;\n    }\n    return;\n  }\n  DCHECK_NULL(main_thread_blocking_on_job_);\n  main_thread_blocking_on_job_ = job;\n  while (main_thread_blocking_on_job_ != nullptr) {\n    main_thread_blocking_signal_.Wait(&mutex_);\n  }\n\n  DCHECK_EQ(job->state, Job::State::kReadyToFinalize);\n  DCHECK_EQ(std::count(finalizable_jobs_.begin(), finalizable_jobs_.end(), job),\n            1);\n\n  // TODO(leszeks): Remove from finalizable jobs without walking the whole\n  // vector.\n  finalizable_jobs_.erase(\n      std::remove(finalizable_jobs_.begin(), finalizable_jobs_.end(), job),\n      finalizable_jobs_.end());\n  job->state = Job::State::kFinalizingNow;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FinishNow\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Finishes the compilation of a SharedFunctionInfo immediately.\",\n            \"logic\": \"Retrieves the job for the SharedFunctionInfo, waits for it to finish if it's running on the background, runs the job on the main thread if necessary, and finalizes the compilation. Opportunistically finalizes other jobs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"function\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo to finish.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the compilation was successful, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Job\",\n                \"GetJobFor\",\n                \"WaitForJobIfRunningOnBackground\",\n                \"Compiler::FinalizeBackgroundCompileTask\",\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool LazyCompileDispatcher::FinishNow(\n    DirectHandle<SharedFunctionInfo> function) {\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.compile\"),\n               \"V8.LazyCompilerDispatcherFinishNow\");\n  RCS_SCOPE(isolate_, RuntimeCallCounterId::kCompileFinishNowOnDispatcher);\n  if (trace_compiler_dispatcher_) {\n    PrintF(\"LazyCompileDispatcher: finishing \");\n    ShortPrint(*function);\n    PrintF(\" now\\n\");\n  }\n\n  Job* job;\n\n  {\n    base::MutexGuard lock(&mutex_);\n    job = GetJobFor(function, lock);\n    WaitForJobIfRunningOnBackground(job, lock);\n  }\n\n  if (job->state == Job::State::kPendingToRunOnForeground) {\n    job->task->RunOnMainThread(isolate_);\n    job->state = Job::State::kFinalizingNow;\n  }\n\n  if (DEBUG_BOOL) {\n    base::MutexGuard lock(&mutex_);\n    DCHECK_EQ(std::count(pending_background_jobs_.begin(),\n                         pending_background_jobs_.end(), job),\n              0);\n    DCHECK_EQ(\n        std::count(finalizable_jobs_.begin(), finalizable_jobs_.end(), job), 0);\n    DCHECK_EQ(job->state, Job::State::kFinalizingNow);\n  }\n\n  bool success = Compiler::FinalizeBackgroundCompileTask(\n      job->task.get(), isolate_, Compiler::KEEP_EXCEPTION);\n  job->state = Job::State::kFinalized;\n\n  DCHECK_NE(success, isolate_->has_exception());\n  DeleteJob(job);\n\n  // Opportunistically finalize all other jobs for a maximum time of\n  // kMaxOpportunisticFinalizeTimeMs.\n  double deadline_in_seconds = platform_->MonotonicallyIncreasingTime() +\n                               kMaxOpportunisticFinalizeTimeMs / 1000.0;\n  while (deadline_in_seconds > platform_->MonotonicallyIncreasingTime()) {\n    if (!FinalizeSingleJob()) break;\n  }\n\n  return success;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AbortJob\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Aborts the compilation job for a SharedFunctionInfo.\",\n            \"logic\": \"If the job is running on the background thread, it sets the job state to abort requested. Otherwise, it removes the job from the pending or finalizable queues and aborts the job task.\",\n            \"parameters\": [\n                {\n                    \"name\": \"shared_info\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo to abort.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Job\",\n                \"GetJobFor\",\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LazyCompileDispatcher::AbortJob(\n    DirectHandle<SharedFunctionInfo> shared_info) {\n  if (trace_compiler_dispatcher_) {\n    PrintF(\"LazyCompileDispatcher: aborting job for \");\n    ShortPrint(*shared_info);\n    PrintF(\"\\n\");\n  }\n  base::LockGuard<base::Mutex> lock(&mutex_);\n\n  Job* job = GetJobFor(shared_info, lock);\n  if (job->is_running_on_background()) {\n    // Job is currently running on the background thread, wait until it's done\n    // and remove job then.\n    job->state = Job::State::kAbortRequested;\n  } else {\n    if (job->state == Job::State::kPending) {\n      DCHECK_EQ(std::count(pending_background_jobs_.begin(),\n                           pending_background_jobs_.end(), job),\n                1);\n\n      pending_background_jobs_.erase(\n          std::remove(pending_background_jobs_.begin(),\n                      pending_background_jobs_.end(), job),\n          pending_background_jobs_.end());\n      job->state = Job::State::kAbortingNow;\n      NotifyRemovedBackgroundJob(lock);\n    } else if (job->state == Job::State::kReadyToFinalize) {\n      DCHECK_EQ(\n          std::count(finalizable_jobs_.begin(), finalizable_jobs_.end(), job),\n          1);\n\n      finalizable_jobs_.erase(\n          std::remove(finalizable_jobs_.begin(), finalizable_jobs_.end(), job),\n          finalizable_jobs_.end());\n      job->state = Job::State::kAbortingNow;\n    } else {\n      UNREACHABLE();\n    }\n    job->task->AbortFunction();\n    job->state = Job::State::kFinalized;\n    DeleteJob(job, lock);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AbortAll\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Aborts all pending and finalizable compilation jobs.\",\n            \"logic\": \"Aborts all idle tasks and cancels the job handle. Iterates through the pending and finalizable queues, aborts each job task, and deletes the jobs.\",\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Job\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LazyCompileDispatcher::AbortAll() {\n  idle_task_manager_->TryAbortAll();\n  job_handle_->Cancel();\n\n  {\n    base::MutexGuard lock(&mutex_);\n    for (Job* job : pending_background_jobs_) {\n      job->task->AbortFunction();\n      job->state = Job::State::kFinalized;\n      DeleteJob(job, lock);\n    }\n    pending_background_jobs_.clear();\n    for (Job* job : finalizable_jobs_) {\n      job->task->AbortFunction();\n      job->state = Job::State::kFinalized;\n      DeleteJob(job, lock);\n    }\n    finalizable_jobs_.clear();\n    for (Job* job : jobs_to_dispose_) {\n      delete job;\n    }\n    jobs_to_dispose_.clear();\n\n    DCHECK_EQ(all_jobs_.size(), 0);\n    num_jobs_for_background_ = 0;\n    VerifyBackgroundTaskCount(lock);\n  }\n\n  idle_task_manager_->CancelAndWait();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetJobFor\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Retrieves the Job associated with a SharedFunctionInfo.\",\n            \"logic\": \"Checks the SharedFunctionInfo's UncompiledData for a job pointer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"shared\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo to get the job for.\"\n                },\n                {\n                    \"name\": \"\",\n                    \"type\": \"const base::MutexGuard&\",\n                    \"purpose\": \"\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Job*\",\n                \"description\": \"The Job associated with the SharedFunctionInfo, or nullptr if not found.\"\n            },\n            \"dependencies\": [\n                \"SharedFunctionInfo\",\n                \"UncompiledData\",\n                \"UncompiledDataWithPreparseDataAndJob\",\n                \"UncompiledDataWithoutPreparseDataWithJob\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nLazyCompileDispatcher::Job* LazyCompileDispatcher::GetJobFor(\n    DirectHandle<SharedFunctionInfo> shared, const base::MutexGuard&) const {\n  if (!shared->HasUncompiledData()) return nullptr;\n  Tagged<UncompiledData> data = shared->uncompiled_data(isolate_);\n  if (IsUncompiledDataWithPreparseDataAndJob(data)) {\n    return reinterpret_cast<Job*>(\n        Cast<UncompiledDataWithPreparseDataAndJob>(data)->job());\n  } else if (IsUncompiledDataWithoutPreparseDataWithJob(data)) {\n    return reinterpret_cast<Job*>(\n        Cast<UncompiledDataWithoutPreparseDataWithJob>(data)->job());\n  }\n  return nullptr;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ScheduleIdleTaskFromAnyThread\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Schedules an idle task to finalize compilation.\",\n            \"logic\": \"Schedules an idle task to be executed on the main thread if idle tasks are enabled and an idle task is not already scheduled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"\",\n                    \"type\": \"const base::MutexGuard&\",\n                    \"purpose\": \"\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LazyCompileDispatcher::ScheduleIdleTaskFromAnyThread(\n    const base::MutexGuard&) {\n  if (!taskrunner_->IdleTasksEnabled()) return;\n  if (idle_task_scheduled_) return;\n\n  idle_task_scheduled_ = true;\n  // TODO(leszeks): Using a full task manager for a single cancellable task is\n  // overkill, we could probably do the cancelling ourselves.\n  taskrunner_->PostIdleTask(MakeCancelableIdleTask(\n      idle_task_manager_.get(),\n      [this](double deadline_in_seconds) { DoIdleWork(deadline_in_seconds); }));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DoBackgroundWork\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Performs background compilation work.\",\n            \"logic\": \"Runs compilation tasks from the pending queue on a background thread. Finalizes completed tasks and schedules idle tasks to finalize compilation on the main thread.\",\n            \"parameters\": [\n                {\n                    \"name\": \"delegate\",\n                    \"type\": \"JobDelegate*\",\n                    \"purpose\": \"The job delegate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Job\",\n                \"BackgroundCompileTask\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LazyCompileDispatcher::DoBackgroundWork(JobDelegate* delegate) {\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.compile\"),\n               \"V8.LazyCompileDispatcherDoBackgroundWork\");\n\n  LocalIsolate isolate(isolate_, ThreadKind::kBackground);\n  UnparkedScope unparked_scope(&isolate);\n  LocalHandleScope handle_scope(&isolate);\n\n  ReusableUnoptimizedCompileState reusable_state(&isolate);\n\n  while (true) {\n    // Return immediately on yield, avoiding the second loop.\n    if (delegate->ShouldYield()) return;\n\n    Job* job = nullptr;\n    {\n      base::MutexGuard lock(&mutex_);\n\n      if (pending_background_jobs_.empty()) break;\n      job = pending_background_jobs_.back();\n      pending_background_jobs_.pop_back();\n      DCHECK_EQ(job->state, Job::State::kPending);\n\n      job->state = Job::State::kRunning;\n    }\n\n    if (V8_UNLIKELY(block_for_testing_.Value())) {\n      block_for_testing_.SetValue(false);\n      semaphore_for_testing_.Wait();\n    }\n\n    if (trace_compiler_dispatcher_) {\n      PrintF(\"LazyCompileDispatcher: doing background work\\n\");\n    }\n\n    job->task->Run(&isolate, &reusable_state);\n\n    {\n      base::MutexGuard lock(&mutex_);\n      if (job->state == Job::State::kRunning) {\n        job->state = Job::State::kReadyToFinalize;\n        // Schedule an idle task to finalize the compilation on the main thread\n        // if the job has a shared function info registered.\n      } else {\n        DCHECK_EQ(job->state, Job::State::kAbortRequested);\n        job->state = Job::State::kAborted;\n      }\n      finalizable_jobs_.push_back(job);\n      NotifyRemovedBackgroundJob(lock);\n\n      if (main_thread_blocking_on_job_ == job) {\n        main_thread_blocking_on_job_ = nullptr;\n        main_thread_blocking_signal_.NotifyOne();\n      } else {\n        ScheduleIdleTaskFromAnyThread(lock);\n      }\n    }\n  }\n\n  while (!delegate->ShouldYield()) {\n    Job* job = nullptr;\n    {\n      base::MutexGuard lock(&mutex_);\n      if (jobs_to_dispose_.empty()) break;\n      job = jobs_to_dispose_.back();\n      jobs_to_dispose_.pop_back();\n      if (jobs_to_dispose_.empty()) {\n        num_jobs_for_background_--;\n      }\n    }\n    delete job;\n  }\n\n  // Don't touch |this| anymore after this point, as it might have been\n  // deleted.\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PopSingleFinalizeJob\",\n            \"parent\": \"LazyCompileDispatcher\",\n            \"about\": \"Pops a single job that is ready for finalization.\",\n            \"logic\": \"Removes a job from the finalizable jobs list. Can be in ReadyToFinalize or Aborted state.\",\n            \"return\": {\n                \"type\": \"LazyCompileDispatcher::Job*\",\n                \"description\": \"A job that is ready for finalization or nullptr if no such job is found.\"\n            },\n            \"parameters\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nLazyCompileDispatcher::Job* LazyCompileDispatcher::PopSingleFinalizeJob() {\n  base::MutexGuard lock(&mutex_);\n\n  if (finalizable_jobs_.empty()) return nullptr;\n\n  Job* job = finalizable_jobs_.back();\n  finalizable_jobs_.pop_back();\n  DCHECK(job->state == Job::State::kReadyToFinalize ||\n         job->state == Job::State::kAborted);\n  if"
}