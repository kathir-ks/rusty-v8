{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/graph-assembler.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/graph-assembler.cc\",\n            \"file_name\": \"graph-assembler.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides an assembler-like interface for constructing graphs in the V8 compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for graph construction, code generation, and object manipulation within the V8 engine.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/graph-assembler.h\"\n\n            #include <optional>\n\n            #include \"src/base/container-utils.h\"\n            #include \"src/codegen/callable.h\"\n            #include \"src/codegen/machine-type.h\"\n            #include \"src/codegen/tnode.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/compiler/access-builder.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/graph-reducer.h\"\n            #include \"src/compiler/linkage.h\"\n            #include \"src/compiler/type-cache.h\"\n            // For TNode types.\n            #include \"src/deoptimizer/deoptimize-reason.h\"\n            #include \"src/objects/elements-kind.h\"\n            #include \"src/objects/heap-number.h\"\n            #include \"src/objects/instance-type.h\"\n            #include \"src/objects/js-array-buffer.h\"\n            #include \"src/objects/oddball.h\"\n            #include \"src/objects/string.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GraphAssembler::BlockInlineReduction\",\n                \"about\": \"A helper class to block inline reductions temporarily within a GraphAssembler instance.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"GraphAssembler\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_NODISCARD GraphAssembler::BlockInlineReduction {\n            public:\n                explicit BlockInlineReduction(GraphAssembler* gasm) : gasm_(gasm) {\n                    DCHECK(!gasm_->inline_reductions_blocked_);\n                    gasm_->inline_reductions_blocked_ = true;\n                }\n                ~BlockInlineReduction() {\n                    DCHECK(gasm_->inline_reductions_blocked_);\n                    gasm_->inline_reductions_blocked_ = false;\n                }\n\n            private:\n                GraphAssembler* gasm_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GraphAssembler\",\n                \"about\": \"Provides an assembler-like interface for constructing graphs in the V8 compiler.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"temp_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Temporary memory zone for allocating nodes.\"\n                    },\n                    {\n                        \"name\": \"mcgraph_\",\n                        \"type\": \"MachineGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The underlying MachineGraph instance.\"\n                    },\n                    {\n                        \"name\": \"default_branch_semantics_\",\n                        \"type\": \"BranchSemantics\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Default branching semantics for conditional nodes.\"\n                    },\n                    {\n                        \"name\": \"effect_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current effect node in the graph.\"\n                    },\n                    {\n                        \"name\": \"control_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current control node in the graph.\"\n                    },\n                    {\n                        \"name\": \"node_changed_callback_\",\n                        \"type\": \"std::optional<NodeChangedCallback>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Optional callback to invoke when a node is changed.\"\n                    },\n                    {\n                        \"name\": \"inline_reducers_\",\n                        \"type\": \"ZoneVector<GraphReducer*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of graph reducers to apply inline during graph construction.\"\n                    },\n                    {\n                        \"name\": \"inline_reductions_blocked_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether inline reductions are currently blocked.\"\n                    },\n                    {\n                        \"name\": \"loop_headers_\",\n                        \"type\": \"ZoneVector<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector to store loop header nodes.\"\n                    },\n                    {\n                        \"name\": \"mark_loop_exits_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A flag to mark loop exits for optimization purposes.\"\n                    },\n                    {\n                        \"name\": \"loop_nesting_level_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current level of loop nesting.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Zone\",\n                    \"BranchSemantics\",\n                    \"NodeChangedCallback\",\n                    \"Node\",\n                    \"TNode\",\n                    \"UintPtrT\",\n                    \"Smi\",\n                    \"HeapObject\",\n                    \"Object\",\n                    \"Number\",\n                    \"ExternalReference\",\n                    \"IsolateFieldId\",\n                    \"CEntryStubConstant\",\n                    \"MachineType\",\n                    \"HeapNumber\",\n                    \"Map\",\n                    \"FieldAccess\",\n                    \"ElementAccess\",\n                    \"JSArray\",\n                    \"FixedArrayBase\",\n                    \"String\",\n                    \"ElementsKind\",\n                    \"DeoptimizeReason\",\n                    \"Context\",\n                    \"JSArrayBufferView\",\n                    \"Uint32T\",\n                    \"Word32T\",\n                    \"UintPtrT\",\n                    \"BoolT\",\n                    \"Type\",\n                    \"AllocationType\",\n                    \"Simplified\",\n                    \"MapRef\",\n                    \"FeedbackSource\",\n                    \"GrowFastElementsMode\",\n                    \"JSTypedArray\",\n                    \"Runtime\",\n                    \"FrameState\",\n                    \"JSCallRuntime1\",\n                    \"JSCallRuntime2\",\n                    \"CommonOperatorBuilder\",\n                    \"MachineOperatorBuilder\",\n                    \"CallDescriptor\",\n                    \"AbortReason\",\n                    \"StoreRepresentation\",\n                    \"CallDescriptor\",\n                    \"IrOpcode\",\n                    \"GraphReducer\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class GraphAssembler {\n            public:\n                using NodeChangedCallback = std::function<void(Node*)>;\n\n                GraphAssembler(\n                    MachineGraph* mcgraph, Zone* zone, BranchSemantics default_branch_semantics,\n                    std::optional<NodeChangedCallback> node_changed_callback = std::nullopt,\n                    bool mark_loop_exits = false);\n                ~GraphAssembler();\n\n                Node* IntPtrConstant(intptr_t value);\n                TNode<UintPtrT> UintPtrConstant(uintptr_t value);\n                Node* Int32Constant(int32_t value);\n                TNode<Uint32T> Uint32Constant(uint32_t value);\n                Node* Int64Constant(int64_t value);\n                Node* Uint64Constant(uint64_t value);\n                Node* UniqueIntPtrConstant(intptr_t value);\n                Node* Float64Constant(double value);\n                Node* ExternalConstant(ExternalReference ref);\n                Node* IsolateField(IsolateFieldId id);\n                Node* Parameter(int index);\n                Node* LoadFramePointer();\n                Node* LoadRootRegister();\n\n            #if V8_ENABLE_WEBASSEMBLY\n                Node* LoadStackPointer();\n                Node* SetStackPointer(Node* node);\n            #endif\n\n                Node* LoadHeapNumberValue(Node* heap_number);\n\n                Node* Name(Node* input);\n                Node* Name(Node* left, Node* right);\n\n                TNode<BoolT> UintPtrLessThan(TNode<UintPtrT> left, TNode<UintPtrT> right);\n                TNode<BoolT> UintPtrLessThanOrEqual(TNode<UintPtrT> left, TNode<UintPtrT> right);\n                TNode<UintPtrT> UintPtrAdd(TNode<UintPtrT> left, TNode<UintPtrT> right);\n                TNode<UintPtrT> UintPtrSub(TNode<UintPtrT> left, TNode<UintPtrT> right);\n                TNode<UintPtrT> UintPtrDiv(TNode<UintPtrT> left, TNode<UintPtrT> right);\n                TNode<UintPtrT> ChangeUint32ToUintPtr(SloppyTNode<Uint32T> value);\n\n                Node* Name(Node* left, Node* right);\n\n                Node* IntPtrEqual(Node* left, Node* right);\n                Node* TaggedEqual(Node* left, Node* right);\n                Node* SmiSub(Node* left, Node* right);\n                Node* SmiLessThan(Node* left, Node* right);\n\n                Node* Float64RoundDown(Node* value);\n                Node* Float64RoundTruncate(Node* value);\n                Node* TruncateFloat64ToInt64(Node* value, TruncateKind kind);\n\n                Node* Projection(int index, Node* value, Node* ctrl = nullptr);\n\n                Node* TypeGuard(Type type, Node* value);\n                Node* Checkpoint(FrameState frame_state);\n                Node* DebugBreak();\n                Node* Unreachable();\n                Node* UnreachableWithoutConnectToEnd();\n                TNode<RawPtrT> StackSlot(int size, int alignment, bool is_tagged);\n                Node* AdaptLocalArgument(Node* argument);\n                Node* Store(StoreRepresentation rep, Node* object, Node* offset,\n                            Node* value);\n                Node* Store(StoreRepresentation rep, Node* object, int offset,\n                            Node* value);\n                Node* Load(MachineType type, Node* object, Node* offset);\n                Node* Load(MachineType type, Node* object, int offset);\n                Node* StoreUnaligned(MachineRepresentation rep, Node* object,\n                                     Node* offset, Node* value);\n                Node* LoadUnaligned(MachineType type, Node* object,\n                                    Node* offset);\n                Node* ProtectedStore(MachineRepresentation rep, Node* object,\n                                     Node* offset, Node* value);\n                Node* ProtectedLoad(MachineType type, Node* object,\n                                    Node* offset);\n                Node* LoadTrapOnNull(MachineType type, Node* object,\n                                     Node* offset);\n                Node* StoreTrapOnNull(StoreRepresentation rep, Node* object,\n                                      Node* offset, Node* value);\n                Node* Retain(Node* buffer);\n\n                Node* IntPtrAdd(Node* a, Node* b);\n                Node* IntPtrSub(Node* a, Node* b);\n\n                Node* BitcastWordToTaggedSigned(Node* value);\n                Node* BitcastWordToTagged(Node* value);\n                Node* BitcastTaggedToWord(Node* value);\n                Node* BitcastTaggedToWordForTagAndSmiBits(Node* value);\n                Node* BitcastMaybeObjectToWord(Node* value);\n                Node* DeoptimizeIf(DeoptimizeReason reason,\n                                    FeedbackSource const& feedback,\n                                    Node* condition, Node* frame_state);\n                Node* DeoptimizeIfNot(DeoptimizeReason reason,\n                                       FeedbackSource const& feedback,\n                                       Node* condition, Node* frame_state);\n\n                TNode<Object> Call(const CallDescriptor* call_descriptor,\n                                    int inputs_size, Node** inputs);\n                TNode<Object> Call(const Operator* op, int inputs_size,\n                                    Node** inputs);\n                void TailCall(const CallDescriptor* call_descriptor,\n                              int inputs_size, Node** inputs);\n                void BranchWithCriticalSafetyCheck(\n                    Node* condition, GraphAssemblerLabel<0u>* if_true,\n                    GraphAssemblerLabel<0u>* if_false);\n                void RuntimeAbort(AbortReason reason);\n\n                void ConnectUnreachableToEnd();\n\n                Zone* temp_zone() const { return temp_zone_; }\n                Graph* graph() const { return mcgraph_->graph(); }\n                CommonOperatorBuilder* common() const {\n                    return mcgraph_->common();\n                }\n                MachineOperatorBuilder* machine() const {\n                    return mcgraph_->machine();\n                }\n                Node* effect() const { return effect_; }\n                Node* control() const { return control_; }\n                void InitializeEffectControl(Node* effect, Node* control);\n                void Reset();\n\n                void AddInlineReducer(GraphReducer* reducer) {\n                    inline_reducers_.push_back(reducer);\n                }\n\n                void BlockInlineReductions() { inline_reductions_blocked_ = true; }\n                void UnblockInlineReductions() { inline_reductions_blocked_ = false; }\n\n            protected:\n                Node* AddClonedNode(Node* node);\n                Node* AddNode(Node* node);\n                void UpdateEffectControlWith(Node* node) {\n                    if (node->op()->EffectInputCount() > 0) {\n                        effect_ = node;\n                    }\n                    if (node->op()->ControlInputCount() > 0) {\n                        control_ = node;\n                    }\n                }\n\n                void BranchImpl(BranchSemantics branch_semantics, Node* condition,\n                                GraphAssemblerLabel<0u>* if_true,\n                                GraphAssemblerLabel<0u>* if_false,\n                                BranchHint branch_hint);\n                template <unsigned N>\n                void SwitchImpl(Node* index, GraphAssemblerLabel<N>* default_label,\n                                int case_count,\n                                const std::pair<int32_t, GraphAssemblerLabel<0u>*>* cases);\n\n            private:\n                // The zone for temporary allocations in this assembler.\n                Zone* const temp_zone_;\n\n                // The underlying machine graph.\n                MachineGraph* const mcgraph_;\n\n                // Default branching semantics used for branches.\n                const BranchSemantics default_branch_semantics_;\n\n                // The current effect and control nodes.\n                Node* effect_;\n                Node* control_;\n\n                // Optional callback to invoke when a node is changed.\n                std::optional<NodeChangedCallback> node_changed_callback_;\n\n                // Reducers to apply inline during graph construction.\n                ZoneVector<GraphReducer*> inline_reducers_;\n\n                // Flag indicating whether inline reductions are currently blocked.\n                bool inline_reductions_blocked_;\n\n                // Loop related data\n                ZoneVector<Node*> loop_headers_;\n                bool mark_loop_exits_;\n                int loop_nesting_level_ = 0;\n\n                friend class BlockInlineReduction;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphAssembler::GraphAssembler\",\n                \"parent\": \"GraphAssembler\",\n                \"about\": \"Constructor for the GraphAssembler class.\",\n                \"logic\": \"Initializes the GraphAssembler with the provided MachineGraph, Zone, default branch semantics, optional node changed callback and loop exit marking flag.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"mcgraph\",\n                        \"type\": \"MachineGraph*\",\n                        \"purpose\": \"The underlying MachineGraph.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone for allocating nodes.\"\n                    },\n                    {\n                        \"name\": \"default_branch_semantics\",\n                        \"type\": \"BranchSemantics\",\n                        \"purpose\": \"The default branch semantics.\"\n                    },\n                    {\n                        \"name\": \"node_changed_callback\",\n                        \"type\": \"std::optional<NodeChangedCallback>\",\n                        \"purpose\": \"Optional callback to invoke when a node is changed.\"\n                    },\n                    {\n                        \"name\": \"mark_loop_exits\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Flag to mark loop exits.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Zone\",\n                    \"BranchSemantics\",\n                    \"NodeChangedCallback\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            GraphAssembler::GraphAssembler(\n                MachineGraph* mcgraph, Zone* zone, BranchSemantics default_branch_semantics,\n                std::optional<NodeChangedCallback> node_changed_callback,\n                bool mark_loop_exits)\n                : temp_zone_(zone),\n                  mcgraph_(mcgraph),\n                  default_branch_semantics_(default_branch_semantics),\n                  effect_(nullptr),\n                  control_(nullptr),\n                  node_changed_callback_(node_changed_callback),\n                  inline_reducers_(zone),\n                  inline_reductions_blocked_(false),\n                  loop_headers_(zone),\n                  mark_loop_exits_(mark_loop_exits) {\n              DCHECK_NE(default_branch_semantics_, BranchSemantics::kUnspecified);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphAssembler::~GraphAssembler\",\n                \"parent\": \"GraphAssembler\",\n                \"about\": \"Destructor for the GraphAssembler class.\",\n                \"logic\": \"Checks that the loop nesting level is zero upon destruction.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            GraphAssembler::~GraphAssembler() { DCHECK_EQ(loop_nesting_level_, 0); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphAssembler::IntPtrConstant\",\n                \"parent\": \"GraphAssembler\",\n                \"about\": \"Creates an IntPtr constant node in the graph.\",\n                \"logic\": \"Clones an existing IntPtr constant node from the MachineGraph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"intptr_t\",\n                        \"purpose\": \"The constant value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The created IntPtr constant node.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Node* GraphAssembler::IntPtrConstant(intptr_t value) {\n              return AddClonedNode(mcgraph()->IntPtrConstant(value));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphAssembler::UintPtrConstant\",\n                \"parent\": \"GraphAssembler\",\n                \"about\": \"Creates a UintPtr constant node in the graph.\",\n                \"logic\": \"Clones an existing UintPtr constant node from the MachineGraph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"uintptr_t\",\n                        \"purpose\": \"The constant value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"TNode<UintPtrT>\",\n                    \"description\": \"The created UintPtr constant node.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"TNode\",\n                    \"UintPtrT\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            TNode<UintPtrT> GraphAssembler::UintPtrConstant(uintptr_t value) {\n              return TNode<UintPtrT>::UncheckedCast(mcgraph()->UintPtrConstant(value));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphAssembler::Int32Constant\",\n                \"parent\": \"GraphAssembler\",\n                \"about\": \"Creates an Int32 constant node in the graph.\",\n                \"logic\": \"Clones an existing Int32 constant node from the MachineGraph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"int32_t\",\n                        \"purpose\": \"The constant value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The created Int32 constant node.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Node* GraphAssembler::Int32Constant(int32_t value) {\n              return AddClonedNode(mcgraph()->Int32Constant(value));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphAssembler::Uint32Constant\",\n                \"parent\": \"GraphAssembler\",\n                \"about\": \"Creates a Uint32 constant node in the graph.\",\n                \"logic\": \"Clones an existing Uint32 constant node from the MachineGraph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"uint32_t\",\n                        \"purpose\": \"The constant value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"TNode<Uint32T>\",\n                    \"description\": \"The created Uint32 constant node.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"TNode\",\n                    \"Uint32T\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            TNode<Uint32T> GraphAssembler::Uint32Constant(uint32_t value) {\n              return TNode<Uint32T>::UncheckedCast(mcgraph()->Uint32Constant(value));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphAssembler::Int64Constant\",\n                \"parent\": \"GraphAssembler\",\n                \"about\": \"Creates an Int64 constant node in the graph.\",\n                \"logic\": \"Clones an existing Int64 constant node from the MachineGraph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"int64_t\",\n                        \"purpose\": \"The constant value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The created Int64 constant node.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Node* GraphAssembler::Int64Constant(int64_t value) {\n              return AddClonedNode(mcgraph()->Int64Constant(value));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphAssembler::Uint64Constant\",\n                \"parent\": \"GraphAssembler\",\n                \"about\": \"Creates an Uint64 constant node in the graph.\",\n                \"logic\": \"Clones an existing Uint64 constant node from the MachineGraph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The constant value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The created Uint64 constant node.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Node* GraphAssembler::Uint64Constant(uint64_t value) {\n              return AddClonedNode(mcgraph()->Uint64Constant(value));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphAssembler::UniqueIntPtrConstant\",\n                \"parent\": \"GraphAssembler\",\n                \"about\": \"Creates a unique IntPtr constant node in the graph, choosing between Int32 and Int64 based on the architecture.\",\n                \"logic\": \"Creates either Int32 or Int64 constant based on the architecture bitness.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"intptr_t\",\n                        \"purpose\": \"The constant value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The created unique IntPtr constant node.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Node\",\n                    \"CommonOperatorBuilder\",\n                    \"MachineOperatorBuilder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Node* GraphAssembler::UniqueIntPtrConstant(intptr_t value) {\n              return AddNode(graph()->NewNode(\n                  machine()->Is64()\n                      ? common()->Int64Constant(value)\n                      : common()->Int32Constant(static_cast<int32_t>(value))));\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSGraphAssembler\",\n                \"about\": \"Extends GraphAssembler to provide JavaScript-specific graph building functionality.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"GraphAssembler\",\n                    \"JSGraph\",\n                    \"TNode\",\n                    \"Smi\",\n                    \"HeapObject\",\n                    \"Object\",\n                    \"Number\",\n                    \"Handle\",\n                    \"ObjectRef\",\n                    \"ExternalReference\",\n                    \"Isolate\",\n                    \"MachineType\",\n                    \"Map\",\n                    \"FieldAccess\",\n                    \"ElementAccess\",\n                    \"JSArray\",\n                    \"FixedArrayBase\",\n                    \"String\",\n                    \"ElementsKind\",\n                    \"DeoptimizeReason\",\n                    \"Context\",\n                    \"JSArrayBufferView\",\n                    \"Uint32T\",\n                    \"Word32T\",\n                    \"UintPtrT\",\n                    \"BoolT\",\n                    \"Type\",\n                    \"AllocationType\",\n                    \"Simplified\",\n                    \"MapRef\",\n                    \"FeedbackSource\",\n                    \"GrowFastElementsMode\",\n                    \"JSTypedArray\",\n                    \"Runtime\",\n                    \"FrameState\",\n                    \"JSCallRuntime1\",\n                    \"JSCallRuntime2\",\n                    \"CommonOperatorBuilder\",\n                    \"MachineOperatorBuilder\",\n                    \"CallDescriptor\",\n                    \"AbortReason\",\n                    \"StoreRepresentation\",\n                    \"CallDescriptor\",\n                    \"PlainPrimitiveToNumberOperator\",\n                    \"Internals\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class JSGraphAssembler : public GraphAssembler {\n            public:\n                using GraphAssembler::GraphAssembler;\n\n                TNode<Smi> SmiConstant(int32_t value);\n                TNode<HeapObject> HeapConstant(Handle<HeapObject> object);\n                TNode<Object> Constant(ObjectRef ref);\n                TNode<Number> NumberConstant(double value);\n                Node* CEntryStubConstant(int result_size);\n\n                TNode<Smi> SmiConstant();\n                TNode<HeapObject> HeapConstant();\n                TNode<Object> Constant();\n                TNode<Number> NumberConstant();\n\n                TNode<HeapObject> HeapConstant();\n\n                TNode<Object> Constant();\n\n                TNode<Number> NumberConstant();\n\n                TNode<Boolean> BooleanConstant();\n\n                TNode<Boolean> BooleanConstant();\n\n                TNode<Boolean> BooleanConstant();\n\n                TNode<Boolean> BooleanConstant();\n\n                TNode<Boolean> BooleanConstant();\n\n                TNode<Boolean> IsSmi();\n\n                TNode<Boolean> IsHeapObject();\n\n                TNode<Boolean> IsString();\n\n                TNode<Boolean> IsSymbol();\n\n                TNode<Boolean> IsBoolean();\n\n                TNode<Boolean> IsNull();\n\n                TNode<Boolean> IsUndefined();\n\n                TNode<Boolean> IsTheHole();\n\n                TNode<Boolean> IsNaN();\n\n                TNode<Boolean> IsMinusZero();\n\n                AllocationType allocation() const { return allocation_; }\n\n                Node* Allocate(AllocationType allocation, Node* size);\n                TNode<Map> LoadMap(TNode<HeapObject> object);\n                Node* LoadField(FieldAccess const& access, Node* object);\n                TNode<Uint32T> LoadElementsKind(TNode<Map> map);\n                Node* LoadElement(ElementAccess const& access, Node* object,\n                                    Node* index);\n                Node* StoreField(FieldAccess const& access, Node* object,\n                                   Node* value);\n                Node* ClearPendingMessage();\n\n                TNode<Map> UnpackMapWord(Node* map_word);\n                Node* PackMapWord(TNode<Map> map);\n\n                TNode<Map> LoadMap(Node* object);\n                Node* StoreElement(ElementAccess const& access, Node* object,\n                                     Node* index, Node* value);\n                void TransitionAndStoreElement(MapRef double_map,\n                                                 MapRef fast_map,\n                                                 TNode<HeapObject> object,\n                                                 TNode<Number> index,\n                                                 TNode<Object> value);\n\n                TNode<Number> StringLength(TNode<String> string);\n                TNode<Boolean> ReferenceEqual(TNode<Object> lhs,\n                                                TNode<Object> rhs);\n                TNode<Boolean> NumberEqual(TNode<Number> lhs,\n                                             TNode<Number> rhs);\n                TNode<Number> NumberMin(TNode<Number> lhs,\n                                          TNode<Number> rhs);\n                TNode<Number> NumberMax(TNode<Number> lhs,\n                                          TNode<Number> rhs);\n                TNode<Number> NumberAdd(TNode<Number> lhs,\n                                          TNode<Number> rhs);\n                TNode<Number> NumberSubtract(TNode<Number> lhs,\n                                               TNode<Number> rhs);\n                TNode<Boolean> NumberLessThan(TNode<Number> lhs,\n                                                TNode<Number> rhs);\n                TNode<Boolean> NumberLessThanOrEqual(TNode<Number> lhs,\n                                                       TNode<Number> rhs);\n                TNode<Number> NumberShiftRightLogical(TNode<Number> lhs,\n                                                        TNode<Number> rhs);\n                TNode<Number> NumberBitwiseAnd(TNode<Number> lhs,\n                                                 TNode<Number> rhs);\n                TNode<Number> NumberBitwiseOr(TNode<Number> lhs,\n                                                TNode<Number> rhs);\n                TNode<String> StringSubstring(TNode<String> string,\n                                                TNode<Number> from,\n                                                TNode<Number> to);\n\n                TNode<Boolean> ObjectIsCallable(TNode<Object> value);\n                TNode<Boolean> ObjectIsSmi(TNode<Object> value);\n                TNode<Boolean> ObjectIsUndetectable(TNode<Object> value);\n                Node* BooleanNot(Node* cond);\n                Node* CheckSmi(Node* value, const FeedbackSource& feedback);\n                Node* CheckNumberFitsInt32(Node* value,\n                                             const FeedbackSource& feedback);\n                Node* CheckNumber(Node* value,\n                                    const FeedbackSource& feedback);\n                Node* CheckIf(Node* cond, DeoptimizeReason reason,\n                                const FeedbackSource& feedback);\n                Node* Assert(Node* cond, const char* condition_string,\n                               const char* file, int line);\n                void Assert(TNode<Word32T> cond, const char* condition_string,\n                              const char* file, int line);\n                TNode<Boolean> NumberIsFloat64Hole(TNode<Number> value);\n                TNode<Boolean> ToBoolean(TNode<Object> value);\n                TNode<Object> ConvertTaggedHoleToUndefined(\n                    TNode<Object> value);\n\n                TNode<FixedArrayBase> MaybeGrowFastElements(\n                    ElementsKind kind, const FeedbackSource& feedback, TNode<JSArray> array,\n                    TNode<FixedArrayBase> elements, TNode<Number> index_needed,\n                    TNode<Number> old_length);\n\n                TNode<Object> DoubleArrayMax(TNode<JSArray> array);\n                TNode<Object> DoubleArrayMin(TNode<JSArray> array);\n\n                Node* StringCharCodeAt(TNode<String> string,\n                                         TNode<Number> position);\n                TNode<String> StringFromSingleCharCode(TNode<Number> code);\n\n                TNode<Number> ArrayBufferViewByteLength(\n                    TNode<JSArrayBufferView> array_buffer_view, InstanceType instance_type,\n                    std::set<ElementsKind> elements_kinds_candidates, TNode<Context> context);\n\n                TNode<Word32T> ArrayBufferDetachedBit(\n                    TNode<HeapObject> buffer);\n\n                TNode<Word32T> ArrayBufferViewDetachedBit(\n                    TNode<JSArrayBufferView> array_buffer_view);\n\n                TNode<Number> TypedArrayLength(\n                    TNode<JSTypedArray> typed_array,\n                    std::set<ElementsKind> elements_kinds_candidates, TNode<Context> context);\n\n                void CheckIfTypedArrayWasDetachedOrOutOfBounds(\n                    TNode<JSTypedArray> typed_array,\n                    std::set<ElementsKind> elements_kinds_candidates,\n                    const FeedbackSource& feedback);\n\n                TNode<Uint"
}