{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/property-access-builder.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 158, column 58",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/property-access-builder.h\",\n            \"file_name\": \"property-access-builder.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the PropertyAccessBuilder class, which provides methods for building graph nodes for property access operations in the V8 compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for optional types, code generation, compiler components, node representation, handle management, and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/codegen/machine-type.h\"\n#include \"src/compiler/feedback-source.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/node.h\"\n#include \"src/handles/handles.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PropertyAccessBuilder\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Provides methods to build graph nodes for property access operations, including checks and loads.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"jsgraph_\",\n                        \"type\": \"JSGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSGraph instance.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSHeapBroker instance.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"JSGraph\",\n                    \"JSHeapBroker\",\n                    \"CompilationDependencies\",\n                    \"TFGraph\",\n                    \"CommonOperatorBuilder\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"PropertyAccessInfo\",\n                    \"FieldAccess\",\n                    \"NameRef\",\n                    \"MapRef\",\n                    \"ObjectRef\",\n                    \"FeedbackSource\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass PropertyAccessBuilder {\n public:\n  PropertyAccessBuilder(JSGraph* jsgraph, JSHeapBroker* broker)\n      : jsgraph_(jsgraph), broker_(broker) {}\n\n  // Builds the appropriate string check if the maps are only string\n  // maps.\n  bool TryBuildStringCheck(JSHeapBroker* broker, ZoneVector<MapRef> const& maps,\n                           Node** receiver, Effect* effect, Control control);\n  // Builds a number check if all maps are number maps.\n  bool TryBuildNumberCheck(JSHeapBroker* broker, ZoneVector<MapRef> const& maps,\n                           Node** receiver, Effect* effect, Control control);\n\n  void BuildCheckMaps(Node* object, Effect* effect, Control control,\n                      ZoneVector<MapRef> const& maps,\n                      bool has_deprecated_map_without_migration_target = false);\n\n  Node* BuildCheckValue(Node* receiver, Effect* effect, Control control,\n                        ObjectRef value);\n\n  Node* BuildCheckSmi(Node* value, Effect* effect, Control control,\n                      FeedbackSource feedback_source = FeedbackSource());\n\n  Node* BuildCheckNumber(Node* value, Effect* effect, Control control,\n                         FeedbackSource feedback_source = FeedbackSource());\n\n  Node* BuildCheckNumberFitsInt32(\n      Node* value, Effect* effect, Control control,\n      FeedbackSource feedback_source = FeedbackSource());\n\n  // Builds the actual load for data-field and data-constant-field\n  // properties (without heap-object or map checks).\n  Node* BuildLoadDataField(NameRef name, PropertyAccessInfo const& access_info,\n                           Node* lookup_start_object, Node** effect,\n                           Node** control);\n\n  // Tries to load a constant value from a prototype object in dictionary mode\n  // and constant-folds it. Returns {} if the constant couldn't be safely\n  // retrieved.\n  std::optional<Node*> FoldLoadDictPrototypeConstant(\n      PropertyAccessInfo const& access_info);\n\n  static MachineRepresentation ConvertRepresentation(\n      Representation representation);\n\n private:\n  JSGraph* jsgraph() const { return jsgraph_; }\n  JSHeapBroker* broker() const { return broker_; }\n  CompilationDependencies* dependencies() const {\n    return broker_->dependencies();\n  }\n  TFGraph* graph() const;\n  Isolate* isolate() const;\n  CommonOperatorBuilder* common() const;\n  SimplifiedOperatorBuilder* simplified() const;\n\n  Node* TryFoldLoadConstantDataField(NameRef name,\n                                     PropertyAccessInfo const& access_info,\n                                     Node* lookup_start_object);\n  // Returns a node with the holder for the property access described by\n  // {access_info}.\n  Node* ResolveHolder(PropertyAccessInfo const& access_info,\n                      Node* lookup_start_object);\n\n  Node* BuildLoadDataField(NameRef name, Node* holder,\n                           FieldAccess&& field_access, bool is_inobject,\n                           Node** effect, Node** control);\n\n  JSGraph* jsgraph_;\n  JSHeapBroker* broker_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasOnlyStringMaps\",\n                \"parent\": null,\n                \"about\": \"Determines if a vector of maps contains only string maps.\",\n                \"logic\": \"Iterates through the vector of MapRef objects, checking if each map represents a string.  The implementation details of this check are not present in this header file.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"Provides access to heap objects and map properties.\"\n                    },\n                    {\n                        \"name\": \"maps\",\n                        \"type\": \"ZoneVector<MapRef> const&\",\n                        \"purpose\": \"The vector of MapRef objects to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if all maps are string maps, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"ZoneVector\",\n                    \"MapRef\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool HasOnlyStringMaps(JSHeapBroker* broker, ZoneVector<MapRef> const& maps);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasOnlyStringWrapperMaps\",\n                \"parent\": null,\n                \"about\": \"Determines if a vector of maps contains only string wrapper maps.\",\n                \"logic\": \"Iterates through the vector of MapRef objects, checking if each map represents a String wrapper.  The implementation details of this check are not present in this header file.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"Provides access to heap objects and map properties.\"\n                    },\n                    {\n                        \"name\": \"maps\",\n                        \"type\": \"ZoneVector<MapRef> const&\",\n                        \"purpose\": \"The vector of MapRef objects to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if all maps are string wrapper maps, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"ZoneVector\",\n                    \"MapRef\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool HasOnlyStringWrapperMaps(JSHeapBroker* broker,\n                              ZoneVector<MapRef> const& maps);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasOnlyNonResizableTypedArrayMaps\",\n                \"parent\": null,\n                \"about\": \"Determines if a vector of maps contains only non-resizable typed array maps.\",\n                \"logic\": \"Iterates through the vector of MapRef objects, checking if each map represents a non-resizable TypedArray.  The implementation details of this check are not present in this header file.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"Provides access to heap objects and map properties.\"\n                    },\n                    {\n                        \"name\": \"maps\",\n                        \"type\": \"ZoneVector<MapRef> const&\",\n                        \"purpose\": \"The vector of MapRef objects to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if all maps are non-resizable typed array maps, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"ZoneVector\",\n                    \"MapRef\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool HasOnlyNonResizableTypedArrayMaps(JSHeapBroker* broker,\n                                       ZoneVector<MapRef> const& maps);\n        ]]></code>\n    </func>\n</file>\n```"
}