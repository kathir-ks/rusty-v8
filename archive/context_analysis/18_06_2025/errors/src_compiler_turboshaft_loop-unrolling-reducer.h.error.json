{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/loop-unrolling-reducer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/loop-unrolling-reducer.h\",\n            \"file_name\": \"loop-unrolling-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the LoopUnrollingReducer, LoopStackCheckElisionReducer, LoopUnrollingAnalyzer, and related classes for performing loop unrolling and stack check elision in the Turboshaft compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for optional values, logging, compiler globals, assembler, copying phase, index, loop finding, machine optimization, operations, and compiler phase management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/logging.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/copying-phase.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/loop-finder.h\"\n#include \"src/compiler/turboshaft/machine-optimization-reducer.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"IterationCount\",\n                \"about\": \"Represents the number of iterations a loop will execute.  Can be exact, approximate, or unknown.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind_\",\n                        \"type\": \"Kind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The type of iteration count (exact, approximate, unknown).\"\n                    },\n                    {\n                        \"name\": \"count_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The number of iterations, valid if kind_ is exact or approximate.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass IterationCount {\n  enum class Kind { kExact, kApprox, kUnknown };\n\n public:\n  // Loops with an exact number of iteration could be unrolled.\n  static IterationCount Exact(size_t count) {\n    return IterationCount(Kind::kExact, count);\n  }\n  // We can remove stack checks from loops with a small number of iterations.\n  static IterationCount Approx(size_t count) {\n    return IterationCount(Kind::kApprox, count);\n  }\n  static IterationCount Unknown() { return IterationCount(Kind::kUnknown); }\n\n  IterationCount() : kind_(Kind::kUnknown) {}\n  explicit IterationCount(Kind kind) : kind_(kind) {\n    DCHECK_NE(kind, Kind::kExact);\n  }\n  IterationCount(Kind kind, size_t count) : kind_(kind), count_(count) {\n    DCHECK_EQ(kind, any_of(Kind::kExact, Kind::kApprox));\n  }\n\n  size_t exact_count() const {\n    DCHECK_EQ(kind_, Kind::kExact);\n    return count_;\n  }\n  size_t approx_count() const {\n    DCHECK_EQ(kind_, Kind::kApprox);\n    return count_;\n  }\n\n  bool IsExact() const { return kind_ == Kind::kExact; }\n  bool IsApprox() const { return kind_ == Kind::kApprox; }\n  bool IsUnknown() const { return kind_ == Kind::kUnknown; }\n\n  bool IsSmallerThan(size_t max) {\n    return (IsExact() || IsApprox()) && count_ < max;\n  }\n\n private:\n  Kind kind_;\n  size_t count_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for IterationCount to allow printing to an ostream.\",\n                \"logic\": \"Outputs the IterationCount's state (kind and count).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"count\",\n                        \"type\": \"const IterationCount&\",\n                        \"purpose\": \"The IterationCount to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The modified output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const IterationCount& count);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StaticCanonicalForLoopMatcher\",\n                \"about\": \"Matches simple for-loops of the form `for (let i = cst; i cmp cst; i = i binop cst)` to statically compute the number of iterations.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"matcher_\",\n                        \"type\": \"const OperationMatcher&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to an OperationMatcher object.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"OperationMatcher\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE StaticCanonicalForLoopMatcher {\n  // In the context of this class, a \"static canonical for-loop\" is one of the\n  // form `for (let i = cst; i cmp cst; i = i binop cst)`. That is, a fairly\n  // simple for-loop, for which we can statically compute the number of\n  // iterations.\n  //\n  // There is an added constraint that this class can only match loops with few\n  // iterations (controlled by the `max_iter_` parameter), for performance\n  // reasons (because it's a bit tricky to compute how many iterations a loop\n  // has, see the `HasFewerIterationsThan` method).\n  //\n  // This class and its methods are not in OperationMatcher, even though they\n  // could fit there, because they seemed a bit too loop-unrolling specific.\n  // However, if they can ever be useful for something else, any of the\n  // \"MatchXXX\" method of this class could be moved to OperationMatcher.\n public:\n  explicit StaticCanonicalForLoopMatcher(const OperationMatcher& matcher)\n      : matcher_(matcher) {}\n\n  IterationCount GetIterCountIfStaticCanonicalForLoop(\n      const Block* header, OpIndex cond_idx, bool loop_if_cond_is) const;\n\n  enum class CmpOp {\n    kEqual,\n    kSignedLessThan,\n    kSignedLessThanOrEqual,\n    kUnsignedLessThan,\n    kUnsignedLessThanOrEqual,\n    kSignedGreaterThan,\n    kSignedGreaterThanOrEqual,\n    kUnsignedGreaterThan,\n    kUnsignedGreaterThanOrEqual,\n  };\n  static constexpr CmpOp ComparisonKindToCmpOp(ComparisonOp::Kind kind);\n  static constexpr CmpOp InvertComparisonOp(CmpOp op);\n  enum class BinOp {\n    kAdd,\n    kMul,\n    kSub,\n    kBitwiseAnd,\n    kBitwiseOr,\n    kBitwiseXor,\n    kOverflowCheckedAdd,\n    kOverflowCheckedMul,\n    kOverflowCheckedSub\n  };\n  static constexpr BinOp BinopFromWordBinopKind(WordBinopOp::Kind kind);\n  static constexpr BinOp BinopFromOverflowCheckedBinopKind(\n      OverflowCheckedBinopOp::Kind kind);\n  static constexpr bool BinopKindIsSupported(WordBinopOp::Kind binop_kind);\n\n private:\n  bool MatchPhiCompareCst(OpIndex cond_idx,\n                          StaticCanonicalForLoopMatcher::CmpOp* cmp_op,\n                          OpIndex* phi, uint64_t* cst) const;\n  bool MatchCheckedOverflowBinop(OpIndex idx, V<Word>* left, V<Word>* right,\n                                 BinOp* binop_op,\n                                 WordRepresentation* binop_rep) const;\n  bool MatchWordBinop(OpIndex idx, V<Word>* left, V<Word>* right,\n                      BinOp* binop_op, WordRepresentation* binop_rep) const;\n  IterationCount CountIterations(uint64_t equal_cst, CmpOp cmp_op,\n                                 uint64_t initial_input, uint64_t binop_cst,\n                                 BinOp binop_op, WordRepresentation binop_rep,\n                                 bool loop_if_cond_is) const;\n  template <class Int>\n  IterationCount CountIterationsImpl(\n      Int init, Int max, CmpOp cmp_op, Int binop_cst,\n      StaticCanonicalForLoopMatcher::BinOp binop_op,\n      WordRepresentation binop_rep, bool loop_if_cond_is) const;\n\n  const OperationMatcher& matcher_;\n\n  // When trying to compute the number of iterations of a loop, we simulate the\n  // first {kMaxExactIter} iterations of the loop, and check if the loop ends\n  // during these first few iterations. This is slightly inneficient, hence the\n  // small value for {kMaxExactIter}, but it's simpler than using a formula to\n  // compute the number of iterations (in particular because of overflows).\n  static constexpr size_t kMaxExactIter = 5;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for StaticCanonicalForLoopMatcher::CmpOp to allow printing to an ostream.\",\n                \"logic\": \"Outputs the CmpOp's string representation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"cmp\",\n                        \"type\": \"const StaticCanonicalForLoopMatcher::CmpOp&\",\n                        \"purpose\": \"The CmpOp to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The modified output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os,\n                         const StaticCanonicalForLoopMatcher::CmpOp& cmp);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for StaticCanonicalForLoopMatcher::BinOp to allow printing to an ostream.\",\n                \"logic\": \"Outputs the BinOp's string representation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"binop\",\n                        \"type\": \"const StaticCanonicalForLoopMatcher::BinOp&\",\n                        \"purpose\": \"The BinOp to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The modified output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os,\n                         const StaticCanonicalForLoopMatcher::BinOp& binop);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoopUnrollingAnalyzer\",\n                \"about\": \"Analyzes loops in the graph to determine if they can be fully or partially unrolled, or removed.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"input_graph_\",\n                        \"type\": \"Graph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the input graph being analyzed.\"\n                    },\n                    {\n                        \"name\": \"matcher_\",\n                        \"type\": \"OperationMatcher\",\n                        \"access\": \"private\",\n                        \"purpose\": \"OperationMatcher instance used for pattern matching.\"\n                    },\n                    {\n                        \"name\": \"loop_finder_\",\n                        \"type\": \"LoopFinder\",\n                        \"access\": \"private\",\n                        \"purpose\": \"LoopFinder instance used to find loops in the graph.\"\n                    },\n                    {\n                        \"name\": \"loop_iteration_count_\",\n                        \"type\": \"ZoneUnorderedMap<const Block*, IterationCount>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps loop headers to the number of iterations.\"\n                    },\n                    {\n                        \"name\": \"canonical_loop_matcher_\",\n                        \"type\": \"const StaticCanonicalForLoopMatcher\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Instance of StaticCanonicalForLoopMatcher used to match canonical for loops.\"\n                    },\n                    {\n                        \"name\": \"is_wasm_\",\n                        \"type\": \"const bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if the code being analyzed is WebAssembly.\"\n                    },\n                    {\n                        \"name\": \"kMaxLoopSizeForPartialUnrolling\",\n                        \"type\": \"const size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maximum loop size for partial unrolling.\"\n                    },\n                    {\n                        \"name\": \"can_unroll_at_least_one_loop_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if at least one loop can be unrolled.\"\n                    },\n                    {\n                        \"name\": \"stack_checks_to_remove_\",\n                        \"type\": \"ZoneAbslFlatHashSet<uint32_t>&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of stack checks to be removed.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Graph\",\n                    \"OperationMatcher\",\n                    \"LoopFinder\",\n                    \"StaticCanonicalForLoopMatcher\",\n                    \"IterationCount\",\n                    \"Block\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE LoopUnrollingAnalyzer {\n  // LoopUnrollingAnalyzer analyzes the loops of the graph, and in particular\n  // tries to figure out if some inner loops have a fixed (and known) number of\n  // iterations. In particular, it tries to pattern match loops like\n  //\n  //    for (let i = 0; i < 4; i++) { ... }\n  //\n  // where `i++` could alternatively be pretty much any WordBinopOp or\n  // OverflowCheckedBinopOp, and `i < 4` could be any ComparisonOp.\n  // Such loops, if small enough, could be fully unrolled.\n  //\n  // Loops that don't have statically-known bounds could still be partially\n  // unrolled if they are small enough.\n public:\n  LoopUnrollingAnalyzer(Zone* phase_zone, Graph* input_graph, bool is_wasm)\n      : input_graph_(input_graph),\n        matcher_(*input_graph),\n        loop_finder_(phase_zone, input_graph),\n        loop_iteration_count_(phase_zone),\n        canonical_loop_matcher_(matcher_),\n        is_wasm_(is_wasm),\n        stack_checks_to_remove_(input_graph->stack_checks_to_remove()) {\n    DetectUnrollableLoops();\n  }\n\n  bool ShouldFullyUnrollLoop(const Block* loop_header) const {\n    DCHECK(loop_header->IsLoop());\n\n    LoopFinder::LoopInfo header_info = loop_finder_.GetLoopInfo(loop_header);\n    if (header_info.has_inner_loops) return false;\n    if (header_info.op_count > kMaxLoopSizeForFullUnrolling) return false;\n\n    auto iter_count = GetIterationCount(loop_header);\n    return iter_count.IsExact() &&\n           iter_count.exact_count() < kMaxLoopIterationsForFullUnrolling;\n  }\n\n  bool ShouldPartiallyUnrollLoop(const Block* loop_header) const {\n    DCHECK(loop_header->IsLoop());\n    LoopFinder::LoopInfo info = loop_finder_.GetLoopInfo(loop_header);\n    return !info.has_inner_loops &&\n           info.op_count < kMaxLoopSizeForPartialUnrolling;\n  }\n\n  // The returned unroll count is the total number of copies of the loop body\n  // in the resulting graph, i.e., an unroll count of N means N-1 copies of the\n  // body which were partially unrolled, and 1 for the original/remaining body.\n  size_t GetPartialUnrollCount(const Block* loop_header) const {\n    // Don't unroll if the function is already huge.\n    // Otherwise we have run into pathological runtimes or large memory usage,\n    // e.g., in register allocation in the past, see https://crbug.com/383661627\n    // for an example / reproducer.\n    // Even though we return an unroll count of one (i.e., don't unroll at all\n    // really), running this phase can speed up subsequent optimizations,\n    // probably because it produces loops in a \"compact\"/good block order for\n    // analyses, namely <loop header>, <loop body>, <loop exit>, <rest of code>.\n    // In principle, we should fix complexity problems in analyses, make sure\n    // loops are already produced in this order, and not rely on the \"unrolling\"\n    // here for the order alone, but this is a longer standing issue.\n    if (input_graph_->op_id_count() > kMaxFunctionSizeForPartialUnrolling) {\n      return 1;\n    }\n    if (is_wasm_) {\n      LoopFinder::LoopInfo info = loop_finder_.GetLoopInfo(loop_header);\n      return std::min(\n          LoopUnrollingAnalyzer::kMaxPartialUnrollingCount,\n          LoopUnrollingAnalyzer::kWasmMaxUnrolledLoopSize / info.op_count);\n    }\n    return LoopUnrollingAnalyzer::kMaxPartialUnrollingCount;\n  }\n\n  bool ShouldRemoveLoop(const Block* loop_header) const {\n    auto iter_count = GetIterationCount(loop_header);\n    return iter_count.IsExact() && iter_count.exact_count() == 0;\n  }\n\n  IterationCount GetIterationCount(const Block* loop_header) const {\n    DCHECK(loop_header->IsLoop());\n    auto it = loop_iteration_count_.find(loop_header);\n    if (it == loop_iteration_count_.end()) return IterationCount::Unknown();\n    return it->second;\n  }\n\n  ZoneSet<const Block*, LoopFinder::BlockCmp> GetLoopBody(\n      const Block* loop_header) {\n    return loop_finder_.GetLoopBody(loop_header);\n  }\n\n  const Block* GetLoopHeader(const Block* block) {\n    return loop_finder_.GetLoopHeader(block);\n  }\n\n  bool CanUnrollAtLeastOneLoop() const { return can_unroll_at_least_one_loop_; }\n\n  // TODO(dmercadier): consider tweaking these value for a better size-speed\n  // trade-off. In particular, having the number of iterations to unroll be a\n  // function of the loop's size and a MaxLoopSize could make sense.\n  static constexpr size_t kMaxLoopSizeForFullUnrolling = 150;\n  // This function size limit is quite arbitrary. It is large enough that we\n  // probably never hit it in JavaScript and it is lower than the operation\n  // count we have seen in some huge Wasm functions in the past, e.g., function\n  // #21937 of https://crbug.com/383661627 (1.7M operations, 2.7MB wire bytes).\n  static constexpr size_t kMaxFunctionSizeForPartialUnrolling = 1'000'000;\n  static constexpr size_t kJSMaxLoopSizeForPartialUnrolling = 50;\n  static constexpr size_t kWasmMaxLoopSizeForPartialUnrolling = 80;\n  static constexpr size_t kWasmMaxUnrolledLoopSize = 240;\n  static constexpr size_t kMaxLoopIterationsForFullUnrolling = 4;\n  static constexpr size_t kMaxPartialUnrollingCount = 4;\n  static constexpr size_t kMaxIterForStackCheckRemoval = 5000;\n\n private:\n  void DetectUnrollableLoops();\n  IterationCount GetLoopIterationCount(const LoopFinder::LoopInfo& info) const;\n\n  Graph* input_graph_;\n  OperationMatcher matcher_;\n  LoopFinder loop_finder_;\n  // {loop_iteration_count_} maps loop headers to number of iterations. It\n  // doesn't contain entries for loops for which we don't know the number of\n  // iterations.\n  ZoneUnorderedMap<const Block*, IterationCount> loop_iteration_count_;\n  const StaticCanonicalForLoopMatcher canonical_loop_matcher_;\n  const bool is_wasm_;\n  const size_t kMaxLoopSizeForPartialUnrolling =\n      is_wasm_ ? kWasmMaxLoopSizeForPartialUnrolling\n               : kJSMaxLoopSizeForPartialUnrolling;\n  bool can_unroll_at_least_one_loop_ = false;\n\n  ZoneAbslFlatHashSet<uint32_t>& stack_checks_to_remove_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoopPeelingReducer\",\n                \"about\": \"A reducer class that performs loop peeling.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass LoopPeelingReducer;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoopStackCheckElisionReducer\",\n                \"extends\": \"Next\",\n                \"about\": \"A reducer class that eliminates stack checks within loops based on analysis results.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"skip_next_stack_check_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the next stack check should be skipped.\"\n                    },\n                    {\n                        \"name\": \"stack_checks_to_remove_\",\n                        \"type\": \"const ZoneAbslFlatHashSet<uint32_t>&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of loop IDs for which stack checks should be removed.\"\n                    },\n                    {\n                        \"name\": \"remove_stack_checks_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating if stack check removal is enabled.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSHeapBroker.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Next\",\n                    \"Block\",\n                    \"ZoneAbslFlatHashSet\",\n                    \"CallOp\",\n                    \"JSStackCheckOp\",\n                    \"WasmStackCheckOp\",\n                    \"StackCheckKind\",\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass LoopStackCheckElisionReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(LoopStackCheckElision)\n\n  void Bind(Block* new_block) {\n    Next::Bind(new_block);\n    if (!remove_stack_checks_) return;\n\n    if (new_block->IsLoop()) {\n      const Block* origin = new_block->OriginForBlockEnd();\n      if (origin) {\n        if (stack_checks_to_remove_.contains(origin->index().id())) {\n          skip_next_stack_check_ = true;\n        }\n      }\n    }\n  }\n\n  V<AnyOrNone> REDUCE_INPUT_GRAPH(Call)(V<AnyOrNone> ig_idx,\n                                        const CallOp& call) {\n    LABEL_BLOCK(no_change) { return Next::ReduceInputGraphCall(ig_idx, call); }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    if (skip_next_stack_check_ &&\n        call.IsStackCheck(__ input_graph(), broker_,\n                          StackCheckKind::kJSIterationBody)) {\n      skip_next_stack_check_ = false;\n      return {};\n    }\n\n    goto no_change;\n  }\n\n  V<None> REDUCE_INPUT_GRAPH(JSStackCheck)(V<None> ig_idx,\n                                           const JSStackCheckOp& stack_check) {\n    if (skip_next_stack_check_ &&\n        stack_check.kind == JSStackCheckOp::Kind::kLoop) {\n      skip_next_stack_check_ = false;\n      return {};\n    }\n    return Next::ReduceInputGraphJSStackCheck(ig_idx, stack_check);\n  }\n\n#if V8_ENABLE_WEBASSEMBLY\n  V<None> REDUCE_INPUT_GRAPH(WasmStackCheck)(\n      V<None> ig_idx, const WasmStackCheckOp& stack_check) {\n    if (skip_next_stack_check_ &&\n        stack_check.kind == WasmStackCheckOp::Kind::kLoop) {\n      skip_next_stack_check_ = false;\n      return {};\n    }\n    return Next::ReduceInputGraphWasmStackCheck(ig_idx, stack_check);\n  }\n#endif\n\n private:\n  bool skip_next_stack_check_ = false;\n\n  // The analysis should have ran before the CopyingPhase starts, and stored in\n  // `PipelineData::Get().stack_checks_to_remove()` the loops whose stack checks\n  // should be removed.\n  const ZoneAbslFlatHashSet<uint32_t>& stack_checks_to_remove_ =\n      __ input_graph().stack_checks_to_remove();\n  bool remove_stack_checks_ = !stack_checks_to_remove_.empty();\n\n  JSHeapBroker* broker_ = __ data() -> broker();\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoopUnrollingReducer\",\n                \"extends\": \"Next\",\n                \"about\": \"A reducer class that performs loop unrolling optimizations.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"analyzer_\",\n                        \"type\": \"LoopUnrollingAnalyzer&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to the LoopUnrollingAnalyzer for analyzing loops.\"\n                    },\n                    {\n                        \"name\": \"unrolling_\",\n                        \"type\": \"UnrollingStatus\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether a loop is currently being unrolled.\"\n                    },\n                    {\n                        \"name\": \"skip_next_stack_check_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the next stack check should be skipped.\"\n                    },\n                    {\n                        \"name\": \"current_loop_header_\",\n                        \"type\": \"const Block*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the header of the loop currently being unrolled.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSHeapBroker.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Next\",\n                    \"Block\",\n                    \"LoopUnrollingAnalyzer\",\n                    \"GotoOp\",\n                    \"BranchOp\",\n                    \"CallOp\",\n                    \"JSStackCheckOp\",\n                    \"WasmStackCheckOp\",\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass LoopUnrollingReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(LoopUnrolling)\n\n#if defined(__clang__)\n  // LoopUnrolling and LoopPeeling shouldn't be performed in the same phase, see\n  // the comment in pipeline.cc where LoopUnrolling is triggered.\n  static_assert(!reducer_list_contains<ReducerList, LoopPeelingReducer>::value);\n\n  // TODO(dmercadier): Add static_assert that this is ran as part of a\n  // CopyingPhase.\n#endif\n\n  V<None> REDUCE_INPUT_GRAPH(Goto)(V<None> ig_idx, const GotoOp& gto) {\n    // Note that the \"ShouldSkipOptimizationStep\" are placed in the parts of\n    // this Reduce method triggering the unrolling rather than at the begining.\n    // This is because the backedge skipping is not an optimization but a\n    // mandatory lowering when unrolling is being performed.\n    LABEL_BLOCK(no_change) { return Next::ReduceInputGraphGoto(ig_idx, gto); }\n\n    const Block* dst = gto.destination;\n    if (unrolling_ == UnrollingStatus::kNotUnrolling && dst->IsLoop() &&\n        !gto.is_backedge) {\n      // We trigger unrolling when reaching the GotoOp that jumps to the loop\n      // header (note that loop headers only have 2 predecessor, including the\n      // backedge), and that isn't the backedge.\n      if (ShouldSkipOptimizationStep()) goto no_change;\n      if (analyzer_.ShouldRemoveLoop(dst)) {\n        RemoveLoop(dst);\n        return {};\n      } else if (analyzer_.ShouldFullyUnrollLoop(dst)) {\n        FullyUnrollLoop(dst);\n        return {};\n      } else if (analyzer_.ShouldPartiallyUnrollLoop(dst)) {\n        PartiallyUnrollLoop(dst);\n        return {};\n      }\n    } else if ((unrolling_ == UnrollingStatus::kUnrolling) &&\n               dst == current_loop_header_) {\n      // Skipping the backedge of the loop: FullyUnrollLoop and\n      // PartiallyUnrollLoop will emit a Goto to the next unrolled iteration.\n      return {};\n    }\n    goto no_change;\n  }\n\n  V<None> REDUCE_INPUT_GRAPH(Branch)(V<None> ig_idx, const BranchOp& branch) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphBranch(ig_idx, branch);\n    }\n\n    if (unrolling_ == UnrollingStatus::kRemoveLoop) {\n      // We know that the branch of the final inlined header of a fully unrolled\n      // loop never actually goes to the loop, so we can replace it by a Goto\n      // (so that the non-unrolled loop doesn't get emitted). We still need to\n      // figure out if we should Goto to the true or false side of the BranchOp.\n      const Block* header = __ current_block()->OriginForBlockEnd();\n      bool is_true_in_loop = analyzer_.GetLoopHeader(branch.if_true) == header;\n      bool is_false_in_loop =\n          analyzer_.GetLoopHeader(branch.if_false) == header;\n\n      if (is_true_in_loop && !is_false_in_loop) {\n        __ Goto(__ MapToNewGraph(branch.if_false));\n        return OpIndex::Invalid();\n      } else if (is_false_in_loop && !is_true_in_loop) {\n        __ Goto(__ MapToNewGraph(branch.if_true));\n        return OpIndex::Invalid();\n      } else {\n        // Both the true and false destinations of this block are in the loop,\n        // which means that the exit of the loop is later down the graph. We\n        // thus still emit the branch, which will lead to the loop being emitted\n        // (unless some other reducers in the stack manage to get rid of the\n        // loop).\n        DCHECK(is_true_in_loop && is_false_in_loop);\n      }\n    }\n    goto no_change;\n  }\n\n  V<AnyOrNone> REDUCE_INPUT_GRAPH(Call)(V<AnyOrNone> ig_idx,\n                                        const CallOp& call) {\n    LABEL_BLOCK(no_change) { return Next::ReduceInputGraphCall(ig_idx, call); }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    if (V8_LIKELY(!IsRunningBuiltinPipeline())) {\n      if (skip_next_stack_check_ &&\n          call.IsStackCheck(__ input_graph(), broker_,\n                            StackCheckKind::kJSIterationBody)) {\n        // When we unroll a loop, we get rid of its stack checks. (note that\n        // we don't do this for the last folded body of partially unrolled\n        // loops so that the loop keeps one stack check).\n        return {};\n      }\n    }\n\n    goto no_change;\n  }\n\n  V<None> REDUCE_INPUT_GRAPH(JSStackCheck)(V<None> ig_idx,\n                                           const JSStackCheckOp& check) {\n    if (ShouldSkipOptimizationStep() || !skip_next_stack_check_) {\n      return Next::ReduceInputGraphJSStackCheck(ig_idx, check);\n    }\n    return V<None>::Invalid();\n  }\n\n#if V8_ENABLE_WEBASSEMBLY\n  V<None> REDUCE_INPUT_GRAPH(WasmStackCheck)(V<None> ig_idx,\n                                             const WasmStackCheckOp& check) {\n    if (ShouldSkipOptimizationStep() || !skip_next_stack_check_) {\n      return Next::ReduceInputGraphWasm"
}