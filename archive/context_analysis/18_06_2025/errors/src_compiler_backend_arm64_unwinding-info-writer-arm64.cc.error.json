{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm64/unwinding-info-writer-arm64.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 243, column 44",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm64/unwinding-info-writer-arm64.cc\",\n        \"file_name\": \"unwinding-info-writer-arm64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the UnwindingInfoWriter class for ARM64 architecture, responsible for generating unwinding information for stack frames, used for exception handling and debugging.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for the UnwindingInfoWriter class and instruction definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/backend/arm64/unwinding-info-writer-arm64.h\"\n#include \"src/compiler/backend/instruction.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BeginInstructionBlock\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Handles the beginning of an instruction block, potentially recording changes in the saved link register (LR) status.\",\n            \"logic\": \"Checks if the unwinding information writing is enabled. If so, it retrieves the initial state of the block and compares the saved LR status with the current status. If there's a change, it records the appropriate unwinding information using the eh_frame_writer_.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pc_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The program counter offset for the current instruction block.\"\n                },\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const InstructionBlock*\",\n                    \"purpose\": \"A pointer to the InstructionBlock object representing the current block.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionBlock\",\n                \"BlockInitialState\",\n                \"eh_frame_writer_\",\n                \"lr\",\n                \"fp\",\n                \"kSystemPointerSize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::BeginInstructionBlock(int pc_offset,\n                                                const InstructionBlock* block) {\n  if (!enabled()) return;\n\n  block_will_exit_ = false;\n\n  DCHECK_LT(block->rpo_number().ToInt(),\n            static_cast<int>(block_initial_states_.size()));\n  const BlockInitialState* initial_state =\n      block_initial_states_[block->rpo_number().ToInt()];\n  if (!initial_state) return;\n  if (initial_state->saved_lr_ != saved_lr_) {\n    eh_frame_writer_.AdvanceLocation(pc_offset);\n    if (initial_state->saved_lr_) {\n      eh_frame_writer_.RecordRegisterSavedToStack(lr, kSystemPointerSize);\n      eh_frame_writer_.RecordRegisterSavedToStack(fp, 0);\n    } else {\n      eh_frame_writer_.RecordRegisterFollowsInitialRule(lr);\n    }\n    saved_lr_ = initial_state->saved_lr_;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EndInstructionBlock\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Handles the end of an instruction block, propagating the saved LR status to successor blocks.\",\n            \"logic\": \"Iterates through the successors of the current block. For each successor, it checks if an initial state already exists. If it does, it verifies that the saved LR status is consistent. If not, it creates a new initial state with the current saved LR status and stores it for the successor block.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const InstructionBlock*\",\n                    \"purpose\": \"A pointer to the InstructionBlock object representing the current block.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionBlock\",\n                \"BlockInitialState\",\n                \"RpoNumber\",\n                \"zone_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::EndInstructionBlock(const InstructionBlock* block) {\n  if (!enabled() || block_will_exit_) return;\n\n  for (const RpoNumber& successor : block->successors()) {\n    int successor_index = successor.ToInt();\n    DCHECK_LT(successor_index, static_cast<int>(block_initial_states_.size()));\n    const BlockInitialState* existing_state =\n        block_initial_states_[successor_index];\n\n    // If we already had an entry for this BB, check that the values are the\n    // same we are trying to insert.\n    if (existing_state) {\n      DCHECK_EQ(existing_state->saved_lr_, saved_lr_);\n    } else {\n      block_initial_states_[successor_index] =\n          zone_->New<BlockInitialState>(saved_lr_);\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkFrameConstructed\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Marks the point in the code where a stack frame has been fully constructed.\",\n            \"logic\": \"Records that the LR and FP registers have been saved to the stack at specific offsets.  It then updates the `saved_lr_` flag to indicate the LR is saved.\",\n            \"parameters\": [\n                {\n                    \"name\": \"at_pc\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The program counter value where the frame construction is complete.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"eh_frame_writer_\",\n                \"lr\",\n                \"fp\",\n                \"kSystemPointerSize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::MarkFrameConstructed(int at_pc) {\n  if (!enabled()) return;\n\n  // Regardless of the type of frame constructed, the relevant part of the\n  // layout is always the one in the diagram:\n  //\n  // |   ....   |         higher addresses\n  // +----------+               ^\n  // |    LR    |               |            |\n  // +----------+               |            |\n  // | saved FP |               |            |\n  // +----------+ <-- FP                     v\n  // |   ....   |                       stack growth\n  //\n  // The LR is pushed on the stack, and we can record this fact at the end of\n  // the construction, since the LR itself is not modified in the process.\n  eh_frame_writer_.AdvanceLocation(at_pc);\n  eh_frame_writer_.RecordRegisterSavedToStack(lr, kSystemPointerSize);\n  eh_frame_writer_.RecordRegisterSavedToStack(fp, 0);\n  saved_lr_ = true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkFrameDeconstructed\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Marks the point in the code where a stack frame has been deconstructed (e.g., during a function return).\",\n            \"logic\": \"Records that the LR has been restored by setting it to follow the initial rule, indicating it's no longer saved on the stack. It also updates the `saved_lr_` flag.\",\n            \"parameters\": [\n                {\n                    \"name\": \"at_pc\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The program counter value where the frame deconstruction is complete.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"eh_frame_writer_\",\n                \"lr\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::MarkFrameDeconstructed(int at_pc) {\n  if (!enabled()) return;\n\n  // The lr is restored by the last operation in LeaveFrame().\n  eh_frame_writer_.AdvanceLocation(at_pc);\n  eh_frame_writer_.RecordRegisterFollowsInitialRule(lr);\n  saved_lr_ = false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkLinkRegisterOnTopOfStack\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Marks the location where the link register is placed on top of the stack.\",\n            \"logic\": \"Sets the base address register to the stack pointer (sp) with an offset of 0 and records that the link register is saved at offset 0 from the stack pointer.  The `sp` register is architecture specific.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pc_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The program counter offset.\"\n                },\n                {\n                    \"name\": \"sp\",\n                    \"type\": \"const Register&\",\n                    \"purpose\": \"The stack pointer register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"eh_frame_writer_\",\n                \"lr\",\n                \"Register\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::MarkLinkRegisterOnTopOfStack(int pc_offset,\n                                                       const Register& sp) {\n  if (!enabled()) return;\n\n  eh_frame_writer_.AdvanceLocation(pc_offset);\n  eh_frame_writer_.SetBaseAddressRegisterAndOffset(sp, 0);\n  eh_frame_writer_.RecordRegisterSavedToStack(lr, 0);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkPopLinkRegisterFromTopOfStack\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Marks the location where the link register is popped from the top of the stack.\",\n            \"logic\": \"Sets the base address register to the frame pointer (fp) with an offset of 0 and records that the link register follows the initial rule, meaning it's no longer saved on the stack at that location.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pc_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The program counter offset.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"eh_frame_writer_\",\n                \"lr\",\n                \"fp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid UnwindingInfoWriter::MarkPopLinkRegisterFromTopOfStack(int pc_offset) {\n  if (!enabled()) return;\n\n  eh_frame_writer_.AdvanceLocation(pc_offset);\n  eh_frame_writer_.SetBaseAddressRegisterAndOffset(fp, 0);\n  eh_frame_writer_.RecordRegisterFollowsInitialRule(lr);\n}\n        ]]></code>\n    </func>\n</file>\n```"
}