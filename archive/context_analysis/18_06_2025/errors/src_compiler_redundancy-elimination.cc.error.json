{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/redundancy-elimination.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/redundancy-elimination.cc\",\n            \"file_name\": \"redundancy-elimination.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements redundancy elimination optimization in the V8 compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for compiler components and data structures\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/redundancy-elimination.h\"\n\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RedundancyElimination\",\n                \"extends\": \"AdvancedReducer\",\n                \"about\": \"Performs redundancy elimination on the graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"node_checks_\",\n                        \"type\": \"ZoneMap<Node*, EffectPathChecks const*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps nodes to EffectPathChecks.\"\n                    },\n                    {\n                        \"name\": \"jsgraph_\",\n                        \"type\": \"JSGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSGraph object.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocations.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"JSGraph\",\n                    \"Zone\",\n                    \"Node\",\n                    \"EffectPathChecks\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass RedundancyElimination : public AdvancedReducer {\n public:\n  RedundancyElimination(Editor* editor, JSGraph* jsgraph, Zone* zone);\n  ~RedundancyElimination() override;\n\n  Reduction Reduce(Node* node) override;\n\n private:\n  ZoneMap<Node*, EffectPathChecks const*> node_checks_;\n  JSGraph* jsgraph_;\n  Zone* zone_;\n\n  Reduction ReduceCheckNode(Node* node);\n  Reduction ReduceEffectPhi(Node* node);\n  Reduction ReduceSpeculativeNumberComparison(Node* node);\n  Reduction ReduceSpeculativeNumberOperation(Node* node);\n  Reduction ReduceStart(Node* node);\n  Reduction ReduceOtherNode(Node* node);\n  Reduction TakeChecksFromFirstEffect(Node* node);\n  Reduction UpdateChecks(Node* node, EffectPathChecks const* checks);\n\n  class EffectPathChecks {\n   public:\n    // static\n    static EffectPathChecks* Copy(Zone* zone, EffectPathChecks const* checks);\n    // static\n    static EffectPathChecks const* Empty(Zone* zone);\n\n    bool Equals(EffectPathChecks const* that) const;\n    void Merge(EffectPathChecks const* that);\n    EffectPathChecks const* AddCheck(Zone* zone, Node* node) const;\n    Node* LookupCheck(Node* node, JSGraph* jsgraph) const;\n    Node* LookupBoundsCheckFor(Node* node) const;\n\n   private:\n    struct Check {\n      Check* next;\n      Node* node;\n      Check(Node* node, Check* next) : next(next), node(node) {}\n    };\n\n    Check* head_ = nullptr;\n    size_t size_ = 0;\n\n    EffectPathChecks(Check* head, size_t size) : head_(head), size_(size) {}\n  };\n\n  class PathChecksForEffectNodes {\n   public:\n    EffectPathChecks const* Get(Node* node) const;\n    void Set(Node* node, EffectPathChecks const* checks);\n\n   private:\n    ZoneVector<EffectPathChecks const*> info_for_node_;\n  };\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RedundancyElimination\",\n                \"parent\": \"RedundancyElimination\",\n                \"about\": \"Constructor for RedundancyElimination.\",\n                \"logic\": \"Initializes the RedundancyElimination object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"editor\",\n                        \"type\": \"Editor*\",\n                        \"purpose\": \"The graph editor.\"\n                    },\n                    {\n                        \"name\": \"jsgraph\",\n                        \"type\": \"JSGraph*\",\n                        \"purpose\": \"The JSGraph object.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"JSGraph\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nRedundancyElimination::RedundancyElimination(Editor* editor, JSGraph* jsgraph,\n                                             Zone* zone)\n    : AdvancedReducer(editor),\n      node_checks_(zone),\n      jsgraph_(jsgraph),\n      zone_(zone) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"~RedundancyElimination\",\n                \"parent\": \"RedundancyElimination\",\n                \"about\": \"Destructor for RedundancyElimination.\",\n                \"logic\": \"Default destructor.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nRedundancyElimination::~RedundancyElimination() = default;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reduce\",\n                \"parent\": \"RedundancyElimination\",\n                \"about\": \"Reduces a node in the graph, performing redundancy elimination.\",\n                \"logic\": \"Checks the opcode of the node and calls the appropriate reduction method.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The reduction result.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"NoChange\",\n                    \"ReduceCheckNode\",\n                    \"ReduceSpeculativeNumberComparison\",\n                    \"ReduceSpeculativeNumberOperation\",\n                    \"ReduceEffectPhi\",\n                    \"ReduceStart\",\n                    \"ReduceOtherNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction RedundancyElimination::Reduce(Node* node) {\n  if (node_checks_.Get(node)) return NoChange();\n  switch (node->opcode()) {\n    case IrOpcode::kCheckBigInt:\n    case IrOpcode::kCheckedBigIntToBigInt64:\n    case IrOpcode::kCheckBounds:\n    case IrOpcode::kCheckClosure:\n    case IrOpcode::kCheckEqualsInternalizedString:\n    case IrOpcode::kCheckEqualsSymbol:\n    case IrOpcode::kCheckFloat64Hole:\n    case IrOpcode::kCheckHeapObject:\n    case IrOpcode::kCheckIf:\n    case IrOpcode::kCheckInternalizedString:\n    case IrOpcode::kCheckNotTaggedHole:\n    case IrOpcode::kCheckNumber:\n    case IrOpcode::kCheckNumberFitsInt32:\n    case IrOpcode::kCheckReceiver:\n    case IrOpcode::kCheckReceiverOrNullOrUndefined:\n    case IrOpcode::kCheckSmi:\n    case IrOpcode::kCheckString:\n    case IrOpcode::kCheckStringOrStringWrapper:\n    case IrOpcode::kCheckSymbol:\n    // These are not really check nodes, but behave the same in that they can be\n    // folded together if repeated with identical inputs.\n    case IrOpcode::kStringCharCodeAt:\n    case IrOpcode::kStringCodePointAt:\n    case IrOpcode::kStringFromCodePointAt:\n    case IrOpcode::kStringSubstring:\n#define SIMPLIFIED_OP(Opcode) case IrOpcode::k##Opcode:\n      SIMPLIFIED_CHECKED_OP_LIST(SIMPLIFIED_OP)\n      SIMPLIFIED_BIGINT_BINOP_LIST(SIMPLIFIED_OP)\n#undef SIMPLIFIED_OP\n      return ReduceCheckNode(node);\n    case IrOpcode::kSpeculativeNumberEqual:\n    case IrOpcode::kSpeculativeNumberLessThan:\n    case IrOpcode::kSpeculativeNumberLessThanOrEqual:\n      return ReduceSpeculativeNumberComparison(node);\n    case IrOpcode::kSpeculativeNumberAdd:\n    case IrOpcode::kSpeculativeNumberSubtract:\n    case IrOpcode::kSpeculativeAdditiveSafeIntegerAdd:\n    case IrOpcode::kSpeculativeAdditiveSafeIntegerSubtract:\n    case IrOpcode::kSpeculativeSmallIntegerAdd:\n    case IrOpcode::kSpeculativeSmallIntegerSubtract:\n    case IrOpcode::kSpeculativeToNumber:\n      return ReduceSpeculativeNumberOperation(node);\n    case IrOpcode::kEffectPhi:\n      return ReduceEffectPhi(node);\n    case IrOpcode::kDead:\n      break;\n    case IrOpcode::kStart:\n      return ReduceStart(node);\n    default:\n      return ReduceOtherNode(node);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"EffectPathChecks\",\n                \"about\": \"Represents a list of checks along an effect path.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Node\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nRedundancyElimination::EffectPathChecks*\nRedundancyElimination::EffectPathChecks::Copy(Zone* zone,\n                                              EffectPathChecks const* checks) {\n  return zone->New<EffectPathChecks>(*checks);\n}\n        ]]></code>\n    </class>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Empty\",\n                \"parent\": \"EffectPathChecks\",\n                \"static\": true,\n                \"about\": \"Creates an empty EffectPathChecks object.\",\n                \"logic\": \"Allocates a new EffectPathChecks object with an empty check list.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"EffectPathChecks const*\",\n                    \"description\": \"A pointer to the newly created EffectPathChecks object.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"EffectPathChecks\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nRedundancyElimination::EffectPathChecks const*\nRedundancyElimination::EffectPathChecks::Empty(Zone* zone) {\n  return zone->New<EffectPathChecks>(nullptr, 0);\n}\n        ]]></code>\n    </func>\n            <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Equals\",\n                \"parent\": \"EffectPathChecks\",\n                \"about\": \"Checks if two EffectPathChecks objects are equal.\",\n                \"logic\": \"Compares the size and the check list of the two objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"that\",\n                        \"type\": \"EffectPathChecks const*\",\n                        \"purpose\": \"The EffectPathChecks object to compare with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the two objects are equal, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"EffectPathChecks\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool RedundancyElimination::EffectPathChecks::Equals(\n    EffectPathChecks const* that) const {\n  if (this->size_ != that->size_) return false;\n  Check* this_head = this->head_;\n  Check* that_head = that->head_;\n  while (this_head != that_head) {\n    if (this_head->node != that_head->node) return false;\n    this_head = this_head->next;\n    that_head = that_head->next;\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n            <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Merge\",\n                \"parent\": \"EffectPathChecks\",\n                \"about\": \"Merges two EffectPathChecks objects.\",\n                \"logic\": \"Changes the current check list to a longest common tail of this check list and the other list.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"that\",\n                        \"type\": \"EffectPathChecks const*\",\n                        \"purpose\": \"The EffectPathChecks object to merge with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"EffectPathChecks\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RedundancyElimination::EffectPathChecks::Merge(\n    EffectPathChecks const* that) {\n  // Change the current check list to a longest common tail of this check\n  // list and the other list.\n\n  // First, we throw away the prefix of the longer list, so that\n  // we have lists of the same length.\n  Check* that_head = that->head_;\n  size_t that_size = that->size_;\n  while (that_size > size_) {\n    that_head = that_head->next;\n    that_size--;\n  }\n  while (size_ > that_size) {\n    head_ = head_->next;\n    size_--;\n  }\n\n  // Then we go through both lists in lock-step until we find\n  // the common tail.\n  while (head_ != that_head) {\n    DCHECK_LT(0u, size_);\n    DCHECK_NOT_NULL(head_);\n    size_--;\n    head_ = head_->next;\n    that_head = that_head->next;\n  }\n}\n        ]]></code>\n    </func>\n            <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddCheck\",\n                \"parent\": \"EffectPathChecks\",\n                \"about\": \"Adds a check to the EffectPathChecks object.\",\n                \"logic\": \"Creates a new check and adds it to the head of the check list.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to add as a check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"EffectPathChecks const*\",\n                    \"description\": \"A pointer to the newly created EffectPathChecks object.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"Node\",\n                    \"EffectPathChecks\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nRedundancyElimination::EffectPathChecks const*\nRedundancyElimination::EffectPathChecks::AddCheck(Zone* zone,\n                                                  Node* node) const {\n  Check* head = zone->New<Check>(node, head_);\n  return zone->New<EffectPathChecks>(head, size_ + 1);\n}\n        ]]></code>\n    </func>\n            <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LookupCheck\",\n                \"parent\": \"EffectPathChecks\",\n                \"about\": \"Looks up a check in the EffectPathChecks object.\",\n                \"logic\": \"Iterates through the check list and checks if any of the existing checks subsumes the given node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to lookup.\"\n                    },\n                    {\n                        \"name\": \"jsgraph\",\n                        \"type\": \"JSGraph*\",\n                        \"purpose\": \"The JSGraph object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The node that subsumes the given node, or nullptr if no such node exists.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"JSGraph\",\n                    \"CheckSubsumes\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nstruct Subsumption {\n  enum class Kind {\n    kNone,\n    kImplicit,\n    kWithConversion,\n  };\n\n  static Subsumption None() { return Subsumption(Kind::kNone, nullptr); }\n  static Subsumption Implicit() {\n    return Subsumption(Kind::kImplicit, nullptr);\n  }\n  static Subsumption WithConversion(const Operator* conversion_op) {\n    return Subsumption(Kind::kWithConversion, conversion_op);\n  }\n\n  bool IsNone() const { return kind_ == Kind::kNone; }\n  bool IsImplicit() const { return kind_ == Kind::kImplicit; }\n  bool IsWithConversion() const { return kind_ == Kind::kWithConversion; }\n  const Operator* conversion_operator() const {\n    DCHECK(IsWithConversion());\n    return conversion_op_;\n  }\n\n private:\n  Subsumption(Kind kind, const Operator* conversion_op)\n      : kind_(kind), conversion_op_(conversion_op) {\n    DCHECK_EQ(kind_ == Kind::kWithConversion, conversion_op_ != nullptr);\n  }\n\n  Kind kind_;\n  const Operator* conversion_op_;\n};\n\n// Does check {a} subsume check {b}?\nSubsumption CheckSubsumes(Node const* a, Node const* b,\n                          MachineOperatorBuilder* machine) {\n  Subsumption subsumption = Subsumption::Implicit();\n  if (a->op() != b->op()) {\n    if (a->opcode() == IrOpcode::kCheckInternalizedString &&\n        b->opcode() == IrOpcode::kCheckString) {\n      // CheckInternalizedString(node) implies CheckString(node)\n    } else if (a->opcode() == IrOpcode::kCheckString &&\n               b->opcode() == IrOpcode::kCheckStringOrStringWrapper) {\n      // CheckString(node) implies CheckStringOrStringWrapper(node)\n    } else if (a->opcode() == IrOpcode::kCheckInternalizedString &&\n               b->opcode() == IrOpcode::kCheckStringOrStringWrapper) {\n      // CheckInteralizedString(node) implies CheckStringOrStringWrapper(node)\n    } else if (a->opcode() == IrOpcode::kCheckSmi &&\n               b->opcode() == IrOpcode::kCheckNumber) {\n      // CheckSmi(node) implies CheckNumber(node)\n    } else if (a->opcode() == IrOpcode::kCheckSmi &&\n               b->opcode() == IrOpcode::kCheckNumberFitsInt32) {\n      // CheckSmi(node) implies CheckNumberFitsInt32(node)\n    } else if (a->opcode() == IrOpcode::kCheckNumberFitsInt32 &&\n               b->opcode() == IrOpcode::kCheckNumber) {\n      // CheckNumberFitsInt32(node) implies CheckNumber(node)\n    } else if (a->opcode() == IrOpcode::kCheckedTaggedSignedToInt32 &&\n               b->opcode() == IrOpcode::kCheckedTaggedToInt32) {\n      // CheckedTaggedSignedToInt32(node) implies CheckedTaggedToInt32(node)\n    } else if (a->opcode() == IrOpcode::kCheckedTaggedSignedToInt32 &&\n               b->opcode() == IrOpcode::kCheckedTaggedToArrayIndex) {\n      // CheckedTaggedSignedToInt32(node) implies\n      // CheckedTaggedToArrayIndex(node)\n      if (machine->Is64()) {\n        // On 64 bit architectures, ArrayIndex is 64 bit.\n        subsumption =\n            Subsumption::WithConversion(machine->ChangeInt32ToInt64());\n      }\n    } else if (a->opcode() == IrOpcode::kCheckedTaggedToInt32 &&\n               b->opcode() == IrOpcode::kCheckedTaggedToArrayIndex) {\n      // CheckedTaggedToInt32(node) implies CheckedTaggedToArrayIndex(node)\n      if (machine->Is64()) {\n        // On 64 bit architectures, ArrayIndex is 64 bit.\n        subsumption =\n            Subsumption::WithConversion(machine->ChangeInt32ToInt64());\n      }\n    } else if (a->opcode() == IrOpcode::kCheckReceiver &&\n               b->opcode() == IrOpcode::kCheckReceiverOrNullOrUndefined) {\n      // CheckReceiver(node) implies CheckReceiverOrNullOrUndefined(node)\n    } else if (a->opcode() != b->opcode()) {\n      return Subsumption::None();\n    } else {\n      switch (a->opcode()) {\n        case IrOpcode::kCheckBounds:\n        case IrOpcode::kCheckSmi:\n        case IrOpcode::kCheckString:\n        case IrOpcode::kCheckStringOrStringWrapper:\n        case IrOpcode::kCheckNumber:\n        case IrOpcode::kCheckNumberFitsInt32:\n        case IrOpcode::kCheckBigInt:\n        case IrOpcode::kCheckedBigIntToBigInt64:\n          break;\n        case IrOpcode::kCheckedInt32ToTaggedSigned:\n        case IrOpcode::kCheckedInt64ToInt32:\n        case IrOpcode::kCheckedInt64ToTaggedSigned:\n        case IrOpcode::kCheckedTaggedSignedToInt32:\n        case IrOpcode::kCheckedTaggedToTaggedPointer:\n        case IrOpcode::kCheckedTaggedToTaggedSigned:\n        case IrOpcode::kCheckedTaggedToArrayIndex:\n        case IrOpcode::kCheckedUint32Bounds:\n        case IrOpcode::kCheckedUint32ToInt32:\n        case IrOpcode::kCheckedUint32ToTaggedSigned:\n        case IrOpcode::kCheckedUint64Bounds:\n        case IrOpcode::kCheckedUint64ToInt32:\n        case IrOpcode::kCheckedUint64ToTaggedSigned:\n          break;\n        case IrOpcode::kCheckedFloat64ToInt32:\n        case IrOpcode::kCheckedFloat64ToAdditiveSafeInteger:\n        case IrOpcode::kCheckedFloat64ToInt64:\n        case IrOpcode::kCheckedTaggedToInt32:\n        case IrOpcode::kCheckedTaggedToAdditiveSafeInteger:\n        case IrOpcode::kCheckedTaggedToInt64: {\n          const CheckMinusZeroParameters& ap =\n              CheckMinusZeroParametersOf(a->op());\n          const CheckMinusZeroParameters& bp =\n              CheckMinusZeroParametersOf(b->op());\n          if (ap.mode() != bp.mode()) {\n            return Subsumption::None();\n          }\n          break;\n        }\n        case IrOpcode::kCheckedTaggedToFloat64:\n        case IrOpcode::kCheckedTruncateTaggedToWord32: {\n          CheckTaggedInputParameters const& ap =\n              CheckTaggedInputParametersOf(a->op());\n          CheckTaggedInputParameters const& bp =\n              CheckTaggedInputParametersOf(b->op());\n          // {a} subsumes {b} if the modes are either the same, or {a} checks\n          // for Number, in which case {b} will be subsumed no matter what.\n          if (ap.mode() != bp.mode() &&\n              ap.mode() != CheckTaggedInputMode::kNumber) {\n            return Subsumption::None();\n          }\n          break;\n        }\n        default:\n          DCHECK(!IsCheckedWithFeedback(a->op()));\n          return Subsumption::None();\n      }\n    }\n  }\n  for (int i = a->op()->ValueInputCount(); --i >= 0;) {\n    if (a->InputAt(i) != b->InputAt(i)) return Subsumption::None();\n  }\n  return subsumption;\n}\n\nbool TypeSubsumes(Node* node, Node* replacement) {\n  if (!NodeProperties::IsTyped(node) || !NodeProperties::IsTyped(replacement)) {\n    // If either node is untyped, we are running during an untyped optimization\n    // phase, and replacement is OK.\n    return true;\n  }\n  Type node_type = NodeProperties::GetType(node);\n  Type replacement_type = NodeProperties::GetType(replacement);\n  return replacement_type.Is(node_type);\n}\n\n}  // namespace\n\nNode* RedundancyElimination::EffectPathChecks::LookupCheck(\n    Node* node, JSGraph* jsgraph) const {\n  for (Check const* check = head_; check != nullptr; check = check->next) {\n    Subsumption subsumption =\n        CheckSubsumes(check->node, node, jsgraph->machine());\n    if (!subsumption.IsNone() && TypeSubsumes(node, check->node)) {\n      DCHECK(!check->node->IsDead());\n      Node* result = check->node;\n      if (subsumption.IsWithConversion()) {\n        result = jsgraph->graph()->NewNode(subsumption.conversion_operator(),\n                                           result);\n      }\n      return result;\n    }\n  }\n  return nullptr;\n}\n        ]]></code>\n    </func>\n            <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LookupBoundsCheckFor\",\n                \"parent\": \"EffectPathChecks\",\n                \"about\": \"Looks up a bounds check for a given node in the EffectPathChecks object.\",\n                \"logic\": \"Iterates through the check list and checks if any of the existing checks is a bounds check for the given node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to lookup.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The bounds check node, or nullptr if no such node exists.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"CheckBoundsParametersOf\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* RedundancyElimination::EffectPathChecks::LookupBoundsCheckFor(\n    Node* node) const {\n  for (Check const* check = head_; check != nullptr; check = check->next) {\n    if (check->node->opcode() == IrOpcode::kCheckBounds &&\n        check->node->InputAt(0) == node && TypeSubsumes(node, check->node) &&\n        !(CheckBoundsParametersOf(check->node->op()).flags() &\n          CheckBoundsFlag::kConvertStringAndMinusZero)) {\n      return check->node;\n    }\n  }\n  return nullptr;\n}\n        ]]></code>\n    </func>\n            <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PathChecksForEffectNodes\",\n                \"about\": \"Maps effect nodes to their corresponding EffectPathChecks.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Node\",\n                    \"EffectPathChecks\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nRedundancyElimination::EffectPathChecks const*\nRedundancyElimination::PathChecksForEffectNodes::Get(Node* node) const {\n  size_t const id = node->id();\n  if (id < info_for_node_.size()) return info_for_node_[id];\n  return nullptr;\n}\n        ]]></code>\n    </class>\n                <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Set\",\n                \"parent\": \"PathChecksForEffectNodes\",\n                \"about\": \"Sets the EffectPathChecks for a given effect node.\",\n                \"logic\": \"Stores the EffectPathChecks object in a vector, using the node ID as the index.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The effect node.\"\n                    },\n                    {\n                        \"name\": \"checks\",\n                        \"type\": \"EffectPathChecks const*\",\n                        \"purpose\": \"The EffectPathChecks object to store.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"EffectPathChecks\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RedundancyElimination::PathChecksForEffectNodes::Set(\n    Node* node, EffectPathChecks const* checks) {\n  size_t const id = node->id();\n  if (id >= info_for_node_.size()) info_for_node_.resize(id + 1, nullptr);\n  info_for_node_[id] = checks;\n}\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceCheckNode\",\n                \"parent\": \"RedundancyElimination\",\n                \"about\": \"Reduces a check node in the graph.\",\n                \"logic\": \"Looks up existing checks for the effect input of the node and checks if any of them subsumes the current node. If so, replaces the current node with the subsuming node. Otherwise, adds the current node to the list of checks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The check node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The reduction result.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"EffectPathChecks\",\n                    \"LookupCheck\",\n                    \"UpdateChecks\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction RedundancyElimination::ReduceCheckNode(Node* node) {\n  Node* const effect = NodeProperties::GetEffectInput(node);\n  EffectPathChecks const* checks = node_checks_.Get(effect);\n  // If we do not know anything about the predecessor, do not propagate just yet\n  // because we will have to recompute anyway once we compute the predecessor.\n  if (checks == nullptr) return NoChange();\n  // See if we have another check that dominates us.\n  if (Node* check = checks->LookupCheck(node, jsgraph_)) {\n    ReplaceWithValue(node, check);\n    return Replace(check);\n  }\n\n  // Learn from this check.\n  return UpdateChecks(node, checks->AddCheck(zone(), node));\n}\n        ]]></code>\n    </func>\n            <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceEffectPhi\",\n                \"parent\": \"RedundancyElimination\",\n                \"about\": \"Reduces an effect phi node in the graph.\",\n                \"logic\": \"Merges the effect path checks from all input effects into a single EffectPathChecks object and updates the checks for the current node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The effect phi node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The reduction result.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"EffectPathChecks\",\n                    \"UpdateChecks\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction RedundancyElimination::ReduceEffectPhi(Node* node) {\n  Node* const control = NodeProperties::GetControlInput(node);\n  if (control->opcode() == IrOpcode::kLoop) {\n    // Here we rely on having only reducible loops:\n    // The loop entry edge always dominates the header, so we can just use\n    // the information from the loop entry edge.\n    return TakeChecksFromFirstEffect(node);\n  }\n  DCHECK_EQ(IrOpcode::kMerge, control->opcode());\n\n  // Shortcut for the case when we do not know anything about some input.\n  int const input_count = node->op()->EffectInputCount();\n  for (int i = 0; i < input_count; ++i) {\n    Node* const effect = NodeProperties::GetEffectInput(node, i);\n    if (node_checks_.Get(effect) == nullptr) return NoChange();\n  }\n\n  // Make a copy of the first input's checks and merge with the checks\n  // from other inputs.\n  EffectPathChecks* checks = EffectPathChecks::Copy(\n      zone(), node_checks_.Get(NodeProperties::GetEffectInput(node, 0)));\n  for (int i = 1; i < input_count; ++i) {\n    Node* const input = NodeProperties::GetEffectInput(node, i);\n    checks->Merge(node_checks_.Get(input));\n  }\n  return UpdateChecks(node, checks);\n}\n"
}