{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/fast-api-call-lowering-reducer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/fast-api-call-lowering-reducer.h\",\n        \"file_name\": \"fast-api-call-lowering-reducer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines a Turboshaft reducer that lowers Fast API calls into lower-level operations.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for V8 Fast API calls, compiler globals, Turboshaft assembler, copying phase, index, operations, phase, and representations.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"include/v8-fast-api-calls.h\"\n#include \"src/compiler/fast-api-calls.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/copying-phase.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FastApiCallLoweringReducer\",\n            \"about\": \"A Turboshaft reducer that transforms FastApiCall operations into lower-level code, adapting arguments, calling C functions, and handling return values and exceptions.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Next\",\n                \"FastApiCallParameters\",\n                \"FastApiCallFunction\",\n                \"CTypeInfo\",\n                \"TSCallDescriptor\",\n                \"Label\",\n                \"Variable\",\n                \"ExternalReference\",\n                \"MachineSignature\",\n                \"MachineType\",\n                \"Isolate\",\n                \"Factory\",\n                \"Context\",\n                \"base::Vector\",\n                \"base::SmallVector\",\n                \"V\",\n                \"FrameState\",\n                \"Object\",\n                \"Word32\",\n                \"Any\",\n                \"Tuple\",\n                \"Float64\",\n                \"HeapObject\",\n                \"Map\",\n                \"WordPtr\",\n                \"FixedArray\",\n                \"JSExternalObject\",\n                \"Uninitialized\",\n                \"AccessBuilder\",\n                \"IsolateFieldId\",\n                \"CallDescriptor\",\n                \"RuntimeCallDescriptor\",\n                \"Linkage\",\n                \"JS_ARRAY_TYPE\",\n                \"kStringRepresentationAndEncodingMask\",\n                \"FastOneByteString\",\n                \"MemoryRepresentation\",\n                \"FastApiCallbackOptions\",\n                \"CallRuntime\",\n                \"TaggedEqual\",\n                \"ObjectIsSmi\",\n                \"Word32Equal\",\n                \"WordPtrEqual\",\n                \"Float64LessThan\",\n                \"Float64IsNaN\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Next>\nclass FastApiCallLoweringReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(FastApiCallLowering)\n\n  OpIndex REDUCE(FastApiCall)(\n      V<FrameState> frame_state, V<Object> data_argument, V<Context> context,\n      base::Vector<const OpIndex> arguments,\n      const FastApiCallParameters* parameters,\n      base::Vector<const RegisterRepresentation> out_reps) {\n    __ data() -> set_graph_has_lowered_fast_api_calls();\n\n    FastApiCallFunction c_function = parameters->c_function;\n    const auto& c_signature = parameters->c_signature();\n    const int c_arg_count = c_signature->ArgumentCount();\n    DCHECK_EQ(c_arg_count, arguments.size());\n\n    Label<> handle_error(this);\n    Label<Word32> done(this);\n    Variable result = __ NewVariable(RegisterRepresentation::FromCTypeInfo(\n        c_signature->ReturnInfo(), c_signature->GetInt64Representation()));\n\n    OpIndex callee = __ ExternalConstant(ExternalReference::Create(\n        c_function.address, ExternalReference::FAST_C_CALL));\n\n    base::SmallVector<OpIndex, 16> args;\n    for (int i = 0; i < c_arg_count; ++i) {\n        CTypeInfo type = c_signature->ArgumentInfo(i);\n        args.push_back(AdaptFastCallArgument(arguments[i], type, handle_error));\n    }\n\n    // While adapting the arguments, we might have noticed an inconsistency that\n    // lead to unconditionally jumping to {handle_error}. If this happens, then\n    // we don't emit the call.\n    if (V8_LIKELY(!__ generating_unreachable_operations())) {\n      MachineSignature::Builder builder(\n          __ graph_zone(), 1,\n          c_arg_count + (c_signature->HasOptions() ? 1 : 0));\n\n      builder.AddReturn(MachineType::TypeForCType(c_signature->ReturnInfo()));\n\n      for (int i = 0; i < c_arg_count; ++i) {\n        CTypeInfo type = c_signature->ArgumentInfo(i);\n        START_ALLOW_USE_DEPRECATED()\n        MachineType machine_type =\n            type.GetSequenceType() == CTypeInfo::SequenceType::kScalar\n                ? MachineType::TypeForCType(type)\n                : MachineType::AnyTagged();\n        END_ALLOW_USE_DEPRECATED()\n        builder.AddParam(machine_type);\n      }\n\n      OpIndex stack_slot;\n      if (c_signature->HasOptions()) {\n        const int kAlign = alignof(v8::FastApiCallbackOptions);\n        const int kSize = sizeof(v8::FastApiCallbackOptions);\n        // If this check fails, you've probably added new fields to\n        // v8::FastApiCallbackOptions, which means you'll need to write code\n        // that initializes and reads from them too.\n        static_assert(kSize == sizeof(uintptr_t) * 2);\n        stack_slot = __ StackSlot(kSize, kAlign);\n\n        // isolate\n        __ StoreOffHeap(\n            stack_slot,\n            __ ExternalConstant(ExternalReference::isolate_address()),\n            MemoryRepresentation::UintPtr(),\n            offsetof(v8::FastApiCallbackOptions, isolate));\n        // data = data_argument\n        OpIndex data_argument_to_pass = __ AdaptLocalArgument(data_argument);\n        __ StoreOffHeap(stack_slot, data_argument_to_pass,\n                        MemoryRepresentation::UintPtr(),\n                        offsetof(v8::FastApiCallbackOptions, data));\n\n        args.push_back(stack_slot);\n        builder.AddParam(MachineType::Pointer());\n      }\n\n      // Build the actual call.\n      const TSCallDescriptor* call_descriptor = TSCallDescriptor::Create(\n          Linkage::GetSimplifiedCDescriptor(__ graph_zone(), builder.Get(),\n                                            CallDescriptor::kNeedsFrameState),\n          CanThrow::kNo, LazyDeoptOnThrow::kNo, __ graph_zone());\n      OpIndex c_call_result = WrapFastCall(call_descriptor, callee, frame_state,\n                                           context, base::VectorOf(args));\n\n      Label<> trigger_exception(this);\n\n      V<Object> exception =\n          __ Load(__ ExternalConstant(ExternalReference::Create(\n                      IsolateAddressId::kExceptionAddress, isolate_)),\n                  LoadOp::Kind::RawAligned(), MemoryRepresentation::UintPtr());\n      GOTO_IF_NOT(LIKELY(__ TaggedEqual(\n                      exception,\n                      __ HeapConstant(isolate_->factory()->the_hole_value()))),\n                  trigger_exception);\n\n      V<Any> fast_call_result = ConvertReturnValue(c_signature, c_call_result);\n      __ SetVariable(result, fast_call_result);\n\n      GOTO(done, FastApiCallOp::kSuccessValue);\n      BIND(trigger_exception);\n      __ template CallRuntime<\n          typename RuntimeCallDescriptor::PropagateException>(\n          isolate_, frame_state, __ NoContextConstant(), LazyDeoptOnThrow::kNo,\n          {});\n\n      __ Unreachable();\n    }\n\n    if (BIND(handle_error)) {\n      __ SetVariable(result, DefaultReturnValue(c_signature));\n      // We pass Tagged<Smi>(0) as the value here, although this should never be\n      // visible when calling code reacts to `kFailureValue` properly.\n      GOTO(done, FastApiCallOp::kFailureValue);\n    }\n\n    BIND(done, state);\n    return __ Tuple(state, __ GetVariable(result));\n  }\n\n private:\n  template <typename T>\n  V<T> Checked(V<Tuple<T, Word32>> result, Label<>& otherwise) {\n    V<Word32> result_state = __ template Projection<1>(result);\n    GOTO_IF_NOT(__ Word32Equal(result_state, TryChangeOp::kSuccessValue),\n                otherwise);\n    return __ template Projection<0>(result);\n  }\n\n  OpIndex AdaptFastCallArgument(OpIndex argument, CTypeInfo arg_type,\n                                Label<>& handle_error) {\n    START_ALLOW_USE_DEPRECATED()\n    switch (arg_type.GetSequenceType()) {\n      case CTypeInfo::SequenceType::kScalar: {\n        uint8_t flags = static_cast<uint8_t>(arg_type.GetFlags());\n        if (flags & static_cast<uint8_t>(CTypeInfo::Flags::kEnforceRangeBit)) {\n          switch (arg_type.GetType()) {\n            case CTypeInfo::Type::kInt32: {\n              auto result = __ TryTruncateFloat64ToInt32(argument);\n              return Checked(result, handle_error);\n            }\n            case CTypeInfo::Type::kUint32: {\n              auto result = __ TryTruncateFloat64ToUint32(argument);\n              return Checked(result, handle_error);\n            }\n            case CTypeInfo::Type::kInt64: {\n              auto result = __ TryTruncateFloat64ToInt64(argument);\n              return Checked(result, handle_error);\n            }\n            case CTypeInfo::Type::kUint64: {\n              auto result = __ TryTruncateFloat64ToUint64(argument);\n              return Checked(result, handle_error);\n            }\n            default: {\n              GOTO(handle_error);\n              return argument;\n            }\n          }\n        } else if (flags & static_cast<uint8_t>(CTypeInfo::Flags::kClampBit)) {\n          return ClampFastCallArgument(argument, arg_type.GetType());\n        } else {\n          switch (arg_type.GetType()) {\n            case CTypeInfo::Type::kV8Value: {\n              return __ AdaptLocalArgument(argument);\n            }\n            case CTypeInfo::Type::kFloat32: {\n              return __ TruncateFloat64ToFloat32(argument);\n            }\n            case CTypeInfo::Type::kPointer: {\n              // Check that the value is a HeapObject.\n              GOTO_IF(__ ObjectIsSmi(argument), handle_error);\n              Label<WordPtr> done(this);\n\n              // Check if the value is null.\n              GOTO_IF(UNLIKELY(__ TaggedEqual(\n                          argument, __ HeapConstant(factory_->null_value()))),\n                      done, 0);\n\n              // Check that the value is a JSExternalObject.\n              GOTO_IF_NOT(\n                  __ TaggedEqual(__ LoadMapField(argument),\n                                 __ HeapConstant(factory_->external_map())),\n                  handle_error);\n\n              GOTO(done, __ template LoadField<WordPtr>(\n                             V<HeapObject>::Cast(argument),\n                             AccessBuilder::ForJSExternalObjectValue()));\n\n              BIND(done, result);\n              return result;\n            }\n            case CTypeInfo::Type::kSeqOneByteString: {\n              // Check that the value is a HeapObject.\n              GOTO_IF(__ ObjectIsSmi(argument), handle_error);\n              V<HeapObject> argument_obj = V<HeapObject>::Cast(argument);\n\n              V<Map> map = __ LoadMapField(argument_obj);\n              V<Word32> instance_type = __ LoadInstanceTypeField(map);\n\n              V<Word32> encoding = __ Word32BitwiseAnd(\n                  instance_type, kStringRepresentationAndEncodingMask);\n              GOTO_IF_NOT(__ Word32Equal(encoding, kSeqOneByteStringTag),\n                          handle_error);\n\n              V<WordPtr> length_in_bytes = __ template LoadField<WordPtr>(\n                  argument_obj, AccessBuilder::ForStringLength());\n              V<WordPtr> data_ptr = __ GetElementStartPointer(\n                  argument_obj, AccessBuilder::ForSeqOneByteStringCharacter());\n\n              constexpr int kAlign = alignof(FastOneByteString);\n              constexpr int kSize = sizeof(FastOneByteString);\n              static_assert(kSize == sizeof(uintptr_t) + sizeof(size_t),\n                            \"The size of \"\n                            \"FastOneByteString isn't equal to the sum of its \"\n                            \"expected members.\");\n              OpIndex stack_slot = __ StackSlot(kSize, kAlign);\n              __ StoreOffHeap(stack_slot, data_ptr,\n                              MemoryRepresentation::UintPtr());\n              __ StoreOffHeap(stack_slot, length_in_bytes,\n                              MemoryRepresentation::Uint32(), sizeof(size_t));\n              static_assert(sizeof(uintptr_t) == sizeof(size_t),\n                            \"The string length can't \"\n                            \"fit the PointerRepresentation used to store it.\");\n              return stack_slot;\n            }\n            default: {\n              return argument;\n            }\n          }\n        }\n      }\n      case CTypeInfo::SequenceType::kIsSequence: {\n        CHECK_EQ(arg_type.GetType(), CTypeInfo::Type::kVoid);\n\n        // Check that the value is a HeapObject.\n        GOTO_IF(__ ObjectIsSmi(argument), handle_error);\n\n        // Check that the value is a JSArray.\n        V<Map> map = __ LoadMapField(argument);\n        V<Word32> instance_type = __ LoadInstanceTypeField(map);\n        GOTO_IF_NOT(__ Word32Equal(instance_type, JS_ARRAY_TYPE), handle_error);\n\n        return __ AdaptLocalArgument(argument);\n      }\n      default: {\n        UNREACHABLE();\n      }\n    }\n    END_ALLOW_USE_DEPRECATED()\n  }\n\n  OpIndex ClampFastCallArgument(V<Float64> argument,\n                                CTypeInfo::Type scalar_type) {\n    double min, max;\n    switch (scalar_type) {\n      case CTypeInfo::Type::kInt32:\n        min = std::numeric_limits<int32_t>::min();\n        max = std::numeric_limits<int32_t>::max();\n        break;\n      case CTypeInfo::Type::kUint32:\n        min = 0;\n        max = std::numeric_limits<uint32_t>::max();\n        break;\n      case CTypeInfo::Type::kInt64:\n        min = kMinSafeInteger;\n        max = kMaxSafeInteger;\n        break;\n      case CTypeInfo::Type::kUint64:\n        min = 0;\n        max = kMaxSafeInteger;\n        break;\n      default:\n        UNREACHABLE();\n    }\n\n    V<Float64> clamped =\n        __ Conditional(__ Float64LessThan(min, argument),\n                       __ Conditional(__ Float64LessThan(argument, max),\n                                      argument, __ Float64Constant(max)),\n                       __ Float64Constant(min));\n\n    Label<Float64> done(this);\n    V<Float64> rounded = __ Float64RoundTiesEven(clamped);\n    GOTO_IF(__ Float64IsNaN(rounded), done, 0.0);\n    GOTO(done, rounded);\n\n    BIND(done, rounded_result);\n    switch (scalar_type) {\n      case CTypeInfo::Type::kInt32:\n        return __ ReversibleFloat64ToInt32(rounded_result);\n      case CTypeInfo::Type::kUint32:\n        return __ ReversibleFloat64ToUint32(rounded_result);\n      case CTypeInfo::Type::kInt64:\n        return __ ReversibleFloat64ToInt64(rounded_result);\n      case CTypeInfo::Type::kUint64:\n        return __ ReversibleFloat64ToUint64(rounded_result);\n      default:\n        UNREACHABLE();\n    }\n  }\n\n  V<Any> DefaultReturnValue(const CFunctionInfo* c_signature) {\n    switch (c_signature->ReturnInfo().GetType()) {\n      case CTypeInfo::Type::kVoid:\n        return __ HeapConstant(factory_->undefined_value());\n      case CTypeInfo::Type::kBool:\n      case CTypeInfo::Type::kInt32:\n      case CTypeInfo::Type::kUint32:\n        return __ Word32Constant(0);\n      case CTypeInfo::Type::kInt64:\n      case CTypeInfo::Type::kUint64: {\n        CFunctionInfo::Int64Representation repr =\n            c_signature->GetInt64Representation();\n        if (repr == CFunctionInfo::Int64Representation::kBigInt) {\n          return __ Word64Constant(int64_t{0});\n        }\n        DCHECK_EQ(repr, CFunctionInfo::Int64Representation::kNumber);\n        return __ Float64Constant(0);\n      }\n      case CTypeInfo::Type::kFloat32:\n        return __ Float32Constant(0);\n      case CTypeInfo::Type::kFloat64:\n        return __ Float64Constant(0);\n      case CTypeInfo::Type::kPointer:\n        return __ HeapConstant(factory_->undefined_value());\n      case CTypeInfo::Type::kAny:\n      case CTypeInfo::Type::kSeqOneByteString:\n      case CTypeInfo::Type::kV8Value:\n      case CTypeInfo::Type::kApiObject:\n      case CTypeInfo::Type::kUint8:\n        UNREACHABLE();\n    }\n  }\n\n  V<Any> ConvertReturnValue(const CFunctionInfo* c_signature, OpIndex result) {\n    switch (c_signature->ReturnInfo().GetType()) {\n      case CTypeInfo::Type::kVoid:\n        return __ HeapConstant(factory_->undefined_value());\n      case CTypeInfo::Type::kBool:\n        static_assert(sizeof(bool) == 1, \"unsupported bool size\");\n        return __ Word32BitwiseAnd(result, __ Word32Constant(0xFF));\n      case CTypeInfo::Type::kInt32:\n      case CTypeInfo::Type::kUint32:\n      case CTypeInfo::Type::kFloat32:\n      case CTypeInfo::Type::kFloat64:\n        return result;\n      case CTypeInfo::Type::kInt64: {\n        CFunctionInfo::Int64Representation repr =\n            c_signature->GetInt64Representation();\n        if (repr == CFunctionInfo::Int64Representation::kBigInt) {\n          return result;\n        }\n        DCHECK_EQ(repr, CFunctionInfo::Int64Representation::kNumber);\n        return __ ChangeInt64ToFloat64(result);\n      }\n      case CTypeInfo::Type::kUint64: {\n        CFunctionInfo::Int64Representation repr =\n            c_signature->GetInt64Representation();\n        if (repr == CFunctionInfo::Int64Representation::kBigInt) {\n          return result;\n        }\n        DCHECK_EQ(repr, CFunctionInfo::Int64Representation::kNumber);\n        return __ ChangeUint64ToFloat64(result);\n      }\n\n      case CTypeInfo::Type::kPointer:\n        return BuildAllocateJSExternalObject(result);\n      case CTypeInfo::Type::kAny:\n      case CTypeInfo::Type::kSeqOneByteString:\n      case CTypeInfo::Type::kV8Value:\n      case CTypeInfo::Type::kApiObject:\n      case CTypeInfo::Type::kUint8:\n        UNREACHABLE();\n    }\n  }\n\n  V<HeapObject> BuildAllocateJSExternalObject(V<WordPtr> pointer) {\n    Label<HeapObject> done(this);\n\n    // Check if the pointer is a null pointer.\n    GOTO_IF(__ WordPtrEqual(pointer, 0), done,\n            __ HeapConstant(factory_->null_value()));\n\n    Uninitialized<HeapObject> external =\n        __ Allocate(JSExternalObject::kHeaderSize, AllocationType::kYoung);\n    __ InitializeField(external, AccessBuilder::ForMap(),\n                       __ HeapConstant(factory_->external_map()));\n    V<FixedArray> empty_fixed_array =\n        __ HeapConstant(factory_->empty_fixed_array());\n    __ InitializeField(external, AccessBuilder::ForJSObjectPropertiesOrHash(),\n                       empty_fixed_array);\n    __ InitializeField(external, AccessBuilder::ForJSObjectElements(),\n                       empty_fixed_array);\n\n#ifdef V8_ENABLE_SANDBOX\n    OpIndex isolate_ptr =\n        __ ExternalConstant(ExternalReference::isolate_address());\n    MachineSignature::Builder builder(__ graph_zone(), 1, 2);\n    builder.AddReturn(MachineType::Uint32());\n    builder.AddParam(MachineType::Pointer());\n    builder.AddParam(MachineType::Pointer());\n    OpIndex allocate_and_initialize_young_external_pointer_table_entry =\n        __ ExternalConstant(\n            ExternalReference::\n                allocate_and_initialize_young_external_pointer_table_entry());\n    auto call_descriptor =\n        Linkage::GetSimplifiedCDescriptor(__ graph_zone(), builder.Get());\n    OpIndex handle = __ Call(\n        allocate_and_initialize_young_external_pointer_table_entry,\n        {isolate_ptr, pointer},\n        TSCallDescriptor::Create(call_descriptor, CanThrow::kNo,\n                                 LazyDeoptOnThrow::kNo, __ graph_zone()));\n    __ InitializeField(\n        external, AccessBuilder::ForJSExternalObjectPointerHandle(), handle);\n#else\n    __ InitializeField(external, AccessBuilder::ForJSExternalObjectValue(),\n                       pointer);\n#endif  // V8_ENABLE_SANDBOX\n    GOTO(done, __ FinishInitialization(std::move(external)));\n\n    BIND(done, result);\n    return result;\n  }\n\n  OpIndex WrapFastCall(const TSCallDescriptor* descriptor, OpIndex callee,\n                       V<FrameState> frame_state, V<Context> context,\n                       base::Vector<const OpIndex> arguments) {\n    // CPU profiler support.\n    OpIndex target_address =\n        __ IsolateField(IsolateFieldId::kFastApiCallTarget);\n    __ StoreOffHeap(target_address, __ BitcastHeapObjectToWordPtr(callee),\n                    MemoryRepresentation::UintPtr());\n\n    OpIndex context_address = __ ExternalConstant(\n        ExternalReference::Create(IsolateAddressId::kContextAddress, isolate_));\n\n    __ StoreOffHeap(context_address, __ BitcastHeapObjectToWordPtr(context),\n                    MemoryRepresentation::UintPtr());\n\n    // Create the fast call.\n    OpIndex result = __ Call(callee, frame_state, arguments, descriptor);\n\n    // Reset the CPU profiler target address.\n    __ StoreOffHeap(target_address, __ IntPtrConstant(0),\n                    MemoryRepresentation::UintPtr());\n\n#if DEBUG\n    // Reset the context again after the call, to make sure nobody is using the\n    // leftover context in the isolate.\n    __ StoreOffHeap(context_address,\n                    __ WordPtrConstant(Context::kInvalidContext),\n                    MemoryRepresentation::UintPtr());\n#endif\n\n    return result;\n  }\n\n  Isolate* isolate_ = __ data() -> isolate();\n  Factory* factory_ = isolate_->factory();\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Next\",\n                \"about\": \"A template parameter representing the next reducer in a chain.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            template <typename Next> class FastApiCallLoweringReducer : public Next { /* ... */ };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FastApiCallParameters\",\n                \"about\": \"Contains the parameters for a Fast API call, including the C function and its signature.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            struct FastApiCallParameters;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"CTypeInfo\",\n                \"about\": \"Describes the type information of a C function argument or return value.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            struct CTypeInfo;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TSCallDescriptor\",\n                \"about\": \"Describes the calling convention for a Turboshaft call.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class TSCallDescriptor;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Label\",\n                \"about\": \"Represents a label in the generated code for branching and control flow.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Label;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Variable\",\n                \"about\": \"Represents a variable in the generated code.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Variable;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ExternalReference\",\n                \"about\": \"Represents a reference to an external function or data.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class ExternalReference;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MachineSignature\",\n                \"about\": \"Describes the signature of a machine code function.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class MachineSignature;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"MachineType\",\n                \"about\": \"Enumerates the possible machine types.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            enum class MachineType;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents a V8 isolate.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Factory\",\n                \"about\": \"A factory for creating V8 objects.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Factory;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Context\",\n                \"about\": \"Represents a JavaScript context.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Context;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"V\",\n                \"about\": \"Represents a value in the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            template <typename T> class V;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FrameState\",\n                \"about\": \"Represents the state of the stack frame.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class FrameState;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Object\",\n                \"about\": \"The base class for all V8 objects.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Object;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Word32\",\n                \"about\": \"Represents a 32-bit word.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Word32;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Any\",\n                \"about\": \"Represents any type.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Any;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Tuple\",\n                \"about\": \"Represents a tuple.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            template <typename T, typename U> class Tuple;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Float64\",\n                \"about\": \"Represents a 64-bit floating point number.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Float64;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"HeapObject\",\n                \"about\": \"Represents an object allocated on the V8 heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class HeapObject;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Map\",\n                \"about\": \"Describes the layout and properties of a V8 object.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Map;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WordPtr\",\n                \"about\": \"Represents a pointer-sized word.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class WordPtr;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FixedArray\",\n                \"about\": \"Represents a fixed-size array.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class FixedArray;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSExternalObject\",\n                \"about\": \"Represents a JavaScript external object.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class JSExternalObject;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Uninitialized\",\n                \"about\": \"Represents an uninitialized value.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            template <typename T> class Uninitialized;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AccessBuilder\",\n                \"about\": \"Provides access to object fields.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class AccessBuilder;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"IsolateFieldId\",\n                \"about\": \"Enumerates the IDs of isolate fields.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            enum class IsolateFieldId;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CallDescriptor\",\n                \"about\": \"Describes the calling convention for a function call.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class CallDescriptor;\n            ]]"
}