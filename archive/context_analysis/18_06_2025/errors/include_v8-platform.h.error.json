{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-platform.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-platform.h\",\n            \"file_name\": \"v8-platform.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the V8 Platform abstraction layer, providing interfaces for embedders to customize V8's interaction with the underlying operating system and hardware. Includes task scheduling, memory management, and tracing functionalities.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers for math functions, standard definitions, integer types, and memory allocation, as well as V8-specific headers for source locations and configuration.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <math.h>\n            #include <stddef.h>\n            #include <stdint.h>\n            #include <stdlib.h>  // For abort.\n\n            #include <memory>\n            #include <string>\n\n            #include \"v8-source-location.h\"  // NOLINT(build/include_directory)\n            #include \"v8config.h\"            // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Forward declaration for the Isolate class.  This is needed as Platform uses Isolate in some method signatures.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class Isolate;\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"TaskPriority\",\n                \"about\": \"Defines the priorities for tasks scheduled using the platform's task scheduling infrastructure.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class TaskPriority : uint8_t {\n              /**\n               * Best effort tasks are not critical for performance of the application. The\n               * platform implementation should preempt such tasks if higher priority tasks\n               * arrive.\n               */\n              kBestEffort,\n              /**\n               * User visible tasks are long running background tasks that will\n               * improve performance and memory usage of the application upon completion.\n               * Example: background compilation and garbage collection.\n               */\n              kUserVisible,\n              /**\n               * User blocking tasks are highest priority tasks that block the execution\n               * thread (e.g. major garbage collection). They must be finished as soon as\n               * possible.\n               */\n              kUserBlocking,\n              kMaxPriority = kUserBlocking\n            };\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Task\",\n                \"about\": \"Represents a unit of work to be executed by the platform.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class Task {\n             public:\n              virtual ~Task() = default;\n\n              virtual void Run() = 0;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"IdleTask\",\n                \"about\": \"Represents a unit of work to be executed during idle time.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class IdleTask {\n             public:\n              virtual ~IdleTask() = default;\n              virtual void Run(double deadline_in_seconds) = 0;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TaskRunner\",\n                \"about\": \"Allows scheduling of tasks to be executed. Provides methods to post tasks with or without delay, and supports idle tasks.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Task\",\n                    \"IdleTask\",\n                    \"SourceLocation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class TaskRunner {\n             public:\n              /**\n               * Schedules a task to be invoked by this TaskRunner. The TaskRunner\n               * implementation takes ownership of |task|.\n               *\n               * Embedders should override PostTaskImpl instead of this.\n               */\n              void PostTask(std::unique_ptr<Task> task,\n                            const SourceLocation& location = SourceLocation::Current()) {\n                PostTaskImpl(std::move(task), location);\n              }\n\n              /**\n               * Schedules a task to be invoked by this TaskRunner. The TaskRunner\n               * implementation takes ownership of |task|. The |task| cannot be nested\n               * within other task executions.\n               *\n               * Tasks which shouldn't be interleaved with JS execution must be posted with\n               * |PostNonNestableTask| or |PostNonNestableDelayedTask|. This is because the\n               * embedder may process tasks in a callback which is called during JS\n               * execution.\n               *\n               * In particular, tasks which execute JS must be non-nestable, since JS\n               * execution is not allowed to nest.\n               *\n               * Requires that |TaskRunner::NonNestableTasksEnabled()| is true.\n               *\n               * Embedders should override PostNonNestableTaskImpl instead of this.\n               */\n              void PostNonNestableTask(\n                  std::unique_ptr<Task> task,\n                  const SourceLocation& location = SourceLocation::Current()) {\n                PostNonNestableTaskImpl(std::move(task), location);\n              }\n\n              /**\n               * Schedules a task to be invoked by this TaskRunner. The task is scheduled\n               * after the given number of seconds |delay_in_seconds|. The TaskRunner\n               * implementation takes ownership of |task|.\n               *\n               * Embedders should override PostDelayedTaskImpl instead of this.\n               */\n              void PostDelayedTask(\n                  std::unique_ptr<Task> task, double delay_in_seconds,\n                  const SourceLocation& location = SourceLocation::Current()) {\n                PostDelayedTaskImpl(std::move(task), delay_in_seconds, location);\n              }\n\n              /**\n               * Schedules a task to be invoked by this TaskRunner. The task is scheduled\n               * after the given number of seconds |delay_in_seconds|. The TaskRunner\n               * implementation takes ownership of |task|. The |task| cannot be nested\n               * within other task executions.\n               *\n               * Tasks which shouldn't be interleaved with JS execution must be posted with\n               * |PostNonNestableTask| or |PostNonNestableDelayedTask|. This is because the\n               * embedder may process tasks in a callback which is called during JS\n               * execution.\n               *\n               * In particular, tasks which execute JS must be non-nestable, since JS\n               * execution is not allowed to nest.\n               *\n               * Requires that |TaskRunner::NonNestableDelayedTasksEnabled()| is true.\n               *\n               * Embedders should override PostNonNestableDelayedTaskImpl instead of this.\n               */\n              void PostNonNestableDelayedTask(\n                  std::unique_ptr<Task> task, double delay_in_seconds,\n                  const SourceLocation& location = SourceLocation::Current()) {\n                PostNonNestableDelayedTaskImpl(std::move(task), delay_in_seconds, location);\n              }\n\n              /**\n               * Schedules an idle task to be invoked by this TaskRunner. The task is\n               * scheduled when the embedder is idle. Requires that\n               * |TaskRunner::IdleTasksEnabled()| is true. Idle tasks may be reordered\n               * relative to other task types and may be starved for an arbitrarily long\n               * time if no idle time is available. The TaskRunner implementation takes\n               * ownership of |task|.\n               *\n               * Embedders should override PostIdleTaskImpl instead of this.\n               */\n              void PostIdleTask(\n                  std::unique_ptr<IdleTask> task,\n                  const SourceLocation& location = SourceLocation::Current()) {\n                PostIdleTaskImpl(std::move(task), location);\n              }\n\n              /**\n               * Returns true if idle tasks are enabled for this TaskRunner.\n               */\n              virtual bool IdleTasksEnabled() = 0;\n\n              /**\n               * Returns true if non-nestable tasks are enabled for this TaskRunner.\n               */\n              virtual bool NonNestableTasksEnabled() const { return false; }\n\n              /**\n               * Returns true if non-nestable delayed tasks are enabled for this TaskRunner.\n               */\n              virtual bool NonNestableDelayedTasksEnabled() const { return false; }\n\n              TaskRunner() = default;\n              virtual ~TaskRunner() = default;\n\n              TaskRunner(const TaskRunner&) = delete;\n              TaskRunner& operator=(const TaskRunner&) = delete;\n\n             protected:\n              /**\n               * Implementation of above methods with an additional `location` argument.\n               */\n              virtual void PostTaskImpl(std::unique_ptr<Task> task,\n                                        const SourceLocation& location) {}\n              virtual void PostNonNestableTaskImpl(std::unique_ptr<Task> task,\n                                                    const SourceLocation& location) {}\n              virtual void PostDelayedTaskImpl(std::unique_ptr<Task> task,\n                                                double delay_in_seconds,\n                                                const SourceLocation& location) {}\n              virtual void PostNonNestableDelayedTaskImpl(std::unique_ptr<Task> task,\n                                                       double delay_in_seconds,\n                                                       const SourceLocation& location) {}\n              virtual void PostIdleTaskImpl(std::unique_ptr<IdleTask> task,\n                                            const SourceLocation& location) {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JobDelegate\",\n                \"about\": \"Delegate passed to Job's worker task, providing an entry point to communicate with the scheduler.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class JobDelegate {\n             public:\n              /**\n               * Returns true if this thread *must* return from the worker task on the\n               * current thread ASAP. Workers should periodically invoke ShouldYield (or\n               * YieldIfNeeded()) as often as is reasonable.\n               * After this method returned true, ShouldYield must not be called again.\n               */\n              virtual bool ShouldYield() = 0;\n\n              /**\n               * Notifies the scheduler that max concurrency was increased, and the number\n               * of worker should be adjusted accordingly. See Platform::PostJob() for more\n               * details.\n               */\n              virtual void NotifyConcurrencyIncrease() = 0;\n\n              /**\n               * Returns a task_id unique among threads currently running this job, such\n               * that GetTaskId() < worker count. To achieve this, the same task_id may be\n               * reused by a different thread after a worker_task returns.\n               */\n              virtual uint8_t GetTaskId() = 0;\n\n              /**\n               * Returns true if the current task is called from the thread currently\n               * running JobHandle::Join().\n               */\n              virtual bool IsJoiningThread() const = 0;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JobHandle\",\n                \"about\": \"Handle returned when posting a Job. Provides methods to control execution of the posted Job.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"TaskPriority\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class JobHandle {\n             public:\n              virtual ~JobHandle() = default;\n\n              /**\n               * Notifies the scheduler that max concurrency was increased, and the number\n               * of worker should be adjusted accordingly. See Platform::PostJob() for more\n               * details.\n               */\n              virtual void NotifyConcurrencyIncrease() = 0;\n\n              /**\n               * Contributes to the job on this thread. Doesn't return until all tasks have\n               * completed and max concurrency becomes 0. When Join() is called and max\n               * concurrency reaches 0, it should not increase again. This also promotes\n               * this Job's priority to be at least as high as the calling thread's\n               * priority.\n               */\n              virtual void Join() = 0;\n\n              /**\n               * Forces all existing workers to yield ASAP. Waits until they have all\n               * returned from the Job's callback before returning.\n               */\n              virtual void Cancel() = 0;\n\n              /*\n               * Forces all existing workers to yield ASAP but doesn\u2019t wait for them.\n               * Warning, this is dangerous if the Job's callback is bound to or has access\n               * to state which may be deleted after this call.\n               */\n              virtual void CancelAndDetach() = 0;\n\n              /**\n               * Returns true if there's any work pending or any worker running.\n               */\n              virtual bool IsActive() = 0;\n\n              /**\n               * Returns true if associated with a Job and other methods may be called.\n               * Returns false after Join() or Cancel() was called. This may return true\n               * even if no workers are running and IsCompleted() returns true\n               */\n              virtual bool IsValid() = 0;\n\n              /**\n               * Returns true if job priority can be changed.\n               */\n              virtual bool UpdatePriorityEnabled() const { return false; }\n\n              /**\n               *  Update this Job's priority.\n               */\n              virtual void UpdatePriority(TaskPriority new_priority) {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JobTask\",\n                \"about\": \"Represents work to run in parallel from Platform::PostJob().\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"JobDelegate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class JobTask {\n             public:\n              virtual ~JobTask() = default;\n\n              virtual void Run(JobDelegate* delegate) = 0;\n\n              /**\n               * Controls the maximum number of threads calling Run() concurrently, given\n               * the number of threads currently assigned to this job and executing Run().\n               * Run() is only invoked if the number of threads previously running Run() was\n               * less than the value returned. In general, this should return the latest\n               * number of incomplete work items (smallest unit of work) left to process,\n               * including items that are currently in progress. |worker_count| is the\n               * number of threads currently assigned to this job which some callers may\n               * need to determine their return value. Since GetMaxConcurrency() is a leaf\n               * function, it must not call back any JobHandle methods.\n               */\n              virtual size_t GetMaxConcurrency(size_t worker_count) const = 0;\n            };\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"BlockingType\",\n                \"about\": \"Indicates the likelihood that a blocking call will actually block.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class BlockingType {\n              // The call might block (e.g. file I/O that might hit in memory cache).\n              kMayBlock,\n              // The call will definitely block (e.g. cache already checked and now pinging\n              // server synchronously).\n              kWillBlock\n            };\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ScopedBlockingCall\",\n                \"about\": \"Instantiated with CreateBlockingScope() in every scope where a blocking call is made and serves as a precise annotation of the scope that may/will block.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class ScopedBlockingCall {\n             public:\n              virtual ~ScopedBlockingCall() = default;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ConvertableToTraceFormat\",\n                \"about\": \"The interface represents complex arguments to trace events.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class ConvertableToTraceFormat {\n             public:\n              virtual ~ConvertableToTraceFormat() = default;\n\n              /**\n               * Append the class info to the provided |out| string. The appended\n               * data must be a valid JSON object. Strings must be properly quoted, and\n               * escaped. There is no processing applied to the content after it is\n               * appended.\n               */\n              virtual void AppendAsTraceFormat(std::string* out) const = 0;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TracingController\",\n                \"about\": \"V8 Tracing controller. Can be implemented by an embedder to record trace events from V8.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"ConvertableToTraceFormat\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class TracingController {\n             public:\n              virtual ~TracingController() = default;\n\n              // In Perfetto mode, trace events are written using Perfetto's Track Event\n              // API directly without going through the embedder. However, it is still\n              // possible to observe tracing being enabled and disabled.\n            #if !defined(V8_USE_PERFETTO)\n              /**\n               * Called by TRACE_EVENT* macros, don't call this directly.\n               * The name parameter is a category group for example:\n               * TRACE_EVENT0(\"v8,parse\", \"V8.Parse\")\n               * The pointer returned points to a value with zero or more of the bits\n               * defined in CategoryGroupEnabledFlags.\n               **/\n              virtual const uint8_t* GetCategoryGroupEnabled(const char* name) {\n                static uint8_t no = 0;\n                return &no;\n              }\n\n              /**\n               * Adds a trace event to the platform tracing system. These function calls are\n               * usually the result of a TRACE_* macro from trace-event-no-perfetto.h when\n               * tracing and the category of the particular trace are enabled. It is not\n               * advisable to call these functions on their own; they are really only meant\n               * to be used by the trace macros. The returned handle can be used by\n               * UpdateTraceEventDuration to update the duration of COMPLETE events.\n               */\n              virtual uint64_t AddTraceEvent(\n                  char phase, const uint8_t* category_enabled_flag, const char* name,\n                  const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,\n                  const char** arg_names, const uint8_t* arg_types,\n                  const uint64_t* arg_values,\n                  std::unique_ptr<ConvertableToTraceFormat>* arg_convertables,\n                  unsigned int flags) {\n                return 0;\n              }\n              virtual uint64_t AddTraceEventWithTimestamp(\n                  char phase, const uint8_t* category_enabled_flag, const char* name,\n                  const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,\n                  const char** arg_names, const uint8_t* arg_types,\n                  const uint64_t* arg_values,\n                  std::unique_ptr<ConvertableToTraceFormat>* arg_convertables,\n                  unsigned int flags, int64_t timestamp) {\n                return 0;\n              }\n\n              /**\n               * Sets the duration field of a COMPLETE trace event. It must be called with\n               * the handle returned from AddTraceEvent().\n               **/\n              virtual void UpdateTraceEventDuration(const uint8_t* category_enabled_flag,\n                                                    const char* name, uint64_t handle) {}\n            #endif  // !defined(V8_USE_PERFETTO)\n\n              class TraceStateObserver {\n               public:\n                virtual ~TraceStateObserver() = default;\n                virtual void OnTraceEnabled() = 0;\n                virtual void OnTraceDisabled() = 0;\n              };\n\n              /**\n               * Adds tracing state change observer.\n               * Does nothing in Perfetto SDK build (v8_use_perfetto = true).\n               */\n              virtual void AddTraceStateObserver(TraceStateObserver*) {}\n\n              /**\n               * Removes tracing state change observer.\n               * Does nothing in Perfetto SDK build (v8_use_perfetto = true).\n               */\n              virtual void RemoveTraceStateObserver(TraceStateObserver*) {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PageAllocator\",\n                \"about\": \"V8 memory page allocator. Can be implemented by an embedder to manage large host OS allocations.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class PageAllocator {\n             public:\n              virtual ~PageAllocator() = default;\n\n              /**\n               * Gets the page granularity for AllocatePages and FreePages. Addresses and\n               * lengths for those calls should be multiples of AllocatePageSize().\n               */\n              virtual size_t AllocatePageSize() = 0;\n\n              /**\n               * Gets the page granularity for SetPermissions and ReleasePages. Addresses\n               * and lengths for those calls should be multiples of CommitPageSize().\n               */\n              virtual size_t CommitPageSize() = 0;\n\n              /**\n               * Sets the random seed so that GetRandomMmapAddr() will generate repeatable\n               * sequences of random mmap addresses.\n               */\n              virtual void SetRandomMmapSeed(int64_t seed) = 0;\n\n              /**\n               * Returns a randomized address, suitable for memory allocation under ASLR.\n               * The address will be aligned to AllocatePageSize.\n               */\n              virtual void* GetRandomMmapAddr() = 0;\n\n              /**\n               * Memory permissions.\n               */\n              enum Permission {\n                kNoAccess,\n                kRead,\n                kReadWrite,\n                kReadWriteExecute,\n                kReadExecute,\n                // Set this when reserving memory that will later require kReadWriteExecute\n                // permissions. The resulting behavior is platform-specific, currently\n                // this is used to set the MAP_JIT flag on Apple Silicon.\n                // TODO(jkummerow): Remove this when Wasm has a platform-independent\n                // w^x implementation.\n                // TODO(saelo): Remove this once all JIT pages are allocated through the\n                // VirtualAddressSpace API.\n                kNoAccessWillJitLater\n              };\n\n              /**\n               * Allocates memory in range with the given alignment and permission.\n               */\n              virtual void* AllocatePages(void* address, size_t length, size_t alignment,\n                                          Permission permissions) = 0;\n\n              /**\n               * Frees memory in a range that was allocated by a call to AllocatePages.\n               */\n              virtual bool FreePages(void* address, size_t length) = 0;\n\n              /**\n               * Releases memory in a range that was allocated by a call to AllocatePages.\n               */\n              virtual bool ReleasePages(void* address, size_t length,\n                                        size_t new_length) = 0;\n\n              /**\n               * Sets permissions on pages in an allocated range.\n               */\n              virtual bool SetPermissions(void* address, size_t length,\n                                          Permission permissions) = 0;\n\n              /**\n               * Recommits discarded pages in the given range with given permissions.\n               * Discarded pages must be recommitted with their original permissions\n               * before they are used again.\n               */\n              virtual bool RecommitPages(void* address, size_t length,\n                                         Permission permissions) {\n                // TODO(v8:12797): make it pure once it's implemented on Chromium side.\n                return false;\n              }\n\n              /**\n               * Frees memory in the given [address, address + size) range. address and size\n               * should be operating system page-aligned. The next write to this\n               * memory area brings the memory transparently back. This should be treated as\n               * a hint to the OS that the pages are no longer needed. It does not guarantee\n               * that the pages will be discarded immediately or at all.\n               */\n              virtual bool DiscardSystemPages(void* address, size_t size) { return true; }\n\n              /**\n               * Decommits any wired memory pages in the given range, allowing the OS to\n               * reclaim them, and marks the region as inacessible (kNoAccess). The address\n               * range stays reserved and can be accessed again later by changing its\n               * permissions. However, in that case the memory content is guaranteed to be\n               * zero-initialized again. The memory must have been previously allocated by a\n               * call to AllocatePages. Returns true on success, false otherwise.\n               */\n              virtual bool DecommitPages(void* address, size_t size) = 0;\n\n              /**\n               * Block any modifications to the given mapping such as changing permissions\n               * or unmapping the pages on supported platforms.\n               * The address space reservation will exist until the process ends, but it's\n               * possible to release the memory using DiscardSystemPages. Note that this\n               * might require write permissions to the page as e.g. on Linux, mseal will\n               * block discarding sealed anonymous memory.\n               */\n              virtual bool SealPages(void* address, size_t length) {\n                // TODO(360048056): make it pure once it's implemented on Chromium side.\n                return false;\n              }\n\n              /**\n               * INTERNAL ONLY: This interface has not been stabilised and may change\n               * without notice from one release to another without being deprecated first.\n               */\n              class SharedMemoryMapping {\n               public:\n                // Implementations are expected to free the shared memory mapping in the\n                // destructor.\n                virtual ~SharedMemoryMapping() = default;\n                virtual void* GetMemory() const = 0;\n              };\n\n              /**\n               * INTERNAL ONLY: This interface has not been stabilised and may change\n               * without notice from one release to another without being deprecated first.\n               */\n              class SharedMemory {\n               public:\n                // Implementations are expected to free the shared memory in the destructor.\n                virtual ~SharedMemory() = default;\n                virtual std::unique_ptr<SharedMemoryMapping> RemapTo(\n                    void* new_address) const = 0;\n                virtual void* GetMemory() const = 0;\n                virtual size_t GetSize() const = 0;\n              };\n\n              /**\n               * INTERNAL ONLY: This interface has not been stabilised and may change\n               * without notice from one release to another without being deprecated first.\n               *\n               * Reserve pages at a fixed address returning whether the reservation is\n               * possible. The reserved memory is detached from the PageAllocator and so\n               * should not be freed by it. It's intended for use with\n               * SharedMemory::RemapTo, where ~SharedMemoryMapping would free the memory.\n               */\n              virtual bool ReserveForSharedMemoryMapping(void* address, size_t size) {\n                return false;\n              }\n\n              /**\n               * INTERNAL ONLY: This interface has not been stabilised and may change\n               * without notice from one release to another without being deprecated first.\n               *\n               * Allocates shared memory pages. Not all PageAllocators need support this and\n               * so this method need not be overridden.\n               * Allocates a new read-only shared memory region of size |length| and copies\n               * the memory at |original_address| into it.\n               */\n              virtual std::unique_ptr<SharedMemory> AllocateSharedPages(\n                  size_t length, const void* original_address) {\n                return {};\n              }\n\n              /**\n               * INTERNAL ONLY: This interface has not been stabilised and may change\n               * without notice from one release to another without being deprecated first.\n               *\n               * If not overridden and changed to return true, V8 will not attempt to call\n               * AllocateSharedPages or RemapSharedPages. If overridden, AllocateSharedPages\n               * and RemapSharedPages must also be overridden.\n               */\n              virtual bool CanAllocateSharedPages() { return false; }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ThreadIsolatedAllocator\",\n                \"about\": \"An allocator that uses per-thread permissions to protect the memory.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class ThreadIsolatedAllocator {\n             public:\n              virtual ~ThreadIsolatedAllocator() = default;\n\n              virtual void* Allocate(size_t size) = 0;\n\n              virtual void Free(void* object) = 0;\n\n              enum class Type {\n                kPkey,\n              };\n\n              virtual Type Type() const = 0;\n\n              /**\n               * Return the pkey used to implement the thread isolation if Type == kPkey.\n               */\n              virtual int Pkey() const { return -1; }\n\n              /**\n               * Per-thread permissions can be reset on signal handler entry. Even reading\n               * ThreadIsolated memory will segfault in that case.\n               * Call this function on signal handler entry to ensure that read permissions\n               * are restored.\n               */\n              static void SetDefaultPermissionsForSignalHandler();\n            };\n        ]]></code>\n    </class>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"PlatformSharedMemoryHandle\",\n                \"about\": \"Opaque type representing a handle to a shared memory region.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            using PlatformSharedMemoryHandle = intptr_t;\n        ]]></code>\n    </typedef>\n    <variable>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"kInvalidSharedMemoryHandle\",\n                \"about\": \"Constant representing an invalid shared memory handle.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            static constexpr PlatformSharedMemoryHandle kInvalidSharedMemoryHandle = -1;\n        ]]></code>\n    </variable>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"inline function\",\n                \"name\": \"SharedMemoryHandleFromMachMemoryEntry\",\n                \"about\": \"Convert between a shared memory handle and a mach_port_t referencing a memory entry object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"port\",\n                        \"type\": \"unsigned int\",\n                        \"purpose\": \"The mach port\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"PlatformSharedMemoryHandle\",\n                    \"description\": \"The shared memory handle.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            inline PlatformSharedMemoryHandle SharedMemoryHandleFromMachMemoryEntry(\n                unsigned int port) {\n              return static_cast<PlatformSharedMemoryHandle>(port);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"inline function\",\n                \"name\": \"MachMemoryEntryFromSharedMemoryHandle\",\n                \"about\": \"Convert between a shared memory handle and a mach_port_t referencing a memory entry object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"PlatformSharedMemoryHandle\",\n                        \"purpose\": \"The shared memory handle.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"unsigned int\",\n                    \"description\": \"The mach port\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            inline unsigned int MachMemoryEntryFromSharedMemoryHandle(\n                PlatformSharedMemoryHandle handle) {\n              return static_cast<unsigned int>(handle);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"inline function\",\n                \"name\": \"SharedMemoryHandleFromVMO\",\n                \"about\": \"Convert between a shared memory handle and a zx_handle_t to a VMO.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"uint32_t\",\n                        \"purpose\": \"The zx_handle_t\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"PlatformSharedMemoryHandle\",\n                    \"description\": \"The shared memory handle.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            inline PlatformSharedMemoryHandle SharedMemoryHandleFromVMO(uint32_t handle) {\n              return static_cast<PlatformSharedMemoryHandle>(handle);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"inline function\",\n                \"name\": \"VMOFromSharedMemoryHandle\",\n                \"about\": \"Convert between a shared memory handle and a zx_handle_t to a VMO.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"PlatformSharedMemoryHandle\",\n                        \"purpose\": \"The shared memory handle.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint32_t\",\n                    \"description\": \"The zx_handle_t\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            inline uint32_t VMOFromSharedMemoryHandle(PlatformSharedMemoryHandle handle) {\n              return static_cast<uint32_t>(handle);\n            }\n        ]]></code>\n    </func"
}