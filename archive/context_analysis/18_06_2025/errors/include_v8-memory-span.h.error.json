{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-memory-span.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 467, column 37",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-memory-span.h\",\n            \"file_name\": \"v8-memory-span.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the v8::MemorySpan class, a container similar to std::span for representing a contiguous sequence of objects. Also defines the v8::to_array helper function.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers necessary for MemorySpan implementation and feature detection.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <stddef.h>\n\n#include <array>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n\n#include \"v8config.h\"  // NOLINT(build/include_directory)\n\n// TODO(pkasting): Use <compare>/spaceship unconditionally after dropping\n// support for old libstdc++ versions.\n#if __has_include(<version>)\n#include <version>\n#endif\n#if defined(__cpp_lib_three_way_comparison) && \\\n    __cpp_lib_three_way_comparison >= 201711L\n#define V8_HAVE_SPACESHIP_OPERATOR 1\n#else\n#define V8_HAVE_SPACESHIP_OPERATOR 0\n#endif\n\n// TODO(pkasting): Make this block unconditional after dropping support for old\n// libstdc++ versions.\n#if __has_include(<ranges>)\n#include <ranges>\n#endif\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MemorySpan\",\n                \"about\": \"Represents a contiguous sequence of objects, similar to std::span.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"data_\",\n                        \"type\": \"T*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the beginning of the buffer.\"\n                    },\n                    {\n                        \"name\": \"size_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The number of elements in the buffer.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"std::is_convertible\",\n                    \"std::iterator_traits\",\n                    \"std::random_access_iterator_tag\",\n                    \"std::remove_reference_t\",\n                    \"std::void_t\",\n                    \"std::is_base_of\",\n                    \"std::declval\",\n                    \"std::nullptr_t\",\n                    \"std::array\",\n                    \"std::ranges::enable_view\",\n                    \"std::ranges::enable_borrowed_range\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass V8_EXPORT MemorySpan {\n private:\n  /** Some C++ machinery, brought from the future. */\n  template <typename From, typename To>\n  using is_array_convertible = std::is_convertible<From (*)[], To (*)[]>;\n  template <typename From, typename To>\n  static constexpr bool is_array_convertible_v =\n      is_array_convertible<From, To>::value;\n\n  template <typename It>\n  using iter_reference_t = decltype(*std::declval<It&>());\n\n  template <typename It, typename = void>\n  struct is_compatible_iterator : std::false_type {};\n  template <typename It>\n  struct is_compatible_iterator<\n      It,\n      std::void_t<\n          std::is_base_of<std::random_access_iterator_tag,\n                          typename std::iterator_traits<It>::iterator_category>,\n          is_array_convertible<std::remove_reference_t<iter_reference_t<It>>,\n                               T>>> : std::true_type {};\n  template <typename It>\n  static constexpr bool is_compatible_iterator_v =\n      is_compatible_iterator<It>::value;\n\n  template <typename U>\n  [[nodiscard]] static constexpr U* to_address(U* p) noexcept {\n    return p;\n  }\n\n  template <typename It,\n            typename = std::void_t<decltype(std::declval<It&>().operator->())>>\n  [[nodiscard]] static constexpr auto to_address(It it) noexcept {\n    return it.operator->();\n  }\n\n public:\n  /** The default constructor creates an empty span. */\n  constexpr MemorySpan() = default;\n\n  /** Constructor from nullptr and count, for backwards compatibility.\n   * This is not compatible with C++20 std::span.\n   */\n  constexpr MemorySpan(std::nullptr_t, size_t) {}\n\n  /** Constructor from \"iterator\" and count. */\n  template <typename Iterator,\n            std::enable_if_t<is_compatible_iterator_v<Iterator>, bool> = true>\n  constexpr MemorySpan(Iterator first,\n                       size_t count)  // NOLINT(runtime/explicit)\n      : data_(to_address(first)), size_(count) {}\n\n  /** Constructor from two \"iterators\". */\n  template <typename Iterator,\n            std::enable_if_t<is_compatible_iterator_v<Iterator> &&\n                                 !std::is_convertible_v<Iterator, size_t>,\n                             bool> = true>\n  constexpr MemorySpan(Iterator first,\n                       Iterator last)  // NOLINT(runtime/explicit)\n      : data_(to_address(first)), size_(last - first) {}\n\n  /** Implicit conversion from C-style array. */\n  template <size_t N>\n  constexpr MemorySpan(T (&a)[N]) noexcept  // NOLINT(runtime/explicit)\n      : data_(a), size_(N) {}\n\n  /** Implicit conversion from std::array. */\n  template <typename U, size_t N,\n            std::enable_if_t<is_array_convertible_v<U, T>, bool> = true>\n  constexpr MemorySpan(\n      std::array<U, N>& a) noexcept  // NOLINT(runtime/explicit)\n      : data_(a.data()), size_{N} {}\n\n  /** Implicit conversion from const std::array. */\n  template <typename U, size_t N,\n            std::enable_if_t<is_array_convertible_v<const U, T>, bool> = true>\n  constexpr MemorySpan(\n      const std::array<U, N>& a) noexcept  // NOLINT(runtime/explicit)\n      : data_(a.data()), size_{N} {}\n\n  /** Returns a pointer to the beginning of the buffer. */\n  [[nodiscard]] constexpr T* data() const { return data_; }\n  /** Returns the number of elements that the buffer holds. */\n  [[nodiscard]] constexpr size_t size() const { return size_; }\n\n  [[nodiscard]] constexpr T& operator[](size_t i) const { return data_[i]; }\n\n  /** Returns true if the buffer is empty. */\n  [[nodiscard]] constexpr bool empty() const { return size() == 0; }\n\n  class Iterator {\n   public:\n    using difference_type = std::ptrdiff_t;\n    using value_type = T;\n    using pointer = value_type*;\n    using reference = value_type&;\n    using iterator_category = std::random_access_iterator_tag;\n    // There seems to be no feature-test macro covering this, so use the\n    // presence of `<ranges>` as a crude proxy, since it was added to the\n    // standard as part of the Ranges papers.\n    // TODO(pkasting): Add this unconditionally after dropping support for old\n    // libstdc++ versions.\n#if __has_include(<ranges>)\n    using iterator_concept = std::contiguous_iterator_tag;\n#endif\n\n    // Required to satisfy `std::semiregular<>`.\n    constexpr Iterator() = default;\n\n    [[nodiscard]] friend constexpr bool operator==(const Iterator& a,\n                                                   const Iterator& b) {\n      // TODO(pkasting): Replace this body with `= default` after dropping\n      // support for old gcc versions.\n      return a.ptr_ == b.ptr_;\n    }\n#if V8_HAVE_SPACESHIP_OPERATOR\n    [[nodiscard]] friend constexpr auto operator<=>(const Iterator&,\n                                                    const Iterator&) = default;\n#else\n    // Assume that if spaceship isn't present, operator rewriting might not be\n    // either.\n    [[nodiscard]] friend constexpr bool operator!=(const Iterator& a,\n                                                   const Iterator& b) {\n      return a.ptr_ != b.ptr_;\n    }\n\n    [[nodiscard]] friend constexpr bool operator<(const Iterator& a,\n                                                  const Iterator& b) {\n      return a.ptr_ < b.ptr_;\n    }\n    [[nodiscard]] friend constexpr bool operator<=(const Iterator& a,\n                                                   const Iterator& b) {\n      return a.ptr_ <= b.ptr_;\n    }\n    [[nodiscard]] friend constexpr bool operator>(const Iterator& a,\n                                                  const Iterator& b) {\n      return a.ptr_ > b.ptr_;\n    }\n    [[nodiscard]] friend constexpr bool operator>=(const Iterator& a,\n                                                   const Iterator& b) {\n      return a.ptr_ >= b.ptr_;\n    }\n#endif\n\n    constexpr Iterator& operator++() {\n      ++ptr_;\n      return *this;\n    }\n\n    constexpr Iterator operator++(int) {\n      Iterator temp = *this;\n      ++*this;\n      return temp;\n    }\n\n    constexpr Iterator& operator--() {\n      --ptr_;\n      return *this;\n    }\n\n    constexpr Iterator operator--(int) {\n      Iterator temp = *this;\n      --*this;\n      return temp;\n    }\n\n    constexpr Iterator& operator+=(difference_type rhs) {\n      ptr_ += rhs;\n      return *this;\n    }\n\n    [[nodiscard]] friend constexpr Iterator operator+(Iterator lhs,\n                                                      difference_type rhs) {\n      lhs += rhs;\n      return lhs;\n    }\n\n    [[nodiscard]] friend constexpr Iterator operator+(difference_type lhs,\n                                                      const Iterator& rhs) {\n      return rhs + lhs;\n    }\n\n    constexpr Iterator& operator-=(difference_type rhs) {\n      ptr_ -= rhs;\n      return *this;\n    }\n\n    [[nodiscard]] friend constexpr Iterator operator-(Iterator lhs,\n                                                      difference_type rhs) {\n      lhs -= rhs;\n      return lhs;\n    }\n\n    [[nodiscard]] friend constexpr difference_type operator-(\n        const Iterator& lhs, const Iterator& rhs) {\n      return lhs.ptr_ - rhs.ptr_;\n    }\n\n    [[nodiscard]] constexpr reference operator*() const { return *ptr_; }\n    [[nodiscard]] constexpr pointer operator->() const { return ptr_; }\n    [[nodiscard]] constexpr reference operator[](size_t offset) const {\n      return ptr_[offset];\n    }\n\n   private:\n    friend class MemorySpan<T>;\n\n    constexpr explicit Iterator(T* ptr) : ptr_(ptr) {}\n\n    T* ptr_ = nullptr;\n  };\n\n  [[nodiscard]] Iterator begin() const { return Iterator(data_); }\n  [[nodiscard]] Iterator end() const { return Iterator(data_ + size_); }\n\n private:\n  T* data_ = nullptr;\n  size_t size_ = 0;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MemorySpan::Iterator\",\n                \"about\": \"Iterator class for MemorySpan, providing random access to elements within the span.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"ptr_\",\n                        \"type\": \"T*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the current element in the span.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"std::ptrdiff_t\",\n                    \"std::random_access_iterator_tag\",\n                    \"std::contiguous_iterator_tag\",\n                    \"V8_HAVE_SPACESHIP_OPERATOR\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class Iterator {\n   public:\n    using difference_type = std::ptrdiff_t;\n    using value_type = T;\n    using pointer = value_type*;\n    using reference = value_type&;\n    using iterator_category = std::random_access_iterator_tag;\n    // There seems to be no feature-test macro covering this, so use the\n    // presence of `<ranges>` as a crude proxy, since it was added to the\n    // standard as part of the Ranges papers.\n    // TODO(pkasting): Add this unconditionally after dropping support for old\n    // libstdc++ versions.\n#if __has_include(<ranges>)\n    using iterator_concept = std::contiguous_iterator_tag;\n#endif\n\n    // Required to satisfy `std::semiregular<>`.\n    constexpr Iterator() = default;\n\n    [[nodiscard]] friend constexpr bool operator==(const Iterator& a,\n                                                   const Iterator& b) {\n      // TODO(pkasting): Replace this body with `= default` after dropping\n      // support for old gcc versions.\n      return a.ptr_ == b.ptr_;\n    }\n#if V8_HAVE_SPACESHIP_OPERATOR\n    [[nodiscard]] friend constexpr auto operator<=>(const Iterator&,\n                                                    const Iterator&) = default;\n#else\n    // Assume that if spaceship isn't present, operator rewriting might not be\n    // either.\n    [[nodiscard]] friend constexpr bool operator!=(const Iterator& a,\n                                                   const Iterator& b) {\n      return a.ptr_ != b.ptr_;\n    }\n\n    [[nodiscard]] friend constexpr bool operator<(const Iterator& a,\n                                                  const Iterator& b) {\n      return a.ptr_ < b.ptr_;\n    }\n    [[nodiscard]] friend constexpr bool operator<=(const Iterator& a,\n                                                   const Iterator& b) {\n      return a.ptr_ <= b.ptr_;\n    }\n    [[nodiscard]] friend constexpr bool operator>(const Iterator& a,\n                                                  const Iterator& b) {\n      return a.ptr_ > b.ptr_;\n    }\n    [[nodiscard]] friend constexpr bool operator>=(const Iterator& a,\n                                                   const Iterator& b) {\n      return a.ptr_ >= b.ptr_;\n    }\n#endif\n\n    constexpr Iterator& operator++() {\n      ++ptr_;\n      return *this;\n    }\n\n    constexpr Iterator operator++(int) {\n      Iterator temp = *this;\n      ++*this;\n      return temp;\n    }\n\n    constexpr Iterator& operator--() {\n      --ptr_;\n      return *this;\n    }\n\n    constexpr Iterator operator--(int) {\n      Iterator temp = *this;\n      --*this;\n      return temp;\n    }\n\n    constexpr Iterator& operator+=(difference_type rhs) {\n      ptr_ += rhs;\n      return *this;\n    }\n\n    [[nodiscard]] friend constexpr Iterator operator+(Iterator lhs,\n                                                      difference_type rhs) {\n      lhs += rhs;\n      return lhs;\n    }\n\n    [[nodiscard]] friend constexpr Iterator operator+(difference_type lhs,\n                                                      const Iterator& rhs) {\n      return rhs + lhs;\n    }\n\n    constexpr Iterator& operator-=(difference_type rhs) {\n      ptr_ -= rhs;\n      return *this;\n    }\n\n    [[nodiscard]] friend constexpr Iterator operator-(Iterator lhs,\n                                                      difference_type rhs) {\n      lhs -= rhs;\n      return lhs;\n    }\n\n    [[nodiscard]] friend constexpr difference_type operator-(\n        const Iterator& lhs, const Iterator& rhs) {\n      return lhs.ptr_ - rhs.ptr_;\n    }\n\n    [[nodiscard]] constexpr reference operator*() const { return *ptr_; }\n    [[nodiscard]] constexpr pointer operator->() const { return ptr_; }\n    [[nodiscard]] constexpr reference operator[](size_t offset) const {\n      return ptr_[offset];\n    }\n\n   private:\n    friend class MemorySpan<T>;\n\n    constexpr explicit Iterator(T* ptr) : ptr_(ptr) {}\n\n    T* ptr_ = nullptr;\n  };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"to_array\",\n                \"about\": \"Helper function template to create a std::array of fixed length from an initializer list without explicitly specifying the array size.\",\n                \"logic\": \"Uses std::index_sequence and parameter pack expansion to copy or move elements from the input array to the output std::array.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"T (&)[N]\",\n                        \"purpose\": \"Reference to a C-style array.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::array<std::remove_cv_t<T>, N>\",\n                    \"description\": \"A std::array containing the elements from the input array.\"\n                },\n                \"dependencies\": [\n                    \"std::array\",\n                    \"std::remove_cv_t\",\n                    \"std::make_index_sequence\",\n                    \"std::index_sequence\",\n                    \"detail::to_array_lvalue_impl\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, std::size_t N>\n[[nodiscard]] constexpr std::array<std::remove_cv_t<T>, N> to_array(T (&a)[N]) {\n  return detail::to_array_lvalue_impl(a, std::make_index_sequence<N>{});\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"to_array\",\n                \"about\": \"Overload of the to_array helper function template for rvalue C-style arrays.\",\n                \"logic\": \"Uses std::index_sequence and parameter pack expansion to move elements from the input array to the output std::array.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"T (&&)[N]\",\n                        \"purpose\": \"Rvalue reference to a C-style array.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::array<std::remove_cv_t<T>, N>\",\n                    \"description\": \"A std::array containing the elements from the input array.\"\n                },\n                \"dependencies\": [\n                    \"std::array\",\n                    \"std::remove_cv_t\",\n                    \"std::make_index_sequence\",\n                    \"std::index_sequence\",\n                    \"std::move\",\n                    \"detail::to_array_rvalue_impl\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, std::size_t N>\n[[nodiscard]] constexpr std::array<std::remove_cv_t<T>, N> to_array(\n    T (&&a)[N]) {\n  return detail::to_array_rvalue_impl(std::move(a),\n                                      std::make_index_sequence<N>{});\n}\n        ]]></code>\n    </func>\n\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"detail\",\n                \"about\": \"Namespace containing implementation details for the to_array function.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace detail {\ntemplate <class T, std::size_t N, std::size_t... I>\n[[nodiscard]] constexpr std::array<std::remove_cv_t<T>, N> to_array_lvalue_impl(\n    T (&a)[N], std::index_sequence<I...>) {\n  return {{a[I]...}};\n}\n\ntemplate <class T, std::size_t N, std::size_t... I>\n[[nodiscard]] constexpr std::array<std::remove_cv_t<T>, N> to_array_rvalue_impl(\n    T (&&a)[N], std::index_sequence<I...>) {\n  return {{std::move(a[I])...}};\n}\n}  // namespace detail\n        ]]></code>\n    </namespace>\n\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"v8\",\n                \"about\": \"V8 namespace\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\n\ntemplate <typename T>\nclass V8_EXPORT MemorySpan;\n\n}  // namespace v8\n        ]]></code>\n    </namespace>\n\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"std::ranges\",\n                \"about\": \"Specilizations for std::ranges\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\n\ntemplate <typename T>\nclass V8_EXPORT MemorySpan;\n\n}  // namespace v8\n\n// Mark `MemorySpan` as satisfying the `view` and `borrowed_range` concepts.\n// This should be done before the definition of `MemorySpan`, so that any\n// inlined calls to range functionality use the correct specializations.\ntemplate <typename T>\ninline constexpr bool std::ranges::enable_view<v8::MemorySpan<T>> = true;\ntemplate <typename T>\ninline constexpr bool std::ranges::enable_borrowed_range<v8::MemorySpan<T>> =\n    true;\n        ]]></code>\n    </namespace>\n</file>\n```"
}