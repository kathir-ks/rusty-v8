{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/class-debug-reader-generator.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/class-debug-reader-generator.cc\",\n        \"file_name\": \"class-debug-reader-generator.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Generates C++ classes (TqFoo) for debugging Torque-defined classes (Foo), enabling inspection of object properties in postmortem or remote scenarios.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for standard library, V8 flags, Torque implementation visitor, and type oracle.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/flags/flags.h\"\n#include \"src/torque/implementation-visitor.h\"\n#include \"src/torque/type-oracle.h\"\n        ]]></code>\n    </imports>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ObjectProperty\",\n                \"about\": \"Represents a property of an object for debugging purposes\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ObjectProperty {\n                public:\n                    ObjectProperty(const char* name, const char* type, const char* decompressed_type,\n                                   uintptr_t address, size_t count, size_t size,\n                                   std::vector<std::unique_ptr<StructProperty>> struct_fields,\n                                   d::PropertyKind kind);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StructProperty\",\n                \"about\": \"Represents a property within a struct, used for debugging\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class StructProperty {\n                public:\n                    StructProperty(const char* name, const char* type, size_t offset_bytes, int num_bits, int shift_bits);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TqObject\",\n                \"about\": \"Base class for Tq debugging classes\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TqObject {\n                public:\n                    virtual std::vector<std::unique_ptr<ObjectProperty>> GetProperties(d::MemoryAccessor accessor) const = 0;\n                    virtual const char* GetName() const = 0;\n                    virtual void Visit(TqObjectVisitor* visitor) const = 0;\n                    virtual bool IsSuperclassOf(const TqObject* other) const = 0;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TqObjectVisitor\",\n                \"about\": \"Visitor class for TqObjects\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TqObjectVisitor {\n                public:\n                    virtual void VisitObject(const TqObject* object) {}\n                };\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CamelifyString\",\n                \"about\": \"Converts snake_case to CamelCase\",\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"CamelCase string\"\n                }\n            }\n            </metadata>\n            <code><![CDATA[\n                std::string CamelifyString(const std::string& snake_case);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SizeOf\",\n                \"about\": \"Returns the size of a Type in bytes.\",\n                \"return\": {\n                    \"type\": \"std::optional<std::tuple<size_t, size_t>>\",\n                    \"description\": \"Optional tuple containing size and alignment\"\n                }\n            }\n            </metadata>\n            <code><![CDATA[\n                std::optional<std::tuple<size_t, size_t>> SizeOf(const Type* type);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"StringLiteralQuote\",\n                \"about\": \"Quotes a string literal\",\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"Quoted string literal\"\n                }\n            }\n            </metadata>\n            <code><![CDATA[\n                std::string StringLiteralQuote(const std::string& s);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"WriteFile\",\n                \"about\": \"Writes a string to a file\",\n                \"parameters\": [\n                    {\n                        \"name\": \"filename\",\n                        \"type\": \"std::string\",\n                        \"purpose\": \"Path to the file to write\"\n                    },\n                    {\n                        \"name\": \"content\",\n                        \"type\": \"std::string\",\n                        \"purpose\": \"Content to write to the file\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                }\n            }\n            </metadata>\n            <code><![CDATA[\n                void WriteFile(const std::string& filename, const std::string& content);\n            ]]></code>\n        </func>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Type\",\n                \"about\": \"Base class for Torque types\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Type {\n                public:\n                    bool IsSubtypeOf(const Type* other) const;\n                    const StructType* StructSupertype() const;\n                    std::string ToString() const;\n                    std::string GetConstexprGeneratedTypeName() const;\n                    static const Type* MatchUnaryGeneric(const Type* type, const Type* generic);\n                    const ClassType* ClassSupertype() const;\n                    bool IsStructType() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StructType\",\n                \"about\": \"Represents a struct type in Torque\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class StructType {\n                public:\n                    const std::vector<Field>& fields() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BitFieldStructType\",\n                \"about\": \"Represents a bitfield struct type\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class BitFieldStructType {\n                public:\n                    static const BitFieldStructType* DynamicCast(const Type* type);\n                    const std::vector<Field>& fields() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ClassType\",\n                \"about\": \"Represents a class type\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ClassType {\n                public:\n                    std::string name() const;\n                    const ClassType* GetSuperClass() const;\n                    bool HasUndefinedLayout() const;\n                    std::string GetGeneratedTNodeTypeName() const;\n                    const std::vector<Field>& fields() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Field\",\n                \"about\": \"Represents a field in a class or struct\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Field {\n                public:\n                    NameAndType name_and_type;\n                    SourcePosition pos;\n                    std::optional<size_t> offset;\n                    std::optional<bool> index;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NameAndType\",\n                \"about\": \"Represents the name and type of a field or variable\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class NameAndType {\n                public:\n                    const Type* type;\n                    std::string name;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SourcePosition\",\n                \"about\": \"Represents a source position\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SourcePosition {\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ImplementationVisitor\",\n                \"about\": \"Visitor pattern for Torque implementations\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ImplementationVisitor {\n                public:\n                    void GenerateClassDebugReaders(const std::string& output_directory);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GlobalContext\",\n                \"about\": \"Global context for Torque compilation\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class GlobalContext {\n                public:\n                    static const std::vector<std::string>& CppIncludes();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"IncludeGuardScope\",\n                \"about\": \"Manages include guards for header files\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class IncludeGuardScope {\n                public:\n                    IncludeGuardScope(std::ostream& os, const std::string& name);\n                    ~IncludeGuardScope();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NamespaceScope\",\n                \"about\": \"Manages namespace scope for C++ code generation\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class NamespaceScope {\n                public:\n                    NamespaceScope(std::ostream& os, const std::vector<std::string>& namespaces);\n                    ~NamespaceScope();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TypeOracle\",\n                \"about\": \"Provides access to pre-defined types\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TypeOracle {\n                public:\n                    static const Type* GetTaggedType();\n                    static const Type* GetVoidType();\n                    static const Type* GetSmiTaggedGeneric();\n                    static const StructType* GetFloat64OrUndefinedOrHoleType();\n                    static const std::vector<const ClassType*>& GetClasses();\n                };\n            ]]></code>\n        </class>\n\n    </dependencies>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueTypeFieldIterator\",\n            \"about\": \"An iterator for use in ValueTypeFieldsRange.\"\n        }\n        </metadata>\n        <code><![CDATA[\nclass ValueTypeFieldIterator {\n public:\n  ValueTypeFieldIterator(const Type* type, size_t index)\n      : type_(type), index_(index) {}\n  struct Result {\n    NameAndType name_and_type;\n    SourcePosition pos;\n    size_t offset_bytes;\n    int num_bits;\n    int shift_bits;\n  };\n  const Result operator*() const {\n    if (auto struct_type = type_->StructSupertype()) {\n      const auto& field = (*struct_type)->fields()[index_];\n      return {field.name_and_type, field.pos, *field.offset, 0, 0};\n    }\n    const Type* type = type_;\n    int bitfield_start_offset = 0;\n    if (const auto type_wrapped_in_smi =\n            Type::MatchUnaryGeneric(type_, TypeOracle::GetSmiTaggedGeneric())) {\n      type = *type_wrapped_in_smi;\n      bitfield_start_offset = TargetArchitecture::SmiTagAndShiftSize();\n    }\n    if (const BitFieldStructType* bit_field_struct_type =\n            BitFieldStructType::DynamicCast(type)) {\n      const auto& field = bit_field_struct_type->fields()[index_];\n      return {field.name_and_type, field.pos, 0, field.num_bits,\n              field.offset + bitfield_start_offset};\n    }\n    UNREACHABLE();\n  }\n  ValueTypeFieldIterator& operator++() {\n    ++index_;\n    return *this;\n  }\n  bool operator==(const ValueTypeFieldIterator& other) const {\n    return type_ == other.type_ && index_ == other.index_;\n  }\n  bool operator!=(const ValueTypeFieldIterator& other) const {\n    return !(*this == other);\n  }\n\n private:\n  const Type* type_;\n  size_t index_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueTypeFieldsRange\",\n            \"about\": \"A way to iterate over the fields of structs or bitfield structs.\"\n        }\n        </metadata>\n        <code><![CDATA[\nclass ValueTypeFieldsRange {\n public:\n  explicit ValueTypeFieldsRange(const Type* type) : type_(type) {}\n  ValueTypeFieldIterator begin() { return {type_, 0}; }\n  ValueTypeFieldIterator end() {\n    size_t index = 0;\n    std::optional<const StructType*> struct_type = type_->StructSupertype();\n    if (struct_type &&\n        *struct_type != TypeOracle::GetFloat64OrUndefinedOrHoleType()) {\n      index = (*struct_type)->fields().size();\n    }\n    const Type* type = type_;\n    if (const auto type_wrapped_in_smi =\n            Type::MatchUnaryGeneric(type_, TypeOracle::GetSmiTaggedGeneric())) {\n      type = *type_wrapped_in_smi;\n    }\n    if (const BitFieldStructType* bit_field_struct_type =\n            BitFieldStructType::DynamicCast(type)) {\n      index = bit_field_struct_type->fields().size();\n    }\n    return {type_, index};\n  }\n\n private:\n  const Type* type_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DebugFieldType\",\n            \"about\": \"A convenient way to keep track of several different ways that we might need to represent a field's type in the generated C++.\"\n        }\n        </metadata>\n        <code><![CDATA[\nclass DebugFieldType {\n public:\n  explicit DebugFieldType(const Field& field)\n      : name_and_type_(field.name_and_type), pos_(field.pos) {}\n  DebugFieldType(const NameAndType& name_and_type, const SourcePosition& pos)\n      : name_and_type_(name_and_type), pos_(pos) {}\n\n  bool IsTagged() const {\n    return name_and_type_.type->IsSubtypeOf(TypeOracle::GetTaggedType());\n  }\n\n  // Returns the type that should be used for this field's value within code\n  // that is compiled as part of the debug helper library. In particular, this\n  // simplifies any tagged type to a plain uintptr_t because the debug helper\n  // compiles without most of the V8 runtime code.\n  std::string GetValueType(TypeStorage storage) const {\n    if (IsTagged()) {\n      return storage == kAsStoredInHeap ? \"i::Tagged_t\" : \"uintptr_t\";\n    }\n\n    // We can't emit a useful error at this point if the constexpr type name is\n    // wrong, but we can include a comment that might be helpful.\n    return GetOriginalType(storage) +\n           \" /*Failing? Ensure constexpr type name is correct, and the \"\n           \"necessary #include is in any .tq file*/\";\n  }\n\n  // Returns the type that should be used to represent a field's type to\n  // debugging tools that have full V8 symbols. The types returned from this\n  // method are resolveable in the v8::internal namespace and may refer to\n  // object types that are not included in the compilation of the debug helper\n  // library.\n  std::string GetOriginalType(TypeStorage storage) const {\n    if (name_and_type_.type->StructSupertype()) {\n      // There's no meaningful type we could use here, because the V8 symbols\n      // don't have any definition of a C++ struct matching this struct type.\n      return \"\";\n    }\n    if (IsTagged()) {\n      std::optional<const ClassType*> field_class_type =\n          name_and_type_.type->ClassSupertype();\n      std::string result =\n          \"v8::internal::\" +\n          (field_class_type.has_value()\n               ? (*field_class_type)->GetGeneratedTNodeTypeName()\n               : \"Object\");\n      if (storage == kAsStoredInHeap) {\n        result = \"v8::internal::TaggedMember<\" + result + \">\";\n      }\n      return result;\n    }\n    return name_and_type_.type->GetConstexprGeneratedTypeName();\n  }\n\n  // Returns a C++ expression that evaluates to a string (type `const char*`)\n  // containing the name of the field's type. The types returned from this\n  // method are resolveable in the v8::internal namespace and may refer to\n  // object types that are not included in the compilation of the debug helper\n  // library.\n  std::string GetTypeString(TypeStorage storage) const {\n    if (IsTagged() || name_and_type_.type->IsStructType()) {\n      // Wrap up the original type in a string literal.\n      return \"\\\"\" + GetOriginalType(storage) + \"\\\"\";\n    }\n\n    // We require constexpr type names to be resolvable in the v8::internal\n    // namespace, according to the contract in debug-helper.h. In order to\n    // verify at compile time that constexpr type names are resolvable, we use\n    // the type name as a dummy template parameter to a function that just\n    // returns its parameter.\n    return \"CheckTypeName<\" + GetValueType(storage) + \">(\\\"\" +\n           GetOriginalType(storage) + \"\\\")\";\n  }\n\n  // Returns the field's size in bytes.\n  size_t GetSize() const {\n    auto opt_size = SizeOf(name_and_type_.type);\n    if (!opt_size.has_value()) {\n      Error(\"Size required for type \", name_and_type_.type->ToString())\n          .Position(pos_);\n      return 0;\n    }\n    return std::get<0>(*opt_size);\n  }\n\n  // Returns the name of the function for getting this field's address.\n  std::string GetAddressGetter() {\n    return \"Get\" + CamelifyString(name_and_type_.name) + \"Address\";\n  }\n\n private:\n  NameAndType name_and_type_;\n  SourcePosition pos_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GenerateFieldAddressAccessor\",\n            \"about\": \"Emits a function to get the address of a field within a class.\",\n            \"parameters\": [\n                {\n                    \"name\": \"field\",\n                    \"type\": \"const Field&\",\n                    \"purpose\": \"The field for which to generate the accessor.\"\n                },\n                {\n                    \"name\": \"class_name\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The name of the class containing the field.\"\n                },\n                {\n                    \"name\": \"h_contents\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for the header file.\"\n                },\n                {\n                    \"name\": \"cc_contents\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for the source file.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"DebugFieldType\",\n                \"CamelifyString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid GenerateFieldAddressAccessor(const Field& field,\n                                  const std::string& class_name,\n                                  std::ostream& h_contents,\n                                  std::ostream& cc_contents) {\n  DebugFieldType debug_field_type(field);\n\n  const std::string address_getter = debug_field_type.GetAddressGetter();\n\n  h_contents << \"  uintptr_t \" << address_getter << \"() const;\\n\";\n  cc_contents << \"\\nuintptr_t Tq\" << class_name << \"::\" << address_getter\n              << \"() const {\\n\";\n  cc_contents << \"  return address_ - i::kHeapObjectTag + \" << *field.offset\n              << \";\\n\";\n  cc_contents << \"}\\n\";\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GenerateFieldValueAccessor\",\n            \"about\": \"Emits a function to get the value of a field.\",\n            \"parameters\": [\n                {\n                    \"name\": \"field\",\n                    \"type\": \"const Field&\",\n                    \"purpose\": \"The field for which to generate the accessor.\"\n                },\n                {\n                    \"name\": \"class_name\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The name of the class containing the field.\"\n                },\n                {\n                    \"name\": \"h_contents\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for the header file.\"\n                },\n                {\n                    \"name\": \"cc_contents\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for the source file.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"DebugFieldType\",\n                \"CamelifyString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid GenerateFieldValueAccessor(const Field& field,\n                                const std::string& class_name,\n                                std::ostream& h_contents,\n                                std::ostream& cc_contents) {\n  // Currently not implemented for struct fields.\n  if (field.name_and_type.type->StructSupertype()) return;\n\n  DebugFieldType debug_field_type(field);\n\n  const std::string address_getter = debug_field_type.GetAddressGetter();\n  const std::string field_getter =\n      \"Get\" + CamelifyString(field.name_and_type.name) + \"Value\";\n\n  std::string index_param;\n  std::string index_offset;\n  if (field.index) {\n    index_param = \", size_t offset\";\n    index_offset = \" + offset * sizeof(value)\";\n  }\n\n  std::string field_value_type = debug_field_type.GetValueType(kUncompressed);\n  h_contents << \"  Value<\" << field_value_type << \"> \" << field_getter\n             << \"(d::MemoryAccessor accessor \" << index_param << \") const;\\n\";\n  cc_contents << \"\\nValue<\" << field_value_type << \"> Tq\" << class_name\n              << \"::\" << field_getter << \"(d::MemoryAccessor accessor\"\n              << index_param << \") const {\\n\";\n  cc_contents << \"  \" << debug_field_type.GetValueType(kAsStoredInHeap)\n              << \" value{};\\n\";\n  cc_contents << \"  d::MemoryAccessResult validity = accessor(\"\n              << address_getter << \"()\" << index_offset\n              << \", reinterpret_cast<uint8_t*>(&value), sizeof(value));\\n\";\n#ifdef V8_MAP_PACKING\n  if (field_getter == \"GetMapValue\") {\n    cc_contents << \"  value = i::MapWord::Unpack(value);\\n\";\n  }\n#endif\n  cc_contents << \"  return {validity, \"\n              << (debug_field_type.IsTagged()\n                      ? \"EnsureDecompressed(value, address_)\"\n                      : \"value\")\n              << \"};\\n\";\n  cc_contents << \"}\\n\";\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GenerateGetPropsChunkForField\",\n            \"about\": \"Emits a portion of the member function GetProperties that is responsible for adding data about the current field to a result vector called \\\"result\\\".\",\n            \"parameters\": [\n                {\n                    \"name\": \"field\",\n                    \"type\": \"const Field&\",\n                    \"purpose\": \"The field for which to generate the property chunk.\"\n                },\n                {\n                    \"name\": \"get_props_impl\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream to write the property chunk implementation.\"\n                },\n                {\n                    \"name\": \"class_name\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The name of the class.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"DebugFieldType\",\n                \"ValueTypeFieldsRange\",\n                \"CamelifyString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid GenerateGetPropsChunkForField(const Field& field,\n                                   std::ostream& get_props_impl,\n                                   std::string class_name) {\n  DebugFieldType debug_field_type(field);\n\n  // If the current field is a struct or bitfield struct, create a vector\n  // describing its fields. Otherwise this vector will be empty.\n  std::string struct_field_list =\n      field.name_and_type.name + \"_struct_field_list\";\n  get_props_impl << \"  std::vector<std::unique_ptr<StructProperty>> \"\n                 << struct_field_list << \";\\n\";\n  for (const auto& struct_field :\n       ValueTypeFieldsRange(field.name_and_type.type)) {\n    DebugFieldType struct_field_type(struct_field.name_and_type,\n                                     struct_field.pos);\n    get_props_impl << \"  \" << struct_field_list\n                   << \".push_back(std::make_unique<StructProperty>(\\\"\"\n                   << struct_field.name_and_type.name << \"\\\", \"\n                   << struct_field_type.GetTypeString(kAsStoredInHeap) << \", \"\n                   << struct_field.offset_bytes << \", \" << struct_field.num_bits\n                   << \", \" << struct_field.shift_bits << \"));\\n\";\n  }\n  struct_field_list = \"std::move(\" + struct_field_list + \")\";\n\n  // The number of values and property kind for non-indexed properties:\n  std::string count_value = \"1\";\n  std::string property_kind = \"d::PropertyKind::kSingle\";\n\n  // If the field is indexed, emit a fetch of the array length, and change\n  // count_value and property_kind to be the correct values for an array.\n  if (field.index) {\n    std::string indexed_field_slice =\n        \"indexed_field_slice_\" + field.name_and_type.name;\n    get_props_impl << \"  auto \" << indexed_field_slice << \" = \"\n                   << \"TqDebugFieldSlice\" << class_name\n                   << CamelifyString(field.name_and_type.name)\n                   << \"(accessor, address_);\\n\";\n    std::string validity = indexed_field_slice + \".validity\";\n    std::string value = indexed_field_slice + \".value\";\n    property_kind = \"GetArrayKind(\" + validity + \")\";\n\n    get_props_impl << \"  if (\" << validity\n                   << \" == d::MemoryAccessResult::kOk) {\\n\"\n                   << \"    result.push_back(std::make_unique<ObjectProperty>(\\\"\"\n                   << field.name_and_type.name << \"\\\", \"\n                   << debug_field_type.GetTypeString(kAsStoredInHeap) << \", \"\n                   << \"address_ - i::kHeapObjectTag + std::get<1>(\" << value\n                   << \"), \"\n                   << \"std::get<2>(\" << value << \")\"\n                   << \", \" << debug_field_type.GetSize() << \", \"\n                   << struct_field_list << \", \" << property_kind << \"));\\n\"\n                   << \"  }\\n\";\n    return;\n  }\n  get_props_impl << \"  result.push_back(std::make_unique<ObjectProperty>(\\\"\"\n                 << field.name_and_type.name << \"\\\", \"\n                 << debug_field_type.GetTypeString(kAsStoredInHeap) << \", \"\n                 << debug_field_type.GetAddressGetter() << \"(), \" << count_value\n                 << \", \" << debug_field_type.GetSize() << \", \"\n                 << struct_field_list << \", \" << property_kind << \"));\\n\";\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GenerateClassDebugReader\",\n            \"about\": \"Generates a class TqFoo which allows for convenient inspection of objects of type Foo.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"const ClassType&\",\n                    \"purpose\": \"The class type to generate the debug reader for.\"\n                },\n                {\n                    \"name\": \"h_contents\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for the header file.\"\n                },\n                {\n                    \"name\": \"cc_contents\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for the source file.\"\n                },\n                {\n                    \"name\": \"visitor\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for the TqObjectVisitor definition.\"\n                },\n                {\n                    \"name\": \"done\",\n                    \"type\": \"std::unordered_set<const ClassType*>*\",\n                    \"purpose\": \"Set to keep track of already generated classes.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ClassType\",\n                \"GenerateClassDebugReader\",\n                \"DebugFieldType\",\n                \"GenerateFieldAddressAccessor\",\n                \"GenerateFieldValueAccessor\",\n                \"GenerateGetPropsChunkForField\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid GenerateClassDebugReader(const ClassType& type, std::ostream& h_contents,\n                              std::ostream& cc_contents, std::ostream& visitor,\n                              std::unordered_set<const ClassType*>* done) {\n  // Make sure each class only gets generated once.\n  if (!done->insert(&type).second) return;\n  const ClassType* super_type = type.GetSuperClass();\n\n  // We must emit the classes in dependency order. If the super class hasn't\n  // been emitted yet, go handle it first.\n  if (super_type != nullptr) {\n    GenerateClassDebugReader(*super_type, h_contents, cc_contents, visitor,\n                             done);\n  }\n\n  // Classes with undefined layout don't grant any particular value here and may\n  // not correspond with actual C++ classes, so skip them.\n  if (type.HasUndefinedLayout()) return;\n\n  const std::string name = type.name();\n  const std::string super_name =\n      super_type == nullptr ? \"Object\" : super_type->name();\n  h_contents << \"\\nclass Tq\" << name << \" : public Tq\" << super_name << \" {\\n\";\n  h_contents << \" public:\\n\";\n  h_contents << \"  inline Tq\" << name << \"(uintptr_t address) : Tq\"\n             << super_name << \"(address) {}\\n\";\n  h_contents << kTqObjectOverrideDecls;\n\n  cc_contents << \"\\nconst char* Tq\" << name << \"::GetName() const {\\"
}