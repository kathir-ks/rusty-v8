{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/roots/roots.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 85, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/roots/roots.cc\",\n        \"file_name\": \"roots.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the RootsTable and ReadOnlyRoots classes for accessing commonly used objects in the V8 heap.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for root management, object manipulation, and assertions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/roots/roots.h\"\n\n#include <type_traits>\n\n#include \"src/common/globals.h\"\n#include \"src/objects/elements-kind.h\"\n#include \"src/objects/heap-object-inl.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/visitors.h\"\n#include \"src/roots/static-roots.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RootsTable\",\n            \"about\": \"Provides a table of root names.\",\n            \"attributes\": [\n                {\n                    \"name\": \"root_names_\",\n                    \"type\": \"const char* []\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of root names\"\n                }\n            ],\n            \"dependencies\": [\n                \"RootIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nconst char* RootsTable::root_names_[RootsTable::kEntriesCount] = {\n#define ROOT_NAME(type, name, CamelName) #name,\n    ROOT_LIST(ROOT_NAME)\n#undef ROOT_NAME\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FindHeapNumber\",\n            \"parent\": \"RootsTable\",\n            \"about\": \"Finds a HeapNumber root with a specific double value.\",\n            \"logic\": \"Iterates through the HeapNumber roots and compares their values with the given value using bitwise comparison.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"double\",\n                    \"purpose\": \"The double value to search for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"IndirectHandle<HeapNumber>\",\n                \"description\": \"An IndirectHandle to the HeapNumber if found, otherwise an empty IndirectHandle.\"\n            },\n            \"dependencies\": [\n                \"HeapNumber\",\n                \"RootIndex\",\n                \"Object\",\n                \"Tagged\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nIndirectHandle<HeapNumber> RootsTable::FindHeapNumber(double value) {\n  auto bits = base::bit_cast<uint64_t>(value);\n  for (auto pos = RootIndex::kFirstHeapNumberRoot;\n       pos <= RootIndex::kLastHeapNumberRoot; ++pos) {\n    auto root = Cast<HeapNumber>(Tagged<Object>((*this)[pos]));\n    if (base::bit_cast<uint64_t>(root->value()) == bits) {\n      return IndirectHandle<HeapNumber>(&(*this)[pos]);\n    }\n  }\n  return {};\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ReadOnlyRoots\",\n            \"about\": \"Provides access to read-only roots.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"one_pointer_filler_map_word\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Returns a MapWord for the one pointer filler map.\",\n            \"return\": {\n                \"type\": \"MapWord\",\n                \"description\": \"The MapWord for the one pointer filler map.\"\n            },\n            \"dependencies\": [\n                \"MapWord\",\n                \"one_pointer_filler_map\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMapWord ReadOnlyRoots::one_pointer_filler_map_word() {\n  return MapWord::FromMap(one_pointer_filler_map());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Iterate\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Iterates through the read-only roots and visits them using a RootVisitor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"visitor\",\n                    \"type\": \"RootVisitor*\",\n                    \"purpose\": \"The visitor to use for visiting the roots.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"RootVisitor\",\n                \"Root\",\n                \"FullObjectSlot\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ReadOnlyRoots::Iterate(RootVisitor* visitor) {\n  visitor->VisitRootPointers(Root::kReadOnlyRootList, nullptr,\n                             FullObjectSlot(read_only_roots_),\n                             FullObjectSlot(&read_only_roots_[kEntriesCount]));\n  visitor->Synchronize(VisitorSynchronization::kReadOnlyRootList);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VerifyNameForProtectors\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Verifies that the Name objects for protectors are correctly laid out in memory.\",\n            \"logic\": \"Checks adjacency and alignment of Name objects within a specific range of root indices.\",\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Name\",\n                \"RootIndex\",\n                \"Object\",\n                \"Tagged\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nvoid ReadOnlyRoots::VerifyNameForProtectors() {\n  DisallowGarbageCollection no_gc;\n  Tagged<Name> prev;\n  for (RootIndex root_index = RootIndex::kFirstNameForProtector;\n       root_index <= RootIndex::kLastNameForProtector; ++root_index) {\n    Tagged<Name> current = Cast<Name>(object_at(root_index));\n    DCHECK(IsNameForProtector(current));\n    if (root_index != RootIndex::kFirstNameForProtector) {\n      // Make sure the objects are adjacent in memory.\n      CHECK_LT(prev.address(), current.address());\n      Address computed_address =\n          prev.address() + ALIGN_TO_ALLOCATION_ALIGNMENT(prev->Size());\n      CHECK_EQ(computed_address, current.address());\n    }\n    prev = current;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VerifyTypes\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Verifies the types of the read-only roots.\",\n            \"logic\": \"Uses a macro to generate type checking functions for each read-only root and then calls these functions to verify the types.\",\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Undefined\",\n                \"Null\",\n                \"True\",\n                \"False\",\n                \"Oddball\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n#define ROOT_TYPE_CHECK(Type, name, CamelName)                                \\\n  bool CheckType_##name(Tagged<Type> value) {                                 \\\n    /* For the oddball subtypes, the \"IsFoo\" checks only check for address in \\\n     * the RORoots, which is trivially true here. So, do a slow check of the  \\\n     * oddball kind instead. Do the casts via Tagged<Object> to satisfy cast  \\\n     * compatibility static_asserts in the Tagged class. */                   \\\n    if (std::is_same_v<Type, Undefined>) {                                    \\\n      return Cast<Oddball>(Tagged<Object>(value))->kind() ==                  \\\n             Oddball::kUndefined;                                             \\\n    } else if (std::is_same_v<Type, Null>) {                                  \\\n      return Cast<Oddball>(Tagged<Object>(value))->kind() == Oddball::kNull;  \\\n    } else if (std::is_same_v<Type, True>) {                                  \\\n      return Cast<Oddball>(Tagged<Object>(value))->kind() == Oddball::kTrue;  \\\n    } else if (std::is_same_v<Type, False>) {                                 \\\n      return Cast<Oddball>(Tagged<Object>(value))->kind() == Oddball::kFalse; \\\n    } else {                                                                  \\\n      return Is##Type(value);                                                 \\\n    }                                                                         \\\n  }\n\nREAD_ONLY_ROOT_LIST(ROOT_TYPE_CHECK)\n#undef ROOT_TYPE_CHECK\n}  // namespace\n\nvoid ReadOnlyRoots::VerifyTypes() {\n  DisallowGarbageCollection no_gc;\n#define ROOT_TYPE_CHECK(Type, name, CamelName) CHECK(CheckType_##name(name()));\n\n  READ_ONLY_ROOT_LIST(ROOT_TYPE_CHECK)\n#undef ROOT_TYPE_CHECK\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitFromStaticRootsTable\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Initializes the read-only roots from a static roots table.\",\n            \"logic\": \"Iterates through the static roots table, decompresses the tagged pointers, and assigns them to the corresponding read-only roots.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cage_base\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The base address of the memory cage.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"RootIndex\",\n                \"V8HeapCompressionScheme\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ReadOnlyRoots::InitFromStaticRootsTable(Address cage_base) {\n  CHECK(V8_STATIC_ROOTS_BOOL);\n#if V8_STATIC_ROOTS_BOOL\n  RootIndex pos = RootIndex::kFirstReadOnlyRoot;\n  for (auto element : StaticReadOnlyRootsPointerTable) {\n    auto ptr = V8HeapCompressionScheme::DecompressTagged(cage_base, element);\n    DCHECK(!is_initialized(pos));\n    read_only_roots_[static_cast<size_t>(pos)] = ptr;\n    ++pos;\n  }\n  DCHECK_EQ(static_cast<int>(pos) - 1, RootIndex::kLastReadOnlyRoot);\n#endif  // V8_STATIC_ROOTS_BOOL\n}\n        ]]></code>\n    </func>\n</file>\n```"
}