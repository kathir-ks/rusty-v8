{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/all-nodes.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 46, column 48",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/all-nodes.cc\",\n            \"file_name\": \"all-nodes.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the AllNodes class, which finds all nodes reachable from a given node in a graph, either only through inputs or also through uses.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Provides the definition of the AllNodes class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/all-nodes.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Provides the definition of the TFGraph class.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turbofan-graph.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AllNodes\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Finds all nodes reachable from a given node in a graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"reachable\",\n                        \"type\": \"ZoneVector<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector containing all reachable nodes.\"\n                    },\n                    {\n                        \"name\": \"is_reachable_\",\n                        \"type\": \"ZoneSet<int>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A set to efficiently check if a node is reachable.\"\n                    },\n                    {\n                        \"name\": \"only_inputs_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A flag indicating whether to only consider inputs or also uses.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Zone\",\n                    \"TFGraph\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass AllNodes {\n public:\n  AllNodes(Zone* local_zone, const TFGraph* graph, bool only_inputs);\n  AllNodes(Zone* local_zone, Node* end, const TFGraph* graph,\n                   bool only_inputs);\n\n  void Mark(Zone* local_zone, Node* end, const TFGraph* graph);\n\n private:\n  ZoneVector<Node*> reachable;\n  ZoneSet<int> is_reachable_;\n  bool only_inputs_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constructor\",\n                \"name\": \"AllNodes\",\n                \"parent\": \"AllNodes\",\n                \"about\": \"Constructs an AllNodes object and marks all reachable nodes from the end node of the graph.\",\n                \"logic\": \"Initializes the reachable nodes set and vector and calls the Mark method to find all reachable nodes. This constructor starts from the graph's end node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"local_zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone to allocate memory in.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const TFGraph*\",\n                        \"purpose\": \"The graph to traverse.\"\n                    },\n                    {\n                        \"name\": \"only_inputs\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Whether to only consider inputs or also uses.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"TFGraph\",\n                    \"Node\",\n                    \"Mark\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nAllNodes::AllNodes(Zone* local_zone, const TFGraph* graph, bool only_inputs)\n    : reachable(local_zone),\n      is_reachable_(static_cast<int>(graph->NodeCount()), local_zone),\n      only_inputs_(only_inputs) {\n  Mark(local_zone, graph->end(), graph);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constructor\",\n                \"name\": \"AllNodes\",\n                \"parent\": \"AllNodes\",\n                \"about\": \"Constructs an AllNodes object and marks all reachable nodes from a specified end node.\",\n                \"logic\": \"Initializes the reachable nodes set and vector and calls the Mark method to find all reachable nodes, starting from the provided `end` node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"local_zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone to allocate memory in.\"\n                    },\n                    {\n                        \"name\": \"end\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to start the search from.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const TFGraph*\",\n                        \"purpose\": \"The graph to traverse.\"\n                    },\n                    {\n                        \"name\": \"only_inputs\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Whether to only consider inputs or also uses.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"TFGraph\",\n                    \"Node\",\n                    \"Mark\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nAllNodes::AllNodes(Zone* local_zone, Node* end, const TFGraph* graph,\n                   bool only_inputs)\n    : reachable(local_zone),\n      is_reachable_(static_cast<int>(graph->NodeCount()), local_zone),\n      only_inputs_(only_inputs) {\n  Mark(local_zone, end, graph);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Mark\",\n                \"parent\": \"AllNodes\",\n                \"about\": \"Marks all nodes reachable from a given end node in the graph.\",\n                \"logic\": \"Performs a breadth-first search to find all nodes reachable from the end node, adding them to the reachable set and vector. It iterates through the reachable nodes, processing their inputs and, depending on the `only_inputs_` flag, their uses. Checks for null inputs and invalid use IDs.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"local_zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone to allocate memory in.\"\n                    },\n                    {\n                        \"name\": \"end\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to start the search from.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const TFGraph*\",\n                        \"purpose\": \"The graph to traverse.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"TFGraph\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AllNodes::Mark(Zone* local_zone, Node* end, const TFGraph* graph) {\n  DCHECK_LT(end->id(), graph->NodeCount());\n  is_reachable_.Add(end->id());\n  reachable.push_back(end);\n  // Find all nodes reachable from {end}.\n  for (size_t i = 0; i < reachable.size(); i++) {\n    for (Node* const input : reachable[i]->inputs()) {\n      if (input == nullptr) {\n        // TODO(titzer): print a warning.\n        continue;\n      }\n      if (!is_reachable_.Contains(input->id())) {\n        is_reachable_.Add(input->id());\n        reachable.push_back(input);\n      }\n    }\n    if (!only_inputs_) {\n      for (Node* use : reachable[i]->uses()) {\n        if (use == nullptr || use->id() >= graph->NodeCount()) {\n          continue;\n        }\n        if (!is_reachable_.Contains(use->id())) {\n          is_reachable_.Add(use->id());\n          reachable.push_back(use);\n        }\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n</file>\n```"
}