{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/duplication-optimization-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 247, column 48",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/duplication-optimization-reducer.h\",\n            \"file_name\": \"duplication-optimization-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the DuplicationOptimizationReducer class for the Turboshaft compiler, which introduces duplication of code to improve code generation, especially for branches and load/store operations on ARM64.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for assembler, graph, index, operations, and value numbering reducer in the Turboshaft compiler.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/value-numbering-reducer.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DuplicationOptimizationReducer\",\n                \"extends\": \"Next\",\n                \"about\": \"Reducer that duplicates code for optimization purposes, specifically for branch conditions and load/store index calculations.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Next\",\n                    \"BranchOp\",\n                    \"SelectOp\",\n                    \"LoadOp\",\n                    \"StoreOp\",\n                    \"OpIndex\",\n                    \"OptionalOpIndex\",\n                    \"MemoryRepresentation\",\n                    \"RegisterRepresentation\",\n                    \"WriteBarrierKind\",\n                    \"IndirectPointerTag\",\n                    \"ComparisonOp\",\n                    \"WordBinopOp\",\n                    \"ShiftOp\",\n                    \"WordRepresentation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass DuplicationOptimizationReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(DuplucationOptimization)\n\n  V<None> REDUCE_INPUT_GRAPH(Branch)(V<None> ig_index, const BranchOp& branch) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphBranch(ig_index, branch);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    const Operation& cond = __ input_graph().Get(branch.condition());\n    V<Word32> new_cond;\n    if (!MaybeDuplicateCond(cond, branch.condition(), &new_cond)) {\n      goto no_change;\n    }\n\n    DCHECK(new_cond.valid());\n    __ Branch(new_cond, __ MapToNewGraph(branch.if_true),\n              __ MapToNewGraph(branch.if_false), branch.hint);\n    return V<None>::Invalid();\n  }\n\n  V<Any> REDUCE_INPUT_GRAPH(Select)(V<Any> ig_index, const SelectOp& select) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphSelect(ig_index, select);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    const Operation& cond = __ input_graph().Get(select.cond());\n    V<Word32> new_cond;\n    if (!MaybeDuplicateCond(cond, select.cond(), &new_cond)) goto no_change;\n\n    DCHECK(new_cond.valid());\n    return __ Select(new_cond, __ MapToNewGraph(select.vtrue()),\n                     __ MapToNewGraph(select.vfalse()), select.rep, select.hint,\n                     select.implem);\n  }\n\n#if V8_TARGET_ARCH_ARM64\n  // TODO(dmercadier): duplicating a shift to use a flexible second operand is\n  // not always worth it; this depends mostly on the CPU, the kind of shift, and\n  // the size of the loaded/stored data. Ideally, we would have cost models for\n  // all the CPUs we target, and use those to decide to duplicate shifts or not.\n  OpIndex REDUCE(Load)(OpIndex base, OptionalOpIndex index, LoadOp::Kind kind,\n                       MemoryRepresentation loaded_rep,\n                       RegisterRepresentation result_rep, int32_t offset,\n                       uint8_t element_size_log2) {\n    if (offset == 0 && element_size_log2 == 0 && index.valid()) {\n      index = MaybeDuplicateOutputGraphShift(index.value());\n    }\n    return Next::ReduceLoad(base, index, kind, loaded_rep, result_rep, offset,\n                            element_size_log2);\n  }\n\n  OpIndex REDUCE(Store)(OpIndex base, OptionalOpIndex index, OpIndex value,\n                        StoreOp::Kind kind, MemoryRepresentation stored_rep,\n                        WriteBarrierKind write_barrier, int32_t offset,\n                        uint8_t element_size_log2,\n                        bool maybe_initializing_or_transitioning,\n                        IndirectPointerTag maybe_indirect_pointer_tag) {\n    if (offset == 0 && element_size_log2 == 0 && index.valid()) {\n      index = MaybeDuplicateOutputGraphShift(index.value());\n    }\n    return Next::ReduceStore(base, index, value, kind, stored_rep,\n                             write_barrier, offset, element_size_log2,\n                             maybe_initializing_or_transitioning,\n                             maybe_indirect_pointer_tag);\n  }\n#endif\n\n private:\n  bool MaybeDuplicateCond(const Operation& cond, OpIndex input_idx,\n                          V<Word32>* new_cond) {\n    if (cond.saturated_use_count.IsOne()) return false;\n\n    switch (cond.opcode) {\n      case Opcode::kComparison:\n        *new_cond =\n            MaybeDuplicateComparison(cond.Cast<ComparisonOp>(), input_idx);\n        break;\n      case Opcode::kWordBinop:\n        *new_cond =\n            MaybeDuplicateWordBinop(cond.Cast<WordBinopOp>(), input_idx);\n        break;\n      case Opcode::kShift:\n        *new_cond = MaybeDuplicateShift(cond.Cast<ShiftOp>(), input_idx);\n        break;\n      default:\n        return false;\n    }\n    return new_cond->valid();\n  }\n\n  bool MaybeCanDuplicateGenericBinop(OpIndex input_idx, OpIndex left,\n                                     OpIndex right) {\n    if (__ input_graph().Get(left).saturated_use_count.IsOne() &&\n        __ input_graph().Get(right).saturated_use_count.IsOne()) {\n      // We don't duplicate binops when all of their inputs are used a single\n      // time (this would increase register pressure by keeping 2 values alive\n      // instead of 1).\n      return false;\n    }\n    OpIndex binop_output_idx = __ MapToNewGraph(input_idx);\n    if (__ Get(binop_output_idx).saturated_use_count.IsZero()) {\n      // This is the 1st use of {binop} in the output graph, so there is no need\n      // to duplicate it just yet.\n      return false;\n    }\n    return true;\n  }\n\n  OpIndex MaybeDuplicateWordBinop(const WordBinopOp& binop, OpIndex input_idx) {\n    if (!MaybeCanDuplicateGenericBinop(input_idx, binop.left(),\n                                       binop.right())) {\n      return OpIndex::Invalid();\n    }\n\n    switch (binop.kind) {\n      case WordBinopOp::Kind::kSignedDiv:\n      case WordBinopOp::Kind::kUnsignedDiv:\n      case WordBinopOp::Kind::kSignedMod:\n      case WordBinopOp::Kind::kUnsignedMod:\n        // These operations are somewhat expensive, and duplicating them is\n        // probably not worth it.\n        return OpIndex::Invalid();\n      default:\n        break;\n    }\n\n    DisableValueNumbering disable_gvn(this);\n    return __ WordBinop(__ MapToNewGraph(binop.left()),\n                        __ MapToNewGraph(binop.right()), binop.kind, binop.rep);\n  }\n\n  V<Word32> MaybeDuplicateComparison(const ComparisonOp& comp,\n                                     OpIndex input_idx) {\n    if (!MaybeCanDuplicateGenericBinop(input_idx, comp.left(), comp.right())) {\n      return {};\n    }\n\n    DisableValueNumbering disable_gvn(this);\n    return __ Comparison(__ MapToNewGraph(comp.left()),\n                         __ MapToNewGraph(comp.right()), comp.kind, comp.rep);\n  }\n\n  OpIndex MaybeDuplicateShift(const ShiftOp& shift, OpIndex input_idx) {\n    if (!MaybeCanDuplicateGenericBinop(input_idx, shift.left(),\n                                       shift.right())) {\n      return OpIndex::Invalid();\n    }\n\n    DisableValueNumbering disable_gvn(this);\n    return __ Shift(__ MapToNewGraph(shift.left()),\n                    __ MapToNewGraph(shift.right()), shift.kind, shift.rep);\n  }\n\n  OpIndex MaybeDuplicateOutputGraphShift(OpIndex index) {\n    V<Word> shifted;\n    int shifted_by;\n    ShiftOp::Kind shift_kind;\n    WordRepresentation shift_rep;\n    if (__ matcher().MatchConstantShift(index, &shifted, &shift_kind,\n                                        &shift_rep, &shifted_by) &&\n        !__ matcher().Get(index).saturated_use_count.IsZero()) {\n      // We don't check the use count of {shifted}, because it might have uses\n      // in the future that haven't been emitted yet.\n      DisableValueNumbering disable_gvn(this);\n      return __ Shift(shifted, __ Word32Constant(shifted_by), shift_kind,\n                      shift_rep);\n    }\n    return index;\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE_INPUT_GRAPH(Branch)\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Reduces a Branch operation by potentially duplicating its condition.\",\n                \"logic\": \"Checks if the branch condition can be duplicated. If so, duplicates the condition and creates a new Branch operation with the duplicated condition. This helps improve code generation by allowing the instruction selector to generate more efficient code for branches.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_index\",\n                        \"type\": \"V<None>\",\n                        \"purpose\": \"Index of the input graph.\"\n                    },\n                    {\n                        \"name\": \"branch\",\n                        \"type\": \"const BranchOp&\",\n                        \"purpose\": \"The Branch operation to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<None>\",\n                    \"description\": \"Returns an invalid V<None> if the branch was successfully reduced (condition duplicated), otherwise calls the base class implementation.\"\n                },\n                \"dependencies\": [\n                    \"BranchOp\",\n                    \"Operation\",\n                    \"MaybeDuplicateCond\",\n                    \"__ input_graph\",\n                    \"__ MapToNewGraph\",\n                    \"__ Branch\",\n                    \"DCHECK\",\n                    \"ShouldSkipOptimizationStep\",\n                    \"Next::ReduceInputGraphBranch\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<None> REDUCE_INPUT_GRAPH(Branch)(V<None> ig_index, const BranchOp& branch) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphBranch(ig_index, branch);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    const Operation& cond = __ input_graph().Get(branch.condition());\n    V<Word32> new_cond;\n    if (!MaybeDuplicateCond(cond, branch.condition(), &new_cond)) {\n      goto no_change;\n    }\n\n    DCHECK(new_cond.valid());\n    __ Branch(new_cond, __ MapToNewGraph(branch.if_true),\n              __ MapToNewGraph(branch.if_false), branch.hint);\n    return V<None>::Invalid();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE_INPUT_GRAPH(Select)\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Reduces a Select operation by potentially duplicating its condition.\",\n                \"logic\": \"Similar to branch condition duplication, this function checks if the select condition can be duplicated. If so, duplicates the condition and creates a new Select operation with the duplicated condition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_index\",\n                        \"type\": \"V<Any>\",\n                        \"purpose\": \"Index of the input graph.\"\n                    },\n                    {\n                        \"name\": \"select\",\n                        \"type\": \"const SelectOp&\",\n                        \"purpose\": \"The Select operation to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<Any>\",\n                    \"description\": \"Returns the new Select operation if the condition was successfully duplicated, otherwise calls the base class implementation.\"\n                },\n                \"dependencies\": [\n                    \"SelectOp\",\n                    \"Operation\",\n                    \"MaybeDuplicateCond\",\n                    \"__ input_graph\",\n                    \"__ MapToNewGraph\",\n                    \"__ Select\",\n                    \"DCHECK\",\n                    \"ShouldSkipOptimizationStep\",\n                    \"Next::ReduceInputGraphSelect\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<Any> REDUCE_INPUT_GRAPH(Select)(V<Any> ig_index, const SelectOp& select) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphSelect(ig_index, select);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    const Operation& cond = __ input_graph().Get(select.cond());\n    V<Word32> new_cond;\n    if (!MaybeDuplicateCond(cond, select.cond(), &new_cond)) goto no_change;\n\n    DCHECK(new_cond.valid());\n    return __ Select(new_cond, __ MapToNewGraph(select.vtrue()),\n                     __ MapToNewGraph(select.vfalse()), select.rep, select.hint,\n                     select.implem);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE(Load)\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Reduces a Load operation by potentially duplicating the index.\",\n                \"logic\": \"If the offset and element size are 0 and the index is valid, it attempts to duplicate the shift operation used as the index. This is specific to ARM64 and allows the instruction selector to use flexible second operands.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"base\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Base address of the load.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"OptionalOpIndex\",\n                        \"purpose\": \"Optional index for the load.\"\n                    },\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"LoadOp::Kind\",\n                        \"purpose\": \"Kind of load operation.\"\n                    },\n                    {\n                        \"name\": \"loaded_rep\",\n                        \"type\": \"MemoryRepresentation\",\n                        \"purpose\": \"Memory representation of the loaded data.\"\n                    },\n                    {\n                        \"name\": \"result_rep\",\n                        \"type\": \"RegisterRepresentation\",\n                        \"purpose\": \"Register representation of the result.\"\n                    },\n                    {\n                        \"name\": \"offset\",\n                        \"type\": \"int32_t\",\n                        \"purpose\": \"Offset from the base address.\"\n                    },\n                    {\n                        \"name\": \"element_size_log2\",\n                        \"type\": \"uint8_t\",\n                        \"purpose\": \"Log2 of the element size.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The OpIndex of the reduced Load operation.\"\n                },\n                \"dependencies\": [\n                    \"LoadOp\",\n                    \"OptionalOpIndex\",\n                    \"MemoryRepresentation\",\n                    \"RegisterRepresentation\",\n                    \"MaybeDuplicateOutputGraphShift\",\n                    \"Next::ReduceLoad\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_TARGET_ARCH_ARM64\n  // TODO(dmercadier): duplicating a shift to use a flexible second operand is\n  // not always worth it; this depends mostly on the CPU, the kind of shift, and\n  // the size of the loaded/stored data. Ideally, we would have cost models for\n  // all the CPUs we target, and use those to decide to duplicate shifts or not.\n  OpIndex REDUCE(Load)(OpIndex base, OptionalOpIndex index, LoadOp::Kind kind,\n                       MemoryRepresentation loaded_rep,\n                       RegisterRepresentation result_rep, int32_t offset,\n                       uint8_t element_size_log2) {\n    if (offset == 0 && element_size_log2 == 0 && index.valid()) {\n      index = MaybeDuplicateOutputGraphShift(index.value());\n    }\n    return Next::ReduceLoad(base, index, kind, loaded_rep, result_rep, offset,\n                            element_size_log2);\n  }\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE(Store)\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Reduces a Store operation by potentially duplicating the index.\",\n                \"logic\": \"Similar to Load, if the offset and element size are 0 and the index is valid, it attempts to duplicate the shift operation used as the index for Store operations on ARM64.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"base\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Base address of the store.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"OptionalOpIndex\",\n                        \"purpose\": \"Optional index for the store.\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Value to store.\"\n                    },\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"StoreOp::Kind\",\n                        \"purpose\": \"Kind of store operation.\"\n                    },\n                    {\n                        \"name\": \"stored_rep\",\n                        \"type\": \"MemoryRepresentation\",\n                        \"purpose\": \"Memory representation of the stored data.\"\n                    },\n                    {\n                        \"name\": \"write_barrier\",\n                        \"type\": \"WriteBarrierKind\",\n                        \"purpose\": \"Write barrier kind.\"\n                    },\n                    {\n                        \"name\": \"offset\",\n                        \"type\": \"int32_t\",\n                        \"purpose\": \"Offset from the base address.\"\n                    },\n                    {\n                        \"name\": \"element_size_log2\",\n                        \"type\": \"uint8_t\",\n                        \"purpose\": \"Log2 of the element size.\"\n                    },\n                    {\n                        \"name\": \"maybe_initializing_or_transitioning\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the store is initializing or transitioning.\"\n                    },\n                    {\n                        \"name\": \"maybe_indirect_pointer_tag\",\n                        \"type\": \"IndirectPointerTag\",\n                        \"purpose\": \"Indirect pointer tag.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The OpIndex of the reduced Store operation.\"\n                },\n                \"dependencies\": [\n                    \"StoreOp\",\n                    \"OptionalOpIndex\",\n                    \"MemoryRepresentation\",\n                    \"WriteBarrierKind\",\n                    \"IndirectPointerTag\",\n                    \"MaybeDuplicateOutputGraphShift\",\n                    \"Next::ReduceStore\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  OpIndex REDUCE(Store)(OpIndex base, OptionalOpIndex index, OpIndex value,\n                        StoreOp::Kind kind, MemoryRepresentation stored_rep,\n                        WriteBarrierKind write_barrier, int32_t offset,\n                        uint8_t element_size_log2,\n                        bool maybe_initializing_or_transitioning,\n                        IndirectPointerTag maybe_indirect_pointer_tag) {\n    if (offset == 0 && element_size_log2 == 0 && index.valid()) {\n      index = MaybeDuplicateOutputGraphShift(index.value());\n    }\n    return Next::ReduceStore(base, index, value, kind, stored_rep,\n                             write_barrier, offset, element_size_log2,\n                             maybe_initializing_or_transitioning,\n                             maybe_indirect_pointer_tag);\n  }\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MaybeDuplicateCond\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Determines if a condition can be duplicated and performs the duplication if possible.\",\n                \"logic\": \"Checks if the condition's use count is greater than one. If so, it attempts to duplicate the condition based on its opcode (Comparison, WordBinop, or Shift).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cond\",\n                        \"type\": \"const Operation&\",\n                        \"purpose\": \"The condition operation.\"\n                    },\n                    {\n                        \"name\": \"input_idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the input condition.\"\n                    },\n                    {\n                        \"name\": \"new_cond\",\n                        \"type\": \"V<Word32>*\",\n                        \"purpose\": \"Pointer to store the duplicated condition.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the condition was successfully duplicated, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Operation\",\n                    \"OpIndex\",\n                    \"V<Word32>\",\n                    \"ComparisonOp\",\n                    \"WordBinopOp\",\n                    \"ShiftOp\",\n                    \"MaybeDuplicateComparison\",\n                    \"MaybeDuplicateWordBinop\",\n                    \"MaybeDuplicateShift\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n private:\n  bool MaybeDuplicateCond(const Operation& cond, OpIndex input_idx,\n                          V<Word32>* new_cond) {\n    if (cond.saturated_use_count.IsOne()) return false;\n\n    switch (cond.opcode) {\n      case Opcode::kComparison:\n        *new_cond =\n            MaybeDuplicateComparison(cond.Cast<ComparisonOp>(), input_idx);\n        break;\n      case Opcode::kWordBinop:\n        *new_cond =\n            MaybeDuplicateWordBinop(cond.Cast<WordBinopOp>(), input_idx);\n        break;\n      case Opcode::kShift:\n        *new_cond = MaybeDuplicateShift(cond.Cast<ShiftOp>(), input_idx);\n        break;\n      default:\n        return false;\n    }\n    return new_cond->valid();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MaybeCanDuplicateGenericBinop\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Determines if a generic binary operation can be duplicated.\",\n                \"logic\": \"Checks if either the left or right inputs to the binop are used only once. It also checks if the binop has already been used in the output graph. This prevents unnecessary duplication that would increase register pressure or duplicate code that isn't actually used multiple times.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"input_idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the input binop.\"\n                    },\n                    {\n                        \"name\": \"left\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the left operand.\"\n                    },\n                    {\n                        \"name\": \"right\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the right operand.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the binop can be duplicated, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"OpIndex\",\n                    \"__ input_graph\",\n                    \"__ MapToNewGraph\",\n                    \"__ Get\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  bool MaybeCanDuplicateGenericBinop(OpIndex input_idx, OpIndex left,\n                                     OpIndex right) {\n    if (__ input_graph().Get(left).saturated_use_count.IsOne() &&\n        __ input_graph().Get(right).saturated_use_count.IsOne()) {\n      // We don't duplicate binops when all of their inputs are used a single\n      // time (this would increase register pressure by keeping 2 values alive\n      // instead of 1).\n      return false;\n    }\n    OpIndex binop_output_idx = __ MapToNewGraph(input_idx);\n    if (__ Get(binop_output_idx).saturated_use_count.IsZero()) {\n      // This is the 1st use of {binop} in the output graph, so there is no need\n      // to duplicate it just yet.\n      return false;\n    }\n    return true;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MaybeDuplicateWordBinop\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Duplicates a WordBinop operation.\",\n                \"logic\": \"Checks if the binop can be duplicated using MaybeCanDuplicateGenericBinop. Then checks the binop kind. If it's an expensive operation (division, modulo), it returns Invalid(). Otherwise it duplicates the binop using the assembler.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"binop\",\n                        \"type\": \"const WordBinopOp&\",\n                        \"purpose\": \"The WordBinop operation to duplicate.\"\n                    },\n                    {\n                        \"name\": \"input_idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the input WordBinop.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The OpIndex of the duplicated WordBinop, or Invalid() if duplication is not possible or not worth it.\"\n                },\n                \"dependencies\": [\n                    \"WordBinopOp\",\n                    \"OpIndex\",\n                    \"MaybeCanDuplicateGenericBinop\",\n                    \"__ MapToNewGraph\",\n                    \"__ WordBinop\",\n                    \"DisableValueNumbering\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  OpIndex MaybeDuplicateWordBinop(const WordBinopOp& binop, OpIndex input_idx) {\n    if (!MaybeCanDuplicateGenericBinop(input_idx, binop.left(),\n                                       binop.right())) {\n      return OpIndex::Invalid();\n    }\n\n    switch (binop.kind) {\n      case WordBinopOp::Kind::kSignedDiv:\n      case WordBinopOp::Kind::kUnsignedDiv:\n      case WordBinopOp::Kind::kSignedMod:\n      case WordBinopOp::Kind::kUnsignedMod:\n        // These operations are somewhat expensive, and duplicating them is\n        // probably not worth it.\n        return OpIndex::Invalid();\n      default:\n        break;\n    }\n\n    DisableValueNumbering disable_gvn(this);\n    return __ WordBinop(__ MapToNewGraph(binop.left()),\n                        __ MapToNewGraph(binop.right()), binop.kind, binop.rep);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MaybeDuplicateComparison\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Duplicates a Comparison operation.\",\n                \"logic\": \"Checks if the comparison can be duplicated using MaybeCanDuplicateGenericBinop, then duplicates it using the assembler.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"comp\",\n                        \"type\": \"const ComparisonOp&\",\n                        \"purpose\": \"The Comparison operation to duplicate.\"\n                    },\n                    {\n                        \"name\": \"input_idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the input Comparison.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<Word32>\",\n                    \"description\": \"The duplicated Comparison operation.\"\n                },\n                \"dependencies\": [\n                    \"ComparisonOp\",\n                    \"OpIndex\",\n                    \"MaybeCanDuplicateGenericBinop\",\n                    \"__ MapToNewGraph\",\n                    \"__ Comparison\",\n                    \"DisableValueNumbering\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<Word32> MaybeDuplicateComparison(const ComparisonOp& comp,\n                                     OpIndex input_idx) {\n    if (!MaybeCanDuplicateGenericBinop(input_idx, comp.left(), comp.right())) {\n      return {};\n    }\n\n    DisableValueNumbering disable_gvn(this);\n    return __ Comparison(__ MapToNewGraph(comp.left()),\n                         __ MapToNewGraph(comp.right()), comp.kind, comp.rep);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MaybeDuplicateShift\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Duplicates a Shift operation.\",\n                \"logic\": \"Checks if the shift can be duplicated using MaybeCanDuplicateGenericBinop, then duplicates it using the assembler.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"shift\",\n                        \"type\": \"const ShiftOp&\",\n                        \"purpose\": \"The Shift operation to duplicate.\"\n                    },\n                    {\n                        \"name\": \"input_idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the input Shift.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The OpIndex of the duplicated Shift operation.\"\n                },\n                \"dependencies\": [\n                    \"ShiftOp\",\n                    \"OpIndex\",\n                    \"MaybeCanDuplicateGenericBinop\",\n                    \"__ MapToNewGraph\",\n                    \"__ Shift\",\n                    \"DisableValueNumbering\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  OpIndex MaybeDuplicateShift(const ShiftOp& shift, OpIndex input_idx) {\n    if (!MaybeCanDuplicateGenericBinop(input_idx, shift.left(),\n                                       shift.right())) {\n      return OpIndex::Invalid();\n    }\n\n    DisableValueNumbering disable_gvn(this);\n    return __ Shift(__ MapToNewGraph(shift.left()),\n                    __ MapToNewGraph(shift.right()), shift.kind, shift.rep);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MaybeDuplicateOutputGraphShift\",\n                \"parent\": \"DuplicationOptimizationReducer\",\n                \"about\": \"Duplicates a Shift operation used as an index for Load/Store operations on ARM64.\",\n                \"logic\": \"Checks if the index is a constant shift, and if its saturated use count is not zero.  It avoids checking {shifted}'s use count because uses may appear later in the graph building process. If these conditions are met, it duplicates the shift.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The index to potentially duplicate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The OpIndex of the duplicated Shift operation, or the original index if duplication is not possible.\"\n                },\n                \"dependencies\": [\n                    \"OpIndex\",\n                    \"V<Word>\",\n                    \"ShiftOp\",\n                    \"WordRepresentation\",\n                    \"__ matcher\",\n                    \"__ Shift\",\n                    \"__ Word32Constant\",\n                    \"DisableValueNumbering\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  OpIndex MaybeDuplicateOutputGraphShift(OpIndex index) {\n    V<Word> shifted;\n    int shifted_by;\n    ShiftOp::Kind shift_kind;\n    WordRepresentation shift_rep;\n    if (__ matcher().MatchConstantShift(index, &shifted, &shift_kind,\n                                        &shift_rep, &shifted_by) &&\n        !__ matcher().Get(index).saturated_use_count.IsZero()) {\n      // We don't check the use count of {shifted}, because it might have uses\n      // in the future that haven't been emitted yet.\n      DisableValueNumbering disable_gvn(this);\n      return __ Shift(shifted, __ Word32Constant(shifted_by), shift_kind,\n                      shift_rep);\n    }\n    return index;\n  }\n        ]]></code>\n    </func>\n</file>\n```"
}