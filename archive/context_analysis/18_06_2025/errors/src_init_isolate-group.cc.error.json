{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/init/isolate-group.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/init/isolate-group.cc\",\n        \"file_name\": \"isolate-group.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Manages groups of isolates, including initialization, pointer compression, and sandboxing.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for isolate group management, memory allocation, and sandboxing.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/init/isolate-group.h\"\n\n#include \"src/base/bounded-page-allocator.h\"\n#include \"src/base/platform/memory.h\"\n#include \"src/base/platform/mutex.h\"\n#include \"src/common/ptr-compr-inl.h\"\n#include \"src/compiler-dispatcher/optimizing-compile-dispatcher.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/heap/code-range.h\"\n#include \"src/heap/read-only-heap.h\"\n#include \"src/heap/read-only-spaces.h\"\n#include \"src/heap/trusted-range.h\"\n#include \"src/sandbox/code-pointer-table-inl.h\"\n#include \"src/sandbox/sandbox.h\"\n#include \"src/utils/memcopy.h\"\n#include \"src/utils/utils.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IsolateGroupAccessScope\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Provides a scope to set and restore the current isolate group, particularly relevant when pointer compression in multiple cages is enabled.\",\n            \"attributes\": [\n                {\n                    \"name\": \"previous_\",\n                    \"type\": \"IsolateGroup*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the previously active IsolateGroup.\"\n                }\n            ],\n            \"dependencies\": [\n                \"IsolateGroup\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\nclass IsolateGroupAccessScope final {\n public:\n  explicit IsolateGroupAccessScope(IsolateGroup* group)\n      : previous_(IsolateGroup::current()) {\n    IsolateGroup::set_current(group);\n  }\n\n  ~IsolateGroupAccessScope() { IsolateGroup::set_current(previous_); }\n\n private:\n  IsolateGroup* previous_;\n};\n#else\nclass IsolateGroupAccessScope final {\n public:\n  explicit IsolateGroupAccessScope(IsolateGroup*) {}\n\n  ~IsolateGroupAccessScope() {}\n};\n#endif  // V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"PtrComprCageReservationParams\",\n            \"extends\": \"VirtualMemoryCage::ReservationParams\",\n            \"implements\": [],\n            \"about\": \"Parameters for reserving memory for the pointer compression cage.\",\n            \"attributes\": [\n              {\n                \"name\": \"page_allocator\",\n                \"type\": \"PageAllocator*\",\n                \"access\": \"public\",\n                \"purpose\": \"Allocator for pages\"\n              },\n              {\n                \"name\": \"reservation_size\",\n                \"type\": \"size_t\",\n                \"access\": \"public\",\n                \"purpose\": \"Size of the memory reservation\"\n              },\n              {\n                \"name\": \"base_alignment\",\n                \"type\": \"size_t\",\n                \"access\": \"public\",\n                \"purpose\": \"Alignment of the base address\"\n              },\n              {\n                \"name\": \"page_size\",\n                \"type\": \"size_t\",\n                \"access\": \"public\",\n                \"purpose\": \"Size of each page\"\n              },\n              {\n                \"name\": \"requested_start_hint\",\n                \"type\": \"Address\",\n                \"access\": \"public\",\n                \"purpose\": \"Hint for starting address\"\n              },\n              {\n                \"name\": \"permissions\",\n                \"type\": \"PageAllocator::Permission\",\n                \"access\": \"public\",\n                \"purpose\": \"Memory permissions\"\n              },\n              {\n                \"name\": \"page_initialization_mode\",\n                \"type\": \"base::PageInitializationMode\",\n                \"access\": \"public\",\n                \"purpose\": \"Mode of page initialization\"\n              },\n              {\n                \"name\": \"page_freeing_mode\",\n                \"type\": \"base::PageFreeingMode\",\n                \"access\": \"public\",\n                \"purpose\": \"Mode of page freeing\"\n              }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_COMPRESS_POINTERS\nstruct PtrComprCageReservationParams\n    : public VirtualMemoryCage::ReservationParams {\n  PtrComprCageReservationParams() {\n    page_allocator = GetPlatformPageAllocator();\n\n    reservation_size = kPtrComprCageReservationSize;\n    base_alignment = kPtrComprCageBaseAlignment;\n\n    // Simplify BoundedPageAllocator's life by configuring it to use same page\n    // size as the Heap will use (MemoryChunk::kPageSize).\n    page_size =\n        RoundUp(size_t{1} << kPageSizeBits, page_allocator->AllocatePageSize());\n    requested_start_hint = RoundDown(\n        reinterpret_cast<Address>(page_allocator->GetRandomMmapAddr()),\n        base_alignment);\n\n#if V8_OS_FUCHSIA && !V8_EXTERNAL_CODE_SPACE\n    // If external code space is not enabled then executable pages (e.g. copied\n    // builtins, and JIT pages) will fall under the pointer compression range.\n    // Under Fuchsia that means the entire range must be allocated as JITtable.\n    permissions = PageAllocator::Permission::kNoAccessWillJitLater;\n#else\n    permissions = PageAllocator::Permission::kNoAccess;\n#endif\n    page_initialization_mode =\n        base::PageInitializationMode::kAllocatedPagesCanBeUninitialized;\n    page_freeing_mode = base::PageFreeingMode::kMakeInaccessible;\n  }\n};\n#endif  // V8_COMPRESS_POINTERS\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"~IsolateGroup\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Destructor for the IsolateGroup class. Releases resources, including the code pointer table, code range, and pointer compression reservation.\",\n            \"logic\": \"It checks reference count and isolate count to make sure no isolates are using the group before tearing down. It then tears down various components based on compilation flags, frees memory reservations, and destroys the sandbox, if enabled.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"CodeRange\",\n                \"sandbox::CodePointerTable\",\n                \"VirtualMemoryCage\",\n                \"Sandbox\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nIsolateGroup::~IsolateGroup() {\n  DCHECK_EQ(reference_count_.load(), 0);\n  DCHECK_EQ(isolate_count_, 0);\n\n#ifdef V8_ENABLE_LEAPTIERING\n  js_dispatch_table_.TearDown();\n#endif  // V8_ENABLE_LEAPTIERING\n\n#ifdef V8_ENABLE_SANDBOX\n  code_pointer_table_.TearDown();\n#endif  // V8_ENABLE_SANDBOX\n\n  // Reset before `reservation_` for pointer compression but disabled external\n  // code space.\n  code_range_.reset();\n\n#ifdef V8_COMPRESS_POINTERS\n  DCHECK(reservation_.IsReserved());\n  reservation_.Free();\n#endif  // V8_COMPRESS_POINTERS\n\n#ifdef V8_ENABLE_SANDBOX\n  sandbox_->TearDown();\n#endif  // V8_ENABLE_SANDBOX\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Initialize\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Initializes the IsolateGroup. Allocates memory for pointer compression, initializes the code pointer table, and the optimizing compile task executor.\",\n            \"logic\": \"The method checks compilation flags (V8_ENABLE_SANDBOX, V8_COMPRESS_POINTERS) to conditionally initialize the pointer compression cage, code pointer table, and the optimizing compile task executor.  When sandboxing is enabled, it uses the sandbox's address space to allocate pages. Otherwise it allocates the pointer compression cage directly.  It also sets the trusted pointer compression cage and initializes the js dispatch table if leap tiering is enabled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"process_wide\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the isolate group is process-wide\"\n                },\n                {\n                    \"name\": \"sandbox\",\n                    \"type\": \"Sandbox*\",\n                    \"purpose\": \"The sandbox instance (only used when sandboxing is enabled)\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"VirtualMemoryCage\",\n                \"sandbox::CodePointerTable\",\n                \"OptimizingCompileTaskExecutor\",\n                \"Sandbox\",\n                \"PtrComprCageReservationParams\",\n                \"TrustedRange\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_ENABLE_SANDBOX\nvoid IsolateGroup::Initialize(bool process_wide, Sandbox* sandbox) {\n  DCHECK(!reservation_.IsReserved());\n  CHECK(sandbox->is_initialized());\n  process_wide_ = process_wide;\n  PtrComprCageReservationParams params;\n  Address base = sandbox->address_space()->AllocatePages(\n    sandbox->base(), params.reservation_size, params.base_alignment,\n    PagePermissions::kNoAccess);\n  CHECK_EQ(sandbox->base(), base);\n  base::AddressRegion existing_reservation(base, params.reservation_size);\n  params.page_allocator = sandbox->page_allocator();\n  if (!reservation_.InitReservation(params, existing_reservation)) {\n    V8::FatalProcessOutOfMemory(\n      nullptr,\n      \"Failed to reserve virtual memory for process-wide V8 \"\n      \"pointer compression cage\");\n  }\n  page_allocator_ = reservation_.page_allocator();\n  pointer_compression_cage_ = &reservation_;\n  trusted_pointer_compression_cage_ =\n      TrustedRange::EnsureProcessWideTrustedRange(kMaximalTrustedRangeSize);\n  sandbox_ = sandbox;\n\n  code_pointer_table()->Initialize();\n  optimizing_compile_task_executor_ =\n      std::make_unique<OptimizingCompileTaskExecutor>();\n\n#ifdef V8_ENABLE_LEAPTIERING\n  js_dispatch_table()->Initialize();\n#endif  // V8_ENABLE_LEAPTIERING\n}\n#elif defined(V8_COMPRESS_POINTERS)\nvoid IsolateGroup::Initialize(bool process_wide) {\n  DCHECK(!reservation_.IsReserved());\n  process_wide_ = process_wide;\n  PtrComprCageReservationParams params;\n  if (!reservation_.InitReservation(params)) {\n    V8::FatalProcessOutOfMemory(\n        nullptr,\n        \"Failed to reserve virtual memory for process-wide V8 \"\n        \"pointer compression cage\");\n  }\n  page_allocator_ = reservation_.page_allocator();\n  pointer_compression_cage_ = &reservation_;\n  trusted_pointer_compression_cage_ = &reservation_;\n  optimizing_compile_task_executor_ =\n      std::make_unique<OptimizingCompileTaskExecutor>();\n#ifdef V8_ENABLE_LEAPTIERING\n  js_dispatch_table()->Initialize();\n#endif  // V8_ENABLE_LEAPTIERING\n}\n#else   // !V8_COMPRESS_POINTERS\nvoid IsolateGroup::Initialize(bool process_wide) {\n  process_wide_ = process_wide;\n  page_allocator_ = GetPlatformPageAllocator();\n  optimizing_compile_task_executor_ =\n      std::make_unique<OptimizingCompileTaskExecutor>();\n#ifdef V8_ENABLE_LEAPTIERING\n  js_dispatch_table()->Initialize();\n#endif  // V8_ENABLE_LEAPTIERING\n}\n#endif  // V8_ENABLE_SANDBOX\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeOncePerProcess\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Initializes the default isolate group for the process. This is a static method called once per process.\",\n            \"logic\": \"The method first checks if the default isolate group has already been initialized. It then creates a new IsolateGroup instance and calls the Initialize method on it, passing in whether the group should be process-wide and either a Sandbox instance or nothing depending on the compilation flags. It also initializes the V8HeapCompressionScheme and ExternalCodeCompressionScheme (when V8_EXTERNAL_CODE_SPACE is defined) with the pointer compression cage base.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"IsolateGroup::Initialize\",\n                \"Sandbox\",\n                \"V8HeapCompressionScheme\",\n                \"ExternalCodeCompressionScheme\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid IsolateGroup::InitializeOncePerProcess() {\n  CHECK_NULL(default_isolate_group_);\n  default_isolate_group_ = new IsolateGroup;\n  IsolateGroup* group = GetDefault();\n\n  DCHECK_NULL(group->page_allocator_);\n#ifdef V8_ENABLE_SANDBOX\n  group->Initialize(true, Sandbox::GetDefault());\n#else\n  group->Initialize(true);\n#endif\n  CHECK_NOT_NULL(group->page_allocator_);\n\n#ifdef V8_COMPRESS_POINTERS\n  V8HeapCompressionScheme::InitBase(group->GetPtrComprCageBase());\n#endif  // V8_COMPRESS_POINTERS\n#ifdef V8_EXTERNAL_CODE_SPACE\n  // Speculatively set the code cage base to the same value in case jitless\n  // mode will be used. Once the process-wide CodeRange instance is created\n  // the code cage base will be set accordingly.\n  ExternalCodeCompressionScheme::InitBase(V8HeapCompressionScheme::base());\n#endif  // V8_EXTERNAL_CODE_SPACE\n#ifdef V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n  IsolateGroup::set_current(group);\n#endif\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TearDownOncePerProcess\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Releases the default isolate group for the process. This is a static method called once per process during shutdown.\",\n            \"logic\": \"This method simply calls ReleaseDefault, which handles releasing the default isolate group.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"IsolateGroup::ReleaseDefault\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid IsolateGroup::TearDownOncePerProcess() { ReleaseDefault(); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Release\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Releases an isolate group. Decrements the reference count and deletes the group if the reference count reaches zero.\",\n            \"logic\": \"This method decrements the reference count of the isolate group. If the reference count becomes zero, it means that no more isolates are using the group, and the group can be safely deleted.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid IsolateGroup::Release() {\n  DCHECK_LT(0, reference_count_.load());\n\n  if (--reference_count_ == 0) {\n    delete this;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitCodeRangeOnce\",\n            \"parent\": null,\n            \"about\": \"Initializes the code range for an isolate group. This is a helper function called only once.\",\n            \"logic\": \"This function creates a new CodeRange object and initializes it with the given page allocator, requested size, and immutability flag. It then resets the unique pointer `code_range_member` to point to the new CodeRange object. Additionally, it initializes the ExternalCodeCompressionScheme if external code space is enabled and using a shared cage.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code_range_member\",\n                    \"type\": \"std::unique_ptr<CodeRange>*\",\n                    \"purpose\": \"A pointer to a unique pointer that will store the CodeRange object.\"\n                },\n                {\n                    \"name\": \"page_allocator\",\n                    \"type\": \"v8::PageAllocator*\",\n                    \"purpose\": \"The page allocator to use for allocating memory for the code range.\"\n                },\n                {\n                    \"name\": \"requested_size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The requested size of the code range.\"\n                },\n                {\n                    \"name\": \"immutable\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"A flag indicating whether the code range should be immutable.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"CodeRange\",\n                \"ExternalCodeCompressionScheme\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\nvoid InitCodeRangeOnce(std::unique_ptr<CodeRange>* code_range_member,\n                       v8::PageAllocator* page_allocator, size_t requested_size,\n                       bool immutable) {\n  CodeRange* code_range = new CodeRange();\n  if (!code_range->InitReservation(page_allocator, requested_size, immutable)) {\n    V8::FatalProcessOutOfMemory(\n        nullptr, \"Failed to reserve virtual memory for CodeRange\");\n  }\n  code_range_member->reset(code_range);\n#ifdef V8_EXTERNAL_CODE_SPACE\n#ifdef V8_COMPRESS_POINTERS_IN_SHARED_CAGE\n  ExternalCodeCompressionScheme::InitBase(\n      ExternalCodeCompressionScheme::PrepareCageBaseAddress(\n          code_range->base()));\n#endif  // V8_COMPRESS_POINTERS_IN_SHARED_CAGE\n#endif  // V8_EXTERNAL_CODE_SPACE\n}\n}  // namespace\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EnsureCodeRange\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Ensures that a CodeRange is initialized for the isolate group. Initializes it only once using base::CallOnce.\",\n            \"logic\": \"The function uses `base::CallOnce` to ensure that the code range is initialized only once. It calls the `InitCodeRangeOnce` function to perform the actual initialization, passing in the code range member, page allocator, requested size, and process-wide flag.\",\n            \"parameters\": [\n                {\n                    \"name\": \"requested_size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The requested size of the code range.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CodeRange*\",\n                \"description\": \"A pointer to the CodeRange object.\"\n            },\n            \"dependencies\": [\n                \"CodeRange\",\n                \"InitCodeRangeOnce\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCodeRange* IsolateGroup::EnsureCodeRange(size_t requested_size) {\n  base::CallOnce(&init_code_range_, InitCodeRangeOnce, &code_range_,\n                 page_allocator_, requested_size, process_wide_);\n  return code_range_.get();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeReadOnlyArtifacts\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Initializes the read-only artifacts for the isolate group.\",\n            \"logic\": \"The method acquires a mutex, checks if the read-only artifacts have already been initialized, and then creates a new ReadOnlyArtifacts object and assigns it to the read_only_artifacts_ member.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"ReadOnlyArtifacts*\",\n                \"description\": \"A pointer to the newly created ReadOnlyArtifacts object.\"\n            },\n            \"dependencies\": [\n                \"ReadOnlyArtifacts\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReadOnlyArtifacts* IsolateGroup::InitializeReadOnlyArtifacts() {\n  mutex_.AssertHeld();\n  DCHECK(!read_only_artifacts_);\n  read_only_artifacts_ = std::make_unique<ReadOnlyArtifacts>();\n  return read_only_artifacts_.get();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetBackingStorePageAllocator\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Returns the page allocator used for backing stores (e.g., ArrayBuffers).\",\n            \"logic\": \"If sandboxing is enabled, it returns the sandbox's page allocator. Otherwise, it returns the platform's default page allocator.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"PageAllocator*\",\n                \"description\": \"The page allocator for backing stores.\"\n            },\n            \"dependencies\": [\n                \"Sandbox\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nPageAllocator* IsolateGroup::GetBackingStorePageAllocator() {\n#ifdef V8_ENABLE_SANDBOX\n  return sandbox()->page_allocator();\n#else\n  return GetPlatformPageAllocator();\n#endif\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetupReadOnlyHeap\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Sets up the read-only heap for an isolate within this isolate group.\",\n            \"logic\": \"The method takes an Isolate, SnapshotData, and a boolean indicating whether rehashing is allowed. It acquires a mutex to protect access to the read-only heap and calls ReadOnlyHeap::SetUp to perform the actual setup.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate for which to set up the read-only heap.\"\n                },\n                {\n                    \"name\": \"read_only_snapshot_data\",\n                    \"type\": \"SnapshotData*\",\n                    \"purpose\": \"Snapshot data to initialize the read-only heap with.\"\n                },\n                {\n                    \"name\": \"can_rehash\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether rehashing is allowed during read-only heap setup.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ReadOnlyHeap\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid IsolateGroup::SetupReadOnlyHeap(Isolate* isolate,\n                                     SnapshotData* read_only_snapshot_data,\n                                     bool can_rehash) {\n  DCHECK_EQ(isolate->isolate_group(), this);\n  base::MutexGuard guard(&mutex_);\n  ReadOnlyHeap::SetUp(isolate, read_only_snapshot_data, can_rehash);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddIsolate\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Adds an isolate to the isolate group. This method manages the isolate count and initializes the optimizing compile task executor.\",\n            \"logic\": \"The method takes an Isolate pointer as input. It asserts that the isolate's isolate group is the same as the current isolate group. It then acquires a mutex to protect access to shared data. It increments the isolate count and ensures that the optimizing compile task executor is initialized. If shared heap is enabled, it checks if there's already a shared space isolate. If not, it initializes the shared space isolate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to add to the group.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"OptimizingCompileTaskExecutor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid IsolateGroup::AddIsolate(Isolate* isolate) {\n  DCHECK_EQ(isolate->isolate_group(), this);\n  base::MutexGuard guard(&mutex_);\n  ++isolate_count_;\n\n  optimizing_compile_task_executor_->EnsureInitialized();\n\n  if (v8_flags.shared_heap) {\n    if (has_shared_space_isolate()) {\n      isolate->owns_shareable_data_ = false;\n    } else {\n      init_shared_space_isolate(isolate);\n      isolate->is_shared_space_isolate_ = true;\n      DCHECK(isolate->owns_shareable_data_);\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RemoveIsolate\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Removes an isolate from the isolate group. This method manages the isolate count and resets read-only artifacts and shared space isolate when the last isolate is removed.\",\n            \"logic\": \"The method takes an Isolate pointer as input. It acquires a mutex to protect access to shared data. It decrements the isolate count. If the isolate count becomes 0, it means that the last isolate is being removed. In this case, it resets the read-only artifacts. If shared heap is enabled, it checks if the isolate being removed is the shared space isolate and resets it accordingly. Finally, the method asserts that if there's a shared space isolate, it must be the last one to be removed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to remove from the group.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid IsolateGroup::RemoveIsolate(Isolate* isolate) {\n  base::MutexGuard guard(&mutex_);\n\n  if (--isolate_count_ == 0) {\n    read_only_artifacts_.reset();\n\n    // We are removing the last isolate from the group. If this group has a\n    // shared heap, the last isolate has to be the shared space isolate.\n    DCHECK_EQ(has_shared_space_isolate(), isolate->is_shared_space_isolate());\n\n    if (isolate->is_shared_space_isolate()) {\n      CHECK_EQ(isolate, shared_space_isolate_);\n      shared_space_isolate_ = nullptr;\n    }\n  } else {\n    // The shared space isolate needs to be removed last.\n    DCHECK(!isolate->is_shared_space_isolate());\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"New\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Creates a new IsolateGroup instance.\",\n            \"logic\": \"This method first checks if new isolate groups can be created (CanCreateNewGroups()). If not, it triggers a fatal error. Otherwise, it creates a new IsolateGroup instance, initializes it (with or without sandboxing depending on build flags), and initializes the external reference table.  It uses IsolateGroupAccessScope to set the newly created group as the current group during external reference table initialization.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"IsolateGroup*\",\n                \"description\": \"A pointer to the newly created IsolateGroup.\"\n            },\n            \"dependencies\": [\n                \"IsolateGroup::Initialize\",\n                \"Sandbox\",\n                \"ExternalReferenceTable\",\n                \"IsolateGroupAccessScope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nIsolateGroup* IsolateGroup::New() {\n  if (!CanCreateNewGroups()) {\n    FATAL(\n        \"Creation of new isolate groups requires enabling \"\n        \"multiple pointer compression cages at build-time\");\n  }\n\n  IsolateGroup* group = new IsolateGroup;\n#ifdef V8_ENABLE_SANDBOX\n  Sandbox* sandbox = Sandbox::New(GetPlatformVirtualAddressSpace());\n  group->Initialize(false, sandbox);\n#else\n  group->Initialize(false);\n#endif\n  CHECK_NOT_NULL(group->page_allocator_);\n\n  // We need to set this early, because it is needed while initializing the\n  // external reference table, eg. in the js_dispatch_table_address and\n  // code_pointer_table_address functions.  This is also done in\n  // IsolateGroup::InitializeOncePerProcess for the single-IsolateGroup\n  // configurations.\n  IsolateGroupAccessScope group_access_scope(group);\n  ExternalReferenceTable::InitializeOncePerIsolateGroup(\n      group->external_ref_table());\n  return group;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReleaseDefault\",\n            \"parent\": \"IsolateGroup\",\n            \"about\": \"Releases the default isolate group.\",\n            \"logic\": \"This method retrieves the default isolate group using `GetDefault()`, checks that its reference count is 1 (meaning it's only referenced by the static default_isolate_group_ pointer) and that it has no shared space isolate. Then it calls the `Release()` method to decrement the reference count and potentially delete the group, and finally sets the `default_isolate_group_` pointer to null.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"IsolateGroup::Release\",\n                \"IsolateGroup::GetDefault\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid IsolateGroup::ReleaseDefault() {\n  IsolateGroup* group = GetDefault();\n  CHECK_EQ(group->reference_count_.load(), 1);\n  CHECK(!group->has_shared_space_isolate());\n  group->Release();\n  default_isolate_group_ = nullptr;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SandboxedArrayBufferAllocator\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A custom ArrayBuffer allocator that allocates memory within the sandbox.\",\n            \"attributes\": [\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Protects access to the allocator's internal state.\"\n                },\n                {\n                    \"name\": \"sandbox_\",\n                    \"type\": \"Sandbox*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The sandbox instance used for memory allocation.\"\n                },\n                {\n                    \"name\": \"region_alloc_\",\n                    \"type\": \"std::unique_ptr<base::RegionAllocator>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The region allocator used for allocating memory within a reserved region.\"\n                },\n                {\n                    \"name\": \"end_of_accessible_region_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The end of the accessible region within the reserved memory.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Sandbox\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_ENABLE_SANDBOX\nvoid SandboxedArrayBufferAllocator::LazyInitialize(Sandbox* sandbox) {\n  base::MutexGuard guard(&mutex_);\n  if (is_initialized()) {\n    return;\n  }\n  CHECK(sandbox->is_initialized());\n  sandbox_ = sandbox;\n  constexpr size_t max_backing_memory_size = 8ULL * GB;\n  constexpr size_t min_backing_memory_size = 1ULL * GB;\n  size_t backing_memory_size = max_backing_memory_size;\n  Address backing_memory_base = 0;"
}