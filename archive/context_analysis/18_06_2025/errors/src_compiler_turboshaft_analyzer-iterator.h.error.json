{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/analyzer-iterator.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 142, column 41",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/analyzer-iterator.h\",\n        \"file_name\": \"analyzer-iterator.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines AnalyzerIterator class for efficient graph traversal in Turboshaft compiler, particularly optimized for SnapshotTable analysis by visiting blocks close in the graph somewhat consecutively.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for logging, graph representation, indexing, loop finding, operations, and side table management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/logging.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/loop-finder.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/sidetable.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AnalyzerIterator\",\n            \"about\": \"Provides methods to iterate forward a Graph in a way that is efficient for the SnapshotTable.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Graph\",\n                \"LoopFinder\",\n                \"Block\",\n                \"Zone\",\n                \"FixedBlockSidetable\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE AnalyzerIterator {\n public:\n  AnalyzerIterator(Zone* phase_zone, const Graph& graph,\n                   const LoopFinder& loop_finder);\n\n  bool HasNext() const;\n  const Block* Next();\n  // Schedule the loop pointed to by the current block (as a backedge)\n  // to be revisited on the next iteration.\n  void MarkLoopForRevisit();\n  // Schedule the loop pointed to by the current block (as a backedge) to be\n  // revisited on the next iteration but skip the loop header.\n  void MarkLoopForRevisitSkipHeader();\n\n private:\n  struct StackNode {\n    const Block* block;\n    uint64_t generation;\n  };\n  static constexpr uint64_t kNotVisitedGeneration = 0;\n  static constexpr uint64_t kGenerationForFirstVisit = 1;\n\n  void PopOutdated();\n  bool IsOutdated(StackNode node) const;\n\n  const Graph& graph_;\n  const LoopFinder& loop_finder_;\n\n  uint64_t current_generation_ = kGenerationForFirstVisit;\n\n  // The last block returned by Next.\n  StackNode curr_ = {nullptr, 0};\n\n  // {visited_} maps BlockIndex to the generation they were visited with. If a\n  // Block has been visited with a generation `n`, then we never want to revisit\n  // it with a generation `k` when `k <= n`.\n  FixedBlockSidetable<uint64_t> visited_;\n\n  // The stack of blocks that are left to visit. We maintain the invariant that\n  // the .back() of {stack_} is never out-dated (ie, its generation is always\n  // greater than the generation for its node recorded in {visited_}), so that\n  // \"Next\" can simply check whether {stack_} is empty or not.\n  ZoneVector<StackNode> stack_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"StackNode\",\n            \"parent\": \"AnalyzerIterator\",\n            \"about\": \"Represents a node in the stack of blocks to visit, storing a Block pointer and a generation number.\",\n            \"attributes\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const Block*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Pointer to a block in the graph.\"\n                },\n                {\n                    \"name\": \"generation\",\n                    \"type\": \"uint64_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Generation number associated with the block's visit.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  struct StackNode {\n    const Block* block;\n    uint64_t generation;\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AnalyzerIterator\",\n            \"parent\": \"AnalyzerIterator\",\n            \"about\": \"Constructor for AnalyzerIterator, initializes the iterator with a graph, loop finder, and a zone for memory allocation.\",\n            \"logic\": \"Initializes the visited table, the stack with the start block, and sets the initial generation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"phase_zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"Memory zone for allocation.\"\n                },\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"const Graph&\",\n                    \"purpose\": \"The graph to iterate.\"\n                },\n                {\n                    \"name\": \"loop_finder\",\n                    \"type\": \"const LoopFinder&\",\n                    \"purpose\": \"Loop finder instance to determine loop structure.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Graph\",\n                \"LoopFinder\",\n                \"FixedBlockSidetable\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  AnalyzerIterator(Zone* phase_zone, const Graph& graph,\n                   const LoopFinder& loop_finder)\n      : graph_(graph),\n        loop_finder_(loop_finder),\n        visited_(graph.block_count(), kNotVisitedGeneration, phase_zone),\n        stack_(phase_zone) {\n    stack_.push_back({&graph.StartBlock(), kGenerationForFirstVisit});\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"HasNext\",\n            \"parent\": \"AnalyzerIterator\",\n            \"about\": \"Checks if there are more blocks to visit.\",\n            \"logic\": \"Returns true if the stack is not empty, implying there are more blocks to iterate through.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if more blocks exist, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  bool HasNext() const {\n    DCHECK_IMPLIES(!stack_.empty(), !IsOutdated(stack_.back()));\n    return !stack_.empty();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Next\",\n            \"parent\": \"AnalyzerIterator\",\n            \"about\": \"Returns the next block to visit and updates the iterator state.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"const Block*\",\n                \"description\": \"Pointer to the next block in the graph.\"\n            },\n            \"dependencies\": [\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  const Block* Next();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkLoopForRevisit\",\n            \"parent\": \"AnalyzerIterator\",\n            \"about\": \"Schedules the loop pointed to by the current block (as a backedge) to be revisited on the next iteration.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void MarkLoopForRevisit();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkLoopForRevisitSkipHeader\",\n            \"parent\": \"AnalyzerIterator\",\n            \"about\": \"Schedules the loop pointed to by the current block (as a backedge) to be revisited on the next iteration but skips the loop header.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void MarkLoopForRevisitSkipHeader();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PopOutdated\",\n            \"parent\": \"AnalyzerIterator\",\n            \"about\": \"Removes outdated nodes from the stack.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void PopOutdated();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsOutdated\",\n            \"parent\": \"AnalyzerIterator\",\n            \"about\": \"Checks if a given stack node is outdated based on its generation and the visited table.\",\n            \"logic\": \"Compares the generation of the stack node with the generation recorded in the visited table for the corresponding block.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"StackNode\",\n                    \"purpose\": \"The stack node to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the node is outdated, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  bool IsOutdated(StackNode node) const {\n    return visited_[node.block->index()] >= node.generation;\n  }\n        ]]></code>\n    </func>\n</file>\n```"
}