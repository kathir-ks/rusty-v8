{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-scanner.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 97, column 52",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-scanner.h\",\n        \"file_name\": \"asm-scanner.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines a custom scanner (AsmJsScanner) to extract the token stream needed to parse valid asm.js code. This scanner is optimized for asm.js parsing and avoids unnecessary JavaScript lexing.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary standard library headers for memory management, string manipulation, and unordered maps, as well as V8-specific headers for asm.js names, logging, and string utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <memory>\n            #include <string>\n            #include <unordered_map>\n\n            #include \"src/asmjs/asm-names.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/base/strings.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsmJsScanner\",\n            \"about\": \"A custom scanner optimized for parsing asm.js code. It provides methods for tokenizing the input stream, managing identifiers in local and global scopes, and identifying numeric literals.\",\n            \"attributes\": [\n                {\n                    \"name\": \"stream_\",\n                    \"type\": \"Utf16CharacterStream*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the input character stream.\"\n                },\n                {\n                    \"name\": \"token_\",\n                    \"type\": \"token_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current token.\"\n                },\n                {\n                    \"name\": \"preceding_token_\",\n                    \"type\": \"token_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The token preceding the current token.\"\n                },\n                {\n                    \"name\": \"next_token_\",\n                    \"type\": \"token_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The next token (used during rewind).\"\n                },\n                {\n                    \"name\": \"position_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The position of the current token in the stream.\"\n                },\n                {\n                    \"name\": \"preceding_position_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The position of the preceding token in the stream.\"\n                },\n                {\n                    \"name\": \"next_position_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The position of the next token in the stream (used during rewind).\"\n                },\n                {\n                    \"name\": \"rewind_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether the scanner is in a rewind state.\"\n                },\n                {\n                    \"name\": \"identifier_string_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The string representation of the current identifier.\"\n                },\n                {\n                    \"name\": \"in_local_scope_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether the scanner is currently in a local scope.\"\n                },\n                {\n                    \"name\": \"local_names_\",\n                    \"type\": \"std::unordered_map<std::string, token_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of local identifier names to their corresponding tokens.\"\n                },\n                {\n                    \"name\": \"global_names_\",\n                    \"type\": \"std::unordered_map<std::string, token_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of global identifier names to their corresponding tokens.\"\n                },\n                {\n                    \"name\": \"property_names_\",\n                    \"type\": \"std::unordered_map<std::string, token_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of property names to their corresponding tokens.\"\n                },\n                {\n                    \"name\": \"global_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Counter for global identifiers.\"\n                },\n                {\n                    \"name\": \"double_value_\",\n                    \"type\": \"double\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The value of the current double literal.\"\n                },\n                {\n                    \"name\": \"unsigned_value_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The value of the current unsigned integer literal.\"\n                },\n                {\n                    \"name\": \"preceded_by_newline_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the current token was preceded by a newline character.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Utf16CharacterStream\",\n                \"asm_names\",\n                \"logging\",\n                \"strings\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE AsmJsScanner {\n            public:\n              using token_t = int32_t;\n\n              explicit AsmJsScanner(Utf16CharacterStream* stream);\n\n              // Get current token.\n              token_t Token() const { return token_; }\n              // Get position of current token.\n              size_t Position() const { return position_; }\n              // Advance to the next token.\n              void Next();\n              // Back up by one token.\n              void Rewind();\n\n              // Get raw string for current identifier. Note that the returned string will\n              // become invalid when the scanner advances, create a copy to preserve it.\n              const std::string& GetIdentifierString() const {\n                // Identifier strings don't work after a rewind.\n                DCHECK(!rewind_);\n                return identifier_string_;\n              }\n\n              // Check if we just passed a newline.\n              bool IsPrecededByNewline() const {\n                // Newline tracking doesn't work if you back up.\n                DCHECK(!rewind_);\n                return preceded_by_newline_;\n              }\n\n            #if DEBUG\n              // Debug only method to go from a token back to its name.\n              // Slow, only use for debugging.\n              std::string Name(token_t token) const;\n            #endif\n\n              // Restores old position (token after that position). Note that it is not\n              // allowed to rewind right after a seek, because previous tokens are unknown.\n              void Seek(size_t pos);\n\n              // Select whether identifiers are resolved in global or local scope,\n              // and which scope new identifiers are added to.\n              void EnterLocalScope() { in_local_scope_ = true; }\n              void EnterGlobalScope() { in_local_scope_ = false; }\n              // Drop all current local identifiers.\n              void ResetLocals();\n\n              // Methods to check if a token is an identifier and which scope.\n              bool IsLocal() const { return IsLocal(Token()); }\n              bool IsGlobal() const { return IsGlobal(Token()); }\n              static bool IsLocal(token_t token) { return token <= kLocalsStart; }\n              static bool IsGlobal(token_t token) { return token >= kGlobalsStart; }\n              // Methods to find the index position of an identifier (count starting from\n              // 0 for each scope separately).\n              static size_t LocalIndex(token_t token) {\n                DCHECK(IsLocal(token));\n                return -(token - kLocalsStart);\n              }\n              static size_t GlobalIndex(token_t token) {\n                DCHECK(IsGlobal(token));\n                return token - kGlobalsStart;\n              }\n\n              // Methods to check if the current token is a numeric literal considered an\n              // asm.js \"double\" (contains a dot) or an \"unsigned\" (without a dot). Note\n              // that numbers without a dot outside the [0 .. 2^32) range are errors.\n              bool IsUnsigned() const { return Token() == kUnsigned; }\n              uint32_t AsUnsigned() const {\n                DCHECK(IsUnsigned());\n                return unsigned_value_;\n              }\n              bool IsDouble() const { return Token() == kDouble; }\n              double AsDouble() const {\n                DCHECK(IsDouble());\n                return double_value_;\n              }\n\n              // clang-format off\n              enum {\n                // [-10000-kMaxIdentifierCount, -10000)    :: Local identifiers (counting\n                //                                            backwards)\n                // [-10000 .. -1)                          :: Builtin tokens like keywords\n                //                                            (also includes some special\n                //                                             ones like end of input)\n                // 0        .. 255                         :: Single char tokens\n                // 256      .. 256+kMaxIdentifierCount     :: Global identifiers\n                kLocalsStart = -10000,\n        #define V(name, _junk1, _junk2, _junk3) kToken_##name,\n                STDLIB_MATH_FUNCTION_LIST(V)\n                STDLIB_ARRAY_TYPE_LIST(V)\n        #undef V\n        #define V(name, _junk1) kToken_##name,\n                STDLIB_MATH_VALUE_LIST(V)\n        #undef V\n        #define V(name) kToken_##name,\n                STDLIB_OTHER_LIST(V)\n                KEYWORD_NAME_LIST(V)\n        #undef V\n        #define V(rawname, name) kToken_##name,\n                LONG_SYMBOL_NAME_LIST(V)\n        #undef V\n        #define V(name, value, string_name) name = value,\n                SPECIAL_TOKEN_LIST(V)\n        #undef V\n                kGlobalsStart = 256,\n              };\n              // clang-format on\n\n              static constexpr base::uc32 kEndOfInputU =\n                  static_cast<base::uc32>(kEndOfInput);\n\n             private:\n              Utf16CharacterStream* stream_;\n              token_t token_;\n              token_t preceding_token_;\n              token_t next_token_;         // Only set when in {rewind} state.\n              size_t position_;            // Corresponds to {token} position.\n              size_t preceding_position_;  // Corresponds to {preceding_token} position.\n              size_t next_position_;       // Only set when in {rewind} state.\n              bool rewind_;\n              std::string identifier_string_;\n              bool in_local_scope_;\n              std::unordered_map<std::string, token_t> local_names_;\n              std::unordered_map<std::string, token_t> global_names_;\n              std::unordered_map<std::string, token_t> property_names_;\n              int global_count_;\n              double double_value_;\n              uint32_t unsigned_value_;\n              bool preceded_by_newline_;\n\n              // Consume multiple characters.\n              void ConsumeIdentifier(base::uc32 ch);\n              void ConsumeNumber(base::uc32 ch);\n              bool ConsumeCComment();\n              void ConsumeCPPComment();\n              void ConsumeString(base::uc32 quote);\n              void ConsumeCompareOrShift(base::uc32 ch);\n\n              // Classify character categories.\n              bool IsIdentifierStart(base::uc32 ch);\n              bool IsIdentifierPart(base::uc32 ch);\n              bool IsNumberStart(base::uc32 ch);\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AsUnsigned\",\n            \"parent\": \"AsmJsScanner\",\n            \"about\": \"Returns the unsigned integer value of the current token.\",\n            \"logic\": \"Asserts that the current token is an unsigned integer and then returns its value.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"uint32_t\",\n                \"description\": \"The unsigned integer value of the current token.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            uint32_t AsmJsScanner::AsUnsigned() const {\n              DCHECK(IsUnsigned());\n              return unsigned_value_;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AsDouble\",\n            \"parent\": \"AsmJsScanner\",\n            \"about\": \"Returns the double value of the current token.\",\n            \"logic\": \"Asserts that the current token is a double and then returns its value.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"double\",\n                \"description\": \"The double value of the current token.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            double AsmJsScanner::AsDouble() const {\n              DCHECK(IsDouble());\n              return double_value_;\n            }\n        ]]></code>\n    </func>\n</file>\n```"
}