{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-heap-broker.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-heap-broker.h\",\n            \"file_name\": \"js-heap-broker.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the JSHeapBroker class, which facilitates communication between the compiler and the JavaScript heap. It provides a mechanism for the compiler to access and reason about heap objects without directly manipulating the heap.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for data structures, base functionalities, platform-specific features, code generation, common globals, access information, feedback sources, heap references, processed feedback, references map, execution environment, handle management, heap management, object kinds, object representations, root indices, utilities, output streams, and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/compiler-specific.h\"\n#include \"src/base/macros.h\"\n#include \"src/base/platform/mutex.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/access-info.h\"\n#include \"src/compiler/feedback-source.h\"\n#include \"src/compiler/heap-refs.h\"\n#include \"src/compiler/processed-feedback.h\"\n#include \"src/compiler/refs-map.h\"\n#include \"src/execution/local-isolate.h\"\n#include \"src/handles/handles.h\"\n#include \"src/handles/persistent-handles.h\"\n#include \"src/heap/local-heap.h\"\n#include \"src/heap/parked-scope.h\"\n#include \"src/objects/code-kind.h\"\n#include \"src/objects/feedback-vector.h\"\n#include \"src/objects/objects.h\"\n#include \"src/objects/tagged.h\"\n#include \"src/roots/roots.h\"\n#include \"src/utils/address-map.h\"\n#include \"src/utils/identity-map.h\"\n#include \"src/utils/ostreams.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSHeapBroker\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Provides a broker to access the JS heap for the compiler.  Allows the compiler to reason about heap objects without direct heap manipulation. Caches object data, manages canonical handles, and facilitates feedback processing.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Isolate.\"\n                    },\n                    {\n                        \"name\": \"cage_base_\",\n                        \"type\": \"PtrComprCageBase\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The pointer compression cage base value.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the zone used for allocations.\"\n                    },\n                    {\n                        \"name\": \"target_native_context_\",\n                        \"type\": \"OptionalNativeContextRef\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The target native context.\"\n                    },\n                    {\n                        \"name\": \"refs_\",\n                        \"type\": \"RefsMap*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map for managing references to heap objects.\"\n                    },\n                    {\n                        \"name\": \"root_index_map_\",\n                        \"type\": \"RootIndexMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map for storing root indices of heap objects.\"\n                    },\n                    {\n                        \"name\": \"array_and_object_prototypes_\",\n                        \"type\": \"ZoneUnorderedSet<IndirectHandle<JSObject>, IndirectHandle<JSObject>::hash,IndirectHandle<JSObject>::equal_to>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set to store array and object prototypes.\"\n                    },\n                    {\n                        \"name\": \"mode_\",\n                        \"type\": \"BrokerMode\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current broker mode.\"\n                    },\n                    {\n                        \"name\": \"tracing_enabled_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether tracing is enabled.\"\n                    },\n                    {\n                        \"name\": \"code_kind_\",\n                        \"type\": \"CodeKind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The code kind for the broker.\"\n                    },\n                    {\n                        \"name\": \"ph_\",\n                        \"type\": \"std::unique_ptr<PersistentHandles>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Unique pointer to persistent handles.\"\n                    },\n                    {\n                        \"name\": \"local_isolate_\",\n                        \"type\": \"LocalIsolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the local isolate.\"\n                    },\n                    {\n                        \"name\": \"canonical_handles_\",\n                        \"type\": \"CanonicalHandlesMap*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map for canonical handles.\"\n                    },\n                    {\n                        \"name\": \"trace_indentation_\",\n                        \"type\": \"unsigned\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indentation level for tracing.\"\n                    },\n                    {\n                        \"name\": \"feedback_\",\n                        \"type\": \"ZoneUnorderedMap<FeedbackSource, ProcessedFeedback const*,FeedbackSource::Hash, FeedbackSource::Equal>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map for storing processed feedback for feedback sources.\"\n                    },\n                    {\n                        \"name\": \"property_access_infos_\",\n                        \"type\": \"ZoneUnorderedMap<PropertyAccessTarget, PropertyAccessInfo,PropertyAccessTarget::Hash, PropertyAccessTarget::Equal>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map for storing property access information for property access targets.\"\n                    },\n                    {\n                        \"name\": \"name##_\",\n                        \"type\": \"OptionalRef<typename ref_traits<Type>::ref_type>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Cached read-only roots.\"\n                    },\n                    {\n                        \"name\": \"dependencies_\",\n                        \"type\": \"CompilationDependencies*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to compilation dependencies.\"\n                    },\n                    {\n                         \"name\": \"map_updater_mutex_depth_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Locking depth for MapUpdater mutex\"\n                    },\n                    {\n                         \"name\": \"boilerplate_migration_mutex_depth_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Locking depth for BoilerplateMigration mutex\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Zone\",\n                    \"NativeContextRef\",\n                    \"ObjectRef\",\n                    \"RefsMap\",\n                    \"RootIndexMap\",\n                    \"BrokerMode\",\n                    \"CodeKind\",\n                    \"PersistentHandles\",\n                    \"LocalIsolate\",\n                    \"CanonicalHandlesMap\",\n                    \"FeedbackSource\",\n                    \"ProcessedFeedback\",\n                    \"PropertyAccessTarget\",\n                    \"PropertyAccessInfo\",\n                    \"CompilationDependencies\",\n                    \"ObjectData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE JSHeapBroker {\n public:\n  JSHeapBroker(Isolate* isolate, Zone* broker_zone, bool tracing_enabled,\n               CodeKind code_kind);\n\n  // For use only in tests, sets default values for some arguments. Avoids\n  // churn when new flags are added.\n  JSHeapBroker(Isolate* isolate, Zone* broker_zone)\n      : JSHeapBroker(isolate, broker_zone, v8_flags.trace_heap_broker,\n                     CodeKind::TURBOFAN_JS) {}\n\n  ~JSHeapBroker();\n\n  // The compilation target's native context. We need the setter because at\n  // broker construction time we don't yet have the canonical handle.\n  NativeContextRef target_native_context() const {\n    return target_native_context_.value();\n  }\n  void SetTargetNativeContextRef(DirectHandle<NativeContext> native_context);\n\n  void InitializeAndStartSerializing(\n      DirectHandle<NativeContext> native_context);\n\n  Isolate* isolate() const { return isolate_; }\n\n  // The pointer compression cage base value used for decompression of all\n  // tagged values except references to InstructionStream objects.\n  PtrComprCageBase cage_base() const {\n#if V8_COMPRESS_POINTERS\n    return cage_base_;\n#else\n    return PtrComprCageBase{};\n#endif  // V8_COMPRESS_POINTERS\n  }\n\n  Zone* zone() const { return zone_; }\n  bool tracing_enabled() const { return tracing_enabled_; }\n\n  NexusConfig feedback_nexus_config() const {\n    return IsMainThread() ? NexusConfig::FromMainThread(isolate())\n                          : NexusConfig::FromBackgroundThread(\n                                isolate(), local_isolate()->heap());\n  }\n\n  enum BrokerMode { kDisabled, kSerializing, kSerialized, kRetired };\n  BrokerMode mode() const { return mode_; }\n\n  void StopSerializing();\n  void Retire();\n  bool SerializingAllowed() const;\n\n#ifdef DEBUG\n  // Get the current heap broker for this thread. Only to be used for DCHECKs.\n  static JSHeapBroker* Current();\n#endif\n\n  // Remember the local isolate and initialize its local heap with the\n  // persistent and canonical handles provided by {info}.\n  void AttachLocalIsolate(OptimizedCompilationInfo* info,\n                          LocalIsolate* local_isolate);\n  // Forget about the local isolate and pass the persistent and canonical\n  // handles provided back to {info}. {info} is responsible for disposing of\n  // them.\n  void DetachLocalIsolate(OptimizedCompilationInfo* info);\n\n  // TODO(v8:7700): Refactor this once the broker is no longer\n  // Turbofan-specific.\n  void AttachLocalIsolateForMaglev(maglev::MaglevCompilationInfo* info,\n                                   LocalIsolate* local_isolate);\n  void DetachLocalIsolateForMaglev(maglev::MaglevCompilationInfo* info);\n\n  // Attaches the canonical handles map from the compilation info to the broker.\n  // Ownership of the map remains in the compilation info.\n  template <typename CompilationInfoT>\n  void AttachCompilationInfo(CompilationInfoT* info) {\n    set_canonical_handles(info->canonical_handles());\n  }\n\n  bool StackHasOverflowed() const;\n\n#ifdef DEBUG\n  void PrintRefsAnalysis() const;\n#endif  // DEBUG\n\n  // Returns the handle from root index table for read only heap objects.\n  DirectHandle<Object> GetRootHandle(Tagged<Object> object);\n\n  // Never returns nullptr.\n  ObjectData* GetOrCreateData(Handle<Object> object,\n                              GetOrCreateDataFlags flags = {});\n  ObjectData* GetOrCreateData(Tagged<Object> object,\n                              GetOrCreateDataFlags flags = {});\n\n  // Gets data only if we have it. However, thin wrappers will be created for\n  // smis, read-only objects and never-serialized objects.\n  ObjectData* TryGetOrCreateData(Handle<Object> object,\n                                 GetOrCreateDataFlags flags = {});\n  ObjectData* TryGetOrCreateData(Tagged<Object> object,\n                                 GetOrCreateDataFlags flags = {});\n\n  // Check if {object} is any native context's %ArrayPrototype% or\n  // %ObjectPrototype%.\n  bool IsArrayOrObjectPrototype(JSObjectRef object) const;\n  bool IsArrayOrObjectPrototype(Handle<JSObject> object) const;\n\n  bool HasFeedback(FeedbackSource const& source) const;\n  void SetFeedback(FeedbackSource const& source,\n                   ProcessedFeedback const* feedback);\n  FeedbackSlotKind GetFeedbackSlotKind(FeedbackSource const& source) const;\n\n  ElementAccessFeedback const& ProcessFeedbackMapsForElementAccess(\n      ZoneVector<MapRef>& maps, KeyedAccessMode const& keyed_mode,\n      FeedbackSlotKind slot_kind);\n\n  // Binary, comparison and for-in hints can be fully expressed via\n  // an enum. Insufficient feedback is signaled by <Hint enum>::kNone.\n  BinaryOperationHint GetFeedbackForBinaryOperation(\n      FeedbackSource const& source);\n  CompareOperationHint GetFeedbackForCompareOperation(\n      FeedbackSource const& source);\n  ForInHint GetFeedbackForForIn(FeedbackSource const& source);\n\n  ProcessedFeedback const& GetFeedbackForCall(FeedbackSource const& source);\n  ProcessedFeedback const& GetFeedbackForGlobalAccess(\n      FeedbackSource const& source);\n  ProcessedFeedback const& GetFeedbackForInstanceOf(\n      FeedbackSource const& source);\n  TypeOfFeedback::Result GetFeedbackForTypeOf(FeedbackSource const& source);\n  ProcessedFeedback const& GetFeedbackForArrayOrObjectLiteral(\n      FeedbackSource const& source);\n  ProcessedFeedback const& GetFeedbackForRegExpLiteral(\n      FeedbackSource const& source);\n  ProcessedFeedback const& GetFeedbackForTemplateObject(\n      FeedbackSource const& source);\n  ProcessedFeedback const& GetFeedbackForPropertyAccess(\n      FeedbackSource const& source, AccessMode mode,\n      OptionalNameRef static_name);\n\n  ProcessedFeedback const& ProcessFeedbackForBinaryOperation(\n      FeedbackSource const& source);\n  ProcessedFeedback const& ProcessFeedbackForCompareOperation(\n      FeedbackSource const& source);\n  ProcessedFeedback const& ProcessFeedbackForForIn(\n      FeedbackSource const& source);\n  ProcessedFeedback const& ProcessFeedbackForTypeOf(\n      FeedbackSource const& source);\n\n  bool FeedbackIsInsufficient(FeedbackSource const& source) const;\n\n  OptionalNameRef GetNameFeedback(FeedbackNexus const& nexus);\n\n  PropertyAccessInfo GetPropertyAccessInfo(MapRef map, NameRef name,\n                                           AccessMode access_mode);\n\n  StringRef GetTypedArrayStringTag(ElementsKind kind);\n\n  bool IsMainThread() const {\n    return local_isolate() == nullptr || local_isolate()->is_main_thread();\n  }\n\n  LocalIsolate* local_isolate() const { return local_isolate_; }\n\n  // TODO(jgruber): Consider always having local_isolate_ set to a real value.\n  // This seems not entirely trivial since we currently reset local_isolate_ to\n  // nullptr at some point in the JSHeapBroker lifecycle.\n  LocalIsolate* local_isolate_or_isolate() const {\n    return local_isolate() != nullptr ? local_isolate()\n                                      : isolate()->AsLocalIsolate();\n  }\n\n  std::optional<RootIndex> FindRootIndex(HeapObjectRef object) {\n    // No root constant is a JSReceiver.\n    if (object.IsJSReceiver()) return {};\n    RootIndex root_index;\n    if (root_index_map_.Lookup(*object.object(), &root_index)) {\n      return root_index;\n    }\n    return {};\n  }\n\n  // Return the corresponding canonical persistent handle for {object}. Create\n  // one if it does not exist.\n  // If a local isolate is attached, we can create the persistent handle through\n  // it. This commonly happens during the Execute phase.\n  // If we don't, that means we are calling this method from serialization. If\n  // that happens, we should be inside a persistent handle scope. Then, we would\n  // just use the regular handle creation.\n  template <typename T>\n  Handle<T> CanonicalPersistentHandle(Tagged<T> object) {\n    DCHECK_NOT_NULL(canonical_handles_);\n    if (Tagged<HeapObject> heap_object;\n        TryCast<HeapObject>(object, &heap_object)) {\n      RootIndex root_index;\n      // CollectArrayAndObjectPrototypes calls this function often with T equal\n      // to JSObject. The root index map only contains immortal, immutable\n      // objects; it never contains any instances of type JSObject, since\n      // JSObjects must exist within a NativeContext, and NativeContexts can be\n      // created and destroyed. Thus, we can skip the lookup in the root index\n      // map for those values and save a little time.\n      if constexpr (std::is_convertible_v<T, JSObject>) {\n        DCHECK(!root_index_map_.Lookup(heap_object, &root_index));\n      } else if (root_index_map_.Lookup(heap_object, &root_index)) {\n        return Handle<T>(isolate_->root_handle(root_index).location());\n      }\n    }\n\n    auto find_result = canonical_handles_->FindOrInsert(object);\n    if (find_result.already_exists) return Handle<T>(*find_result.entry);\n\n    // Allocate new PersistentHandle if one wasn't created before.\n    if (local_isolate()) {\n      *find_result.entry =\n          local_isolate()->heap()->NewPersistentHandle(object).location();\n    } else {\n      DCHECK(PersistentHandlesScope::IsActive(isolate()));\n      *find_result.entry = IndirectHandle<T>(object, isolate()).location();\n    }\n    return Handle<T>(*find_result.entry);\n  }\n\n  template <typename T>\n  Handle<T> CanonicalPersistentHandle(Handle<T> object) {\n    if (object.is_null()) return object;  // Can't deref a null handle.\n    return CanonicalPersistentHandle<T>(*object);\n  }\n\n  // Checks if a canonical persistent handle for {object} exists.\n  template <typename T>\n  bool IsCanonicalHandle(Handle<T> handle) {\n    DCHECK_NOT_NULL(canonical_handles_);\n    if (Tagged<HeapObject> heap_object;\n        TryCast<HeapObject>(*handle, &heap_object)) {\n      RootIndex root_index;\n      if (root_index_map_.Lookup(heap_object, &root_index)) {\n        return true;\n      }\n      // Builtins use pseudo handles that are canonical and persistent by\n      // design.\n      if (isolate()->IsBuiltinTableHandleLocation(handle.location())) {\n        return true;\n      }\n    }\n    return canonical_handles_->Find(*handle) != nullptr;\n  }\n\n  std::string Trace() const;\n  void IncrementTracingIndentation();\n  void DecrementTracingIndentation();\n\n  // Locks {mutex} through the duration of this scope iff it is the first\n  // occurrence. This is done to have a recursive shared lock on {mutex}.\n  class V8_NODISCARD RecursiveMutexGuardIfNeeded {\n   protected:\n    V8_INLINE RecursiveMutexGuardIfNeeded(LocalIsolate* local_isolate,\n                                          base::Mutex* mutex,\n                                          int* mutex_depth_address);\n\n    ~RecursiveMutexGuardIfNeeded() {\n      DCHECK_GE((*mutex_depth_address_), 1);\n      (*mutex_depth_address_)--;\n      DCHECK_EQ(initial_mutex_depth_, (*mutex_depth_address_));\n    }\n\n   private:\n    int* const mutex_depth_address_;\n    const int initial_mutex_depth_;\n    ParkedMutexGuardIf mutex_guard_;\n  };\n\n  class MapUpdaterGuardIfNeeded final : public RecursiveMutexGuardIfNeeded {\n   public:\n    V8_INLINE explicit MapUpdaterGuardIfNeeded(JSHeapBroker* broker);\n  };\n\n  class BoilerplateMigrationGuardIfNeeded final\n      : public RecursiveMutexGuardIfNeeded {\n   public:\n    V8_INLINE explicit BoilerplateMigrationGuardIfNeeded(JSHeapBroker* broker);\n  };\n\n  // If this returns false, the object is guaranteed to be fully initialized and\n  // thus safe to read from a memory safety perspective. The converse does not\n  // necessarily hold.\n  bool ObjectMayBeUninitialized(DirectHandle<Object> object) const;\n  bool ObjectMayBeUninitialized(Tagged<Object> object) const;\n  bool ObjectMayBeUninitialized(Tagged<HeapObject> object) const;\n\n  void set_dependencies(CompilationDependencies* dependencies) {\n    DCHECK_NOT_NULL(dependencies);\n    DCHECK_NULL(dependencies_);\n    dependencies_ = dependencies;\n  }\n  CompilationDependencies* dependencies() const {\n    DCHECK_NOT_NULL(dependencies_);\n    return dependencies_;\n  }\n\n#define V(Type, name, Name) inline typename ref_traits<Type>::ref_type name();\n  READ_ONLY_ROOT_LIST(V)\n#undef V\n\n private:\n  friend class JSHeapBrokerScopeForTesting;\n  friend class HeapObjectRef;\n  friend class ObjectRef;\n  friend class ObjectData;\n  friend class PropertyCellData;\n\n  ProcessedFeedback const& GetFeedback(FeedbackSource const& source) const;\n  const ProcessedFeedback& NewInsufficientFeedback(FeedbackSlotKind kind) const;\n\n  // Bottleneck FeedbackNexus access here, for storage in the broker\n  // or on-the-fly usage elsewhere in the compiler.\n  ProcessedFeedback const& ReadFeedbackForArrayOrObjectLiteral(\n      FeedbackSource const& source);\n  ProcessedFeedback const& ReadFeedbackForBinaryOperation(\n      FeedbackSource const& source) const;\n  ProcessedFeedback const& ReadFeedbackForTypeOf(\n      FeedbackSource const& source) const;\n  ProcessedFeedback const& ReadFeedbackForCall(FeedbackSource const& source);\n  ProcessedFeedback const& ReadFeedbackForCompareOperation(\n      FeedbackSource const& source) const;\n  ProcessedFeedback const& ReadFeedbackForForIn(\n      FeedbackSource const& source) const;\n  ProcessedFeedback const& ReadFeedbackForGlobalAccess(\n      JSHeapBroker* broker, FeedbackSource const& source);\n  ProcessedFeedback const& ReadFeedbackForInstanceOf(\n      FeedbackSource const& source);\n  ProcessedFeedback const& ReadFeedbackForPropertyAccess(\n      FeedbackSource const& source, AccessMode mode,\n      OptionalNameRef static_name);\n  ProcessedFeedback const& ReadFeedbackForRegExpLiteral(\n      FeedbackSource const& source);\n  ProcessedFeedback const& ReadFeedbackForTemplateObject(\n      FeedbackSource const& source);\n\n  void CollectArrayAndObjectPrototypes();\n\n  void set_persistent_handles(\n      std::unique_ptr<PersistentHandles> persistent_handles) {\n    DCHECK_NULL(ph_);\n    ph_ = std::move(persistent_handles);\n    DCHECK_NOT_NULL(ph_);\n  }\n  std::unique_ptr<PersistentHandles> DetachPersistentHandles() {\n    DCHECK_NOT_NULL(ph_);\n    return std::move(ph_);\n  }\n\n  void set_canonical_handles(CanonicalHandlesMap* canonical_handles) {\n    canonical_handles_ = canonical_handles;\n  }\n\n#define V(Type, name, Name) void Init##Name();\n  READ_ONLY_ROOT_LIST(V)\n#undef V\n\n  Isolate* const isolate_;\n#if V8_COMPRESS_POINTERS\n  const PtrComprCageBase cage_base_;\n#endif  // V8_COMPRESS_POINTERS\n  Zone* const zone_;\n  OptionalNativeContextRef target_native_context_;\n  RefsMap* refs_;\n  RootIndexMap root_index_map_;\n  ZoneUnorderedSet<IndirectHandle<JSObject>, IndirectHandle<JSObject>::hash,\n                   IndirectHandle<JSObject>::equal_to>\n      array_and_object_prototypes_;\n  BrokerMode mode_ = kDisabled;\n  bool const tracing_enabled_;\n  CodeKind const code_kind_;\n  std::unique_ptr<PersistentHandles> ph_;\n  LocalIsolate* local_isolate_ = nullptr;\n  // The CanonicalHandlesMap is owned by the compilation info.\n  CanonicalHandlesMap* canonical_handles_;\n  unsigned trace_indentation_ = 0;\n  ZoneUnorderedMap<FeedbackSource, ProcessedFeedback const*,\n                   FeedbackSource::Hash, FeedbackSource::Equal>\n      feedback_;\n  ZoneUnorderedMap<PropertyAccessTarget, PropertyAccessInfo,\n                   PropertyAccessTarget::Hash, PropertyAccessTarget::Equal>\n      property_access_infos_;\n\n  // Cache read only roots to avoid needing to look them up via the map.\n#define V(Type, name, Name) \\\n  OptionalRef<typename ref_traits<Type>::ref_type> name##_;\n  READ_ONLY_ROOT_LIST(V)\n#undef V\n\n  CompilationDependencies* dependencies_ = nullptr;\n\n  // The MapUpdater mutex is used in recursive patterns; for example,\n  // ComputePropertyAccessInfo may call itself recursively. Thus we need to\n  // emulate a recursive mutex, which we do by checking if this heap broker\n  // instance already holds the mutex when a lock is requested. This field\n  // holds the locking depth, i.e. how many times the mutex has been\n  // recursively locked. Only the outermost locker actually locks underneath.\n  int map_updater_mutex_depth_ = 0;\n  // Likewise for boilerplate migrations.\n  int boilerplate_migration_mutex_depth_ = 0;\n\n  static constexpr uint32_t kMinimalRefsBucketCount = 8;\n  static_assert(base::bits::IsPowerOfTwo(kMinimalRefsBucketCount));\n  static constexpr uint32_t kInitialRefsBucketCount = 1024;\n  static_assert(base::bits::IsPowerOfTwo(kInitialRefsBucketCount));\n};\n        ]]></code>\n    </class>\n    <enum>\n      <metadata>\n        {\n          \"language\": \"cpp\",\n          \"type\": \"enum\",\n          \"name\": \"GetOrCreateDataFlag\",\n          \"about\": \"Flags for GetOrCreateData function to control its behavior.\",\n          \"dependencies\": []\n        }\n      </metadata>\n      <code><![CDATA[\nenum GetOrCreateDataFlag {\n  // If set, a failure to create the data object results in a crash.\n  kCrashOnError = 1 << 0,\n  // If set, data construction assumes that the given object is protected by\n  // a memory fence (e.g. acquire-release) and thus fields required for\n  // construction (like Object::map) are safe to read. The protection can\n  // extend to some other situations as well.\n  kAssumeMemoryFence = 1 << 1,\n};\n      ]]></code>\n    </enum>\n    <typedef>\n      <metadata>\n        {\n          \"language\": \"cpp\",\n          \"type\": \"typedef\",\n          \"name\": \"GetOrCreateDataFlags\",\n          \"about\": \"Typedef for GetOrCreateDataFlags as flags for GetOrCreateDataFlag enum\",\n          \"dependencies\": [\n            \"GetOrCreateDataFlag\"\n          ]\n        }\n      </metadata>\n      <code><![CDATA[\nusing GetOrCreateDataFlags = base::Flags<GetOrCreateDataFlag>;\nDEFINE_OPERATORS_FOR_FLAGS(GetOrCreateDataFlags)\n      ]]></code>\n    </typedef>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"PropertyAccessTarget\",\n                \"about\": \"Represents the target of a property access, including the map, name, and access mode.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"MapRef\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The map of the object being accessed.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"NameRef\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The name of the property being accessed.\"\n                    },\n                    {\n                        \"name\": \"mode\",\n                        \"type\": \"AccessMode\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The access mode (e.g., read, write).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"MapRef\",\n                    \"NameRef\",\n                    \"AccessMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct PropertyAccessTarget {\n  MapRef map;\n  NameRef name;\n  AccessMode mode;\n\n  struct Hash {\n    size_t operator()(const PropertyAccessTarget& pair) const {\n      return base::hash_combine(\n          base::hash_combine(pair.map.object().address(),\n                             pair.name.object().address()),\n          static_cast<int>(pair.mode));\n    }\n  };\n  struct Equal {\n    bool operator()(const PropertyAccessTarget& lhs,\n                    const PropertyAccessTarget& rhs) const {\n      return lhs.map.equals(rhs.map) && lhs.name.equals(rhs.name) &&\n             lhs.mode == rhs.mode;\n    }\n  };\n};\n        ]]></code>\n    </struct>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"BrokerMode\",\n                \"about\": \"Represents the different modes the JSHeapBroker can operate in.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum JSHeapBroker::BrokerMode { kDisabled, kSerializing, kSerialized, kRetired };\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RecursiveMutexGuardIfNeeded\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"A guard that locks a mutex only if it's the first occurrence in a recursive locking pattern.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"mutex_depth_address_\",\n                        \"type\": \"int* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Address of the mutex depth counter.\"\n                    },\n                    {\n                        \"name\": \"initial_mutex_depth_\",\n                        \"type\": \"const int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Initial mutex depth.\"\n                    },\n                    {\n                        \"name\": \"mutex_guard_\",\n                        \"type\": \"ParkedMutexGuardIf\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Parked mutex guard.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"LocalIsolate\",\n                    \"base::Mutex\",\n                    \"ParkedMutexGuardIf\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class V8_NODISCARD RecursiveMutexGuardIfNeeded {\n   protected:\n    V8_INLINE RecursiveMutexGuardIfNeeded(LocalIsolate* local_isolate,\n                                          base::Mutex* mutex,\n                                          int* mutex_depth_address);\n\n    ~RecursiveMutexGuardIfNeeded() {\n      DCHECK_GE((*mutex_depth_address_), 1);\n      (*mutex_depth_address_)--;\n      DCHECK_EQ(initial_mutex_depth_, (*mutex_depth_address_));\n    }\n\n   private:\n    int* const mutex_depth_address_;\n    const int initial_mutex_depth_;\n    ParkedMutexGuardIf mutex_guard_;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MapUpdaterGuardIfNeeded\",\n                \"extends\": \"RecursiveMutexGuardIfNeeded\",\n                \"implements\": [],\n                \"about\": \"A guard specifically for map updates that locks the mutex only if needed (recursive).\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class MapUpdaterGuardIfNeeded final : public RecursiveMutexGuardIfNeeded {\n   public:\n    V8_INLINE explicit MapUpdaterGuardIfNeeded(JSHeapBroker* broker);\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BoilerplateMigrationGuardIfNeeded\",\n                \"extends\": \"RecursiveMutexGuardIfNeeded\",\n                \"implements\": [],\n                \"about\": \"A guard specifically for boilerplate migrations that locks the mutex only if needed (recursive).\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class BoilerplateMigrationGuardIfNeeded final\n      : public RecursiveMutexGuardIfNeeded {\n   public:\n    V8_INLINE explicit BoilerplateMigrationGuardIfNeeded(JSHeapBroker* broker);\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CurrentHeapBrokerScope\",\n                \"about\": \"A scope that stores the current heap broker on a thread local for debug builds.\",\n                \"dependencies\": [\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\n// In debug builds, store the current heap broker on a thread local, for\n// DCHECKs to access it via JSHeapBroker::Current();\nclass V8_NODISCARD V8_EXPORT_PRIVATE CurrentHeapBrokerScope {\n public:\n  explicit CurrentHeapBrokerScope(JSHeapBroker* broker);\n  ~CurrentHeapBrokerScope();\n\n private:\n  JSHeapBroker* const prev_broker_;\n};\n#else\nclass V8_NODISCARD V8_EXPORT_PRIVATE CurrentHeapBrokerScope {\n public:\n  explicit CurrentHeapBrokerScope(JSHeapBroker* broker) {}\n  ~CurrentHeapBrokerScope() {}\n};\n#endif\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TraceScope\",\n                \"about\": \"A scope for tracing the execution of code with indentation.\",\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"ObjectData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_NODISCARD TraceScope {\n public:\n  TraceScope(JSHeapBroker* broker, const char* label)\n      : TraceScope(broker, static_cast<void*>(broker), label) {}\n\n  TraceScope(JSHeapBroker* broker, ObjectData* data, const char* label)\n      : TraceScope(broker, static_cast<void*>(data), label) {}\n\n  TraceScope(JSHeapBroker* broker, void* subject, const char* label)\n      : broker_(broker) {\n    TRACE_BROKER(broker_, \"Running \" << label << \" on \" << subject);\n    broker_->IncrementTracingIndentation();\n  }\n\n  ~TraceScope() { broker_->DecrementTracingIndentation(); }\n\n private:\n  JSHeapBroker* const broker_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \""
}