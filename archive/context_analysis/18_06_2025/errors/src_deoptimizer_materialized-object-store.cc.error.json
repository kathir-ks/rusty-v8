{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/materialized-object-store.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 48, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/materialized-object-store.cc\",\n        \"file_name\": \"materialized-object-store.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements a store for materialized objects during deoptimization, mapping stack frame pointers to FixedArrays containing the materialized objects.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for materialized object store functionality including FixedArray manipulation, isolate access, and other utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/deoptimizer/materialized-object-store.h\"\n\n#include \"src/execution/isolate.h\"\n#include \"src/heap/heap-inl.h\"\n#include \"src/objects/fixed-array-inl.h\"\n#include \"src/objects/oddball.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MaterializedObjectStore\",\n            \"about\": \"Stores materialized objects associated with stack frames during deoptimization. It maps frame pointers to FixedArrays containing the materialized objects.\",\n            \"attributes\": [\n                {\n                    \"name\": \"frame_fps_\",\n                    \"type\": \"std::vector<Address>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the frame pointers (fp) as keys.\"\n                }\n            ],\n            \"dependencies\": [\n                \"FixedArray\",\n                \"Isolate\",\n                \"Handle\",\n                \"Address\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nclass MaterializedObjectStore {\n public:\n  DirectHandle<FixedArray> Get(Address fp);\n  void Set(Address fp, DirectHandle<FixedArray> materialized_objects);\n  bool Remove(Address fp);\n\n private:\n  int StackIdToIndex(Address fp);\n  DirectHandle<FixedArray> GetStackEntries();\n  DirectHandle<FixedArray> EnsureStackEntries(int length);\n\n  std::vector<Address> frame_fps_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Get\",\n            \"parent\": \"MaterializedObjectStore\",\n            \"about\": \"Retrieves the FixedArray of materialized objects associated with a given frame pointer.\",\n            \"logic\": \"Converts the frame pointer to an index, retrieves the FixedArray from the store, and returns a handle to it.\",\n            \"parameters\": [\n                {\n                    \"name\": \"fp\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The frame pointer to look up.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DirectHandle<FixedArray>\",\n                \"description\": \"A handle to the FixedArray if found, otherwise a null handle.\"\n            },\n            \"dependencies\": [\n                \"StackIdToIndex\",\n                \"GetStackEntries\",\n                \"FixedArray\",\n                \"Handle\",\n                \"Object\",\n                \"Cast\",\n                \"isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<FixedArray> MaterializedObjectStore::Get(Address fp) {\n  int index = StackIdToIndex(fp);\n  if (index == -1) {\n    return Handle<FixedArray>::null();\n  }\n  DirectHandle<FixedArray> array = GetStackEntries();\n  CHECK_GT(array->length(), index);\n  return Cast<FixedArray>(Handle<Object>(array->get(index), isolate()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Set\",\n            \"parent\": \"MaterializedObjectStore\",\n            \"about\": \"Associates a FixedArray of materialized objects with a given frame pointer.\",\n            \"logic\": \"Converts the frame pointer to an index. If not present it adds the frame pointer to the frame_fps_. It then ensures the stack entries array is large enough and sets the materialized objects at the index.\",\n            \"parameters\": [\n                {\n                    \"name\": \"fp\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The frame pointer to associate with the objects.\"\n                },\n                {\n                    \"name\": \"materialized_objects\",\n                    \"type\": \"DirectHandle<FixedArray>\",\n                    \"purpose\": \"The FixedArray of materialized objects.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StackIdToIndex\",\n                \"EnsureStackEntries\",\n                \"FixedArray\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MaterializedObjectStore::Set(\n    Address fp, DirectHandle<FixedArray> materialized_objects) {\n  int index = StackIdToIndex(fp);\n  if (index == -1) {\n    index = static_cast<int>(frame_fps_.size());\n    frame_fps_.push_back(fp);\n  }\n\n  DirectHandle<FixedArray> array = EnsureStackEntries(index + 1);\n  array->set(index, *materialized_objects);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Remove\",\n            \"parent\": \"MaterializedObjectStore\",\n            \"about\": \"Removes the association between a frame pointer and its materialized objects.\",\n            \"logic\": \"Finds the frame pointer in the frame_fps_ vector, removes it, and shifts the subsequent entries in the materialized_objects array to fill the gap. Sets the last value in the array to undefined.\",\n            \"parameters\": [\n                {\n                    \"name\": \"fp\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The frame pointer to remove.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the frame pointer was found and removed, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"std::find\",\n                \"frame_fps_\",\n                \"std::distance\",\n                \"isolate\",\n                \"heap\",\n                \"materialized_objects\",\n                \"CHECK_LT\",\n                \"ReadOnlyRoots\",\n                \"undefined_value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MaterializedObjectStore::Remove(Address fp) {\n  auto it = std::find(frame_fps_.begin(), frame_fps_.end(), fp);\n  if (it == frame_fps_.end()) return false;\n  int index = static_cast<int>(std::distance(frame_fps_.begin(), it));\n\n  frame_fps_.erase(it);\n  Tagged<FixedArray> array = isolate()->heap()->materialized_objects();\n\n  CHECK_LT(index, array->length());\n  int fps_size = static_cast<int>(frame_fps_.size());\n  for (int i = index; i < fps_size; i++) {\n    array->set(i, array->get(i + 1));\n  }\n  array->set(fps_size, ReadOnlyRoots(isolate()).undefined_value());\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"StackIdToIndex\",\n            \"parent\": \"MaterializedObjectStore\",\n            \"about\": \"Converts a frame pointer to an index in the frame_fps_ vector.\",\n            \"logic\": \"Searches for the frame pointer in the frame_fps_ vector and returns its index if found, otherwise returns -1.\",\n            \"parameters\": [\n                {\n                    \"name\": \"fp\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The frame pointer to look up.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The index of the frame pointer in the frame_fps_ vector, or -1 if not found.\"\n            },\n            \"dependencies\": [\n                \"std::find\",\n                \"frame_fps_\",\n                \"std::distance\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint MaterializedObjectStore::StackIdToIndex(Address fp) {\n  auto it = std::find(frame_fps_.begin(), frame_fps_.end(), fp);\n  return it == frame_fps_.end()\n             ? -1\n             : static_cast<int>(std::distance(frame_fps_.begin(), it));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetStackEntries\",\n            \"parent\": \"MaterializedObjectStore\",\n            \"about\": \"Retrieves the FixedArray that stores the materialized objects from the isolate's heap.\",\n            \"logic\": \"Accesses the isolate's heap and returns the FixedArray which holds the materialized objects.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"DirectHandle<FixedArray>\",\n                \"description\": \"A DirectHandle to the FixedArray containing the materialized objects.\"\n            },\n            \"dependencies\": [\n                \"isolate\",\n                \"heap\",\n                \"materialized_objects\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<FixedArray> MaterializedObjectStore::GetStackEntries() {\n  return DirectHandle<FixedArray>(isolate()->heap()->materialized_objects(),\n                                  isolate());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EnsureStackEntries\",\n            \"parent\": \"MaterializedObjectStore\",\n            \"about\": \"Ensures that the FixedArray for stack entries is large enough to hold the specified length.\",\n            \"logic\": \"If the current array is too small, it creates a new, larger array, copies the existing entries, and sets any new entries to undefined. Then it sets the root materialized objects of the heap to the new array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"length\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The minimum required length of the FixedArray.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DirectHandle<FixedArray>\",\n                \"description\": \"A DirectHandle to the FixedArray (either the original or a newly created one) that is large enough.\"\n            },\n            \"dependencies\": [\n                \"GetStackEntries\",\n                \"FixedArray\",\n                \"factory\",\n                \"NewFixedArray\",\n                \"AllocationType::kOld\",\n                \"Tagged<HeapObject>\",\n                \"ReadOnlyRoots\",\n                \"undefined_value\",\n                \"isolate\",\n                \"heap\",\n                \"SetRootMaterializedObjects\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<FixedArray> MaterializedObjectStore::EnsureStackEntries(\n    int length) {\n  DirectHandle<FixedArray> array = GetStackEntries();\n  if (array->length() >= length) {\n    return array;\n  }\n\n  int new_length = length > 10 ? length : 10;\n  if (new_length < 2 * array->length()) {\n    new_length = 2 * array->length();\n  }\n\n  DirectHandle<FixedArray> new_array =\n      isolate()->factory()->NewFixedArray(new_length, AllocationType::kOld);\n  for (int i = 0; i < array->length(); i++) {\n    new_array->set(i, array->get(i));\n  }\n  Tagged<HeapObject> undefined_value =\n      ReadOnlyRoots(isolate()).undefined_value();\n  for (int i = array->length(); i < length; i++) {\n    new_array->set(i, undefined_value);\n  }\n  isolate()->heap()->SetRootMaterializedObjects(*new_array);\n  return new_array;\n}\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FixedArray\",\n                \"about\": \"Represents a fixed-size array of objects in the V8 heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class FixedArray {\n            public:\n                int length();\n                Object get(int index);\n                void set(int index, Object value);\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Isolate {\n            public:\n                Heap* heap();\n                Factory* factory();\n                ReadOnlyRoots& read_only_roots();\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Heap\",\n                \"about\": \"Represents the V8 heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Heap {\n            public:\n                FixedArray materialized_objects();\n                void SetRootMaterializedObjects(HeapObject object);\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Factory\",\n                \"about\": \"Used to create objects in the V8 heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class Factory {\n            public:\n                DirectHandle<FixedArray> NewFixedArray(int length, AllocationType allocation_type);\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReadOnlyRoots\",\n                \"about\": \"Provides access to read-only objects in the V8 heap, like undefined.\"\n            }\n            </metadata>\n            <code><![CDATA[\n            class ReadOnlyRoots {\n            public:\n                Tagged<HeapObject> undefined_value();\n            };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}