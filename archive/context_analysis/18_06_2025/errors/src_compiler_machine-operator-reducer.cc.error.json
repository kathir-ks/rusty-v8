{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/machine-operator-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/machine-operator-reducer.cc\",\n        \"file_name\": \"machine-operator-reducer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Performs constant folding and strength reduction on machine operators in the Turbofan compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for compiler, standard library, and V8 base utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/machine-operator-reducer.h\"\n\n            #include <cmath>\n            #include <cstdint>\n            #include <limits>\n            #include <optional>\n\n            #include \"src/base/bits.h\"\n            #include \"src/base/division-by-constant.h\"\n            #include \"src/base/ieee754.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/base/overflowing-math.h\"\n            #include \"src/builtins/builtins.h\"\n            #include \"src/compiler/diamond.h\"\n            #include \"src/compiler/js-operator.h\"\n            #include \"src/compiler/machine-graph.h\"\n            #include \"src/compiler/node-matchers.h\"\n            #include \"src/compiler/node-properties.h\"\n            #include \"src/compiler/opcodes.h\"\n            #include \"src/compiler/turbofan-graph.h\"\n            #include \"src/numbers/conversions-inl.h\"\n            #include \"src/numbers/ieee754.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Word32Adapter\",\n            \"about\": \"Adapts a generic algorithm to Word32 operations.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"MachineOperatorReducer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Word32Adapter {\n            public:\n            using IntNBinopMatcher = Int32BinopMatcher;\n            using UintNBinopMatcher = Uint32BinopMatcher;\n            using intN_t = int32_t;\n            using uintN_t = uint32_t;\n            // WORD_SIZE refers to the N for which this adapter specializes.\n            static constexpr std::size_t WORD_SIZE = 32;\n\n            explicit Word32Adapter(MachineOperatorReducer* reducer) : r_(reducer) {}\n\n            template <typename T>\n            static bool IsWordNAnd(const T& x) {\n                return x.IsWord32And();\n            }\n            template <typename T>\n            static bool IsWordNShl(const T& x) {\n                return x.IsWord32Shl();\n            }\n            template <typename T>\n            static bool IsWordNShr(const T& x) {\n                return x.IsWord32Shr();\n            }\n            template <typename T>\n            static bool IsWordNSar(const T& x) {\n                return x.IsWord32Sar();\n            }\n            static bool IsWordNSarShiftOutZeros(const Operator* op) {\n                return op->opcode() == IrOpcode::kWord32Sar &&\n                    OpParameter<ShiftKind>(op) == ShiftKind::kShiftOutZeros;\n            }\n            template <typename T>\n            static bool IsWordNXor(const T& x) {\n                return x.IsWord32Xor();\n            }\n            template <typename T>\n            static bool IsIntNAdd(const T& x) {\n                return x.IsInt32Add();\n            }\n            template <typename T>\n            static bool IsIntNMul(const T& x) {\n                return x.IsInt32Mul();\n            }\n\n            const Operator* IntNAdd(MachineOperatorBuilder* machine) {\n                return machine->Int32Add();\n            }\n            static const Operator* WordNEqual(MachineOperatorBuilder* machine) {\n                return machine->Word32Equal();\n            }\n\n            Reduction ReplaceIntN(int32_t value) { return r_->ReplaceInt32(value); }\n            Reduction ReduceWordNAnd(Node* node) { return r_->ReduceWord32And(node); }\n            Reduction ReduceIntNAdd(Node* node) { return r_->ReduceInt32Add(node); }\n            Reduction TryMatchWordNRor(Node* node) { return r_->TryMatchWord32Ror(node); }\n\n            Node* IntNConstant(int32_t value) { return r_->Int32Constant(value); }\n            Node* UintNConstant(uint32_t value) { return r_->Uint32Constant(value); }\n            Node* WordNAnd(Node* lhs, Node* rhs) { return r_->Word32And(lhs, rhs); }\n\n            Reduction ReduceWordNComparisons(Node* node) {\n                return r_->ReduceWord32Comparisons(node);\n            }\n\n            private:\n            MachineOperatorReducer* r_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Word64Adapter\",\n            \"about\": \"Adapts a generic algorithm to Word64 operations.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"MachineOperatorReducer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Word64Adapter {\n            public:\n            using IntNBinopMatcher = Int64BinopMatcher;\n            using UintNBinopMatcher = Uint64BinopMatcher;\n            using intN_t = int64_t;\n            using uintN_t = uint64_t;\n            // WORD_SIZE refers to the N for which this adapter specializes.\n            static constexpr std::size_t WORD_SIZE = 64;\n\n            explicit Word64Adapter(MachineOperatorReducer* reducer) : r_(reducer) {}\n\n            template <typename T>\n            static bool IsWordNAnd(const T& x) {\n                return x.IsWord64And();\n            }\n            template <typename T>\n            static bool IsWordNShl(const T& x) {\n                return x.IsWord64Shl();\n            }\n            template <typename T>\n            static bool IsWordNShr(const T& x) {\n                return x.IsWord64Shr();\n            }\n            template <typename T>\n            static bool IsWordNSar(const T& x) {\n                return x.IsWord64Sar();\n            }\n            static bool IsWordNSarShiftOutZeros(const Operator* op) {\n                return op->opcode() == IrOpcode::kWord64Sar &&\n                    OpParameter<ShiftKind>(op) == ShiftKind::kShiftOutZeros;\n            }\n            template <typename T>\n            static bool IsWordNXor(const T& x) {\n                return x.IsWord64Xor();\n            }\n            template <typename T>\n            static bool IsIntNAdd(const T& x) {\n                return x.IsInt64Add();\n            }\n            template <typename T>\n            static bool IsIntNMul(const T& x) {\n                return x.IsInt64Mul();\n            }\n\n            static const Operator* IntNAdd(MachineOperatorBuilder* machine) {\n                return machine->Int64Add();\n            }\n            static const Operator* WordNEqual(MachineOperatorBuilder* machine) {\n                return machine->Word64Equal();\n            }\n\n            Reduction ReplaceIntN(int64_t value) { return r_->ReplaceInt64(value); }\n            Reduction ReduceWordNAnd(Node* node) { return r_->ReduceWord64And(node); }\n            Reduction ReduceIntNAdd(Node* node) { return r_->ReduceInt64Add(node); }\n            Reduction TryMatchWordNRor(Node* node) {\n                // TODO(nicohartmann@): Add a MachineOperatorReducer::TryMatchWord64Ror.\n                return r_->NoChange();\n            }\n\n            Node* IntNConstant(int64_t value) { return r_->Int64Constant(value); }\n            Node* UintNConstant(uint64_t value) { return r_->Uint64Constant(value); }\n            Node* WordNAnd(Node* lhs, Node* rhs) { return r_->Word64And(lhs, rhs); }\n\n            Reduction ReduceWordNComparisons(Node* node) {\n                return r_->ReduceWord64Comparisons(node);\n            }\n\n            private:\n            MachineOperatorReducer* r_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SilenceNaN\",\n            \"about\": \"Silences a signaling NaN by performing a calculation.\",\n            \"logic\": \"The function checks if the input is NaN and then performs a subtraction of the NaN from itself, effectively making it a quiet NaN.\",\n            \"parameters\": [\n                {\n                    \"name\": \"x\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The floating-point value to silence if it's a signaling NaN.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T\",\n                \"description\": \"A quiet NaN if the input was a signaling NaN, otherwise the original value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n\n            // TODO(jgruber): Consider replacing all uses of this function by\n            // std::numeric_limits<T>::quiet_NaN().\n            template <class T>\n            T SilenceNaN(T x) {\n            DCHECK(std::isnan(x));\n            // Do some calculation to make a signalling NaN quiet.\n            return x - x;\n            }\n\n            }  // namespace\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MachineOperatorReducer\",\n            \"about\": \"Performs constant folding and strength reduction on machine operators.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"AdvancedReducer\",\n                \"Editor\",\n                \"MachineGraph\",\n                \"SignallingNanPropagation\",\n                \"Node\",\n                \"MachineRepresentation\",\n                \"Int32BinopMatcher\",\n                \"IrOpcode\",\n                \"Float64BinopMatcher\",\n                \"Float32BinopMatcher\",\n                \"Int32Matcher\",\n                \"Float64Matcher\",\n                \"Int64Matcher\",\n                \"Uint32Matcher\",\n                \"Uint64Matcher\",\n                \"NodeMatcher\",\n                \"LoadRepresentation\",\n                \"Edge\",\n                \"BranchHint\",\n                \"StoreRepresentation\",\n                \"UnalignedStoreRepresentation\",\n                \"Word32Adapter\",\n                \"Word64Adapter\",\n                \"BitfieldCheck\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            MachineOperatorReducer::MachineOperatorReducer(\n                Editor* editor, MachineGraph* mcgraph,\n                SignallingNanPropagation signalling_nan_propagation)\n                : AdvancedReducer(editor),\n                mcgraph_(mcgraph),\n                signalling_nan_propagation_(signalling_nan_propagation) {}\n\n            MachineOperatorReducer::~MachineOperatorReducer() = default;\n\n            Node* MachineOperatorReducer::Float32Constant(float value) {\n            return graph()->NewNode(common()->Float32Constant(value));\n            }\n\n            Node* MachineOperatorReducer::Float64Constant(double value) {\n            return mcgraph()->Float64Constant(value);\n            }\n\n            Node* MachineOperatorReducer::Int32Constant(int32_t value) {\n            return mcgraph()->Int32Constant(value);\n            }\n\n            Node* MachineOperatorReducer::Int64Constant(int64_t value) {\n            return graph()->NewNode(common()->Int64Constant(value));\n            }\n\n            Node* MachineOperatorReducer::Float64Mul(Node* lhs, Node* rhs) {\n            return graph()->NewNode(machine()->Float64Mul(), lhs, rhs);\n            }\n\n            Node* MachineOperatorReducer::Float64PowHalf(Node* value) {\n            value =\n                graph()->NewNode(machine()->Float64Add(), Float64Constant(0.0), value);\n            Diamond d(graph(), common(),\n                        graph()->NewNode(machine()->Float64LessThanOrEqual(), value,\n                                         Float64Constant(-V8_INFINITY)),\n                        BranchHint::kFalse);\n            return d.Phi(MachineRepresentation::kFloat64, Float64Constant(V8_INFINITY),\n                        graph()->NewNode(machine()->Float64Sqrt(), value));\n            }\n\n            Node* MachineOperatorReducer::Word32And(Node* lhs, Node* rhs) {\n            Node* const node = graph()->NewNode(machine()->Word32And(), lhs, rhs);\n            Reduction const reduction = ReduceWord32And(node);\n            return reduction.Changed() ? reduction.replacement() : node;\n            }\n\n            Node* MachineOperatorReducer::Word32Sar(Node* lhs, uint32_t rhs) {\n            if (rhs == 0) return lhs;\n            return graph()->NewNode(machine()->Word32Sar(), lhs, Uint32Constant(rhs));\n            }\n\n            Node* MachineOperatorReducer::Word64Sar(Node* lhs, uint32_t rhs) {\n            if (rhs == 0) return lhs;\n            return graph()->NewNode(machine()->Word64Sar(), lhs, Uint64Constant(rhs));\n            }\n\n            Node* MachineOperatorReducer::Word32Shr(Node* lhs, uint32_t rhs) {\n            if (rhs == 0) return lhs;\n            return graph()->NewNode(machine()->Word32Shr(), lhs, Uint32Constant(rhs));\n            }\n\n            Node* MachineOperatorReducer::Word64Shr(Node* lhs, uint32_t rhs) {\n            if (rhs == 0) return lhs;\n            return graph()->NewNode(machine()->Word64Shr(), lhs, Uint64Constant(rhs));\n            }\n\n            Node* MachineOperatorReducer::Word32Equal(Node* lhs, Node* rhs) {\n            return graph()->NewNode(machine()->Word32Equal(), lhs, rhs);\n            }\n\n            Node* MachineOperatorReducer::Word64Equal(Node* lhs, Node* rhs) {\n            return graph()->NewNode(machine()->Word64Equal(), lhs, rhs);\n            }\n\n            Node* MachineOperatorReducer::Word64And(Node* lhs, Node* rhs) {\n            Node* const node = graph()->NewNode(machine()->Word64And(), lhs, rhs);\n            Reduction const reduction = ReduceWord64And(node);\n            return reduction.Changed() ? reduction.replacement() : node;\n            }\n\n            Node* MachineOperatorReducer::Int32Add(Node* lhs, Node* rhs) {\n            Node* const node = graph()->NewNode(machine()->Int32Add(), lhs, rhs);\n            Reduction const reduction = ReduceInt32Add(node);\n            return reduction.Changed() ? reduction.replacement() : node;\n            }\n\n            Node* MachineOperatorReducer::Int64Add(Node* lhs, Node* rhs) {\n            Node* const node = graph()->NewNode(machine()->Int64Add(), lhs, rhs);\n            Reduction const reduction = ReduceInt64Add(node);\n            return reduction.Changed() ? reduction.replacement() : node;\n            }\n\n            Node* MachineOperatorReducer::Int32Sub(Node* lhs, Node* rhs) {\n            Node* const node = graph()->NewNode(machine()->Int32Sub(), lhs, rhs);\n            Reduction const reduction = ReduceInt32Sub(node);\n            return reduction.Changed() ? reduction.replacement() : node;\n            }\n\n            Node* MachineOperatorReducer::Int64Sub(Node* lhs, Node* rhs) {\n            Node* const node = graph()->NewNode(machine()->Int64Sub(), lhs, rhs);\n            Reduction const reduction = ReduceInt64Sub(node);\n            return reduction.Changed() ? reduction.replacement() : node;\n            }\n\n            Node* MachineOperatorReducer::Int32Mul(Node* lhs, Node* rhs) {\n            return graph()->NewNode(machine()->Int32Mul(), lhs, rhs);\n            }\n\n            Node* MachineOperatorReducer::Int64Mul(Node* lhs, Node* rhs) {\n            return graph()->NewNode(machine()->Int64Mul(), lhs, rhs);\n            }\n\n            Node* MachineOperatorReducer::Int32Div(Node* dividend, int32_t divisor) {\n            DCHECK_NE(0, divisor);\n            DCHECK_NE(std::numeric_limits<int32_t>::min(), divisor);\n            base::MagicNumbersForDivision<uint32_t> const mag =\n                base::SignedDivisionByConstant(base::bit_cast<uint32_t>(divisor));\n            Node* quotient = graph()->NewNode(machine()->Int32MulHigh(), dividend,\n                                                Uint32Constant(mag.multiplier));\n            if (divisor > 0 && base::bit_cast<int32_t>(mag.multiplier) < 0) {\n                quotient = Int32Add(quotient, dividend);\n            } else if (divisor < 0 && base::bit_cast<int32_t>(mag.multiplier) > 0) {\n                quotient = Int32Sub(quotient, dividend);\n            }\n            return Int32Add(Word32Sar(quotient, mag.shift), Word32Shr(dividend, 31));\n            }\n\n            Node* MachineOperatorReducer::Int64Div(Node* dividend, int64_t divisor) {\n            DCHECK_NE(0, divisor);\n            DCHECK_NE(std::numeric_limits<int64_t>::min(), divisor);\n            base::MagicNumbersForDivision<uint64_t> const mag =\n                base::SignedDivisionByConstant(base::bit_cast<uint64_t>(divisor));\n            Node* quotient = graph()->NewNode(machine()->Int64MulHigh(), dividend,\n                                                Uint64Constant(mag.multiplier));\n            if (divisor > 0 && base::bit_cast<int64_t>(mag.multiplier) < 0) {\n                quotient = Int64Add(quotient, dividend);\n            } else if (divisor < 0 && base::bit_cast<int64_t>(mag.multiplier) > 0) {\n                quotient = Int64Sub(quotient, dividend);\n            }\n            return Int64Add(Word64Sar(quotient, mag.shift), Word64Shr(dividend, 63));\n            }\n\n            Node* MachineOperatorReducer::Uint32Div(Node* dividend, uint32_t divisor) {\n            DCHECK_LT(0u, divisor);\n            // If the divisor is even, we can avoid using the expensive fixup by shifting\n            // the dividend upfront.\n            unsigned const shift = base::bits::CountTrailingZeros(divisor);\n            dividend = Word32Shr(dividend, shift);\n            divisor >>= shift;\n            // Compute the magic number for the (shifted) divisor.\n            base::MagicNumbersForDivision<uint32_t> const mag =\n                base::UnsignedDivisionByConstant(divisor, shift);\n            Node* quotient = graph()->NewNode(machine()->Uint32MulHigh(), dividend,\n                                                Uint32Constant(mag.multiplier));\n            if (mag.add) {\n                DCHECK_LE(1u, mag.shift);\n                quotient = Word32Shr(\n                    Int32Add(Word32Shr(Int32Sub(dividend, quotient), 1), quotient),\n                    mag.shift - 1);\n            } else {\n                quotient = Word32Shr(quotient, mag.shift);\n            }\n            return quotient;\n            }\n\n            Node* MachineOperatorReducer::Uint64Div(Node* dividend, uint64_t divisor) {\n            DCHECK_LT(0u, divisor);\n            // If the divisor is even, we can avoid using the expensive fixup by shifting\n            // the dividend upfront.\n            unsigned const shift = base::bits::CountTrailingZeros(divisor);\n            dividend = Word64Shr(dividend, shift);\n            divisor >>= shift;\n            // Compute the magic number for the (shifted) divisor.\n            base::MagicNumbersForDivision<uint64_t> const mag =\n                base::UnsignedDivisionByConstant(divisor, shift);\n            Node* quotient = graph()->NewNode(machine()->Uint64MulHigh(), dividend,\n                                                Uint64Constant(mag.multiplier));\n            if (mag.add) {\n                DCHECK_LE(1u, mag.shift);\n                quotient = Word64Shr(\n                    Int64Add(Word64Shr(Int64Sub(dividend, quotient), 1), quotient),\n                    mag.shift - 1);\n            } else {\n                quotient = Word64Shr(quotient, mag.shift);\n            }\n            return quotient;\n            }\n\n            Node* MachineOperatorReducer::TruncateInt64ToInt32(Node* value) {\n            Node* const node = graph()->NewNode(machine()->TruncateInt64ToInt32(), value);\n            Reduction const reduction = ReduceTruncateInt64ToInt32(node);\n            return reduction.Changed() ? reduction.replacement() : node;\n            }\n\n            Node* MachineOperatorReducer::ChangeInt32ToInt64(Node* value) {\n            return graph()->NewNode(machine()->ChangeInt32ToInt64(), value);\n            }\n\n            // Perform constant folding and strength reduction on machine operators.\n            Reduction MachineOperatorReducer::Reduce(Node* node) {\n            switch (node->opcode()) {\n                case IrOpcode::kProjection:\n                return ReduceProjection(ProjectionIndexOf(node->op()), node->InputAt(0));\n                case IrOpcode::kWord32And:\n                return ReduceWord32And(node);\n                case IrOpcode::kWord64And:\n                return ReduceWord64And(node);\n                case IrOpcode::kWord32Or:\n                return ReduceWord32Or(node);\n                case IrOpcode::kWord64Or:\n                return ReduceWord64Or(node);\n                case IrOpcode::kWord32Xor:\n                return ReduceWord32Xor(node);\n                case IrOpcode::kWord64Xor:\n                return ReduceWord64Xor(node);\n                case IrOpcode::kWord32Shl:\n                return ReduceWord32Shl(node);\n                case IrOpcode::kWord64Shl:\n                return ReduceWord64Shl(node);\n                case IrOpcode::kWord32Shr:\n                return ReduceWord32Shr(node);\n                case IrOpcode::kWord64Shr:\n                return ReduceWord64Shr(node);\n                case IrOpcode::kWord32Sar:\n                return ReduceWord32Sar(node);\n                case IrOpcode::kWord64Sar:\n                return ReduceWord64Sar(node);\n                case IrOpcode::kWord32Ror: {\n                Int32BinopMatcher m(node);\n                if (m.right().Is(0)) return Replace(m.left().node());  // x ror 0 => x\n                if (m.IsFoldable()) {  // K ror K => K  (K stands for arbitrary constants)\n                    return ReplaceInt32(base::bits::RotateRight32(\n                        m.left().ResolvedValue(), m.right().ResolvedValue() & 31));\n                }\n                break;\n                }\n                case IrOpcode::kWord32Equal:\n                return ReduceWord32Equal(node);\n                case IrOpcode::kWord64Equal:\n                return ReduceWord64Equal(node);\n                case IrOpcode::kInt32Add:\n                return ReduceInt32Add(node);\n                case IrOpcode::kInt64Add:\n                return ReduceInt64Add(node);\n                case IrOpcode::kInt32Sub:\n                return ReduceInt32Sub(node);\n                case IrOpcode::kInt64Sub:\n                return ReduceInt64Sub(node);\n                case IrOpcode::kInt32Mul: {\n                Int32BinopMatcher m(node);\n                if (m.right().Is(0)) return Replace(m.right().node());  // x * 0 => 0\n                if (m.right().Is(1)) return Replace(m.left().node());   // x * 1 => x\n                if (m.IsFoldable()) {  // K * K => K  (K stands for arbitrary constants)\n                    return ReplaceInt32(base::MulWithWraparound(m.left().ResolvedValue(),\n                                                                m.right().ResolvedValue()));\n                }\n                if (m.right().Is(-1)) {  // x * -1 => 0 - x\n                    node->ReplaceInput(0, Int32Constant(0));\n                    node->ReplaceInput(1, m.left().node());\n                    NodeProperties::ChangeOp(node, machine()->Int32Sub());\n                    return Changed(node);\n                }\n                if (m.right().IsPowerOf2()) {  // x * 2^n => x << n\n                    node->ReplaceInput(1, Int32Constant(base::bits::WhichPowerOfTwo(\n                                                                m.right().ResolvedValue())));\n                    NodeProperties::ChangeOp(node, machine()->Word32Shl());\n                    return Changed(node).FollowedBy(ReduceWord32Shl(node));\n                }\n                // (x * Int32Constant(a)) * Int32Constant(b)) => x * Int32Constant(a * b)\n                if (m.right().HasResolvedValue() && m.left().IsInt32Mul()) {\n                    Int32BinopMatcher n(m.left().node());\n                    if (n.right().HasResolvedValue() && m.OwnsInput(m.left().node())) {\n                    node->ReplaceInput(\n                        1, Int32Constant(base::MulWithWraparound(\n                                            m.right().ResolvedValue(), n.right().ResolvedValue())));\n                    node->ReplaceInput(0, n.left().node());\n                    return Changed(node);\n                    }\n                }\n                break;\n                }\n                case IrOpcode::kInt32MulWithOverflow: {\n                Int32BinopMatcher m(node);\n                if (m.right().Is(2)) {\n                    node->ReplaceInput(1, m.left().node());\n                    NodeProperties::ChangeOp(node, machine()->Int32AddWithOverflow());\n                    return Changed(node);\n                }\n                if (m.right().Is(-1)) {\n                    node->ReplaceInput(0, Int32Constant(0));\n                    node->ReplaceInput(1, m.left().node());\n                    NodeProperties::ChangeOp(node, machine()->Int32SubWithOverflow());\n                    return Changed(node);\n                }\n                break;\n                }\n                case IrOpcode::kInt64Mul:\n                return ReduceInt64Mul(node);\n                case IrOpcode::kInt32Div:\n                return ReduceInt32Div(node);\n                case IrOpcode::kInt64Div:\n                return ReduceInt64Div(node);\n                case IrOpcode::kUint32Div:\n                return ReduceUint32Div(node);\n                case IrOpcode::kUint64Div:\n                return ReduceUint64Div(node);\n                case IrOpcode::kInt32Mod:\n                return ReduceInt32Mod(node);\n                case IrOpcode::kInt64Mod:\n                return ReduceInt64Mod(node);\n                case IrOpcode::kUint32Mod:\n                return ReduceUint32Mod(node);\n                case IrOpcode::kUint64Mod:\n                return ReduceUint64Mod(node);\n                case IrOpcode::kInt32LessThan: {\n                Int32BinopMatcher m(node);\n                if (m.IsFoldable()) {  // K < K => K  (K stands for arbitrary constants)\n                    return ReplaceBool(m.left().ResolvedValue() <\n                                        m.right().ResolvedValue());\n                }\n                if (m.LeftEqualsRight()) return ReplaceBool(false);  // x < x => false\n                if (m.left().IsWord32Or() && m.right().Is(0)) {\n                    // (x | K) < 0 => true or (K | x) < 0 => true iff K < 0\n                    Int32BinopMatcher mleftmatcher(m.left().node());\n                    if (mleftmatcher.left().IsNegative() ||\n                        mleftmatcher.right().IsNegative()) {\n                    return ReplaceBool(true);\n                    }\n                }\n                return ReduceWord32Comparisons(node);\n                }\n                case IrOpcode::kInt32LessThanOrEqual: {\n                Int32BinopMatcher m(node);\n                if (m.IsFoldable()) {  // K <= K => K  (K stands for arbitrary constants)\n                    return ReplaceBool(m.left().ResolvedValue() <=\n                                        m.right().ResolvedValue());\n                }\n                if (m.LeftEqualsRight()) return ReplaceBool(true);  // x <= x => true\n                return ReduceWord32Comparisons(node);\n                }\n                case IrOpcode::kUint32LessThan: {\n                Uint32BinopMatcher m(node);\n                if (m.left().Is(kMaxUInt32)) return ReplaceBool(false);  // M < x => false\n                if (m.right().Is(0)) return ReplaceBool(false);          // x < 0 => false\n                if (m.IsFoldable()) {  // K < K => K  (K stands for arbitrary constants)\n                    return ReplaceBool(m.left().ResolvedValue() <\n                                        m.right().ResolvedValue());\n                }\n                if (m.LeftEqualsRight()) return ReplaceBool(false);  // x < x => false\n                if (m.left().IsWord32Sar() && m.right().HasResolvedValue()) {\n                    Int32BinopMatcher mleft(m.left().node());\n                    if (mleft.right().HasResolvedValue()) {\n                    // (x >> K) < C => x < (C << K)\n                    // when C < (M >> K)\n                    const uint32_t c = m.right().ResolvedValue();\n                    const uint32_t k = mleft.right().ResolvedValue() & 0x1F;\n                    if (c < static_cast<uint32_t>(kMaxInt >> k)) {\n                        node->ReplaceInput(0, mleft.left().node());\n                        node->ReplaceInput(1, Uint32Constant(c << k));\n                        return Changed(node);\n                    }\n                    // TODO(turbofan): else the comparison is always true.\n                    }\n                }\n                return ReduceWord32Comparisons(node);\n                }\n                case IrOpcode::kUint32LessThanOrEqual: {\n                return ReduceUintNLessThanOrEqual<Word32Adapter>(node);\n                }\n                case IrOpcode::kFloat32Sub: {\n                Float32BinopMatcher m(node);\n                if (signalling_nan_propagation_ == kPropagateSignallingNan &&\n                    m.right().Is(0) &&\n                    (std::copysign(1.0, m.right().ResolvedValue()) > 0)) {\n                    return Replace(m.left().node());  // x - 0 => x\n                }\n                if (m.right().IsNaN()) {  // x - NaN => NaN\n                    return ReplaceFloat32(SilenceNaN(m.right().ResolvedValue()));\n                }\n                if (m.left().IsNaN()) {  // NaN - x => NaN\n                    return ReplaceFloat32(SilenceNaN(m.left().ResolvedValue()));\n                }\n                if (m.IsFoldable()) {  // L - R => (L - R)\n                    return ReplaceFloat32(m.left().ResolvedValue() -\n                                        m.right().ResolvedValue());\n                }\n                if (signalling_nan_propagation_ == kPropagateSignallingNan &&\n                    m.left().IsMinusZero()) {\n                    // -0.0 - round_down(-0.0 - R) => round_up(R)\n                    if (machine()->Float32RoundUp().IsSupported() &&\n                        m.right().IsFloat32RoundDown()) {\n                    if (m.right().InputAt(0)->opcode() == IrOpcode::kFloat32Sub) {\n                        Float32BinopMatcher mright0(m.right().InputAt(0));\n                        if (mright0.left().IsMinusZero()) {\n                        return Replace(graph()->NewNode(machine()->Float32RoundUp().op(),\n                                                        mright0.right().node()));\n                        }\n                    }\n                    }\n                    // -0.0 - R => -R\n                    node->RemoveInput(0);\n                    NodeProperties::ChangeOp(node, machine()->Float32Neg());\n                    return Changed(node);\n                }\n                break;\n                }\n                case IrOpcode::kFloat64Add: {\n                Float64BinopMatcher m(node);\n                if (m.right().IsNaN()) {  // x + NaN => NaN\n                    return ReplaceFloat64(SilenceNaN(m.right().ResolvedValue()));\n                }\n                if (m.left().IsNaN()) {  // NaN + x => NaN\n                    return ReplaceFloat64(SilenceNaN(m.left().ResolvedValue()));\n                }\n                if (m.IsFoldable()) {  // K + K => K  (K stands for arbitrary constants)\n                    return ReplaceFloat64(m.left().ResolvedValue() +\n                                        m.right().ResolvedValue());\n                }\n                break;\n                }\n                case IrOpcode::kFloat64Sub: {\n                Float64BinopMatcher m(node);\n                if (signalling_nan_propagation_ == kPropagateSignalling"
}