{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/mips64/instruction-selector-mips64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/mips64/instruction-selector-mips64.cc\",\n        \"file_name\": \"instruction-selector-mips64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the instruction selector for the MIPS64 architecture within the V8 compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for base utilities, logging, code generation, and compiler backend components.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/bits.h\"\n#include \"src/base/logging.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/compiler/backend/instruction-selector-impl.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Mips64OperandGeneratorT\",\n            \"extends\": \"OperandGeneratorT\",\n            \"about\": \"Generates MIPS64-specific InstructionOperands for instruction selection.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ConstantOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass Mips64OperandGeneratorT final : public OperandGeneratorT {\n public:\n  explicit Mips64OperandGeneratorT(InstructionSelectorT* selector)\n      : OperandGeneratorT(selector) {}\n\n  InstructionOperand UseOperand(OpIndex node, InstructionCode opcode) {\n    if (CanBeImmediate(node, opcode)) {\n      return UseImmediate(node);\n    }\n    return UseRegister(node);\n  }\n\n  // Use the zero register if the node has the immediate value zero, otherwise\n  // assign a register.\n  InstructionOperand UseRegisterOrImmediateZero(OpIndex node) {\n    if (const ConstantOp* constant =\n            selector()->Get(node).TryCast<ConstantOp>()) {\n      if ((constant->IsIntegral() && constant->integral() == 0) ||\n          (constant->kind == ConstantOp::Kind::kFloat32 &&\n           constant->float32().get_bits() == 0) ||\n          (constant->kind == ConstantOp::Kind::kFloat64 &&\n           constant->float64().get_bits() == 0)) {\n        return UseImmediate(node);\n      }\n    }\n    return UseRegister(node);\n  }\n\n  bool IsIntegerConstant(OpIndex node) {\n    int64_t unused;\n    return selector()->MatchSignedIntegralConstant(node, &unused);\n  }\n\n  std::optional<int64_t> GetOptionalIntegerConstant(OpIndex operation) {\n    if (int64_t constant; MatchSignedIntegralConstant(operation, &constant)) {\n      return constant;\n    }\n    return std::nullopt;\n  }\n\n  bool CanBeImmediate(OpIndex node, InstructionCode mode) {\n    const ConstantOp* constant = selector()->Get(node).TryCast<ConstantOp>();\n    if (!constant) return false;\n\n    int64_t value;\n    return selector()->MatchSignedIntegralConstant(node, &value) &&\n           CanBeImmediate(value, mode);\n  }\n\n  bool CanBeImmediate(int64_t value, InstructionCode opcode) {\n    switch (ArchOpcodeField::decode(opcode)) {\n      case kMips64Shl:\n      case kMips64Sar:\n      case kMips64Shr:\n        return is_uint5(value);\n      case kMips64Dshl:\n      case kMips64Dsar:\n      case kMips64Dshr:\n        return is_uint6(value);\n      case kMips64Add:\n      case kMips64And32:\n      case kMips64And:\n      case kMips64Dadd:\n      case kMips64Or32:\n      case kMips64Or:\n      case kMips64Tst:\n      case kMips64Xor:\n        return is_uint16(value);\n      case kMips64Lb:\n      case kMips64Lbu:\n      case kMips64Sb:\n      case kMips64Lh:\n      case kMips64Lhu:\n      case kMips64Sh:\n      case kMips64Lw:\n      case kMips64Sw:\n      case kMips64Ld:\n      case kMips64Sd:\n      case kMips64Lwc1:\n      case kMips64Swc1:\n      case kMips64Ldc1:\n      case kMips64Sdc1:\n        return is_int32(value);\n      default:\n        return is_int16(value);\n    }\n  }\n\n private:\n  bool ImmediateFitsAddrMode1Instruction(int32_t imm) const {\n    TRACE(\"UNIMPLEMENTED instr_sel: %s at line %d\\n\", __FUNCTION__, __LINE__);\n    return false;\n  }\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRR\",\n            \"about\": \"Emits an instruction with two register operands.\",\n            \"logic\": \"Defines the output as a register and uses the first input as a register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Mips64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitRR(InstructionSelectorT* selector, ArchOpcode opcode,\n                    OpIndex node) {\n  Mips64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRI\",\n            \"about\": \"Emits an instruction with two register operands and one immediate operand.\",\n            \"logic\": \"Placeholder; currently unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitRRI(InstructionSelectorT* selector, ArchOpcode opcode,\n                     OpIndex node) {\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitSimdShift\",\n            \"about\": \"Handles instruction selection for SIMD shift operations.\",\n            \"logic\": \"Placeholder; currently unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitSimdShift(InstructionSelectorT* selector, ArchOpcode opcode,\n                           OpIndex node) {\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRIR\",\n            \"about\": \"Emits an instruction with two register operands, one immediate operand, and another register operand.\",\n            \"logic\": \"Placeholder; currently unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitRRIR(InstructionSelectorT* selector, ArchOpcode opcode,\n                      OpIndex node) {\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRR\",\n            \"about\": \"Emits an instruction with three register operands.\",\n            \"logic\": \"Defines the output as a register and uses the first two inputs as registers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Mips64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRRR(InstructionSelectorT* selector, ArchOpcode opcode, OpIndex node) {\n  Mips64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)),\n                 g.UseRegister(selector->input_at(node, 1)));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitUniqueRRR\",\n            \"about\": \"Emits an instruction with three unique register operands.\",\n            \"logic\": \"Placeholder; currently unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitUniqueRRR(InstructionSelectorT* selector, ArchOpcode opcode,\n                           OpIndex node) {\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRRR\",\n            \"about\": \"Emits an instruction with four register operands.\",\n            \"logic\": \"Placeholder; currently unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRRRR(InstructionSelectorT* selector, ArchOpcode opcode,\n               OpIndex node) {\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRO\",\n            \"about\": \"Emits an instruction with two register operands and one generic operand.\",\n            \"logic\": \"Defines the output as a register and uses the first input as a register and the second as a generic operand.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Mips64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitRRO(InstructionSelectorT* selector, ArchOpcode opcode,\n                     OpIndex node) {\n  Mips64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)),\n                 g.UseOperand(selector->input_at(node, 1), opcode));\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ExtendingLoadMatcher\",\n            \"about\": \"Matches specific extending load patterns for optimization.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OpIndex\",\n                \"InstructionSelectorT\",\n                \"ShiftOp\",\n                \"LoadOp\",\n                \"Mips64OperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct ExtendingLoadMatcher {\n  ExtendingLoadMatcher(OpIndex node, InstructionSelectorT* selector)\n      : matches_(false), selector_(selector), immediate_(0) {\n    Initialize(node);\n  }\n\n  bool Matches() const { return matches_; }\n\n  OpIndex base() const {\n    DCHECK(Matches());\n    return base_;\n  }\n  int64_t immediate() const {\n    DCHECK(Matches());\n    return immediate_;\n  }\n  ArchOpcode opcode() const {\n    DCHECK(Matches());\n    return opcode_;\n  }\n\n private:\n  bool matches_;\n  InstructionSelectorT* selector_;\n  OpIndex base_{};\n  int64_t immediate_;\n  ArchOpcode opcode_;\n\n  void Initialize(turboshaft::OpIndex node) {\n    const ShiftOp& shift = selector_->Get(node).template Cast<ShiftOp>();\n    DCHECK(shift.kind == ShiftOp::Kind::kShiftRightArithmetic ||\n           shift.kind == ShiftOp::Kind::kShiftRightArithmeticShiftOutZeros);\n    // When loading a 64-bit value and shifting by 32, we should\n    // just load and sign-extend the interesting 4 bytes instead.\n    // This happens, for example, when we're loading and untagging SMIs.\n    const Operation& lhs = selector_->Get(shift.left());\n    int64_t constant_rhs;\n\n    if (lhs.Is<LoadOp>() &&\n        selector_->MatchIntegralWord64Constant(shift.right(), &constant_rhs) &&\n        constant_rhs == 32 && selector_->CanCover(node, shift.left())) {\n      Mips64OperandGeneratorT g(selector_);\n\n      const LoadOp& load = lhs.Cast<LoadOp>();\n      base_ = load.base();\n      opcode_ = kMips64Lw;\n      if (load.index().has_value()) {\n        int64_t index_constant;\n        if (selector_->MatchIntegralWord64Constant(load.index().value(),\n                                                   &index_constant)) {\n          DCHECK_EQ(load.element_size_log2, 0);\n          immediate_ = index_constant + 4;\n          matches_ = g.CanBeImmediate(immediate_, kMips64Lw);\n        }\n      } else {\n        immediate_ = load.offset + 4;\n        matches_ = g.CanBeImmediate(immediate_, kMips64Lw);\n      }\n    }\n  }\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryEmitExtendingLoad\",\n            \"about\": \"Attempts to emit an optimized extending load instruction.\",\n            \"logic\": \"Uses ExtendingLoadMatcher to identify suitable load patterns and emit the corresponding instruction if a match is found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                },\n                {\n                    \"name\": \"output_node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node that represent output of the operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if an extending load was emitted, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ExtendingLoadMatcher\",\n                \"Mips64OperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TryEmitExtendingLoad(InstructionSelectorT* selector, OpIndex node,\n                          OpIndex output_node) {\n  ExtendingLoadMatcher m(node, selector);\n  Mips64OperandGeneratorT g(selector);\n  if (m.Matches()) {\n    InstructionOperand inputs[2];\n    inputs[0] = g.UseRegister(m.base());\n    InstructionCode opcode =\n        m.opcode() | AddressingModeField::encode(kMode_MRI);\n    DCHECK(is_int32(m.immediate()));\n    inputs[1] = g.TempImmediate(static_cast<int32_t>(m.immediate()));\n    InstructionOperand outputs[] = {g.DefineAsRegister(output_node)};\n    selector->Emit(opcode, arraysize(outputs), outputs, arraysize(inputs),\n                   inputs);\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchImmediate\",\n            \"about\": \"Tries to match an immediate operand for a given instruction.\",\n            \"logic\": \"Checks if a node can be represented as an immediate value for a given opcode. If so, encodes the addressing mode and sets the input operand.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the opcode to be updated.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                },\n                {\n                    \"name\": \"input_count_return\",\n                    \"type\": \"size_t*\",\n                    \"purpose\": \"Pointer to the input count to be updated.\"\n                },\n                {\n                    \"name\": \"inputs\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the array of input operands.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if an immediate was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"Mips64OperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TryMatchImmediate(InstructionSelectorT* selector,\n                       InstructionCode* opcode_return, OpIndex node,\n                       size_t* input_count_return, InstructionOperand* inputs) {\n  Mips64OperandGeneratorT g(selector);\n  if (g.CanBeImmediate(node, *opcode_return)) {\n    *opcode_return |= AddressingModeField::encode(kMode_MRI);\n    inputs[0] = g.UseImmediate(node);\n    *input_count_return = 1;\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Visits a binary operation and emits the corresponding instruction.\",\n            \"logic\": \"Handles immediate matching for binary operations, potentially using reverse opcodes if necessary.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The primary opcode for the binary operation.\"\n                },\n                {\n                    \"name\": \"has_reverse_opcode\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether a reverse opcode is available.\"\n                },\n                {\n                    \"name\": \"reverse_opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The reverse opcode, if available.\"\n                },\n                {\n                    \"name\": \"cont\",\n                    \"type\": \"FlagsContinuationT*\",\n                    \"purpose\": \"The flags continuation for the instruction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"Mips64OperandGeneratorT\",\n                \"FlagsContinuationT\",\n                \"TryMatchImmediate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                       InstructionCode opcode, bool has_reverse_opcode,\n                       InstructionCode reverse_opcode,\n                       FlagsContinuationT* cont) {\n  Mips64OperandGeneratorT g(selector);\n  InstructionOperand inputs[2];\n  size_t input_count = 0;\n  InstructionOperand outputs[1];\n  size_t output_count = 0;\n\n  const Operation& binop = selector->Get(node);\n  OpIndex left_node = binop.input(0);\n  OpIndex right_node = binop.input(1);\n\n  if (TryMatchImmediate(selector, &opcode, right_node, &input_count,\n                        &inputs[1])) {\n    inputs[0] = g.UseRegister(left_node);\n    input_count++;\n  } else if (has_reverse_opcode &&\n             TryMatchImmediate(selector, &reverse_opcode, left_node,\n                               &input_count, &inputs[1])) {\n    inputs[0] = g.UseRegister(right_node);\n    opcode = reverse_opcode;\n    input_count++;\n  } else {\n    inputs[input_count++] = g.UseRegister(left_node);\n    inputs[input_count++] = g.UseOperand(right_node, opcode);\n  }\n\n  outputs[output_count++] = g.DefineAsRegister(node);\n\n  DCHECK_NE(0u, input_count);\n  DCHECK_EQ(1u, output_count);\n  DCHECK_GE(arraysize(inputs), input_count);\n  DCHECK_GE(arraysize(outputs), output_count);\n\n  selector->EmitWithContinuation(opcode, output_count, outputs, input_count,\n                                 inputs, cont);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Overload of VisitBinop that omits the FlagsContinuationT* argument.\",\n            \"logic\": \"Calls the main VisitBinop function with a default FlagsContinuationT.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The primary opcode for the binary operation.\"\n                },\n                {\n                    \"name\": \"has_reverse_opcode\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether a reverse opcode is available.\"\n                },\n                {\n                    \"name\": \"reverse_opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The reverse opcode, if available.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"FlagsContinuationT\",\n                \"VisitBinop\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                       InstructionCode opcode, bool has_reverse_opcode,\n                       InstructionCode reverse_opcode) {\n  FlagsContinuationT cont;\n  VisitBinop(selector, node, opcode, has_reverse_opcode, reverse_opcode, &cont);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Overload of VisitBinop that omits the reverse opcode and FlagsContinuationT* argument.\",\n            \"logic\": \"Calls the main VisitBinop function with a default FlagsContinuationT and no reverse opcode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The primary opcode for the binary operation.\"\n                },\n                {\n                    \"name\": \"cont\",\n                    \"type\": \"FlagsContinuationT*\",\n                    \"purpose\": \"The flags continuation for the instruction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"VisitBinop\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                       InstructionCode opcode, FlagsContinuationT* cont) {\n  VisitBinop(selector, node, opcode, false, kArchNop, cont);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Overload of VisitBinop that omits the reverse opcode and flags continuation.\",\n            \"logic\": \"Calls the main VisitBinop function with a default FlagsContinuationT, no reverse opcode\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The primary opcode for the binary operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"VisitBinop\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                       InstructionCode opcode) {\n  VisitBinop(selector, node, opcode, false, kArchNop);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitStackSlot\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Allocates a stack slot and emits an instruction to access it.\",\n            \"logic\": \"Allocates a spill slot in the frame and emits an ArchStackSlot instruction to represent the stack slot.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"StackSlotOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitStackSlot(OpIndex node) {\n  const StackSlotOp& stack_slot = Cast<StackSlotOp>(node);\n  int slot = frame_->AllocateSpillSlot(stack_slot.size, stack_slot.alignment,\n                                       stack_slot.is_tagged);\n  OperandGenerator g(this);\n\n  Emit(kArchStackSlot, g.DefineAsRegister(node),\n       sequence()->AddImmediate(Constant(slot)), 0, nullptr);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitAbortCSADcheck\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Emits an instruction to abort a CSAD (Code Sandboxing Abort Check) check.\",\n            \"logic\": \"Emits an instruction that triggers a code sandboxing abort check.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"Mips64OperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitAbortCSADcheck(OpIndex node) {\n  Mips64OperandGeneratorT g(this);\n  Emit(kArchAbortCSADcheck, g.NoOutput(),\n       g.UseFixed(this->input_at(node, 0), a0));\n}\n        ]]></code>\n    </"
}