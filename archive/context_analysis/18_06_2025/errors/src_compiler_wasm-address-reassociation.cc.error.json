{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-address-reassociation.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 63, column 69",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-address-reassociation.cc\",\n            \"file_name\": \"wasm-address-reassociation.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the WasmAddressReassociation optimization pass in the V8 compiler, which reassociates address computations in WebAssembly code to enable more efficient code generation by utilizing immediate offsets.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary V8 compiler headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/wasm-address-reassociation.h\"\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/machine-graph.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operator.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmAddressReassociation\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"This class implements the WasmAddressReassociation optimization pass.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"Graph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The graph being optimized.\"\n                    },\n                    {\n                        \"name\": \"common_\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builder for common operators.\"\n                    },\n                    {\n                        \"name\": \"machine_\",\n                        \"type\": \"MachineOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builder for machine operators.\"\n                    },\n                    {\n                        \"name\": \"candidate_base_addrs_\",\n                        \"type\": \"ZoneUnorderedMap<CandidateAddressKey, CandidateBaseAddr>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores candidate base addresses for reassociation.\"\n                    },\n                    {\n                        \"name\": \"candidates_\",\n                        \"type\": \"ZoneUnorderedMap<CandidateAddressKey, CandidateMemOps>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores candidate memory operations for reassociation.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The zone used for memory allocation.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"JSGraph\",\n                    \"Zone\",\n                    \"Graph\",\n                    \"CommonOperatorBuilder\",\n                    \"MachineOperatorBuilder\",\n                    \"CandidateAddressKey\",\n                    \"CandidateBaseAddr\",\n                    \"CandidateMemOps\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass WasmAddressReassociation {\n public:\n  WasmAddressReassociation(JSGraph* jsgraph, Zone* zone);\n\n  void Optimize();\n\n private:\n  bool ShouldTryOptimize(const CandidateAddressKey& key) const;\n  Node* CreateNewBase(const CandidateAddressKey& key);\n  void ReplaceInputs(Node* mem_op, Node* base, Node* offset);\n  void VisitProtectedMemOp(Node* node, NodeId effect_chain);\n  void AddCandidate(Node* mem_op, Node* base, Node* reg_offset,\n                     int64_t imm_offset, NodeId effect_chain);\n  bool HasCandidateBaseAddr(const CandidateAddressKey& key) const;\n\n  Graph* graph_;\n  CommonOperatorBuilder* common_;\n  MachineOperatorBuilder* machine_;\n  ZoneUnorderedMap<CandidateAddressKey, CandidateBaseAddr> candidate_base_addrs_;\n  ZoneUnorderedMap<CandidateAddressKey, CandidateMemOps> candidates_;\n  Zone* zone_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CandidateMemOps\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Helper class to store candidate memory operations for reassociation.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"mem_ops_\",\n                        \"type\": \"ZoneVector<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector to store memory operation nodes.\"\n                    },\n                    {\n                        \"name\": \"imm_offsets_\",\n                        \"type\": \"ZoneVector<int64_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector to store immediate offsets.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The zone used for memory allocation.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Node\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class CandidateMemOps {\n   public:\n    explicit CandidateMemOps(Zone* zone) : mem_ops_(zone), imm_offsets_(zone), zone_(zone) {}\n    void AddCandidate(Node* mem_op, int64_t imm_offset);\n    size_t GetNumNodes() const;\n    Node* mem_op(size_t i) const;\n    int64_t imm_offset(size_t i) const;\n\n   private:\n    ZoneVector<Node*> mem_ops_;\n    ZoneVector<int64_t> imm_offsets_;\n    Zone* zone_;\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"WasmAddressReassociation\",\n                \"parent\": \"WasmAddressReassociation\",\n                \"about\": \"Constructor for WasmAddressReassociation.\",\n                \"logic\": \"Initializes the WasmAddressReassociation object with the graph, common operator builder, machine operator builder, and zone.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"jsgraph\",\n                        \"type\": \"JSGraph*\",\n                        \"purpose\": \"The JSGraph containing the graph to be optimized.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone used for memory allocation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"JSGraph\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nWasmAddressReassociation::WasmAddressReassociation(JSGraph* jsgraph, Zone* zone)\n    : graph_(jsgraph->graph()),\n      common_(jsgraph->common()),\n      machine_(jsgraph->machine()),\n      candidate_base_addrs_(zone),\n      candidates_(zone),\n      zone_(zone) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Optimize\",\n                \"parent\": \"WasmAddressReassociation\",\n                \"about\": \"The main optimization function.\",\n                \"logic\": \"Iterates through candidate memory operations and reassociates addresses to enable more efficient code generation. Creates new base nodes and replaces inputs to memory operations.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CandidateAddressKey\",\n                    \"CandidateMemOps\",\n                    \"CreateNewBase\",\n                    \"ReplaceInputs\",\n                    \"ShouldTryOptimize\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmAddressReassociation::Optimize() {\n  for (auto& candidate : candidates_) {\n    const CandidateAddressKey& key = candidate.first;\n    if (!ShouldTryOptimize(key)) continue;\n    // We've found multiple instances of addresses in the form\n    // object(base + imm_offset), reg_offset\n    // So, create a new object for these operations to share and then use an\n    // immediate offset:\n    // object(base, reg_offset), imm_offset\n    Node* new_object = CreateNewBase(key);\n    CandidateMemOps& mem_ops = candidate.second;\n    size_t num_nodes = mem_ops.GetNumNodes();\n    for (size_t i = 0; i < num_nodes; ++i) {\n      Node* mem_op = mem_ops.mem_op(i);\n      Node* imm_offset =\n          graph_->NewNode(common_->Int64Constant(mem_ops.imm_offset(i)));\n      ReplaceInputs(mem_op, new_object, imm_offset);\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ShouldTryOptimize\",\n                \"parent\": \"WasmAddressReassociation\",\n                \"about\": \"Determines whether to attempt optimization for a given candidate key.\",\n                \"logic\": \"Checks if the number of nodes associated with the candidate key is greater than 1, which is a heuristic to ensure that the benefits of optimization outweigh any detrimental effects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"const CandidateAddressKey&\",\n                        \"purpose\": \"The candidate address key to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if optimization should be attempted, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"CandidateAddressKey\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool WasmAddressReassociation::ShouldTryOptimize(\n    const CandidateAddressKey& key) const {\n  // We already process the graph in terms of effect chains in an attempt to\n  // reduce the risk of creating large live-ranges, but also set a lower\n  // bound for the number of required users so that the benefits are more\n  // likely to outweigh any detrimental affects, such as additions being shared\n  // and so the number of operations is increased. Benchmarking showed two or\n  // more was a good heuristic.\n  return candidates_.at(key).GetNumNodes() > 1;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CreateNewBase\",\n                \"parent\": \"WasmAddressReassociation\",\n                \"about\": \"Creates a new base node for reassociated addresses.\",\n                \"logic\": \"Retrieves the base and offset nodes from the candidate base address and creates a new Int64Add node to represent the new base.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"const CandidateAddressKey&\",\n                        \"purpose\": \"The candidate address key.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The new base node.\"\n                },\n                \"dependencies\": [\n                    \"CandidateAddressKey\",\n                    \"CandidateBaseAddr\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmAddressReassociation::CreateNewBase(const CandidateAddressKey& key) {\n  CandidateBaseAddr& candidate_base_addr = candidate_base_addrs_.at(key);\n  Node* base = candidate_base_addr.base();\n  Node* reg_offset = candidate_base_addr.offset();\n  return graph_->NewNode(machine_->Int64Add(), base, reg_offset);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReplaceInputs\",\n                \"parent\": \"WasmAddressReassociation\",\n                \"about\": \"Replaces the inputs of a memory operation node with the new base and offset.\",\n                \"logic\": \"Replaces the first and second inputs of the memory operation node with the new base and offset nodes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"mem_op\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The memory operation node to modify.\"\n                    },\n                    {\n                        \"name\": \"base\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The new base node.\"\n                    },\n                    {\n                        \"name\": \"offset\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The new offset node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmAddressReassociation::ReplaceInputs(Node* mem_op, Node* base,\n                                             Node* offset) {\n  DCHECK_GT(mem_op->InputCount(), 1);\n  DCHECK(NodeProperties::IsConstant(offset));\n  mem_op->ReplaceInput(0, base);\n  mem_op->ReplaceInput(1, offset);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VisitProtectedMemOp\",\n                \"parent\": \"WasmAddressReassociation\",\n                \"about\": \"Visits a protected memory operation node to identify candidate addresses for reassociation.\",\n                \"logic\": \"Checks if the memory operation is a ProtectedLoad or ProtectedStore. Analyzes the base and offset inputs to identify potential address reassociation opportunities. Adds candidates if the address computation matches the expected patterns.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The memory operation node to visit.\"\n                    },\n                    {\n                        \"name\": \"effect_chain\",\n                        \"type\": \"NodeId\",\n                        \"purpose\": \"The ID of the effect chain node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IrOpcode\",\n                    \"Int64BinopMatcher\",\n                    \"AddCandidate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmAddressReassociation::VisitProtectedMemOp(Node* node,\n                                                   NodeId effect_chain) {\n  DCHECK(node->opcode() == IrOpcode::kProtectedLoad ||\n         node->opcode() == IrOpcode::kProtectedStore);\n\n  Node* base(node->InputAt(0));\n  Node* offset(node->InputAt(1));\n\n  if (base->opcode() == IrOpcode::kInt64Add &&\n      offset->opcode() == IrOpcode::kInt64Add) {\n    Int64BinopMatcher base_add(base);\n    Int64BinopMatcher offset_add(offset);\n    if (base_add.right().HasResolvedValue() &&\n        !base_add.left().HasResolvedValue() &&\n        offset_add.right().HasResolvedValue() &&\n        !offset_add.left().HasResolvedValue()) {\n      Node* base_reg = base_add.left().node();\n      Node* reg_offset = offset_add.left().node();\n      int64_t imm_offset =\n          base_add.right().ResolvedValue() + offset_add.right().ResolvedValue();\n      return AddCandidate(node, base_reg, reg_offset, imm_offset, effect_chain);\n    }\n  }\n  if (base->opcode() == IrOpcode::kInt64Add) {\n    Int64BinopMatcher base_add(base);\n    if (base_add.right().HasResolvedValue() &&\n        !base_add.left().HasResolvedValue()) {\n      Node* base_reg = base_add.left().node();\n      Node* reg_offset = node->InputAt(1);\n      int64_t imm_offset = base_add.right().ResolvedValue();\n      return AddCandidate(node, base_reg, reg_offset, imm_offset, effect_chain);\n    }\n  }\n  if (offset->opcode() == IrOpcode::kInt64Add) {\n    Int64BinopMatcher offset_add(offset);\n    if (offset_add.right().HasResolvedValue() &&\n        !offset_add.left().HasResolvedValue()) {\n      Node* base_reg = node->InputAt(0);\n      Node* reg_offset = offset_add.left().node();\n      int64_t imm_offset = offset_add.right().ResolvedValue();\n      return AddCandidate(node, base_reg, reg_offset, imm_offset, effect_chain);\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddCandidate\",\n                \"parent\": \"WasmAddressReassociation\",\n                \"about\": \"Adds a candidate memory operation to the list of candidates for reassociation.\",\n                \"logic\": \"Creates a key based on the base and offset nodes, and effect chain. Stores the base, offset, and immediate offset associated with the memory operation. Swaps base/reg_offset so order doesn't matter in the key.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"mem_op\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The memory operation node.\"\n                    },\n                    {\n                        \"name\": \"base\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The base node.\"\n                    },\n                    {\n                        \"name\": \"reg_offset\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The register offset node.\"\n                    },\n                    {\n                        \"name\": \"imm_offset\",\n                        \"type\": \"int64_t\",\n                        \"purpose\": \"The immediate offset.\"\n                    },\n                    {\n                        \"name\": \"effect_chain\",\n                        \"type\": \"NodeId\",\n                        \"purpose\": \"The effect chain id.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CandidateAddressKey\",\n                    \"CandidateBaseAddr\",\n                    \"CandidateMemOps\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmAddressReassociation::AddCandidate(Node* mem_op, Node* base,\n                                            Node* reg_offset,\n                                            int64_t imm_offset,\n                                            NodeId effect_chain) {\n  // Sort base and offset so that the key is the same for either permutation.\n  if (base->id() > reg_offset->id()) {\n    std::swap(base, reg_offset);\n  }\n  CandidateAddressKey key =\n      std::make_tuple(base->id(), reg_offset->id(), effect_chain);\n  bool is_new =\n      candidate_base_addrs_.emplace(key, CandidateBaseAddr(base, reg_offset))\n          .second;\n  auto it = is_new ? candidates_.emplace(key, CandidateMemOps(zone_)).first\n                   : candidates_.find(key);\n  it->second.AddCandidate(mem_op, imm_offset);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HasCandidateBaseAddr\",\n                \"parent\": \"WasmAddressReassociation\",\n                \"about\": \"Checks if a candidate base address exists for a given key.\",\n                \"logic\": \"Checks if the candidate_base_addrs_ map contains the specified key.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"const CandidateAddressKey&\",\n                        \"purpose\": \"The candidate address key to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the candidate base address exists, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"CandidateAddressKey\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool WasmAddressReassociation::HasCandidateBaseAddr(\n    const CandidateAddressKey& key) const {\n  return candidate_base_addrs_.count(key);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddCandidate\",\n                \"parent\": \"CandidateMemOps\",\n                \"about\": \"Adds a candidate memory operation and its immediate offset.\",\n                \"logic\": \"Adds a memory operation and its immediate offset to the respective vectors.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"mem_op\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The memory operation node.\"\n                    },\n                    {\n                        \"name\": \"imm_offset\",\n                        \"type\": \"int64_t\",\n                        \"purpose\": \"The immediate offset.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IrOpcode\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmAddressReassociation::CandidateMemOps::AddCandidate(\n    Node* mem_op, int64_t imm_offset) {\n  DCHECK(mem_op->opcode() == IrOpcode::kProtectedLoad ||\n         mem_op->opcode() == IrOpcode::kProtectedStore);\n  mem_ops_.push_back(mem_op);\n  imm_offsets_.push_back(imm_offset);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetNumNodes\",\n                \"parent\": \"CandidateMemOps\",\n                \"about\": \"Gets the number of candidate memory operations.\",\n                \"logic\": \"Returns the size of the mem_ops_ vector.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The number of candidate memory operations.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nsize_t WasmAddressReassociation::CandidateMemOps::GetNumNodes() const {\n  DCHECK_EQ(mem_ops_.size(), imm_offsets_.size());\n  return mem_ops_.size();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"mem_op\",\n                \"parent\": \"CandidateMemOps\",\n                \"about\": \"Gets a memory operation node at a specific index.\",\n                \"logic\": \"Returns the memory operation node at the specified index from the mem_ops_ vector.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"i\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the memory operation node to retrieve.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The memory operation node at the specified index.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmAddressReassociation::CandidateMemOps::mem_op(size_t i) const {\n  return mem_ops_[i];\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"imm_offset\",\n                \"parent\": \"CandidateMemOps\",\n                \"about\": \"Gets the immediate offset at a specific index.\",\n                \"logic\": \"Returns the immediate offset at the specified index from the imm_offsets_ vector.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"i\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the immediate offset to retrieve.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int64_t\",\n                    \"description\": \"The immediate offset at the specified index.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nint64_t WasmAddressReassociation::CandidateMemOps::imm_offset(size_t i) const {\n  return imm_offsets_[i];\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"CandidateBaseAddr\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Struct to hold base address information.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"base_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The base node.\"\n                    },\n                    {\n                        \"name\": \"offset_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The offset node.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct CandidateBaseAddr {\n  CandidateBaseAddr(Node* base, Node* offset) : base_(base), offset_(offset) {}\n  Node* base() const { return base_; }\n  Node* offset() const { return offset_; }\n\n private:\n  Node* base_;\n  Node* offset_;\n};\n        ]]></code>\n    </class>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"CandidateAddressKey\",\n                \"about\": \"Type alias for the key used to store candidate addresses.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing CandidateAddressKey = std::tuple<NodeId, NodeId, NodeId>;\n        ]]></code>\n    </typedef>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSGraph\",\n                    \"about\": \"Represents the JavaScript graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class JSGraph {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Zone\",\n                    \"about\": \"Represents a memory allocation zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Zone {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Graph\",\n                    \"about\": \"Represents the compiler graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Graph {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CommonOperatorBuilder\",\n                    \"about\": \"Builds common operators.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class CommonOperatorBuilder {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"MachineOperatorBuilder\",\n                    \"about\": \"Builds machine operators.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class MachineOperatorBuilder {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Node\",\n                    \"about\": \"Represents a node in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Node {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Int64BinopMatcher\",\n                    \"about\": \"Matches int64 binary operations.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Int64BinopMatcher {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NodeProperties\",\n                    \"about\": \"Provides node property utilities.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class NodeProperties {};\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"IrOpcode\",\n                    \"about\": \"Enum of IR opcodes.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum class IrOpcode {\n                    kProtectedLoad,\n                    kProtectedStore,\n                    kInt64Add\n                };\n            ]]></code>\n        </enum>\n    </dependencies>\n</file>\n```"
}