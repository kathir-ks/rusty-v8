{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/type-inference-reducer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/type-inference-reducer.h\",\n        \"file_name\": \"type-inference-reducer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the TypeInferenceReducer, which infers types for Turboshaft graphs during compilation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for various functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <limits>\n#include <optional>\n\n#include \"src/base/logging.h\"\n#include \"src/base/vector.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/copying-phase.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/compiler/turboshaft/sidetable.h\"\n#include \"src/compiler/turboshaft/snapshot-table.h\"\n#include \"src/compiler/turboshaft/tracing.h\"\n#include \"src/compiler/turboshaft/type-inference-analysis.h\"\n#include \"src/compiler/turboshaft/typer.h\"\n#include \"src/compiler/turboshaft/types.h\"\n#include \"src/compiler/turboshaft/uniform-reducer-adapter.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"TypeInferenceReducerArgs\",\n            \"extends\": \"base::ContextualClass<TypeInferenceReducerArgs>\",\n            \"about\": \"Configuration options for the TypeInferenceReducer, determining how types are handled for input and output graphs.\",\n            \"attributes\": [\n                {\n                    \"name\": \"input_graph_typing\",\n                    \"type\": \"InputGraphTyping\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Specifies whether and how types are computed for the input graph.\"\n                },\n                {\n                    \"name\": \"output_graph_typing\",\n                    \"type\": \"OutputGraphTyping\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Specifies how types are computed or preserved for the output graph.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstruct TypeInferenceReducerArgs\n    : base::ContextualClass<TypeInferenceReducerArgs> {\n  enum class InputGraphTyping {\n    kNone,     // Do not compute types for the input graph.\n    kPrecise,  // Run a complete fixpoint analysis on the input graph.\n  };\n  enum class OutputGraphTyping {\n    kNone,                    // Do not compute types for the output graph.\n    kPreserveFromInputGraph,  // Reuse types of the input graph where\n                              // possible.\n    kRefineFromInputGraph,  // Reuse types of the input graph and compute types\n                            // for new nodes and more precise types where\n                            // possible.\n  };\n  InputGraphTyping input_graph_typing;\n  OutputGraphTyping output_graph_typing;\n\n  TypeInferenceReducerArgs(InputGraphTyping input_graph_typing,\n                           OutputGraphTyping output_graph_typing)\n      : input_graph_typing(input_graph_typing),\n        output_graph_typing(output_graph_typing) {}\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypeInferenceReducer\",\n            \"about\": \"The central component for inferring types for Turboshaft graphs. Uses different strategies based on the provided arguments.\",\n            \"attributes\": [\n                {\n                    \"name\": \"args_\",\n                    \"type\": \"TypeInferenceReducerArgs\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Configuration arguments for the reducer.\"\n                },\n                {\n                    \"name\": \"input_graph_types_\",\n                    \"type\": \"GrowingOpIndexSidetable<Type>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the inferred types for the input graph.\"\n                },\n                {\n                    \"name\": \"output_graph_types_\",\n                    \"type\": \"GrowingOpIndexSidetable<Type>&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Reference to the sidetable storing types for the output graph.\"\n                },\n                {\n                    \"name\": \"table_\",\n                    \"type\": \"SnapshotTable<Type>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A snapshot table used to track type information during block processing.\"\n                },\n                {\n                    \"name\": \"current_block_\",\n                    \"type\": \"const Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The currently being processed block.\"\n                },\n                {\n                    \"name\": \"op_to_key_mapping_\",\n                    \"type\": \"GrowingOpIndexSidetable<std::optional<SnapshotTable<Type>::Key>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mapping from operation index to snapshot table key.\"\n                },\n                {\n                    \"name\": \"block_to_snapshot_mapping_\",\n                    \"type\": \"GrowingBlockSidetable<std::optional<SnapshotTable<Type>::Snapshot>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mapping from block index to snapshot.\"\n                },\n                {\n                    \"name\": \"predecessors_\",\n                    \"type\": \"ZoneVector<SnapshotTable<Type>::Snapshot>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Used during snapshot merging, stores predecessor snapshots.\"\n                },\n                {\n                    \"name\": \"analyzer_\",\n                    \"type\": \"TypeInferenceAnalysis\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The type inference analysis object.\"\n                }\n            ],\n            \"dependencies\": [\n                \"UniformReducerAdapter\",\n                \"SnapshotTable\",\n                \"Type\",\n                \"TypeInferenceReducerArgs\",\n                \"TypeInferenceAnalysis\",\n                \"Typer\",\n                \"OpIndex\",\n                \"Block\",\n                \"Operation\",\n                \"BranchOp\",\n                \"TupleOp\",\n                \"ConstantOp\",\n                \"ComparisonOp\",\n                \"WordBinopOp\",\n                \"OverflowCheckedBinopOp\",\n                \"FloatBinopOp\"\n            ],\n            \"implements\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass TypeInferenceReducer\n    : public UniformReducerAdapter<TypeInferenceReducer, Next> {\n  static_assert(next_is_bottom_of_assembler_stack<Next>::value);\n  using table_t = SnapshotTable<Type>;\n\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(TypeInference)\n\n  using Adapter = UniformReducerAdapter<TypeInferenceReducer, Next>;\n  using Args = TypeInferenceReducerArgs;\n\n  TypeInferenceReducer() {\n    // It is not reasonable to try to reuse input graph types if there are none.\n    DCHECK_IMPLIES(args_.output_graph_typing ==\n                       Args::OutputGraphTyping::kPreserveFromInputGraph,\n                   args_.input_graph_typing != Args::InputGraphTyping::kNone);\n  }\n\n  void Analyze() {\n    if (args_.input_graph_typing == Args::InputGraphTyping::kPrecise) {\n#ifdef DEBUG\n      GrowingBlockSidetable<std::vector<std::pair<OpIndex, Type>>>\n          block_refinements(Asm().input_graph().block_count(), {},\n                            Asm().phase_zone());\n      input_graph_types_ = analyzer_.Run(&block_refinements);\n      Tracing::Get().PrintPerBlockData(\n          \"Type Refinements\", Asm().input_graph(),\n          [&](std::ostream& stream, const turboshaft::Graph& graph,\n              turboshaft::BlockIndex index) -> bool {\n            const std::vector<std::pair<turboshaft::OpIndex, turboshaft::Type>>&\n                refinements = block_refinements[index];\n            if (refinements.empty()) return false;\n            stream << \"\\\\n\";\n            for (const auto& [op, type] : refinements) {\n              stream << op << \" : \" << type << \"\\\\n\";\n            }\n            return true;\n          });\n#else\n      input_graph_types_ = analyzer_.Run(nullptr);\n#endif  // DEBUG\n      Tracing::Get().PrintPerOperationData(\n          \"Types\", Asm().input_graph(),\n          [&](std::ostream& stream, const turboshaft::Graph& graph,\n              turboshaft::OpIndex index) -> bool {\n            turboshaft::Type type = input_graph_types_[index];\n            if (!type.IsInvalid() && !type.IsNone()) {\n              type.PrintTo(stream);\n              return true;\n            }\n            return false;\n          });\n    }\n    Next::Analyze();\n  }\n\n  Type GetInputGraphType(OpIndex ig_index) {\n    return input_graph_types_[ig_index];\n  }\n\n  Type GetOutputGraphType(OpIndex og_index) { return GetType(og_index); }\n\n  template <Opcode opcode, typename Continuation, typename... Ts>\n  OpIndex ReduceOperation(Ts... args) {\n    OpIndex index = Continuation{this}.Reduce(args...);\n    if (!NeedsTyping(index)) return index;\n\n    const Operation& op = Asm().output_graph().Get(index);\n    if (CanBeTyped(op)) {\n      Type type = Typer::TypeForRepresentation(\n          Asm().output_graph().Get(index).outputs_rep(), Asm().graph_zone());\n      SetType(index, type, true);\n    }\n    return index;\n  }\n\n  template <typename Op, typename Continuation>\n  OpIndex ReduceInputGraphOperation(OpIndex ig_index, const Op& operation) {\n    OpIndex og_index = Continuation{this}.ReduceInputGraph(ig_index, operation);\n    if (!og_index.valid()) return og_index;\n    if (args_.output_graph_typing == Args::OutputGraphTyping::kNone) {\n      return og_index;\n    }\n    if (!CanBeTyped(operation)) return og_index;\n\n    Type ig_type = GetInputGraphType(ig_index);\n    DCHECK_IMPLIES(args_.input_graph_typing != Args::InputGraphTyping::kNone,\n                   !ig_type.IsInvalid());\n    if (!ig_type.IsInvalid()) {\n      Type og_type = GetType(og_index);\n      // If the type we have from the input graph is more precise, we keep it.\n      if (og_type.IsInvalid() ||\n          (ig_type.IsSubtypeOf(og_type) && !og_type.IsSubtypeOf(ig_type))) {\n        RefineTypeFromInputGraph(og_index, og_type, ig_type);\n      }\n    }\n    return og_index;\n  }\n\n  void Bind(Block* new_block) {\n    Next::Bind(new_block);\n\n    // Seal the current block first.\n    if (table_.IsSealed()) {\n      DCHECK_NULL(current_block_);\n    } else {\n      // If we bind a new block while the previous one is still unsealed, we\n      // finalize it.\n      DCHECK_NOT_NULL(current_block_);\n      DCHECK(current_block_->index().valid());\n      block_to_snapshot_mapping_[current_block_->index()] = table_.Seal();\n      current_block_ = nullptr;\n    }\n\n    // Collect the snapshots of all predecessors.\n    {\n      predecessors_.clear();\n      for (const Block* pred : new_block->PredecessorsIterable()) {\n        std::optional<table_t::Snapshot> pred_snapshot =\n            block_to_snapshot_mapping_[pred->index()];\n        DCHECK(pred_snapshot.has_value());\n        predecessors_.push_back(pred_snapshot.value());\n      }\n      std::reverse(predecessors_.begin(), predecessors_.end());\n    }\n\n    // Start a new snapshot for this block by merging information from\n    // predecessors.\n    {\n      auto MergeTypes = [&](table_t::Key,\n                            base::Vector<const Type> predecessors) -> Type {\n        DCHECK_GT(predecessors.size(), 0);\n        Type result_type = predecessors[0];\n        for (size_t i = 1; i < predecessors.size(); ++i) {\n          result_type = Type::LeastUpperBound(result_type, predecessors[i],\n                                              Asm().graph_zone());\n        }\n        return result_type;\n      };\n\n      table_.StartNewSnapshot(base::VectorOf(predecessors_), MergeTypes);\n    }\n\n    // Check if the predecessor is a branch that allows us to refine a few\n    // types.\n    if (args_.output_graph_typing ==\n        Args::OutputGraphTyping::kRefineFromInputGraph) {\n      if (new_block->PredecessorCount() == 1) {\n        Block* predecessor = new_block->LastPredecessor();\n        const Operation& terminator =\n            predecessor->LastOperation(Asm().output_graph());\n        if (const BranchOp* branch = terminator.TryCast<BranchOp>()) {\n          DCHECK(branch->if_true == new_block || branch->if_false == new_block);\n          RefineTypesAfterBranch(branch, new_block,\n                                 branch->if_true == new_block);\n        }\n      }\n    }\n    current_block_ = new_block;\n  }\n\n  void RefineTypesAfterBranch(const BranchOp* branch, Block* new_block,\n                              bool then_branch) {\n    const std::string branch_str = branch->ToString().substr(0, 40);\n    USE(branch_str);\n    TURBOSHAFT_TRACE_TYPING_OK(\"Br   %3d:%-40s\\n\",\n                               Asm().output_graph().Index(*branch).id(),\n                               branch_str.c_str());\n\n    Typer::BranchRefinements refinements(\n        [this](OpIndex index) { return GetType(index); },\n        [&](OpIndex index, const Type& refined_type) {\n          RefineOperationType(new_block, index, refined_type,\n                              then_branch ? 'T' : 'F');\n        });\n\n    // Inspect branch condition.\n    const Operation& condition = Asm().output_graph().Get(branch->condition());\n    refinements.RefineTypes(condition, then_branch, Asm().graph_zone());\n  }\n\n  void RefineOperationType(Block* new_block, OpIndex op, const Type& type,\n                           char case_for_tracing) {\n    DCHECK(op.valid());\n    DCHECK(!type.IsInvalid());\n\n    TURBOSHAFT_TRACE_TYPING_OK(\n        \"  %c: %3d:%-40s ~~> %s\\n\", case_for_tracing, op.id(),\n        Asm().output_graph().Get(op).ToString().substr(0, 40).c_str(),\n        type.ToString().c_str());\n\n    auto key_opt = op_to_key_mapping_[op];\n    // We might not have a key for this value, because we are running in a mode\n    // where we don't type all operations.\n    if (key_opt.has_value()) {\n      table_.Set(*key_opt, type);\n\n#ifdef DEBUG\n      std::vector<std::pair<OpIndex, Type>>& refinement =\n          Asm().output_graph().block_type_refinement()[new_block->index()];\n      refinement.push_back(std::make_pair(op, type));\n#endif\n\n      // TODO(nicohartmann@): One could push the refined type deeper into the\n      // operations.\n    }\n  }\n\n  OpIndex REDUCE(PendingLoopPhi)(OpIndex first, RegisterRepresentation rep) {\n    OpIndex index = Next::ReducePendingLoopPhi(first, rep);\n    if (!NeedsTyping(index)) return index;\n\n    // There is not much we can do for pending loop phis, because we don't know\n    // the type of the backedge yet, so we have to assume maximal type. If we\n    // run with a typed input graph, we can refine this type using the input\n    // graph's type (see ReduceInputGraphOperation).\n    SetType(index, Typer::TypeForRepresentation(rep));\n    return index;\n  }\n\n  OpIndex REDUCE(Phi)(base::Vector<const OpIndex> inputs,\n                      RegisterRepresentation rep) {\n    OpIndex index = Next::ReducePhi(inputs, rep);\n    if (!NeedsTyping(index)) return index;\n\n    Type type = Type::LeastUpperBound(type, GetType(input), Asm().graph_zone());\n    SetType(index, type);\n    return index;\n  }\n\n  OpIndex REDUCE(Constant)(ConstantOp::Kind kind, ConstantOp::Storage value) {\n    OpIndex index = Next::ReduceConstant(kind, value);\n    if (!NeedsTyping(index)) return index;\n\n    Type type = Typer::TypeConstant(kind, value);\n    SetType(index, type);\n    return index;\n  }\n\n  V<Word32> REDUCE(Comparison)(V<Any> left, V<Any> right,\n                               ComparisonOp::Kind kind,\n                               RegisterRepresentation rep) {\n    OpIndex index = Next::ReduceComparison(left, right, kind, rep);\n    if (!NeedsTyping(index)) return index;\n\n    Type type = Typer::TypeComparison(GetType(left), GetType(right), rep, kind,\n                                      Asm().graph_zone());\n    SetType(index, type);\n    return index;\n  }\n\n  V<Any> REDUCE(Projection)(V<Any> input, uint16_t idx,\n                            RegisterRepresentation rep) {\n    V<Any> index = Next::ReduceProjection(input, idx, rep);\n    if (!NeedsTyping(index)) return index;\n\n    Type type = Typer::TypeProjection(GetType(input), idx);\n    SetType(index, type);\n    return index;\n  }\n\n  V<Word> REDUCE(WordBinop)(V<Word> left, V<Word> right, WordBinopOp::Kind kind,\n                            WordRepresentation rep) {\n    V<Word> index = Next::ReduceWordBinop(left, right, kind, rep);\n    if (!NeedsTyping(index)) return index;\n\n    Type type = Typer::TypeWordBinop(GetType(left), GetType(right), kind, rep,\n                                     Asm().graph_zone());\n    SetType(index, type);\n    return index;\n  }\n\n  OpIndex REDUCE(OverflowCheckedBinop)(V<Word> left, V<Word> right,\n                                       OverflowCheckedBinopOp::Kind kind,\n                                       WordRepresentation rep) {\n    OpIndex index = Next::ReduceOverflowCheckedBinop(left, right, kind, rep);\n    if (!NeedsTyping(index)) return index;\n\n    Type type = Typer::TypeOverflowCheckedBinop(GetType(left), GetType(right),\n                                                kind, rep, Asm().graph_zone());\n    SetType(index, type);\n    return index;\n  }\n\n  V<Float> REDUCE(FloatBinop)(V<Float> left, V<Float> right,\n                              FloatBinopOp::Kind kind,\n                              FloatRepresentation rep) {\n    V<Float> index = Next::ReduceFloatBinop(left, right, kind, rep);\n    if (!NeedsTyping(index)) return index;\n\n    Type type = Typer::TypeFloatBinop(GetType(left), GetType(right), kind, rep,\n                                      Asm().graph_zone());\n    SetType(index, type);\n    return index;\n  }\n\n  OpIndex REDUCE(CheckTurboshaftTypeOf)(OpIndex input,\n                                        RegisterRepresentation rep, Type type,\n                                        bool successful) {\n    Type input_type = GetType(input);\n    if (input_type.IsSubtypeOf(type)) {\n      OpIndex index = Next::ReduceCheckTurboshaftTypeOf(input, rep, type, true);\n      TURBOSHAFT_TRACE_TYPING_OK(\n          \"CTOF %3d:%-40s\\n  P: %3d:%-40s ~~> %s\\n\", index.id(),\n          Asm().output_graph().Get(index).ToString().substr(0, 40).c_str(),\n          input.id(),\n          Asm().output_graph().Get(input).ToString().substr(0, 40).c_str(),\n          input_type.ToString().c_str());\n      return index;\n    }\n    if (successful) {\n      FATAL(\n          \"Checking type %s of operation %d:%s failed after it passed in a \"\n          \"previous phase\",\n          type.ToString().c_str(), input.id(),\n          Asm().output_graph().Get(input).ToString().c_str());\n    }\n    OpIndex index =\n        Next::ReduceCheckTurboshaftTypeOf(input, rep, type, successful);\n    TURBOSHAFT_TRACE_TYPING_FAIL(\n        \"CTOF %3d:%-40s\\n  F: %3d:%-40s ~~> %s\\n\", index.id(),\n        Asm().output_graph().Get(index).ToString().substr(0, 40).c_str(),\n        input.id(),\n        Asm().output_graph().Get(input).ToString().substr(0, 40).c_str(),\n        input_type.ToString().c_str());\n    return index;\n  }\n\n  void RemoveLast(OpIndex index_of_last_operation) {\n    if (op_to_key_mapping_[index_of_last_operation]) {\n      op_to_key_mapping_[index_of_last_operation] = std::nullopt;\n      TURBOSHAFT_TRACE_TYPING_OK(\n          \"REM  %3d:%-40s %-40s\\n\", index_of_last_operation.id(),\n          Asm()\n              .output_graph()\n              .Get(index_of_last_operation)\n              .ToString()\n              .substr(0, 40)\n              .c_str(),\n          GetType(index_of_last_operation).ToString().substr(0, 40).c_str());\n      output_graph_types_[index_of_last_operation] = Type::Invalid();\n    }\n    Next::RemoveLast(index_of_last_operation);\n  }\n\n private:\n  void RefineTypeFromInputGraph(OpIndex index, const Type& og_type,\n                                const Type& ig_type) {\n    // Refinement should happen when we just lowered the corresponding\n    // operation, so we should be at the point where the operation is defined\n    // (e.g. not in a refinement after a branch). So the current block must\n    // contain the operation.\n    DCHECK(!ig_type.IsInvalid());\n\n    TURBOSHAFT_TRACE_TYPING_OK(\n        \"Refi %3d:%-40s\\n  I:     %-40s ~~> %-40s\\n\", index.id(),\n        Asm().output_graph().Get(index).ToString().substr(0, 40).c_str(),\n        (og_type.IsInvalid() ? \"invalid\" : og_type.ToString().c_str()),\n        ig_type.ToString().c_str());\n\n    RefineOperationType(Asm().current_block(), index, ig_type, 'I');\n  }\n\n  Type GetTypeOrInvalid(OpIndex index) {\n    if (auto key = op_to_key_mapping_[index]) return table_.Get(*key);\n    return Type::Invalid();\n  }\n\n  Type GetTupleType(const TupleOp& tuple) {\n    base::SmallVector<Type, 4> tuple_types;\n    for (OpIndex input : tuple.inputs()) {\n      tuple_types.push_back(GetType(input));\n    }\n    return TupleType::Tuple(base::VectorOf(tuple_types), Asm().graph_zone());\n  }\n\n  Type GetType(OpIndex index) {\n    Type type = GetTypeOrInvalid(index);\n    if (type.IsInvalid()) {\n      const Operation& op = Asm().output_graph().Get(index);\n      if (op.Is<TupleOp>()) {\n        return GetTupleType(op.Cast<TupleOp>());\n      } else {\n        return Typer::TypeForRepresentation(op.outputs_rep(),\n                                            Asm().graph_zone());\n      }\n    }\n    return type;\n  }\n\n  void SetType(OpIndex index, const Type& result_type,\n               bool is_fallback_for_unsupported_operation = false) {\n    DCHECK(!result_type.IsInvalid());\n\n    if (auto key_opt = op_to_key_mapping_[index]) {\n      table_.Set(*key_opt, result_type);\n      DCHECK(result_type.IsSubtypeOf(output_graph_types_[index]));\n      output_graph_types_[index] = result_type;\n      DCHECK(!output_graph_types_[index].IsInvalid());\n    } else {\n      auto key = table_.NewKey(Type::None());\n      op_to_key_mapping_[index] = key;\n      table_.Set(key, result_type);\n      output_graph_types_[index] = result_type;\n    }\n\n    if (!is_fallback_for_unsupported_operation) {\n      TURBOSHAFT_TRACE_TYPING_OK(\n          \"Type %3d:%-40s ==> %s\\n\", index.id(),\n          Asm().output_graph().Get(index).ToString().substr(0, 40).c_str(),\n          result_type.ToString().c_str());\n    } else {\n      // TODO(nicohartmann@): Remove the fallback case once all operations are\n      // supported.\n      TURBOSHAFT_TRACE_TYPING_FAIL(\n          \"TODO %3d:%-40s ==> %s\\n\", index.id(),\n          Asm().output_graph().Get(index).ToString().substr(0, 40).c_str(),\n          result_type.ToString().c_str());\n    }\n  }\n\n// Verification is more difficult, now that the output graph uses types from the\n// input graph. It is generally not possible to verify that the output graph's\n// type is a subtype of the input graph's type, because the typer might not\n// support a precise typing of the operations after the lowering.\n// TODO(nicohartmann@): Evaluate new strategies for verification.\n#if 0\n#ifdef DEBUG\n  void Verify(OpIndex input_index, OpIndex output_index) {\n    DCHECK(input_index.valid());\n    DCHECK(output_index.valid());\n\n    const auto& input_type = Asm().input_graph().operation_types()[input_index];\n    const auto& output_type = types_[output_index];\n\n    if (input_type.IsInvalid()) return;\n    DCHECK(!output_type.IsInvalid());\n\n    const bool is_okay = output_type.IsSubtypeOf(input_type);\n\n    TURBOSHAFT_TRACE_TYPING(\n        \"\\033[%s %3d:%-40s %-40s\\n     %3d:%-40s %-40s\\033[0m\\n\",\n        is_okay ? \"32mOK  \" : \"31mFAIL\", input_index.id(),\n        Asm().input_graph().Get(input_index).ToString().substr(0, 40).c_str(),\n        input_type.ToString().substr(0, 40).c_str(), output_index.id(),\n        Asm().output_graph().Get(output_index).ToString().substr(0, 40).c_str(),\n        output_type.ToString().substr(0, 40).c_str());\n\n    if (V8_UNLIKELY(!is_okay)) {\n      FATAL(\n          \"\\033[%s %3d:%-40s %-40s\\n     %3d:%-40s %-40s\\033[0m\\n\",\n          is_okay ? \"32mOK  \" : \"31mFAIL\", input_index.id(),\n          Asm().input_graph().Get(input_index).ToString().substr(0, 40).c_str(),\n          input_type.ToString().substr(0, 40).c_str(), output_index.id(),\n          Asm()\n              .output_graph()\n              .Get(output_index)\n              .ToString()\n              .substr(0, 40)\n              .c_str(),\n          output_type.ToString().substr(0, 40).c_str());\n    }\n  }\n#endif\n#endif\n\n  bool NeedsTyping(OpIndex index) const {\n    return index.valid() && args_.output_graph_typing ==\n                                Args::OutputGraphTyping::kRefineFromInputGraph;\n  }\n\n  TypeInferenceReducerArgs args_{TypeInferenceReducerArgs::Get()};\n  GrowingOpIndexSidetable<Type> input_graph_types_{Asm().graph_zone(),\n                                                   &Asm().input_graph()};\n  GrowingOpIndexSidetable<Type>& output_graph_types_{\n      Asm().output_graph().operation_types()};\n  table_t table_{Asm().phase_zone()};\n  const Block* current_block_ = nullptr;\n  GrowingOpIndexSidetable<std::optional<table_t::Key>> op_to_key_mapping_{\n      Asm().phase_zone(), &Asm().output_graph()};\n  GrowingBlockSidetable<std::optional<table_t::Snapshot>>\n      block_to_snapshot_mapping_{Asm().input_graph().block_count(),\n                                 std::nullopt, Asm().phase_zone()};\n  // {predecessors_} is used during merging, but we use an instance variable for\n  // it, in order to save memory and not reallocate it for each merge.\n  ZoneVector<table_t::Snapshot> predecessors_{Asm().phase_zone()};\n  TypeInferenceAnalysis analyzer_{Asm().modifiable_input_graph(),\n                                  Asm().phase_zone()};\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UniformReducerAdapter\",\n                \"about\": \"Adapter class for implementing uniform reducers in Turboshaft.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename Reducer, typename Next>\n                class UniformReducerAdapter {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SnapshotTable\",\n                \"about\": \"Table for storing snapshots of data during compilation.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class SnapshotTable {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Type\",\n                \"about\": \"Represents the type of a value in the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Type {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TypeInferenceAnalysis\",\n                \"about\": \"Performs type inference analysis on the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TypeInferenceAnalysis {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Typer\",\n                \"about\": \"Provides type information for various operations.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Typer {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OpIndex\",\n                \"about\": \"Index of an operation in the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class OpIndex {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Block\",\n                \"about\": \"Represents a basic block in the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Block {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Operation\",\n                \"about\": \"Base class for all operations in the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Operation {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BranchOp\",\n                \"about\": \"Represents a branch operation in the Turboshaft graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class BranchOp {};\n            ]]></code>\n"
}