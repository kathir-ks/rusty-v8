{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/access-info.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/access-info.cc\",\n            \"file_name\": \"access-info.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides access information for properties and elements, used during compilation to optimize property and element access.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for access info computation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/access-info.h\"\n\n#include <optional>\n#include <ostream>\n\n#include \"src/builtins/accessors.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/heap-refs.h\"\n#include \"src/compiler/js-heap-broker-inl.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/type-cache.h\"\n#include \"src/ic/call-optimization.h\"\n#include \"src/objects/cell-inl.h\"\n#include \"src/objects/elements-kind.h\"\n#include \"src/objects/field-index-inl.h\"\n#include \"src/objects/field-type.h\"\n#include \"src/objects/instance-type-inl.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/property-details.h\"\n#include \"src/objects/struct-inl.h\"\n#include \"src/objects/templates.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CanInlinePropertyAccess\",\n                \"about\": \"Determines if property access can be inlined based on the map and access mode.\",\n                \"logic\": \"Checks if the map is a primitive map (excluding Null, Undefined, TheHole), or a JSObject map that is not a dictionary map, does not have a named interceptor, and does not require access checks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"MapRef\",\n                        \"purpose\": \"The map of the object being accessed.\"\n                    },\n                    {\n                        \"name\": \"access_mode\",\n                        \"type\": \"AccessMode\",\n                        \"purpose\": \"The type of access (load, store, etc.).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the access can be inlined, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"IsBooleanMap\",\n                    \"IsJSObjectMap\",\n                    \"V8_DICT_PROPERTY_CONST_TRACKING_BOOL\",\n                    \"map.object()->is_prototype_map()\",\n                    \"map.object()->has_named_interceptor()\",\n                    \"map.is_access_check_needed()\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nbool CanInlinePropertyAccess(MapRef map, AccessMode access_mode) {\n  // We can inline property access to prototypes of all primitives, except\n  // the special Oddball ones that have no wrapper counterparts (i.e. Null,\n  // Undefined and TheHole).\n  // We can only inline accesses to dictionary mode holders if the access is a\n  // load and the holder is a prototype. The latter ensures a 1:1\n  // relationship between the map and the object (and therefore the property\n  // dictionary).\n  static_assert(ODDBALL_TYPE == LAST_PRIMITIVE_HEAP_OBJECT_TYPE);\n  if (IsBooleanMap(*map.object())) return true;\n  if (map.instance_type() < LAST_PRIMITIVE_HEAP_OBJECT_TYPE) return true;\n  if (IsJSObjectMap(*map.object())) {\n    if (map.is_dictionary_map()) {\n      if (!V8_DICT_PROPERTY_CONST_TRACKING_BOOL) return false;\n      return access_mode == AccessMode::kLoad &&\n             map.object()->is_prototype_map();\n    }\n    return !map.object()->has_named_interceptor() &&\n           // TODO(verwaest): Allowlist contexts to which we have access.\n           !map.is_access_check_needed();\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasFieldRepresentationDependenciesOnMap\",\n                \"about\": \"Checks if there are field representation dependencies on a specific map.\",\n                \"logic\": \"Iterates through the compilation dependencies and checks if any of them are field representation dependencies on the given map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"dependencies\",\n                        \"type\": \"ZoneVector<CompilationDependency const*>&\",\n                        \"purpose\": \"The list of compilation dependencies.\"\n                    },\n                    {\n                        \"name\": \"field_owner_map\",\n                        \"type\": \"Handle<Map> const&\",\n                        \"purpose\": \"The map that owns the field.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if there are field representation dependencies on the map, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"CompilationDependencies::IsFieldRepresentationDependencyOnMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nbool HasFieldRepresentationDependenciesOnMap(\n    ZoneVector<CompilationDependency const*>& dependencies,\n    Handle<Map> const& field_owner_map) {\n  for (auto dep : dependencies) {\n    if (CompilationDependencies::IsFieldRepresentationDependencyOnMap(\n            dep, field_owner_map)) {\n      return true;\n    }\n  }\n  return false;\n}\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for AccessMode enum.\",\n                \"logic\": \"Returns a string representation of the AccessMode.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"access_mode\",\n                        \"type\": \"AccessMode\",\n                        \"purpose\": \"The access mode to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"AccessMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, AccessMode access_mode) {\n  switch (access_mode) {\n    case AccessMode::kLoad:\n      return os << \"Load\";\n    case AccessMode::kStore:\n      return os << \"Store\";\n    case AccessMode::kStoreInLiteral:\n      return os << \"StoreInLiteral\";\n    case AccessMode::kHas:\n      return os << \"Has\";\n    case AccessMode::kDefine:\n      return os << \"Define\";\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ElementAccessInfo\",\n                \"about\": \"Stores information about element access.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"elements_kind_\",\n                        \"type\": \"ElementsKind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The elements kind of the array.\"\n                    },\n                    {\n                        \"name\": \"lookup_start_object_maps_\",\n                        \"type\": \"ZoneVector<MapRef>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps of objects where the element lookup starts.\"\n                    },\n                    {\n                        \"name\": \"transition_sources_\",\n                        \"type\": \"ZoneVector<MapRef>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Sources of element transitions.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneVector\",\n                    \"MapRef\",\n                    \"ElementsKind\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nElementAccessInfo::ElementAccessInfo(\n    ZoneVector<MapRef>&& lookup_start_object_maps, ElementsKind elements_kind,\n    Zone* zone)\n    : elements_kind_(elements_kind),\n      lookup_start_object_maps_(lookup_start_object_maps),\n      transition_sources_(zone) {\n  CHECK(!lookup_start_object_maps.empty());\n}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PropertyAccessInfo\",\n                \"about\": \"Stores information about property access.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind_\",\n                        \"type\": \"Kind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The kind of property access.\"\n                    },\n                    {\n                        \"name\": \"lookup_start_object_maps_\",\n                        \"type\": \"ZoneVector<MapRef>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps of objects where the property lookup starts.\"\n                    },\n                    {\n                        \"name\": \"holder_\",\n                        \"type\": \"OptionalJSObjectRef\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The holder of the property.\"\n                    },\n                    {\n                        \"name\": \"constant_\",\n                        \"type\": \"OptionalObjectRef\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The constant value of the property.\"\n                    },\n                    {\n                        \"name\": \"api_holder_\",\n                        \"type\": \"OptionalJSObjectRef\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The API holder of the property.\"\n                    },\n                    {\n                        \"name\": \"unrecorded_dependencies_\",\n                        \"type\": \"ZoneVector<CompilationDependency const*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Unrecorded compilation dependencies.\"\n                    },\n                    {\n                        \"name\": \"field_index_\",\n                        \"type\": \"FieldIndex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The field index of the property.\"\n                    },\n                    {\n                        \"name\": \"field_representation_\",\n                        \"type\": \"Representation\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The representation of the field.\"\n                    },\n                    {\n                        \"name\": \"field_type_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The type of the field.\"\n                    },\n                     {\n                        \"name\": \"field_owner_map_\",\n                        \"type\": \"MapRef\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The map owning the field.\"\n                    },\n                    {\n                        \"name\": \"field_map_\",\n                        \"type\": \"OptionalMapRef\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The map of the field, if it's a heap object.\"\n                    },\n                     {\n                        \"name\": \"transition_map_\",\n                        \"type\": \"OptionalMapRef\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map after transition operation.\"\n                    },\n                     {\n                        \"name\": \"dictionary_index_\",\n                        \"type\": \"InternalIndex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Index in dictionary.\"\n                    },\n                     {\n                        \"name\": \"name_\",\n                        \"type\": \"OptionalNameRef\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The name associated with accessor constants.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneVector\",\n                    \"MapRef\",\n                    \"OptionalJSObjectRef\",\n                    \"OptionalObjectRef\",\n                    \"CompilationDependency\",\n                    \"FieldIndex\",\n                    \"Representation\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nPropertyAccessInfo PropertyAccessInfo::Invalid(Zone* zone) {\n  return PropertyAccessInfo(zone);\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::NotFound(Zone* zone, MapRef receiver_map,\n                                                OptionalJSObjectRef holder) {\n  return PropertyAccessInfo(zone, kNotFound, holder, {{receiver_map}, zone});\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::DataField(\n    JSHeapBroker* broker, Zone* zone, MapRef receiver_map,\n    ZoneVector<CompilationDependency const*>&& dependencies,\n    FieldIndex field_index, Representation field_representation,\n    Type field_type, MapRef field_owner_map, OptionalMapRef field_map,\n    OptionalJSObjectRef holder, OptionalMapRef transition_map) {\n  DCHECK(!field_representation.IsNone());\n  DCHECK_IMPLIES(\n      field_representation.IsDouble(),\n      HasFieldRepresentationDependenciesOnMap(\n          dependencies, transition_map.has_value() ? transition_map->object()\n                        : holder.has_value() ? holder->map(broker).object()\n                                             : receiver_map.object()));\n  return PropertyAccessInfo(kDataField, holder, transition_map, field_index,\n                            field_representation, field_type, field_owner_map,\n                            field_map, {{receiver_map}, zone},\n                            std::move(dependencies));\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::FastDataConstant(\n    Zone* zone, MapRef receiver_map,\n    ZoneVector<CompilationDependency const*>&& dependencies,\n    FieldIndex field_index, Representation field_representation,\n    Type field_type, MapRef field_owner_map, OptionalMapRef field_map,\n    OptionalJSObjectRef holder, OptionalMapRef transition_map) {\n  DCHECK(!field_representation.IsNone());\n  return PropertyAccessInfo(kFastDataConstant, holder, transition_map,\n                            field_index, field_representation, field_type,\n                            field_owner_map, field_map, {{receiver_map}, zone},\n                            std::move(dependencies));\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::FastAccessorConstant(\n    Zone* zone, MapRef receiver_map, OptionalJSObjectRef holder,\n    OptionalObjectRef constant, OptionalJSObjectRef api_holder) {\n  return PropertyAccessInfo(zone, kFastAccessorConstant, holder, constant,\n                            api_holder, {} /* name */, {{receiver_map}, zone});\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::ModuleExport(Zone* zone,\n                                                    MapRef receiver_map,\n                                                    CellRef cell) {\n  return PropertyAccessInfo(zone, kModuleExport, {} /* holder */,\n                            cell /* constant */, {} /* api_holder */,\n                            {} /* name */, {{receiver_map}, zone});\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::StringLength(Zone* zone,\n                                                    MapRef receiver_map) {\n  return PropertyAccessInfo(zone, kStringLength, {}, {{receiver_map}, zone});\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::StringWrapperLength(\n    Zone* zone, MapRef receiver_map) {\n  return PropertyAccessInfo(zone, kStringWrapperLength, {},\n                            {{receiver_map}, zone});\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::TypedArrayLength(Zone* zone,\n                                                        MapRef receiver_map) {\n  PropertyAccessInfo result(zone, kTypedArrayLength, {},\n                            {{receiver_map}, zone});\n  result.set_elements_kind(receiver_map.elements_kind());\n  return result;\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::DictionaryProtoDataConstant(\n    Zone* zone, MapRef receiver_map, JSObjectRef holder,\n    InternalIndex dictionary_index, NameRef name) {\n  return PropertyAccessInfo(zone, kDictionaryProtoDataConstant, holder,\n                            {{receiver_map}, zone}, dictionary_index, name);\n}\n\n// static\nPropertyAccessInfo PropertyAccessInfo::DictionaryProtoAccessorConstant(\n    Zone* zone, MapRef receiver_map, OptionalJSObjectRef holder,\n    ObjectRef constant, OptionalJSObjectRef api_holder, NameRef property_name) {\n  return PropertyAccessInfo(zone, kDictionaryProtoAccessorConstant, holder,\n                            constant, api_holder, property_name,\n                            {{receiver_map}, zone});\n}\n\nPropertyAccessInfo::PropertyAccessInfo(Zone* zone)\n    : kind_(kInvalid),\n      lookup_start_object_maps_(zone),\n      unrecorded_dependencies_(zone),\n      field_representation_(Representation::None()),\n      field_type_(Type::None()),\n      dictionary_index_(InternalIndex::NotFound()) {}\n\nPropertyAccessInfo::PropertyAccessInfo(\n    Zone* zone, Kind kind, OptionalJSObjectRef holder,\n    ZoneVector<MapRef>&& lookup_start_object_maps)\n    : kind_(kind),\n      lookup_start_object_maps_(lookup_start_object_maps),\n      holder_(holder),\n      unrecorded_dependencies_(zone),\n      field_representation_(Representation::None()),\n      field_type_(Type::None()),\n      dictionary_index_(InternalIndex::NotFound()) {}\n\nPropertyAccessInfo::PropertyAccessInfo(\n    Zone* zone, Kind kind, OptionalJSObjectRef holder,\n    OptionalObjectRef constant, OptionalJSObjectRef api_holder,\n    OptionalNameRef name, ZoneVector<MapRef>&& lookup_start_object_maps)\n    : kind_(kind),\n      lookup_start_object_maps_(lookup_start_object_maps),\n      constant_(constant),\n      holder_(holder),\n      api_holder_(api_holder),\n      unrecorded_dependencies_(zone),\n      field_representation_(Representation::None()),\n      field_type_(Type::Any()),\n      dictionary_index_(InternalIndex::NotFound()),\n      name_(name) {\n  DCHECK_IMPLIES(kind == kDictionaryProtoAccessorConstant, name.has_value());\n}\n\nPropertyAccessInfo::PropertyAccessInfo(\n    Kind kind, OptionalJSObjectRef holder, OptionalMapRef transition_map,\n    FieldIndex field_index, Representation field_representation,\n    Type field_type, MapRef field_owner_map, OptionalMapRef field_map,\n    ZoneVector<MapRef>&& lookup_start_object_maps,\n    ZoneVector<CompilationDependency const*>&& unrecorded_dependencies)\n    : kind_(kind),\n      lookup_start_object_maps_(lookup_start_object_maps),\n      holder_(holder),\n      unrecorded_dependencies_(std::move(unrecorded_dependencies)),\n      transition_map_(transition_map),\n      field_index_(field_index),\n      field_representation_(field_representation),\n      field_type_(field_type),\n      field_owner_map_(field_owner_map),\n      field_map_(field_map),\n      dictionary_index_(InternalIndex::NotFound()) {\n  DCHECK_IMPLIES(transition_map.has_value(),\n                 field_owner_map.equals(transition_map.value()));\n}\n\nPropertyAccessInfo::PropertyAccessInfo(\n    Zone* zone, Kind kind, OptionalJSObjectRef holder,\n    ZoneVector<MapRef>&& lookup_start_object_maps,\n    InternalIndex dictionary_index, NameRef name)\n    : kind_(kind),\n      lookup_start_object_maps_(lookup_start_object_maps),\n      holder_(holder),\n      unrecorded_dependencies_(zone),\n      field_representation_(Representation::None()),\n      field_type_(Type::Any()),\n      dictionary_index_(dictionary_index),\n      name_{name} {}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"OptionalRefEquals\",\n                \"about\": \"Compares two optional references for equality.\",\n                \"logic\": \"Checks if both optional references are present and, if so, compares the underlying references.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"OptionalRef<RefT>\",\n                        \"purpose\": \"The left-hand side optional reference.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"OptionalRef<RefT>\",\n                        \"purpose\": \"The right-hand side optional reference.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the optional references are equal, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\ntemplate <class RefT>\nbool OptionalRefEquals(OptionalRef<RefT> lhs, OptionalRef<RefT> rhs) {\n  if (!lhs.has_value()) return !rhs.has_value();\n  if (!rhs.has_value()) return false;\n  return lhs->equals(rhs.value());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"AppendVector\",\n                \"about\": \"Appends the content of one ZoneVector to another.\",\n                \"logic\": \"Uses insert to append elements from src to the end of dst.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"dst\",\n                        \"type\": \"ZoneVector<T>*\",\n                        \"purpose\": \"The destination vector.\"\n                    },\n                    {\n                        \"name\": \"src\",\n                        \"type\": \"const ZoneVector<T>&\",\n                        \"purpose\": \"The source vector.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nvoid AppendVector(ZoneVector<T>* dst, const ZoneVector<T>& src) {\n  dst->insert(dst->end(), src.begin(), src.end());\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Merge\",\n                \"parent\": \"PropertyAccessInfo\",\n                \"about\": \"Merges this PropertyAccessInfo with another.\",\n                \"logic\": \"Merges the properties of the other PropertyAccessInfo into this one, if possible.  Handles different access modes and property kinds.  Returns true if the merge was successful.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"that\",\n                        \"type\": \"PropertyAccessInfo const*\",\n                        \"purpose\": \"The other PropertyAccessInfo to merge.\"\n                    },\n                    {\n                        \"name\": \"access_mode\",\n                        \"type\": \"AccessMode\",\n                        \"purpose\": \"The access mode.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if merged, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"OptionalRefEquals\",\n                    \"field_index_.GetFieldAccessStubKey()\",\n                    \"field_representation_.Equals()\",\n                    \"Type::Union\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool PropertyAccessInfo::Merge(PropertyAccessInfo const* that,\n                               AccessMode access_mode, Zone* zone) {\n  if (kind_ != that->kind_) return false;\n  if (!OptionalRefEquals(holder_, that->holder_)) return false;\n\n  switch (kind_) {\n    case kInvalid:\n      DCHECK_EQ(that->kind_, kInvalid);\n      return true;\n\n    case kDataField:\n    case kFastDataConstant: {\n      // Check if we actually access the same field (we use the\n      // GetFieldAccessStubKey method here just like the ICs do\n      // since that way we only compare the relevant bits of the\n      // field indices).\n      if (field_index_.GetFieldAccessStubKey() !=\n          that->field_index_.GetFieldAccessStubKey()) {\n        return false;\n      }\n\n      switch (access_mode) {\n        case AccessMode::kHas:\n        case AccessMode::kLoad: {\n          if (!field_representation_.Equals(that->field_representation_)) {\n            if (field_representation_.IsDouble() ||\n                that->field_representation_.IsDouble()) {\n              return false;\n            }\n            field_representation_ = Representation::Tagged();\n          }\n          if (!OptionalRefEquals(field_map_, that->field_map_)) {\n            field_map_ = {};\n          }\n          break;\n        }\n        case AccessMode::kStore:\n        case AccessMode::kStoreInLiteral:\n        case AccessMode::kDefine: {\n          // For stores, the field map and field representation information\n          // must match exactly, otherwise we cannot merge the stores. We\n          // also need to make sure that in case of transitioning stores,\n          // the transition targets match.\n          if (!OptionalRefEquals(field_map_, that->field_map_) ||\n              !field_representation_.Equals(that->field_representation_) ||\n              !OptionalRefEquals(transition_map_, that->transition_map_)) {\n            return false;\n          }\n          break;\n        }\n      }\n\n      field_type_ = Type::Union(field_type_, that->field_type_, zone);\n      AppendVector(&lookup_start_object_maps_, that->lookup_start_object_maps_);\n      AppendVector(&unrecorded_dependencies_, that->unrecorded_dependencies_);\n      return true;\n    }\n\n    case kDictionaryProtoAccessorConstant:\n    case kFastAccessorConstant: {\n      // Check if we actually access the same constant.\n      if (!OptionalRefEquals(constant_, that->constant_)) return false;\n\n      DCHECK(unrecorded_dependencies_.empty());\n      DCHECK(that->unrecorded_dependencies_.empty());\n      AppendVector(&lookup_start_object_maps_, that->lookup_start_object_maps_);\n      return true;\n    }\n\n    case kDictionaryProtoDataConstant: {\n      DCHECK_EQ(AccessMode::kLoad, access_mode);\n      if (dictionary_index_ != that->dictionary_index_) return false;\n      AppendVector(&lookup_start_object_maps_, that->lookup_start_object_maps_);\n      return true;\n    }\n\n    case kNotFound:\n    case kStringLength:\n    case kStringWrapperLength: {\n      DCHECK(unrecorded_dependencies_.empty());\n      DCHECK(that->unrecorded_dependencies_.empty());\n      AppendVector(&lookup_start_object_maps_, that->lookup_start_object_maps_);\n      return true;\n    }\n    case kTypedArrayLength:\n      DCHECK_EQ(lookup_start_object_maps_.size(), 1);\n      DCHECK_EQ(that->lookup_start_object_maps_.size(), 1);\n      return lookup_start_object_maps_[0] == that->lookup_start_object_maps_[0];\n    case kModuleExport:\n      return false;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetConstFieldInfo\",\n                \"parent\": \"PropertyAccessInfo\",\n                \"about\": \"Returns ConstFieldInfo based on whether this access info is for a fast data constant field.\",\n                \"logic\": \"If IsFastDataConstant returns ConstFieldInfo with owner map, otherwise returns ConstFieldInfo::None().\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"ConstFieldInfo\",\n                    \"description\": \"ConstFieldInfo instance or ConstFieldInfo::None()\"\n                },\n                \"dependencies\": [\n                    \"IsFastDataConstant\",\n                    \"ConstFieldInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nConstFieldInfo PropertyAccessInfo::GetConstFieldInfo() const {\n  return IsFastDataConstant() ? ConstFieldInfo(*field_owner_map_)\n                              : ConstFieldInfo::None();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AccessInfoFactory\",\n                \"about\": \"Factory class to compute AccessInfo instances for properties and elements.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The JSHeapBroker used to access the heap.\"\n                    },\n                    {\n                        \"name\": \"type_cache_\",\n                        \"type\": \"TypeCache*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The TypeCache used to cache types.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The memory zone.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"TypeCache\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nAccessInfoFactory::AccessInfoFactory(JSHeapBroker* broker, Zone* zone)\n    : broker_(broker), type_cache_(TypeCache::Get()), zone_(zone) {}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ComputeElementAccessInfo\",\n                \"parent\": \"AccessInfoFactory\",\n                \"about\": \"Computes element access information for a given map and access mode.\",\n                \"logic\": \"Checks if element access can be inlined. Creates an ElementAccessInfo with the given map and elements kind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"MapRef\",\n                        \"purpose\": \"The map of the array.\"\n                    },\n                    {\n                        \"name\": \"access_mode\",\n                        \"type\": \"AccessMode\",\n                        \"purpose\": \"The access mode (load or store).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ElementAccessInfo>\",\n                    \"description\": \"The element access info if access can be inlined, std::nullopt otherwise.\"\n                },\n                \"dependencies\": [\n                    \"map.CanInlineElementAccess\",\n                    \"ElementAccessInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ElementAccessInfo> AccessInfoFactory::ComputeElementAccessInfo(\n    MapRef map, AccessMode access_mode) const {\n  if (!map.CanInlineElementAccess()) return {};\n  return ElementAccessInfo({{map}, zone()}, map.elements_kind(), zone());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ComputeElementAccessInfos\",\n                \"parent\": \"AccessInfoFactory\",\n                \"about\": \"Computes element access information for a given element access feedback.\",\n                \"logic\": \"Iterates through the transition groups in the feedback and computes ElementAccessInfo for each group.  If consolidating ElementLoad returns a value, it's added to the access_infos.  For each target map in a group, computes element access information. If a map doesn't exist, the function exits.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"feedback\",\n                        \"type\": \"ElementAccessFeedback const&\",\n                        \"purpose\": \"The element access feedback.\"\n                    },\n                    {\n                        \"name\": \"access_infos\",\n                        \"type\": \"ZoneVector<ElementAccessInfo>*\",\n                        \"purpose\": \"The vector to store the computed access infos.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if all access infos were computed successfully, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"ConsolidateElementLoad\",\n                    \"ComputeElementAccessInfo\",\n                    \"access_info->AddTransitionSource\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool AccessInfoFactory::ComputeElementAccessInfos(\n    ElementAccessFeedback const& feedback,\n    ZoneVector<ElementAccessInfo>* access_infos) const {\n  AccessMode access_mode = feedback.keyed_mode().access_mode();\n  if (access_mode == AccessMode::kLoad || access_mode == AccessMode::kHas) {\n    // For polymorphic loads of similar elements kinds (i.e. all tagged or all\n    // double), always use the \"worst case\" code without a transition.  This is\n    // much faster than transitioning the elements to the worst case, trading a\n    // TransitionElementsKind for a CheckMaps, avoiding mutation of the array.\n    std::optional<ElementAccessInfo> access_info =\n        ConsolidateElementLoad(feedback);\n    if (access_info.has_value()) {\n      access_infos->push_back(*access_info);\n      return true;\n    }\n  }\n\n  for (auto const& group : feedback.transition_groups()) {\n    DCHECK(!group.empty());\n    OptionalMapRef target = group.front();\n    std::optional<ElementAccessInfo> access_info =\n        ComputeElementAccessInfo(target.value(), access_mode);\n    if (!access_info.has_value()) return false;\n\n    for (size_t i = 1; i < group.size(); ++i) {\n      OptionalMapRef map_ref = group[i];\n      if (!map_ref.has_value()) continue;\n      access_info->AddTransitionSource(map_ref.value());\n    }\n    access_infos->push_back(*access_info);\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ComputeDataFieldAccessInfo\",\n                \"parent\": \"AccessInfoFactory\",\n                \"about\": \"Computes data field access information.\",\n                \"logic\": \"Retrieves field details, creates a FieldIndex, determines the field type (Smi, Double, HeapObject, or Tagged), and creates a PropertyAccessInfo based on"
}