{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/logging/log-file.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/logging/log-file.h\",\n        \"file_name\": \"log-file.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the LogFile class for handling log message output in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard library headers for file I/O, atomic operations, variadic arguments, memory management, and optional values.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stdio.h>\n\n            #include <atomic>\n            #include <cstdarg>\n            #include <memory>\n            #include <optional>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"V8-specific headers for compiler specifics, mutex, assertion scopes, flags, allocation utilities, and output streams.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/compiler-specific.h\"\n            #include \"src/base/platform/mutex.h\"\n            #include \"src/common/assert-scope.h\"\n            #include \"src/flags/flags.h\"\n            #include \"src/utils/allocation.h\"\n            #include \"src/utils/ostreams.h\"\n        ]]></code>\n    </imports>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"V8FileLogger\",\n                \"about\": \"Handles overall log management and configuration\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class V8FileLogger;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"String\",\n                \"about\": \"Represents a string object in V8\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> class Tagged;\n                class String;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Symbol\",\n                \"about\": \"Represents a symbol object in V8\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Symbol;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Name\",\n                \"about\": \"Base class for names in V8\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Name;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OFStream\",\n                \"about\": \"V8's output stream class\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class OFStream;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Mutex\",\n                \"about\": \"Mutex class for thread synchronization\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base { class Mutex; }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Vector\",\n                \"about\": \"V8's dynamic array class\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base { template <typename T> class Vector; }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NoGarbageCollectionMutexGuard\",\n                \"about\": \"RAII guard to prevent GC during critical sections\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class NoGarbageCollectionMutexGuard;\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"LogSeparator\",\n                \"about\": \"Enumeration used to separate log entries\"\n            }\n            </metadata>\n            <code><![CDATA[\n                enum class LogSeparator { kSeparator };\n            ]]></code>\n        </enum>\n        <macro>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_EXPORT_PRIVATE\",\n                \"about\": \"Macro to declare a symbol as exported (private to V8)\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define V8_EXPORT_PRIVATE\n            ]]></code>\n        </macro>\n        <macro>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"PRINTF_FORMAT\",\n                \"about\": \"Attribute that allows the compiler to check format strings\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define PRINTF_FORMAT(a, b)\n            ]]></code>\n        </macro>\n        <template>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"template\",\n                \"name\": \"Tagged\",\n                \"about\": \"Smart pointer to V8 objects\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> class Tagged;\n            ]]></code>\n        </template>\n    </dependencies>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LogFile\",\n            \"about\": \"Handles the output of log messages to a file or console.\",\n            \"attributes\": [\n                {\n                    \"name\": \"logger_\",\n                    \"type\": \"V8FileLogger*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the logger object.\"\n                },\n                {\n                    \"name\": \"file_name_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The name of the log file.\"\n                },\n                {\n                    \"name\": \"output_handle_\",\n                    \"type\": \"FILE*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"File handle for the output log file.\"\n                },\n                {\n                    \"name\": \"os_\",\n                    \"type\": \"OFStream\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Output stream for writing to the log file.\"\n                },\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mutex for thread-safe access to the log file and buffer.\"\n                },\n                {\n                    \"name\": \"format_buffer_\",\n                    \"type\": \"std::unique_ptr<char[]>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Buffer for formatting log messages.\"\n                }\n            ],\n            \"dependencies\": [\n                \"V8FileLogger\",\n                \"std::string\",\n                \"base::Mutex\",\n                \"OFStream\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class LogFile {\n            public:\n            explicit LogFile(V8FileLogger* logger, std::string log_file_name);\n\n            V8_EXPORT_PRIVATE static bool IsLoggingToConsole(std::string file_name);\n            V8_EXPORT_PRIVATE static bool IsLoggingToTemporaryFile(std::string file_name);\n\n            // Frees all resources acquired in Initialize and Open... functions.\n            // When a temporary file is used for the log, returns its stream descriptor,\n            // leaving the file open.\n            FILE* Close();\n\n            std::string file_name() const;\n\n            // Size of buffer used for formatting log messages.\n            static const int kMessageBufferSize = 2048;\n\n            // This mode is only used in tests, as temporary files are automatically\n            // deleted on close and thus can't be accessed afterwards.\n            V8_EXPORT_PRIVATE static const char* const kLogToTemporaryFile;\n            static const char* const kLogToConsole;\n\n            // Utility class for formatting log messages. It escapes the given messages\n            // and then appends them to the static buffer in Log.\n            class MessageBuilder {\n            public:\n                ~MessageBuilder() = default;\n\n                void AppendString(Tagged<String> str,\n                                    std::optional<int> length_limit = std::nullopt);\n                void AppendString(base::Vector<const char> str);\n                void AppendString(const char* str);\n                void AppendString(const char* str, size_t length, bool is_one_byte = true);\n                void PRINTF_FORMAT(2, 3) AppendFormatString(const char* format, ...);\n                void AppendCharacter(char c);\n                void AppendTwoByteCharacter(char c1, char c2);\n                void AppendSymbolName(Tagged<Symbol> symbol);\n\n                // Delegate insertion to the underlying {log_}.\n                // All appended strings are escaped to maintain one-line log entries.\n                template <typename T>\n                MessageBuilder& operator<<(T value) {\n                log_->os_ << value;\n                return *this;\n                }\n\n                // Finish the current log line an flush the it to the log file.\n                void WriteToLogFile();\n\n            private:\n                // Create a message builder starting from position 0.\n                // This acquires the mutex in the log as well.\n                explicit MessageBuilder(LogFile* log);\n\n                // Prints the format string into |log_->format_buffer_|. Returns the length\n                // of the result, or kMessageBufferSize if it was truncated.\n                int PRINTF_FORMAT(2, 0)\n                    FormatStringIntoBuffer(const char* format, va_list args);\n\n                void AppendSymbolNameDetails(Tagged<String> str, bool show_impl_info);\n\n                void PRINTF_FORMAT(2, 3) AppendRawFormatString(const char* format, ...);\n                void AppendRawString(const char* format);\n                void AppendRawCharacter(const char character);\n\n                LogFile* log_;\n                NoGarbageCollectionMutexGuard lock_guard_;\n\n                friend class LogFile;\n            };\n\n            // Use this method to create an instance of LogFile::MessageBuilder. This\n            // method will return null if logging is disabled.\n            std::unique_ptr<LogFile::MessageBuilder> NewMessageBuilder();\n\n            private:\n            static FILE* CreateOutputHandle(std::string file_name);\n            base::Mutex* mutex() { return &mutex_; }\n\n            void WriteLogHeader();\n\n            V8FileLogger* logger_;\n\n            std::string file_name_;\n\n            // When logging is active output_handle_ is used to store a pointer to log\n            // destination.  mutex_ should be acquired before using output_handle_.\n            FILE* output_handle_;\n\n            OFStream os_;\n\n            // mutex_ is a Mutex used for enforcing exclusive\n            // access to the formatting buffer and the log file or log memory buffer.\n            base::Mutex mutex_;\n\n            // Buffer used for formatting log messages. This is a singleton buffer and\n            // mutex_ should be acquired before using it.\n            std::unique_ptr<char[]> format_buffer_;\n\n            friend class V8FileLogger;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MessageBuilder\",\n            \"parent\": \"LogFile\",\n            \"about\": \"Helper class for building and formatting log messages before writing them to the log file.\",\n            \"dependencies\": [\n                \"LogFile\",\n                \"Tagged<String>\",\n                \"base::Vector<const char>\",\n                \"Tagged<Symbol>\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class MessageBuilder {\n            public:\n                ~MessageBuilder() = default;\n\n                void AppendString(Tagged<String> str,\n                                    std::optional<int> length_limit = std::nullopt);\n                void AppendString(base::Vector<const char> str);\n                void AppendString(const char* str);\n                void AppendString(const char* str, size_t length, bool is_one_byte = true);\n                void PRINTF_FORMAT(2, 3) AppendFormatString(const char* format, ...);\n                void AppendCharacter(char c);\n                void AppendTwoByteCharacter(char c1, char c2);\n                void AppendSymbolName(Tagged<Symbol> symbol);\n\n                // Delegate insertion to the underlying {log_}.\n                // All appended strings are escaped to maintain one-line log entries.\n                template <typename T>\n                MessageBuilder& operator<<(T value) {\n                log_->os_ << value;\n                return *this;\n                }\n\n                // Finish the current log line an flush the it to the log file.\n                void WriteToLogFile();\n\n            private:\n                // Create a message builder starting from position 0.\n                // This acquires the mutex in the log as well.\n                explicit MessageBuilder(LogFile* log);\n\n                // Prints the format string into |log_->format_buffer_|. Returns the length\n                // of the result, or kMessageBufferSize if it was truncated.\n                int PRINTF_FORMAT(2, 0)\n                    FormatStringIntoBuffer(const char* format, va_list args);\n\n                void AppendSymbolNameDetails(Tagged<String> str, bool show_impl_info);\n\n                void PRINTF_FORMAT(2, 3) AppendRawFormatString(const char* format, ...);\n                void AppendRawString(const char* format);\n                void AppendRawCharacter(const char character);\n\n                LogFile* log_;\n                NoGarbageCollectionMutexGuard lock_guard_;\n\n                friend class LogFile;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NewMessageBuilder\",\n            \"parent\": \"LogFile\",\n            \"about\": \"Creates a new MessageBuilder instance.  Returns null if logging is disabled.\",\n            \"return\": {\n                \"type\": \"std::unique_ptr<LogFile::MessageBuilder>\",\n                \"description\": \"A unique pointer to a new MessageBuilder instance, or nullptr if logging is disabled.\"\n            },\n            \"dependencies\": [\n                \"LogFile::MessageBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::unique_ptr<LogFile::MessageBuilder> LogFile::NewMessageBuilder() {\n                // Implementation detail would go here - not shown in the header.\n                return nullptr; // Dummy return for now\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsLoggingToConsole\",\n            \"parent\": \"LogFile\",\n            \"about\": \"Checks if the specified file name indicates logging to the console.\",\n            \"parameters\": [\n                {\n                    \"name\": \"file_name\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The file name to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if logging to console, false otherwise.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE static bool LogFile::IsLoggingToConsole(std::string file_name) {\n                // Implementation detail would go here - not shown in the header.\n                return false; // Dummy return for now\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsLoggingToTemporaryFile\",\n            \"parent\": \"LogFile\",\n            \"about\": \"Checks if the specified file name indicates logging to a temporary file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"file_name\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The file name to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if logging to a temporary file, false otherwise.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE static bool LogFile::IsLoggingToTemporaryFile(std::string file_name) {\n                // Implementation detail would go here - not shown in the header.\n                return false; // Dummy return for now\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Close\",\n            \"parent\": \"LogFile\",\n            \"about\": \"Frees resources and closes the log file.\",\n            \"return\": {\n                \"type\": \"FILE*\",\n                \"description\": \"Stream descriptor of the temporary file if used, otherwise NULL.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            FILE* LogFile::Close() {\n                // Implementation detail would go here - not shown in the header.\n                return nullptr; // Dummy return for now\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"file_name\",\n            \"parent\": \"LogFile\",\n            \"about\": \"Returns the name of the log file.\",\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The name of the log file.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            std::string LogFile::file_name() const {\n                return file_name_;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendString\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a tagged string to the message builder\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"Tagged<String>\",\n                    \"purpose\": \"The string to append\"\n                },\n                {\n                    \"name\": \"length_limit\",\n                    \"type\": \"std::optional<int>\",\n                    \"purpose\": \"Optional length limit for the appended string\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendString(Tagged<String> str,\n                                    std::optional<int> length_limit) {\n                                        // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendString\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a string to the message builder\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"base::Vector<const char>\",\n                    \"purpose\": \"The string to append\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendString(base::Vector<const char> str) {\n                // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendString\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a string to the message builder\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The string to append\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendString(const char* str) {\n                 // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendString\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a string to the message builder\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The string to append\"\n                },\n                {\n                    \"name\": \"length\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The length of the string\"\n                },\n                {\n                    \"name\": \"is_one_byte\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether the string is one byte\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendString(const char* str, size_t length, bool is_one_byte) {\n                // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendFormatString\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a formatted string to the message builder\",\n            \"parameters\": [\n                {\n                    \"name\": \"format\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The format string\"\n                },\n                {\n                    \"name\": \"...\",\n                    \"type\": \"...\",\n                    \"purpose\": \"The arguments to the format string\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendFormatString(const char* format, ...) {\n                // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendCharacter\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a character to the message builder\",\n            \"parameters\": [\n                {\n                    \"name\": \"c\",\n                    \"type\": \"char\",\n                    \"purpose\": \"The character to append\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendCharacter(char c) {\n                 // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendTwoByteCharacter\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a two-byte character to the message builder\",\n            \"parameters\": [\n                {\n                    \"name\": \"c1\",\n                    \"type\": \"char\",\n                    \"purpose\": \"The first byte of the character to append\"\n                },\n                {\n                    \"name\": \"c2\",\n                    \"type\": \"char\",\n                    \"purpose\": \"The second byte of the character to append\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendTwoByteCharacter(char c1, char c2) {\n                 // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendSymbolName\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a symbol name to the message builder\",\n            \"parameters\": [\n                {\n                    \"name\": \"symbol\",\n                    \"type\": \"Tagged<Symbol>\",\n                    \"purpose\": \"The symbol to append\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendSymbolName(Tagged<Symbol> symbol) {\n                 // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteToLogFile\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Writes the message in the builder to the log file\",\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::WriteToLogFile() {\n                // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FormatStringIntoBuffer\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Formats a string into the log's format buffer\",\n            \"parameters\": [\n                {\n                    \"name\": \"format\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The format string\"\n                },\n                {\n                    \"name\": \"args\",\n                    \"type\": \"va_list\",\n                    \"purpose\": \"The arguments to the format string\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The length of the formatted string or kMessageBufferSize if truncated\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            int LogFile::MessageBuilder::FormatStringIntoBuffer(const char* format, va_list args) {\n                // Implementation detail would go here - not shown in the header.\n                return 0; // Dummy return for now\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendSymbolNameDetails\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends details of a symbol name to the message builder.\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"Tagged<String>\",\n                    \"purpose\": \"The string representing the symbol name.\"\n                },\n                {\n                    \"name\": \"show_impl_info\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Flag indicating whether to show implementation-specific information.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendSymbolNameDetails(Tagged<String> str, bool show_impl_info) {\n                // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendRawFormatString\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a raw formatted string to the message builder.\",\n            \"parameters\": [\n                {\n                    \"name\": \"format\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The format string.\"\n                },\n                {\n                    \"name\": \"...\",\n                    \"type\": \"...\",\n                    \"purpose\": \"Variable arguments for the format string.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendRawFormatString(const char* format, ...) {\n                // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendRawString\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a raw string to the message builder.\",\n            \"parameters\": [\n                {\n                    \"name\": \"format\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The string to append.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendRawString(const char* format) {\n                // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendRawCharacter\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Appends a raw character to the message builder.\",\n            \"parameters\": [\n                {\n                    \"name\": \"character\",\n                    \"type\": \"const char\",\n                    \"purpose\": \"The character to append.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::MessageBuilder::AppendRawCharacter(const char character) {\n                // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CreateOutputHandle\",\n            \"parent\": \"LogFile\",\n            \"about\": \"Creates the output file handle based on the file name.\",\n            \"parameters\": [\n                {\n                    \"name\": \"file_name\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The name of the log file.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"FILE*\",\n                \"description\": \"The file handle.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            static FILE* LogFile::CreateOutputHandle(std::string file_name) {\n                // Implementation detail would go here - not shown in the header.\n                return nullptr; // Dummy return for now\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteLogHeader\",\n            \"parent\": \"LogFile\",\n            \"about\": \"Writes a header to the log file.\",\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            void LogFile::WriteLogHeader() {\n                // Implementation detail would go here - not shown in the header.\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<<LogSeparator>\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Overloads the << operator for LogSeparator enum\",\n            \"parameters\": [\n                {\n                    \"name\": \"separator\",\n                    \"type\": \"LogSeparator\",\n                    \"purpose\": \"The separator to output\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"LogFile::MessageBuilder&\",\n                \"description\": \"A reference to the MessageBuilder object\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            LogFile::MessageBuilder& LogFile::MessageBuilder::operator<<<LogSeparator>(\n                LogSeparator separator) {\n                    // Implementation detail would go here - not shown in the header.\n                    return *this; // Dummy return for now\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<<void*>\",\n            \"parent\": \"LogFile::MessageBuilder\",\n            \"about\": \"Overloads the << operator for void* type\",\n            \"parameters\": [\n                {\n                    \"name\": \"pointer\",\n                    \"type\": \"void*\",\n                    \"purpose\": \"The pointer to output\"\n                }\n            ],\n            \"return\": {\n                \"type\": \""
}