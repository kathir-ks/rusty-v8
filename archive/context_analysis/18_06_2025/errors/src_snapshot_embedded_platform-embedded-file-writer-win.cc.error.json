{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/platform-embedded-file-writer-win.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/platform-embedded-file-writer-win.cc\",\n        \"file_name\": \"platform-embedded-file-writer-win.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Platform-specific implementation of EmbeddedFileWriter for Windows. Handles emitting assembly code compatible with MSVC (MASM/MARMASM) and other assemblers.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard library headers\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <algorithm>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"V8 headers\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/embedded/platform-embedded-file-writer-win.h\"\n\n#include \"src/common/globals.h\"  // For V8_OS_WIN64\n\n#if defined(V8_OS_WIN64)\n#include \"src/builtins/builtins.h\"\n#include \"src/diagnostics/unwinding-info-win64.h\"\n#include \"src/snapshot/embedded/embedded-data-inl.h\"\n#include \"src/snapshot/embedded/embedded-file-writer.h\"\n#endif  // V8_OS_WIN64\n\n// V8_CC_MSVC is true for both MSVC and clang on windows. clang can handle\n// __asm__-style inline assembly but MSVC cannot, and thus we need a more\n// precise compiler detection that can distinguish between the two. clang on\n// windows sets both __clang__ and _MSC_VER, MSVC sets only _MSC_VER.\n#if defined(_MSC_VER) && !defined(__clang__)\n#define V8_COMPILER_IS_MSVC\n#endif\n\n#if defined(V8_COMPILER_IS_MSVC)\n#include \"src/flags/flags.h\"\n#endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PlatformEmbeddedFileWriterWin\",\n            \"extends\": \"PlatformEmbeddedFileWriterBase\",\n            \"about\": \"Platform-specific EmbeddedFileWriter for Windows.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"EmbeddedData\",\n                \"win64_unwindinfo\",\n                \"Builtins\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\n// MSVC uses MASM for x86 and x64, while it has a ARMASM for ARM32 and\n// ARMASM64 for ARM64. Since ARMASM and ARMASM64 accept a slightly tweaked\n// version of ARM assembly language, they are referred to together in Visual\n// Studio project files as MARMASM.\n//\n// ARM assembly language docs:\n// http://infocenter.arm.com/help/topic/com.arm.doc.dui0802b/index.html\n// Microsoft ARM assembler and assembly language docs:\n// https://docs.microsoft.com/en-us/cpp/assembler/arm/arm-assembler-reference\n\n// Name mangling.\n// Symbols are prefixed with an underscore on 32-bit architectures.\n#if !defined(V8_TARGET_ARCH_X64) && !defined(V8_TARGET_ARCH_ARM64)\n#define SYMBOL_PREFIX \"_\"\n#else\n#define SYMBOL_PREFIX \"\"\n#endif\n\n// Notes:\n//\n// Cross-bitness builds are unsupported. It's thus safe to detect bitness\n// through compile-time defines.\n//\n// Cross-compiler builds (e.g. with mixed use of clang / MSVC) are likewise\n// unsupported and hence the compiler can also be detected through compile-time\n// defines.\n\nnamespace {\n\n#if defined(V8_OS_WIN_X64)\n\nvoid WriteUnwindInfoEntry(PlatformEmbeddedFileWriterWin* w,\n                          const char* unwind_info_symbol,\n                          const char* embedded_blob_data_symbol,\n                          uint64_t rva_start, uint64_t rva_end) {\n  w->DeclareRvaToSymbol(embedded_blob_data_symbol, rva_start);\n  w->DeclareRvaToSymbol(embedded_blob_data_symbol, rva_end);\n  w->DeclareRvaToSymbol(unwind_info_symbol);\n}\n\nvoid EmitUnwindData(PlatformEmbeddedFileWriterWin* w,\n                    const char* unwind_info_symbol,\n                    const char* embedded_blob_data_symbol,\n                    const EmbeddedData* blob,\n                    const win64_unwindinfo::BuiltinUnwindInfo* unwind_infos) {\n  // Emit an UNWIND_INFO (XDATA) struct, which contains the unwinding\n  // information that is used for all builtin functions.\n  DCHECK(win64_unwindinfo::CanEmitUnwindInfoForBuiltins());\n  w->Comment(\"xdata for all the code in the embedded blob.\");\n  w->DeclareExternalFunction(CRASH_HANDLER_FUNCTION_NAME_STRING);\n\n  w->StartXdataSection();\n  {\n    w->DeclareLabel(unwind_info_symbol);\n\n    std::vector<uint8_t> xdata =\n        win64_unwindinfo::GetUnwindInfoForBuiltinFunctions();\n    DCHECK(!xdata.empty());\n\n    w->IndentedDataDirective(kByte);\n    for (size_t i = 0; i < xdata.size(); i++) {\n      if (i > 0) fprintf(w->fp(), \",\");\n      w->HexLiteral(xdata[i]);\n    }\n    w->Newline();\n\n    w->Comment(\"    ExceptionHandler\");\n    w->DeclareRvaToSymbol(CRASH_HANDLER_FUNCTION_NAME_STRING);\n  }\n  w->EndXdataSection();\n  w->Newline();\n\n  // Emit a RUNTIME_FUNCTION (PDATA) entry for each builtin function, as\n  // documented here:\n  // https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64.\n  w->Comment(\n      \"pdata for all the code in the embedded blob (structs of type \"\n      \"RUNTIME_FUNCTION).\");\n  w->Comment(\"    BeginAddress\");\n  w->Comment(\"    EndAddress\");\n  w->Comment(\"    UnwindInfoAddress\");\n  w->StartPdataSection();\n  {\n    static_assert(Builtins::kAllBuiltinsAreIsolateIndependent);\n    Address prev_builtin_end_offset = 0;\n    for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;\n         ++builtin) {\n      const int builtin_index = static_cast<int>(builtin);\n      // Some builtins are leaf functions from the point of view of Win64 stack\n      // walking: they do not move the stack pointer and do not require a PDATA\n      // entry because the return address can be retrieved from [rsp].\n      if (unwind_infos[builtin_index].is_leaf_function()) continue;\n\n      uint64_t builtin_start_offset = blob->InstructionStartOf(builtin) -\n                                      reinterpret_cast<Address>(blob->code());\n      uint32_t builtin_size = blob->InstructionSizeOf(builtin);\n\n      const std::vector<int>& xdata_desc =\n          unwind_infos[builtin_index].fp_offsets();\n      if (xdata_desc.empty()) {\n        // Some builtins do not have any \"push rbp - mov rbp, rsp\" instructions\n        // to start a stack frame. We still emit a PDATA entry as if they had,\n        // relying on the fact that we can find the previous frame address from\n        // rbp in most cases. Note that since the function does not really start\n        // with a 'push rbp' we need to specify the start RVA in the PDATA entry\n        // a few bytes before the beginning of the function, if it does not\n        // overlap the end of the previous builtin.\n        WriteUnwindInfoEntry(\n            w, unwind_info_symbol, embedded_blob_data_symbol,\n            std::max(prev_builtin_end_offset,\n                     builtin_start_offset - win64_unwindinfo::kRbpPrefixLength),\n            builtin_start_offset + builtin_size);\n      } else {\n        // Some builtins have one or more \"push rbp - mov rbp, rsp\" sequences,\n        // but not necessarily at the beginning of the function. In this case\n        // we want to yield a PDATA entry for each block of instructions that\n        // emit an rbp frame. If the function does not start with 'push rbp'\n        // we also emit a PDATA entry for the initial block of code up to the\n        // first 'push rbp', like in the case above.\n        if (xdata_desc[0] > 0) {\n          WriteUnwindInfoEntry(w, unwind_info_symbol, embedded_blob_data_symbol,\n                               std::max(prev_builtin_end_offset,\n                                        builtin_start_offset -\n                                            win64_unwindinfo::kRbpPrefixLength),\n                               builtin_start_offset + xdata_desc[0]);\n        }\n\n        for (size_t j = 0; j < xdata_desc.size(); j++) {\n          int chunk_start = xdata_desc[j];\n          int chunk_end =\n              (j < xdata_desc.size() - 1) ? xdata_desc[j + 1] : builtin_size;\n          WriteUnwindInfoEntry(w, unwind_info_symbol, embedded_blob_data_symbol,\n                               builtin_start_offset + chunk_start,\n                               builtin_start_offset + chunk_end);\n        }\n      }\n\n      prev_builtin_end_offset = builtin_start_offset + builtin_size;\n      w->Newline();\n    }\n  }\n  w->EndPdataSection();\n  w->Newline();\n}\n\n#elif defined(V8_OS_WIN_ARM64)\n\nvoid EmitUnwindData(PlatformEmbeddedFileWriterWin* w,\n                    const char* unwind_info_symbol,\n                    const char* embedded_blob_data_symbol,\n                    const EmbeddedData* blob,\n                    const win64_unwindinfo::BuiltinUnwindInfo* unwind_infos) {\n  DCHECK(win64_unwindinfo::CanEmitUnwindInfoForBuiltins());\n\n  // Fairly arbitrary but should fit all symbol names.\n  static constexpr int kTemporaryStringLength = 256;\n  base::EmbeddedVector<char, kTemporaryStringLength> unwind_info_full_symbol;\n\n  // Emit a RUNTIME_FUNCTION (PDATA) entry for each builtin function, as\n  // documented here:\n  // https://docs.microsoft.com/en-us/cpp/build/arm64-exception-handling.\n  w->Comment(\n      \"pdata for all the code in the embedded blob (structs of type \"\n      \"RUNTIME_FUNCTION).\");\n  w->Comment(\"    BeginAddress\");\n  w->Comment(\"    UnwindInfoAddress\");\n  w->StartPdataSection();\n  std::vector<int> code_chunks;\n  std::vector<win64_unwindinfo::FrameOffsets> fp_adjustments;\n\n  static_assert(Builtins::kAllBuiltinsAreIsolateIndependent);\n  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;\n       ++builtin) {\n    const int builtin_index = static_cast<int>(builtin);\n    if (unwind_infos[builtin_index].is_leaf_function()) continue;\n\n    uint64_t builtin_start_offset = blob->InstructionStartOf(builtin) -\n                                    reinterpret_cast<Address>(blob->code());\n    uint32_t builtin_size = blob->InstructionSizeOf(builtin);\n\n    const std::vector<int>& xdata_desc =\n        unwind_infos[builtin_index].fp_offsets();\n    const std::vector<win64_unwindinfo::FrameOffsets>& xdata_fp_adjustments =\n        unwind_infos[builtin_index].fp_adjustments();\n    DCHECK_EQ(xdata_desc.size(), xdata_fp_adjustments.size());\n\n    for (size_t j = 0; j < xdata_desc.size(); j++) {\n      int chunk_start = xdata_desc[j];\n      int chunk_end =\n          (j < xdata_desc.size() - 1) ? xdata_desc[j + 1] : builtin_size;\n      int chunk_len = ::RoundUp(chunk_end - chunk_start, kInstrSize);\n\n      while (chunk_len > 0) {\n        int allowed_chunk_len =\n            std::min(chunk_len, win64_unwindinfo::kMaxFunctionLength);\n        chunk_len -= win64_unwindinfo::kMaxFunctionLength;\n\n        // Record the chunk length and fp_adjustment for emitting UNWIND_INFO\n        // later.\n        code_chunks.push_back(allowed_chunk_len);\n        fp_adjustments.push_back(xdata_fp_adjustments[j]);\n        base::SNPrintF(unwind_info_full_symbol, \"%s_%u\", unwind_info_symbol,\n                       code_chunks.size());\n        w->DeclareRvaToSymbol(embedded_blob_data_symbol,\n                              builtin_start_offset + chunk_start);\n        w->DeclareRvaToSymbol(unwind_info_full_symbol.begin());\n      }\n    }\n  }\n  w->EndPdataSection();\n  w->Newline();\n\n  // Emit an UNWIND_INFO (XDATA) structs, which contains the unwinding\n  // information.\n  w->DeclareExternalFunction(CRASH_HANDLER_FUNCTION_NAME_STRING);\n  w->StartXdataSection();\n  {\n    for (size_t i = 0; i < code_chunks.size(); i++) {\n      base::SNPrintF(unwind_info_full_symbol, \"%s_%u\", unwind_info_symbol,\n                     i + 1);\n      w->DeclareLabel(unwind_info_full_symbol.begin());\n      std::vector<uint8_t> xdata =\n          win64_unwindinfo::GetUnwindInfoForBuiltinFunction(code_chunks[i],\n                                                            fp_adjustments[i]);\n\n      w->IndentedDataDirective(kByte);\n      for (size_t j = 0; j < xdata.size(); j++) {\n        if (j > 0) fprintf(w->fp(), \",\");\n        w->HexLiteral(xdata[j]);\n      }\n      w->Newline();\n      w->DeclareRvaToSymbol(CRASH_HANDLER_FUNCTION_NAME_STRING);\n    }\n  }\n  w->EndXdataSection();\n  w->Newline();\n}\n\n#endif  // V8_OS_WIN_X64\n\n}  // namespace\n\nconst char* PlatformEmbeddedFileWriterWin::DirectiveAsString(\n    DataDirective directive) {\n#if defined(V8_COMPILER_IS_MSVC)\n  if (target_arch_ != EmbeddedTargetArch::kArm64) {\n    switch (directive) {\n      case kByte:\n        return \"BYTE\";\n      case kLong:\n        return \"DWORD\";\n      case kQuad:\n        return \"QWORD\";\n      default:\n        UNREACHABLE();\n    }\n  } else {\n    switch (directive) {\n      case kByte:\n        return \"DCB\";\n      case kLong:\n        return \"DCDU\";\n      case kQuad:\n        return \"DCQU\";\n      default:\n        UNREACHABLE();\n    }\n  }\n#else\n  switch (directive) {\n    case kByte:\n      return \".byte\";\n    case kLong:\n      return \".long\";\n    case kQuad:\n      return \".quad\";\n    case kOcta:\n      return \".octa\";\n  }\n  UNREACHABLE();\n#endif\n}\n\nvoid PlatformEmbeddedFileWriterWin::MaybeEmitUnwindData(\n    const char* unwind_info_symbol, const char* embedded_blob_data_symbol,\n    const EmbeddedData* blob, const void* unwind_infos) {\n// Windows ARM64 supports cross build which could require unwind info for\n// host_os. Ignore this case because it is only used in build time.\n#if defined(V8_OS_WIN_ARM64)\n  if (target_arch_ != EmbeddedTargetArch::kArm64) {\n    return;\n  }\n#endif  // V8_OS_WIN_ARM64\n\n#if defined(V8_OS_WIN64)\n  if (win64_unwindinfo::CanEmitUnwindInfoForBuiltins()) {\n    EmitUnwindData(this, unwind_info_symbol, embedded_blob_data_symbol, blob,\n                   reinterpret_cast<const win64_unwindinfo::BuiltinUnwindInfo*>(\n                       unwind_infos));\n  }\n#endif  // V8_OS_WIN64\n}\n\n// Windows, MSVC\n// -----------------------------------------------------------------------------\n\n#if defined(V8_COMPILER_IS_MSVC)\n\n// For x64 MSVC builds we emit assembly in MASM syntax.\n// See https://docs.microsoft.com/en-us/cpp/assembler/masm/directives-reference.\n// For Arm build, we emit assembly in MARMASM syntax.\n// Note that the same mksnapshot has to be used to compile the host and target.\n\n// The AARCH64 ABI requires instructions be 4-byte-aligned and Windows does\n// not have a stricter alignment requirement (see the TEXTAREA macro of\n// kxarm64.h in the Windows SDK), so code is 4-byte-aligned.\n// The data fields in the emitted assembly tend to be accessed with 8-byte\n// LDR instructions, so data is 8-byte-aligned.\n//\n// armasm64's warning A4228 states\n//     Alignment value exceeds AREA alignment; alignment not guaranteed\n// To ensure that ALIGN directives are honored, their values are defined as\n// equal to their corresponding AREA's ALIGN attributes.\n\n#define ARM64_DATA_ALIGNMENT_POWER (3)\n#define ARM64_DATA_ALIGNMENT (1 << ARM64_DATA_ALIGNMENT_POWER)\n#define ARM64_CODE_ALIGNMENT_POWER (2)\n#define ARM64_CODE_ALIGNMENT (1 << ARM64_CODE_ALIGNMENT_POWER)\n\nvoid PlatformEmbeddedFileWriterWin::SectionText() {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  AREA |.text|, CODE, ALIGN=%d, READONLY\\n\",\n            ARM64_CODE_ALIGNMENT_POWER);\n  } else {\n    fprintf(fp_, \".CODE\\n\");\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::SectionRoData() {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  AREA |.rodata|, DATA, ALIGN=%d, READONLY\\n\",\n            ARM64_DATA_ALIGNMENT_POWER);\n  } else {\n    fprintf(fp_, \".CONST\\n\");\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareUint32(const char* name,\n                                                  uint32_t value) {\n  DeclareSymbolGlobal(name);\n  fprintf(fp_, \"%s%s %s %d\\n\", SYMBOL_PREFIX, name, DirectiveAsString(kLong),\n          value);\n}\n\nvoid PlatformEmbeddedFileWriterWin::StartPdataSection() {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  AREA |.pdata|, DATA, ALIGN=%d, READONLY\\n\",\n            ARM64_DATA_ALIGNMENT_POWER);\n  } else {\n    fprintf(fp_, \"OPTION DOTNAME\\n\");\n    fprintf(fp_, \".pdata SEGMENT DWORD READ ''\\n\");\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::EndPdataSection() {\n  if (target_arch_ != EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \".pdata ENDS\\n\");\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::StartXdataSection() {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  AREA |.xdata|, DATA, ALIGN=%d, READONLY\\n\",\n            ARM64_DATA_ALIGNMENT_POWER);\n  } else {\n    fprintf(fp_, \"OPTION DOTNAME\\n\");\n    fprintf(fp_, \".xdata SEGMENT DWORD READ ''\\n\");\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::EndXdataSection() {\n  if (target_arch_ != EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \".xdata ENDS\\n\");\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareExternalFunction(const char* name) {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  EXTERN %s \\n\", name);\n  } else {\n    fprintf(fp_, \"EXTERN %s : PROC\\n\", name);\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareRvaToSymbol(const char* name,\n                                                       uint64_t offset) {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    if (offset > 0) {\n      fprintf(fp_, \"  DCD  %s + %llu\\n\", name, offset);\n    } else {\n      fprintf(fp_, \"  DCD  %s\\n\", name);\n    }\n    // The default relocation entry generated by MSVC armasm64.exe for DCD\n    // directive is IMAGE_REL_ARM64_ADDR64 which represents relocation for\n    // 64-bit pointer instead of 32-bit RVA. Append RELOC with\n    // IMAGE_REL_ARM64_ADDR32NB(2) to generate correct relocation entry for\n    // 32-bit RVA.\n    fprintf(fp_, \"  RELOC 2\\n\");\n  } else {\n    if (offset > 0) {\n      fprintf(fp_, \"DD IMAGEREL %s+%llu\\n\", name, offset);\n    } else {\n      fprintf(fp_, \"DD IMAGEREL %s\\n\", name);\n    }\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareSymbolGlobal(const char* name) {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  EXPORT %s%s\\n\", SYMBOL_PREFIX, name);\n  } else {\n    fprintf(fp_, \"PUBLIC %s%s\\n\", SYMBOL_PREFIX, name);\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::AlignToCodeAlignment() {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  ALIGN %d\\n\", ARM64_CODE_ALIGNMENT);\n  } else {\n    // Diverges from other platforms due to compile error\n    // 'invalid combination with segment alignment'.\n    fprintf(fp_, \"ALIGN 4\\n\");\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::AlignToDataAlignment() {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  ALIGN %d\\n\", ARM64_DATA_ALIGNMENT);\n\n  } else {\n    fprintf(fp_, \"ALIGN 4\\n\");\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::Comment(const char* string) {\n  fprintf(fp_, \"; %s\\n\", string);\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareLabel(const char* name) {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"%s%s\\n\", SYMBOL_PREFIX, name);\n\n  } else {\n    fprintf(fp_, \"%s%s LABEL %s\\n\", SYMBOL_PREFIX, name,\n            DirectiveAsString(kByte));\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::SourceInfo(int fileid, const char* filename,\n                                               int line) {\n  // TODO(mvstanton): output source information for MSVC.\n  // Its syntax is #line <line> \"<filename>\"\n}\n\n// TODO(mmarchini): investigate emitting size annotations for Windows\nvoid PlatformEmbeddedFileWriterWin::DeclareFunctionBegin(const char* name,\n                                                         uint32_t size) {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"%s%s FUNCTION\\n\", SYMBOL_PREFIX, name);\n\n  } else {\n    fprintf(fp_, \"%s%s PROC\\n\", SYMBOL_PREFIX, name);\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareFunctionEnd(const char* name) {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  ENDFUNC\\n\");\n\n  } else {\n    fprintf(fp_, \"%s%s ENDP\\n\", SYMBOL_PREFIX, name);\n  }\n}\n\nint PlatformEmbeddedFileWriterWin::HexLiteral(uint64_t value) {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    return fprintf(fp_, \"0x%\" PRIx64, value);\n\n  } else {\n    return fprintf(fp_, \"0%\" PRIx64 \"h\", value);\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::FilePrologue() {\n  if (target_arch_ != EmbeddedTargetArch::kArm64 &&\n      target_arch_ != EmbeddedTargetArch::kX64) {\n    // x86 falls into this case\n    fprintf(fp_, \".MODEL FLAT\\n\");\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareExternalFilename(\n    int fileid, const char* filename) {}\n\nvoid PlatformEmbeddedFileWriterWin::FileEpilogue() {\n  if (target_arch_ == EmbeddedTargetArch::kArm64) {\n    fprintf(fp_, \"  END\\n\");\n  } else {\n    fprintf(fp_, \"END\\n\");\n  }\n}\n\nint PlatformEmbeddedFileWriterWin::IndentedDataDirective(\n    DataDirective directive) {\n  return fprintf(fp_, \"  %s \", DirectiveAsString(directive));\n}\n\n#undef ARM64_DATA_ALIGNMENT_POWER\n#undef ARM64_DATA_ALIGNMENT\n#undef ARM64_CODE_ALIGNMENT_POWER\n#undef ARM64_CODE_ALIGNMENT\n\n// All Windows builds without MSVC.\n// -----------------------------------------------------------------------------\n\n#else\n\n// The directives for text section prefix come from the COFF\n// (Common Object File Format) standards:\n// https://llvm.org/docs/Extensions.html\n//\n// .text$hot means this section contains hot code.\n// x means executable section.\n// r means read-only section.\nvoid PlatformEmbeddedFileWriterWin::SectionText() {\n  fprintf(fp_, \".section .text$hot,\\\"xr\\\"\\n\");\n}\n\nvoid PlatformEmbeddedFileWriterWin::SectionRoData() {\n  fprintf(fp_, \".section .rdata\\n\");\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareUint32(const char* name,\n                                                  uint32_t value) {\n  DeclareSymbolGlobal(name);\n  DeclareLabel(name);\n  IndentedDataDirective(kLong);\n  fprintf(fp_, \"%d\", value);\n  Newline();\n}\n\nvoid PlatformEmbeddedFileWriterWin::StartPdataSection() {\n  fprintf(fp_, \".section .pdata\\n\");\n}\n\nvoid PlatformEmbeddedFileWriterWin::EndPdataSection() {}\n\nvoid PlatformEmbeddedFileWriterWin::StartXdataSection() {\n  fprintf(fp_, \".section .xdata\\n\");\n}\n\nvoid PlatformEmbeddedFileWriterWin::EndXdataSection() {}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareExternalFunction(const char* name) {}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareRvaToSymbol(const char* name,\n                                                       uint64_t offset) {\n  if (offset > 0) {\n    fprintf(fp_, \".rva %s + %\" PRIu64 \"\\n\", name, offset);\n  } else {\n    fprintf(fp_, \".rva %s\\n\", name);\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareSymbolGlobal(const char* name) {\n  fprintf(fp_, \".global %s%s\\n\", SYMBOL_PREFIX, name);\n}\n\nvoid PlatformEmbeddedFileWriterWin::AlignToCodeAlignment() {\n#if V8_TARGET_ARCH_X64\n  // On x64 use 64-bytes code alignment to allow 64-bytes loop header alignment.\n  static_assert(64 >= kCodeAlignment);\n  fprintf(fp_, \".balign 64\\n\");\n#elif V8_TARGET_ARCH_PPC64\n  // 64 byte alignment is needed on ppc64 to make sure p10 prefixed instructions\n  // don't cross 64-byte boundaries.\n  static_assert(64 >= kCodeAlignment);\n  fprintf(fp_, \".balign 64\\n\");\n#else\n  static_assert(32 >= kCodeAlignment);\n  fprintf(fp_, \".balign 32\\n\");\n#endif\n}\n\nvoid PlatformEmbeddedFileWriterWin::AlignToDataAlignment() {\n  // On Windows ARM64, s390, PPC and possibly more platforms, aligned load\n  // instructions are used to retrieve v8_Default_embedded_blob_ and/or\n  // v8_Default_embedded_blob_size_. The generated instructions require the\n  // load target to be aligned at 8 bytes (2^3).\n  fprintf(fp_, \".balign 8\\n\");\n}\n\nvoid PlatformEmbeddedFileWriterWin::Comment(const char* string) {\n  fprintf(fp_, \"// %s\\n\", string);\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareLabel(const char* name) {\n  fprintf(fp_, \"%s%s:\\n\", SYMBOL_PREFIX, name);\n}\n\nvoid PlatformEmbeddedFileWriterWin::SourceInfo(int fileid, const char* filename,\n                                               int line) {\n  // BUG(9944): Use .cv_loc to ensure CodeView information is used on\n  // Windows.\n}\n\n// TODO(mmarchini): investigate emitting size annotations for Windows\nvoid PlatformEmbeddedFileWriterWin::DeclareFunctionBegin(const char* name,\n                                                         uint32_t size) {\n  DeclareLabel(name);\n\n  if (target_arch_ == EmbeddedTargetArch::kArm64\n#if V8_ENABLE_DRUMBRAKE\n      || IsDrumBrakeInstructionHandler(name)\n#endif  // V8_ENABLE_DRUMBRAKE\n  ) {\n    // Windows ARM64 assembly is in GAS syntax, but \".type\" is invalid directive\n    // in PE/COFF for Windows.\n    DeclareSymbolGlobal(name);\n  } else {\n    // The directives for inserting debugging information on Windows come\n    // from the PE (Portable Executable) and COFF (Common Object File Format)\n    // standards. Documented here:\n    // https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format\n    //\n    // .scl 2 means StorageClass external.\n    // .type 32 means Type Representation Function.\n    fprintf(fp_, \".def %s%s; .scl 2; .type 32; .endef;\\n\", SYMBOL_PREFIX, name);\n  }\n}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareFunctionEnd(const char* name) {}\n\nint PlatformEmbeddedFileWriterWin::HexLiteral(uint64_t value) {\n  return fprintf(fp_, \"0x%\" PRIx64, value);\n}\n\nvoid PlatformEmbeddedFileWriterWin::FilePrologue() {}\n\nvoid PlatformEmbeddedFileWriterWin::DeclareExternalFilename(\n    int fileid, const char* filename) {\n  // BUG(9944): Use .cv_filename to ensure CodeView information is used on\n  // Windows.\n}\n\nvoid PlatformEmbeddedFileWriterWin::FileEpilogue() {}\n\nint PlatformEmbeddedFileWriterWin::IndentedDataDirective(\n    DataDirective directive) {\n  return fprintf(fp_, \"  %s \", DirectiveAsString(directive));\n}\n\n#endif\n\nDataDirective PlatformEmbeddedFileWriterWin::ByteChunkDataDirective() const {\n#if defined(V8_COMPILER_IS_MSVC)\n  // Windows MASM doesn't have an .octa directive, use QWORDs instead.\n  // Note: MASM *really* does not like large data streams. It takes over 5\n  // minutes to assemble the ~350K lines of embedded.S produced when using\n  // BYTE directives in a debug build. QWORD produces roughly 120KLOC and\n  // reduces assembly time to ~40 seconds. Still terrible, but much better\n  // than before. See also: https://crbug.com/v8/8475.\n  return kQuad;\n#else\n  return PlatformEmbeddedFileWriterBase::ByteChunkDataDirective();\n#endif\n}\n\nint PlatformEmbeddedFileWriterWin::WriteByteChunk(const uint8_t* data) {\n#if defined(V8_COMPILER_IS_MSVC)\n  DCHECK_EQ(ByteChunkDataDirective(), kQuad);\n  const uint64_t* quad_ptr = reinterpret_cast<const uint64_t*>(data);\n  return HexLiteral(*quad_ptr);\n#else\n  return PlatformEmbeddedFileWriterBase::WriteByteChunk(data);\n#endif\n}\n\n#undef SYMBOL_PREFIX\n#undef V8_ASSEMBLER_IS_MASM\n#undef V8_ASSEMBLER_IS_MARMASM\n#undef V8_COMPILER_IS_MSVC\n\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"WriteUnwindInfoEntry\",\n            \"parent\": \"\",\n            \"about\": \"Writes an entry for unwind information, declaring RVA (Relative Virtual Address) to symbol mappings.\",\n            \"logic\": \"Declares mappings between a symbol (representing unwind information) and offsets within another symbol (representing embedded blob data).  This is critical for"
}