{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-containers.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-containers.h\",\n        \"file_name\": \"zone-containers.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines zone-aware container classes that allocate memory from a Zone, providing efficient memory management for short-lived objects.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ containers and related headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <deque>\n#include <forward_list>\n#include <initializer_list>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes abseil containers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"absl/container/btree_map.h\"\n#include \"absl/container/flat_hash_map.h\"\n#include \"absl/container/flat_hash_set.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes V8-specific headers for hashing, intrusive sets, small maps/vectors, and zone allocation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/hashing.h\"\n#include \"src/base/intrusive-set.h\"\n#include \"src/base/small-map.h\"\n#include \"src/base/small-vector.h\"\n#include \"src/zone/zone-allocator.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneVector\",\n            \"about\": \"A zone-allocated vector that provides similar functionality to std::vector but allocates memory from a Zone.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"T*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the start of the allocated memory.\"\n                },\n                {\n                    \"name\": \"end_\",\n                    \"type\": \"T*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the end of the used memory (one past the last element).\"\n                },\n                {\n                    \"name\": \"capacity_\",\n                    \"type\": \"T*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the end of the allocated memory.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass ZoneVector {\n public:\n  using iterator = T*;\n  using const_iterator = const T*;\n  using reverse_iterator = std::reverse_iterator<T*>;\n  using const_reverse_iterator = std::reverse_iterator<const T*>;\n  using value_type = T;\n  using reference = T&;\n  using const_reference = const T&;\n  using size_type = size_t;\n\n  // Constructs an empty vector.\n  explicit ZoneVector(Zone* zone) : zone_(zone) {}\n\n  // Constructs a new vector and fills it with {size} elements, each\n  // constructed via the default constructor.\n  ZoneVector(size_t size, Zone* zone) : zone_(zone) {\n    data_ = size > 0 ? zone->AllocateArray<T>(size) : nullptr;\n    end_ = capacity_ = data_ + size;\n    for (T* p = data_; p < end_; p++) emplace(p);\n  }\n\n  // Constructs a new vector and fills it with {size} elements, each\n  // having the value {def}.\n  ZoneVector(size_t size, T def, Zone* zone) : zone_(zone) {\n    data_ = size > 0 ? zone->AllocateArray<T>(size) : nullptr;\n    end_ = capacity_ = data_ + size;\n    for (T* p = data_; p < end_; p++) emplace(p, def);\n  }\n\n  // Constructs a new vector and fills it with the contents of the given\n  // initializer list.\n  ZoneVector(std::initializer_list<T> list, Zone* zone) : zone_(zone) {\n    size_t size = list.size();\n    if (size > 0) {\n      data_ = zone->AllocateArray<T>(size);\n      CopyToNewStorage(data_, list.begin(), list.end());\n    } else {\n      data_ = nullptr;\n    }\n    end_ = capacity_ = data_ + size;\n  }\n\n  // Constructs a new vector and fills it with the contents of the range\n  // [first, last).\n  template <class It,\n            typename = typename std::iterator_traits<It>::iterator_category>\n  ZoneVector(It first, It last, Zone* zone) : zone_(zone) {\n    if constexpr (std::is_base_of_v<\n                      std::random_access_iterator_tag,\n                      typename std::iterator_traits<It>::iterator_category>) {\n      size_t size = last - first;\n      data_ = size > 0 ? zone->AllocateArray<T>(size) : nullptr;\n      end_ = capacity_ = data_ + size;\n      for (T* p = data_; p < end_; p++) emplace(p, *first++);\n    } else {\n      while (first != last) push_back(*first++);\n    }\n    DCHECK_EQ(first, last);\n  }\n\n  ZoneVector(const ZoneVector& other) V8_NOEXCEPT : zone_(other.zone_) {\n    *this = other;\n  }\n\n  ZoneVector(ZoneVector&& other) V8_NOEXCEPT { *this = std::move(other); }\n\n  ~ZoneVector() {\n    for (T* p = data_; p < end_; p++) p->~T();\n    if (data_) zone_->DeleteArray(data_, capacity());\n  }\n\n  // Assignment operators.\n  ZoneVector& operator=(const ZoneVector& other) V8_NOEXCEPT {\n    // Self-assignment would cause undefined behavior in the !copy_assignable\n    // branch, but likely indicates a bug in calling code anyway.\n    DCHECK_NE(this, &other);\n    T* src = other.data_;\n    if (capacity() >= other.size() && zone_ == other.zone_) {\n      T* dst = data_;\n      if constexpr (std::is_trivially_copyable_v<T>) {\n        size_t size = other.size();\n        if (size) memcpy(dst, src, size * sizeof(T));\n        end_ = dst + size;\n      } else if constexpr (std::is_copy_assignable_v<T>) {\n        while (dst < end_ && src < other.end_) *dst++ = *src++;\n        while (src < other.end_) emplace(dst++, *src++);\n        T* old_end = end_;\n        end_ = dst;\n        for (T* p = end_; p < old_end; p++) p->~T();\n      } else {\n        for (T* p = data_; p < end_; p++) p->~T();\n        while (src < other.end_) emplace(dst++, *src++);\n        end_ = dst;\n      }\n    } else {\n      for (T* p = data_; p < end_; p++) p->~T();\n      if (data_) zone_->DeleteArray(data_, capacity());\n      size_t new_cap = other.capacity();\n      if (new_cap > 0) {\n        data_ = zone_->AllocateArray<T>(new_cap);\n        CopyToNewStorage(data_, other.data_, other.end_);\n      } else {\n        data_ = nullptr;\n      }\n      capacity_ = data_ + new_cap;\n      end_ = data_ + other.size();\n    }\n    return *this;\n  }\n\n  ZoneVector& operator=(ZoneVector&& other) V8_NOEXCEPT {\n    // Self-assignment would cause undefined behavior, and is probably a bug.\n    DCHECK_NE(this, &other);\n    // Move-assigning vectors from different zones would have surprising\n    // lifetime semantics regardless of how we choose to implement it (keep\n    // the old zone? Take the new zone?).\n    if (zone_ == nullptr) {\n      zone_ = other.zone_;\n    } else {\n      DCHECK_EQ(zone_, other.zone_);\n    }\n    for (T* p = data_; p < end_; p++) p->~T();\n    if (data_) zone_->DeleteArray(data_, capacity());\n    data_ = other.data_;\n    end_ = other.end_;\n    capacity_ = other.capacity_;\n    // {other.zone_} may stay.\n    other.data_ = other.end_ = other.capacity_ = nullptr;\n    return *this;\n  }\n\n  ZoneVector& operator=(std::initializer_list<T> ilist) {\n    clear();\n    EnsureCapacity(ilist.size());\n    CopyToNewStorage(data_, ilist.begin(), ilist.end());\n    end_ = data_ + ilist.size();\n    return *this;\n  }\n\n  void swap(ZoneVector<T>& other) noexcept {\n    DCHECK_EQ(zone_, other.zone_);\n    std::swap(data_, other.data_);\n    std::swap(end_, other.end_);\n    std::swap(capacity_, other.capacity_);\n  }\n\n  void resize(size_t new_size) {\n    EnsureCapacity(new_size);\n    T* new_end = data_ + new_size;\n    for (T* p = end_; p < new_end; p++) emplace(p);\n    for (T* p = new_end; p < end_; p++) p->~T();\n    end_ = new_end;\n  }\n\n  void resize(size_t new_size, const T& value) {\n    EnsureCapacity(new_size);\n    T* new_end = data_ + new_size;\n    for (T* p = end_; p < new_end; p++) emplace(p, value);\n    for (T* p = new_end; p < end_; p++) p->~T();\n    end_ = new_end;\n  }\n\n  void assign(size_t new_size, const T& value) {\n    if (capacity() >= new_size) {\n      T* new_end = data_ + new_size;\n      T* assignable = data_ + std::min(size(), new_size);\n      for (T* p = data_; p < assignable; p++) CopyingOverwrite(p, &value);\n      for (T* p = assignable; p < new_end; p++) CopyToNewStorage(p, &value);\n      for (T* p = new_end; p < end_; p++) p->~T();\n      end_ = new_end;\n    } else {\n      clear();\n      EnsureCapacity(new_size);\n      T* new_end = data_ + new_size;\n      for (T* p = data_; p < new_end; p++) emplace(p, value);\n      end_ = new_end;\n    }\n  }\n\n  void clear() {\n    for (T* p = data_; p < end_; p++) p->~T();\n    end_ = data_;\n  }\n\n  size_t size() const { return end_ - data_; }\n  bool empty() const { return end_ == data_; }\n  size_t capacity() const { return capacity_ - data_; }\n  void reserve(size_t new_cap) { EnsureCapacity(new_cap); }\n  T* data() { return data_; }\n  const T* data() const { return data_; }\n  Zone* zone() const { return zone_; }\n\n  T& at(size_t pos) {\n    DCHECK_LT(pos, size());\n    return data_[pos];\n  }\n  const T& at(size_t pos) const {\n    DCHECK_LT(pos, size());\n    return data_[pos];\n  }\n\n  T& operator[](size_t pos) { return at(pos); }\n  const T& operator[](size_t pos) const { return at(pos); }\n\n  T& front() {\n    DCHECK_GT(end_, data_);\n    return *data_;\n  }\n  const T& front() const {\n    DCHECK_GT(end_, data_);\n    return *data_;\n  }\n\n  T& back() {\n    DCHECK_GT(end_, data_);\n    return *(end_ - 1);\n  }\n  const T& back() const {\n    DCHECK_GT(end_, data_);\n    return *(end_ - 1);\n  }\n\n  T* begin() V8_NOEXCEPT { return data_; }\n  const T* begin() const V8_NOEXCEPT { return data_; }\n  const T* cbegin() const V8_NOEXCEPT { return data_; }\n\n  T* end() V8_NOEXCEPT { return end_; }\n  const T* end() const V8_NOEXCEPT { return end_; }\n  const T* cend() const V8_NOEXCEPT { return end_; }\n\n  reverse_iterator rbegin() V8_NOEXCEPT {\n    return std::make_reverse_iterator(end());\n  }\n  const_reverse_iterator rbegin() const V8_NOEXCEPT {\n    return std::make_reverse_iterator(end());\n  }\n  const_reverse_iterator crbegin() const V8_NOEXCEPT {\n    return std::make_reverse_iterator(cend());\n  }\n  reverse_iterator rend() V8_NOEXCEPT {\n    return std::make_reverse_iterator(begin());\n  }\n  const_reverse_iterator rend() const V8_NOEXCEPT {\n    return std::make_reverse_iterator(begin());\n  }\n  const_reverse_iterator crend() const V8_NOEXCEPT {\n    return std::make_reverse_iterator(cbegin());\n  }\n\n  void push_back(const T& value) {\n    EnsureOneMoreCapacity();\n    emplace(end_++, value);\n  }\n  void push_back(T&& value) { emplace_back(std::move(value)); }\n\n  void pop_back() {\n    DCHECK_GT(end_, data_);\n    (--end_)->~T();\n  }\n\n  template <typename... Args>\n  T& emplace_back(Args&&... args) {\n    EnsureOneMoreCapacity();\n    T* ptr = end_++;\n    new (ptr) T(std::forward<Args>(args)...);\n    return *ptr;\n  }\n\n  template <class It,\n            typename = typename std::iterator_traits<It>::iterator_category>\n  T* insert(const T* pos, It first, It last) {\n    T* position;\n    if constexpr (std::is_base_of_v<\n                      std::random_access_iterator_tag,\n                      typename std::iterator_traits<It>::iterator_category>) {\n      DCHECK_LE(0, last - first);\n      size_t count = last - first;\n      size_t assignable;\n      position = PrepareForInsertion(pos, count, &assignable);\n      if constexpr (std::is_trivially_copyable_v<T>) {\n        if (count > 0) memcpy(position, first, count * sizeof(T));\n      } else {\n        CopyingOverwrite(position, first, first + assignable);\n        CopyToNewStorage(position + assignable, first + assignable, last);\n      }\n    } else if (pos == end()) {\n      position = end_;\n      while (first != last) {\n        EnsureOneMoreCapacity();\n        emplace(end_++, *first++);\n      }\n    } else {\n      UNIMPLEMENTED();\n      // We currently have no users of this case.\n      // It could be implemented inefficiently as a combination of the two\n      // cases above: while (first != last) { PrepareForInsertion(_, 1, _); }.\n      // A more efficient approach would be to accumulate the input iterator's\n      // results into a temporary vector first, then grow {this} only once\n      // (by calling PrepareForInsertion(_, count, _)), then copy over the\n      // accumulated elements.\n    }\n    return position;\n  }\n  T* insert(const T* pos, size_t count, const T& value) {\n    size_t assignable;\n    T* position = PrepareForInsertion(pos, count, &assignable);\n    T* dst = position;\n    T* stop = dst + assignable;\n    while (dst < stop) {\n      CopyingOverwrite(dst++, &value);\n    }\n    stop = position + count;\n    while (dst < stop) emplace(dst++, value);\n    return position;\n  }\n\n  T* erase(const T* pos) {\n    DCHECK(data_ <= pos && pos <= end());\n    if (pos == end()) return const_cast<T*>(pos);\n    return erase(pos, 1);\n  }\n  T* erase(const T* first, const T* last) {\n    DCHECK(data_ <= first && first <= last && last <= end());\n    if (first == last) return const_cast<T*>(first);\n    return erase(first, last - first);\n  }\n\n private:\n  static constexpr size_t kMinCapacity = 2;\n  size_t NewCapacity(size_t minimum) {\n    // We can ignore possible overflow here: on 32-bit platforms, if the\n    // multiplication overflows, there's no better way to handle it than\n    // relying on the \"new_capacity < minimum\" check; in particular, a\n    // saturating multiplication would make no sense. On 64-bit platforms,\n    // overflow is effectively impossible anyway.\n    size_t new_capacity = data_ == capacity_ ? kMinCapacity : capacity() * 2;\n    return new_capacity < minimum ? minimum : new_capacity;\n  }\n\n  V8_INLINE void EnsureOneMoreCapacity() {\n    if (V8_LIKELY(end_ < capacity_)) return;\n    Grow(capacity() + 1);\n  }\n\n  V8_INLINE void EnsureCapacity(size_t minimum) {\n    if (V8_LIKELY(minimum <= capacity())) return;\n    Grow(minimum);\n  }\n\n  V8_INLINE void CopyToNewStorage(T* dst, const T* src) { emplace(dst, *src); }\n\n  V8_INLINE void MoveToNewStorage(T* dst, T* src) {\n    if constexpr (std::is_move_constructible_v<T>) {\n      emplace(dst, std::move(*src));\n    } else {\n      CopyToNewStorage(dst, src);\n    }\n  }\n\n  V8_INLINE void CopyingOverwrite(T* dst, const T* src) {\n    if constexpr (std::is_copy_assignable_v<T>) {\n      *dst = *src;\n    } else {\n      dst->~T();\n      CopyToNewStorage(dst, src);\n    }\n  }\n\n  V8_INLINE void MovingOverwrite(T* dst, T* src) {\n    if constexpr (std::is_move_assignable_v<T>) {\n      *dst = std::move(*src);\n    } else {\n      CopyingOverwrite(dst, src);\n    }\n  }\n\n#define EMIT_TRIVIAL_CASE(memcpy_function)                 \\\n  DCHECK_LE(src, src_end);                                 \\\n  if constexpr (std::is_trivially_copyable_v<T>) {         \\\n    size_t count = src_end - src;                          \\\n    /* Add V8_ASSUME to silence gcc null check warning. */ \\\n    V8_ASSUME(src != nullptr);                             \\\n    memcpy_function(dst, src, count * sizeof(T));          \\\n    return;                                                \\\n  }\n\n  V8_INLINE void CopyToNewStorage(T* dst, const T* src, const T* src_end) {\n    EMIT_TRIVIAL_CASE(memcpy)\n    for (; src < src_end; dst++, src++) {\n      CopyToNewStorage(dst, src);\n    }\n  }\n\n  V8_INLINE void MoveToNewStorage(T* dst, T* src, const T* src_end) {\n    EMIT_TRIVIAL_CASE(memcpy)\n    for (; src < src_end; dst++, src++) {\n      MoveToNewStorage(dst, src);\n      src->~T();\n    }\n  }\n\n  V8_INLINE void CopyingOverwrite(T* dst, const T* src, const T* src_end) {\n    EMIT_TRIVIAL_CASE(memmove)\n    for (; src < src_end; dst++, src++) {\n      CopyingOverwrite(dst, src);\n    }\n  }\n\n  V8_INLINE void MovingOverwrite(T* dst, T* src, const T* src_end) {\n    EMIT_TRIVIAL_CASE(memmove)\n    for (; src < src_end; dst++, src++) {\n      MovingOverwrite(dst, src);\n    }\n  }\n\n#undef EMIT_TRIVIAL_CASE\n\n  V8_NOINLINE V8_PRESERVE_MOST void Grow(size_t minimum) {\n    T* old_data = data_;\n    T* old_end = end_;\n    size_t old_size = size();\n    size_t new_capacity = NewCapacity(minimum);\n    data_ = zone_->AllocateArray<T>(new_capacity);\n    end_ = data_ + old_size;\n    if (old_data) {\n      MoveToNewStorage(data_, old_data, old_end);\n      zone_->DeleteArray(old_data, capacity_ - old_data);\n    }\n    capacity_ = data_ + new_capacity;\n  }\n\n  T* PrepareForInsertion(const T* pos, size_t count, size_t* assignable) {\n    DCHECK(data_ <= pos && pos <= end_);\n    CHECK(std::numeric_limits<size_t>::max() - size() >= count);\n    size_t index = pos - data_;\n    size_t to_shift = end() - pos;\n    DCHECK_EQ(index + to_shift, size());\n    if (capacity() < size() + count) {\n      *assignable = 0;  // Fresh memory is not assignable (must be constructed).\n      T* old_data = data_;\n      T* old_end = end_;\n      size_t old_size = size();\n      size_t new_capacity = NewCapacity(old_size + count);\n      data_ = zone_->AllocateArray<T>(new_capacity);\n      end_ = data_ + old_size + count;\n      if (old_data) {\n        MoveToNewStorage(data_, old_data, pos);\n        MoveToNewStorage(data_ + index + count, const_cast<T*>(pos), old_end);\n        zone_->DeleteArray(old_data, capacity_ - old_data);\n      }\n      capacity_ = data_ + new_capacity;\n    } else {\n      // There are two interesting cases: we're inserting more elements\n      // than we're shifting (top), or the other way round (bottom).\n      //\n      // Old: [ABCDEFGHIJ___________]\n      //       <--used--><--empty-->\n      //\n      // Case 1: index=7, count=8, to_shift=3\n      // New: [ABCDEFGaaacccccHIJ___]\n      //              <-><------>\n      //               \u2191    \u2191 to be in-place constructed\n      //               \u2191\n      //               assignable_slots\n      //\n      // Case 2: index=3, count=3, to_shift=7\n      // New: [ABCaaaDEFGHIJ________]\n      //          <-----><->\n      //             \u2191    \u2191 to be in-place constructed\n      //             \u2191\n      //             This range can be assigned. We report the first 3\n      //             as {assignable_slots} to the caller, and use the other 4\n      //             in the loop below.\n      // Observe that the number of old elements that are moved to the\n      // new end by in-place construction always equals {assignable_slots}.\n      size_t assignable_slots = std::min(to_shift, count);\n      *assignable = assignable_slots;\n      if constexpr (std::is_trivially_copyable_v<T>) {\n        if (to_shift > 0) {\n          // Add V8_ASSUME to silence gcc null check warning.\n          V8_ASSUME(pos != nullptr);\n          memmove(const_cast<T*>(pos + count), pos, to_shift * sizeof(T));\n        }\n        end_ += count;\n        return data_ + index;\n      }\n      // Construct elements in previously-unused area (\"HIJ\" in the example\n      // above). This frees up assignable slots.\n      T* dst = end_ + count;\n      T* src = end_;\n      for (T* stop = dst - assignable_slots; dst > stop;) {\n        MoveToNewStorage(--dst, --src);\n      }\n      // Move (by assignment) elements into previously used area. This is\n      // \"DEFG\" in \"case 2\" in the example above.\n      DCHECK_EQ(src > pos, to_shift > count);\n      DCHECK_IMPLIES(src > pos, dst == end_);\n      while (src > pos) MovingOverwrite(--dst, --src);\n      // Not destructing {src} here because that'll happen either in a\n      // future iteration (when that spot becomes {dst}) or in {insert()}.\n      end_ += count;\n    }\n    return data_ + index;\n  }\n\n  T* erase(const T* first, size_t count) {\n    DCHECK(data_ <= first && first <= end());\n    DCHECK_LE(count, end() - first);\n    T* position = const_cast<T*>(first);\n    MovingOverwrite(position, position + count, end());\n    T* old_end = end();\n    end_ -= count;\n    for (T* p = end_; p < old_end; p++) p->~T();\n    return position;\n  }\n\n  template <typename... Args>\n  void emplace(T* target, Args&&... args) {\n    new (target) T(std::forward<Args>(args)...);\n  }\n\n  Zone* zone_{nullptr};\n  T* data_{nullptr};\n  T* end_{nullptr};\n  T* capacity_{nullptr};\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Equality operator for ZoneVector\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const ZoneVector<T>&\",\n                    \"purpose\": \"Left-hand side ZoneVector\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const ZoneVector<T>&\",\n                    \"purpose\": \"Right-hand side ZoneVector\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the ZoneVectors are equal, false otherwise\"\n            },\n            \"dependencies\": [\n                \"std::equal\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nbool operator==(const ZoneVector<T>& lhs, const ZoneVector<T>& rhs) {\n  return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Inequality operator for ZoneVector\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const ZoneVector<T>&\",\n                    \"purpose\": \"Left-hand side ZoneVector\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const ZoneVector<T>&\",\n                    \"purpose\": \"Right-hand side ZoneVector\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the ZoneVectors are not equal, false otherwise\"\n            },\n            \"dependencies\": [\n                \"operator==\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nbool operator!=(const ZoneVector<T>& lhs, const ZoneVector<T>& rhs) {\n  return !(lhs == rhs);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<\",\n            \"about\": \"Less-than operator for ZoneVector\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const ZoneVector<T>&\",\n                    \"purpose\": \"Left-hand side ZoneVector\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const ZoneVector<T>&\",\n                    \"purpose\": \"Right-hand side ZoneVector\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the left-hand side is lexicographically less than the right-hand side, false otherwise\"\n            },\n            \"dependencies\": [\n                \"std::lexicographical_compare\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nbool operator<(const ZoneVector<T>& lhs, const ZoneVector<T>& rhs) {\n  return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(),\n                                      rhs.end());\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneIntrusiveSet\",\n            \"about\": \"A zone-allocated intrusive set, based on base::IntrusiveSet, that uses a ZoneVector for storage.\",\n            \"extends\": \"base::IntrusiveSet\",\n            \"dependencies\": [\n                \"base::IntrusiveSet\",\n                \"ZoneVector\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, class GetIntrusiveSetIndex>\nclass ZoneIntrusiveSet\n    : public base::IntrusiveSet<T, GetIntrusiveSetIndex, ZoneVector<T>> {\n public:\n  explicit ZoneIntrusiveSet(Zone* zone, GetIntrusiveSetIndex index_functor = {})\n      : base::IntrusiveSet<T, GetIntrusiveSetIndex, ZoneVector<T>>(\n            ZoneVector<T>(zone), std::move(index_functor)) {}\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneDeque\",\n            \"about\": \"A zone-allocated deque, based on std::deque, that uses RecyclingZoneAllocator for memory management.\",\n            \"extends\": \"std::deque\",\n            \"dependencies\": [\n                \"std::deque\",\n                \"RecyclingZoneAllocator\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass ZoneDeque : public std::deque<T, RecyclingZoneAllocator<T>> {\n public:\n  // Constructs an empty deque.\n  explicit ZoneDeque(Zone* zone)\n      : std::deque<T, RecyclingZoneAllocator<T>>(\n            RecyclingZoneAllocator<T>(zone)) {}\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneLinkedList\",\n            \"about\": \"A zone-allocated linked list, based on std::list, that uses ZoneAllocator for memory management.\",\n            \"extends\": \"std::list\",\n            \"dependencies\": [\n                \"std::list\",\n                \"ZoneAllocator\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass ZoneLinkedList : public std::list<T, ZoneAllocator<T>> {\n public:\n  // Constructs an empty list.\n  explicit ZoneLinkedList(Zone* zone)\n      : std::list<T, ZoneAllocator<T>>(ZoneAllocator<T>(zone)) {}\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneForwardList\",\n            \"about\": \"A zone-allocated forward list, based on std::forward_list, that uses ZoneAllocator for memory management.\",\n            \"extends\": \"std::forward_list\",\n            \"dependencies\": [\n                \"std::forward_list\",\n                \"ZoneAllocator\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass ZoneForwardList : public std::forward_list<T, ZoneAllocator<T>>"
}