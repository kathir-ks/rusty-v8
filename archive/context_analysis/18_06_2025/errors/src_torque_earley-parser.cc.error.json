{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/earley-parser.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/earley-parser.cc\",\n            \"file_name\": \"earley-parser.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implementation of Earley's parsing algorithm for the Torque language.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and Torque-specific headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/earley-parser.h\"\n\n#include <algorithm>\n#include <optional>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include \"src/torque/ast.h\"\n#include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"LineAndColumnTracker\",\n                \"about\": \"Tracks line and column information during lexing.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"previous\",\n                        \"type\": \"LineAndColumn\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the previous line and column information.\"\n                    },\n                    {\n                        \"name\": \"current\",\n                        \"type\": \"LineAndColumn\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the current line and column information.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"LineAndColumn\",\n                    \"SourcePosition\",\n                    \"CurrentSourceFile\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct LineAndColumnTracker {\n  LineAndColumn previous{0, 0, 0};\n  LineAndColumn current{0, 0, 0};\n\n  void Advance(InputPosition from, InputPosition to);\n\n  SourcePosition ToSourcePosition();\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Advance\",\n                \"parent\": \"LineAndColumnTracker\",\n                \"about\": \"Advances the line and column tracker based on input positions.\",\n                \"logic\": \"Calculates the distance between two InputPositions, updates line and column numbers accordingly by iterating through the characters between 'from' and 'to'.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"from\",\n                        \"type\": \"InputPosition\",\n                        \"purpose\": \"The starting InputPosition.\"\n                    },\n                    {\n                        \"name\": \"to\",\n                        \"type\": \"InputPosition\",\n                        \"purpose\": \"The ending InputPosition.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"InputPosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void LineAndColumnTracker::Advance(InputPosition from, InputPosition to) {\n    previous = current;\n    current.offset += std::distance(from, to);\n    while (from != to) {\n      if (*from == '\\n') {\n        current.line += 1;\n        current.column = 0;\n      } else {\n        current.column += 1;\n      }\n      ++from;\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ToSourcePosition\",\n                \"parent\": \"LineAndColumnTracker\",\n                \"about\": \"Converts the tracked line and column information to a SourcePosition.\",\n                \"logic\": \"Creates a SourcePosition object using the current file and the previous and current line/column information.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"SourcePosition\",\n                    \"description\": \"A SourcePosition object representing the current position in the source file.\"\n                },\n                \"dependencies\": [\n                    \"SourcePosition\",\n                    \"CurrentSourceFile\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  SourcePosition LineAndColumnTracker::ToSourcePosition() {\n    return {CurrentSourceFile::Get(), previous, current};\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RunAction\",\n                \"parent\": \"Rule\",\n                \"about\": \"Executes the parse action associated with a rule.\",\n                \"logic\": \"Collects parse results from child items, creates a ParseResultIterator, executes the action function with the iterator, and ensures all child results are consumed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"completed_item\",\n                        \"type\": \"const Item*\",\n                        \"purpose\": \"The completed item.\"\n                    },\n                    {\n                        \"name\": \"tokens\",\n                        \"type\": \"const LexerResult&\",\n                        \"purpose\": \"The lexer results.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The result of the parse action, if successful.\"\n                },\n                \"dependencies\": [\n                    \"Item\",\n                    \"LexerResult\",\n                    \"ParseResult\",\n                    \"ParseResultIterator\",\n                    \"MatchedInput\",\n                    \"CurrentSourcePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> Rule::RunAction(const Item* completed_item,\n                                           const LexerResult& tokens) const {\n  std::vector<ParseResult> results;\n  for (const Item* child : completed_item->Children()) {\n    if (!child) continue;\n    std::optional<ParseResult> child_result =\n        child->left()->RunAction(child, tokens);\n    if (child_result) results.push_back(std::move(*child_result));\n  }\n  MatchedInput matched_input = completed_item->GetMatchedInput(tokens);\n  CurrentSourcePosition::Scope pos_scope(matched_input.pos);\n  ParseResultIterator iterator(std::move(results), matched_input);\n  auto result = action_(&iterator);\n  // Make sure the parse action consumed all the child results.\n  CHECK(!iterator.HasNext());\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"operator=\",\n                \"parent\": \"Symbol\",\n                \"about\": \"Assigns a set of rules to a symbol.\",\n                \"logic\": \"Clears the existing rules and adds the new rules from the initializer list.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"rules\",\n                        \"type\": \"std::initializer_list<Rule>\",\n                        \"purpose\": \"The list of rules to assign.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Symbol&\",\n                    \"description\": \"A reference to the symbol.\"\n                },\n                \"dependencies\": [\n                    \"Rule\",\n                    \"Symbol\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSymbol& Symbol::operator=(std::initializer_list<Rule> rules) {\n  rules_.clear();\n  for (const Rule& rule : rules) {\n    AddRule(rule);\n  }\n  return *this;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Children\",\n                \"parent\": \"Item\",\n                \"about\": \"Gets the child items of a completed item.\",\n                \"logic\": \"Traverses the linked list of items to collect the children, reverses the order, and checks if the number of children matches the rule size.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"std::vector<const Item*>\",\n                    \"description\": \"A vector of pointers to the child items.\"\n                },\n                \"dependencies\": [\n                    \"Item\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::vector<const Item*> Item::Children() const {\n  std::vector<const Item*> children;\n  for (const Item* current = this; current->prev_; current = current->prev_) {\n    children.push_back(current->child_);\n  }\n  // The above loop collects the child nodes in reversed order.\n  std::reverse(children.begin(), children.end());\n  DCHECK_EQ(children.size(), right().size());\n  return children;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SplitByChildren\",\n                \"parent\": \"Item\",\n                \"about\": \"Returns a string representation of the item's children.\",\n                \"logic\": \"Recursively calls SplitByChildren on the first child if there's only one child, otherwise concatenates the matched input of each child with spaces.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"tokens\",\n                        \"type\": \"const LexerResult&\",\n                        \"purpose\": \"The lexer results.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"A string representation of the item's children.\"\n                },\n                \"dependencies\": [\n                    \"LexerResult\",\n                    \"Item\",\n                    \"MatchedInput\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::string Item::SplitByChildren(const LexerResult& tokens) const {\n  if (right().size() == 1) {\n    if (const Item* child = Children()[0])\n      return child->SplitByChildren(tokens);\n  }\n  std::stringstream s;\n  bool first = true;\n  for (const Item* item : Children()) {\n    if (!item) continue;\n    if (!first) s << \"  \";\n    s << item->GetMatchedInput(tokens).ToString();\n    first = false;\n  }\n  return s.str();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CheckAmbiguity\",\n                \"parent\": \"Item\",\n                \"about\": \"Checks for ambiguity in the grammar.\",\n                \"logic\": \"Compares the children and previous items of two identical items. If they differ, it reports an error with a detailed description of the ambiguity.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"other\",\n                        \"type\": \"const Item&\",\n                        \"purpose\": \"The other item to compare with.\"\n                    },\n                    {\n                        \"name\": \"tokens\",\n                        \"type\": \"const LexerResult&\",\n                        \"purpose\": \"The lexer results.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Item\",\n                    \"LexerResult\",\n                    \"ReportError\",\n                    \"MatchedInput\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Item::CheckAmbiguity(const Item& other, const LexerResult& tokens) const {\n  DCHECK(*this == other);\n  if (child_ != other.child_) {\n    std::stringstream s;\n    s << \"Ambiguous grammer rules for \\\"\"\n      << child_->GetMatchedInput(tokens).ToString() << \"\\\":\\n   \"\n      << child_->SplitByChildren(tokens) << \"\\nvs\\n   \"\n      << other.child_->SplitByChildren(tokens);\n    ReportError(s.str());\n  }\n  if (prev_ != other.prev_) {\n    std::stringstream s;\n    s << \"Ambiguous grammer rules for \\\"\" << GetMatchedInput(tokens).ToString()\n      << \"\\\":\\n   \" << SplitByChildren(tokens) << \"  ...\\nvs\\n   \"\n      << other.SplitByChildren(tokens) << \"  ...\";\n    ReportError(s.str());\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RunLexer\",\n                \"parent\": \"Lexer\",\n                \"about\": \"Runs the lexer on the input string.\",\n                \"logic\": \"Iterates through the input, matching tokens and whitespace, and storing the results in a LexerResult object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"input\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The input string to lex.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"LexerResult\",\n                    \"description\": \"The result of the lexing process.\"\n                },\n                \"dependencies\": [\n                    \"LexerResult\",\n                    \"InputPosition\",\n                    \"LineAndColumnTracker\",\n                    \"Symbol\",\n                    \"CurrentSourcePosition\",\n                    \"ReportError\",\n                    \"StringLiteralQuote\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nLexerResult Lexer::RunLexer(const std::string& input) {\n  LexerResult result;\n  InputPosition const begin = input.c_str();\n  InputPosition const end = begin + input.size();\n  InputPosition pos = begin;\n  InputPosition token_start = pos;\n  LineAndColumnTracker line_column_tracker;\n\n  match_whitespace_(&pos);\n  line_column_tracker.Advance(token_start, pos);\n  while (pos != end) {\n    token_start = pos;\n    Symbol* symbol = MatchToken(&pos, end);\n    DCHECK_IMPLIES(symbol != nullptr, pos != token_start);\n    InputPosition token_end = pos;\n    line_column_tracker.Advance(token_start, token_end);\n    if (!symbol) {\n      CurrentSourcePosition::Scope pos_scope(\n          line_column_tracker.ToSourcePosition());\n      ReportError(\"Lexer Error: unknown token \" +\n                  StringLiteralQuote(std::string(\n                      token_start, token_start + std::min<ptrdiff_t>(\n                                                     end - token_start, 10))));\n    }\n    result.token_symbols.push_back(symbol);\n    result.token_contents.push_back(\n        {token_start, pos, line_column_tracker.ToSourcePosition()});\n    match_whitespace_(&pos);\n    line_column_tracker.Advance(token_end, pos);\n  }\n\n  // Add an additional token position to simplify corner cases.\n  line_column_tracker.Advance(token_start, pos);\n  result.token_contents.push_back(\n      {pos, pos, line_column_tracker.ToSourcePosition()});\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MatchToken\",\n                \"parent\": \"Lexer\",\n                \"about\": \"Matches the longest possible token at the current position.\",\n                \"logic\": \"Iterates through the patterns and keywords, finding the longest match.  Prioritizes keywords if they match the same length as or longer than any pattern.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"InputPosition*\",\n                        \"purpose\": \"The current input position.\"\n                    },\n                    {\n                        \"name\": \"end\",\n                        \"type\": \"InputPosition\",\n                        \"purpose\": \"The end of the input.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Symbol*\",\n                    \"description\": \"A pointer to the matched symbol, or nullptr if no token is matched.\"\n                },\n                \"dependencies\": [\n                    \"InputPosition\",\n                    \"Symbol\",\n                    \"PatternFunction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSymbol* Lexer::MatchToken(InputPosition* pos, InputPosition end) {\n  InputPosition token_start = *pos;\n  Symbol* symbol = nullptr;\n  // Find longest matching pattern.\n  for (std::pair<const PatternFunction, Symbol>& pair : patterns_) {\n    InputPosition token_end = token_start;\n    PatternFunction matchPattern = pair.first;\n    if (matchPattern(&token_end) && token_end > *pos) {\n      *pos = token_end;\n      symbol = &pair.second;\n    }\n  }\n  size_t pattern_size = *pos - token_start;\n\n  // Now check for keywords. Prefer keywords over patterns unless the pattern is\n  // longer. Iterate from the end to ensure that if one keyword is a prefix of\n  // another, we first try to match the longer one.\n  for (auto it = keywords_.rbegin(); it != keywords_.rend(); ++it) {\n    const std::string& keyword = it->first;\n    if (static_cast<size_t>(end - token_start) < keyword.size()) continue;\n    if (keyword.size() >= pattern_size &&\n        keyword == std::string(token_start, token_start + keyword.size())) {\n      *pos = token_start + keyword.size();\n      return &it->second;\n    }\n  }\n  if (pattern_size > 0) return symbol;\n  return nullptr;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RunEarleyAlgorithm\",\n                \"about\": \"Runs Earley's parsing algorithm.\",\n                \"logic\": \"Implements Earley's algorithm using worklists for items at the current and next positions.  It handles 'Predict', 'Scan', and 'Complete' phases.  It manages a processed item set to avoid infinite loops.  It detects parse errors, reporting unexpected tokens or end of input.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"start\",\n                        \"type\": \"Symbol*\",\n                        \"purpose\": \"The start symbol of the grammar.\"\n                    },\n                    {\n                        \"name\": \"tokens\",\n                        \"type\": \"const LexerResult&\",\n                        \"purpose\": \"The lexer results.\"\n                    },\n                    {\n                        \"name\": \"processed\",\n                        \"type\": \"std::unordered_set<Item, base::hash<Item>>*\",\n                        \"purpose\": \"A set to track processed items and prevent infinite loops.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const Item*\",\n                    \"description\": \"A pointer to the root of the parse tree, or nullptr if parsing fails.\"\n                },\n                \"dependencies\": [\n                    \"Symbol\",\n                    \"LexerResult\",\n                    \"Item\",\n                    \"Rule\",\n                    \"CurrentSourcePosition\",\n                    \"ReportError\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconst Item* RunEarleyAlgorithm(\n    Symbol* start, const LexerResult& tokens,\n    std::unordered_set<Item, base::hash<Item>>* processed) {\n  // Worklist for items at the current position.\n  std::vector<Item> worklist;\n  // Worklist for items at the next position.\n  std::vector<Item> future_items;\n  CurrentSourcePosition::Scope source_position(\n      SourcePosition{CurrentSourceFile::Get(), LineAndColumn::Invalid(),\n                     LineAndColumn::Invalid()});\n  std::vector<const Item*> completed_items;\n  std::unordered_map<std::pair<size_t, Symbol*>, std::set<const Item*>,\n                     base::hash<std::pair<size_t, Symbol*>>>\n      waiting;\n\n  std::vector<const Item*> debug_trace;\n\n  // Start with one top_level symbol mapping to the start symbol of the grammar.\n  // This simplifies things because the start symbol might have several\n  // rules.\n  Symbol top_level;\n  top_level.AddRule(Rule({start}));\n  worklist.push_back(Item{top_level.rule(0), 0, 0, 0});\n\n  size_t input_length = tokens.token_symbols.size();\n\n  for (size_t pos = 0; pos <= input_length; ++pos) {\n    while (!worklist.empty()) {\n      auto insert_result = processed->insert(worklist.back());\n      const Item& item = *insert_result.first;\n      DCHECK_EQ(pos, item.pos());\n      MatchedInput last_token = tokens.token_contents[pos];\n      CurrentSourcePosition::Get() = last_token.pos;\n      bool is_new = insert_result.second;\n      if (!is_new) item.CheckAmbiguity(worklist.back(), tokens);\n      worklist.pop_back();\n      if (!is_new) continue;\n\n      debug_trace.push_back(&item);\n      if (item.IsComplete()) {\n        // 'Complete' phase: Advance all items that were waiting to match this\n        // symbol next.\n        for (const Item* parent : waiting[{item.start(), item.left()}]) {\n          worklist.push_back(parent->Advance(pos, &item));\n        }\n      } else {\n        Symbol* next = item.NextSymbol();\n        // 'Scan' phase: Check if {next} is the next symbol in the input (this\n        // is never the case if {next} is a non-terminal).\n        if (pos < tokens.token_symbols.size() &&\n            tokens.token_symbols[pos] == next) {\n          future_items.push_back(item.Advance(pos + 1, nullptr));\n        }\n        // 'Predict' phase: Add items for every rule of the non-terminal.\n        if (!next->IsTerminal()) {\n          // Remember that this item is waiting for completion with {next}.\n          waiting[{pos, next}].insert(&item);\n        }\n        for (size_t i = 0; i < next->rule_number(); ++i) {\n          Rule* rule = next->rule(i);\n          auto already_completed =\n              processed->find(Item{rule, rule->right().size(), pos, pos});\n          // As discussed in section 3 of\n          //    Aycock, John, and R. Nigel Horspool. \"Practical earley\n          //    parsing.\" The Computer Journal 45.6 (2002): 620-630.\n          // Earley parsing has the following problem with epsilon rules:\n          // When we complete an item that started at the current position\n          // (that is, it matched zero tokens), we might not yet have\n          // predicted all items it can complete with. Thus we check for the\n          // existence of such items here and complete them immediately.\n          if (already_completed != processed->end()) {\n            worklist.push_back(item.Advance(pos, &*already_completed));\n          } else {\n            worklist.push_back(Item{rule, 0, pos, pos});\n          }\n        }\n      }\n    }\n    std::swap(worklist, future_items);\n  }\n\n  auto final_item =\n      processed->find(Item{top_level.rule(0), 1, 0, input_length});\n  if (final_item != processed->end()) {\n    // Success: The {top_level} rule matches the complete input.\n    return final_item->Children()[0];\n  }\n  std::string reason;\n  const Item& last_item = *debug_trace.back();\n  if (last_item.pos() < tokens.token_symbols.size()) {\n    std::string next_token = tokens.token_contents[last_item.pos()].ToString();\n    reason = \"unexpected token \\\"\" + next_token + \"\\\"\";\n  } else {\n    reason = \"unexpected end of input\";\n  }\n  ReportError(\"Parser Error: \" + reason);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MatchChar\",\n                \"parent\": \"Grammar\",\n                \"about\": \"Matches a character based on a character class function.\",\n                \"logic\": \"Checks if the current character matches the character class. If it matches, advances the input position.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"char_class\",\n                        \"type\": \"int (*)(int)\",\n                        \"purpose\": \"A function that determines if a character belongs to a character class.\"\n                    },\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"InputPosition*\",\n                        \"purpose\": \"A pointer to the current input position.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the character matches, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"InputPosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDISABLE_CFI_ICALL\nbool Grammar::MatchChar(int (*char_class)(int), InputPosition* pos) {\n  if (**pos && char_class(static_cast<unsigned char>(**pos))) {\n    ++*pos;\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MatchChar\",\n                \"parent\": \"Grammar\",\n                \"about\": \"Matches a character based on a character class function.\",\n                \"logic\": \"Checks if the current character matches the character class. If it matches, advances the input position.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"char_class\",\n                        \"type\": \"bool (*)(char)\",\n                        \"purpose\": \"A function that determines if a character belongs to a character class.\"\n                    },\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"InputPosition*\",\n                        \"purpose\": \"A pointer to the current input position.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the character matches, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"InputPosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Grammar::MatchChar(bool (*char_class)(char), InputPosition* pos) {\n  if (**pos && char_class(**pos)) {\n    ++*pos;\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MatchString\",\n                \"parent\": \"Grammar\",\n                \"about\": \"Matches a string at the current input position.\",\n                \"logic\": \"Compares the input string with the given string. If they match, advances the input position.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"s\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The string to match.\"\n                    },\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"InputPosition*\",\n                        \"purpose\": \"A pointer to the current input position.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the string matches, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"InputPosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Grammar::MatchString(const char* s, InputPosition* pos) {\n  InputPosition current = *pos;\n  for (; *s != 0; ++s, ++current) {\n    if (*s != *current) return false;\n  }\n  *pos = current;\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MatchAnyChar\",\n                \"parent\": \"Grammar\",\n                \"about\": \"Matches any character at the current input position.\",\n                \"logic\": \"Always returns true and advances the input position.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"InputPosition*\",\n                        \"purpose\": \"A pointer to the current input position.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"Always true.\"\n                },\n                \"dependencies\": [\n                    \"InputPosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Grammar::MatchAnyChar(InputPosition* pos) {\n  return MatchChar([](char c) { return true; }, pos);\n}\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Rule\",\n                    \"about\": \"Represents a grammar rule.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Rule {\n public:\n  std::optional<ParseResult> RunAction(const Item* completed_item,\n                                           const LexerResult& tokens) const;\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Symbol\",\n                    \"about\": \"Represents a symbol in the grammar.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Symbol {\n public:\n  Symbol& operator=(std::initializer_list<Rule> rules);\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Item\",\n                    \"about\": \"Represents an item in the Earley parser.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Item {\n public:\n  std::vector<const Item*> Children() const;\n  std::string SplitByChildren(const LexerResult& tokens) const;\n  void CheckAmbiguity(const Item& other, const LexerResult& tokens) const;\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Lexer\",\n                    \"about\": \"The lexer for the Torque language.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Lexer {\n public:\n  LexerResult RunLexer(const std::string& input);\n  Symbol* MatchToken(InputPosition* pos, InputPosition end);\n private:\n  void match_whitespace_(InputPosition* pos) {}\n  std::vector<std::pair<const PatternFunction, Symbol>> patterns_;\n  std::unordered_map<std::string, Symbol> keywords_;\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Grammar\",\n                    \"about\": \"Base class for grammars.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Grammar {\n public:\n  static bool MatchChar(int (*char_class)(int), InputPosition* pos);\n  static bool MatchChar(bool (*char_class)(char), InputPosition* pos);\n  static bool MatchString(const char* s, InputPosition* pos);\n  static bool MatchAnyChar(InputPosition* pos);\n};\n            ]]></code>\n        </class>\n        <typedef>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"typedef\",\n                    \"name\": \"InputPosition\",\n                    \"about\": \"Represents a position in the input string.\"\n                }\n            </metadata>\n            <code><![CDATA[\ntypedef const char* InputPosition;\n            ]]></code>\n        </typedef>\n        <typedef>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"typedef\",\n                    \"name\": \"PatternFunction\",\n                    \"about\": \"Represents a function that matches a pattern in the input.\"\n                }\n            </metadata>\n            <code><![CDATA[\ntypedef bool (*PatternFunction)(InputPosition*);\n            ]]></code>\n        </typedef>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"LexerResult\",\n                    \"about\": \"Holds the result of lexing.\"\n                }\n            </metadata>\n            <code><![CDATA[\nstruct LexerResult {\n  std::vector<Symbol*> token_symbols;\n  std::vector<MatchedInput> token_contents;\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"MatchedInput\",\n                    \"about\": \"Holds the matched input and source position.\"\n                }\n            </metadata>\n            <code><![CDATA[\nstruct MatchedInput {\n  InputPosition begin;\n  InputPosition end;\n  SourcePosition pos;\n  std::string ToString() const { return std::string(begin, end); }\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"SourcePosition\",\n                    \"about\": \"Represents a position in the source file.\"\n                }\n            </metadata>\n            <code><![CDATA[\nstruct SourcePosition {\n  const std::string* file;\n  LineAndColumn start;\n  LineAndColumn end;\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"LineAndColumn"
}