{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/machine-lowering-reducer-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/machine-lowering-reducer-inl.h\",\n        \"file_name\": \"machine-lowering-reducer-inl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Inline header file for the MachineLoweringReducer, which lowers simplified operations to machine operations in the Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8 specific headers required for the implementation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <optional>\n\n            #include \"src/base/logging.h\"\n            #include \"src/codegen/external-reference.h\"\n            #include \"src/codegen/machine-type.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/compiler/access-builder.h\"\n            #include \"src/compiler/compilation-dependencies.h\"\n            #include \"src/compiler/feedback-source.h\"\n            #include \"src/compiler/globals.h\"\n            #include \"src/compiler/linkage.h\"\n            #include \"src/compiler/operator.h\"\n            #include \"src/compiler/simplified-operator.h\"\n            #include \"src/compiler/turboshaft/assembler.h\"\n            #include \"src/compiler/turboshaft/copying-phase.h\"\n            #include \"src/compiler/turboshaft/index.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/opmasks.h\"\n            #include \"src/compiler/turboshaft/phase.h\"\n            #include \"src/compiler/turboshaft/reducer-traits.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n            #include \"src/compiler/write-barrier-kind.h\"\n            #include \"src/deoptimizer/deoptimize-reason.h\"\n            #include \"src/execution/frame-constants.h\"\n            #include \"src/objects/bigint.h\"\n            #include \"src/objects/heap-number.h\"\n            #include \"src/objects/instance-type-checker.h\"\n            #include \"src/objects/instance-type-inl.h\"\n            #include \"src/objects/instance-type.h\"\n            #include \"src/objects/oddball.h\"\n            #include \"src/objects/string-inl.h\"\n            #include \"src/runtime/runtime.h\"\n            #include \"src/utils/utils.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MachineLoweringReducer\",\n            \"extends\": \"Next\",\n            \"about\": \"Reduces simplified operations to machine-specific operations within the Turboshaft compiler pipeline.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Next\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename Next>\n            class MachineLoweringReducer : public Next {\n            public:\n              TURBOSHAFT_REDUCER_BOILERPLATE(MachineLowering)\n\n              bool NeedsHeapObjectCheck(ObjectIsOp::InputAssumptions input_assumptions) {\n                // TODO(nicohartmann@): Consider type information once we have that.\n                switch (input_assumptions) {\n                  case ObjectIsOp::InputAssumptions::kNone:\n                    return true;\n                  case ObjectIsOp::InputAssumptions::kHeapObject:\n                  case ObjectIsOp::InputAssumptions::kBigInt:\n                    return false;\n                }\n              }\n            \n              V<Word32> REDUCE(Word32SignHint)(V<Word32> input, Word32SignHintOp::Sign);\n            \n              V<Untagged> REDUCE(ChangeOrDeopt)(V<Untagged> input,\n                                                    V<FrameState> frame_state,\n                                                    ChangeOrDeoptOp::Kind kind,\n                                                    CheckForMinusZeroMode minus_zero_mode,\n                                                    const FeedbackSource& feedback);\n            \n              V<None> REDUCE(DeoptimizeIf)(V<Word32> condition, V<FrameState> frame_state,\n                                           bool negated,\n                                           const DeoptimizeParameters* parameters);\n            \n              V<Word32> REDUCE(ObjectIs)(V<Object> input, ObjectIsOp::Kind kind,\n                                         ObjectIsOp::InputAssumptions input_assumptions);\n            \n              V<Word32> REDUCE(Float64Is)(V<Float64> value, NumericKind kind);\n            \n              V<Word32> REDUCE(ObjectIsNumericValue)(V<Object> input, NumericKind kind,\n                                               FloatRepresentation input_rep);\n            \n              V<Object> REDUCE(Convert)(V<Object> input, ConvertOp::Kind from,\n                                        ConvertOp::Kind to);\n            \n              V<JSPrimitive> REDUCE(ConvertUntaggedToJSPrimitive)(\n                  V<Untagged> input, ConvertUntaggedToJSPrimitiveOp::JSPrimitiveKind kind,\n                  RegisterRepresentation input_rep,\n                  ConvertUntaggedToJSPrimitiveOp::InputInterpretation input_interpretation,\n                  CheckForMinusZeroMode minus_zero_mode);\n            \n              V<JSPrimitive> REDUCE(ConvertUntaggedToJSPrimitiveOrDeopt)(\n                  V<Untagged> input, V<FrameState> frame_state,\n                  ConvertUntaggedToJSPrimitiveOrDeoptOp::JSPrimitiveKind kind,\n                  RegisterRepresentation input_rep,\n                  ConvertUntaggedToJSPrimitiveOrDeoptOp::InputInterpretation\n                      input_interpretation,\n                  const FeedbackSource& feedback);\n            \n              V<Untagged> REDUCE(ConvertJSPrimitiveToUntagged)(\n                  V<JSPrimitive> object, ConvertJSPrimitiveToUntaggedOp::UntaggedKind kind,\n                  ConvertJSPrimitiveToUntaggedOp::InputAssumptions input_assumptions);\n            \n              V<Untagged> REDUCE(ConvertJSPrimitiveToUntaggedOrDeopt)(\n                  V<Object> object, V<FrameState> frame_state,\n                  ConvertJSPrimitiveToUntaggedOrDeoptOp::JSPrimitiveKind from_kind,\n                  ConvertJSPrimitiveToUntaggedOrDeoptOp::UntaggedKind to_kind,\n                  CheckForMinusZeroMode minus_zero_mode, const FeedbackSource& feedback);\n            \n              V<Word> REDUCE(TruncateJSPrimitiveToUntagged)(\n                  V<JSPrimitive> object, TruncateJSPrimitiveToUntaggedOp::UntaggedKind kind,\n                  TruncateJSPrimitiveToUntaggedOp::InputAssumptions input_assumptions);\n            \n              V<Word> REDUCE(TruncateJSPrimitiveToUntaggedOrDeopt)(\n                  V<JSPrimitive> input, V<FrameState> frame_state,\n                  TruncateJSPrimitiveToUntaggedOrDeoptOp::UntaggedKind kind,\n                  TruncateJSPrimitiveToUntaggedOrDeoptOp::InputRequirement\n                      input_requirement,\n                  const FeedbackSource& feedback);\n            \n              V<Word32> JSAnyIsNotPrimitiveHeapObject(\n                  V<Object> value, V<Map> value_map = V<Map>::Invalid());\n            \n              V<Object> REDUCE(ConvertJSPrimitiveToObject)(V<JSPrimitive> value,\n                                                       V<Context> native_context,\n                                                       V<JSGlobalProxy> global_proxy,\n                                                       ConvertReceiverMode mode);\n            \n              enum class StringEncoding { kOneByte, kTwoByte, kUnknown };\n              StringEncoding GetStringEncoding(V<String> string);\n            \n              V<ConsString> REDUCE(NewConsString)(V<Word32> length, V<String> first,\n                                                V<String> second);\n            \n              V<AnyFixedArray> REDUCE(NewArray)(V<WordPtr> length, NewArrayOp::Kind kind,\n                                              AllocationType allocation_type);\n            \n              V<Number> REDUCE(DoubleArrayMinMax)(V<JSArray> array,\n                                                DoubleArrayMinMaxOp::Kind kind);\n            \n              V<Object> REDUCE(LoadFieldByIndex)(V<Object> object, V<Word32> field_index);\n            \n              V<Word> REDUCE(WordBinopDeoptOnOverflow)(\n                  V<Word> left, V<Word> right, V<FrameState> frame_state,\n                  WordBinopDeoptOnOverflowOp::Kind kind, WordRepresentation rep,\n                  FeedbackSource feedback, CheckForMinusZeroMode mode);\n            \n              V<BigInt> REDUCE(BigIntBinop)(V<BigInt> left, V<BigInt> right,\n                                          V<FrameState> frame_state,\n                                          BigIntBinopOp::Kind kind);\n            \n              V<Boolean> REDUCE(BigIntComparison)(V<BigInt> left, V<BigInt> right,\n                                                BigIntComparisonOp::Kind kind);\n            \n              V<BigInt> REDUCE(BigIntUnary)(V<BigInt> input, BigIntUnaryOp::Kind kind);\n            \n              V<Word32> REDUCE(StringAt)(V<String> string, V<WordPtr> pos,\n                                     StringAtOp::Kind kind);\n            \n              V<Word32> REDUCE(StringLength)(V<String> string);\n            \n              V<WordPtr> REDUCE(TypedArrayLength)(V<JSTypedArray> typed_array,\n                                          ElementSizeKind element_size_kind);\n            \n              V<Word> REDUCE(TypedArrayElementSize)(ElementSizeKind element_size_kind);\n            \n              V<Object> REDUCE(LoadTypedArrayElement)(V<JSTypedArray> typed_array,\n                                                   V<WordPtr> index,\n                                                   ExternalArrayMode array_mode,\n                                                   MachineType element_type,\n                                                   ElementSizeKind element_size_kind);\n            \n              V<Object> REDUCE(StoreTypedArrayElement)(V<JSTypedArray> typed_array,\n                                                    V<WordPtr> index, V<Word> value,\n                                                    ExternalArrayMode array_mode,\n                                                    MachineType element_type,\n                                                    ElementSizeKind element_size_kind);\n            \n              V<Object> REDUCE(TransitionElementsKind)(\n                  V<JSObject> object, V<Map> old_elements_map,\n                  ElementsKind old_elements_kind, V<Map> new_elements_map,\n                  ElementsKind new_elements_kind);\n            \n              V<Map> REDUCE(GetElementsKindMap)(ElementsKind elements_kind);\n            \n            private:\n              V<JSPrimitive> TagSmiOrOverflow(V<Word32> input, Label<>* overflow,\n                                               Label<Number>* done);\n            \n              OpIndex CallBuiltinForBigIntOp(Builtin builtin,\n                                              std::initializer_list<OpIndex> args);\n              Builtin GetBuiltinForBigIntBinop(BigIntBinopOp::Kind kind);\n              OpIndex StringFromSingleCharCode(V<Word32> char_code);\n              OpIndex StringFromSingleCodePoint(V<Word32> code_point,\n                                                UnicodeEncoding encoding);\n              V<Word32> BuildUint32Mod(V<Word32> left, V<Word32> right);\n              OpIndex AllocateBigInt(V<Word32> bitfield, V<Word64> lsd);\n              OpIndex AllocateHeapNumber(V<Float64> value);\n              V<Float64> ConvertHeapObjectToFloat64OrDeopt(\n                  V<Object> input, V<FrameState> frame_state,\n                  ConvertJSPrimitiveToUntaggedOrDeoptOp::JSPrimitiveKind from_kind,\n                  const FeedbackSource& feedback);\n              V<Float64> ConvertHeapObjectToFloat64OrDeopt(\n                  V<Object> input, V<FrameState> frame_state,\n                  TruncateJSPrimitiveToUntaggedOrDeoptOp::InputRequirement requirement,\n                  const FeedbackSource& feedback);\n              V<Word32> LoadFromSeqString(V<String> string, V<WordPtr> pos,\n                                         V<Word32> is_one_byte);\n              V<Word32> LoadSurrogatePairAt(V<String> string,\n                                            const std::optional<OpIndex>& maybe_check,\n                                            V<WordPtr> pos, UnicodeEncoding encoding);\n            \n              const FeedbackSource& MakeSource(OpIndex op) {\n                return Next::MakeSource(op);\n              }\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NeedsHeapObjectCheck\",\n            \"parent\": \"MachineLoweringReducer\",\n            \"about\": \"Determines if a heap object check is needed based on the input assumptions of an ObjectIs operation.\",\n            \"logic\": \"Based on the input assumptions (kNone, kHeapObject, kBigInt), decides whether or not to perform a heap object check. Returns true if a check is needed (kNone), false otherwise.\",\n            \"parameters\": [\n                {\n                    \"name\": \"input_assumptions\",\n                    \"type\": \"ObjectIsOp::InputAssumptions\",\n                    \"purpose\": \"Specifies the assumptions about the type of the input to the ObjectIs operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a heap object check is needed, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool NeedsHeapObjectCheck(ObjectIsOp::InputAssumptions input_assumptions) {\n              // TODO(nicohartmann@): Consider type information once we have that.\n              switch (input_assumptions) {\n                case ObjectIsOp::InputAssumptions::kNone:\n                  return true;\n                case ObjectIsOp::InputAssumptions::kHeapObject:\n                case ObjectIsOp::InputAssumptions::kBigInt:\n                  return false;\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(Word32SignHint)\",\n            \"parent\": \"MachineLoweringReducer\",\n            \"about\": \"Reduces the Word32SignHint operation.\",\n            \"logic\": \"Since Int32 and Uint32 are both Word32 from a machine operation perspective, the input is returned directly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"input\",\n                    \"type\": \"V<Word32>\",\n                    \"purpose\": \"The input Word32 value.\"\n                },\n                {\n                    \"name\": \"Sign\",\n                    \"type\": \"Word32SignHintOp::Sign\",\n                    \"purpose\": \"Sign hint\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Word32>\",\n                \"description\": \"The input Word32 value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V<Word32> REDUCE(Word32SignHint)(V<Word32> input, Word32SignHintOp::Sign) {\n              // As far as Machine operations are concerned, Int32 and Uint32 are both\n              // Word32.\n              return input;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(ChangeOrDeopt)\",\n            \"parent\": \"MachineLoweringReducer\",\n            \"about\": \"Reduces the ChangeOrDeopt operation, potentially deoptimizing if a conversion would lose precision.\",\n            \"logic\": \"The function handles various conversions between numeric types, such as Uint32ToInt32, Int64ToInt32, Float64ToInt32, etc.  It performs checks to ensure that the conversions do not result in a loss of precision. If a loss of precision is detected, the function triggers a deoptimization with a specific DeoptimizeReason.\",\n            \"parameters\": [\n                {\n                    \"name\": \"input\",\n                    \"type\": \"V<Untagged>\",\n                    \"purpose\": \"The input value to be converted.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"V<FrameState>\",\n                    \"purpose\": \"The current frame state for deoptimization.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"ChangeOrDeoptOp::Kind\",\n                    \"purpose\": \"Specifies the kind of conversion to perform.\"\n                },\n                {\n                    \"name\": \"minus_zero_mode\",\n                    \"type\": \"CheckForMinusZeroMode\",\n                    \"purpose\": \"Specifies whether or not to check for minus zero.\"\n                },\n                {\n                    \"name\": \"feedback\",\n                    \"type\": \"const FeedbackSource&\",\n                    \"purpose\": \"Feedback source\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Untagged>\",\n                \"description\": \"The converted value, potentially of a different type than the input.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V<Untagged> REDUCE(ChangeOrDeopt)(V<Untagged> input,\n                                              V<FrameState> frame_state,\n                                              ChangeOrDeoptOp::Kind kind,\n                                              CheckForMinusZeroMode minus_zero_mode,\n                                              const FeedbackSource& feedback) {\n              switch (kind) {\n                case ChangeOrDeoptOp::Kind::kUint32ToInt32: {\n                  __ DeoptimizeIf(__ Int32LessThan(V<Word32>::Cast(input), 0),\n                                  frame_state, DeoptimizeReason::kLostPrecision,\n                                  feedback);\n                  return input;\n                }\n                case ChangeOrDeoptOp::Kind::kInt64ToInt32: {\n                  V<Word64> i64_input = V<Word64>::Cast(input);\n                  V<Word32> i32 = __ TruncateWord64ToWord32(i64_input);\n                  __ DeoptimizeIfNot(\n                      __ Word64Equal(__ ChangeInt32ToInt64(i32), i64_input), frame_state,\n                      DeoptimizeReason::kLostPrecision, feedback);\n                  return i32;\n                }\n                case ChangeOrDeoptOp::Kind::kUint64ToInt32: {\n                  V<Word64> i64_input = V<Word64>::Cast(input);\n                  __ DeoptimizeIfNot(\n                      __ Uint64LessThanOrEqual(i64_input, static_cast<uint64_t>(kMaxInt)),\n                      frame_state, DeoptimizeReason::kLostPrecision, feedback);\n                  return __ TruncateWord64ToWord32(i64_input);\n                }\n                case ChangeOrDeoptOp::Kind::kUint64ToInt64: {\n                  __ DeoptimizeIfNot(\n                      __ Uint64LessThanOrEqual(V<Word64>::Cast(input),\n                                               std::numeric_limits<int64_t>::max()),\n                      frame_state, DeoptimizeReason::kLostPrecision, feedback);\n                  return input;\n                }\n                case ChangeOrDeoptOp::Kind::kFloat64ToInt32: {\n                  V<Float64> f64_input = V<Float64>::Cast(input);\n                  V<Word32> i32 = __ TruncateFloat64ToInt32OverflowUndefined(f64_input);\n                  __ DeoptimizeIfNot(\n                      __ Float64Equal(__ ChangeInt32ToFloat64(i32), f64_input),\n                      frame_state, DeoptimizeReason::kLostPrecisionOrNaN, feedback);\n            \n                  if (minus_zero_mode == CheckForMinusZeroMode::kCheckForMinusZero) {\n                    // Check if {value} is -0.\n                    IF (UNLIKELY(__ Word32Equal(i32, 0))) {\n                      // In case of 0, we need to check the high bits for the IEEE -0\n                      // pattern.\n                      V<Word32> check_negative =\n                          __ Int32LessThan(__ Float64ExtractHighWord32(f64_input), 0);\n                      __ DeoptimizeIf(check_negative, frame_state,\n                                      DeoptimizeReason::kMinusZero, feedback);\n                    }\n                  }\n            \n                  return i32;\n                }\n                case ChangeOrDeoptOp::Kind::kFloat64ToUint32: {\n                  V<Float64> f64_input = V<Float64>::Cast(input);\n                  V<Word32> ui32 = __ TruncateFloat64ToUint32OverflowUndefined(f64_input);\n                  __ DeoptimizeIfNot(\n                      __ Float64Equal(__ ChangeUint32ToFloat64(ui32), f64_input),\n                      frame_state, DeoptimizeReason::kLostPrecisionOrNaN, feedback);\n            \n                  if (minus_zero_mode == CheckForMinusZeroMode::kCheckForMinusZero) {\n                    // Check if {value} is -0.\n                    IF (UNLIKELY(__ Word32Equal(ui32, 0))) {\n                      // In case of 0, we need to check the high bits for the IEEE -0\n                      // pattern.\n                      V<Word32> check_negative =\n                          __ Int32LessThan(__ Float64ExtractHighWord32(f64_input), 0);\n                      __ DeoptimizeIf(check_negative, frame_state,\n                                      DeoptimizeReason::kMinusZero, feedback);\n                    }\n                  }\n            \n                  return ui32;\n                }\n                case ChangeOrDeoptOp::Kind::kFloat64ToAdditiveSafeInteger: {\n                  V<Float64> f64_input = V<Float64>::Cast(input);\n                  V<Word64> i64 = __ TruncateFloat64ToInt64OverflowToMin(f64_input);\n                  __ DeoptimizeIfNot(\n                      __ Float64Equal(__ ChangeInt64ToFloat64(i64), f64_input),\n                      frame_state, DeoptimizeReason::kLostPrecisionOrNaN, feedback);\n            \n                  if (minus_zero_mode == CheckForMinusZeroMode::kCheckForMinusZero) {\n                    // Check if {value} is -0.\n                    IF (UNLIKELY(__ Word64Equal(i64, 0))) {\n                      // In case of 0, we need to check the high bits for the IEEE -0\n                      // pattern.\n                      V<Word32> check_negative =\n                          __ Int32LessThan(__ Float64ExtractHighWord32(f64_input), 0);\n                      __ DeoptimizeIf(check_negative, frame_state,\n                                      DeoptimizeReason::kMinusZero, feedback);\n                    }\n                  }\n            \n                  // Check the value actually fits in AdditiveSafeInteger.\n                  // (value - kMinAdditiveSafeInteger) >> 52 == 0.\n                  V<Word32> check_is_zero =\n                      __ Word64Equal(__ Word64ShiftRightArithmetic(\n                                         __ Word64Sub(i64, kMinAdditiveSafeInteger),\n                                         kAdditiveSafeIntegerBitLength),\n                                    0);\n                  __ DeoptimizeIfNot(check_is_zero, frame_state,\n                                     DeoptimizeReason::kNotAdditiveSafeInteger, feedback);\n            \n                  return i64;\n                }\n                case ChangeOrDeoptOp::Kind::kFloat64ToInt64: {\n                  V<Float64> f64_input = V<Float64>::Cast(input);\n                  V<Word64> i64 = __ TruncateFloat64ToInt64OverflowToMin(f64_input);\n                  __ DeoptimizeIfNot(\n                      __ Float64Equal(__ ChangeInt64ToFloat64(i64), f64_input),\n                      frame_state, DeoptimizeReason::kLostPrecisionOrNaN, feedback);\n            \n                  if (minus_zero_mode == CheckForMinusZeroMode::kCheckForMinusZero) {\n                    // Check if {value} is -0.\n                    IF (UNLIKELY(__ Word64Equal(i64, 0))) {\n                      // In case of 0, we need to check the high bits for the IEEE -0\n                      // pattern.\n                      V<Word32> check_negative =\n                          __ Int32LessThan(__ Float64ExtractHighWord32(f64_input), 0);\n                      __ DeoptimizeIf(check_negative, frame_state,\n                                      DeoptimizeReason::kMinusZero, feedback);\n                    }\n                  }\n            \n                  return i64;\n                }\n                case ChangeOrDeoptOp::Kind::kFloat64NotHole: {\n                  V<Float64> f64_input = V<Float64>::Cast(input);\n                  // First check whether {value} is a NaN at all...\n                  IF_NOT (LIKELY(__ Float64Equal(f64_input, f64_input))) {\n                    // ...and only if {value} is a NaN, perform the expensive bit\n                    // check. See http://crbug.com/v8/8264 for details.\n                    __ DeoptimizeIf(__ Word32Equal(__ Float64ExtractHighWord32(f64_input),\n                                                   kHoleNanUpper32),\n                                    frame_state, DeoptimizeReason::kHole, feedback);\n                  }\n            \n                  return input;\n                }\n              }\n              UNREACHABLE();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(DeoptimizeIf)\",\n            \"parent\": \"MachineLoweringReducer\",\n            \"about\": \"Reduces the DeoptimizeIf operation, potentially replacing it with a branch instruction if beneficial.\",\n            \"logic\": \"This function takes a condition and a frame state, and potentially triggers deoptimization if the condition is met. It attempts to optimize by converting `DeoptimizeIf` into a branch if there is a phi node as input to the condition. Otherwise falls through to Next::ReduceDeoptimizeIf.\",\n            \"parameters\": [\n                {\n                    \"name\": \"condition\",\n                    \"type\": \"V<Word32>\",\n                    \"purpose\": \"The condition to check for deoptimization.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"V<FrameState>\",\n                    \"purpose\": \"The current frame state for deoptimization.\"\n                },\n                {\n                    \"name\": \"negated\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the condition should be negated.\"\n                },\n                {\n                    \"name\": \"parameters\",\n                    \"type\": \"const DeoptimizeParameters*\",\n                    \"purpose\": \"Parameters for deoptimization.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<None>\",\n                \"description\": \"Invalid V<None> if the deoptimization is handled directly; otherwise falls through to the next reducer.\"\n            },\n            \"dependencies\": [\n                \"Next::ReduceDeoptimizeIf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V<None> REDUCE(DeoptimizeIf)(V<Word32> condition, V<FrameState> frame_state,\n                                         bool negated,\n                                         const DeoptimizeParameters* parameters) {\n              LABEL_BLOCK(no_change) {\n                return Next::ReduceDeoptimizeIf(condition, frame_state, negated,\n                                                parameters);\n              }\n              if (ShouldSkipOptimizationStep()) goto no_change;\n              // Block cloning only works for branches, but not for `DeoptimizeIf`. On the\n              // other hand, explicit control flow makes the overall pipeline and\n              // especially the register allocator slower. So we only switch a\n              // `DeoptiomizeIf` to a branch if it has a phi input, which indicates that\n              // block cloning could be helpful.\n              if (__ Get(condition).template Is<PhiOp>()) {\n                if (negated) {\n                  IF_NOT (LIKELY(condition)) {\n                    __ Deoptimize(frame_state, parameters);\n                  }\n            \n                } else {\n                  IF (UNLIKELY(condition)) {\n                    __ Deoptimize(frame_state, parameters);\n                  }\n                }\n                return V<None>::Invalid();\n              }\n              goto no_change;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(ObjectIs)\",\n            \"parent\": \"MachineLoweringReducer\",\n            \"about\": \"Reduces the ObjectIs operation, determining if an object matches a specific kind (e.g., BigInt, Callable, Smi).\",\n            \"logic\": \"This function performs a series of checks based on the specified kind to determine if the input object matches. It handles various cases, including BigInt, Callable, Smi, Number, String, Symbol, and ArrayBufferView.  The logic includes checks for Smi values, heap object types, and map properties.\",\n            \"parameters\": [\n                {\n                    \"name\": \"input\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The input object to check.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"ObjectIsOp::Kind\",\n                    \"purpose\": \"Specifies the kind of object to check for (e.g., kBigInt, kCallable, kSmi).\"\n                },\n                {\n                    \"name\": \"input_assumptions\",\n                    \"type\": \"ObjectIsOp::InputAssumptions\",\n                    \"purpose\": \"Specifies assumptions about the input object (e.g., kNone, kHeapObject).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Word32>\",\n                \"description\": \"A Word32 value representing a boolean: 1 if the object matches the specified kind, 0 otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V<Word32> REDUCE(ObjectIs)(V<Object> input, ObjectIsOp::Kind kind,\n                                      ObjectIsOp::InputAssumptions input_assumptions) {\n              switch (kind) {\n                case ObjectIsOp::Kind::kBigInt:\n                case ObjectIsOp::Kind::kBigInt64: {\n                  DCHECK_IMPLIES(kind == ObjectIsOp::Kind::kBigInt64, Is64());\n            \n                  Label<Word32> done(this);\n            \n                  if (input_assumptions != ObjectIsOp::InputAssumptions::kBigInt) {\n                    if (NeedsHeapObjectCheck(input_assumptions)) {\n                      // Check for Smi.\n                      GOTO_IF(__ IsSmi(input), done, 0);\n                    }\n            \n                    // Check for BigInt.\n                    V<Map> map = __ LoadMapField(input);\n                    V<Word32> is_bigint_map =\n                        __ TaggedEqual(map, __ HeapConstant(factory_->bigint_map()));\n                    GOTO_IF_NOT(is_bigint_map, done, 0);\n                  }\n            \n                  if (kind == ObjectIsOp::Kind::kBigInt) {\n                    GOTO(done, 1);\n                  } else {\n                    DCHECK_EQ(kind, ObjectIsOp::Kind::kBigInt64);\n                    // We have to perform check for BigInt64 range.\n                    V<Word32> bitfield = __ template LoadField<Word32>(\n                        input, AccessBuilder::ForBigIntBitfield());\n                    GOTO_IF(__ Word32Equal(bitfield, 0), done, 1);\n            \n                    // Length must be 1.\n                    V<Word32> length_field =\n                        __ Word32BitwiseAnd(bitfield, BigInt::LengthBits::kMask);\n                    GOTO_IF_NOT(__ Word32Equal(length_field,\n                                               uint32_t{1} << BigInt::LengthBits::kShift),\n                                done, 0);\n            \n                    // Check if it fits in 64 bit signed int.\n                    V<Word64> lsd = __ template LoadField<Word64>(\n                        input, AccessBuilder::ForBigIntLeastSignificantDigit64());\n                    V<Word32> magnitude_check = __ Uint64LessThanOrEqual(\n                        lsd, std::numeric_limits<int64_t>::max());\n                    GOTO_IF(magnitude_check, done, 1);\n            \n                    // The BigInt probably doesn't fit into signed int64. The only\n                    // exception is int64_t::min. We check for this.\n                    V<Word32> sign =\n                        __ Word32BitwiseAnd(bitfield, BigInt::SignBits::kMask);\n                    V<Word32> sign_check = __ Word32Equal(sign, BigInt::SignBits::kMask);\n                    GOTO_IF_NOT(sign_check, done, 0);\n            \n                    V<Word32> min_check =\n                        __ Word64Equal(lsd, std::numeric_limits<int64_t>::min());\n                    GOTO_IF(min_check, done, 1);\n            \n                    GOTO(done, 0);\n                  }\n            \n                  BIND(done, result);\n                  return result;\n                }\n                case ObjectIsOp::Kind::kUndetectable:\n                  if (DependOnNoUndetectableObjectsProtector()) {\n                    V<Word32> is_undefined = __ TaggedEqual(\n                        input, __ HeapConstant(factory_->undefined_value()));\n                    V<Word32> is_null =\n                        __ TaggedEqual(input, __ HeapConstant(factory_->null_value()));\n                    return __ Word32BitwiseOr(is_undefined, is_null);\n                  }\n                  [[fallthrough]];\n                case ObjectIsOp::Kind"
}