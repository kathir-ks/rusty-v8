{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-lowering.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-lowering.cc\",\n        \"file_name\": \"simplified-lowering.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the SimplifiedLowering pass for the Turbofan compiler, which selects machine representations for values and lowers simplified operations to machine operations.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for compiler, code generation, base utilities, and data structures.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/simplified-lowering.h\"\n\n#include <limits>\n#include <optional>\n\n#include \"include/v8-fast-api-calls.h\"\n#include \"src/base/logging.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/base/small-vector.h\"\n#include \"src/codegen/callable.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/codegen/tick-counter.h\"\n#include \"src/compiler/access-builder.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/diamond.h\"\n#include \"src/compiler/feedback-source.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-observer.h\"\n#include \"src/compiler/node-origin-table.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operation-typer.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/representation-change.h\"\n#include \"src/compiler/simplified-lowering-verifier.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/turbofan-graph-visualizer.h\"\n#include \"src/compiler/type-cache.h\"\n#include \"src/flags/flags.h\"\n#include \"src/numbers/conversions-inl.h\"\n#include \"src/objects/objects.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/value-type.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JSONGraphWriterWithVerifierTypes\",\n            \"extends\": \"JSONGraphWriter\",\n            \"about\": \"A custom JSON graph writer that includes type information from the SimplifiedLoweringVerifier.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"JSONGraphWriter\",\n                \"TFGraph\",\n                \"SourcePositionTable\",\n                \"NodeOriginTable\",\n                \"SimplifiedLoweringVerifier\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass JSONGraphWriterWithVerifierTypes : public JSONGraphWriter {\n public:\n  JSONGraphWriterWithVerifierTypes(std::ostream& os, const TFGraph* graph,\n                                   const SourcePositionTable* positions,\n                                   const NodeOriginTable* origins,\n                                   SimplifiedLoweringVerifier* verifier)\n      : JSONGraphWriter(os, graph, positions, origins), verifier_(verifier) {}\n\n protected:\n  std::optional<Type> GetType(Node* node) override {\n    return verifier_->GetType(node);\n  }\n\n private:\n  SimplifiedLoweringVerifier* verifier_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"InputUseInfos\",\n            \"about\": \"Helper class for monotonicity checking of UseInfo during representation selection.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Zone\",\n                \"UseInfo\",\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass InputUseInfos {\n public:\n  explicit InputUseInfos(Zone* zone) : input_use_infos_(zone) {}\n\n  void SetAndCheckInput(Node* node, int index, UseInfo use_info) {\n    if (input_use_infos_.empty()) {\n      input_use_infos_.resize(node->InputCount(), UseInfo::None());\n    }\n    // Check that the new use informatin is a super-type of the old\n    // one.\n    DCHECK(IsUseLessGeneral(input_use_infos_[index], use_info));\n    input_use_infos_[index] = use_info;\n  }\n\n private:\n  ZoneVector<UseInfo> input_use_infos_;\n\n  static bool IsUseLessGeneral(UseInfo use1, UseInfo use2) {\n    return use1.truncation().IsLessGeneralThan(use2.truncation());\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RepresentationSelector\",\n            \"about\": \"The core class that performs representation selection and lowering. It tracks node information, propagates truncation information, and performs the actual lowering.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"JSGraph\",\n                \"JSHeapBroker\",\n                \"Zone\",\n                \"RepresentationChanger\",\n                \"SourcePositionTable\",\n                \"NodeOriginTable\",\n                \"TickCounter\",\n                \"Linkage\",\n                \"ObserveNodeManager\",\n                \"SimplifiedLoweringVerifier\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass RepresentationSelector {\n  // The purpose of this nested class is to hide method\n  // v8::internal::compiler::NodeProperties::ChangeOp which should not be\n  // directly used by code in RepresentationSelector and SimplifiedLowering.\n  // RepresentationSelector code should call RepresentationSelector::ChangeOp in\n  // place of NodeProperties::ChangeOp, in order to notify the changes to a\n  // registered ObserveNodeManager and support the %ObserveNode intrinsic.\n  class NodeProperties : public compiler::NodeProperties {\n    static void ChangeOp(Node* node, const Operator* new_op) { UNREACHABLE(); }\n  };\n\n public:\n  // Information for each node tracked during the fixpoint.\n  class NodeInfo final {\n   public:\n    // Adds new use to the node. Returns true if something has changed\n    // and the node has to be requeued.\n    bool AddUse(UseInfo info) {\n      Truncation old_truncation = truncation_;\n      truncation_ = Truncation::Generalize(truncation_, info.truncation());\n      return truncation_ != old_truncation;\n    }\n\n    void set_queued() { state_ = kQueued; }\n    void set_visited() { state_ = kVisited; }\n    void set_pushed() { state_ = kPushed; }\n    void reset_state() { state_ = kUnvisited; }\n    bool visited() const { return state_ == kVisited; }\n    bool queued() const { return state_ == kQueued; }\n    bool pushed() const { return state_ == kPushed; }\n    bool unvisited() const { return state_ == kUnvisited; }\n    Truncation truncation() const { return truncation_; }\n    void set_output(MachineRepresentation output) { representation_ = output; }\n\n    MachineRepresentation representation() const { return representation_; }\n\n    // Helpers for feedback typing.\n    void set_feedback_type(Type type) { feedback_type_ = type; }\n    Type feedback_type() const { return feedback_type_; }\n    void set_weakened() { weakened_ = true; }\n    bool weakened() const { return weakened_; }\n    void set_restriction_type(Type type) { restriction_type_ = type; }\n    Type restriction_type() const { return restriction_type_; }\n\n   private:\n    // Fields are ordered to avoid mixing byte and word size fields to minimize\n    // padding.\n    enum State : uint8_t { kUnvisited, kPushed, kVisited, kQueued };\n    State state_ = kUnvisited;\n    MachineRepresentation representation_ =\n        MachineRepresentation::kNone;             // Output representation.\n    Truncation truncation_ = Truncation::None();  // Information about uses.\n    bool weakened_ = false;\n\n    Type restriction_type_ = Type::Any();\n    Type feedback_type_;\n  };\n\n  RepresentationSelector(JSGraph* jsgraph, JSHeapBroker* broker, Zone* zone,\n                         RepresentationChanger* changer,\n                         SourcePositionTable* source_positions,\n                         NodeOriginTable* node_origins,\n                         TickCounter* tick_counter, Linkage* linkage,\n                         ObserveNodeManager* observe_node_manager,\n                         SimplifiedLoweringVerifier* verifier)\n      : jsgraph_(jsgraph),\n        broker_(broker),\n        zone_(zone),\n        might_need_revisit_(zone),\n        count_(jsgraph->graph()->NodeCount()),\n        info_(count_, zone),\n#ifdef DEBUG\n        node_input_use_infos_(count_, InputUseInfos(zone), zone),\n#endif\n        replacements_(zone),\n        changer_(changer),\n        revisit_queue_(zone),\n        traversal_nodes_(zone),\n        source_positions_(source_positions),\n        node_origins_(node_origins),\n        type_cache_(TypeCache::Get()),\n        op_typer_(broker, graph_zone()),\n        tick_counter_(tick_counter),\n        linkage_(linkage),\n        observe_node_manager_(observe_node_manager),\n        verifier_(verifier) {\n    singleton_true_ =\n        Type::Constant(broker, broker->true_value(), graph_zone());\n    singleton_false_ =\n        Type::Constant(broker, broker->false_value(), graph_zone());\n  }\n\n  bool verification_enabled() const { return verifier_ != nullptr; }\n\n  void ResetNodeInfoState() {\n    // Clean up for the next phase.\n    for (NodeInfo& info : info_) {\n      info.reset_state();\n    }\n  }\n\n  Type TypeOf(Node* node) {\n    Type type = GetInfo(node)->feedback_type();\n    return type.IsInvalid() ? NodeProperties::GetType(node) : type;\n  }\n\n  Type FeedbackTypeOf(Node* node) {\n    Type type = GetInfo(node)->feedback_type();\n    return type.IsInvalid() ? Type::None() : type;\n  }\n\n  Type TypePhi(Node* node) {\n    int arity = node->op()->ValueInputCount();\n    Type type = FeedbackTypeOf(node->InputAt(0));\n    for (int i = 1; i < arity; ++i) {\n      type = op_typer_.Merge(type, FeedbackTypeOf(node->InputAt(i)));\n    }\n    return type;\n  }\n\n  Type TypeSelect(Node* node) {\n    return op_typer_.Merge(FeedbackTypeOf(node->InputAt(1)),\n                           FeedbackTypeOf(node->InputAt(2)));\n  }\n\n  bool UpdateFeedbackType(Node* node) {\n    if (node->op()->ValueOutputCount() == 0) return false;\n    if ((IrOpcode::IsMachineOpcode(node->opcode()) ||\n         IrOpcode::IsMachineConstantOpcode(node->opcode())) &&\n        node->opcode() != IrOpcode::kLoadFramePointer) {\n      DCHECK(NodeProperties::GetType(node).Is(Type::Machine()));\n    }\n\n    // For any non-phi node just wait until we get all inputs typed. We only\n    // allow untyped inputs for phi nodes because phis are the only places\n    // where cycles need to be broken.\n    if (node->opcode() != IrOpcode::kPhi) {\n      for (int i = 0; i < node->op()->ValueInputCount(); i++) {\n        if (GetInfo(node->InputAt(i))->feedback_type().IsInvalid()) {\n          return false;\n        }\n      }\n    }\n\n    NodeInfo* info = GetInfo(node);\n    Type type = info->feedback_type();\n    Type new_type = NodeProperties::GetType(node);\n\n    // We preload these values here to avoid increasing the binary size too\n    // much, which happens if we inline the calls into the macros below.\n    Type input0_type;\n    if (node->InputCount() > 0) input0_type = FeedbackTypeOf(node->InputAt(0));\n    Type input1_type;\n    if (node->InputCount() > 1) input1_type = FeedbackTypeOf(node->InputAt(1));\n\n    switch (node->opcode()) {\n#define DECLARE_CASE(Name)                               \\\n  case IrOpcode::k##Name: {                              \\\n    new_type = op_typer_.Name(input0_type, input1_type); \\\n    break;                                               \\\n  }\n      SIMPLIFIED_NUMBER_BINOP_LIST(DECLARE_CASE)\n      DECLARE_CASE(SameValue)\n#undef DECLARE_CASE\n\n#define DECLARE_CASE(Name)                                               \\\n  case IrOpcode::k##Name: {                                              \\\n    new_type = Type::Intersect(op_typer_.Name(input0_type, input1_type), \\\n                               info->restriction_type(), graph_zone());  \\\n    break;                                                               \\\n  }\n      SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(DECLARE_CASE)\n      SIMPLIFIED_SPECULATIVE_BIGINT_BINOP_LIST(DECLARE_CASE)\n#undef DECLARE_CASE\n\n#define DECLARE_CASE(Name)                  \\\n  case IrOpcode::k##Name: {                 \\\n    new_type = op_typer_.Name(input0_type); \\\n    break;                                  \\\n  }\n      SIMPLIFIED_NUMBER_UNOP_LIST(DECLARE_CASE)\n#undef DECLARE_CASE\n\n#define DECLARE_CASE(Name)                                              \\\n  case IrOpcode::k##Name: {                                             \\\n    new_type = Type::Intersect(op_typer_.Name(input0_type),             \\\n                               info->restriction_type(), graph_zone()); \\\n    break;                                                              \\\n  }\n      SIMPLIFIED_SPECULATIVE_NUMBER_UNOP_LIST(DECLARE_CASE)\n#undef DECLARE_CASE\n\n      case IrOpcode::kConvertReceiver:\n        new_type = op_typer_.ConvertReceiver(input0_type);\n        break;\n\n      case IrOpcode::kPlainPrimitiveToNumber:\n        new_type = op_typer_.ToNumber(input0_type);\n        break;\n\n      case IrOpcode::kCheckBounds:\n        new_type =\n            Type::Intersect(op_typer_.CheckBounds(input0_type, input1_type),\n                            info->restriction_type(), graph_zone());\n        break;\n\n      case IrOpcode::kCheckFloat64Hole:\n        new_type = Type::Intersect(op_typer_.CheckFloat64Hole(input0_type),\n                                   info->restriction_type(), graph_zone());\n        break;\n\n      case IrOpcode::kCheckNumber:\n        new_type = Type::Intersect(op_typer_.CheckNumber(input0_type),\n                                   info->restriction_type(), graph_zone());\n        break;\n\n      case IrOpcode::kCheckNumberFitsInt32:\n        new_type = Type::Intersect(op_typer_.CheckNumberFitsInt32(input0_type),\n                                   info->restriction_type(), graph_zone());\n        break;\n\n      case IrOpcode::kPhi: {\n        new_type = TypePhi(node);\n        if (!type.IsInvalid()) {\n          new_type = Weaken(node, type, new_type);\n        }\n        break;\n      }\n\n      case IrOpcode::kConvertTaggedHoleToUndefined:\n        new_type = op_typer_.ConvertTaggedHoleToUndefined(\n            FeedbackTypeOf(node->InputAt(0)));\n        break;\n\n      case IrOpcode::kTypeGuard: {\n        new_type = op_typer_.TypeTypeGuard(node->op(),\n                                           FeedbackTypeOf(node->InputAt(0)));\n        break;\n      }\n\n      case IrOpcode::kSelect: {\n        const auto& p = SelectParametersOf(node->op());\n        if (p.semantics() == BranchSemantics::kMachine) {\n          if (type.IsInvalid()) {\n            GetInfo(node)->set_feedback_type(NodeProperties::GetType(node));\n            return true;\n          }\n          return false;\n        }\n        new_type = TypeSelect(node);\n        break;\n      }\n\n      default:\n        // Shortcut for operations that we do not handle.\n        if (type.IsInvalid()) {\n          GetInfo(node)->set_feedback_type(NodeProperties::GetType(node));\n          return true;\n        }\n        return false;\n    }\n    // We need to guarantee that the feedback type is a subtype of the upper\n    // bound. Naively that should hold, but weakening can actually produce\n    // a bigger type if we are unlucky with ordering of phi typing. To be\n    // really sure, just intersect the upper bound with the feedback type.\n    new_type = Type::Intersect(GetUpperBound(node), new_type, graph_zone());\n\n    if (!type.IsInvalid() && new_type.Is(type)) return false;\n    GetInfo(node)->set_feedback_type(new_type);\n    if (v8_flags.trace_representation) {\n      PrintNodeFeedbackType(node);\n    }\n    return true;\n  }\n\n  void PrintNodeFeedbackType(Node* n) {\n    StdoutStream os;\n    os << \"#\" << n->id() << \":\" << *n->op() << \"(\";\n    int j = 0;\n    for (Node* const i : n->inputs()) {\n      if (j++ > 0) os << \", \";\n      os << \"#\" << i->id() << \":\" << i->op()->mnemonic();\n    }\n    os << \")\";\n    if (NodeProperties::IsTyped(n)) {\n      Type static_type = NodeProperties::GetType(n);\n      os << \"  [Static type: \" << static_type;\n      Type feedback_type = GetInfo(n)->feedback_type();\n      if (!feedback_type.IsInvalid() && feedback_type != static_type) {\n        os << \", Feedback type: \" << feedback_type;\n      }\n      os << \"]\";\n    }\n    os << std::endl;\n  }\n\n  Type Weaken(Node* node, Type previous_type, Type current_type) {\n    // If the types have nothing to do with integers, return the types.\n    Type const integer = type_cache_->kInteger;\n    if (!previous_type.Maybe(integer)) {\n      return current_type;\n    }\n    DCHECK(current_type.Maybe(integer));\n\n    Type current_integer = Type::Intersect(current_type, integer, graph_zone());\n    DCHECK(!current_integer.IsNone());\n    Type previous_integer =\n        Type::Intersect(previous_type, integer, graph_zone());\n    DCHECK(!previous_integer.IsNone());\n\n    // Once we start weakening a node, we should always weaken.\n    if (!GetInfo(node)->weakened()) {\n      // Only weaken if there is range involved; we should converge quickly\n      // for all other types (the exception is a union of many constants,\n      // but we currently do not increase the number of constants in unions).\n      Type previous = previous_integer.GetRange();\n      Type current = current_integer.GetRange();\n      if (current.IsInvalid() || previous.IsInvalid()) {\n        return current_type;\n      }\n      // Range is involved => we are weakening.\n      GetInfo(node)->set_weakened();\n    }\n\n    return Type::Union(current_type,\n                       op_typer_.WeakenRange(previous_integer, current_integer),\n                       graph_zone());\n  }\n\n  // Generates a pre-order traversal of the nodes, starting with End.\n  void GenerateTraversal() {\n    // Reset previous state.\n    ResetNodeInfoState();\n    traversal_nodes_.clear();\n    count_ = graph()->NodeCount();\n    info_.resize(count_);\n\n    ZoneStack<NodeState> stack(zone_);\n\n    stack.push({graph()->end(), 0});\n    GetInfo(graph()->end())->set_pushed();\n    while (!stack.empty()) {\n      NodeState& current = stack.top();\n      Node* node = current.node;\n      // If there is an unvisited input, push it and continue with that node.\n      bool pushed_unvisited = false;\n      while (current.input_index < node->InputCount()) {\n        Node* input = node->InputAt(current.input_index);\n        NodeInfo* input_info = GetInfo(input);\n        current.input_index++;\n        if (input_info->unvisited()) {\n          input_info->set_pushed();\n          stack.push({input, 0});\n          pushed_unvisited = true;\n          break;\n        } else if (input_info->pushed()) {\n          // Optimization for the Retype phase.\n          // If we had already pushed (and not visited) an input, it means that\n          // the current node will be visited in the Retype phase before one of\n          // its inputs. If this happens, the current node might need to be\n          // revisited.\n          MarkAsPossibleRevisit(node, input);\n        }\n      }\n\n      if (pushed_unvisited) continue;\n\n      stack.pop();\n      NodeInfo* info = GetInfo(node);\n      info->set_visited();\n\n      // Generate the traversal\n      traversal_nodes_.push_back(node);\n    }\n  }\n\n  void PushNodeToRevisitIfVisited(Node* node) {\n    NodeInfo* info = GetInfo(node);\n    if (info->visited()) {\n      TRACE(\" QUEUEING #%d: %s\\n\", node->id(), node->op()->mnemonic());\n      info->set_queued();\n      revisit_queue_.push(node);\n    }\n  }\n\n  // Tries to update the feedback type of the node, as well as setting its\n  // machine representation (in VisitNode). Returns true iff updating the\n  // feedback type is successful.\n  bool RetypeNode(Node* node) {\n    NodeInfo* info = GetInfo(node);\n    info->set_visited();\n    bool updated = UpdateFeedbackType(node);\n    TRACE(\" visit #%d: %s\\n\", node->id(), node->op()->mnemonic());\n    VisitNode<RETYPE>(node, info->truncation(), nullptr);\n    TRACE(\"  ==> output %s\\n\", MachineReprToString(info->representation()));\n    return updated;\n  }\n\n  // Visits the node and marks it as visited. Inside of VisitNode, we might\n  // change the truncation of one of our inputs (see EnqueueInput<PROPAGATE> for\n  // this). If we change the truncation of an already visited node, we will add\n  // it to the revisit queue.\n  void PropagateTruncation(Node* node) {\n    NodeInfo* info = GetInfo(node);\n    info->set_visited();\n    TRACE(\" visit #%d: %s (trunc: %s)\\n\", node->id(), node->op()->mnemonic(),\n          info->truncation().description());\n    VisitNode<PROPAGATE>(node, info->truncation(), nullptr);\n  }\n\n  // Backward propagation of truncations to a fixpoint.\n  void RunPropagatePhase() {\n    TRACE(\"--{Propagate phase}--\\n\");\n    ResetNodeInfoState();\n    DCHECK(revisit_queue_.empty());\n\n    // Process nodes in reverse post order, with End as the root.\n    for (auto it = traversal_nodes_.crbegin(); it != traversal_nodes_.crend();\n         ++it) {\n      PropagateTruncation(*it);\n\n      while (!revisit_queue_.empty()) {\n        Node* node = revisit_queue_.front();\n        revisit_queue_.pop();\n        PropagateTruncation(node);\n      }\n    }\n  }\n\n  // Forward propagation of types from type feedback to a fixpoint.\n  void RunRetypePhase() {\n    TRACE(\"--{Retype phase}--\\n\");\n    ResetNodeInfoState();\n    DCHECK(revisit_queue_.empty());\n\n    for (auto it = traversal_nodes_.cbegin(); it != traversal_nodes_.cend();\n         ++it) {\n      Node* node = *it;\n      if (!RetypeNode(node)) continue;\n\n      auto revisit_it = might_need_revisit_.find(node);\n      if (revisit_it == might_need_revisit_.end()) continue;\n\n      for (Node* const user : revisit_it->second) {\n        PushNodeToRevisitIfVisited(user);\n      }\n\n      // Process the revisit queue.\n      while (!revisit_queue_.empty()) {\n        Node* revisit_node = revisit_queue_.front();\n        revisit_queue_.pop();\n        if (!RetypeNode(revisit_node)) continue;\n        // Here we need to check all uses since we can't easily know which\n        // nodes will need to be revisited due to having an input which was\n        // a revisited node.\n        for (Node* const user : revisit_node->uses()) {\n          PushNodeToRevisitIfVisited(user);\n        }\n      }\n    }\n  }\n\n  // Lowering and change insertion phase.\n  void RunLowerPhase(SimplifiedLowering* lowering) {\n    TRACE(\"--{Lower phase}--\\n\");\n    for (auto it = traversal_nodes_.cbegin(); it != traversal_nodes_.cend();\n         ++it) {\n      Node* node = *it;\n      NodeInfo* info = GetInfo(node);\n      TRACE(\" visit #%d: %s\\n\", node->id(), node->op()->mnemonic());\n      // Reuse {VisitNode()} so the representation rules are in one place.\n      SourcePositionTable::Scope scope(\n          source_positions_, source_positions_->GetSourcePosition(node));\n      NodeOriginTable::Scope origin_scope(node_origins_, \"simplified lowering\",\n                                          node);\n      VisitNode<LOWER>(node, info->truncation(), lowering);\n    }\n\n    // Perform the final replacements.\n    for (NodeVector::iterator i = replacements_.begin();\n         i != replacements_.end(); ++i) {\n      Node* node = *i;\n      Node* replacement = *(++i);\n      node->ReplaceUses(replacement);\n      node->Kill();\n      // We also need to replace the node in the rest of the vector.\n      for (NodeVector::iterator j = i + 1; j != replacements_.end(); ++j) {\n        ++j;\n        if (*j == node) *j = replacement;\n      }\n    }\n  }\n\n  void RunVerifyPhase(OptimizedCompilationInfo* compilation_info) {\n    DCHECK_NOT_NULL(verifier_);\n\n    TRACE(\"--{Verify Phase}--\\n\");\n\n    // Patch pending type overrides.\n    for (const auto& [constant, uses] :\n         verifier_->machine_uses_of_constants()) {\n      Node* typed_constant =\n          InsertTypeOverrideForVerifier(Type::Machine(), constant);\n      for (auto use : uses) {\n        for (int i = 0; i < use->InputCount(); ++i) {\n          if (use->InputAt(i) == constant) {\n            use->ReplaceInput(i, typed_constant);\n          }\n        }\n      }\n    }\n\n    // Generate a new traversal containing all the new nodes created during\n    // lowering.\n    GenerateTraversal();\n\n    // Set node types to the refined types computed during retyping.\n    for (Node* node : traversal_nodes_) {\n      NodeInfo* info = GetInfo(node);\n      if (!info->feedback_type().IsInvalid()) {\n        NodeProperties::SetType(node, info->feedback_type());\n      }\n    }\n\n    // Print graph.\n    if (compilation_info != nullptr && compilation_info->trace_turbo_json()) {\n      UnparkedScopeIfNeeded scope(broker_);\n      AllowHandleDereference allow_deref;\n\n      TurboJsonFile json_of(compilation_info, std::ios_base::app);\n      JSONGraphWriter writer(json_of, graph(), source_positions_,\n                             node_origins_);\n      writer.PrintPhase(\"V8.TFSimplifiedLowering [after lower]\");\n    }\n\n    // Verify all nodes.\n    for (Node* node : traversal_nodes_) {\n      verifier_->VisitNode(node, op_typer_);\n    }\n\n    // Print graph.\n    if (compilation_info != nullptr && compilation_info->trace_turbo_json()) {\n      UnparkedScopeIfNeeded scope(broker_);\n      AllowHandleDereference allow_deref;\n\n      TurboJsonFile json_of(compilation_info, std::ios_base::app);\n      JSONGraphWriterWithVerifierTypes writer(\n          json_of, graph(), source_positions_, node_origins_, verifier_);\n      writer.PrintPhase(\"V8.TFSimplifiedLowering [after verify]\");\n    }\n\n    // Eliminate all introduced hints.\n    for (Node* node : verifier_->inserted_hints()) {\n      Node* input = node->InputAt(0);\n      node->ReplaceUses(input);\n      node->Kill();\n    }\n  }\n\n  void Run(SimplifiedLowering* lowering) {\n    GenerateTraversal();\n    RunPropagatePhase();\n    RunRetypePhase();\n    RunLowerPhase(lowering);\n    if (verification_enabled()) {\n      RunVerifyPhase(lowering->info_);\n    }\n  }\n\n  // Just assert for Retype and Lower. Propagate specialized below.\n  template <Phase T>\n  void EnqueueInput(Node* use_node, int index,\n                    UseInfo use_info = UseInfo::None()) {\n    static_assert(retype<T>() || lower<T>(),\n                  \"This version of EnqueueInput has to be called in \"\n                  \"the Retype or Lower phase.\");\n  }\n\n  template <Phase T>\n  static constexpr bool propagate() {\n    return T == PROPAGATE;\n  }\n\n  template <Phase T>\n  static constexpr bool retype() {\n    return T == RETYPE;\n  }\n\n  template <Phase T>\n  static constexpr bool lower() {\n    return T == LOWER;\n  }\n\n  template <Phase T>\n  void SetOutput(Node* node, MachineRepresentation representation,\n                 Type restriction_type = Type::Any());\n\n  Type GetUpperBound(Node* node) { return NodeProperties::GetType(node); }\n\n  bool InputCannotBe(Node* node, Type type) {\n    DCHECK_EQ(1, node->op()->ValueInputCount());\n    return !GetUpperBound(node->InputAt(0)).Maybe(type);\n  }\n\n  bool InputIs(Node* node, Type type) {\n    DCHECK_EQ(1, node->op()->ValueInputCount());\n    return GetUpperBound(node->InputAt(0)).Is(type);\n  }\n\n  bool BothInputsAreSigned32(Node* node) {\n    return BothInputsAre(node, Type::Signed32());\n  }\n\n  bool BothInputsAreUnsigned32(Node* node) {\n    return BothInputsAre(node, Type::Unsigned32());\n  }\n\n  bool BothInputsAre(Node* node, Type type) {\n    DCHECK_EQ(2, node->op()->ValueInputCount());\n    return GetUpperBound(node->InputAt(0)).Is(type) &&\n           GetUpperBound(node->InputAt(1)).Is(type);\n  }\n\n  bool IsNodeRepresentationTagged(Node* node) {\n    MachineRepresentation representation = GetInfo(node)->representation();\n    return IsAnyTagged(representation);\n  }\n\n  bool OneInputCannotBe(Node* node, Type type) {\n    DCHECK_EQ(2, node->op()->ValueInputCount());\n    return !GetUpperBound(node->InputAt(0)).Maybe(type) ||\n           !GetUpperBound(node->InputAt(1)).Maybe(type);\n  }\n\n  void ChangeToDeadValue(Node* node, Node* effect, Node* control) {\n    DCHECK(TypeOf(node).IsNone());\n    // If the node is unreachable, insert an Unreachable node and mark the\n    // value dead.\n    // TODO(jarin,turbofan) Find a way to unify/merge this insertion with\n    // InsertUnreachableIfNecessary.\n    Node* unreachable = effect =\n        graph()->NewNode(common()->Unreachable(), effect, control);\n    const Operator* dead_value =\n        common()->DeadValue(GetInfo(node)->representation());\n    node->ReplaceInput(0, unreachable);\n    node->TrimInputCount(dead_value->ValueInputCount());\n    ReplaceEffectControlUses(node, effect, control);\n    ChangeOp(node, dead_value);\n  }\n\n  // This function is a generalization of ChangeToPureOp. It can be used to\n  // replace a node that is part of the effect and control chain by a pure node.\n  void ReplaceWithPureNode(Node* node, Node* pure_node) {\n    DCHECK(pure_node->op()->HasProperty(Operator::kPure));\n    if (node->op()->EffectInputCount() > 0) {\n      DCHECK_LT(0, node->op()->ControlInputCount());\n      Node* control = NodeProperties::GetControlInput(node);\n      Node* effect = NodeProperties::GetEffectInput(node);\n      if (TypeOf(node).IsNone()) {\n        ChangeToDeadValue(node, effect, control);\n        return;\n      }\n      // Rewire the effect and control chains.\n      ReplaceEffectControlUses(node, effect, control);\n    } else {\n      DCHECK_EQ(0, node->op()->ControlInputCount());\n    }\n    DeferReplacement(node, pure_node);\n  }\n\n  void ChangeToPureOp(Node* node, const Operator* new_op) {\n    DCHECK(new_op->HasProperty(Operator::kPure));\n    DCHECK_EQ(new_op"
}