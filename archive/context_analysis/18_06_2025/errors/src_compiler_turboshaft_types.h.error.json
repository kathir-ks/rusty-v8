{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/types.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/types.h\",\n            \"file_name\": \"types.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the type system for the Turboshaft compiler, including classes for representing word types, float types, and tuple types, along with utilities for type manipulation and comparison.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for various functionalities, such as math operations, limits, container utilities, logging, fast hashing, number conversions, object representations, output streams, and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cmath>\n            #include <limits>\n            #include <optional>\n\n            #include \"src/base/container-utils.h\"\n            #include \"src/base/export-template.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/base/small-vector.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/compiler/turboshaft/fast-hash.h\"\n            #include \"src/numbers/conversions.h\"\n            #include \"src/objects/turboshaft-types.h\"\n            #include \"src/utils/ostreams.h\"\n            #include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Payload_Empty\",\n                \"about\": \"An empty payload structure, used as a placeholder for types that don't require additional data. Includes a dummy uint8_t to workaround a potential GCC issue.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"dummy\",\n                        \"type\": \"uint8_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Dummy value to avoid uninitialized warnings with some older versions of GCC.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            struct Payload_Empty {\n            uint8_t dummy = 0;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Payload_Range\",\n                \"about\": \"A payload structure for representing a range of values, defined by a minimum and maximum value of a given type.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"min\",\n                        \"type\": \"T\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Minimum value of the range.\"\n                    },\n                    {\n                        \"name\": \"max\",\n                        \"type\": \"T\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Maximum value of the range.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            struct Payload_Range {\n            T min;\n            T max;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Payload_InlineSet\",\n                \"about\": \"A payload structure for representing a small set of values, stored inline within the type representation.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"elements\",\n                        \"type\": \"T[2]\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Array containing the elements of the set.  Limited to a small number of elements.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            struct Payload_InlineSet {\n            T elements[2];\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Payload_OutlineSet\",\n                \"about\": \"A payload structure for representing a larger set of values, where the values are stored in an externally allocated array.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"array\",\n                        \"type\": \"T*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Pointer to an array containing the elements of the set. The array is allocated externally, typically in a Zone.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            struct Payload_OutlineSet {\n            T* array;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"next_smaller\",\n                \"about\": \"Returns the next smaller floating-point value.\",\n                \"logic\": \"Uses std::nextafter to get the next representable floating-point value towards negative infinity.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"v\",\n                        \"type\": \"T\",\n                        \"purpose\": \"The input floating-point value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"T\",\n                    \"description\": \"The next smaller floating-point value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            T next_smaller(T v)\n            requires std::is_floating_point<T>::value\n            {\n            DCHECK(!std::isnan(v));\n            DCHECK_LT(-std::numeric_limits<T>::infinity(), v);\n            return std::nextafter(v, -std::numeric_limits<T>::infinity());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"next_larger\",\n                \"about\": \"Returns the next larger floating-point value.\",\n                \"logic\": \"Uses std::nextafter to get the next representable floating-point value towards positive infinity.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"v\",\n                        \"type\": \"T\",\n                        \"purpose\": \"The input floating-point value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"T\",\n                    \"description\": \"The next larger floating-point value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            T next_larger(T v)\n            requires std::is_floating_point<T>::value\n            {\n            DCHECK(!std::isnan(v));\n            DCHECK_LT(v, std::numeric_limits<T>::infinity());\n            return std::nextafter(v, std::numeric_limits<T>::infinity());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"next_smaller\",\n                \"about\": \"Returns the next smaller integer value.\",\n                \"logic\": \"Subtracts 1 from the input integer value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"v\",\n                        \"type\": \"T\",\n                        \"purpose\": \"The input integer value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"T\",\n                    \"description\": \"The next smaller integer value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            T next_smaller(T v)\n            requires std::is_integral<T>::value\n            {\n            DCHECK_LT(std::numeric_limits<T>::min(), v);\n            return v - 1;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"next_larger\",\n                \"about\": \"Returns the next larger integer value.\",\n                \"logic\": \"Adds 1 to the input integer value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"v\",\n                        \"type\": \"T\",\n                        \"purpose\": \"The input integer value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"T\",\n                    \"description\": \"The next larger integer value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            T next_larger(T v)\n            requires std::is_integral<T>::value\n            {\n            DCHECK_LT(v, std::numeric_limits<T>::max());\n            return v + 1;\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Type\",\n                \"about\": \"Base class for representing types in the Turboshaft compiler. Provides a common interface for different type kinds.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE Type {\n            public:\n            enum class Kind : uint8_t {\n                kInvalid,\n                kNone,\n                kWord32,\n                kWord64,\n                kFloat32,\n                kFloat64,\n                kTuple,\n                kAny,\n            };\n\n            // Some operations cannot express the result precisely in a type, e.g. when an\n            // intersection with a wrapping range may produce to disconnect subranges,\n            // which cannot be represented. {ResolutionMode} allows to specify what the\n            // operation should do when the result cannot be represented precisely.\n            enum class ResolutionMode {\n                // Return Type::Invalid().\n                kPreciseOrInvalid,\n                // Return a safe over approximation.\n                kOverApproximate,\n                // Return the greatest lower bound that can be represented.\n                kGreatestLowerBound,\n            };\n\n            Type() : Type(Kind::kInvalid) {}\n\n            // Type constructors\n            static inline Type Invalid() { return Type(); }\n            static inline Type None() { return Type(Kind::kNone); }\n            static inline Type Any() { return Type(Kind::kAny); }\n\n            // Checks and casts\n            inline Kind kind() const { return kind_; }\n            inline bool IsInvalid() const { return kind_ == Kind::kInvalid; }\n            inline bool IsNone() const { return kind_ == Kind::kNone; }\n            inline bool IsWord32() const { return kind_ == Kind::kWord32; }\n            inline bool IsWord64() const { return kind_ == Kind::kWord64; }\n            inline bool IsFloat32() const { return kind_ == Kind::kFloat32; }\n            inline bool IsFloat64() const { return kind_ == Kind::kFloat64; }\n            inline bool IsTuple() const { return kind_ == Kind::kTuple; }\n            inline bool IsAny() const { return kind_ == Kind::kAny; }\n            template <size_t B>\n            inline bool IsWord() const {\n                static_assert(B == 32 || B == 64);\n                if constexpr (B == 32)\n                return IsWord32();\n                else\n                return IsWord64();\n            }\n            template <size_t B>\n            inline bool IsFloat() const {\n                static_assert(B == 32 || B == 64);\n                if constexpr (B == 32)\n                return IsFloat32();\n                else\n                return IsFloat64();\n            }\n\n            // Casts\n            inline const Word32Type& AsWord32() const;\n            inline const Word64Type& AsWord64() const;\n            inline const Float32Type& AsFloat32() const;\n            inline const Float64Type& AsFloat64() const;\n            inline const TupleType& AsTuple() const;\n            template <size_t B>\n            inline const auto& AsWord() const {\n                static_assert(B == 32 || B == 64);\n                if constexpr (B == 32)\n                return AsWord32();\n                else\n                return AsWord64();\n            }\n            template <size_t B>\n            inline const auto& AsFloat() const {\n                static_assert(B == 32 || B == 64);\n                if constexpr (B == 32)\n                return AsFloat32();\n                else\n                return AsFloat64();\n            }\n\n            // Comparison\n            bool Equals(const Type& other) const;\n            bool IsSubtypeOf(const Type& other) const;\n\n            // Printing\n            void PrintTo(std::ostream& stream) const;\n            void Print() const;\n            std::string ToString() const {\n                std::stringstream stream;\n                PrintTo(stream);\n                return stream.str();\n            }\n\n            // Other functions\n            static Type LeastUpperBound(const Type& lhs, const Type& rhs, Zone* zone);\n            static std::optional<Type> ParseFromString(const std::string_view& str,\n                                                Zone* zone);\n            Handle<TurboshaftType> AllocateOnHeap(Factory* factory) const;\n\n            protected:\n            template <typename Payload>\n            Type(Kind kind, uint8_t sub_kind, uint8_t set_size, uint32_t bitfield,\n                uint8_t reserved, const Payload& payload)\n                : kind_(kind),\n                sub_kind_(sub_kind),\n                set_size_(set_size),\n                reserved_(reserved),\n                bitfield_(bitfield) {\n                static_assert(sizeof(Payload) <= sizeof(payload_));\n                memcpy(&payload_[0], &payload, sizeof(Payload));\n                if constexpr (sizeof(Payload) < sizeof(payload_)) {\n                memset(reinterpret_cast<uint8_t*>(&payload_[0]) + sizeof(Payload), 0x00,\n                        sizeof(payload_) - sizeof(Payload));\n                }\n            }\n\n            template <typename Payload>\n            const Payload& get_payload() const {\n                static_assert(sizeof(Payload) <= sizeof(payload_));\n                return *reinterpret_cast<const Payload*>(&payload_[0]);\n            }\n\n            union {\n                struct {\n                Kind kind_;\n                uint8_t sub_kind_;\n                uint8_t set_size_;\n                uint8_t reserved_;\n                uint32_t bitfield_;\n                };\n                // {header_} can be  used for faster hashing or comparison.\n                uint64_t header_;\n            };\n\n            private:\n            // Access through get_payload<>().\n            uint64_t payload_[2];  // Type specific data\n\n            friend struct fast_hash<Type>;\n            explicit Type(Kind kind) : Type(kind, 0, 0, 0, 0, detail::Payload_Empty{}) {\n                DCHECK(kind == Kind::kInvalid || kind == Kind::kNone || kind == Kind::kAny);\n            }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WordType\",\n                \"about\": \"Represents a word type (32-bit or 64-bit) with support for ranges and sets of values.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Type\",\n                    \"Payload_Range\",\n                    \"Payload_InlineSet\",\n                    \"Payload_OutlineSet\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <size_t Bits>\n            class WordType : public Type {\n            static_assert(Bits == 32 || Bits == 64);\n            friend class Type;\n            static constexpr int kMaxInlineSetSize = 2;\n\n            enum class SubKind : uint8_t {\n                kRange,\n                kSet,\n            };\n\n            public:\n            static constexpr int kMaxSetSize = 8;\n            using word_t = uint_type<Bits>;\n            using value_type = word_t;\n\n            // Constructors\n            static WordType Any() {\n                return Range(0, std::numeric_limits<word_t>::max(), nullptr);\n            }\n            static WordType Range(word_t from, word_t to, Zone* zone) {\n                // Normalize ranges smaller than {kMaxSetSize} to sets.\n                if (to >= from) {\n                // (to - from + 1) <= kMaxSetSize\n                if (to - from <= kMaxSetSize - 1) {\n                    // Normalizing non-wrapping ranges to a Set.\n                    base::SmallVector<word_t, kMaxSetSize> elements;\n                    for (word_t i = from; i < to; ++i) elements.push_back(i);\n                    elements.push_back(to);\n                    return Set(elements, zone);\n                }\n                } else {\n                // (max - from + 1) + (to + 1) <= kMaxSetSize\n                if ((std::numeric_limits<word_t>::max() - from + to) <= kMaxSetSize - 2) {\n                    // Normalizing wrapping ranges to a Set.\n                    base::SmallVector<word_t, kMaxSetSize> elements;\n                    for (word_t i = from; i < std::numeric_limits<word_t>::max(); ++i) {\n                    elements.push_back(i);\n                    }\n                    elements.push_back(std::numeric_limits<word_t>::max());\n                    for (word_t i = 0; i < to; ++i) elements.push_back(i);\n                    elements.push_back(to);\n                    base::sort(elements);\n                    return Set(elements, zone);\n                }\n                }\n                return WordType{SubKind::kRange, 0, Payload_Range{from, to}};\n            }\n            template <size_t N>\n            static WordType Set(const base::SmallVector<word_t, N>& elements,\n                                Zone* zone) {\n                return Set(base::VectorOf(elements), zone);\n            }\n            static WordType Set(const std::vector<word_t>& elements, Zone* zone) {\n                return Set(base::VectorOf(elements), zone);\n            }\n            static WordType Set(const std::initializer_list<word_t>& elements,\n                                Zone* zone) {\n                return Set(base::VectorOf(elements), zone);\n            }\n            static WordType Set(base::Vector<const word_t> elements, Zone* zone) {\n                DCHECK(detail::is_unique_and_sorted(elements));\n                DCHECK_IMPLIES(elements.size() > kMaxInlineSetSize, zone != nullptr);\n                DCHECK_GT(elements.size(), 0);\n                DCHECK_LE(elements.size(), kMaxSetSize);\n\n                if (elements.size() <= kMaxInlineSetSize) {\n                // Use inline storage.\n                Payload_InlineSet p;\n                DCHECK_LT(0, elements.size());\n                p.elements[0] = elements[0];\n                if (elements.size() > 1) p.elements[1] = elements[1];\n                return WordType{SubKind::kSet, static_cast<uint8_t>(elements.size()), p};\n                } else {\n                // Allocate storage in the zone.\n#if defined(__GNUC__) && !defined(__clang__)\n                // Work around a spurious GCC-12 warning. The DCHECK above already\n                // checks the right precondition.\n                if (zone == nullptr) return WordType::Any();\n#endif\n                Payload_OutlineSet p;\n                p.array = zone->AllocateArray<word_t>(elements.size());\n                DCHECK_NOT_NULL(p.array);\n                for (size_t i = 0; i < elements.size(); ++i) p.array[i] = elements[i];\n                return WordType{SubKind::kSet, static_cast<uint8_t>(elements.size()), p};\n                }\n            }\n            static WordType Constant(word_t constant) { return Set({constant}, nullptr); }\n\n            // Checks\n            bool is_range() const { return sub_kind() == SubKind::kRange; }\n            bool is_set() const { return sub_kind() == SubKind::kSet; }\n            bool is_any() const { return is_range() && range_to() + 1 == range_from(); }\n            bool is_constant() const {\n                DCHECK_EQ(set_size_ > 0, is_set());\n                return set_size_ == 1;\n            }\n            bool is_wrapping() const { return is_range() && range_from() > range_to(); }\n\n            // Accessors\n            word_t range_from() const {\n                DCHECK(is_range());\n                return get_payload<Payload_Range>().min;\n            }\n            word_t range_to() const {\n                DCHECK(is_range());\n                return get_payload<Payload_Range>().max;\n            }\n            std::pair<word_t, word_t> range() const {\n                DCHECK(is_range());\n                return {range_from(), range_to()};\n            }\n            int set_size() const {\n                DCHECK(is_set());\n                return static_cast<int>(set_size_);\n            }\n            word_t set_element(int index) const {\n                DCHECK(is_set());\n                DCHECK_GE(index, 0);\n                DCHECK_LT(index, set_size());\n                return set_elements()[index];\n            }\n            base::Vector<const word_t> set_elements() const {\n                DCHECK(is_set());\n                if (set_size() <= kMaxInlineSetSize) {\n                return base::Vector<const word_t>(\n                    get_payload<Payload_InlineSet>().elements, set_size());\n                } else {\n                return base::Vector<const word_t>(get_payload<Payload_OutlineSet>().array,\n                                                set_size());\n                }\n            }\n            std::optional<word_t> try_get_constant() const {\n                if (!is_constant()) return std::nullopt;\n                DCHECK(is_set());\n                DCHECK_EQ(set_size(), 1);\n                return set_element(0);\n            }\n            bool is_constant(word_t value) const {\n                if (auto c = try_get_constant()) return *c == value;\n                return false;\n            }\n            word_t unsigned_min() const {\n                switch (sub_kind()) {\n                case SubKind::kRange:\n                    return is_wrapping() ? word_t{0} : range_from();\n                case SubKind::kSet:\n                    return set_element(0);\n                }\n            }\n            word_t unsigned_max() const {\n                switch (sub_kind()) {\n                case SubKind::kRange:\n                    return is_wrapping() ? std::numeric_limits<word_t>::max() : range_to();\n                case SubKind::kSet:\n                    DCHECK_GE(set_size(), 1);\n                    return set_element(set_size() - 1);\n                }\n            }\n\n            // Misc\n            bool Contains(word_t value) const;\n            bool Equals(const WordType& other) const;\n            bool IsSubtypeOf(const WordType& other) const;\n            static WordType LeastUpperBound(const WordType& lhs, const WordType& rhs,\n                                            Zone* zone);\n            static Type Intersect(const WordType& lhs, const WordType& rhs,\n                                    ResolutionMode resolution_mode, Zone* zone);\n            void PrintTo(std::ostream& stream) const;\n            Handle<TurboshaftType> AllocateOnHeap(Factory* factory) const;\n\n            private:\n            static constexpr Kind KIND = Bits == 32 ? Kind::kWord32 : Kind::kWord64;\n            using Payload_Range = detail::Payload_Range<word_t>;\n            using Payload_InlineSet = detail::Payload_InlineSet<word_t>;\n            using Payload_OutlineSet = detail::Payload_OutlineSet<word_t>;\n\n            SubKind sub_kind() const { return static_cast<SubKind>(sub_kind_); }\n            template <typename Payload>\n            WordType(SubKind sub_kind, uint8_t set_size, const Payload& payload)\n                : Type(KIND, static_cast<uint8_t>(sub_kind), set_size, 0, 0, payload) {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FloatType\",\n                \"about\": \"Represents a floating-point type (32-bit or 64-bit) with support for ranges, sets of values, and special values like NaN and minus zero.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Type\",\n                    \"Payload_Range\",\n                    \"Payload_InlineSet\",\n                    \"Payload_OutlineSet\",\n                    \"Payload_Empty\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <size_t Bits>\n            class FloatType : public Type {\n            static_assert(Bits == 32 || Bits == 64);\n            friend class Type;\n            static constexpr int kMaxInlineSetSize = 2;\n\n            enum class SubKind : uint8_t {\n                kRange,\n                kSet,\n                kOnlySpecialValues,\n            };\n\n            public:\n            static constexpr int kMaxSetSize = 8;\n            using float_t = float_type<Bits>;\n            using value_type = float_t;\n\n            enum Special : uint32_t {\n                kNoSpecialValues = 0x0,\n                kNaN = 0x1,\n                kMinusZero = 0x2,\n            };\n\n            // Constructors\n            static FloatType OnlySpecialValues(uint32_t special_values) {\n                DCHECK_NE(0, special_values);\n                return FloatType{SubKind::kOnlySpecialValues, 0, special_values,\n                                Payload_OnlySpecial{}};\n            }\n            static FloatType NaN() {\n                return FloatType{SubKind::kOnlySpecialValues, 0, Special::kNaN,\n                                Payload_OnlySpecial{}};\n            }\n            static FloatType MinusZero() {\n                return FloatType{SubKind::kOnlySpecialValues, 0, Special::kMinusZero,\n                                Payload_OnlySpecial{}};\n            }\n            static FloatType Any(uint32_t special_values = Special::kNaN |\n                                                        Special::kMinusZero) {\n                return FloatType::Range(-std::numeric_limits<float_t>::infinity(),\n                                        std::numeric_limits<float_t>::infinity(),\n                                        special_values, nullptr);\n            }\n            static FloatType Range(float_t min, float_t max, Zone* zone) {\n                return Range(min, max, Special::kNoSpecialValues, zone);\n            }\n            static FloatType Range(float_t min, float_t max, uint32_t special_values,\n                                Zone* zone) {\n                special_values |= IdentifyMinusZero(min);\n                special_values |= IdentifyMinusZero(max);\n                DCHECK(!detail::is_float_special_value(min));\n                DCHECK(!detail::is_float_special_value(max));\n                DCHECK_LE(min, max);\n                if (min == max) return Set({min}, special_values, zone);\n                return FloatType{SubKind::kRange, 0, special_values,\n                                Payload_Range{min, max}};\n            }\n            template <size_t N>\n            static FloatType Set(const base::SmallVector<const float_t, N>& elements,\n                                Zone* zone) {\n                return Set(elements, Special::kNoSpecialValues, zone);\n            }\n            template <size_t N>\n            static FloatType Set(const base::SmallVector<float_t, N>& elements,\n                                uint32_t special_values, Zone* zone) {\n                return Set(base::VectorOf(elements), special_values, zone);\n            }\n            static FloatType Set(const std::initializer_list<float_t>& elements,\n                                uint32_t special_values, Zone* zone) {\n                return Set(base::VectorOf(elements), special_values, zone);\n            }\n            static FloatType Set(const std::vector<float_t>& elements, Zone* zone) {\n                return Set(elements, Special::kNoSpecialValues, zone);\n            }\n            static FloatType Set(const std::vector<float_t>& elements,\n                                uint32_t special_values, Zone* zone) {\n                return Set(base::VectorOf(elements), special_values, zone);\n            }\n            static FloatType Set(base::Vector<const float_t> elements,\n                                uint32_t special_values, Zone* zone) {\n                DCHECK(detail::is_unique_and_sorted(elements));\n                // NaN should be passed via {special_values} rather than {elements}.\n                DCHECK(base::none_of(elements, [](float_t f) { return std::isnan(f); }));\n                DCHECK_IMPLIES(elements.size() > kMaxInlineSetSize, zone != nullptr);\n                DCHECK_GT(elements.size(), 0);\n                DCHECK_LE(elements.size(), kMaxSetSize);\n\n                if (elements.size() <= kMaxInlineSetSize) {\n                // Use inline storage.\n                Payload_InlineSet p;\n                DCHECK_LT(0, elements.size());\n                p.elements[0] = elements[0];\n                special_values |= IdentifyMinusZero(p.elements[0]);\n                if (elements.size() > 1) {\n                    p.elements[1] = elements[1];\n                    special_values |= IdentifyMinusZero(p.elements[1]);\n                }\n                return FloatType{SubKind::kSet, static_cast<uint8_t>(elements.size()),\n                                special_values, p};\n                } else {\n                // Allocate storage in the zone.\n                Payload_OutlineSet p;\n                p.array = zone->AllocateArray<float_t>(elements.size());\n                DCHECK_NOT_NULL(p.array);\n                for (size_t i = 0; i < elements.size(); ++i) {\n                    p.array[i] = elements[i];\n                    special_values |= IdentifyMinusZero(p.array[i]);\n                }\n                return FloatType{SubKind::kSet, static_cast<uint8_t>(elements.size()),\n                                special_values, p};\n                }\n            }\n            static FloatType Constant(float_t constant) {\n                return Set({constant}, 0, nullptr);\n            }\n\n            // Checks\n            bool is_only_special_values() const {\n                return sub_kind() == SubKind::kOnlySpecialValues;\n            }\n            bool is_only_nan() const {\n                return is_only_special_values() && (special_values() == Special::kNaN);\n            }\n            bool is_only_minus_zero() const {\n                return is_only_special_values() &&\n                    (special_values() == Special::kMinusZero);\n            }\n            bool is_range() const { return sub_kind() == SubKind::kRange; }\n            bool is_set() const { return sub_kind() == SubKind::kSet; }\n            bool is_any() const {\n                return is_range() &&\n                    range_min() == -std::numeric_limits<float_t>::infinity() &&\n                    range_max() == std::numeric_limits<float_t>::infinity();\n            }\n            bool is_constant() const {\n                DCHECK_EQ(set_size_ > 0, is_set());\n                return set_size_ == 1 && !has_special_values();\n            }\n            uint32_t special_values() const { return bitfield_; }\n            bool has_special_values() const { return special_values() != 0; }\n            bool has_nan() const { return (special_values() & Special::kNaN) != 0; }\n            bool has_minus_zero() const {\n                return (special_values() & Special::kMinusZero) != 0;\n            }\n\n            // Accessors\n            float_t range_min() const {\n                DCHECK(is_range());\n                return get_payload<Payload_Range>().min;\n            }\n            float_t range_max() const {\n                DCHECK(is_range());\n                return get_payload<Payload_Range>().max;\n            }\n            std::pair<float_t, float_t> range() const {\n                DCHECK(is_range());\n                return {range_min(), range_max()};\n            }\n            int set_size() const {\n                DCHECK(is_set());\n                return static_cast<int>(set_size_);\n            }\n            float_t set_element(int index) const {\n                DCHECK(is_set());\n                DCHECK_GE(index, 0);\n                DCHECK_LT(index, set_size());\n                return set_elements()[index];\n            }\n            base::Vector<const float_t> set_elements() const {\n                DCHECK(is_set());\n                if (set_size() <= kMaxInlineSetSize) {\n                return base::Vector<const float_t>(\n                    get_payload<Payload_InlineSet>().elements, set_size());\n                } else {\n                return base::Vector<const float_t>(\n                    get_payload<Payload_OutlineSet>().array, set_size());\n                }\n            }\n            float_t min() const {\n                switch (sub_kind()) {\n                case SubKind::"
}