{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/declarations.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/declarations.cc\",\n            \"file_name\": \"declarations.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides the Declarations class and related functions for managing and looking up Torque language declarations (types, functions, macros, etc.) within different scopes.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for declarations, standard library features, declarables, global context, server data, and the type oracle.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/declarations.h\"\n\n#include <optional>\n\n#include \"src/torque/declarable.h\"\n#include \"src/torque/global-context.h\"\n#include \"src/torque/server-data.h\"\n#include \"src/torque/type-oracle.h\"\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::internal::torque\",\n                \"purpose\": \"Encloses all Torque-related code within the V8 project.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::torque {\nnamespace {\n\ntemplate <class T>\nstd::vector<T> EnsureNonempty(std::vector<T> list, const std::string& name,\n                              const char* kind) {\n  if (list.empty()) {\n    ReportError(\"there is no \", kind, \" named \", name);\n  }\n  return std::move(list);\n}\n\ntemplate <class T, class Name>\nT EnsureUnique(const std::vector<T>& list, const Name& name, const char* kind) {\n  if (list.empty()) {\n    ReportError(\"there is no \", kind, \" named \", name);\n  }\n  if (list.size() >= 2) {\n    ReportError(\"ambiguous reference to \", kind, \" \", name);\n  }\n  return list.front();\n}\n\ntemplate <class T>\nvoid CheckAlreadyDeclared(const std::string& name, const char* new_type) {\n  std::vector<T*> declarations =\n      FilterDeclarables<T>(Declarations::TryLookupShallow(QualifiedName(name)));\n  if (!declarations.empty()) {\n    Scope* scope = CurrentScope::Get();\n    ReportError(\"cannot redeclare \", name, \" (type \", *new_type, scope, \")\");\n  }\n}\n\n}  // namespace\n\nstd::vector<Declarable*> Declarations::LookupGlobalScope(\n    const QualifiedName& name) {\n  std::vector<Declarable*> d =\n      GlobalContext::GetDefaultNamespace()->Lookup(name);\n  if (d.empty()) {\n    std::stringstream s;\n    s << \"cannot find \\\"\" << name << \"\\\" in global scope\";\n    ReportError(s.str());\n  }\n  return d;\n}\n\nconst TypeAlias* Declarations::LookupTypeAlias(const QualifiedName& name) {\n  TypeAlias* declaration =\n      EnsureUnique(FilterDeclarables<TypeAlias>(Lookup(name)), name, \"type\");\n  return declaration;\n}\n\nconst Type* Declarations::LookupType(const QualifiedName& name) {\n  return LookupTypeAlias(name)->type();\n}\n\nconst Type* Declarations::LookupType(const Identifier* name) {\n  const TypeAlias* alias = LookupTypeAlias(QualifiedName(name->value));\n  if (GlobalContext::collect_language_server_data()) {\n    LanguageServerData::AddDefinition(name->pos,\n                                      alias->GetDeclarationPosition());\n  }\n  return alias->type();\n}\n\nstd::optional<const Type*> Declarations::TryLookupType(\n    const QualifiedName& name) {\n  auto decls = FilterDeclarables<TypeAlias>(TryLookup(name));\n  if (decls.empty()) return std::nullopt;\n  return EnsureUnique(std::move(decls), name, \"type\")->type();\n}\n\nconst Type* Declarations::LookupGlobalType(const QualifiedName& name) {\n  TypeAlias* declaration = EnsureUnique(\n      FilterDeclarables<TypeAlias>(LookupGlobalScope(name)), name, \"type\");\n  return declaration->type();\n}\n\nBuiltin* Declarations::FindSomeInternalBuiltinWithType(\n    const BuiltinPointerType* type) {\n  for (auto& declarable : GlobalContext::AllDeclarables()) {\n    if (Builtin* builtin = Builtin::DynamicCast(declarable.get())) {\n      if (!builtin->IsExternal() && builtin->kind() == Builtin::kStub &&\n          builtin->signature().return_type == type->return_type() &&\n          builtin->signature().parameter_types.types ==\n              type->parameter_types()) {\n        return builtin;\n      }\n    }\n  }\n  return nullptr;\n}\n\nValue* Declarations::LookupValue(const QualifiedName& name) {\n  return EnsureUnique(FilterDeclarables<Value>(Lookup(name)), name, \"value\");\n}\n\nMacro* Declarations::TryLookupMacro(const std::string& name,\n                                    const TypeVector& types) {\n  std::vector<Macro*> macros = TryLookup<Macro>(QualifiedName(name));\n  for (auto& m : macros) {\n    auto signature_types = m->signature().GetExplicitTypes();\n    if (signature_types == types && !m->signature().parameter_types.var_args) {\n      return m;\n    }\n  }\n  return nullptr;\n}\n\nstd::optional<Builtin*> Declarations::TryLookupBuiltin(\n    const QualifiedName& name) {\n  std::vector<Builtin*> builtins = TryLookup<Builtin>(name);\n  if (builtins.empty()) return std::nullopt;\n  return EnsureUnique(builtins, name.name, \"builtin\");\n}\n\nstd::vector<GenericCallable*> Declarations::LookupGeneric(\n    const std::string& name) {\n  return EnsureNonempty(\n      FilterDeclarables<GenericCallable>(Lookup(QualifiedName(name))), name,\n      \"generic callable\");\n}\n\nGenericCallable* Declarations::LookupUniqueGeneric(const QualifiedName& name) {\n  return EnsureUnique(FilterDeclarables<GenericCallable>(Lookup(name)), name,\n                      \"generic callable\");\n}\n\nGenericType* Declarations::LookupUniqueGenericType(const QualifiedName& name) {\n  return EnsureUnique(FilterDeclarables<GenericType>(Lookup(name)), name,\n                      \"generic type\");\n}\n\nGenericType* Declarations::LookupGlobalUniqueGenericType(\n    const std::string& name) {\n  return EnsureUnique(\n      FilterDeclarables<GenericType>(LookupGlobalScope(QualifiedName(name))),\n      name, \"generic type\");\n}\n\nstd::optional<GenericType*> Declarations::TryLookupGenericType(\n    const QualifiedName& name) {\n  std::vector<GenericType*> results = TryLookup<GenericType>(name);\n  if (results.empty()) return std::nullopt;\n  return EnsureUnique(results, name.name, \"generic type\");\n}\n\nNamespace* Declarations::DeclareNamespace(const std::string& name) {\n  return Declare(name, std::make_unique<Namespace>(name));\n}\n\nTypeAlias* Declarations::DeclareType(const Identifier* name, const Type* type) {\n  CheckAlreadyDeclared<TypeAlias>(name->value, \"type\");\n  return Declare(name->value, std::unique_ptr<TypeAlias>(\n                                  new TypeAlias(type, true, name->pos)));\n}\n\nTypeAlias* Declarations::PredeclareTypeAlias(const Identifier* name,\n                                             TypeDeclaration* type,\n                                             bool redeclaration) {\n  CheckAlreadyDeclared<TypeAlias>(name->value, \"type\");\n  std::unique_ptr<TypeAlias> alias_ptr(\n      new TypeAlias(type, redeclaration, name->pos));\n  return Declare(name->value, std::move(alias_ptr));\n}\n\nTorqueMacro* Declarations::CreateTorqueMacro(\n    std::string external_name, std::string readable_name, bool exported_to_csa,\n    Signature signature, std::optional<Statement*> body, bool is_user_defined) {\n  external_name = GlobalContext::MakeUniqueName(external_name);\n  return RegisterDeclarable(std::unique_ptr<TorqueMacro>(new TorqueMacro(\n      std::move(external_name), std::move(readable_name), std::move(signature),\n      body, is_user_defined, exported_to_csa)));\n}\n\nExternMacro* Declarations::CreateExternMacro(\n    std::string name, std::string external_assembler_name,\n    Signature signature) {\n  return RegisterDeclarable(std::unique_ptr<ExternMacro>(\n      new ExternMacro(std::move(name), std::move(external_assembler_name),\n                      std::move(signature))));\n}\n\nMacro* Declarations::DeclareMacro(\n    const std::string& name, bool accessible_from_csa,\n    std::optional<std::string> external_assembler_name,\n    const Signature& signature, std::optional<Statement*> body,\n    std::optional<std::string> op, bool is_user_defined) {\n  if (Macro* existing_macro =\n          TryLookupMacro(name, signature.GetExplicitTypes())) {\n    if (existing_macro->ParentScope() == CurrentScope::Get()) {\n      ReportError(\"cannot redeclare macro \", name,\n                  \" with identical explicit parameters\");\n    }\n  }\n  Macro* macro;\n  if (external_assembler_name) {\n    macro =\n        CreateExternMacro(name, std::move(*external_assembler_name), signature);\n  } else {\n    macro = CreateTorqueMacro(name, name, accessible_from_csa, signature, body,\n                              is_user_defined);\n  }\n\n  Declare(name, macro);\n  if (op) {\n    if (TryLookupMacro(*op, signature.GetExplicitTypes())) {\n      ReportError(\"cannot redeclare operator \", name,\n                  \" with identical explicit parameters\");\n    }\n    DeclareOperator(*op, macro);\n  }\n  return macro;\n}\n\nMethod* Declarations::CreateMethod(AggregateType* container_type,\n                                   const std::string& name, Signature signature,\n                                   Statement* body) {\n  std::string generated_name = GlobalContext::MakeUniqueName(\n      \"Method_\" + container_type->SimpleName() + \"_\" + name);\n  Method* result = RegisterDeclarable(std::unique_ptr<Method>(new Method(\n      container_type, generated_name, name, std::move(signature), body)));\n  container_type->RegisterMethod(result);\n  return result;\n}\n\nIntrinsic* Declarations::CreateIntrinsic(const std::string& name,\n                                         const Signature& signature) {\n  Intrinsic* result = RegisterDeclarable(std::unique_ptr<Intrinsic>(\n      new Intrinsic(std::move(name), std::move(signature))));\n  return result;\n}\n\nIntrinsic* Declarations::DeclareIntrinsic(const std::string& name,\n                                          const Signature& signature) {\n  Intrinsic* result = CreateIntrinsic(std::move(name), std::move(signature));\n  Declare(name, result);\n  return result;\n}\n\nBuiltin* Declarations::CreateBuiltin(\n    std::string external_name, std::string readable_name, Builtin::Kind kind,\n    Builtin::Flags flags, Signature signature,\n    std::optional<std::string> use_counter_name,\n    std::optional<Statement*> body) {\n  return RegisterDeclarable(std::unique_ptr<Builtin>(new Builtin(\n      std::move(external_name), std::move(readable_name), kind, flags,\n      std::move(signature), std::move(use_counter_name), body)));\n}\n\nRuntimeFunction* Declarations::DeclareRuntimeFunction(\n    const std::string& name, const Signature& signature) {\n  CheckAlreadyDeclared<RuntimeFunction>(name, \"runtime function\");\n  return Declare(name, RegisterDeclarable(std::unique_ptr<RuntimeFunction>(\n                           new RuntimeFunction(name, signature))));\n}\n\nExternConstant* Declarations::DeclareExternConstant(Identifier* name,\n                                                    const Type* type,\n                                                    std::string value) {\n  CheckAlreadyDeclared<Value>(name->value, \"constant\");\n  return Declare(name->value, std::unique_ptr<ExternConstant>(\n                                  new ExternConstant(name, type, value)));\n}\n\nNamespaceConstant* Declarations::DeclareNamespaceConstant(Identifier* name,\n                                                          const Type* type,\n                                                          Expression* body) {\n  CheckAlreadyDeclared<Value>(name->value, \"constant\");\n  std::string external_name = GlobalContext::MakeUniqueName(name->value);\n  std::unique_ptr<NamespaceConstant> namespaceConstant(\n      new NamespaceConstant(name, std::move(external_name), type, body));\n  NamespaceConstant* result = namespaceConstant.get();\n  Declare(name->value, std::move(namespaceConstant));\n  return result;\n}\n\nGenericCallable* Declarations::DeclareGenericCallable(\n    const std::string& name, GenericCallableDeclaration* ast_node) {\n  return Declare(name, std::unique_ptr<GenericCallable>(\n                           new GenericCallable(name, ast_node)));\n}\n\nGenericType* Declarations::DeclareGenericType(\n    const std::string& name, GenericTypeDeclaration* ast_node) {\n  return Declare(name,\n                 std::unique_ptr<GenericType>(new GenericType(name, ast_node)));\n}\n\nstd::string Declarations::GetGeneratedCallableName(\n    const std::string& name, const TypeVector& specialized_types) {\n  std::string result = name;\n  for (auto type : specialized_types) {\n    result += \"_\" + type->SimpleName();\n  }\n  return result;\n}\n\nMacro* Declarations::DeclareOperator(const std::string& name, Macro* m) {\n  GlobalContext::GetDefaultNamespace()->AddDeclarable(name, m);\n  return m;\n}\n\n}  // namespace v8::internal::torque\n        ]]></code>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Declarations\",\n                    \"about\": \"Manages all declarations (types, functions, macros, etc.) in the Torque language.\",\n                    \"attributes\": [],\n                    \"dependencies\": [\n                        \"QualifiedName\",\n                        \"Declarable\",\n                        \"TypeAlias\",\n                        \"Type\",\n                        \"Identifier\",\n                        \"BuiltinPointerType\",\n                        \"Builtin\",\n                        \"Value\",\n                        \"Macro\",\n                        \"TypeVector\",\n                        \"GenericCallable\",\n                        \"GenericType\",\n                        \"Namespace\",\n                        \"TypeDeclaration\",\n                        \"Signature\",\n                        \"Statement\",\n                        \"ExternMacro\",\n                        \"Method\",\n                        \"AggregateType\",\n                        \"Intrinsic\",\n                        \"Builtin::Kind\",\n                        \"Builtin::Flags\",\n                        \"RuntimeFunction\",\n                        \"ExternConstant\",\n                        \"NamespaceConstant\",\n                        \"Expression\",\n                        \"GenericCallableDeclaration\",\n                        \"GenericTypeDeclaration\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\nclass Declarations {\n public:\n  static std::vector<Declarable*> LookupGlobalScope(\n    const QualifiedName& name);\n  static const TypeAlias* LookupTypeAlias(const QualifiedName& name);\n  static const Type* LookupType(const QualifiedName& name);\n  static const Type* LookupType(const Identifier* name);\n  static std::optional<const Type*> TryLookupType(\n    const QualifiedName& name);\n  static const Type* LookupGlobalType(const QualifiedName& name);\n  static Builtin* FindSomeInternalBuiltinWithType(\n    const BuiltinPointerType* type);\n  static Value* LookupValue(const QualifiedName& name);\n  static Macro* TryLookupMacro(const std::string& name,\n                                    const TypeVector& types);\n  static std::optional<Builtin*> TryLookupBuiltin(\n    const QualifiedName& name);\n  static std::vector<GenericCallable*> LookupGeneric(\n    const std::string& name);\n  static GenericCallable* LookupUniqueGeneric(const QualifiedName& name);\n  static GenericType* LookupUniqueGenericType(const QualifiedName& name);\n  static GenericType* LookupGlobalUniqueGenericType(\n    const std::string& name);\n  static std::optional<GenericType*> TryLookupGenericType(\n    const QualifiedName& name);\n\n  static Namespace* DeclareNamespace(const std::string& name);\n  static TypeAlias* DeclareType(const Identifier* name, const Type* type);\n  static TypeAlias* PredeclareTypeAlias(const Identifier* name,\n                                             TypeDeclaration* type,\n                                             bool redeclaration);\n  static TorqueMacro* CreateTorqueMacro(\n    std::string external_name, std::string readable_name, bool exported_to_csa,\n    Signature signature, std::optional<Statement*> body, bool is_user_defined);\n  static ExternMacro* CreateExternMacro(\n    std::string name, std::string external_assembler_name,\n    Signature signature);\n  static Macro* DeclareMacro(\n    const std::string& name, bool accessible_from_csa,\n    std::optional<std::string> external_assembler_name,\n    const Signature& signature, std::optional<Statement*> body,\n    std::optional<std::string> op, bool is_user_defined);\n  static Method* CreateMethod(AggregateType* container_type,\n                                   const std::string& name, Signature signature,\n                                   Statement* body);\n  static Intrinsic* CreateIntrinsic(const std::string& name,\n                                         const Signature& signature);\n  static Intrinsic* DeclareIntrinsic(const std::string& name,\n                                          const Signature& signature);\n  static Builtin* CreateBuiltin(\n    std::string external_name, std::string readable_name, Builtin::Kind kind,\n    Builtin::Flags flags, Signature signature,\n    std::optional<std::string> use_counter_name,\n    std::optional<Statement*> body);\n  static RuntimeFunction* DeclareRuntimeFunction(\n    const std::string& name, const Signature& signature);\n  static ExternConstant* DeclareExternConstant(Identifier* name,\n                                                    const Type* type,\n                                                    std::string value);\n  static NamespaceConstant* DeclareNamespaceConstant(Identifier* name,\n                                                          const Type* type,\n                                                          Expression* body);\n  static GenericCallable* DeclareGenericCallable(\n    const std::string& name, GenericCallableDeclaration* ast_node);\n  static GenericType* DeclareGenericType(\n    const std::string& name, GenericTypeDeclaration* ast_node);\n\n  static std::string GetGeneratedCallableName(\n    const std::string& name, const TypeVector& specialized_types);\n private:\n  static Macro* DeclareOperator(const std::string& name, Macro* m);\n};\n            ]]></code>\n        </class>\n    </namespace>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"QualifiedName\",\n                    \"about\": \"Represents a qualified name (e.g., namespace::name).\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class QualifiedName {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Declarable\",\n                    \"about\": \"Base class for all declarable entities (types, functions, etc.).\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Declarable {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TypeAlias\",\n                    \"about\": \"Represents an alias for a type.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class TypeAlias {\n                public:\n                  const Type* type() const;\n                  SourcePosition GetDeclarationPosition() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Type\",\n                    \"about\": \"Represents a type.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Type {\n                  public:\n                    std::string SimpleName() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Identifier\",\n                    \"about\": \"Represents an identifier (e.g., a variable name).\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Identifier {\n                  public:\n                    std::string value;\n                    SourcePosition pos;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"BuiltinPointerType\",\n                    \"about\": \"Represents a pointer to a builtin function.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class BuiltinPointerType {\n                  public:\n                    const Type* return_type() const;\n                    const TypeVector& parameter_types() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Builtin\",\n                    \"about\": \"Represents a builtin function.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Builtin : public Declarable {\n                  public:\n                    enum Kind { kStub };\n                    bool IsExternal() const;\n                    Kind kind() const;\n                    const Signature& signature() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Value\",\n                    \"about\": \"Represents a value (e.g., a constant).\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Value {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Macro\",\n                    \"about\": \"Represents a macro.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Macro : public Declarable {\n                 public:\n                  const Signature& signature() const;\n                  Scope* ParentScope() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TypeVector\",\n                    \"about\": \"Represents a vector of types.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class TypeVector {\n                  public:\n                    bool var_args;\n                    std::vector<const Type*> types;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"GenericCallable\",\n                    \"about\": \"Represents a generic callable.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class GenericCallable {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"GenericType\",\n                    \"about\": \"Represents a generic type.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class GenericType {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Namespace\",\n                    \"about\": \"Represents a namespace.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Namespace {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TypeDeclaration\",\n                    \"about\": \"Represents a type declaration.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class TypeDeclaration {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Signature\",\n                    \"about\": \"Represents the signature of a function or macro.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Signature {\n                  public:\n                    TypeVector GetExplicitTypes() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Statement\",\n                    \"about\": \"Represents a statement in the Torque language.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Statement {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ExternMacro\",\n                    \"about\": \"Represents an external macro.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ExternMacro {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Method\",\n                    \"about\": \"Represents a method.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Method {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"AggregateType\",\n                    \"about\": \"Represents an aggregate type (e.g., a struct or class).\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class AggregateType {\n                  public:\n                    std::string SimpleName() const;\n                    void RegisterMethod(Method* method);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Intrinsic\",\n                    \"about\": \"Represents an intrinsic function.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Intrinsic {};\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"Builtin::Kind\",\n                    \"about\": \"Represents the kind of a builtin function.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum class Kind { kStub };\n            ]]></code>\n        </enum>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"Builtin::Flags\",\n                    \"about\": \"Represents flags for a builtin function.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum class Flags {};\n            ]]></code>\n        </enum>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RuntimeFunction\",\n                    \"about\": \"Represents a runtime function.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class RuntimeFunction {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ExternConstant\",\n                    \"about\": \"Represents an external constant.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ExternConstant {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NamespaceConstant\",\n                    \"about\": \"Represents a constant within a namespace.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class NamespaceConstant {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Expression\",\n                    \"about\": \"Represents an expression in the Torque language.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Expression {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"GenericCallableDeclaration\",\n                    \"about\": \"Represents the declaration of a generic callable.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class GenericCallableDeclaration {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"GenericTypeDeclaration\",\n                    \"about\": \"Represents the declaration of a generic type.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class GenericTypeDeclaration {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Scope\",\n                    \"about\": \"Represents the current scope of the code.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Scope {\n                 public:\n                  static Scope* Get();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"GlobalContext\",\n                    \"about\": \"Provides access to the global context.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class GlobalContext {\n                  public:\n                    static Namespace* GetDefaultNamespace();\n                    static std::string MakeUniqueName(const std::string& name);\n                    static bool collect_language_server_data();\n                    static std::vector<std::unique_ptr<Declarable>>& AllDeclarables();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"LanguageServerData\",\n                    \"about\": \"Provides functionality to add definitions for Language Server Protocol.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class LanguageServerData {\n                  public:\n                    static void AddDefinition(SourcePosition pos, SourcePosition declaration_position);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SourcePosition\",\n                    \"about\": \"Represents a position in the source code.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class SourcePosition {};\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"ReportError\",\n                    \"about\": \"Reports an error during compilation.\",\n                    \"parameters\": [],\n                    \"return\": {\n                        \"type\": \"void\",\n                        \"description\": \"No return value.\"\n                    }\n                }\n            </metadata>\n            <code><![CDATA[\n                void ReportError(...);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"FilterDeclarables\",\n                    \"about\": \"Filters a vector of Declarables to only include a specific type.\",\n                    \"parameters\": [],\n                    \"return\": {\n                        \"type\": \"std::vector<T*>\",\n                        \"description\": \"A vector of Declarables of the specified type.\"\n                    }\n                }\n            </metadata>\n            <code><![CDATA[\n                template <class T>\n                std::vector<T*> FilterDeclarables(std::vector<Declarable*>);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"Declare\",\n                    \"about\": \"Declares a new entity in the current scope.\",\n                    \"parameters\": [],\n                    \"return\": {\n                        \"type\": \"T*\",\n                        \"description\": \"Pointer to the created and declared entity.\"\n                    }\n                }\n            </metadata>\n            <code><![CDATA[\n                template <class T>\n                T* Declare(const std::string& name, std::unique_ptr<T> declarable);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"RegisterDeclarable\",\n                    \"about\": \"Registers a new declarable entity in the global context.\",\n                    \"parameters\": [],\n                    \"return\": {\n                        \"type\": \"T*\",\n                        \"description\": \"Pointer to the created and registered entity.\"\n                    }\n                }\n            </metadata>\n            <code><![CDATA[\n                template <class T>\n                T* RegisterDeclarable(std::unique_ptr<T> declarable);\n            ]]></code>\n        </func>\n         <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"TryLookup\",\n                    \"about\": \"Tries to lookup a declarable entity by qualified name.\",\n                    \"parameters\": [],\n                    \"return\": {\n                        \"type\": \"std::vector<T*>\",\n                        \"description\": \"A vector of declarables matching the criteria.\"\n                    }\n                }\n            </metadata>\n            <code><![CDATA[\n                template <class T>\n                std::vector<T*>"
}