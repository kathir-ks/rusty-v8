{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ia32/code-generator-ia32.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ia32/code-generator-ia32.cc\",\n        \"file_name\": \"code-generator-ia32.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the IA-32 specific code generator for the V8 compiler backend.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for base utilities, code generation, architecture-specific assembly, compiler backend, object representation, and platform-specific features.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/overflowing-math.h\"\n            #include \"src/codegen/assembler-inl.h\"\n            #include \"src/codegen/callable.h\"\n            #include \"src/codegen/cpu-features.h\"\n            #include \"src/codegen/ia32/assembler-ia32.h\"\n            #include \"src/codegen/ia32/register-ia32.h\"\n            #include \"src/codegen/interface-descriptors-inl.h\"\n            #include \"src/codegen/macro-assembler.h\"\n            #include \"src/codegen/optimized-compilation-info.h\"\n            #include \"src/compiler/backend/code-generator-impl.h\"\n            #include \"src/compiler/backend/code-generator.h\"\n            #include \"src/compiler/backend/gap-resolver.h\"\n            #include \"src/compiler/node-matchers.h\"\n            #include \"src/compiler/osr.h\"\n            #include \"src/execution/frame-constants.h\"\n            #include \"src/execution/frames.h\"\n            #include \"src/heap/mutable-page-metadata.h\"\n            #include \"src/objects/smi.h\"\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/wasm/wasm-linkage.h\"\n            #include \"src/wasm/wasm-objects.h\"\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IA32OperandConverter\",\n            \"extends\": \"InstructionOperandConverter\",\n            \"about\": \"A helper class for converting InstructionOperands to IA-32 specific operands (registers, memory locations, immediates).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"InstructionOperandConverter\",\n                \"CodeGenerator\",\n                \"Instruction\",\n                \"Operand\",\n                \"Immediate\",\n                \"Register\",\n                \"XMMRegister\",\n                \"FrameOffset\",\n                \"Constant\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class IA32OperandConverter : public InstructionOperandConverter {\n            public:\n            IA32OperandConverter(CodeGenerator* gen, Instruction* instr)\n                : InstructionOperandConverter(gen, instr) {}\n\n            Operand InputOperand(size_t index, int extra = 0) {\n                return ToOperand(instr_->InputAt(index), extra);\n            }\n\n            Immediate InputImmediate(size_t index) {\n                return ToImmediate(instr_->InputAt(index));\n            }\n\n            Operand OutputOperand() { return ToOperand(instr_->Output()); }\n\n            Operand ToOperand(InstructionOperand* op, int extra = 0) {\n                if (op->IsRegister()) {\n                DCHECK_EQ(0, extra);\n                return Operand(ToRegister(op));\n                } else if (op->IsFPRegister()) {\n                DCHECK_EQ(0, extra);\n                return Operand(ToDoubleRegister(op));\n                }\n                DCHECK(op->IsStackSlot() || op->IsFPStackSlot());\n                return SlotToOperand(AllocatedOperand::cast(op)->index(), extra);\n            }\n\n            Operand SlotToOperand(int slot, int extra = 0) {\n                FrameOffset offset = frame_access_state()->GetFrameOffset(slot);\n                return Operand(offset.from_stack_pointer() ? esp : ebp,\n                               offset.offset() + extra);\n            }\n\n            Immediate ToImmediate(InstructionOperand* operand) {\n                Constant constant = ToConstant(operand);\n                switch (constant.type()) {\n                case Constant::kInt32:\n                    return Immediate(constant.ToInt32(), constant.rmode());\n                case Constant::kFloat32:\n                    return Immediate::EmbeddedNumber(constant.ToFloat32());\n                case Constant::kFloat64:\n                    return Immediate::EmbeddedNumber(constant.ToFloat64().value());\n                case Constant::kExternalReference:\n                    return Immediate(constant.ToExternalReference());\n                case Constant::kHeapObject:\n                    return Immediate(constant.ToHeapObject());\n                case Constant::kCompressedHeapObject:\n                    break;\n                case Constant::kInt64:\n                    break;\n                case Constant::kRpoNumber:\n                    return Immediate::CodeRelativeOffset(ToLabel(operand));\n                }\n                UNREACHABLE();\n            }\n\n            static size_t NextOffset(size_t* offset) {\n                size_t i = *offset;\n                (*offset)++;\n                return i;\n            }\n\n            static ScaleFactor ScaleFor(AddressingMode one, AddressingMode mode) {\n                static_assert(0 == static_cast<int>(times_1));\n                static_assert(1 == static_cast<int>(times_2));\n                static_assert(2 == static_cast<int>(times_4));\n                static_assert(3 == static_cast<int>(times_8));\n                int scale = static_cast<int>(mode - one);\n                DCHECK(scale >= 0 && scale < 4);\n                return static_cast<ScaleFactor>(scale);\n            }\n\n            Operand MemoryOperand(size_t* offset) {\n                AddressingMode mode = AddressingModeField::decode(instr_->opcode());\n                switch (mode) {\n                case kMode_MR: {\n                    Register base = InputRegister(NextOffset(offset));\n                    int32_t disp = 0;\n                    return Operand(base, disp);\n                }\n                case kMode_MRI: {\n                    Register base = InputRegister(NextOffset(offset));\n                    Constant ctant = ToConstant(instr_->InputAt(NextOffset(offset)));\n                    return Operand(base, ctant.ToInt32(), ctant.rmode());\n                }\n                case kMode_MR1:\n                case kMode_MR2:\n                case kMode_MR4:\n                case kMode_MR8: {\n                    Register base = InputRegister(NextOffset(offset));\n                    Register index = InputRegister(NextOffset(offset));\n                    ScaleFactor scale = ScaleFor(kMode_MR1, mode);\n                    int32_t disp = 0;\n                    return Operand(base, index, scale, disp);\n                }\n                case kMode_MR1I:\n                case kMode_MR2I:\n                case kMode_MR4I:\n                case kMode_MR8I: {\n                    Register base = InputRegister(NextOffset(offset));\n                    Register index = InputRegister(NextOffset(offset));\n                    ScaleFactor scale = ScaleFor(kMode_MR1I, mode);\n                    Constant ctant = ToConstant(instr_->InputAt(NextOffset(offset)));\n                    return Operand(base, index, scale, ctant.ToInt32(), ctant.rmode());\n                }\n                case kMode_M1:\n                case kMode_M2:\n                case kMode_M4:\n                case kMode_M8: {\n                    Register index = InputRegister(NextOffset(offset));\n                    ScaleFactor scale = ScaleFor(kMode_M1, mode);\n                    int32_t disp = 0;\n                    return Operand(index, scale, disp);\n                }\n                case kMode_M1I:\n                case kMode_M2I:\n                case kMode_M4I:\n                case kMode_M8I: {\n                    Register index = InputRegister(NextOffset(offset));\n                    ScaleFactor scale = ScaleFor(kMode_M1I, mode);\n                    Constant ctant = ToConstant(instr_->InputAt(NextOffset(offset)));\n                    return Operand(index, scale, ctant.ToInt32(), ctant.rmode());\n                }\n                case kMode_MI: {\n                    Constant ctant = ToConstant(instr_->InputAt(NextOffset(offset)));\n                    return Operand(ctant.ToInt32(), ctant.rmode());\n                }\n                case kMode_Root: {\n                    Register base = kRootRegister;\n                    int32_t disp = InputInt32(NextOffset(offset));\n                    return Operand(base, disp);\n                }\n                case kMode_None:\n                    UNREACHABLE();\n                }\n                UNREACHABLE();\n            }\n\n            Operand MemoryOperand(size_t first_input = 0) {\n                return MemoryOperand(&first_input);\n            }\n\n            Operand NextMemoryOperand(size_t offset = 0) {\n                AddressingMode mode = AddressingModeField::decode(instr_->opcode());\n                Register base = InputRegister(NextOffset(&offset));\n                const int32_t disp = 4;\n                if (mode == kMode_MR1) {\n                Register index = InputRegister(NextOffset(&offset));\n                ScaleFactor scale = ScaleFor(kMode_MR1, kMode_MR1);\n                return Operand(base, index, scale, disp);\n                } else if (mode == kMode_MRI) {\n                Constant ctant = ToConstant(instr_->InputAt(NextOffset(&offset)));\n                return Operand(base, ctant.ToInt32() + disp, ctant.rmode());\n                } else {\n                UNREACHABLE();\n                }\n            }\n\n            void MoveInstructionOperandToRegister(Register destination,\n                                                    InstructionOperand* op) {\n                if (op->IsImmediate() || op->IsConstant()) {\n                gen_->masm()->mov(destination, ToImmediate(op));\n                } else if (op->IsRegister()) {\n                gen_->masm()->Move(destination, ToRegister(op));\n                } else {\n                gen_->masm()->mov(destination, ToOperand(op));\n                }\n            }\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"HasAddressingMode\",\n            \"about\": \"Checks if an instruction has an addressing mode.\",\n            \"logic\": \"Returns true if the instruction's addressing mode is not kMode_None, indicating that it accesses memory.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the instruction has an addressing mode; otherwise, false.\"\n            },\n            \"dependencies\": [\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool HasAddressingMode(Instruction* instr) {\n            return instr->addressing_mode() != kMode_None;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"HasImmediateInput\",\n            \"about\": \"Checks if an instruction has an immediate input at a specific index.\",\n            \"logic\": \"Returns true if the instruction's input at the given index is an immediate value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the input to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the instruction has an immediate input at the specified index; otherwise, false.\"\n            },\n            \"dependencies\": [\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool HasImmediateInput(Instruction* instr, size_t index) {\n            return instr->InputAt(index)->IsImmediate();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"HasRegisterInput\",\n            \"about\": \"Checks if an instruction has a register input at a specific index.\",\n            \"logic\": \"Returns true if the instruction's input at the given index is a register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the input to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the instruction has a register input at the specified index; otherwise, false.\"\n            },\n            \"dependencies\": [\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool HasRegisterInput(Instruction* instr, size_t index) {\n            return instr->InputAt(index)->IsRegister();\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineLoadFloat32NaN\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"Generates out-of-line code to load a Float32 NaN value into a register.\",\n            \"attributes\": [\n                {\n                    \"name\": \"result_\",\n                    \"type\": \"XMMRegister\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The XMM register to store the NaN value.\"\n                }\n            ],\n            \"dependencies\": [\n                \"OutOfLineCode\",\n                \"CodeGenerator\",\n                \"XMMRegister\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class OutOfLineLoadFloat32NaN final : public OutOfLineCode {\n            public:\n            OutOfLineLoadFloat32NaN(CodeGenerator* gen, XMMRegister result)\n                : OutOfLineCode(gen), result_(result) {}\n\n            void Generate() final {\n                __ xorps(result_, result_);\n                __ divss(result_, result_);\n            }\n\n            private:\n            XMMRegister const result_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineLoadFloat64NaN\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"Generates out-of-line code to load a Float64 NaN value into a register.\",\n            \"attributes\": [\n                {\n                    \"name\": \"result_\",\n                    \"type\": \"XMMRegister\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The XMM register to store the NaN value.\"\n                }\n            ],\n            \"dependencies\": [\n                \"OutOfLineCode\",\n                \"CodeGenerator\",\n                \"XMMRegister\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class OutOfLineLoadFloat64NaN final : public OutOfLineCode {\n            public:\n            OutOfLineLoadFloat64NaN(CodeGenerator* gen, XMMRegister result)\n                : OutOfLineCode(gen), result_(result) {}\n\n            void Generate() final {\n                __ xorpd(result_, result_);\n                __ divsd(result_, result_);\n            }\n\n            private:\n            XMMRegister const result_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineTruncateDoubleToI\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"Generates out-of-line code to truncate a double to an integer.\",\n            \"attributes\": [\n                {\n                    \"name\": \"result_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The register to store the truncated integer value.\"\n                },\n                {\n                    \"name\": \"input_\",\n                    \"type\": \"XMMRegister\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The XMM register containing the double value.\"\n                },\n                {\n                    \"name\": \"stub_mode_\",\n                    \"type\": \"StubCallMode\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The stub call mode\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The isolate.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone.\"\n                }\n            ],\n            \"dependencies\": [\n                \"OutOfLineCode\",\n                \"CodeGenerator\",\n                \"Register\",\n                \"XMMRegister\",\n                \"StubCallMode\",\n                \"Isolate\",\n                \"Zone\",\n                \"Builtin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class OutOfLineTruncateDoubleToI final : public OutOfLineCode {\n            public:\n            OutOfLineTruncateDoubleToI(CodeGenerator* gen, Register result,\n                                        XMMRegister input, StubCallMode stub_mode)\n                : OutOfLineCode(gen),\n                result_(result),\n                input_(input),\n            #if V8_ENABLE_WEBASSEMBLY\n                stub_mode_(stub_mode),\n            #endif  // V8_ENABLE_WEBASSEMBLY\n                isolate_(gen->isolate()),\n                zone_(gen->zone()) {\n            }\n\n            void Generate() final {\n                __ AllocateStackSpace(kDoubleSize);\n                __ Movsd(MemOperand(esp, 0), input_);\n            #if V8_ENABLE_WEBASSEMBLY\n                if (stub_mode_ == StubCallMode::kCallWasmRuntimeStub) {\n                // A direct call to a builtin. Just encode the builtin index. This will be\n                // patched when the code is added to the native module and copied into\n                // wasm code space.\n                __ wasm_call(static_cast<Address>(Builtin::kDoubleToI),\n                            RelocInfo::WASM_STUB_CALL);\n            #else\n                // For balance.\n                if (false) {\n            #endif  // V8_ENABLE_WEBASSEMBLY\n                } else {\n                __ CallBuiltin(Builtin::kDoubleToI);\n                }\n                __ mov(result_, MemOperand(esp, 0));\n                __ add(esp, Immediate(kDoubleSize));\n            }\n\n            private:\n            Register const result_;\n            XMMRegister const input_;\n            #if V8_ENABLE_WEBASSEMBLY\n            StubCallMode stub_mode_;\n            #endif  // V8_ENABLE_WEBASSEMBLY\n            Isolate* isolate_;\n            Zone* zone_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineRecordWrite\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"Generates out-of-line code for performing a record write with write barrier.\",\n            \"attributes\": [\n                {\n                    \"name\": \"object_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The register containing the object being written to.\"\n                },\n                {\n                    \"name\": \"operand_\",\n                    \"type\": \"Operand\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The operand representing the memory location being written to.\"\n                },\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The register containing the value being written.\"\n                },\n                {\n                    \"name\": \"scratch0_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A scratch register for temporary storage.\"\n                },\n                {\n                    \"name\": \"scratch1_\",\n                    \"type\": \"Register\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Another scratch register for temporary storage.\"\n                },\n                {\n                    \"name\": \"mode_\",\n                    \"type\": \"RecordWriteMode\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The record write mode.\"\n                },\n                {\n                    \"name\": \"stub_mode_\",\n                    \"type\": \"StubCallMode\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The stub call mode\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone.\"\n                }\n            ],\n            \"dependencies\": [\n                \"OutOfLineCode\",\n                \"CodeGenerator\",\n                \"Register\",\n                \"Operand\",\n                \"RecordWriteMode\",\n                \"StubCallMode\",\n                \"Zone\",\n                \"MemoryChunk\",\n                \"SaveFPRegsMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class OutOfLineRecordWrite final : public OutOfLineCode {\n            public:\n            OutOfLineRecordWrite(CodeGenerator* gen, Register object, Operand operand,\n                                Register value, Register scratch0, Register scratch1,\n                                RecordWriteMode mode, StubCallMode stub_mode)\n                : OutOfLineCode(gen),\n                object_(object),\n                operand_(operand),\n                value_(value),\n                scratch0_(scratch0),\n                scratch1_(scratch1),\n                mode_(mode),\n            #if V8_ENABLE_WEBASSEMBLY\n                stub_mode_(stub_mode),\n            #endif  // V8_ENABLE_WEBASSEMBLY\n                zone_(gen->zone()) {\n                DCHECK(!AreAliased(object, scratch0, scratch1));\n                DCHECK(!AreAliased(value, scratch0, scratch1));\n            }\n\n            void Generate() final {\n                __ CheckPageFlag(value_, scratch0_,\n                                MemoryChunk::kPointersToHereAreInterestingMask, zero,\n                                exit());\n                __ lea(scratch1_, operand_);\n                SaveFPRegsMode const save_fp_mode = frame()->DidAllocateDoubleRegisters()\n                                                    ? SaveFPRegsMode::kSave\n                                                    : SaveFPRegsMode::kIgnore;\n                if (mode_ == RecordWriteMode::kValueIsEphemeronKey) {\n                __ CallEphemeronKeyBarrier(object_, scratch1_, save_fp_mode);\n            #if V8_ENABLE_WEBASSEMBLY\n                } else if (stub_mode_ == StubCallMode::kCallWasmRuntimeStub) {\n                // A direct call to a wasm runtime stub defined in this module.\n                // Just encode the stub index. This will be patched when the code\n                // is added to the native module and copied into wasm code space.\n                __ CallRecordWriteStubSaveRegisters(object_, scratch1_, save_fp_mode,\n                                                    StubCallMode::kCallWasmRuntimeStub);\n            #endif  // V8_ENABLE_WEBASSEMBLY\n                } else {\n                __ CallRecordWriteStubSaveRegisters(object_, scratch1_, save_fp_mode);\n                }\n            }\n\n            private:\n            Register const object_;\n            Operand const operand_;\n            Register const value_;\n            Register const scratch0_;\n            Register const scratch1_;\n            RecordWriteMode const mode_;\n            #if V8_ENABLE_WEBASSEMBLY\n            StubCallMode const stub_mode_;\n            #endif  // V8_ENABLE_WEBASSEMBLY\n            Zone* zone_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AdjustStackPointerForTailCall\",\n            \"about\": \"Adjusts the stack pointer for a tail call.\",\n            \"logic\": \"Calculates the difference between the current stack slot count and the desired stack slot count, and adjusts the stack pointer accordingly, allocating or deallocating stack space.\",\n            \"parameters\": [\n                {\n                    \"name\": \"masm\",\n                    \"type\": \"MacroAssembler*\",\n                    \"purpose\": \"The macro assembler to use for generating code.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"FrameAccessState*\",\n                    \"purpose\": \"The frame access state.\"\n                },\n                {\n                    \"name\": \"new_slot_above_sp\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The desired stack slot count above the stack pointer.\"\n                },\n                {\n                    \"name\": \"allow_shrinkage\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether stack shrinkage is permitted.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"MacroAssembler\",\n                \"FrameAccessState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void AdjustStackPointerForTailCall(MacroAssembler* masm,\n                                            FrameAccessState* state,\n                                            int new_slot_above_sp,\n                                            bool allow_shrinkage = true) {\n            int current_sp_offset = state->GetSPToFPSlotCount() +\n                                    StandardFrameConstants::kFixedSlotCountAboveFp;\n            int stack_slot_delta = new_slot_above_sp - current_sp_offset;\n            if (stack_slot_delta > 0) {\n                masm->AllocateStackSpace(stack_slot_delta * kSystemPointerSize);\n                state->IncreaseSPDelta(stack_slot_delta);\n            } else if (allow_shrinkage && stack_slot_delta < 0) {\n                masm->add(esp, Immediate(-stack_slot_delta * kSystemPointerSize));\n                state->IncreaseSPDelta(stack_slot_delta);\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VerifyOutputOfAtomicPairInstr\",\n            \"about\": \"Verifies the output registers of an atomic pair instruction.\",\n            \"logic\": \"Asserts that the output registers of the atomic pair instruction are eax and edx.\",\n            \"parameters\": [\n                {\n                    \"name\": \"converter\",\n                    \"type\": \"IA32OperandConverter*\",\n                    \"purpose\": \"The operand converter.\"\n                },\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"const Instruction*\",\n                    \"purpose\": \"The instruction to verify.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the output registers are valid; otherwise, false.\"\n            },\n            \"dependencies\": [\n                \"IA32OperandConverter\",\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef DEBUG\n            bool VerifyOutputOfAtomicPairInstr(IA32OperandConverter* converter,\n                                            const Instruction* instr) {\n            if (instr->OutputCount() == 2) {\n                return (converter->OutputRegister(0) == eax &&\n                        converter->OutputRegister(1) == edx);\n            }\n            if (instr->OutputCount() == 1) {\n                return (converter->OutputRegister(0) == eax &&\n                        converter->TempRegister(0) == edx) ||\n                    (converter->OutputRegister(0) == edx &&\n                        converter->TempRegister(0) == eax);\n            }\n            DCHECK_EQ(instr->OutputCount(), 0);\n            return (converter->TempRegister(0) == eax &&\n                    converter->TempRegister(1) == edx);\n            }\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleDeconstructFrame\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles code to deconstruct a stack frame, restoring the previous frame pointer and stack pointer.\",\n            \"logic\": \"Moves the base pointer (ebp) to the stack pointer (esp), effectively popping the stack frame.  Then pops the old base pointer off the stack and stores it in ebp, restoring the caller's frame.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CodeGenerator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CodeGenerator::AssembleDeconstructFrame() {\n            __ mov(esp, ebp);\n            __ pop(ebp);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssemblePrepareTailCall\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Prepares for a tail call by adjusting the frame access state.\",\n            \"logic\": \"If there's a frame, moves the frame pointer (ebp) to the saved frame pointer on the stack. Sets the frame access state to use the stack pointer (esp) directly.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CodeGenerator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CodeGenerator::AssemblePrepareTailCall() {\n            if (frame_access_state()->has_frame()) {\n                __ mov(ebp, MemOperand(ebp, 0));\n            }\n            frame_access_state()->SetFrameAccessToSP();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleTailCallBeforeGap\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles code for a tail call before a gap in the code.\",\n            \"logic\": \"Handles pushing arguments onto the stack for a tail call.  It optimizes by checking if pushes can be combined, and then calls AdjustStackPointerForTailCall to set up the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction being assembled.\"\n                },\n                {\n                    \"name\": \"first_unused_slot_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The offset of the first unused stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"Instruction\",\n                \"IA32OperandConverter\",\n                \"MoveOperands\",\n                \"LocationOperand\",\n                \"AdjustStackPointerForTailCall\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CodeGenerator::AssembleTailCallBeforeGap(Instruction* instr,\n                                                        int first_unused_slot_offset) {\n            CodeGenerator::PushTypeFlags flags(kImmediatePush | kScalarPush);\n            ZoneVector<MoveOperands*> pushes(zone());\n            GetPushCompatibleMoves(instr, flags, &pushes);\n\n            if (!pushes.empty() &&\n                (LocationOperand::cast(pushes.back()->destination()).index() + 1 ==\n                first_unused_slot_offset)) {\n                IA32OperandConverter g(this, instr);\n                for (auto move : pushes) {\n                LocationOperand destination_location(\n                    LocationOperand::cast(move->destination()));\n                InstructionOperand source(move->source());\n                AdjustStackPointerForTailCall(masm(), frame_access_state(),\n                                                destination_location.index());\n                if (source.IsStackSlot()) {\n                    LocationOperand source_location(LocationOperand::cast(source));\n                    __ push(g.SlotToOperand(source_location.index()));\n                } else if (source.IsRegister()) {\n                    LocationOperand source_location(LocationOperand::cast(source));\n                    __ push(source_location.GetRegister());\n                } else if (source.IsImmediate()) {\n                    __ Push(Immediate(ImmediateOperand::cast(source).inline_int32_value()));\n                } else {\n                    // Pushes of non-scalar data types is not supported.\n                    UNIMPLEMENTED();\n                }\n                frame_access_state()->IncreaseSPDelta(1);\n                move->Eliminate();\n                }\n            }\n            AdjustStackPointerForTailCall(masm(), frame_access_state(),\n                                        first_unused_slot_offset, false);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleTailCallAfterGap\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles code for a tail call after a gap.\",\n            \"logic\": \"Calls AdjustStackPointerForTailCall to set up the stack pointer for the tail call.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction being assembled.\"\n                },\n                {\n                    \"name\": \"first_unused_slot_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The offset of the first unused stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"Instruction\",\n                \"AdjustStackPointerFor"
}