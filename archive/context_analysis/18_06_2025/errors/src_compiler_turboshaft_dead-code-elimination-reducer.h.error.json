{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/dead-code-elimination-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 119, column 34",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/dead-code-elimination-reducer.h\",\n            \"file_name\": \"dead-code-elimination-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the DeadCodeEliminationReducer for the Turboshaft compiler pipeline. This reducer performs dead code elimination based on liveness analysis.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary standard library and V8 headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <iomanip>\n#include <optional>\n\n#include \"src/common/globals.h\"\n#include \"src/compiler/backend/instruction-codes.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/uniform-reducer-adapter.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"ControlState\",\n                \"about\": \"Represents the control state of a block during dead code analysis. It indicates whether a branch can be rewritten to a goto.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"Kind\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates the type of control state (Unreachable, Block, NotEliminatable).\"\n                    },\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"BlockIndex\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The target block index if the control state is Block.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BlockIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct ControlState {\n  // Lattice:\n  //\n  //  NotEliminatable\n  //     /  |  \\\n  //    B1 ... Bn\n  //     \\  |  /\n  //    Unreachable\n  //\n  // We use ControlState to propagate information during the analysis about how\n  // branches can be rewritten. Read the values like this:\n  // - NotEliminatable: We cannot rewrite a branch, because we need the control\n  // flow (e.g. because we have seen live operations on either branch or need\n  // the phi at the merge).\n  // - Bj: Control can be rewritten to go directly to Block Bj, because all\n  // paths to that block are free of live operations.\n  // - Unreachable: This is the bottom element and it represents that we haven't\n  // seen anything live yet and are free to rewrite branches to any block\n  // reachable from the current block.\n  enum Kind {\n    kUnreachable,\n    kBlock,\n    kNotEliminatable,\n  };\n\n  static ControlState NotEliminatable() {\n    return ControlState{kNotEliminatable};\n  }\n  static ControlState Block(BlockIndex block) {\n    return ControlState{kBlock, block};\n  }\n  static ControlState Unreachable() { return ControlState{kUnreachable}; }\n\n  explicit ControlState(Kind kind, BlockIndex block = BlockIndex::Invalid())\n      : kind(kind), block(block) {}\n\n  static ControlState LeastUpperBound(const ControlState& lhs,\n                                      const ControlState& rhs) {\n    switch (lhs.kind) {\n      case Kind::kUnreachable:\n        return rhs;\n      case Kind::kBlock: {\n        if (rhs.kind == Kind::kUnreachable) return lhs;\n        if (rhs.kind == Kind::kNotEliminatable) return rhs;\n        if (lhs.block == rhs.block) return lhs;\n        return NotEliminatable();\n      }\n      case Kind::kNotEliminatable:\n        return lhs;\n    }\n  }\n\n  Kind kind;\n  BlockIndex block;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for ControlState to allow printing ControlState objects to a stream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"stream\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"const ControlState&\",\n                        \"purpose\": \"The ControlState object to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ninline std::ostream& operator<<(std::ostream& stream,\n                                const ControlState& state) {\n  switch (state.kind) {\n    case ControlState::kNotEliminatable:\n      return stream << \"NotEliminatable\";\n    case ControlState::kBlock:\n      return stream << \"Block(\" << state.block << \")\";\n    case ControlState::kUnreachable:\n      return stream << \"Unreachable\";\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Overloads the == operator for ControlState to allow comparing ControlState objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"const ControlState&\",\n                        \"purpose\": \"The left-hand side ControlState.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"const ControlState&\",\n                        \"purpose\": \"The right-hand side ControlState.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the ControlStates are equal, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ninline bool operator==(const ControlState& lhs, const ControlState& rhs) {\n  if (lhs.kind != rhs.kind) return false;\n  if (lhs.kind == ControlState::kBlock) {\n    DCHECK_EQ(rhs.kind, ControlState::kBlock);\n    return lhs.block == rhs.block;\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator!=\",\n                \"about\": \"Overloads the != operator for ControlState to allow comparing ControlState objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"const ControlState&\",\n                        \"purpose\": \"The left-hand side ControlState.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"const ControlState&\",\n                        \"purpose\": \"The right-hand side ControlState.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the ControlStates are not equal, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ninline bool operator!=(const ControlState& lhs, const ControlState& rhs) {\n  return !(lhs == rhs);\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"OperationState\",\n                \"about\": \"Represents the liveness state of an operation during dead code analysis.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstruct OperationState {\n  // Lattice:\n  //\n  //   Live\n  //    |\n  //   Dead\n  //\n  // Describes the liveness state of an operation.\n  enum Liveness : uint8_t {\n    kDead,\n    kLive,\n  };\n\n  static Liveness LeastUpperBound(Liveness lhs, Liveness rhs) {\n    static_assert(kDead == 0 && kLive == 1);\n    return static_cast<Liveness>(lhs | rhs);\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for OperationState::Liveness to allow printing Liveness objects to a stream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"stream\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"liveness\",\n                        \"type\": \"OperationState::Liveness\",\n                        \"purpose\": \"The Liveness object to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ninline std::ostream& operator<<(std::ostream& stream,\n                                OperationState::Liveness liveness) {\n  switch (liveness) {\n    case OperationState::kDead:\n      return stream << \"Dead\";\n    case OperationState::kLive:\n      return stream << \"Live\";\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DeadCodeAnalysis\",\n                \"about\": \"Performs dead code analysis on a Turboshaft graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"Graph&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to the Turboshaft graph being analyzed.\"\n                    },\n                    {\n                        \"name\": \"liveness_\",\n                        \"type\": \"FixedOpIndexSidetable<OperationState::Liveness>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the liveness state of each operation.\"\n                    },\n                    {\n                        \"name\": \"entry_control_state_\",\n                        \"type\": \"FixedBlockSidetable<ControlState>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the control state at the entry of each block.\"\n                    },\n                    {\n                        \"name\": \"rewritable_branch_targets_\",\n                        \"type\": \"SparseOpIndexSideTable<BlockIndex>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the target block for branches that can be rewritten to gotos.\"\n                    },\n                    {\n                        \"name\": \"is_leaf_function_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the function is a leaf function.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Graph\",\n                    \"Zone\",\n                    \"FixedOpIndexSidetable\",\n                    \"OperationState\",\n                    \"FixedBlockSidetable\",\n                    \"ControlState\",\n                    \"SparseOpIndexSideTable\",\n                    \"BlockIndex\",\n                    \"Block\",\n                    \"Operation\",\n                    \"CallOp\",\n                    \"BranchOp\",\n                    \"GotoOp\",\n                    \"PhiOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass DeadCodeAnalysis {\n public:\n  explicit DeadCodeAnalysis(Graph& graph, Zone* phase_zone)\n      : graph_(graph),\n        liveness_(graph.op_id_count(), OperationState::kDead, phase_zone,\n                  &graph),\n        entry_control_state_(graph.block_count(), ControlState::Unreachable(),\n                             phase_zone),\n        rewritable_branch_targets_(phase_zone, &graph) {}\n\n  template <bool trace_analysis>\n  std::pair<FixedOpIndexSidetable<OperationState::Liveness>,\n            SparseOpIndexSideTable<BlockIndex>>\n  Run() {\n    if constexpr (trace_analysis) {\n      std::cout << \"===== Running Dead Code Analysis =====\\n\";\n    }\n    for (uint32_t unprocessed_count = graph_.block_count();\n         unprocessed_count > 0;) {\n      BlockIndex block_index = static_cast<BlockIndex>(unprocessed_count - 1);\n      --unprocessed_count;\n\n      const Block& block = graph_.Get(block_index);\n      ProcessBlock<trace_analysis>(block, &unprocessed_count);\n    }\n\n    if constexpr (trace_analysis) {\n      std::cout << \"===== Results =====\\n== Operation State ==\\n\";\n      for (Block b : graph_.blocks()) {\n        std::cout << PrintAsBlockHeader{b} << \":\\n\";\n        for (OpIndex index : graph_.OperationIndices(b)) {\n          std::cout << \" \" << std::setw(8) << liveness_[index] << \" \"\n                    << std::setw(3) << index.id() << \": \" << graph_.Get(index)\n                    << \"\\n\";\n        }\n      }\n\n      std::cout << \"== Rewritable Branches ==\\n\";\n      for (auto [branch_id, target] : rewritable_branch_targets_) {\n        DCHECK(target.valid());\n        std::cout << \" \" << std::setw(3) << branch_id << \": Branch ==> Goto \"\n                  << target.id() << \"\\n\";\n      }\n      std::cout << \"==========\\n\";\n    }\n\n    return {std::move(liveness_), std::move(rewritable_branch_targets_)};\n  }\n\n  template <bool trace_analysis>\n  void ProcessBlock(const Block& block, uint32_t* unprocessed_count) {\n    if constexpr (trace_analysis) {\n      std::cout << \"\\n==========\\n=== Processing \" << PrintAsBlockHeader{block}\n                << \":\\n==========\\nEXIT CONTROL STATE\\n\";\n    }\n    auto successors = SuccessorBlocks(block.LastOperation(graph_));\n    ControlState control_state = ControlState::Unreachable();\n    for (size_t i = 0; i < successors.size(); ++i) {\n      const auto& r = entry_control_state_[successors[i]->index()];\n      if constexpr (trace_analysis) {\n        std::cout << \" Successor \" << successors[i]->index() << \": \" << r\n                  << \"\\n\";\n      }\n      control_state = ControlState::LeastUpperBound(control_state, r);\n    }\n    if constexpr (trace_analysis)\n      std::cout << \"Combined: \" << control_state << \"\\n\";\n\n    // If control_state == ControlState::Block(b), then the merge block b is\n    // reachable through every path starting at the current block without any\n    // live operations.\n\n    if constexpr (trace_analysis) std::cout << \"OPERATION STATE\\n\";\n    auto op_range = graph_.OperationIndices(block);\n    bool has_live_phis = false;\n    for (auto it = op_range.end(); it != op_range.begin();) {\n      --it;\n      OpIndex index = *it;\n      const Operation& op = graph_.Get(index);\n      if constexpr (trace_analysis) std::cout << index << \":\" << op << \"\\n\";\n      OperationState::Liveness op_state = liveness_[index];\n\n      if (op.Is<DeadOp>()) {\n        // Operation is already recognized as dead by a previous analysis.\n        DCHECK_EQ(op_state, OperationState::kDead);\n      } else if (op.Is<CallOp>()) {\n        // The function contains a call, so it's not a leaf function.\n        is_leaf_function_ = false;\n      } else if (op.Is<BranchOp>() || op.Is<GotoOp>()) {\n        if (control_state != ControlState::NotEliminatable()) {\n          // Branch is still dead.\n          DCHECK_EQ(op_state, OperationState::kDead);\n          // If we know a target block we can rewrite into a goto.\n          if (control_state.kind == ControlState::kBlock) {\n            BlockIndex target = control_state.block;\n            DCHECK(target.valid());\n            rewritable_branch_targets_[index] = target;\n          }\n        } else {\n          // Branch is live. We cannot rewrite it.\n          op_state = OperationState::kLive;\n          rewritable_branch_targets_.remove(index);\n        }\n      } else if (op.IsRequiredWhenUnused()) {\n        op_state = OperationState::kLive;\n      } else if (op.Is<PhiOp>()) {\n        has_live_phis = has_live_phis || (op_state == OperationState::kLive);\n\n        if (block.IsLoop()) {\n          const PhiOp& phi = op.Cast<PhiOp>();\n          // Check if the operation state of the input coming from the backedge\n          // changes the liveness of the phi. In that case, trigger a revisit of\n          // the loop.\n          if (liveness_[phi.inputs()[PhiOp::kLoopPhiBackEdgeIndex]] <\n              op_state) {\n            if constexpr (trace_analysis) {\n              std::cout\n                  << \"Operation state has changed. Need to revisit loop.\\n\";\n            }\n            Block* backedge = block.LastPredecessor();\n            // Revisit the loop by increasing the {unprocessed_count} to include\n            // all blocks of the loop.\n            *unprocessed_count =\n                std::max(*unprocessed_count, backedge->index().id() + 1);\n          }\n        }\n      }\n\n      // TODO(nicohartmann@): Handle Stack Guards to allow elimination of\n      // otherwise empty loops.\n      //\n      // if(const CallOp* call = op.TryCast<CallOp>()) {\n      //   if(std::string(call->descriptor->descriptor->debug_name())\n      //     == \"StackGuard\") {\n      //       DCHECK_EQ(op_state, OperationState::kLive);\n      //       op_state = OperationState::kWeakLive;\n      //     }\n      // }\n\n      DCHECK_LE(liveness_[index], op_state);\n      // If everything is still dead. We don't need to update anything.\n      if (op_state == OperationState::kDead) continue;\n\n      // We have a live operation.\n      if constexpr (trace_analysis) {\n        std::cout << \" \" << op_state << \" <== \" << liveness_[index] << \"\\n\";\n      }\n      liveness_[index] = op_state;\n\n      if constexpr (trace_analysis) {\n        if (op.input_count > 0) std::cout << \" Updating inputs:\\n\";\n      }\n      for (OpIndex input : op.inputs()) {\n        auto old_input_state = liveness_[input];\n        auto new_input_state =\n            OperationState::LeastUpperBound(old_input_state, op_state);\n        if constexpr (trace_analysis) {\n          std::cout << \"  \" << input << \": \" << new_input_state\n                    << \" <== \" << old_input_state << \" || \" << op_state << \"\\n\";\n        }\n        liveness_[input] = new_input_state;\n      }\n\n      if (op_state == OperationState::kLive &&\n          control_state != ControlState::NotEliminatable()) {\n        // This block has live operations, which means that we can't skip it.\n        // Reset the ControlState to NotEliminatable.\n        if constexpr (trace_analysis) {\n          std::cout << \"Block has live operations. New control state: \"\n                    << ControlState::NotEliminatable() << \"\\n\";\n        }\n        control_state = ControlState::NotEliminatable();\n      }\n    }\n\n    if constexpr (trace_analysis) {\n      std::cout << \"ENTRY CONTROL STATE\\nAfter operations: \" << control_state\n                << \"\\n\";\n    }\n\n    // If this block is a merge and we don't have any live phis, it is a\n    // potential target for branch redirection.\n    if (block.IsMerge()) {\n      if (!has_live_phis) {\n        if (control_state.kind != ControlState::kBlock) {\n          control_state = ControlState::Block(block.index());\n          if constexpr (trace_analysis) {\n            std::cout\n                << \"Block is loop or merge and has no live phi operations.\\n\";\n          }\n        } else if constexpr (trace_analysis) {\n          std::cout << \"Block is loop or merge and has no live phi \"\n                       \"operations.\\nControl state already has a goto block: \"\n                    << control_state << \"\\n\";\n        }\n      }\n    } else if (block.IsLoop()) {\n      // If this is a loop, we reset the control state to avoid jumps into the\n      // middle of the loop. In particular, this is required to prevent\n      // introducing new backedges when blocks towards the end of the loop body\n      // want to jump to a block at the beginning (past the header).\n      control_state = ControlState::NotEliminatable();\n      if constexpr (trace_analysis) {\n        std::cout << \"Block is loop header. Resetting control state: \"\n                  << control_state << \"\\n\";\n      }\n\n      if (entry_control_state_[block.index()] != control_state) {\n        if constexpr (trace_analysis) {\n          std::cout << \"Control state has changed. Need to revisit loop.\\n\";\n        }\n        Block* backedge = block.LastPredecessor();\n        DCHECK_NOT_NULL(backedge);\n        // Revisit the loop by increasing the {unprocessed_count} to include\n        // all blocks of the loop.\n        *unprocessed_count =\n            std::max(*unprocessed_count, backedge->index().id() + 1);\n      }\n    }\n\n    if constexpr (trace_analysis) {\n      std::cout << \"Final: \" << control_state << \"\\n\";\n    }\n    entry_control_state_[block.index()] = control_state;\n  }\n\n  bool is_leaf_function() const { return is_leaf_function_; }\n\n private:\n  Graph& graph_;\n  FixedOpIndexSidetable<OperationState::Liveness> liveness_;\n  FixedBlockSidetable<ControlState> entry_control_state_;\n  SparseOpIndexSideTable<BlockIndex> rewritable_branch_targets_;\n  // The stack check at function entry of leaf functions can be eliminated, as\n  // it is guaranteed that another stack check will be hit eventually. This flag\n  // records if the current function is a leaf function.\n  bool is_leaf_function_ = true;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DeadCodeEliminationReducer\",\n                \"extends\": \"UniformReducerAdapter<DeadCodeEliminationReducer, Next>\",\n                \"about\": \"A reducer that eliminates dead code from a Turboshaft graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"liveness_\",\n                        \"type\": \"std::optional<FixedOpIndexSidetable<OperationState::Liveness>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Optional side table storing the liveness of each operation.\"\n                    },\n                    {\n                        \"name\": \"branch_rewrite_targets_\",\n                        \"type\": \"SparseOpIndexSideTable<BlockIndex>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Side table storing the target blocks for branches that can be rewritten.\"\n                    },\n                    {\n                        \"name\": \"analyzer_\",\n                        \"type\": \"DeadCodeAnalysis\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The DeadCodeAnalysis object used to analyze the graph.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"UniformReducerAdapter\",\n                    \"DeadCodeAnalysis\",\n                    \"FixedOpIndexSidetable\",\n                    \"OperationState\",\n                    \"SparseOpIndexSideTable\",\n                    \"BlockIndex\",\n                    \"Assembler\",\n                    \"BranchOp\",\n                    \"GotoOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass DeadCodeEliminationReducer\n    : public UniformReducerAdapter<DeadCodeEliminationReducer, Next> {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(DeadCodeElimination)\n\n  using Adapter = UniformReducerAdapter<DeadCodeEliminationReducer, Next>;\n\n  // DeadCodeElimination can change the control flow in somewhat unexpected ways\n  // (ie, a block with a single predecessor in the input graph can end up with\n  // multiple predecessors in the output graph), so we prevent the CopyingPhase\n  // from automatically inlining blocks with a single predecessor when we run\n  // the DeadCodeEliminationReducer.\n  bool CanAutoInlineBlocksWithSinglePredecessor() const { return false; }\n\n  void Analyze() {\n    // TODO(nicohartmann@): We might want to make this a flag.\n    constexpr bool trace_analysis = false;\n    std::tie(liveness_, branch_rewrite_targets_) =\n        analyzer_.Run<trace_analysis>();\n    Next::Analyze();\n  }\n\n  V<None> REDUCE_INPUT_GRAPH(Branch)(V<None> ig_index, const BranchOp& branch) {\n    if (TryRewriteBranch(ig_index)) return V<None>::Invalid();\n    return Next::ReduceInputGraphBranch(ig_index, branch);\n  }\n\n  V<None> REDUCE_INPUT_GRAPH(Goto)(V<None> ig_index, const GotoOp& gto) {\n    if (TryRewriteBranch(ig_index)) return {};\n    return Next::ReduceInputGraphGoto(ig_index, gto);\n  }\n\n  template <typename Op, typename Continuation>\n  OpIndex ReduceInputGraphOperation(OpIndex ig_index, const Op& op) {\n    if ((*liveness_)[ig_index] == OperationState::kDead) {\n      return OpIndex::Invalid();\n    }\n    return Continuation{this}.ReduceInputGraph(ig_index, op);\n  }\n\n  bool IsLeafFunction() const { return analyzer_.is_leaf_function(); }\n\n private:\n  bool TryRewriteBranch(OpIndex index) {\n    const BlockIndex* goto_target;\n    if (branch_rewrite_targets_.contains(index, &goto_target)) {\n      Asm().Goto(Asm().MapToNewGraph(&Asm().input_graph().Get(*goto_target)));\n      return true;\n    }\n    return false;\n  }\n  std::optional<FixedOpIndexSidetable<OperationState::Liveness>> liveness_;\n  SparseOpIndexSideTable<BlockIndex> branch_rewrite_targets_{\n      Asm().phase_zone(), &Asm().input_graph()};\n  DeadCodeAnalysis analyzer_{Asm().modifiable_input_graph(),\n                             Asm().phase_zone()};\n};\n        ]]></code>\n    </class>\n</file>\n```"
}