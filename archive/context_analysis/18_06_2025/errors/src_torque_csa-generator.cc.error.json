{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/csa-generator.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/csa-generator.cc\",\n            \"file_name\": \"csa-generator.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Generates CodeStubAssembler (CSA) code from Torque IR.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for CSA code generation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/csa-generator.h\"\n\n#include <optional>\n\n#include \"src/common/globals.h\"\n#include \"src/torque/global-context.h\"\n#include \"src/torque/type-oracle.h\"\n#include \"src/torque/types.h\"\n#include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CSAGenerator\",\n                \"about\": \"Generates CodeStubAssembler (CSA) code from Torque IR.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Stack\",\n                    \"Block\",\n                    \"CFG\",\n                    \"Type\",\n                    \"SourcePosition\",\n                    \"PushUninitializedInstruction\",\n                    \"PushBuiltinPointerInstruction\",\n                    \"NamespaceConstantInstruction\",\n                    \"CallIntrinsicInstruction\",\n                    \"CallCsaMacroInstruction\",\n                    \"CallCsaMacroAndBranchInstruction\",\n                    \"MakeLazyNodeInstruction\",\n                    \"CallBuiltinInstruction\",\n                    \"CallBuiltinPointerInstruction\",\n                    \"CallRuntimeInstruction\",\n                    \"BranchInstruction\",\n                    \"ConstexprBranchInstruction\",\n                    \"GotoInstruction\",\n                    \"GotoExternalInstruction\",\n                    \"ReturnInstruction\",\n                    \"PrintErrorInstruction\",\n                    \"AbortInstruction\",\n                    \"UnsafeCastInstruction\",\n                    \"LoadReferenceInstruction\",\n                    \"StoreReferenceInstruction\",\n                    \"LoadBitFieldInstruction\",\n                    \"StoreBitFieldInstruction\",\n                    \"VisitResult\",\n                    \"BitField\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::torque {\n\nclass CSAGenerator : public TorqueCodeGenerator {\n public:\n  explicit CSAGenerator(GlobalContext* context, std::ostream& decls,\n                         std::ostream& out, CFG cfg,\n                         Builtin::Kind linkage = Builtin::kNoContextJavaScript)\n      : TorqueCodeGenerator(context, decls, out),\n        cfg_(std::move(cfg)),\n        linkage_(linkage) {}\n\n  std::optional<Stack<std::string>> EmitGraph(Stack<std::string> parameters);\n\n private:\n  Stack<std::string> EmitBlock(const Block* block);\n  void EmitSourcePosition(SourcePosition pos, bool always_emit = false);\n\n  void EmitInstruction(const PushUninitializedInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const PushBuiltinPointerInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const NamespaceConstantInstruction& instruction,\n                       Stack<std::string>* stack);\n\n  std::vector<std::string> ProcessArgumentsCommon(\n      const TypeVector& parameter_types,\n      std::vector<std::string> constexpr_arguments, Stack<std::string>* stack);\n\n  void EmitInstruction(const CallIntrinsicInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const CallCsaMacroInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const CallCsaMacroAndBranchInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const MakeLazyNodeInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const CallBuiltinInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const CallBuiltinPointerInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const CallRuntimeInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const BranchInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const ConstexprBranchInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const GotoInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const GotoExternalInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const ReturnInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const PrintErrorInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const AbortInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const UnsafeCastInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const LoadReferenceInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const StoreReferenceInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const LoadBitFieldInstruction& instruction,\n                       Stack<std::string>* stack);\n  void EmitInstruction(const StoreBitFieldInstruction& instruction,\n                       Stack<std::string>* stack);\n\n  std::string PreCallableExceptionPreparation(std::optional<Block*> catch_block);\n  void PostCallableExceptionPreparation(\n      const std::string& catch_name, const Type* return_type,\n      std::optional<Block*> catch_block, Stack<std::string>* stack,\n      const std::optional<DefinitionLocation>& exception_object_definition);\n\n  static void EmitCSAValue(VisitResult result,\n                             const Stack<std::string>& values,\n                             std::ostream& out);\n\n  CFG cfg_;\n  SourcePosition previous_position_;\n  Builtin::Kind linkage_;\n};\n\n}  // namespace v8::internal::torque\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitGraph\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Emits the CodeStubAssembler (CSA) graph for a given control flow graph (CFG).\",\n                \"logic\": \"Iterates through each block in the CFG, emitting CSA code for each instruction.  Handles deferred blocks and binds labels. Redirects output to buffer declarations. Returns the stack of the last block.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"parameters\",\n                        \"type\": \"Stack<std::string>\",\n                        \"purpose\": \"Stack of parameters passed to the graph.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<Stack<std::string>>\",\n                    \"description\": \"Returns the final stack if the graph has an end block; otherwise, returns std::nullopt.\"\n                },\n                \"dependencies\": [\n                    \"Block\",\n                    \"GotoInstruction\",\n                    \"EmitInstruction\",\n                    \"BlockName\",\n                    \"SetDefinitionVariable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<Stack<std::string>> CSAGenerator::EmitGraph(\n    Stack<std::string> parameters) {\n  for (BottomOffset i = {0}; i < parameters.AboveTop(); ++i) {\n    SetDefinitionVariable(DefinitionLocation::Parameter(i.offset),\n                          parameters.Peek(i));\n  }\n\n  for (Block* block : cfg_.blocks()) {\n    if (block->IsDead()) continue;\n\n    out() << \"  compiler::CodeAssemblerParameterizedLabel<\";\n    bool first = true;\n    DCHECK_EQ(block->InputTypes().Size(), block->InputDefinitions().Size());\n    for (BottomOffset i = {0}; i < block->InputTypes().AboveTop(); ++i) {\n      if (block->InputDefinitions().Peek(i).IsPhiFromBlock(block)) {\n        if (!first) out() << \", \";\n        out() << block->InputTypes().Peek(i)->GetGeneratedTNodeTypeName();\n        first = false;\n      }\n    }\n    out() << \"> \" << BlockName(block) << \"(&ca_, compiler::CodeAssemblerLabel::\"\n          << (block->IsDeferred() ? \"kDeferred\" : \"kNonDeferred\") << \");\\n\";\n  }\n\n  EmitInstruction(GotoInstruction{cfg_.start()}, &parameters);\n  for (Block* block : cfg_.blocks()) {\n    if (cfg_.end() && *cfg_.end() == block) continue;\n    if (block->IsDead()) continue;\n    out() << \"\\n\";\n\n    // Redirect the output of non-declarations into a buffer and only output\n    // declarations right away.\n    std::stringstream out_buffer;\n    std::ostream* old_out = out_;\n    out_ = &out_buffer;\n\n    out() << \"  if (\" << BlockName(block) << \".is_used()) {\\n\";\n    EmitBlock(block);\n    out() << \"  }\\n\";\n\n    // All declarations have been printed now, so we can append the buffered\n    // output and redirect back to the original output stream.\n    out_ = old_out;\n    out() << out_buffer.str();\n  }\n  if (cfg_.end()) {\n    out() << \"\\n\";\n    return EmitBlock(*cfg_.end());\n  }\n  return std::nullopt;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitBlock\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Emits the CSA code for a given block.\",\n                \"logic\": \"Binds the block's label with phi-node names. Emits instructions in the block using TorqueCodeGenerator::EmitInstruction.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"const Block*\",\n                        \"purpose\": \"The block to emit code for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Stack<std::string>\",\n                    \"description\": \"Returns the stack after emitting all instructions in the block.\"\n                },\n                \"dependencies\": [\n                    \"Block\",\n                    \"EmitInstruction\",\n                    \"DefinitionToVariable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nStack<std::string> CSAGenerator::EmitBlock(const Block* block) {\n  Stack<std::string> stack;\n  std::stringstream phi_names;\n\n  for (BottomOffset i = {0}; i < block->InputTypes().AboveTop(); ++i) {\n    const auto& def = block->InputDefinitions().Peek(i);\n    stack.Push(DefinitionToVariable(def));\n    if (def.IsPhiFromBlock(block)) {\n      decls() << \"  TNode<\"\n              << block->InputTypes().Peek(i)->GetGeneratedTNodeTypeName()\n              << \"> \" << stack.Top() << \";\\n\";\n      phi_names << \", &\" << stack.Top();\n    }\n  }\n  out() << \"    ca_.Bind(&\" << BlockName(block) << phi_names.str() << \");\\n\";\n\n  for (const Instruction& instruction : block->instructions()) {\n    TorqueCodeGenerator::EmitInstruction(instruction, &stack);\n  }\n  return stack;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitSourcePosition\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Emits CSA code to set the source position in the generated code.\",\n                \"logic\": \"Compares the current source position with the previous one and emits the CSA code to set the source position only if it has changed (ignoring column numbers).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"SourcePosition\",\n                        \"purpose\": \"The source position to set.\"\n                    },\n                    {\n                        \"name\": \"always_emit\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Whether to always emit the source position, even if it hasn't changed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"SourceFileMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CSAGenerator::EmitSourcePosition(SourcePosition pos, bool always_emit) {\n  const std::string& file = SourceFileMap::AbsolutePath(pos.source);\n  if (always_emit || !previous_position_.CompareStartIgnoreColumn(pos)) {\n    // Lines in Torque SourcePositions are zero-based, while the\n    // CodeStubAssembler and downwind systems are one-based.\n    out() << \"    ca_.SetSourcePosition(\\\"\" << file << \"\\\", \"\n          << (pos.start.line + 1) << \");\\n\";\n    previous_position_ = pos;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitInstruction\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Emits CSA code for a PushUninitializedInstruction.\",\n                \"logic\": \"Pushes an uninitialized value of the specified type onto the stack.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const PushUninitializedInstruction&\",\n                        \"purpose\": \"The instruction to emit code for.\"\n                    },\n                    {\n                        \"name\": \"stack\",\n                        \"type\": \"Stack<std::string>*\",\n                        \"purpose\": \"The stack to push the value onto.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"PushUninitializedInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CSAGenerator::EmitInstruction(\n    const PushUninitializedInstruction& instruction,\n    Stack<std::string>* stack) {\n  // TODO(turbofan): This can trigger an error in CSA if it is used. Instead, we\n  // should prevent usage of uninitialized in the type system. This\n  // requires \"if constexpr\" being evaluated at Torque time.\n  const std::string str = \"ca_.Uninitialized<\" +\n                          instruction.type->GetGeneratedTNodeTypeName() + \">()\";\n  stack->Push(str);\n  SetDefinitionVariable(instruction.GetValueDefinition(), str);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitInstruction\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Emits CSA code for a PushBuiltinPointerInstruction.\",\n                \"logic\": \"Pushes a builtin pointer onto the stack. Uses ca_.SmiConstant and ca_.UncheckedCast.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const PushBuiltinPointerInstruction&\",\n                        \"purpose\": \"The instruction to emit code for.\"\n                    },\n                    {\n                        \"name\": \"stack\",\n                        \"type\": \"Stack<std::string>*\",\n                        \"purpose\": \"The stack to push the value onto.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"PushBuiltinPointerInstruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CSAGenerator::EmitInstruction(\n    const PushBuiltinPointerInstruction& instruction,\n    Stack<std::string>* stack) {\n  const std::string str =\n      \"ca_.UncheckedCast<BuiltinPtr>(ca_.SmiConstant(Builtin::k\" +\n      instruction.external_name + \"))\";\n  stack->Push(str);\n  SetDefinitionVariable(instruction.GetValueDefinition(), str);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitInstruction\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Emits CSA code for a NamespaceConstantInstruction.\",\n                \"logic\": \"Emits code to retrieve a constant from a namespace. Handles both struct and non-struct return types.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const NamespaceConstantInstruction&\",\n                        \"purpose\": \"The instruction to emit code for.\"\n                    },\n                    {\n                        \"name\": \"stack\",\n                        \"type\": \"Stack<std::string>*\",\n                        \"purpose\": \"The stack to push the value onto.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NamespaceConstantInstruction\",\n                    \"LowerType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CSAGenerator::EmitInstruction(\n    const NamespaceConstantInstruction& instruction,\n    Stack<std::string>* stack) {\n  const Type* type = instruction.constant->type();\n  std::vector<std::string> results;\n\n  const auto lowered = LowerType(type);\n  for (std::size_t i = 0; i < lowered.size(); ++i) {\n    results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));\n    stack->Push(results.back());\n    decls() << \"  TNode<\" << lowered[i]->GetGeneratedTNodeTypeName() << \"> \"\n            << stack->Top() << \";\\n\";\n  }\n\n  out() << \"    \";\n  if (type->StructSupertype()) {\n    out() << \"std::tie(\";\n    PrintCommaSeparatedList(out(), results);\n    out() << \") = \";\n  } else if (results.size() == 1) {\n    out() << results[0] << \" = \";\n  }\n  out() << instruction.constant->external_name() << \"(state_)\";\n  if (type->StructSupertype()) {\n    out() << \".Flatten();\\n\";\n  } else {\n    out() << \";\\n\";\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ProcessArgumentsCommon\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Processes common arguments for call instructions.\",\n                \"logic\": \"Iterates through the parameter types, handling constexpr and non-constexpr arguments differently. Emits CSA value for non-constexpr arguments.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"parameter_types\",\n                        \"type\": \"const TypeVector&\",\n                        \"purpose\": \"Types of the parameters.\"\n                    },\n                    {\n                        \"name\": \"constexpr_arguments\",\n                        \"type\": \"std::vector<std::string>\",\n                        \"purpose\": \"List of constexpr arguments.\"\n                    },\n                    {\n                        \"name\": \"stack\",\n                        \"type\": \"Stack<std::string>*\",\n                        \"purpose\": \"The stack of arguments.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::vector<std::string>\",\n                    \"description\": \"Vector of processed arguments.\"\n                },\n                \"dependencies\": [\n                    \"EmitCSAValue\",\n                    \"LoweredSlotCount\",\n                    \"VisitResult\",\n                    \"ProjectStructField\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::vector<std::string> CSAGenerator::ProcessArgumentsCommon(\n    const TypeVector& parameter_types,\n    std::vector<std::string> constexpr_arguments, Stack<std::string>* stack) {\n  std::vector<std::string> args;\n  for (auto it = parameter_types.rbegin(); it != parameter_types.rend(); ++it) {\n    const Type* type = *it;\n    if (type->IsConstexpr()) {\n      args.push_back(std::move(constexpr_arguments.back()));\n      constexpr_arguments.pop_back();\n    } else {\n      std::stringstream s;\n      size_t slot_count = LoweredSlotCount(type);\n      VisitResult arg = VisitResult(type, stack->TopRange(slot_count));\n      EmitCSAValue(arg, *stack, s);\n      args.push_back(s.str());\n      stack->PopMany(slot_count);\n    }\n  }\n  std::reverse(args.begin(), args.end());\n  return args;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitInstruction\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Emits CSA code for a CallIntrinsicInstruction.\",\n                \"logic\": \"Emits code to call an intrinsic function. Handles different intrinsics, including %RawDownCast, %GetClassMapConstant, and %FromConstexpr.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const CallIntrinsicInstruction&\",\n                        \"purpose\": \"The instruction to emit code for.\"\n                    },\n                    {\n                        \"name\": \"stack\",\n                        \"type\": \"Stack<std::string>*\",\n                        \"purpose\": \"The stack of arguments.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CallIntrinsicInstruction\",\n                    \"ProcessArgumentsCommon\",\n                    \"LowerType\",\n                    \"TypeOracle\",\n                    \"ReportError\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CSAGenerator::EmitInstruction(const CallIntrinsicInstruction& instruction,\n                                   Stack<std::string>* stack) {\n  TypeVector parameter_types =\n      instruction.intrinsic->signature().parameter_types.types;\n  std::vector<std::string> args = ProcessArgumentsCommon(\n      parameter_types, instruction.constexpr_arguments, stack);\n\n  Stack<std::string> pre_call_stack = *stack;\n  const Type* return_type = instruction.intrinsic->signature().return_type;\n  std::vector<std::string> results;\n\n  const auto lowered = LowerType(return_type);\n  for (std::size_t i = 0; i < lowered.size(); ++i) {\n    results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));\n    stack->Push(results.back());\n    decls() << \"  TNode<\" << lowered[i]->GetGeneratedTNodeTypeName() << \"> \"\n            << stack->Top() << \";\\n\";\n  }\n\n  out() << \"    \";\n  if (return_type->StructSupertype()) {\n    out() << \"std::tie(\";\n    PrintCommaSeparatedList(out(), results);\n    out() << \") = \";\n  } else {\n    if (results.size() == 1) {\n      out() << results[0] << \" = \";\n    }\n  }\n\n  if (instruction.intrinsic->ExternalName() == \"%RawDownCast\") {\n    if (parameter_types.size() != 1) {\n      ReportError(\"%RawDownCast must take a single parameter\");\n    }\n    const Type* original_type = parameter_types[0];\n    bool is_subtype =\n        return_type->IsSubtypeOf(original_type) ||\n        (original_type == TypeOracle::GetUninitializedHeapObjectType() &&\n         return_type->IsSubtypeOf(TypeOracle::GetHeapObjectType()));\n    if (!is_subtype) {\n      ReportError(\"%RawDownCast error: \", *return_type, \" is not a subtype of \",\n                  *original_type);\n    }\n    if (!original_type->StructSupertype() &&\n        return_type->GetGeneratedTNodeTypeName() !=\n            original_type->GetGeneratedTNodeTypeName()) {\n      if (return_type->IsSubtypeOf(TypeOracle::GetTaggedType())) {\n        out() << \"TORQUE_CAST\";\n      } else {\n        out() << \"ca_.UncheckedCast<\"\n              << return_type->GetGeneratedTNodeTypeName() << \">\";\n      }\n    }\n  } else if (instruction.intrinsic->ExternalName() == \"%GetClassMapConstant\") {\n    if (!parameter_types.empty()) {\n      ReportError(\"%GetClassMapConstant must not take parameters\");\n    }\n    if (instruction.specialization_types.size() != 1) {\n      ReportError(\n          \"%GetClassMapConstant must take a single class as specialization \"\n          \"parameter\");\n    }\n    const ClassType* class_type =\n        ClassType::DynamicCast(instruction.specialization_types[0]);\n    if (!class_type) {\n      ReportError(\"%GetClassMapConstant must take a class type parameter\");\n    }\n    // If the class isn't actually used as the parameter to a TNode,\n    // then we can't rely on the class existing in C++ or being of the same\n    // type (e.g. it could be a template), so don't use the template CSA\n    // machinery for accessing the class' map.\n    std::string class_name =\n        class_type->name() != class_type->GetGeneratedTNodeTypeName()\n            ? std::string(\"void\")\n            : class_type->name();\n\n    out() << std::string(\"CodeStubAssembler(state_).GetClassMapConstant<\") +\n                 class_name + \">\";\n  } else if (instruction.intrinsic->ExternalName() == \"%FromConstexpr\") {\n    if (parameter_types.size() != 1 || !parameter_types[0]->IsConstexpr()) {\n      ReportError(\n          \"%FromConstexpr must take a single parameter with constexpr \"\n          \"type\");\n    }\n    if (return_type->IsConstexpr()) {\n      ReportError(\"%FromConstexpr must return a non-constexpr type\");\n    }\n    if (return_type->IsSubtypeOf(TypeOracle::GetSmiType())) {\n      out() << \"ca_.SmiConstant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetNumberType())) {\n      out() << \"ca_.NumberConstant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetStringType())) {\n      out() << \"ca_.StringConstant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetObjectType())) {\n      ReportError(\n          \"%FromConstexpr cannot cast to subclass of HeapObject unless it's a \"\n          \"String or Number\");\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetIntPtrType())) {\n      out() << \"ca_.IntPtrConstant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetUIntPtrType())) {\n      out() << \"ca_.UintPtrConstant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetInt32Type())) {\n      out() << \"ca_.Int32Constant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetUint8Type())) {\n      out() << \"TNode<Uint8T>::UncheckedCast(ca_.Uint32Constant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetUint32Type())) {\n      out() << \"ca_.Uint32Constant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetInt64Type())) {\n      out() << \"ca_.Int64Constant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetUint64Type())) {\n      out() << \"ca_.Uint64Constant\";\n    } else if (return_type->IsSubtypeOf(TypeOracle::GetBoolType())) {\n      out() << \"ca_.BoolConstant\";\n    } else {\n      std::stringstream s;\n      s << \"%FromConstexpr does not support return type \" << *return_type;\n      ReportError(s.str());\n    }\n    // Wrap the raw constexpr value in a static_cast to ensure that\n    // enums get properly casted to their backing integral value.\n    out() << \"(CastToUnderlyingTypeIfEnum\";\n  } else {\n    ReportError(\"no built in intrinsic with name \" +\n                instruction.intrinsic->ExternalName());\n  }\n\n  out() << \"(\";\n  PrintCommaSeparatedList(out(), args);\n  if (instruction.intrinsic->ExternalName() == \"%FromConstexpr\") {\n    out() << \")\";\n    if (return_type->IsSubtypeOf(TypeOracle::GetUint8Type())) {\n      out() << \")\";\n    }\n  }\n  if (return_type->StructSupertype()) {\n    out() << \").Flatten();\\n\";\n  } else {\n    out() << \");\\n\";\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitInstruction\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Emits CSA code for a CallCsaMacroInstruction.\",\n                \"logic\": \"Emits code to call a CSA macro. Handles extern macros and exception preparation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const CallCsaMacroInstruction&\",\n                        \"purpose\": \"The instruction to emit code for.\"\n                    },\n                    {\n                        \"name\": \"stack\",\n                        \"type\": \"Stack<std::string>*\",\n                        \"purpose\": \"The stack of arguments.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CallCsaMacroInstruction\",\n                    \"ProcessArgumentsCommon\",\n                    \"LowerType\",\n                    \"PreCallableExceptionPreparation\",\n                    \"PostCallableExceptionPreparation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CSAGenerator::EmitInstruction(const CallCsaMacroInstruction& instruction,\n                                   Stack<std::string>* stack) {\n  TypeVector parameter_types =\n      instruction.macro->signature().parameter_types.types;\n  std::vector<std::string> args = ProcessArgumentsCommon(\n      parameter_types, instruction.constexpr_arguments, stack);\n\n  Stack<std::string> pre_call_stack = *stack;\n  const Type* return_type = instruction.macro->signature().return_type;\n  std::vector<std::string> results;\n\n  const auto lowered = LowerType(return_type);\n  for (std::size_t i = 0; i < lowered.size(); ++i) {\n    results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));\n    stack->Push(results.back());\n    decls() << \"  TNode<\" << lowered[i]->GetGeneratedTNodeTypeName() << \"> \"\n            << stack->Top() << \";\\n\";\n  }\n\n  std::string catch_name =\n      PreCallableExceptionPreparation(instruction.catch_block);\n  out() << \"    \";\n  bool needs_flattening = return_type->StructSupertype().has_value();\n  if (needs_flattening) {\n    out() << \"std::tie(\";\n    PrintCommaSeparatedList(out(), results);\n    out() << \") = \";\n  } else {\n    if (results.size() == 1) {\n      out() << results[0] << \" = \";\n    } else {\n      DCHECK_EQ(0, results.size());\n    }\n  }\n  if (ExternMacro* extern_macro = ExternMacro::DynamicCast(instruction.macro)) {\n    out() << extern_macro->external_assembler_name() << \"(state_).\";\n  } else {\n    args.insert(args.begin(), \"state_\");\n  }\n  out() << instruction.macro->ExternalName() << \"(\";\n  PrintCommaSeparatedList(out(), args);\n  if (needs_flattening) {\n    out() << \").Flatten();\\n\";\n  } else {\n    out() << \");\\n\";\n  }\n  PostCallableExceptionPreparation(catch_name, return_type,\n                                   instruction.catch_block, &pre_call_stack,\n                                   instruction.GetExceptionObjectDefinition());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitInstruction\",\n                \"parent\": \"CSAGenerator\",\n                \"about\": \"Emits CSA code for a CallCsaMacroAndBranchInstruction.\",\n                \"logic\": \"Emits code to call a CSA macro and branch to different blocks based on the macro's return. Handles labels, exception preparation, and continuation blocks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instruction\",\n                        \"type\": \"const CallCsaMacroAndBranchInstruction&\",\n                        \"purpose\": \"The instruction to emit code for.\"\n                    },\n                    {\n                        \"name\": \"stack\",\n                        \"type\": \"Stack<std::string>*\",\n                        \"purpose\": \"The stack of arguments.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CallCsaMacroAndBranchInstruction\",\n                    \"ProcessArgumentsCommon\",\n                    \"LowerType\",\n                    \"PreCallableExceptionPreparation\",\n                    \"PostCallableExceptionPreparation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CSAGenerator::EmitInstruction(\n    const CallCsaMacroAndBranchInstruction& instruction,\n    Stack<std::string>* stack) {\n  TypeVector parameter_types =\n      instruction.macro->signature().parameter_types.types;\n  std::vector<std::string> args = ProcessArgumentsCommon(\n      parameter_types, instruction.constexpr_arguments, stack);"
}