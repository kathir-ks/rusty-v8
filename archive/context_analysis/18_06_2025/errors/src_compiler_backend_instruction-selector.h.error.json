{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-selector.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-selector.h\",\n            \"file_name\": \"instruction-selector.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the InstructionSelector class and related data structures for selecting machine instructions from a Turboshaft graph.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard library headers for data structures and optional values\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <map>\n            #include <optional>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 codebase headers for code generation, compilation, and platform features.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/codegen/cpu-features.h\"\n            #include \"src/codegen/machine-type.h\"\n            #include \"src/compiler/backend/instruction-scheduler.h\"\n            #include \"src/compiler/backend/instruction-selector-adapter.h\"\n            #include \"src/compiler/backend/instruction.h\"\n            #include \"src/compiler/feedback-source.h\"\n            #include \"src/compiler/linkage.h\"\n            #include \"src/compiler/node-matchers.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n            #include \"src/compiler/turboshaft/utils.h\"\n            #include \"src/utils/bit-vector.h\"\n            #include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"WebAssembly support (conditionally included)\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/wasm/simd-shuffle.h\"\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"InstructionSelector\",\n                \"about\": \"Selects machine instructions for a given Turboshaft graph.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"BasicBlock\",\n                    \"CallBufferT\",\n                    \"InstructionSelectorT\",\n                    \"Linkage\",\n                    \"OperandGeneratorT\",\n                    \"SwitchInfoT\",\n                    \"CaseInfoT\",\n                    \"TurbofanStateObjectDeduplicator\",\n                    \"TurboshaftStateObjectDeduplicator\",\n                    \"CpuFeature\",\n                    \"InstructionSequence\",\n                    \"turboshaft::Graph\",\n                    \"Frame\",\n                    \"TickCounter\",\n                    \"JSHeapBroker\",\n                    \"SourcePositionMode\",\n                    \"Features\",\n                    \"SupportedFeatures\",\n                    \"CpuFeatures\",\n                    \"ZoneVector\",\n                    \"NodeId\",\n                    \"MachineOperatorBuilder\",\n                    \"AlignmentRequirements\",\n                    \"BailoutReason\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE InstructionSelector final {\n            public:\n                enum SourcePositionMode { kCallSourcePositions, kAllSourcePositions };\n                enum EnableScheduling { kDisableScheduling, kEnableScheduling };\n                enum EnableRootsRelativeAddressing {\n                    kDisableRootsRelativeAddressing,\n                    kEnableRootsRelativeAddressing\n                };\n                enum EnableSwitchJumpTable {\n                    kDisableSwitchJumpTable,\n                    kEnableSwitchJumpTable\n                };\n                enum EnableTraceTurboJson { kDisableTraceTurboJson, kEnableTraceTurboJson };\n\n                class Features final {\n                public:\n                    Features() : bits_(0) {}\n                    explicit Features(unsigned bits) : bits_(bits) {}\n                    explicit Features(CpuFeature f) : bits_(1u << f) {}\n                    Features(CpuFeature f1, CpuFeature f2) : bits_((1u << f1) | (1u << f2)) {}\n\n                    bool Contains(CpuFeature f) const { return (bits_ & (1u << f)); }\n\n                private:\n                    unsigned bits_;\n                };\n\n                static InstructionSelector ForTurboshaft(\n                    Zone* zone, size_t node_count, Linkage* linkage,\n                    InstructionSequence* sequence, turboshaft::Graph* schedule, Frame* frame,\n                    EnableSwitchJumpTable enable_switch_jump_table, TickCounter* tick_counter,\n                    JSHeapBroker* broker, size_t* max_unoptimized_frame_height,\n                    size_t* max_pushed_argument_count,\n                    SourcePositionMode source_position_mode = kCallSourcePositions,\n                    Features features = SupportedFeatures(),\n                    EnableScheduling enable_scheduling = v8_flags.turbo_instruction_scheduling\n                                                        ? kEnableScheduling\n                                                        : kDisableScheduling,\n                    EnableRootsRelativeAddressing enable_roots_relative_addressing =\n                        kDisableRootsRelativeAddressing,\n                    EnableTraceTurboJson trace_turbo = kDisableTraceTurboJson);\n\n                ~InstructionSelector();\n\n                std::optional<BailoutReason> SelectInstructions();\n\n                bool IsSupported(CpuFeature feature) const;\n\n                // Returns the features supported on the target platform.\n                static Features SupportedFeatures() {\n                    return Features(CpuFeatures::SupportedFeatures());\n                }\n\n                const ZoneVector<std::pair<int, int>>& instr_origins() const;\n                const std::map<NodeId, int> GetVirtualRegistersForTesting() const;\n\n                static MachineOperatorBuilder::Flags SupportedMachineOperatorFlags();\n                static MachineOperatorBuilder::AlignmentRequirements AlignmentRequirements();\n\n            private:\n                InstructionSelector(std::nullptr_t, InstructionSelectorT* turboshaft_impl);\n                InstructionSelector(const InstructionSelector&) = delete;\n                InstructionSelector& operator=(const InstructionSelector&) = delete;\n                InstructionSelectorT* turboshaft_impl_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FlagsContinuationT\",\n                \"about\": \"Represents a continuation for instructions that set flags (e.g., branches, deoptimizations).\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"FlagsCondition\",\n                    \"turboshaft::Block\",\n                    \"DeoptimizeReason\",\n                    \"FeedbackSource\",\n                    \"turboshaft::OpIndex\",\n                    \"TrapId\",\n                    \"InstructionCode\",\n                    \"FlagsModeField\",\n                    \"FlagsConditionField\",\n                    \"NegateFlagsCondition\",\n                    \"CommuteFlagsCondition\",\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // The flags continuation is a way to combine a branch or a materialization\n            // of a boolean value with an instruction that sets the flags register.\n            // The whole instruction is treated as a unit by the register allocator, and\n            // thus no spills or moves can be introduced between the flags-setting\n            // instruction and the branch or set it should be combined with.\n            class FlagsContinuationT final {\n            public:\n                struct ConditionalCompare {\n                    InstructionCode code;\n                    FlagsCondition compare_condition;\n                    FlagsCondition default_flags;\n                    turboshaft::OpIndex lhs;\n                    turboshaft::OpIndex rhs;\n                };\n                // This limit covered almost all the opportunities when compiling the debug\n                // builtins.\n                static constexpr size_t kMaxCompareChainSize = 4;\n                using compare_chain_t = std::array<ConditionalCompare, kMaxCompareChainSize>;\n\n                FlagsContinuationT() : mode_(kFlags_none) {}\n\n                // Creates a new flags continuation from the given condition and true/false\n                // blocks.\n                static FlagsContinuationT ForBranch(FlagsCondition condition,\n                                                    turboshaft::Block* true_block,\n                                                    turboshaft::Block* false_block) {\n                    return FlagsContinuationT(kFlags_branch, condition, true_block,\n                                                false_block);\n                }\n\n                // Creates a new flags continuation from the given conditional compare chain\n                // and true/false blocks.\n                static FlagsContinuationT ForConditionalBranch(\n                    compare_chain_t& compares, uint32_t num_conditional_compares,\n                    FlagsCondition branch_condition, turboshaft::Block* true_block,\n                    turboshaft::Block* false_block) {\n                    return FlagsContinuationT(compares, num_conditional_compares,\n                                                branch_condition, true_block, false_block);\n                }\n\n                // Creates a new flags continuation for an eager deoptimization exit.\n                static FlagsContinuationT ForDeoptimize(FlagsCondition condition,\n                                                        DeoptimizeReason reason,\n                                                        uint32_t node_id,\n                                                        FeedbackSource const& feedback,\n                                                        turboshaft::OpIndex frame_state) {\n                    return FlagsContinuationT(kFlags_deoptimize, condition, reason, node_id,\n                                                feedback, frame_state);\n                }\n                static FlagsContinuationT ForDeoptimizeForTesting(\n                    FlagsCondition condition, DeoptimizeReason reason, uint32_t node_id,\n                    FeedbackSource const& feedback, turboshaft::OpIndex frame_state) {\n                    // test-instruction-scheduler.cc passes a dummy Node* as frame_state.\n                    // Contents don't matter as long as it's not nullptr.\n                    return FlagsContinuationT(kFlags_deoptimize, condition, reason, node_id,\n                                                feedback, frame_state);\n                }\n\n                // Creates a new flags continuation for a boolean value.\n                static FlagsContinuationT ForSet(FlagsCondition condition,\n                                                    turboshaft::OpIndex result) {\n                    return FlagsContinuationT(condition, result);\n                }\n\n                // Creates a new flags continuation for a conditional boolean value.\n                static FlagsContinuationT ForConditionalSet(compare_chain_t& compares,\n                                                            uint32_t num_conditional_compares,\n                                                            FlagsCondition set_condition,\n                                                            turboshaft::OpIndex result) {\n                    return FlagsContinuationT(compares, num_conditional_compares, set_condition,\n                                                result);\n                }\n\n                // Creates a new flags continuation for a wasm trap.\n                static FlagsContinuationT ForTrap(FlagsCondition condition, TrapId trap_id) {\n                    return FlagsContinuationT(condition, trap_id);\n                }\n\n                static FlagsContinuationT ForSelect(FlagsCondition condition,\n                                                    turboshaft::OpIndex result,\n                                                    turboshaft::OpIndex true_value,\n                                                    turboshaft::OpIndex false_value) {\n                    return FlagsContinuationT(condition, result, true_value, false_value);\n                }\n\n                bool IsNone() const { return mode_ == kFlags_none; }\n                bool IsBranch() const { return mode_ == kFlags_branch; }\n                bool IsConditionalBranch() const {\n                    return mode_ == kFlags_conditional_branch;\n                }\n                bool IsDeoptimize() const { return mode_ == kFlags_deoptimize; }\n                bool IsSet() const { return mode_ == kFlags_set; }\n                bool IsConditionalSet() const { return mode_ == kFlags_conditional_set; }\n                bool IsTrap() const { return mode_ == kFlags_trap; }\n                bool IsSelect() const { return mode_ == kFlags_select; }\n                FlagsCondition condition() const {\n                    DCHECK(!IsNone());\n                    return condition_;\n                }\n                FlagsCondition final_condition() const {\n                    DCHECK(IsConditionalSet() || IsConditionalBranch());\n                    return final_condition_;\n                }\n                DeoptimizeReason reason() const {\n                    DCHECK(IsDeoptimize());\n                    return reason_;\n                }\n                uint32_t node_id() const {\n                    DCHECK(IsDeoptimize());\n                    return node_id_;\n                }\n                FeedbackSource const& feedback() const {\n                    DCHECK(IsDeoptimize());\n                    return feedback_;\n                }\n                turboshaft::OpIndex frame_state() const {\n                    DCHECK(IsDeoptimize());\n                    return frame_state_or_result_;\n                }\n                turboshaft::OpIndex result() const {\n                    DCHECK(IsSet() || IsConditionalSet() || IsSelect());\n                    return frame_state_or_result_;\n                }\n                TrapId trap_id() const {\n                    DCHECK(IsTrap());\n                    return trap_id_;\n                }\n                turboshaft::Block* true_block() const {\n                    DCHECK(IsBranch() || IsConditionalBranch());\n                    return true_block_;\n                }\n                turboshaft::Block* false_block() const {\n                    DCHECK(IsBranch() || IsConditionalBranch());\n                    return false_block_;\n                }\n                turboshaft::OpIndex true_value() const {\n                    DCHECK(IsSelect());\n                    return true_value_;\n                }\n                turboshaft::OpIndex false_value() const {\n                    DCHECK(IsSelect());\n                    return false_value_;\n                }\n                const compare_chain_t& compares() const {\n                    DCHECK(IsConditionalSet() || IsConditionalBranch());\n                    return compares_;\n                }\n                uint32_t num_conditional_compares() const {\n                    DCHECK(IsConditionalSet() || IsConditionalBranch());\n                    return num_conditional_compares_;\n                }\n\n                void Negate() {\n                    DCHECK(!IsNone());\n                    DCHECK(!IsConditionalSet() && !IsConditionalBranch());\n                    condition_ = NegateFlagsCondition(condition_);\n                }\n\n                void Commute() {\n                    DCHECK(!IsNone());\n                    DCHECK(!IsConditionalSet() && !IsConditionalBranch());\n                    condition_ = CommuteFlagsCondition(condition_);\n                }\n\n                void Overwrite(FlagsCondition condition) {\n                    DCHECK(!IsConditionalSet() && !IsConditionalBranch());\n                    condition_ = condition;\n                }\n\n                void OverwriteAndNegateIfEqual(FlagsCondition condition) {\n                    DCHECK(condition_ == kEqual || condition_ == kNotEqual);\n                    DCHECK(!IsConditionalSet() && !IsConditionalBranch());\n                    bool negate = condition_ == kEqual;\n                    condition_ = condition;\n                    if (negate) Negate();\n                }\n\n                void OverwriteUnsignedIfSigned() {\n                    DCHECK(!IsConditionalSet() && !IsConditionalBranch());\n                    switch (condition_) {\n                    case kSignedLessThan:\n                        condition_ = kUnsignedLessThan;\n                        break;\n                    case kSignedLessThanOrEqual:\n                        condition_ = kUnsignedLessThanOrEqual;\n                        break;\n                    case kSignedGreaterThan:\n                        condition_ = kUnsignedGreaterThan;\n                        break;\n                    case kSignedGreaterThanOrEqual:\n                        condition_ = kUnsignedGreaterThanOrEqual;\n                        break;\n                    default:\n                        break;\n                    }\n                }\n\n                // Encodes this flags continuation into the given opcode.\n                InstructionCode Encode(InstructionCode opcode) {\n                    opcode |= FlagsModeField::encode(mode_);\n                    if (mode_ != kFlags_none) {\n                    opcode |= FlagsConditionField::encode(condition_);\n                    }\n                    return opcode;\n                }\n\n            private:\n                FlagsContinuationT(FlagsMode mode, FlagsCondition condition,\n                                    turboshaft::Block* true_block,\n                                    turboshaft::Block* false_block)\n                    : mode_(mode),\n                    condition_(condition),\n                    true_block_(true_block),\n                    false_block_(false_block) {\n                    DCHECK(mode == kFlags_branch);\n                    DCHECK_NOT_NULL(true_block);\n                    DCHECK_NOT_NULL(false_block);\n                }\n\n                FlagsContinuationT(compare_chain_t& compares,\n                                    uint32_t num_conditional_compares,\n                                    FlagsCondition branch_condition,\n                                    turboshaft::Block* true_block,\n                                    turboshaft::Block* false_block)\n                    : mode_(kFlags_conditional_branch),\n                    condition_(compares.front().compare_condition),\n                    final_condition_(branch_condition),\n                    num_conditional_compares_(num_conditional_compares),\n                    compares_(compares),\n                    true_block_(true_block),\n                    false_block_(false_block) {\n                    DCHECK_NOT_NULL(true_block);\n                    DCHECK_NOT_NULL(false_block);\n                }\n\n                FlagsContinuationT(FlagsMode mode, FlagsCondition condition,\n                                    DeoptimizeReason reason, uint32_t node_id,\n                                    FeedbackSource const& feedback,\n                                    turboshaft::OpIndex frame_state)\n                    : mode_(mode),\n                    condition_(condition),\n                    reason_(reason),\n                    node_id_(node_id),\n                    feedback_(feedback),\n                    frame_state_or_result_(frame_state) {\n                    DCHECK(mode == kFlags_deoptimize);\n                    DCHECK(frame_state.valid());\n                }\n\n                FlagsContinuationT(FlagsCondition condition, turboshaft::OpIndex result)\n                    : mode_(kFlags_set),\n                    condition_(condition),\n                    frame_state_or_result_(result) {\n                    DCHECK(result.valid());\n                }\n\n                FlagsContinuationT(compare_chain_t& compares,\n                                    uint32_t num_conditional_compares,\n                                    FlagsCondition set_condition, turboshaft::OpIndex result)\n                    : mode_(kFlags_conditional_set),\n                    condition_(compares.front().compare_condition),\n                    final_condition_(set_condition),\n                    num_conditional_compares_(num_conditional_compares),\n                    compares_(compares),\n                    frame_state_or_result_(result) {\n                    DCHECK(result.valid());\n                }\n\n                FlagsContinuationT(FlagsCondition condition, TrapId trap_id)\n                    : mode_(kFlags_trap), condition_(condition), trap_id_(trap_id) {}\n\n                FlagsContinuationT(FlagsCondition condition, turboshaft::OpIndex result,\n                                    turboshaft::OpIndex true_value,\n                                    turboshaft::OpIndex false_value)\n                    : mode_(kFlags_select),\n                    condition_(condition),\n                    frame_state_or_result_(result),\n                    true_value_(true_value),\n                    false_value_(false_value) {\n                    DCHECK(result.valid());\n                    DCHECK(true_value.valid());\n                    DCHECK(false_value.valid());\n                }\n\n                FlagsMode const mode_;\n                FlagsCondition condition_;\n                FlagsCondition final_condition_;     // Only valid if mode_ ==\n                                                    // kFlags_conditional_set.\n                uint32_t num_conditional_compares_;  // Only valid if mode_ ==\n                                                    // kFlags_conditional_set.\n                compare_chain_t compares_;  // Only valid if mode_ == kFlags_conditional_set.\n                DeoptimizeReason reason_;         // Only valid if mode_ == kFlags_deoptimize*\n                uint32_t node_id_;                // Only valid if mode_ == kFlags_deoptimize*\n                FeedbackSource feedback_;         // Only valid if mode_ == kFlags_deoptimize*\n                turboshaft::OpIndex\n                    frame_state_or_result_;       // Only valid if mode_ == kFlags_deoptimize*\n                                                    // or mode_ == kFlags_set.\n                turboshaft::Block* true_block_;   // Only valid if mode_ == kFlags_branch*.\n                turboshaft::Block* false_block_;  // Only valid if mode_ == kFlags_branch*.\n                TrapId trap_id_;                  // Only valid if mode_ == kFlags_trap.\n                turboshaft::OpIndex true_value_;  // Only valid if mode_ == kFlags_select.\n                turboshaft::OpIndex false_value_;  // Only valid if mode_ == kFlags_select.\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"PushParameterT\",\n                \"about\": \"Connects nodes of parameters pushed on the stack with their index in the call descriptor.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"turboshaft::OpIndex\",\n                    \"LinkageLocation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // This struct connects nodes of parameters which are going to be pushed on the\n            // call stack with their parameter index in the call descriptor of the callee.\n            struct PushParameterT {\n            PushParameterT(turboshaft::OpIndex n = {},\n                            LinkageLocation l = LinkageLocation::ForAnyRegister())\n                : node(n), location(l) {}\n\n            turboshaft::OpIndex node;\n            LinkageLocation location;\n            };\n        ]]></code>\n    </struct>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"InstructionSelectorT\",\n                \"about\": \"Generates an InstructionSequence for a given Turboshaft Schedule.\",\n                \"attributes\": [],\n                \"extends\": \"TurboshaftAdapter\",\n                \"dependencies\": [\n                    \"OperandGeneratorT\",\n                    \"PushParameterT\",\n                    \"CallBufferT\",\n                    \"FlagsContinuationT\",\n                    \"SwitchInfoT\",\n                    \"CaseInfoT\",\n                    \"InstructionSelector\",\n                    \"Zone\",\n                    \"Linkage\",\n                    \"InstructionSequence\",\n                    \"turboshaft::Graph\",\n                    \"Frame\",\n                    \"TickCounter\",\n                    \"JSHeapBroker\",\n                    \"SourcePosition\",\n                    \"Instruction\",\n                    \"InstructionOperand\",\n                    \"FlagsContinuation\",\n                    \"CpuFeature\",\n                    \"CpuFeatures\",\n                    \"RpoNumber\",\n                    \"TurboshaftAdapter\",\n                    \"MachineRepresentation\",\n                    \"RegisterRepresentation\",\n                    \"StateObjectDeduplicator\",\n                    \"StateValueList\",\n                    \"FrameStateDescriptor\",\n                    \"MachineType\",\n                    \"Isolate\",\n                    \"turboshaft::OptionalOpIndex\",\n                    \"base::Vector\",\n                    \"turboshaft::ComparisonOp\",\n                    \"ArchOpcode\",\n                    \"Node\",\n                    \"DeoptimizeReason\",\n                    \"FeedbackSource\",\n                    \"TrapId\",\n                    \"CallDescriptor\",\n                    \"InstructionOperandVector\",\n                    \"BitVector\",\n                    \"IntVector\",\n                    \"InstructionScheduler\",\n                    \"NegateFlagsCondition\",\n                    \"CommuteFlagsCondition\",\n                    \"FlagsModeField\",\n                    \"FlagsConditionField\",\n                    \"PhiInstruction\",\n                    \"ExternalReference\",\n                    \"SimdShuffleView\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // Instruction selection generates an InstructionSequence for a given Schedule.\n            class InstructionSelectorT final : public TurboshaftAdapter {\n            public:\n                using OperandGenerator = OperandGeneratorT;\n                using PushParameter = PushParameterT;\n                using CallBuffer = CallBufferT;\n                using FlagsContinuation = FlagsContinuationT;\n                using SwitchInfo = SwitchInfoT;\n                using CaseInfo = CaseInfoT;\n\n                using source_position_table_t =\n                    turboshaft::GrowingOpIndexSidetable<SourcePosition>;\n                using Features = InstructionSelector::Features;\n\n                InstructionSelectorT(\n                    Zone* zone, size_t node_count, Linkage* linkage,\n                    InstructionSequence* sequence, turboshaft::Graph* schedule,\n                    source_position_table_t* source_positions, Frame* frame,\n                    InstructionSelector::EnableSwitchJumpTable enable_switch_jump_table,\n                    TickCounter* tick_counter, JSHeapBroker* broker,\n                    size_t* max_unoptimized_frame_height, size_t* max_pushed_argument_count,\n                    InstructionSelector::SourcePositionMode source_position_mode =\n                        InstructionSelector::kCallSourcePositions,\n                    Features features = SupportedFeatures(),\n                    InstructionSelector::EnableScheduling enable_scheduling =\n                        v8_flags.turbo_instruction_scheduling\n                            ? InstructionSelector::kEnableScheduling\n                            : InstructionSelector::kDisableScheduling,\n                    InstructionSelector::EnableRootsRelativeAddressing\n                        enable_roots_relative_addressing =\n                            InstructionSelector::kDisableRootsRelativeAddressing,\n                    InstructionSelector::EnableTraceTurboJson trace_turbo =\n                        InstructionSelector::kDisableTraceTurboJson);\n\n                // Visit code for the entire graph with the included schedule.\n                std::optional<BailoutReason> SelectInstructions();\n\n                void StartBlock(RpoNumber rpo);\n                void EndBlock(RpoNumber rpo);\n                void AddInstruction(Instruction* instr);\n                void AddTerminator(Instruction* instr);\n\n                // ===========================================================================\n                // ============= Architecture-independent code emission methods. =============\n                // ===========================================================================\n\n                Instruction* Emit(InstructionCode opcode, InstructionOperand output,\n                                    size_t temp_count = 0, InstructionOperand* temps = nullptr);\n                Instruction* Emit(InstructionCode opcode, InstructionOperand output,\n                                    InstructionOperand a, size_t temp_count = 0,\n                                    InstructionOperand* temps = nullptr);\n                Instruction* Emit(InstructionCode opcode, InstructionOperand output,\n                                    InstructionOperand a, InstructionOperand b,\n                                    size_t temp_count = 0, InstructionOperand* temps = nullptr);\n                Instruction* Emit(InstructionCode opcode, InstructionOperand output,\n                                    InstructionOperand a, InstructionOperand b,\n                                    InstructionOperand c, size_t temp_count = 0,\n                                    InstructionOperand* temps = nullptr);\n                Instruction* Emit(InstructionCode opcode, InstructionOperand output,\n                                    InstructionOperand a, InstructionOperand b,\n                                    InstructionOperand c, InstructionOperand d,\n                                    size_t temp_count = 0, InstructionOperand* temps = nullptr);\n                Instruction* Emit(InstructionCode opcode, InstructionOperand output,\n                                    InstructionOperand a, InstructionOperand b,\n                                    InstructionOperand c, InstructionOperand d,\n                                    InstructionOperand e, size_t temp_count = 0,\n                                    InstructionOperand* temps = nullptr);\n                Instruction* Emit(InstructionCode opcode, InstructionOperand output,\n                                    InstructionOperand a, InstructionOperand b,\n                                    InstructionOperand c, InstructionOperand d,\n                                    InstructionOperand e, InstructionOperand f,\n                                    size_t temp_count = 0, InstructionOperand* temps = nullptr);\n                Instruction* Emit(InstructionCode opcode, InstructionOperand output,\n                                    InstructionOperand a, InstructionOperand b,\n                                    InstructionOperand c, InstructionOperand d,\n                                    InstructionOperand e, InstructionOperand f,\n                                    InstructionOperand g, InstructionOperand h,\n                                    size_t temp_count = 0, InstructionOperand* temps = nullptr);\n                Instruction* Emit(InstructionCode opcode, size_t output_count,\n                                    InstructionOperand* outputs, size_t input_count,\n                                    InstructionOperand* inputs, size_t temp_count = 0,\n                                    InstructionOperand* temps = nullptr);\n                Instruction* Emit(Instruction* instr);\n\n                // [0-3] operand instructions with no output, uses labels for true and false\n                // blocks of the continuation.\n                Instruction* EmitWithContinuation(InstructionCode opcode,\n                                                    FlagsContinuation* cont);\n                Instruction* EmitWithContinuation(InstructionCode opcode,\n                                                    InstructionOperand a,\n                                                    FlagsContinuation* cont);\n                Instruction* EmitWithContinuation(InstructionCode opcode,\n                                                    InstructionOperand a, InstructionOperand b,\n                                                    FlagsContinuation* cont);\n                Instruction* EmitWithContinuation(InstructionCode opcode,\n                                                    InstructionOperand a, InstructionOperand b,\n                                                    InstructionOperand c,\n                                                    FlagsContinuation* cont);\n                Instruction* EmitWithContinuation(InstructionCode opcode, size_t output_count,\n                                                    InstructionOperand* outputs,\n                                                    size_t input_count,\n                                                    InstructionOperand* inputs,\n                                                    FlagsContinuation* cont);\n                Instruction* EmitWithContinuation(\n                    InstructionCode opcode, size_t output_count, InstructionOperand* outputs,\n                    size_t input_count, InstructionOperand* inputs, size_t temp_count,\n                    InstructionOperand* temps, FlagsContinuation* cont);\n\n                void EmitIdentity(turboshaft::OpIndex node);\n\n                // ===========================================================================\n                // ============== Architecture-independent CPU feature methods. ==============\n                // ===========================================================================\n\n                bool IsSupported(CpuFeature feature) const {\n                    return features_.Contains(feature);\n                }\n\n                // Returns the features supported on the target platform.\n                static Features SupportedFeatures() {\n                    return Features(CpuFeatures::SupportedFeatures());\n                }\n\n                // ===========================================================================\n                // ============ Architecture-independent graph covering methods. =============\n                // ===========================================================================\n\n                // Used in pattern matching during code generation.\n                // Check if {node} can be covered while generating code for the current\n                // instruction. A node can be covered if the {user} of the node has the only\n                // edge, the two are in the same basic block, and there are no side-effects\n                // in-between. The last check is crucial for soundness.\n                // For pure nodes, CanCover(a,b) is checked to avoid duplicated execution:\n                // If this is not the case, code for b must still be generated for other\n                // users, and fusing is unlikely to improve performance.\n                bool CanCover(turboshaft::OpIndex user, turboshaft::OpIndex node) const;\n\n                bool CanCoverProtectedLoad(turboshaft::OpIndex user,\n                                            turboshaft::OpIndex node) const;\n\n                // Used in pattern matching during code generation.\n                // This function checks that {node} and {user} are in the same basic block,\n                // and that {user} is the only user of {node} in this basic block.  This\n                // check guarantees that there are no users of {node} scheduled between\n                // {node} and {user}, and thus we can select a single instruction for both\n                // nodes, if such an instruction exists. This check can be used for example\n                // when selecting instructions for:\n                //   n = Int32Add(a, b)\n                //   c = Word32Compare(n, 0, cond)\n                //   Branch(c, true_label, false_label)\n                // Here we can generate a flag-setting add instruction, even if the add has\n                // uses in other basic blocks, since the flag-setting add instruction will\n                // still generate the result of the addition and not just set the flags.\n                // However, if we had uses of the add in the same basic block, we could have:\n                //   n = Int32Add(a, b)\n                //   o = OtherOp(n, ...)\n                //   c = Word32Compare(n, 0, cond)\n                //   Branch(c, true_label, false_label)\n                // where we cannot select the add and the compare together.  If we were to\n                // select a flag-setting add instruction for Word32Compare and Int32Add while\n                // visiting Word32Compare, we would then have to select an instruction for\n                // OtherOp *afterwards*, which means we would attempt to use the result of\n                // the add before we have defined it.\n                bool IsOnlyUserOfNodeInSameBlock(turboshaft::OpIndex user,\n                                                turboshaft::OpIndex node) const;\n\n                // Checks if {node} was already defined, and therefore code was already\n                // generated for it.\n                bool IsDefined(turboshaft::OpIndex node) const;\n\n                // Checks if {node} has any uses, and therefore code has to be generated for\n                // it. Always returns {true} if the node has effect IsRequiredWhenUnused.\n                bool IsUsed(turboshaft::OpIndex node) const;\n                // Checks if {node} has any uses, and therefore code has to be generated for\n                // it. Ignores the IsRequiredWhenUnused effect.\n                bool IsReallyUsed(turboshaft::OpIndex node) const;\n\n                // Checks if {node} is currently live.\n                bool IsLive(turboshaft::OpIndex node) const {\n                    return !IsDefined(node) && IsUsed(node);\n                }\n                // Checks if {node} is currently live, ignoring the IsRequiredWhenUnused\n                // effect.\n                bool IsReallyLive(turboshaft::OpIndex node) const {\n                    return !IsDefined(node) && IsReallyUsed(node);\n                }\n\n                // Gets the effect level of {node}.\n                int GetEffectLevel(turboshaft::OpIndex node) const;\n\n                // Gets the effect level of {node}, appropriately adjusted based on\n                // continuation flags if the node is a branch.\n                int GetEffectLevel(turboshaft::OpIndex node, FlagsContinuation* cont) const;\n\n                int GetVirtualRegister(turboshaft::OpIndex node);\n                const std::map<uint32_t, int> GetVirtualRegistersForTesting() const;\n\n                // Check if we can generate loads and stores of ExternalConstants relative\n                // to the roots register.\n                bool CanAddressRelativeToRootsRegister(\n                    const ExternalReference& reference) const;\n                // Check if we can use the roots register to access GC roots.\n                bool CanUseRootsRegister() const;\n\n                Isolate* isolate() const { return sequence()->isolate(); }\n\n                const ZoneVector<std::pair<int, int>>& instr_origins() const {\n                    return instr_origins_;\n                }\n\n                turboshaft::OptionalOpIndex FindProjection(turboshaft::OpIndex node,\n                                                            size_t projection_index);\n                template <typename Op>\n                auto Inputs(turboshaft::OpIndex node) {\n                    const Op& op = Cast<Op>(node);\n                    return InputsImpl(op, std::make_index_sequence<Op::input_count>());\n                }\n                template <typename Op, std::size_t... Is>\n                auto InputsImpl(const Op& op, std::index_sequence<Is...>) {\n                    return std::make_tuple(op.input(Is)...);\n                }\n\n                // When we want to do branch-if-overflow fusion, we need to be mindful of the\n                // 1st projection of the OverflowBinop:\n                //   - If it has no uses, all good, we can do the fusion.\n                //   - If it has any uses, then they must all be already defined: doing the\n                //     fusion will lead to emitting the 1st projection, and any non-defined\n                //     operation is earlier in the graph by construction, which means that it\n                //     won't be able to use the 1st projection that will now be defined later.\n                bool CanDoBranchIfOverflowFusion(turboshaft::OpIndex node);\n\n                // Records that this Protected"
}