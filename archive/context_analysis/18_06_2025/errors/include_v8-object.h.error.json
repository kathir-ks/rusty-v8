{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-object.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-object.h\",\n        \"file_name\": \"v8-object.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the v8::Object class and related classes and enums for interacting with JavaScript objects in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary V8 internal headers, standard library headers, and configuration.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"v8-internal.h\"           // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"       // NOLINT(build/include_directory)\n            #include \"v8-maybe.h\"              // NOLINT(build/include_directory)\n            #include \"v8-persistent-handle.h\"  // NOLINT(build/include_directory)\n            #include \"v8-primitive.h\"          // NOLINT(build/include_directory)\n            #include \"v8-sandbox.h\"            // NOLINT(build/include_directory)\n            #include \"v8-traced-handle.h\"      // NOLINT(build/include_directory)\n            #include \"v8-value.h\"              // NOLINT(build/include_directory)\n            #include \"v8config.h\"              // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Private\",\n            \"extends\": \"Data\",\n            \"about\": \"Represents a private symbol.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Value\",\n                \"Isolate\",\n                \"String\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Private : public Data {\n            public:\n                /**\n                 * Returns the print name string of the private symbol, or undefined if none.\n                 */\n                Local<Value> Name() const;\n\n                /**\n                 * Create a private symbol. If name is not empty, it will be the description.\n                 */\n                static Local<Private> New(Isolate* isolate,\n                                            Local<String> name = Local<String>());\n\n                /**\n                 * Retrieve a global private symbol. If a symbol with this name has not\n                 * been retrieved in the same isolate before, it is created.\n                 * Note that private symbols created this way are never collected, so\n                 * they should only be used for statically fixed properties.\n                 * Also, there is only one global name space for the names used as keys.\n                 * To minimize the potential for clashes, use qualified names as keys,\n                 * e.g., \"Class#property\".\n                 */\n                static Local<Private> ForApi(Isolate* isolate, Local<String> name);\n\n                V8_INLINE static Private* Cast(Data* data);\n\n            private:\n                Private();\n\n                static void CheckCast(Data* that);\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PropertyDescriptor\",\n            \"about\": \"Represents a property descriptor as defined in ECMA-262.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT PropertyDescriptor {\n            public:\n                // GenericDescriptor\n                PropertyDescriptor();\n\n                // DataDescriptor\n                explicit PropertyDescriptor(Local<Value> value);\n\n                // DataDescriptor with writable property\n                PropertyDescriptor(Local<Value> value, bool writable);\n\n                // AccessorDescriptor\n                PropertyDescriptor(Local<Value> get, Local<Value> set);\n\n                ~PropertyDescriptor();\n\n                Local<Value> value() const;\n                bool has_value() const;\n\n                Local<Value> get() const;\n                bool has_get() const;\n                Local<Value> set() const;\n                bool has_set() const;\n\n                void set_enumerable(bool enumerable);\n                bool enumerable() const;\n                bool has_enumerable() const;\n\n                void set_configurable(bool configurable);\n                bool configurable() const;\n                bool has_configurable() const;\n\n                bool writable() const;\n                bool has_writable() const;\n\n                struct PrivateData;\n                PrivateData* get_private() const { return private_; }\n\n                PropertyDescriptor(const PropertyDescriptor&) = delete;\n                void operator=(const PropertyDescriptor&) = delete;\n\n            private:\n                PrivateData* private_;\n            };\n        ]]></code>\n    </class>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"PropertyAttribute\",\n            \"about\": \"Defines attributes for properties (ReadOnly, DontEnum, DontDelete).\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum PropertyAttribute {\n                /** None. **/\n                None = 0,\n                /** ReadOnly, i.e., not writable. **/\n                ReadOnly = 1 << 0,\n                /** DontEnum, i.e., not enumerable. **/\n                DontEnum = 1 << 1,\n                /** DontDelete, i.e., not configurable. **/\n                DontDelete = 1 << 2\n            };\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"AccessorNameGetterCallback\",\n            \"about\": \"Defines the function signature for accessor getter callbacks.\",\n            \"dependencies\": [\n                \"Local\",\n                \"Name\",\n                \"PropertyCallbackInfo\",\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using AccessorNameGetterCallback =\n                void (*)(Local<Name> property, const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"AccessorNameSetterCallback\",\n            \"about\": \"Defines the function signature for accessor setter callbacks.\",\n            \"dependencies\": [\n                \"Local\",\n                \"Name\",\n                \"Value\",\n                \"PropertyCallbackInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using AccessorNameSetterCallback =\n                void (*)(Local<Name> property, Local<Value> value,\n                         const PropertyCallbackInfo<void>& info);\n        ]]></code>\n    </typedef>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"AccessControl\",\n            \"about\": \"Specifies access control for accessors (deprecated).\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum V8_DEPRECATE_SOON(\n                \"This enum is no longer used and will be removed in V8 12.9.\")\n                AccessControl {\n                  DEFAULT V8_ENUM_DEPRECATE_SOON(\"not used\") = 0,\n                };\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"PropertyFilter\",\n            \"about\": \"Defines bit flags for filtering properties (writable, enumerable, configurable, strings, symbols).\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum PropertyFilter {\n              ALL_PROPERTIES = 0,\n              ONLY_WRITABLE = 1,\n              ONLY_ENUMERABLE = 2,\n              ONLY_CONFIGURABLE = 4,\n              SKIP_STRINGS = 8,\n              SKIP_SYMBOLS = 16\n            };\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"SideEffectType\",\n            \"about\": \"Defines options for marking whether callbacks may trigger JS-observable side effects.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class SideEffectType {\n              kHasSideEffect,\n              kHasNoSideEffect,\n              kHasSideEffectToReceiver\n            };\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"KeyCollectionMode\",\n            \"about\": \"Limits the range of collected properties (own only, includes prototypes).\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class KeyCollectionMode { kOwnOnly, kIncludePrototypes };\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"IndexFilter\",\n            \"about\": \"Defines options to include or skip integer indices when collecting properties.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class IndexFilter { kIncludeIndices, kSkipIndices };\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"KeyConversionMode\",\n            \"about\": \"Defines options for converting integer indices to strings or keeping them as numbers.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class KeyConversionMode { kConvertToString, kKeepNumbers, kNoNumbers };\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"IntegrityLevel\",\n            \"about\": \"Defines integrity levels for objects (frozen, sealed).\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class IntegrityLevel { kFrozen, kSealed };\n        ]]></code>\n    </enum>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Object\",\n            \"extends\": \"Value\",\n            \"about\": \"Represents a JavaScript object.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Value\",\n                \"Context\",\n                \"Name\",\n                \"Array\",\n                \"Function\",\n                \"Private\",\n                \"PropertyDescriptor\",\n                \"PropertyAttribute\",\n                \"FunctionTemplate\",\n                \"Isolate\",\n                \"Maybe\",\n                \"MaybeLocal\",\n                \"AccessorNameGetterCallback\",\n                \"AccessorNameSetterCallback\",\n                \"SideEffectType\",\n                \"KeyCollectionMode\",\n                \"PropertyFilter\",\n                \"IndexFilter\",\n                \"KeyConversionMode\",\n                \"IntegrityLevel\",\n                \"PersistentBase\",\n                \"BasicTracedReference\",\n                \"TracedReference\",\n                \"CppHeapPointerTag\",\n                \"CppHeapPointerTagRange\",\n                \"String\",\n                \"Data\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Object : public Value {\n            public:\n              /**\n               * Set only return Just(true) or Empty(), so if it should never fail, use\n               * result.Check().\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> Set(Local<Context> context,\n                                                    Local<Value> key, Local<Value> value);\n              V8_WARN_UNUSED_RESULT Maybe<bool> Set(Local<Context> context,\n                                                    Local<Value> key, Local<Value> value,\n                                                    MaybeLocal<Object> receiver);\n\n              V8_WARN_UNUSED_RESULT Maybe<bool> Set(Local<Context> context, uint32_t index,\n                                                    Local<Value> value);\n\n              /**\n               * Implements CreateDataProperty(O, P, V), see\n               * https://tc39.es/ecma262/#sec-createdataproperty.\n               *\n               * Defines a configurable, writable, enumerable property with the given value\n               * on the object unless the property already exists and is not configurable\n               * or the object is not extensible.\n               *\n               * Returns true on success.\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> CreateDataProperty(Local<Context> context,\n                                                                   Local<Name> key,\n                                                                   Local<Value> value);\n              V8_WARN_UNUSED_RESULT Maybe<bool> CreateDataProperty(Local<Context> context,\n                                                                   uint32_t index,\n                                                                   Local<Value> value);\n\n              /**\n               * Implements [[DefineOwnProperty]] for data property case, see\n               * https://tc39.es/ecma262/#table-essential-internal-methods.\n               *\n               * In general, CreateDataProperty will be faster, however, does not allow\n               * for specifying attributes.\n               *\n               * Returns true on success.\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> DefineOwnProperty(\n                  Local<Context> context, Local<Name> key, Local<Value> value,\n                  PropertyAttribute attributes = None);\n\n              /**\n               * Implements Object.defineProperty(O, P, Attributes), see\n               * https://tc39.es/ecma262/#sec-object.defineproperty.\n               *\n               * The defineProperty function is used to add an own property or\n               * update the attributes of an existing own property of an object.\n               *\n               * Both data and accessor descriptors can be used.\n               *\n               * In general, CreateDataProperty is faster, however, does not allow\n               * for specifying attributes or an accessor descriptor.\n               *\n               * The PropertyDescriptor can change when redefining a property.\n               *\n               * Returns true on success.\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> DefineProperty(\n                  Local<Context> context, Local<Name> key, PropertyDescriptor& descriptor);\n\n              V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,\n                                                        Local<Value> key);\n              V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,\n                                                        Local<Value> key,\n                                                        MaybeLocal<Object> receiver);\n\n              V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,\n                                                        uint32_t index);\n\n              /**\n               * Gets the property attributes of a property which can be None or\n               * any combination of ReadOnly, DontEnum and DontDelete. Returns\n               * None when the property doesn't exist.\n               */\n              V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute> GetPropertyAttributes(\n                  Local<Context> context, Local<Value> key);\n\n              /**\n               * Implements Object.getOwnPropertyDescriptor(O, P), see\n               * https://tc39.es/ecma262/#sec-object.getownpropertydescriptor.\n               */\n              V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetOwnPropertyDescriptor(\n                  Local<Context> context, Local<Name> key);\n\n              /**\n               * Object::Has() calls the abstract operation HasProperty(O, P), see\n               * https://tc39.es/ecma262/#sec-hasproperty. Has() returns\n               * true, if the object has the property, either own or on the prototype chain.\n               * Interceptors, i.e., PropertyQueryCallbacks, are called if present.\n               *\n               * Has() has the same side effects as JavaScript's `variable in object`.\n               * For example, calling Has() on a revoked proxy will throw an exception.\n               *\n               * \\note Has() converts the key to a name, which possibly calls back into\n               * JavaScript.\n               *\n               * See also v8::Object::HasOwnProperty() and\n               * v8::Object::HasRealNamedProperty().\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context,\n                                                  Local<Value> key);\n\n              V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,\n                                                       Local<Value> key);\n\n              V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context, uint32_t index);\n\n              V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,\n                                                       uint32_t index);\n\n              /**\n               * Sets an accessor property like Template::SetAccessorProperty, but\n               * this method sets on this object directly.\n               */\n              void SetAccessorProperty(Local<Name> name, Local<Function> getter,\n                                       Local<Function> setter = Local<Function>(),\n                                       PropertyAttribute attributes = None);\n\n              /**\n               * Sets a native data property like Template::SetNativeDataProperty, but\n               * this method sets on this object directly.\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> SetNativeDataProperty(\n                  Local<Context> context, Local<Name> name,\n                  AccessorNameGetterCallback getter,\n                  AccessorNameSetterCallback setter = nullptr,\n                  Local<Value> data = Local<Value>(), PropertyAttribute attributes = None,\n                  SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect,\n                  SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);\n\n              /**\n               * Attempts to create a property with the given name which behaves like a data\n               * property, except that the provided getter is invoked (and provided with the\n               * data value) to supply its value the first time it is read. After the\n               * property is accessed once, it is replaced with an ordinary data property.\n               *\n               * Analogous to Template::SetLazyDataProperty.\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> SetLazyDataProperty(\n                  Local<Context> context, Local<Name> name,\n                  AccessorNameGetterCallback getter, Local<Value> data = Local<Value>(),\n                  PropertyAttribute attributes = None,\n                  SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect,\n                  SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);\n\n              /**\n               * Functionality for private properties.\n               * This is an experimental feature, use at your own risk.\n               * Note: Private properties are not inherited. Do not rely on this, since it\n               * may change.\n               */\n              Maybe<bool> HasPrivate(Local<Context> context, Local<Private> key);\n              Maybe<bool> SetPrivate(Local<Context> context, Local<Private> key,\n                                     Local<Value> value);\n              Maybe<bool> DeletePrivate(Local<Context> context, Local<Private> key);\n              MaybeLocal<Value> GetPrivate(Local<Context> context, Local<Private> key);\n\n              /**\n               * Returns an array containing the names of the enumerable properties\n               * of this object, including properties from prototype objects.  The\n               * array returned by this method contains the same values as would\n               * be enumerated by a for-in statement over this object.\n               */\n              V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetPropertyNames(\n                  Local<Context> context);\n              V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetPropertyNames(\n                  Local<Context> context, KeyCollectionMode mode,\n                  PropertyFilter property_filter, IndexFilter index_filter,\n                  KeyConversionMode key_conversion = KeyConversionMode::kKeepNumbers);\n\n              /**\n               * This function has the same functionality as GetPropertyNames but\n               * the returned array doesn't contain the names of properties from\n               * prototype objects.\n               */\n              V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetOwnPropertyNames(\n                  Local<Context> context);\n\n              /**\n               * Returns an array containing the names of the filtered properties\n               * of this object, including properties from prototype objects.  The\n               * array returned by this method contains the same values as would\n               * be enumerated by a for-in statement over this object.\n               */\n              V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetOwnPropertyNames(\n                  Local<Context> context, PropertyFilter filter,\n                  KeyConversionMode key_conversion = KeyConversionMode::kKeepNumbers);\n\n              /**\n               * Get the prototype object.  This does not skip objects marked to\n               * be skipped by __proto__ and it does not consult the security\n               * handler.\n               */\n              V8_DEPRECATE_SOON(\n                  \"V8 will stop providing access to hidden prototype (i.e. \"\n                  \"JSGlobalObject). Use GetPrototypeV2() instead. \"\n                  \"See http://crbug.com/333672197.\")\n              Local<Value> GetPrototype();\n\n              /**\n               * Get the prototype object (same as getting __proto__ property).  This does\n               * not consult the security handler.\n               * TODO(333672197): rename back to GetPrototype() once the old version goes\n               * through the deprecation process and is removed.\n               */\n              Local<Value> GetPrototypeV2();\n\n              /**\n               * Set the prototype object.  This does not skip objects marked to\n               * be skipped by __proto__ and it does not consult the security\n               * handler.\n               */\n              V8_DEPRECATE_SOON(\n                  \"V8 will stop providing access to hidden prototype (i.e. \"\n                  \"JSGlobalObject). Use SetPrototypeV2() instead. \"\n                  \"See http://crbug.com/333672197.\")\n              V8_WARN_UNUSED_RESULT Maybe<bool> SetPrototype(Local<Context> context,\n                                                             Local<Value> prototype);\n\n              /**\n               * Set the prototype object (same as setting __proto__ property).  This does\n               * does not consult the security handler.\n               * TODO(333672197): rename back to SetPrototype() once the old version goes\n               * through the deprecation process and is removed.\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> SetPrototypeV2(Local<Context> context,\n                                                             Local<Value> prototype);\n\n              /**\n               * Finds an instance of the given function template in the prototype\n               * chain.\n               */\n              Local<Object> FindInstanceInPrototypeChain(Local<FunctionTemplate> tmpl);\n\n              /**\n               * Call builtin Object.prototype.toString on this object.\n               * This is different from Value::ToString() that may call\n               * user-defined toString function. This one does not.\n               */\n              V8_WARN_UNUSED_RESULT MaybeLocal<String> ObjectProtoToString(\n                  Local<Context> context);\n\n              /**\n               * Returns the name of the function invoked as a constructor for this object.\n               */\n              Local<String> GetConstructorName();\n\n              /**\n               * Sets the integrity level of the object.\n               */\n              Maybe<bool> SetIntegrityLevel(Local<Context> context, IntegrityLevel level);\n\n              /** Gets the number of internal fields for this Object. */\n              int InternalFieldCount() const;\n\n              /** Same as above, but works for PersistentBase. */\n              V8_INLINE static int InternalFieldCount(\n                  const PersistentBase<Object>& object) {\n                return object.template value<Object>()->InternalFieldCount();\n              }\n\n              /** Same as above, but works for BasicTracedReference. */\n              V8_INLINE static int InternalFieldCount(\n                  const BasicTracedReference<Object>& object) {\n                return object.template value<Object>()->InternalFieldCount();\n              }\n\n              /**\n               * Gets the data from an internal field.\n               * To cast the return value into v8::Value subtypes, it needs to be\n               * casted to a v8::Value first. For example, to cast it into v8::External:\n               *\n               * object->GetInternalField(index).As<v8::Value>().As<v8::External>();\n               *\n               * The embedder should make sure that the internal field being retrieved\n               * using this method has already been set with SetInternalField() before.\n               **/\n              V8_INLINE Local<Data> GetInternalField(int index);\n\n              /** Sets the data in an internal field. */\n              void SetInternalField(int index, Local<Data> data);\n\n              /**\n               * Gets a 2-byte-aligned native pointer from an internal field. This field\n               * must have been set by SetAlignedPointerInInternalField, everything else\n               * leads to undefined behavior.\n               */\n              V8_INLINE void* GetAlignedPointerFromInternalField(int index);\n              V8_INLINE void* GetAlignedPointerFromInternalField(v8::Isolate* isolate,\n                                                                 int index);\n\n              /** Same as above, but works for PersistentBase. */\n              V8_INLINE static void* GetAlignedPointerFromInternalField(\n                  const PersistentBase<Object>& object, int index) {\n                return object.template value<Object>()->GetAlignedPointerFromInternalField(\n                    index);\n              }\n\n              /** Same as above, but works for TracedReference. */\n              V8_INLINE static void* GetAlignedPointerFromInternalField(\n                  const BasicTracedReference<Object>& object, int index) {\n                return object.template value<Object>()->GetAlignedPointerFromInternalField(\n                    index);\n              }\n\n              /**\n               * Sets a 2-byte-aligned native pointer in an internal field. To retrieve such\n               * a field, GetAlignedPointerFromInternalField must be used, everything else\n               * leads to undefined behavior.\n               */\n              void SetAlignedPointerInInternalField(int index, void* value);\n              void SetAlignedPointerInInternalFields(int argc, int indices[],\n                                                     void* values[]);\n\n              /**\n               * Unwraps a JS wrapper object.\n               *\n               * \\param tag The tag for retrieving the wrappable instance. Must match the\n               * tag that has been used for a previous `Wrap()` operation.\n               * \\param isolate The Isolate for the `wrapper` object.\n               * \\param wrapper The JS wrapper object that should be unwrapped.\n               * \\returns the C++ wrappable instance, or nullptr if the JS object has never\n               * been wrapped.\n               */\n              template <CppHeapPointerTag tag, typename T = void>\n              static V8_INLINE T* Unwrap(v8::Isolate* isolate,\n                                         const v8::Local<v8::Object>& wrapper);\n              template <CppHeapPointerTag tag, typename T = void>\n              static V8_INLINE T* Unwrap(v8::Isolate* isolate,\n                                         const PersistentBase<Object>& wrapper);\n              template <CppHeapPointerTag tag, typename T = void>\n              static V8_INLINE T* Unwrap(v8::Isolate* isolate,\n                                         const BasicTracedReference<Object>& wrapper);\n\n              template <typename T = void>\n              static V8_INLINE T* Unwrap(v8::Isolate* isolate,\n                                         const v8::Local<v8::Object>& wrapper,\n                                         CppHeapPointerTagRange tag_range);\n              template <typename T = void>\n              static V8_INLINE T* Unwrap(v8::Isolate* isolate,\n                                         const PersistentBase<Object>& wrapper,\n                                         CppHeapPointerTagRange tag_range);\n              template <typename T = void>\n              static V8_INLINE T* Unwrap(v8::Isolate* isolate,\n                                         const BasicTracedReference<Object>& wrapper,\n                                         CppHeapPointerTagRange tag_range);\n\n              /**\n               * Wraps a JS wrapper with a C++ instance.\n               *\n               * \\param tag The pointer tag that should be used for storing this object.\n               * Future `Unwrap()` operations must provide a matching tag.\n               * \\param isolate The Isolate for the `wrapper` object.\n               * \\param wrapper The JS wrapper object.\n               * \\param wrappable The C++ object instance that is wrapped by the JS object.\n               */\n              template <CppHeapPointerTag tag>\n              static V8_INLINE void Wrap(v8::Isolate* isolate,\n                                         const v8::Local<v8::Object>& wrapper,\n                                         void* wrappable);\n              template <CppHeapPointerTag tag>\n              static V8_INLINE void Wrap(v8::Isolate* isolate,\n                                         const PersistentBase<Object>& wrapper,\n                                         void* wrappable);\n              template <CppHeapPointerTag tag>\n              static V8_INLINE void Wrap(v8::Isolate* isolate,\n                                         const BasicTracedReference<Object>& wrapper,\n                                         void* wrappable);\n              static V8_INLINE void Wrap(v8::Isolate* isolate,\n                                         const v8::Local<v8::Object>& wrapper,\n                                         void* wrappable, CppHeapPointerTag tag);\n              static V8_INLINE void Wrap(v8::Isolate* isolate,\n                                         const PersistentBase<Object>& wrapper,\n                                         void* wrappable, CppHeapPointerTag tag);\n              static V8_INLINE void Wrap(v8::Isolate* isolate,\n                                         const BasicTracedReference<Object>& wrapper,\n                                         void* wrappable, CppHeapPointerTag tag);\n\n              /**\n               * HasOwnProperty() is like JavaScript's\n               * Object.prototype.hasOwnProperty().\n               *\n               * See also v8::Object::Has() and v8::Object::HasRealNamedProperty().\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> HasOwnProperty(Local<Context> context,\n                                                               Local<Name> key);\n              V8_WARN_UNUSED_RESULT Maybe<bool> HasOwnProperty(Local<Context> context,\n                                                               uint32_t index);\n              /**\n               * Use HasRealNamedProperty() if you want to check if an object has an own\n               * property without causing side effects, i.e., without calling interceptors.\n               *\n               * This function is similar to v8::Object::HasOwnProperty(), but it does not\n               * call interceptors.\n               *\n               * \\note Consider using non-masking interceptors, i.e., the interceptors are\n               * not called if the receiver has the real named property. See\n               * `v8::PropertyHandlerFlags::kNonMasking`.\n               *\n               * See also v8::Object::Has().\n               */\n              V8_WARN_UNUSED_RESULT Maybe<bool> HasRealNamedProperty(Local<Context> context,\n                                                                   Local<Name> key);\n              V8_WARN_UNUSED_RESULT Maybe<bool> HasRealIndexedProperty(\n                  Local<Context> context, uint32_t index);\n              V8_WARN_UNUSED_RESULT Maybe<bool> HasRealNamedCallbackProperty(\n                  Local<Context> context, Local<Name> key);\n\n              /**\n               * If result.IsEmpty() no real property was located in the prototype chain.\n               * This means interceptors in the prototype chain are not called.\n               */\n              V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetRealNamedPropertyInPrototypeChain(\n                  Local<Context> context, Local<Name> key);\n\n              /**\n               * Gets the property attributes of a real property in the prototype chain,\n               * which can be None or any combination of ReadOnly, DontEnum and DontDelete.\n               * Interceptors in the prototype chain are not called.\n               */\n              V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute>\n              GetRealNamedPropertyAttributesInPrototypeChain(Local<Context> context,\n                                                             Local<Name> key);\n\n              /**\n               * If result.IsEmpty() no real property was located on the object or\n               * in the prototype chain.\n               * This means interceptors in the prototype chain are not called.\n               */\n              V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetRealNamedProperty(\n                  Local<Context> context, Local<Name> key);\n\n              /**\n               * Gets the property attributes of a real property which can be\n               * None or any combination of ReadOnly, DontEnum and DontDelete.\n               * Interceptors in the prototype chain are not called.\n               */\n              V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute> GetRealNamedPropertyAttributes(\n                  Local<Context> context, Local<Name> key);\n\n              /** Tests for a named lookup interceptor.*/\n              bool HasNamedLookupInterceptor() const;\n\n              /** Tests for an index lookup interceptor.*/\n              bool HasIndexedLookupInterceptor() const;\n\n              /**\n               * Returns the identity hash for this object. The current implementation\n               * uses a hidden property on the object to store the identity hash.\n               *\n               * The return value will never be 0. Also, it is not guaranteed to be\n               * unique.\n               */\n              int GetIdentityHash();\n\n              /**\n               * Clone this object with a fast but shallow copy. Values will point to the\n               * same values as the original object.\n               *\n               * Prefer using version with Isolate parameter.\n               */\n              Local<Object> Clone(v8::Isolate* isolate);\n              Local<Object> Clone();\n\n              /**\n               * Returns the context in which the object was created.\n               *\n               * Prefer using version with Isolate parameter.\n               */\n              MaybeLocal<Context> GetCreationContext(v8::Isolate* isolate);\n              V8_DEPRECATE_SOON(\"Use the version with the isolate argument.\")\n              MaybeLocal<Context> GetCreationContext();\n\n              /**\n               * Shortcut for GetCreationContext(...).ToLocalChecked().\n               *\n               * Prefer using version with Isolate parameter.\n               **/\n              Local<Context> GetCreationContextChecked(v8::Isolate* isolate);\n              V8_DEPRECATE_SOON(\"Use the version with the isolate argument.\")\n              Local<Context> GetCreationContextChecked();\n\n              /** Same as above, but works for Persistents */\n              V8_INLINE static MaybeLocal<Context> GetCreationContext(\n                  v8::Isolate* isolate, const PersistentBase<Object>& object) {\n                return object.template value<Object>()->GetCreationContext(isolate);\n              }\n              V8_DEPRECATE_SOON(\"Use the version with the isolate argument.\")\n              V8_INLINE static MaybeLocal<Context> GetCreationContext(\n                  const PersistentBase<Object>& object);\n\n              /**"
}