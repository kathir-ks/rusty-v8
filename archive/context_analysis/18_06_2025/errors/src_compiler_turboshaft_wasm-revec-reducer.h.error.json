{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-revec-reducer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-revec-reducer.h\",\n            \"file_name\": \"wasm-revec-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Header file defining classes and logic for revectorizing WebAssembly code in Turboshaft, specifically targeting SIMD 128-bit to 256-bit vectorization.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard library and V8-specific headers for various functionalities, including algorithms, safe conversions, Turboshaft infrastructure, and WebAssembly graph manipulation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <algorithm>\n\n            #include \"src/base/safe_conversions.h\"\n            #include \"src/compiler/turboshaft/assembler.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/phase.h\"\n            #include \"src/compiler/turboshaft/use-map.h\"\n            #include \"src/compiler/wasm-graph-assembler.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NodeGroup\",\n                \"about\": \"Represents a group of nodes that can be potentially packed together for SIMD vectorization.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kSize\",\n                        \"type\": \"constexpr int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Defines the size of the NodeGroup, which is the ratio of SIMD256 size to SIMD128 size (i.e., 2).\"\n                    },\n                    {\n                        \"name\": \"indexes_\",\n                        \"type\": \"OpIndex[kSize]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array storing the OpIndex values of the nodes in the group.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"OpIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class NodeGroup {\n            public:\n            // Current only support merge 2 Simd128 into Simd256\n            static constexpr int kSize = kSimd256Size / kSimd128Size;\n            NodeGroup(OpIndex a, OpIndex b) {\n                indexes_[0] = a;\n                indexes_[1] = b;\n            }\n            size_t size() const { return kSize; }\n            OpIndex operator[](int i) const { return indexes_[i]; }\n\n            bool operator==(const NodeGroup& other) const {\n                return indexes_[0] == other.indexes_[0] && indexes_[1] == other.indexes_[1];\n            }\n            bool operator!=(const NodeGroup& other) const {\n                return indexes_[0] != other.indexes_[0] || indexes_[1] != other.indexes_[1];\n            }\n\n            const OpIndex* begin() const { return indexes_; }\n            const OpIndex* end() const { return indexes_ + kSize; }\n\n            private:\n            OpIndex indexes_[kSize];\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PackNode\",\n                \"about\": \"Represents a collection of isomorphic SIMD128 nodes that can be executed in parallel and converted to a 256-bit SIMD node.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"nodes_\",\n                        \"type\": \"NodeGroup\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The group of nodes that are packed together.\"\n                    },\n                    {\n                        \"name\": \"revectorized_node_\",\n                        \"type\": \"V<Simd256>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The SIMD256 node that results from vectorizing the PackNode.\"\n                    },\n                    {\n                        \"name\": \"operands_\",\n                        \"type\": \"ZoneVector<PackNode*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of PackNode operands.\"\n                    },\n                    {\n                        \"name\": \"node_type_\",\n                        \"type\": \"NodeType\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The type of the PackNode, indicating how the nodes are packed.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"NodeGroup\",\n                    \"V<Simd256>\",\n                    \"OpIndex\",\n                    \"ZoneVector\",\n                    \"ForcePackNode\",\n                    \"ShufflePackNode\",\n                    \"BundlePackNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // A PackNode consists of a fixed number of isomorphic simd128 nodes which can\n            // execute in parallel and convert to a 256-bit simd node later. The nodes in a\n            // PackNode must satisfy that they can be scheduled in the same basic block and\n            // are mutually independent.\n            class PackNode : public NON_EXPORTED_BASE(ZoneObject) {\n            public:\n            enum NodeType {\n                kDefault,        // Nodes are naturally packed without special attributes.\n                kForcePackNode,  // Nodes do not satisfy some packing rule, but can be\n                                // forcely coalesced with a Pack128To256 operation. E.g.\n                                // inconsecutive loads. In x64, we can use the vinsertf128\n                                // instruction to forcely coalescing two 128-bit values.\n                kShufflePackNode,  // Nodes are Simd128Shuffle operations with specific\n                                // info.\n                kBundlePackNode,   // Nodes representing a i8x16/i16x8 to f32x4 conversion.\n                kIntersectPackNode,  // One or more nodes already packed by an existing\n                                    // PackNode.\n            };\n\n            explicit PackNode(Zone* zone, const NodeGroup& node_group,\n                                NodeType node_type = kDefault)\n                : nodes_(node_group),\n                revectorized_node_(),\n                operands_(zone),\n                node_type_(node_type) {}\n            const NodeGroup& nodes() const { return nodes_; }\n            bool IsSame(const NodeGroup& node_group) const {\n                return nodes_ == node_group;\n            }\n            bool IsSame(const PackNode& other) const { return nodes_ == other.nodes_; }\n            V<Simd256> RevectorizedNode() const { return revectorized_node_; }\n            void SetRevectorizedNode(V<Simd256> node) { revectorized_node_ = node; }\n\n            bool IsDefaultPackNode() const { return node_type_ == kDefault; }\n            bool IsForcePackNode() const { return node_type_ == kForcePackNode; }\n            bool IsShufflePackNode() const { return node_type_ == kShufflePackNode; }\n            bool IsBundlePackNode() const { return node_type_ == kBundlePackNode; }\n            // We will force-pack nodes for both ForcePackNode and IntersectPackNode.\n            bool is_force_packing() const {\n                return node_type_ == kForcePackNode || node_type_ == kIntersectPackNode;\n            }\n\n            ForcePackNode* AsForcePackNode() {\n                DCHECK(IsForcePackNode());\n                return reinterpret_cast<ForcePackNode*>(this);\n            }\n            ShufflePackNode* AsShufflePackNode() {\n                DCHECK(IsShufflePackNode());\n                return reinterpret_cast<ShufflePackNode*>(this);\n            }\n            BundlePackNode* AsBundlePackNode() {\n                DCHECK(IsBundlePackNode());\n                return reinterpret_cast<BundlePackNode*>(this);\n            }\n\n            PackNode* GetOperand(int index) const {\n                DCHECK_LT(index, operands_.size());\n                DCHECK(operands_[index]);\n                return operands_[index];\n            }\n\n            void SetOperand(int index, PackNode* pnode) {\n                DCHECK_GE(index, 0);\n                if (operands_.size() < static_cast<size_t>(index + 1)) {\n                operands_.resize(index + 1);\n                }\n                operands_[index] = pnode;\n            }\n\n            ZoneVector<PackNode*>::size_type GetOperandsSize() const {\n                return operands_.size();\n            }\n\n            void Print(Graph* graph) const;\n\n            private:\n            friend class ForcePackNode;\n            NodeGroup nodes_;\n            V<Simd256> revectorized_node_;\n            ZoneVector<PackNode*> operands_;\n            NodeType node_type_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ForcePackNode\",\n                \"extends\": \"PackNode\",\n                \"about\": \"Represents a PackNode that requires forced packing, typically due to non-consecutive loads or other constraints.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"force_pack_type_\",\n                        \"type\": \"ForcePackType\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Specifies the type of forced packing required (e.g., splatting identical nodes or general packing).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"PackNode\",\n                    \"NodeGroup\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class ForcePackNode : public PackNode {\n            public:\n            enum ForcePackType {\n                kSplat,    // force pack 2 identical nodes or 2 loads at the same address\n                kGeneral,  // force pack 2 different nodes\n            };\n            explicit ForcePackNode(Zone* zone, const NodeGroup& node_group,\n                                    ForcePackType type)\n                : PackNode(zone, node_group, kForcePackNode), force_pack_type_(type) {}\n\n            ForcePackType force_pack_type() const { return force_pack_type_; }\n\n            private:\n            ForcePackType force_pack_type_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ShufflePackNode\",\n                \"extends\": \"PackNode\",\n                \"about\": \"Represents a PackNode specifically for SIMD128 shuffle operations, providing information for efficient 256-bit shuffle generation.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"PackNode\",\n                    \"NodeGroup\",\n                    \"Simd128ShuffleOp\",\n                    \"Simd128LoadTransformOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class ShufflePackNode : public PackNode {\n            public:\n            class SpecificInfo {\n            public:\n                enum class Kind {\n                kS256Load32Transform,\n                kS256Load64Transform,\n                kS256Load8x8U,\n            #ifdef V8_TARGET_ARCH_X64\n                kShufd,\n                kShufps,\n                kS32x8UnpackLow,\n                kS32x8UnpackHigh,\n            #endif  // V8_TARGET_ARCH_X64\n                };\n                union Param {\n                int splat_index = 0;\n            #ifdef V8_TARGET_ARCH_X64\n                uint8_t shufd_control;\n                uint8_t shufps_control;\n            #endif  // V8_TARGET_ARCH_X64\n                };\n\n                Kind kind() { return kind_; }\n                void set_kind(Kind kind) { kind_ = kind; }\n\n                void set_splat_index(uint8_t value) {\n                DCHECK(kind_ == Kind::kS256Load32Transform ||\n                            kind_ == Kind::kS256Load64Transform);\n                param_.splat_index = value;\n                }\n                int splat_index() const {\n                DCHECK(kind_ == Kind::kS256Load32Transform ||\n                            kind_ == Kind::kS256Load64Transform);\n                return param_.splat_index;\n                }\n\n            #ifdef V8_TARGET_ARCH_X64\n                void set_shufd_control(uint8_t control) {\n                DCHECK_EQ(kind_, Kind::kShufd);\n                param_.shufd_control = control;\n                }\n                uint8_t shufd_control() const {\n                DCHECK_EQ(kind_, Kind::kShufd);\n                return param_.shufd_control;\n                }\n\n                void set_shufps_control(uint8_t control) {\n                DCHECK_EQ(kind_, Kind::kShufps);\n                param_.shufps_control = control;\n                }\n                uint8_t shufps_control() const {\n                DCHECK_EQ(kind_, Kind::kShufps);\n                return param_.shufps_control;\n                }\n            #endif  // V8_TARGET_ARCH_X64\n\n            private:\n                Kind kind_;\n                Param param_;\n            };\n\n            ShufflePackNode(Zone* zone, const NodeGroup& node_group,\n                                SpecificInfo::Kind kind)\n                : PackNode(zone, node_group, kShufflePackNode) {\n                info_.set_kind(kind);\n            }\n\n            SpecificInfo& info() { return info_; }\n\n            private:\n            SpecificInfo info_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BundlePackNode\",\n                \"extends\": \"PackNode\",\n                \"about\": \"Represents a PackNode specifically for i8x16/i16x8 to f32x4 conversions.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"base_\",\n                        \"type\": \"OpIndex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The base index for conversion\"\n                    },\n                    {\n                        \"name\": \"offset_\",\n                        \"type\": \"uint8_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The offset where lane starts\"\n                    },\n                    {\n                        \"name\": \"lane_size_\",\n                        \"type\": \"uint8_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Size of lane(1 or 2)\"\n                    },\n                    {\n                        \"name\": \"is_sign_extract_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"If it's sign extract or not\"\n                    },\n                    {\n                        \"name\": \"is_sign_convert_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"If it's signed conversion or not\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"PackNode\",\n                    \"NodeGroup\",\n                    \"OpIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // BundlePackNode is used to represent a i8x16/i16x8 to f32x4 conversion.\n            // The conversion extracts 4 lanes of i8x16/i16x8 input(base), start from lane\n            // index(offset), sign/zero(is_sign_extract) extends the extracted lanes to\n            // i32x4, then converts i32x4/u32x4(is_sign_convert) to f32x4.\n            class BundlePackNode : public PackNode {\n            public:\n                BundlePackNode(Zone* zone, const NodeGroup& node_group, OpIndex base,\n                            int8_t offset, uint8_t lane_size, bool is_sign_extract,\n                            bool is_sign_convert)\n                : PackNode(zone, node_group, kBundlePackNode) {\n                    base_ = base;\n                    offset_ = offset;\n                    lane_size_ = lane_size;\n                    is_sign_extract_ = is_sign_extract;\n                    is_sign_convert_ = is_sign_convert;\n                }\n\n                OpIndex base() const { return base_; }\n                uint8_t offset() const { return offset_; }\n                uint8_t lane_size() const { return lane_size_; }\n                bool is_sign_extract() const { return is_sign_extract_; }\n                bool is_sign_convert() const { return is_sign_convert_; }\n\n            private:\n                OpIndex base_;\n                uint8_t offset_;\n                uint8_t lane_size_;\n                bool is_sign_extract_;\n                bool is_sign_convert_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SLPTree\",\n                \"about\": \"An auxiliary tree structure for Superword Level Parallelism (SLP) vectorization, managing PackNodes.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"RecursionMaxDepth\",\n                        \"type\": \"static constexpr size_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Maximum recursion depth for building the tree.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Graph\",\n                    \"WasmRevecAnalyzer\",\n                    \"Zone\",\n                    \"NodeGroup\",\n                    \"PackNode\",\n                    \"OpIndex\",\n                    \"ZoneUnorderedMap\",\n                    \"ZoneVector\",\n                    \"ForcePackNode\",\n                    \"ShufflePackNode\",\n                    \"Simd128ExtractLaneOp\",\n                    \"ChangeOp\",\n                    \"BundlePackNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // An auxillary tree structure with a set of PackNodes based on the Superword\n            // Level Parallelism (SLP) vectorization technique. The BuildTree method will\n            // start from a selected root, e.g. a group of consecutive stores, and extend\n            // through value inputs to create new PackNodes if the inputs are valid, or\n            // conclude that the current PackNode is a leaf and terminate the tree.\n            // Below is an example of SLPTree where loads and stores in each PackNode are\n            // all consecutive.\n            // [Load0, Load1]  [Load2, Load3]\n            //           \\       /\n            //          [Add0, Add1]\n            //                |\n            //         [Store0, Store1]\n            class SLPTree : public NON_EXPORTED_BASE(ZoneObject) {\n            public:\n            explicit SLPTree(Graph& graph, WasmRevecAnalyzer* analyzer, Zone* zone)\n                : graph_(graph),\n                analyzer_(analyzer),\n                phase_zone_(zone),\n                root_(nullptr),\n                node_to_packnode_(zone),\n                node_to_intersect_packnodes_(zone) {}\n\n            // Information for extending i8x16/i16x8 to f32x4\n            struct ExtendIntToF32x4Info {\n                OpIndex extend_from;\n                uint8_t start_lane;    // 0 or 8\n                uint8_t lane_size;     // 1(i8) or 2(i16)\n                bool is_sign_extract;  // extract_lane_s or extract_lane_u\n                bool is_sign_convert;  // f32x4.convert_i32x4_s or f32x4.convert_i32x4_u\n            };\n\n            // Per-lane information for extending i8x16/i16x8 to f32x4\n            struct LaneExtendInfo {\n                OpIndex extract_from;\n                Simd128ExtractLaneOp::Kind extract_kind;\n                int extract_lane_index;\n                ChangeOp::Kind change_kind;\n                int replace_lane_index;\n            };\n\n            PackNode* BuildTree(const NodeGroup& roots);\n            void DeleteTree();\n\n            PackNode* GetPackNode(OpIndex node);\n            ZoneVector<PackNode*>* GetIntersectPackNodes(OpIndex node);\n            ZoneUnorderedMap<OpIndex, PackNode*>& GetNodeMapping() {\n                return node_to_packnode_;\n            }\n            ZoneUnorderedMap<OpIndex, ZoneVector<PackNode*>>& GetIntersectNodeMapping() {\n                return node_to_intersect_packnodes_;\n            }\n\n            void Print(const char* info);\n\n            private:\n            // This is the recursive part of BuildTree.\n            PackNode* BuildTreeRec(const NodeGroup& node_group, unsigned depth);\n\n            // Baseline: create a new PackNode, and return.\n            PackNode* NewPackNode(const NodeGroup& node_group);\n\n            // Baseline: create a new IntersectPackNode that contains nodes existing in\n            // another PackNode, and return.\n            PackNode* NewIntersectPackNode(const NodeGroup& node_group);\n\n            PackNode* NewForcePackNode(const NodeGroup& node_group,\n                                        ForcePackNode::ForcePackType type,\n                                        const Graph& graph);\n            BundlePackNode* NewBundlePackNode(const NodeGroup& node_group, OpIndex base,\n                                                int8_t offset, uint8_t lane_size,\n                                                bool is_sign_extract, bool is_sign_convert);\n\n            // Recursion: create a new PackNode and call BuildTreeRec recursively\n            PackNode* NewPackNodeAndRecurs(const NodeGroup& node_group, int start_index,\n                                            int count, unsigned depth);\n\n            PackNode* NewCommutativePackNodeAndRecurs(const NodeGroup& node_group,\n                                                        unsigned depth);\n\n            ShufflePackNode* NewShufflePackNode(const NodeGroup& node_group,\n                                                ShufflePackNode::SpecificInfo::Kind kind);\n\n            // Try match the following pattern:\n            //   1. simd128_load64zero(memargs)\n            //   2. simd128_const[0,0,0,0]\n            //   3. simd128_shuffle(1, 2, shuffle_arg0)\n            //   4. simd128_shuffle(1, 2, shuffle_arg1)\n            // To:\n            //   1. simd256_load8x8u(memargs)\n            ShufflePackNode* Try256ShuffleMatchLoad8x8U(const NodeGroup& node_group,\n                                                        const uint8_t* shuffle0,\n                                                        const uint8_t* shuffle1);\n\n            #ifdef V8_TARGET_ARCH_X64\n            // The Simd Shuffle in wasm is a high level representation, and it can map to\n            // different x64 intructions base on its shuffle array. And the performance of\n            // different intructions are varies greatly.\n            // For example, if the shuffle array are totally random, there is a high\n            // probability to use a general shuffle. Under x64, the general shuffle may\n            // consists of a series mov, a vpinsrq and a vpshufb. It's performance cost is\n            // high. However, if the shuffle array is in an particular pattern, for\n            // example: [0,  1,  2,  3,  32, 33, 34, 35, 4,  5,  6,  7,  36, 37, 38, 39,\n            //      16, 17, 18, 19, 48, 49, 50, 51, 20, 21, 22, 23, 52, 53, 54, 55]\n            // we can use a single vpunpckldq instruction. It's performance cost is much\n            // more lower than a general one.\n            //\n            // This function is used to try to match the shuffle array to the\n            // x64 instructions which has the best performance.\n            ShufflePackNode* X64TryMatch256Shuffle(const NodeGroup& node_group,\n                                                    const uint8_t* shuffle0,\n                                                    const uint8_t* shuffle1);\n            #endif  // V8_TARGET_ARCH_X64\n\n            bool TryMatchExtendIntToF32x4(const NodeGroup& node_group,\n                                            ExtendIntToF32x4Info* info);\n            std::optional<ExtendIntToF32x4Info> TryGetExtendIntToF32x4Info(OpIndex index);\n\n            bool IsSideEffectFree(OpIndex first, OpIndex second);\n            bool CanBePacked(const NodeGroup& node_group);\n            bool IsEqual(const OpIndex node0, const OpIndex node1);\n            // Check if the nodes in the node_group depend on the result of each other.\n            bool HasInputDependencies(const NodeGroup& node_group);\n\n            Graph& graph() const { return graph_; }\n            Zone* zone() const { return phase_zone_; }\n\n            Graph& graph_;\n            WasmRevecAnalyzer* analyzer_;\n            Zone* phase_zone_;\n            PackNode* root_;\n            // Maps a specific node to PackNode.\n            ZoneUnorderedMap<OpIndex, PackNode*> node_to_packnode_;\n            // Maps a node to multiple IntersectPackNodes.\n            ZoneUnorderedMap<OpIndex, ZoneVector<PackNode*>> node_to_intersect_packnodes_;\n            static constexpr size_t RecursionMaxDepth = 1000;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmRevecAnalyzer\",\n                \"about\": \"Analyzes the WebAssembly code to identify opportunities for SIMD revectorization.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"should_reduce_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether revectorization should be performed.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"PipelineData\",\n                    \"Zone\",\n                    \"Graph\",\n                    \"PackNode\",\n                    \"OpIndex\",\n                    \"ZoneUnorderedMap\",\n                    \"ZoneVector\",\n                    \"Block\",\n                    \"SimdUseMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class WasmRevecAnalyzer {\n            public:\n            WasmRevecAnalyzer(PipelineData* data, Zone* zone, Graph& graph)\n                : data_(data),\n                graph_(graph),\n                phase_zone_(zone),\n                store_seeds_(zone),\n                reduce_seeds_(zone),\n                revectorizable_node_(zone),\n                revectorizable_intersect_node_(zone),\n                should_reduce_(false),\n                use_map_(nullptr) {\n                Run();\n            }\n\n            void Run();\n\n            void MergeSLPTree(SLPTree& slp_tree);\n            bool ShouldReduce() const { return should_reduce_; }\n\n            PackNode* GetPackNode(const OpIndex ig_index) {\n                auto itr = revectorizable_node_.find(ig_index);\n                if (itr != revectorizable_node_.end()) {\n                return itr->second;\n                }\n                return nullptr;\n            }\n\n            ZoneVector<PackNode*>* GetIntersectPackNodes(const OpIndex node) {\n                auto I = revectorizable_intersect_node_.find(node);\n                if (I != revectorizable_intersect_node_.end()) {\n                return &(I->second);\n                }\n                return nullptr;\n            }\n\n            const OpIndex GetReducedInput(const PackNode* pnode, const int index = 0) {\n                if (index >= static_cast<int>(pnode->GetOperandsSize())) {\n                return OpIndex::Invalid();\n                }\n                return pnode->GetOperand(index)->RevectorizedNode();\n            }\n\n            const Operation& GetStartOperation(const PackNode* pnode, const OpIndex node,\n                                                const Operation& op) {\n                DCHECK(pnode);\n                const OpIndex start = pnode->nodes()[0];\n                return (start == node) ? op : graph_.Get(start);\n            }\n\n            base::Vector<const OpIndex> uses(OpIndex node) {\n                return use_map_->uses(node);\n            }\n\n            private:\n            bool IsSupportedReduceSeed(const Operation& op);\n            void ProcessBlock(const Block& block);\n            bool DecideVectorize();\n            void Print(const char* info);\n\n            PipelineData* data_;\n            Graph& graph_;\n            Zone* phase_zone_;\n            ZoneVector<std::pair<OpIndex, OpIndex>> store_seeds_;\n            ZoneVector<std::pair<OpIndex, OpIndex>> reduce_seeds_;\n            const wasm::WasmModule* module_ = data_->wasm_module();\n            ZoneUnorderedMap<OpIndex, PackNode*> revectorizable_node_;\n            ZoneUnorderedMap<OpIndex, ZoneVector<PackNode*>>\n                revectorizable_intersect_node_;\n            bool should_reduce_;\n            SimdUseMap* use_map_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmRevecReducer\",\n                \"extends\": \"UniformReducerAdapter<WasmRevecReducer, Next>\",\n                \"about\": \"The reducer class that performs the actual SIMD revectorization transformations in the Turboshaft pipeline.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"UniformReducerAdapter\",\n                    \"PackNode\",\n                    \"OpIndex\",\n                    \"Simd128ConstantOp\",\n                    \"Simd128LoadTransformOp\",\n                    \"LoadOp\",\n                    \"StoreOp\",\n                    \"PhiOp\",\n                    \"Simd128UnaryOp\",\n                    \"Simd128BinopOp\",\n                    \"Simd128ShiftOp\",\n                    \"Simd128TernaryOp\",\n                    \"Simd128SplatOp\",\n                    \"Simd128ShuffleOp\",\n                    \"ShufflePackNode\",\n                    \"Simd128ReplaceLaneOp\",\n                    \"BundlePackNode\",\n                    \"WasmRevecAnalyzer\",\n                    \"Block\",\n                    \"PendingLoopPhiOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <class Next>\n            class WasmRevecReducer : public UniformReducerAdapter<WasmRevecReducer, Next> {\n            public:\n            TURBOSHAFT_REDUCER_BOILERPLATE(WasmRevec)\n            using Adapter = UniformReducerAdapter<WasmRevecReducer, Next>;\n\n            OpIndex GetExtractOpIfNeeded(const PackNode* pnode, OpIndex ig_index,\n                                        OpIndex og_index) {\n                const auto lane = base::checked_cast<uint8_t>(\n                    std::find(pnode->nodes().begin(), pnode->nodes().end(), ig_index) -\n                    pnode->nodes().begin());\n\n                // Force PackNode has a dedicated use in SimdPack128To256Op.\n                if (pnode->is_force_packing()) {\n                SimdPack128To256Op& op = __ output_graph()\n                                                .Get(pnode -> RevectorizedNode())\n                                                .template Cast<SimdPack128To256Op>();\n                return lane == 0 ? op.left() : op.right();\n                }\n\n                for (auto use : analyzer_.uses(ig_index)) {\n                // Extract128 is needed for the additional Simd128 store before\n                // Simd256 store in case of OOB trap at the higher 128-bit\n                // address.\n                auto use_pnode = analyzer_.GetPackNode(use);\n                if (use_pnode != nullptr && !use_pnode->is_force_packing()) {\n                    DCHECK_GE(use_pnode->nodes().size(), 2);\n                    if (__ input_graph().Get(use).opcode != Opcode::kStore ||\n                        use_pnode->nodes()[0] != use ||\n                        use_pnode->nodes()[0] > use_pnode->nodes()[1])\n                    continue;\n                }\n\n                return __ Simd256Extract128Lane(og_index, lane);\n                }\n\n                return OpIndex::Invalid();\n            }\n\n            V<Simd128> REDUCE_INPUT_GRAPH(Simd128Constant)(\n                V<Simd128> ig_index, const Simd128ConstantOp& constant_op) {\n                PackNode* pnode = analyzer_.GetPackNode(ig_index);\n                if (!pnode) {\n                return Adapter::ReduceInputGraphSimd128Constant(ig_index, constant_op);\n                }\n\n                V<Simd256> og_index = pnode->RevectorizedNode();\n                // Skip revectorized node.\n                if (!og_index.valid()) {\n                NodeGroup inputs = pnode->nodes();\n                const Simd128ConstantOp& op0 =\n                    __ input_graph().Get(inputs[0]).template Cast<Simd128ConstantOp>();\n                const Simd128ConstantOp& op1 =\n                    __ input_graph().Get(inputs[1]).template Cast<Simd128ConstantOp>();\n                uint8_t value[kSimd256Size] = {};\n                memcpy(value, op0.value, kSimd128Size);\n                memcpy(value + kSimd128Size, op1.value, kSimd128Size);\n\n                og_index = __ Simd256Constant(value);\n\n                pnode->SetRevectorizedNode(og_index);\n                }\n                return GetExtractOpIfNeeded(pnode, ig_index, og_index);\n            }\n\n            V<Simd128> REDUCE_INPUT_GRAPH(Sim"
}