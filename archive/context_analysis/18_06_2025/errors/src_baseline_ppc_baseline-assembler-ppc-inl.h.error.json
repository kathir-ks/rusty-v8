{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/ppc/baseline-assembler-ppc-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/ppc/baseline-assembler-ppc-inl.h\",\n            \"file_name\": \"baseline-assembler-ppc-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Inline implementations for the BaselineAssembler class on the PPC architecture, used for generating baseline code in V8.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for baseline assembly, code generation interfaces, PPC assembler, register definitions, and literal object handling.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/baseline/baseline-assembler.h\"\n            #include \"src/codegen/interface-descriptors.h\"\n            #include \"src/codegen/ppc/assembler-ppc-inl.h\"\n            #include \"src/codegen/ppc/register-ppc.h\"\n            #include \"src/objects/literal-objects-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BaselineAssembler::ScratchRegisterScope\",\n                \"about\": \"Manages the allocation and release of scratch registers within a given scope in the BaselineAssembler. Provides a mechanism to ensure registers are not accidentally clobbered.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"assembler_\",\n                        \"type\": \"BaselineAssembler*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the associated BaselineAssembler instance.\"\n                    },\n                    {\n                        \"name\": \"prev_scope_\",\n                        \"type\": \"ScratchRegisterScope*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the previous ScratchRegisterScope in the stack.\"\n                    },\n                    {\n                        \"name\": \"registers_used_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of the number of scratch registers currently in use.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BaselineAssembler\",\n                    \"detail::kNumScratchRegisters\",\n                    \"detail::kScratchRegisters\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class BaselineAssembler::ScratchRegisterScope {\n            public:\n            explicit ScratchRegisterScope(BaselineAssembler* assembler)\n                : assembler_(assembler),\n                prev_scope_(assembler->scratch_register_scope_),\n                registers_used_(prev_scope_ == nullptr ? 0\n                                                    : prev_scope_->registers_used_) {\n                assembler_->scratch_register_scope_ = this;\n            }\n            ~ScratchRegisterScope() { assembler_->scratch_register_scope_ = prev_scope_; }\n\n            Register AcquireScratch() {\n                DCHECK_LT(registers_used_, detail::kNumScratchRegisters);\n                return detail::kScratchRegisters[registers_used_++];\n            }\n\n            private:\n            BaselineAssembler* assembler_;\n            ScratchRegisterScope* prev_scope_;\n            int registers_used_;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfHelper\",\n                \"about\": \"Helper function to generate conditional jump instructions based on the comparison of two registers.\",\n                \"logic\": \"Compares two registers based on the specified condition code (cc) and generates a branch instruction to the target label if the condition is met.  Handles both 32-bit and 64-bit comparisons, as well as signed and unsigned comparisons.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"assm\",\n                        \"type\": \"MacroAssembler*\",\n                        \"purpose\": \"Pointer to the MacroAssembler object.\"\n                    },\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"Condition code for the jump.\"\n                    },\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"Left-hand side register for comparison.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"Right-hand side register for comparison.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"Target label to jump to if the condition is met.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CmpS64\",\n                    \"CmpU64\",\n                    \"CmpS32\",\n                    \"CmpU32\",\n                    \"b\",\n                    \"is_signed\",\n                    \"to_condition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <int width = 64>\n            static void JumpIfHelper(MacroAssembler* assm, Condition cc, Register lhs,\n                                    Register rhs, Label* target) {\n            static_assert(width == 64 || width == 32,\n                        \"only support 64 and 32 bit compare\");\n            if (width == 64) {\n                if (is_signed(cc)) {\n                __ CmpS64(lhs, rhs);\n                } else {\n                __ CmpU64(lhs, rhs);\n                }\n            } else {\n                if (is_signed(cc)) {\n                __ CmpS32(lhs, rhs);\n                } else {\n                __ CmpU32(lhs, rhs);\n                }\n            }\n            __ b(to_condition(cc), target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RegisterFrameOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the MemOperand for accessing a register within the interpreter's register file on the stack frame.\",\n                \"logic\": \"Calculates the memory offset of the specified interpreter register relative to the frame pointer (fp).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interpreter_register\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The interpreter register to access.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"The MemOperand representing the memory location of the register.\"\n                },\n                \"dependencies\": [\n                    \"kSystemPointerSize\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            MemOperand BaselineAssembler::RegisterFrameOperand(\n                interpreter::Register interpreter_register) {\n            return MemOperand(fp, interpreter_register.ToOperand() * kSystemPointerSize);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RegisterFrameAddress\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the address of a register within the interpreter's register file on the stack frame and stores it in a scratch register.\",\n                \"logic\": \"Calculates the memory address of the specified interpreter register relative to the frame pointer (fp) and stores the resulting address in the provided scratch register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interpreter_register\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The interpreter register to access.\"\n                    },\n                    {\n                        \"name\": \"rscratch\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The scratch register to store the address in.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AddS64\",\n                    \"kSystemPointerSize\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::RegisterFrameAddress(\n                interpreter::Register interpreter_register, Register rscratch) {\n            return __ AddS64(\n                rscratch, fp,\n                Operand(interpreter_register.ToOperand() * kSystemPointerSize));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FeedbackVectorOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the MemOperand for accessing the feedback vector on the stack frame.\",\n                \"logic\": \"Calculates the memory offset of the feedback vector relative to the frame pointer (fp) using BaselineFrameConstants::kFeedbackVectorFromFp.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"The MemOperand representing the memory location of the feedback vector.\"\n                },\n                \"dependencies\": [\n                    \"BaselineFrameConstants::kFeedbackVectorFromFp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            MemOperand BaselineAssembler::FeedbackVectorOperand() {\n            return MemOperand(fp, BaselineFrameConstants::kFeedbackVectorFromFp);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FeedbackCellOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the MemOperand for accessing the feedback cell on the stack frame.\",\n                \"logic\": \"Calculates the memory offset of the feedback cell relative to the frame pointer (fp) using BaselineFrameConstants::kFeedbackCellFromFp.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"The MemOperand representing the memory location of the feedback cell.\"\n                },\n                \"dependencies\": [\n                    \"BaselineFrameConstants::kFeedbackCellFromFp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            MemOperand BaselineAssembler::FeedbackCellOperand() {\n            return MemOperand(fp, BaselineFrameConstants::kFeedbackCellFromFp);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Bind\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Binds a label to the current code position.\",\n                \"logic\": \"Calls the underlying MacroAssembler's bind method to associate a label with the current instruction offset.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"label\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to bind.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"bind\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::Bind(Label* label) { __ bind(label); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpTarget\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Placeholder for architecture-specific jump target handling.\",\n                \"logic\": \"This function does nothing on PPC. It is present for compatibility with other architectures (e.g., ARM) where it might insert a NOP.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpTarget() {\n            // NOP on arm.\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Jump\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates an unconditional jump instruction.\",\n                \"logic\": \"Emits an unconditional branch instruction to the specified target label.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target (e.g., near or far).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"b\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::Jump(Label* target, Label::Distance distance) {\n            ASM_CODE_COMMENT(masm_);\n            __ b(target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfRoot\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump instruction if a register contains a specific root value.\",\n                \"logic\": \"Compares the given register with a root value and jumps to the target label if they are equal.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare with the root.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"RootIndex\",\n                        \"purpose\": \"The index of the root value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to if the register equals the root value.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"JumpIfRoot\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfRoot(Register value, RootIndex index,\n                                        Label* target, Label::Distance) {\n            ASM_CODE_COMMENT(masm_);\n            __ JumpIfRoot(value, index, target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfNotRoot\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump instruction if a register does not contain a specific root value.\",\n                \"logic\": \"Compares the given register with a root value and jumps to the target label if they are not equal.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare with the root.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"RootIndex\",\n                        \"purpose\": \"The index of the root value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to if the register does not equal the root value.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"JumpIfNotRoot\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfNotRoot(Register value, RootIndex index,\n                                        Label* target, Label::Distance) {\n            ASM_CODE_COMMENT(masm_);\n            __ JumpIfNotRoot(value, index, target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump instruction if a register contains a Smi (small integer).\",\n                \"logic\": \"Checks if the given register contains a Smi and jumps to the target label if it does.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to check for a Smi.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to if the register contains a Smi.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"JumpIfSmi\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfSmi(Register value, Label* target,\n                                    Label::Distance) {\n            ASM_CODE_COMMENT(masm_);\n            __ JumpIfSmi(value, target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfImmediate\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump instruction based on the comparison of a register and an immediate value.\",\n                \"logic\": \"Compares a register with an immediate value using the specified condition code and jumps to the target label if the condition is met.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"Condition code for the jump.\"\n                    },\n                    {\n                        \"name\": \"left\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"Left-hand side register for comparison.\"\n                    },\n                    {\n                        \"name\": \"right\",\n                        \"type\": \"int\",\n                        \"purpose\": \"Right-hand side immediate value for comparison.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"Target label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"JumpIf\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfImmediate(Condition cc, Register left, int right,\n                                        Label* target,\n                                        Label::Distance distance) {\n            ASM_CODE_COMMENT(masm_);\n            JumpIf(cc, left, Operand(right), target, distance);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfNotSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump instruction if a register does not contain a Smi.\",\n                \"logic\": \"Checks if the given register does not contain a Smi and jumps to the target label if it doesn't.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to check for a Smi.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to if the register does not contain a Smi.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"JumpIfNotSmi\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfNotSmi(Register value, Label* target,\n                                        Label::Distance) {\n            ASM_CODE_COMMENT(masm_);\n            __ JumpIfNotSmi(value, target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TestAndBranch\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a test-and-branch instruction based on a bitmask.\",\n                \"logic\": \"Performs a bitwise AND operation between the given register and a mask. Jumps to the target label based on the specified condition code (cc) after setting flags.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to test.\"\n                    },\n                    {\n                        \"name\": \"mask\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The bitmask to apply.\"\n                    },\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"Condition code for the jump.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"Target label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AndU64\",\n                    \"b\",\n                    \"to_condition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::TestAndBranch(Register value, int mask, Condition cc,\n                                        Label* target, Label::Distance) {\n            ASM_CODE_COMMENT(masm_);\n            __ AndU64(r0, value, Operand(mask), ip, SetRC);\n            __ b(to_condition(cc), target, cr0);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIf\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump instruction based on the comparison of a register and an operand.\",\n                \"logic\": \"Compares a register with an operand using the specified condition code and jumps to the target label if the condition is met. Handles both signed and unsigned comparisons.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"Condition code for the jump.\"\n                    },\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"Left-hand side register for comparison.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"const Operand&\",\n                        \"purpose\": \"Right-hand side operand for comparison.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"Target label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CmpS64\",\n                    \"CmpU64\",\n                    \"b\",\n                    \"is_signed\",\n                    \"to_condition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIf(Condition cc, Register lhs, const Operand& rhs,\n                                Label* target, Label::Distance) {\n            ASM_CODE_COMMENT(masm_);\n            if (is_signed(cc)) {\n                __ CmpS64(lhs, rhs, r0);\n            } else {\n                __ CmpU64(lhs, rhs, r0);\n            }\n            __ b(to_condition(cc), target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfJSAnyIsPrimitive\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump if a register contains a primitive JSAny value.\",\n                \"logic\": \"Checks if a JSAny value is a primitive (Smi or a HeapObject with an immediate instance type). Uses a scratch register during the check.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"heap_object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the JSAny value.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"Target label to jump to if the value is primitive.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AssertNotSmi\",\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"JumpIfJSAnyIsPrimitive\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_STATIC_ROOTS_BOOL\n            void BaselineAssembler::JumpIfJSAnyIsPrimitive(Register heap_object,\n                                                Label* target,\n                                                Label::Distance distance) {\n            __ AssertNotSmi(heap_object);\n            ScratchRegisterScope temps(this);\n            Register scratch = temps.AcquireScratch();\n            __ JumpIfJSAnyIsPrimitive(heap_object, scratch, target, distance);\n            }\n            #endif  // V8_STATIC_ROOTS_BOOL\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfObjectTypeFast\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump instruction based on the object type, using a fast inline check if the condition is equality or inequality.\",\n                \"logic\": \"Optimized object type check for equality/inequality.  Acquires two scratch registers. If the condition is equality or inequality, use IsObjectType to quickly determine the object type.  Otherwise calls JumpIfObjectType.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"Condition code for the jump.\"\n                    },\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the object to check.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The expected instance type.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"Target label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"IsObjectType\",\n                    \"b\",\n                    \"JumpIfObjectType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfObjectTypeFast(Condition cc, Register object,\n                                                InstanceType instance_type,\n                                                Label* target,\n                                                Label::Distance distance) {\n            ScratchRegisterScope temps(this);\n            Register scratch = temps.AcquireScratch();\n            if (cc == eq || cc == ne) {\n                Register scratch2 = temps.AcquireScratch();\n                __ IsObjectType(object, scratch, scratch2, instance_type);\n                __ b(to_condition(cc), target);\n                return;\n            }\n            JumpIfObjectType(cc, object, instance_type, scratch, target, distance);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfObjectType\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump instruction based on the object type.\",\n                \"logic\": \"Loads the map of the object, then loads the instance type from the map, and then compares it to the expected instance type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"Condition code for the jump.\"\n                    },\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the object to check.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The expected instance type.\"\n                    },\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"Register to load the map into.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"Target label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"LoadMap\",\n                    \"LoadU16\",\n                    \"FieldMemOperand\",\n                    \"Map::kInstanceTypeOffset\",\n                    \"JumpIf\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfObjectType(Condition cc, Register object,\n                                        InstanceType instance_type,\n                                        Register map, Label* target,\n                                        Label::Distance) {\n            ASM_CODE_COMMENT(masm_);\n            ScratchRegisterScope temps(this);\n            Register type = temps.AcquireScratch();\n            __ LoadMap(map, object);\n            __ LoadU16(type, FieldMemOperand(map, Map::kInstanceTypeOffset), r0);\n            JumpIf(cc, type, Operand(instance_type), target);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfInstanceType\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Generates a conditional jump instruction based on the instance type of a map.\",\n                \"logic\": \"Loads the instance type from the given map and compares it with the expected instance type. Includes debug-only assertions to verify that the input is actually a map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"Condition code for the jump.\"\n                    },\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the map to check.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The expected instance type.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"Target label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\",\n                    \"AcquireScratch\",\n                    \"AssertNotSmi\",\n                    \"CompareObjectType\",\n                    \"AbortReason::kUnexpectedValue\",\n                    \"LoadU16\",\n                    \"FieldMemOperand\",\n                    \"Map::kInstanceTypeOffset\",\n                    \"JumpIf\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfInstanceType(Condition cc, Register map,\n                                            InstanceType instance_type,\n                                            Label* target, Label::Distance) {\n            ASM_CODE_COMMENT(masm_);\n            ScratchRegisterScope temps(this);\n            Register type = temps.AcquireScratch();\n            if (v8_flags.debug_code) {\n                __ AssertNotSmi(map);\n                __ CompareObjectType(map, type, type, MAP_TYPE);\n                __ Assert(eq, AbortReason::k"
}