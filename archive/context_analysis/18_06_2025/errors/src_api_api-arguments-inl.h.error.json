{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/api/api-arguments-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/api/api-arguments-inl.h\",\n            \"file_name\": \"api-arguments-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines inline implementations for API argument handling in V8.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for API argument handling, core V8 functionalities, debugging, execution state management, runtime call statistics, object handling, and slot management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/api/api-arguments.h\"\n#include \"src/api/api-inl.h\"\n#include \"src/debug/debug.h\"\n#include \"src/execution/vm-state-inl.h\"\n#include \"src/logging/runtime-call-stats-scope.h\"\n#include \"src/objects/api-callbacks.h\"\n#include \"src/objects/instance-type.h\"\n#include \"src/objects/slots-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CustomArgumentsBase\",\n                \"about\": \"Base class for custom arguments, providing a common constructor.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Relocatable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nCustomArgumentsBase::CustomArgumentsBase(Isolate* isolate)\n    : Relocatable(isolate) {}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CustomArguments\",\n                \"about\": \"Template class for handling custom arguments, providing destructor and return value access.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"T\",\n                    \"Object\",\n                    \"Handle\",\n                    \"JSAny\",\n                    \"Isolate\",\n                    \"FullObjectSlot\",\n                    \"Cast\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nCustomArguments<T>::~CustomArguments() {\n  slot_at(kReturnValueIndex).store(Tagged<Object>(kHandleZapValue));\n}\n\ntemplate <typename T>\ntemplate <typename V>\nHandle<V> CustomArguments<T>::GetReturnValue(Isolate* isolate) const {\n  // Check the ReturnValue.\n  FullObjectSlot slot = slot_at(kReturnValueIndex);\n  DCHECK(Is<JSAny>(*slot));\n  return Cast<V>(Handle<Object>(slot.location()));\n}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PropertyCallbackArguments\",\n                \"about\": \"Provides methods for accessing the holder and receiver objects in property callback arguments.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"JSObject\",\n                    \"Object\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ninline Tagged<JSObject> PropertyCallbackArguments::holder() const {\n  return Cast<JSObject>(*slot_at(T::kHolderIndex));\n}\n\ninline Tagged<Object> PropertyCallbackArguments::receiver() const {\n  return *slot_at(T::kThisIndex);\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DCHECK_NAME_COMPATIBLE\",\n                \"about\": \"Assertion macro to check compatibility of interceptor and name.\",\n                \"logic\": \"Verifies that the interceptor is named, the name is not private, and if the name is a symbol, the interceptor can intercept symbols.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interceptor\",\n                        \"type\": \"InterceptorInfo\",\n                        \"purpose\": \"The interceptor to check.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"Name\",\n                        \"purpose\": \"The name to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; this is a macro.\"\n                },\n                \"dependencies\": [\n                    \"InterceptorInfo\",\n                    \"Name\",\n                    \"IsSymbol\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define DCHECK_NAME_COMPATIBLE(interceptor, name) \\\n  DCHECK(interceptor->is_named());                \\\n  DCHECK(!name->IsPrivate());                     \\\n  DCHECK_IMPLIES(IsSymbol(*name), interceptor->can_intercept_symbols());\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PREPARE_CALLBACK_INFO_ACCESSOR\",\n                \"about\": \"Macro to prepare callback information for accessor calls, including side effect checks and callback scope setup.\",\n                \"logic\": \"Checks for side effects, gets the callback info, and sets up an external callback scope.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ISOLATE\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The current isolate.\"\n                    },\n                    {\n                        \"name\": \"F\",\n                        \"type\": \"function pointer\",\n                        \"purpose\": \"The callback function.\"\n                    },\n                    {\n                        \"name\": \"API_RETURN_TYPE\",\n                        \"type\": \"type\",\n                        \"purpose\": \"The return type of the API function.\"\n                    },\n                    {\n                        \"name\": \"ACCESSOR_INFO\",\n                        \"type\": \"AccessorInfo\",\n                        \"purpose\": \"Accessor information.\"\n                    },\n                    {\n                        \"name\": \"RECEIVER\",\n                        \"type\": \"Object\",\n                        \"purpose\": \"The receiver object.\"\n                    },\n                    {\n                        \"name\": \"ACCESSOR_KIND\",\n                        \"type\": \"enum\",\n                        \"purpose\": \"Accessor kind (getter/setter).\"\n                    },\n                    {\n                        \"name\": \"EXCEPTION_CONTEXT\",\n                        \"type\": \"enum\",\n                        \"purpose\": \"The exception context.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; this is a macro.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"PropertyCallbackInfo\",\n                    \"ExternalCallbackScope\",\n                    \"PerformSideEffectCheckForAccessor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define PREPARE_CALLBACK_INFO_ACCESSOR(ISOLATE, F, API_RETURN_TYPE,            \\\n                                       ACCESSOR_INFO, RECEIVER, ACCESSOR_KIND, \\\n                                       EXCEPTION_CONTEXT)                      \\\n  if (ISOLATE->should_check_side_effects() &&                                  \\\n      !ISOLATE->debug()->PerformSideEffectCheckForAccessor(                    \\\n          ACCESSOR_INFO, RECEIVER, ACCESSOR_KIND)) {                           \\\n    return {};                                                                 \\\n  }                                                                            \\\n  const PropertyCallbackInfo<API_RETURN_TYPE>& callback_info =                 \\\n      GetPropertyCallbackInfo<API_RETURN_TYPE>();                              \\\n  ExternalCallbackScope call_scope(ISOLATE, FUNCTION_ADDR(F),                  \\\n                                   EXCEPTION_CONTEXT, &callback_info);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PREPARE_CALLBACK_INFO_INTERCEPTOR\",\n                \"about\": \"Macro to prepare callback information for interceptor calls, including side effect checks and callback scope setup.\",\n                \"logic\": \"Checks for side effects, gets the callback info, and sets up an external callback scope.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ISOLATE\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The current isolate.\"\n                    },\n                    {\n                        \"name\": \"F\",\n                        \"type\": \"function pointer\",\n                        \"purpose\": \"The callback function.\"\n                    },\n                    {\n                        \"name\": \"API_RETURN_TYPE\",\n                        \"type\": \"type\",\n                        \"purpose\": \"The return type of the API function.\"\n                    },\n                    {\n                        \"name\": \"INTERCEPTOR_INFO\",\n                        \"type\": \"InterceptorInfo\",\n                        \"purpose\": \"Interceptor information.\"\n                    },\n                    {\n                        \"name\": \"EXCEPTION_CONTEXT\",\n                        \"type\": \"enum\",\n                        \"purpose\": \"The exception context.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; this is a macro.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"PropertyCallbackInfo\",\n                    \"ExternalCallbackScope\",\n                    \"PerformSideEffectCheckForInterceptor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define PREPARE_CALLBACK_INFO_INTERCEPTOR(ISOLATE, F, API_RETURN_TYPE,         \\\n                                          INTERCEPTOR_INFO, EXCEPTION_CONTEXT) \\\n  if (ISOLATE->should_check_side_effects() &&                                  \\\n      !ISOLATE->debug()->PerformSideEffectCheckForInterceptor(                 \\\n          INTERCEPTOR_INFO)) {                                                 \\\n    return {};                                                                 \\\n  }                                                                            \\\n  const PropertyCallbackInfo<API_RETURN_TYPE>& callback_info =                 \\\n      GetPropertyCallbackInfo<API_RETURN_TYPE>();                              \\\n  ExternalCallbackScope call_scope(ISOLATE, FUNCTION_ADDR(F),                  \\\n                                   EXCEPTION_CONTEXT, &callback_info);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallOrConstruct\",\n                \"parent\": \"FunctionCallbackArguments\",\n                \"about\": \"Calls a function or constructs an object based on the provided FunctionTemplateInfo.\",\n                \"logic\": \"Retrieves the function callback from the FunctionTemplateInfo, checks for side effects, creates a FunctionCallbackInfo, sets up an external callback scope, calls the function, and returns the return value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"function\",\n                        \"type\": \"Tagged<FunctionTemplateInfo>\",\n                        \"purpose\": \"The function template information.\"\n                    },\n                    {\n                        \"name\": \"is_construct\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether to call as a constructor.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"DirectHandle<Object>\",\n                    \"description\": \"The return value of the function call or constructor.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"RuntimeCallCounterId\",\n                    \"v8::FunctionCallback\",\n                    \"PerformSideEffectCheckForCallback\",\n                    \"FunctionCallbackInfo\",\n                    \"ExternalCallbackScope\",\n                    \"ExceptionContext\",\n                    \"GetReturnValue\",\n                    \"RCS_SCOPE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<Object> FunctionCallbackArguments::CallOrConstruct(\n    Tagged<FunctionTemplateInfo> function, bool is_construct) {\n  Isolate* isolate = this->isolate();\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kFunctionCallback);\n  v8::FunctionCallback f =\n      reinterpret_cast<v8::FunctionCallback>(function->callback(isolate));\n  if (isolate->should_check_side_effects() &&\n      !isolate->debug()->PerformSideEffectCheckForCallback(\n          handle(function, isolate))) {\n    return {};\n  }\n  FunctionCallbackInfo<v8::Value> info(values_, argv_, argc_);\n  ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f),\n                                   is_construct ? ExceptionContext::kConstructor\n                                                : ExceptionContext::kOperation,\n                                   &info);\n  f(info);\n  return GetReturnValue<Object>(isolate);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"~PropertyCallbackArguments\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Destructor for PropertyCallbackArguments.\",\n                \"logic\": \"Currently only includes a DEBUG section that is commented out.  It would check that the javascript execution counter is consistent.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nPropertyCallbackArguments::~PropertyCallbackArguments(){\n#ifdef DEBUG\n// TODO(chromium:1310062): enable this check.\n// if (javascript_execution_counter_) {\n//   CHECK_WITH_MSG(javascript_execution_counter_ ==\n//                      isolate()->javascript_execution_counter(),\n//                  \"Unexpected side effect detected\");\n// }\n#endif  // DEBUG\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetBooleanReturnValue\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Gets the boolean return value from an interceptor callback.\",\n                \"logic\": \"Checks for exceptions, handles intercepted results, and returns a boolean value.  It also performs checks to see if exceptions are thrown when they are supposed to.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"intercepted\",\n                        \"type\": \"v8::Intercepted\",\n                        \"purpose\": \"Indicates whether the callback was intercepted.\"\n                    },\n                    {\n                        \"name\": \"callback_kind_for_error_message\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The callback kind for error messages.\"\n                    },\n                    {\n                        \"name\": \"ignore_return_value\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether to ignore the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Maybe<InterceptorResult>\",\n                    \"description\": \"The boolean return value or Nothing if an exception occurred.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"InterceptorResult\",\n                    \"Nothing\",\n                    \"Just\",\n                    \"DCHECK_EQ\",\n                    \"GetReturnValue\",\n                    \"Boolean\",\n                    \"IsTrue\",\n                    \"ShouldThrowOnError\",\n                    \"Boolean\",\n                    \"FATAL\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nMaybe<InterceptorResult> PropertyCallbackArguments::GetBooleanReturnValue(\n    v8::Intercepted intercepted, const char* callback_kind_for_error_message,\n    bool ignore_return_value) {\n  Isolate* isolate = this->isolate();\n  if (isolate->has_exception()) {\n    // TODO(ishell, 328490288): fix Node.js which has Setter/Definer\n    // interceptor callbacks not returning v8::Intercepted::kYes on exceptions.\n    if ((false) && DEBUG_BOOL && (intercepted == v8::Intercepted::kNo)) {\n      FATAL(\n          \"Check failed: %s interceptor callback has thrown an \"\n          \"exception but hasn't returned v8::Intercepted::kYes.\",\n          callback_kind_for_error_message);\n    }\n    return Nothing<InterceptorResult>();\n  }\n\n  if (intercepted == v8::Intercepted::kNo) {\n    // Not intercepted, there must be no side effects including exceptions.\n    DCHECK(!isolate->has_exception());\n    return Just(InterceptorResult::kNotIntercepted);\n  }\n  DCHECK_EQ(intercepted, v8::Intercepted::kYes);\n  AcceptSideEffects();\n\n  if (ignore_return_value) return Just(InterceptorResult::kTrue);\n\n  bool result = IsTrue(*GetReturnValue<Boolean>(isolate), isolate);\n\n  // TODO(ishell, 348688196): ensure callbacks comply with this and\n  // enable the check.\n  if ((false) && DEBUG_BOOL && !result && ShouldThrowOnError()) {\n    FATAL(\n        \"Check failed: %s interceptor callback hasn't thrown an \"\n        \"exception on failure as requested.\",\n        callback_kind_for_error_message);\n  }\n  return Just(result ? InterceptorResult::kTrue : InterceptorResult::kFalse);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallNamedEnumerator\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Calls a named enumerator interceptor.\",\n                \"logic\": \"Checks that the interceptor is named, sets up the runtime call counter, calls the property enumerator and returns the result.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interceptor\",\n                        \"type\": \"DirectHandle<InterceptorInfo>\",\n                        \"purpose\": \"The interceptor information.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"DirectHandle<JSObjectOrUndefined>\",\n                    \"description\": \"The result of the enumeration.\"\n                },\n                \"dependencies\": [\n                    \"DirectHandle\",\n                    \"InterceptorInfo\",\n                    \"DCHECK\",\n                    \"RuntimeCallCounterId\",\n                    \"CallPropertyEnumerator\",\n                    \"RCS_SCOPE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<JSObjectOrUndefined>\nPropertyCallbackArguments::CallNamedEnumerator(\n    DirectHandle<InterceptorInfo> interceptor) {\n  DCHECK(interceptor->is_named());\n  RCS_SCOPE(isolate(), RuntimeCallCounterId::kNamedEnumeratorCallback);\n  return CallPropertyEnumerator(interceptor);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallNamedQuery\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Calls a named query interceptor.\",\n                \"logic\": \"Checks name compatibility, sets up runtime call counter, stores the name in a slot, prepares callback info, calls the property query, and returns the result.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interceptor\",\n                        \"type\": \"DirectHandle<InterceptorInfo>\",\n                        \"purpose\": \"The interceptor information.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"DirectHandle<Name>\",\n                        \"purpose\": \"The name being queried.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"DirectHandle<Object>\",\n                    \"description\": \"The result of the query.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"InterceptorInfo\",\n                    \"Name\",\n                    \"DCHECK_NAME_COMPATIBLE\",\n                    \"RuntimeCallCounterId\",\n                    \"NamedPropertyQueryCallback\",\n                    \"ToCData\",\n                    \"PREPARE_CALLBACK_INFO_INTERCEPTOR\",\n                    \"v8::Utils::ToLocal\",\n                    \"GetReturnValue\",\n                    \"RCS_SCOPE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// TODO(ishell): return std::optional<PropertyAttributes>.\nDirectHandle<Object> PropertyCallbackArguments::CallNamedQuery(\n    DirectHandle<InterceptorInfo> interceptor, DirectHandle<Name> name) {\n  DCHECK_NAME_COMPATIBLE(interceptor, name);\n  Isolate* isolate = this->isolate();\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kNamedQueryCallback);\n  slot_at(kPropertyKeyIndex).store(*name);\n  slot_at(kReturnValueIndex).store(Smi::FromInt(v8::None));\n  NamedPropertyQueryCallback f =\n      ToCData<NamedPropertyQueryCallback, kApiNamedPropertyQueryCallbackTag>(\n          isolate, interceptor->query());\n  PREPARE_CALLBACK_INFO_INTERCEPTOR(isolate, f, v8::Integer, interceptor,\n                                    ExceptionContext::kNamedQuery);\n  v8::Intercepted intercepted = f(v8::Utils::ToLocal(name), callback_info);\n  if (intercepted == v8::Intercepted::kNo) return {};\n  return GetReturnValue<Object>(isolate);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallNamedGetter\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Calls a named getter interceptor.\",\n                \"logic\": \"Checks name compatibility, sets up runtime call counter, stores the name in a slot, prepares callback info, calls the property getter, and returns the result.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interceptor\",\n                        \"type\": \"DirectHandle<InterceptorInfo>\",\n                        \"purpose\": \"The interceptor information.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"DirectHandle<Name>\",\n                        \"purpose\": \"The name being accessed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"DirectHandle<JSAny>\",\n                    \"description\": \"The result of the getter call.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"InterceptorInfo\",\n                    \"Name\",\n                    \"DCHECK_NAME_COMPATIBLE\",\n                    \"RuntimeCallCounterId\",\n                    \"NamedPropertyGetterCallback\",\n                    \"ToCData\",\n                    \"PREPARE_CALLBACK_INFO_INTERCEPTOR\",\n                    \"v8::Utils::ToLocal\",\n                    \"GetReturnValue\",\n                    \"RCS_SCOPE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<JSAny> PropertyCallbackArguments::CallNamedGetter(\n    DirectHandle<InterceptorInfo> interceptor, DirectHandle<Name> name) {\n  DCHECK_NAME_COMPATIBLE(interceptor, name);\n  Isolate* isolate = this->isolate();\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kNamedGetterCallback);\n  slot_at(kPropertyKeyIndex).store(*name);\n  slot_at(kReturnValueIndex).store(ReadOnlyRoots(isolate).undefined_value());\n  NamedPropertyGetterCallback f =\n      ToCData<NamedPropertyGetterCallback, kApiNamedPropertyGetterCallbackTag>(\n          isolate, interceptor->getter());\n  PREPARE_CALLBACK_INFO_INTERCEPTOR(isolate, f, v8::Value, interceptor,\n                                    ExceptionContext::kNamedGetter);\n  v8::Intercepted intercepted = f(v8::Utils::ToLocal(name), callback_info);\n  if (intercepted == v8::Intercepted::kNo) return {};\n  return GetReturnValue<JSAny>(isolate);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallNamedDescriptor\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Calls a named descriptor interceptor.\",\n                \"logic\": \"Checks name compatibility, sets up runtime call counter, stores the name in a slot, prepares callback info, calls the property descriptor callback, and returns the result.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interceptor\",\n                        \"type\": \"DirectHandle<InterceptorInfo>\",\n                        \"purpose\": \"The interceptor information.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"DirectHandle<Name>\",\n                        \"purpose\": \"The name being accessed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Handle<JSAny>\",\n                    \"description\": \"The result of the descriptor call.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"InterceptorInfo\",\n                    \"Name\",\n                    \"DCHECK_NAME_COMPATIBLE\",\n                    \"RuntimeCallCounterId\",\n                    \"NamedPropertyDescriptorCallback\",\n                    \"ToCData\",\n                    \"PREPARE_CALLBACK_INFO_INTERCEPTOR\",\n                    \"v8::Utils::ToLocal\",\n                    \"GetReturnValue\",\n                    \"RCS_SCOPE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nHandle<JSAny> PropertyCallbackArguments::CallNamedDescriptor(\n    DirectHandle<InterceptorInfo> interceptor, DirectHandle<Name> name) {\n  DCHECK_NAME_COMPATIBLE(interceptor, name);\n  Isolate* isolate = this->isolate();\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kNamedDescriptorCallback);\n  slot_at(kPropertyKeyIndex).store(*name);\n  slot_at(kReturnValueIndex).store(ReadOnlyRoots(isolate).undefined_value());\n  NamedPropertyDescriptorCallback f =\n      ToCData<NamedPropertyDescriptorCallback,\n              kApiNamedPropertyDescriptorCallbackTag>(\n          isolate, interceptor->descriptor());\n  PREPARE_CALLBACK_INFO_INTERCEPTOR(isolate, f, v8::Value, interceptor,\n                                    ExceptionContext::kNamedDescriptor);\n  v8::Intercepted intercepted = f(v8::Utils::ToLocal(name), callback_info);\n  if (intercepted == v8::Intercepted::kNo) return {};\n  return GetReturnValue<JSAny>(isolate);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallNamedSetter\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Calls a named setter interceptor.\",\n                \"logic\": \"Checks name compatibility, sets up runtime call counter, stores the name and value in slots, prepares callback info, calls the property setter, and returns the intercepted value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interceptor\",\n                        \"type\": \"DirectHandle<InterceptorInfo>\",\n                        \"purpose\": \"The interceptor information.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"DirectHandle<Name>\",\n                        \"purpose\": \"The name being set.\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"DirectHandle<Object>\",\n                        \"purpose\": \"The value being set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"v8::Intercepted\",\n                    \"description\": \"Whether or not the call was intercepted\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"InterceptorInfo\",\n                    \"Name\",\n                    \"Object\",\n                    \"DCHECK_NAME_COMPATIBLE\",\n                    \"RuntimeCallCounterId\",\n                    \"NamedPropertySetterCallback\",\n                    \"ToCData\",\n                    \"PREPARE_CALLBACK_INFO_INTERCEPTOR\",\n                    \"v8::Utils::ToLocal\",\n                    \"RCS_SCOPE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nv8::Intercepted PropertyCallbackArguments::CallNamedSetter(\n    DirectHandle<InterceptorInfo> interceptor, DirectHandle<Name> name,\n    DirectHandle<Object> value) {\n  DCHECK_NAME_COMPATIBLE(interceptor, name);\n  Isolate* isolate = this->isolate();\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kNamedSetterCallback);\n  slot_at(kPropertyKeyIndex).store(*name);\n  slot_at(kReturnValueIndex).store(ReadOnlyRoots(isolate).true_value());\n  NamedPropertySetterCallback f =\n      ToCData<NamedPropertySetterCallback, kApiNamedPropertySetterCallbackTag>(\n          isolate, interceptor->setter());\n  DirectHandle<InterceptorInfo> has_side_effects;\n  PREPARE_CALLBACK_INFO_INTERCEPTOR(isolate, f, void, has_side_effects,\n                                    ExceptionContext::kNamedSetter);\n  v8::Intercepted intercepted =\n      f(v8::Utils::ToLocal(name), v8::Utils::ToLocal(value), callback_info);\n  return intercepted;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallNamedDefiner\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Calls a named definer interceptor.\",\n                \"logic\": \"Checks name compatibility, sets up runtime call counter, stores the name in a slot, prepares callback info, calls the property definer callback, and returns the intercepted value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interceptor\",\n                        \"type\": \"DirectHandle<InterceptorInfo>\",\n                        \"purpose\": \"The interceptor information.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"DirectHandle<Name>\",\n                        \"purpose\": \"The name being defined.\"\n                    },\n                    {\n                        \"name\": \"desc\",\n                        \"type\": \"const v8::PropertyDescriptor&\",\n                        \"purpose\": \"The property descriptor.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"v8::Intercepted\",\n                    \"description\": \"Whether or not the call was intercepted\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"InterceptorInfo\",\n                    \"Name\",\n                    \"DCHECK_NAME_COMPATIBLE\",\n                    \"RuntimeCallCounterId\",\n                    \"NamedPropertyDefinerCallback\",\n                    \"ToCData\",\n                    \"PREPARE_CALLBACK_INFO_INTERCEPTOR\",\n                    \"v8::Utils::ToLocal\",\n                    \"RCS_SCOPE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nv8::Intercepted PropertyCallbackArguments::CallNamedDefiner(\n    DirectHandle<InterceptorInfo> interceptor, DirectHandle<Name> name,\n    const v8::PropertyDescriptor& desc) {\n  DCHECK_NAME_COMPATIBLE(interceptor, name);\n  Isolate* isolate = this->isolate();\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kNamedDefinerCallback);\n  slot_at(kPropertyKeyIndex).store(*name);\n  slot_at(kReturnValueIndex).store(ReadOnlyRoots(isolate).true_value());\n  NamedPropertyDefinerCallback f = ToCData<NamedPropertyDefinerCallback,\n                                           kApiNamedPropertyDefinerCallbackTag>(\n      isolate, interceptor->definer());\n  DirectHandle<InterceptorInfo> has_side_effects;\n  PREPARE_CALLBACK_INFO_INTERCEPTOR(isolate, f, void, has_side_effects,\n                                    ExceptionContext::kNamedDefiner);\n  v8::Intercepted intercepted =\n      f(v8::Utils::ToLocal(name), desc, callback_info);\n  return intercepted;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallNamedDeleter\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Calls a named deleter interceptor.\",\n                \"logic\": \"Checks name compatibility, sets up runtime call counter, stores the name in a slot, prepares callback info, calls the property deleter callback, and returns the intercepted value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interceptor\",\n                        \"type\": \"DirectHandle<InterceptorInfo>\",\n                        \"purpose\": \"The interceptor information.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"DirectHandle<Name>\",\n                        \"purpose\": \"The name being deleted.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"v8::Intercepted\",\n                    \"description\": \"Whether or not the call was intercepted\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"DirectHandle\",\n                    \"InterceptorInfo\",\n                    \"Name\",\n                    \"DCHECK_NAME_COMPATIBLE\",\n                    \"RuntimeCallCounterId\",\n                    \"NamedPropertyDeleterCallback\",\n                    \"ToCData\",\n                    \"PREPARE_CALLBACK_INFO_INTERCEPTOR\",\n                    \"v8::Utils::ToLocal\",\n                    \"RCS_SCOPE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nv8::Intercepted PropertyCallbackArguments::CallNamedDeleter(\n    DirectHandle<InterceptorInfo> interceptor, DirectHandle<Name> name) {\n  DCHECK_NAME_COMPATIBLE(interceptor, name);\n  Isolate* isolate = this->isolate();\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kNamedDeleterCallback);\n  slot_at(kPropertyKeyIndex).store(*name);\n  slot_at(kReturnValueIndex).store(ReadOnlyRoots(isolate).true_value());\n  NamedPropertyDeleterCallback f = ToCData<NamedPropertyDeleterCallback,\n                                           kApiNamedPropertyDeleterCallbackTag>(\n      isolate, interceptor->deleter());\n  DirectHandle<InterceptorInfo> has_side_effects;\n  PREPARE_CALLBACK_INFO_INTERCEPTOR(isolate, f, v8::Boolean, has_side_effects,\n                                    ExceptionContext::kNamedDeleter);\n  v8::Intercepted intercepted = f(v8::Utils::ToLocal(name), callback_info);\n  return intercepted;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallIndexedEnumerator\",\n                \"parent\": \"PropertyCallbackArguments\",\n                \"about\": \"Calls an indexed enumerator interceptor.\",\n                \"logic\": \"Checks that the interceptor is not named, sets up the runtime call counter, calls the property enumerator and returns the result.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interceptor\",\n                        \"type\": \"DirectHandle<InterceptorInfo>\",\n                        \"purpose\": \"The interceptor information.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"DirectHandle<JSObjectOrUndefined>\",\n                    \"description\": \"The result of the enumeration.\"\n"
}