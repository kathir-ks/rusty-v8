{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/load-store-simplification-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 269, column 41",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/load-store-simplification-reducer.h\",\n            \"file_name\": \"load-store-simplification-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines a Turboshaft reducer that simplifies load and store operations for different target architectures.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for assembler, operation matching, operations, and the phase system.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/operation-matcher.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"LoadStoreSimplificationConfiguration\",\n                \"about\": \"Defines architecture-specific configuration parameters for load/store simplification.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kNeedsUntaggedBase\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates if the architecture requires untagged base pointers for loads.\"\n                    },\n                    {\n                        \"name\": \"kMinOffset\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Minimum allowed offset for memory access.\"\n                    },\n                    {\n                        \"name\": \"kMaxOffset\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Maximum allowed offset for memory access.\"\n                    },\n                    {\n                        \"name\": \"kMaxElementSizeLog2\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Maximum allowed log2 of the element size for indexed memory access.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstruct LoadStoreSimplificationConfiguration {\n  // TODO(12783): This needs to be extended for all architectures that don't\n  // have loads with the base + index * element_size + offset pattern.\n#if V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_ARM || V8_TARGET_ARCH_RISCV64 ||    \\\n    V8_TARGET_ARCH_LOONG64 || V8_TARGET_ARCH_MIPS64 || V8_TARGET_ARCH_PPC64 || \\\n    V8_TARGET_ARCH_RISCV32\n  // As tagged loads result in modfiying the offset by -1, those loads are\n  // converted into raw loads.\n  static constexpr bool kNeedsUntaggedBase = true;\n  // By setting {kMinOffset} > {kMaxOffset}, we ensure that all offsets\n  // (including 0) are merged into the computed index.\n  static constexpr int32_t kMinOffset = 1;\n  static constexpr int32_t kMaxOffset = 0;\n  // Turboshaft's loads and stores follow the pattern of\n  // *(base + index * element_size_log2 + displacement), but architectures\n  // typically support only a limited `element_size_log2`.\n  static constexpr int kMaxElementSizeLog2 = 0;\n#elif V8_TARGET_ARCH_S390X\n  static constexpr bool kNeedsUntaggedBase = false;\n  // s390x supports *(base + index + displacement), element_size isn't\n  // supported.\n  static constexpr int32_t kDisplacementBits = 20;  // 20 bit signed integer.\n  static constexpr int32_t kMinOffset =\n      -(static_cast<int32_t>(1) << (kDisplacementBits - 1));\n  static constexpr int32_t kMaxOffset =\n      (static_cast<int32_t>(1) << (kDisplacementBits - 1)) - 1;\n  static constexpr int kMaxElementSizeLog2 = 0;\n#else\n  static constexpr bool kNeedsUntaggedBase = false;\n  // We don't want to encode INT32_MIN in the offset becauce instruction\n  // selection might not be able to put this into an immediate operand.\n  static constexpr int32_t kMinOffset = std::numeric_limits<int32_t>::min() + 1;\n  static constexpr int32_t kMaxOffset = std::numeric_limits<int32_t>::max();\n  // Turboshaft's loads and stores follow the pattern of\n  // *(base + index * element_size_log2 + displacement), but architectures\n  // typically support only a limited `element_size_log2`.\n  static constexpr int kMaxElementSizeLog2 = 3;\n#endif\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoadStoreSimplificationReducer\",\n                \"about\": \"A Turboshaft reducer that simplifies load and store operations based on the target architecture's capabilities.\",\n                \"attributes\": [],\n                \"extends\": \"Next\",\n                \"implements\": [\n                    \"LoadStoreSimplificationConfiguration\"\n                ],\n                \"dependencies\": [\n                    \"Next\",\n                    \"LoadStoreSimplificationConfiguration\",\n                    \"OperationMatcher\",\n                    \"LoadOp\",\n                    \"StoreOp\",\n                    \"AtomicWord32PairOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass LoadStoreSimplificationReducer : public Next,\n                                       LoadStoreSimplificationConfiguration {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(LoadStoreSimplification)\n\n  OpIndex REDUCE(Load)(OpIndex base, OptionalOpIndex index, LoadOp::Kind kind,\n                       MemoryRepresentation loaded_rep,\n                       RegisterRepresentation result_rep, int32_t offset,\n                       uint8_t element_size_log2) {\n    SimplifyLoadStore(base, index, kind, offset, element_size_log2);\n    return Next::ReduceLoad(base, index, kind, loaded_rep, result_rep, offset,\n                            element_size_log2);\n  }\n\n  OpIndex REDUCE(Store)(OpIndex base, OptionalOpIndex index, OpIndex value,\n                        StoreOp::Kind kind, MemoryRepresentation stored_rep,\n                        WriteBarrierKind write_barrier, int32_t offset,\n                        uint8_t element_size_log2,\n                        bool maybe_initializing_or_transitioning,\n                        IndirectPointerTag maybe_indirect_pointer_tag) {\n    SimplifyLoadStore(base, index, kind, offset, element_size_log2);\n    if (write_barrier != WriteBarrierKind::kNoWriteBarrier &&\n        !index.has_value() && __ Get(base).template Is<ConstantOp>()) {\n      const ConstantOp& const_base = __ Get(base).template Cast<ConstantOp>();\n      if (const_base.IsIntegral() ||\n          const_base.kind == ConstantOp::Kind::kSmi) {\n        // It never makes sense to have a WriteBarrier for a store to a raw\n        // address. We should thus be in unreachable code.\n        // The instruction selector / register allocator don't handle this very\n        // well, so it's easier to emit an Unreachable rather than emitting a\n        // weird store that will never be executed.\n        __ Unreachable();\n        return OpIndex::Invalid();\n      }\n    }\n    return Next::ReduceStore(base, index, value, kind, stored_rep,\n                             write_barrier, offset, element_size_log2,\n                             maybe_initializing_or_transitioning,\n                             maybe_indirect_pointer_tag);\n  }\n\n  OpIndex REDUCE(AtomicWord32Pair)(V<WordPtr> base, OptionalV<WordPtr> index,\n                                   OptionalV<Word32> value_low,\n                                   OptionalV<Word32> value_high,\n                                   OptionalV<Word32> expected_low,\n                                   OptionalV<Word32> expected_high,\n                                   AtomicWord32PairOp::Kind kind,\n                                   int32_t offset) {\n    if (kind == AtomicWord32PairOp::Kind::kStore ||\n        kind == AtomicWord32PairOp::Kind::kLoad) {\n      if (!index.valid()) {\n        index = __ IntPtrConstant(offset);\n        offset = 0;\n      } else if (offset != 0) {\n        index = __ WordPtrAdd(index.value(), offset);\n        offset = 0;\n      }\n    }\n    return Next::ReduceAtomicWord32Pair(base, index, value_low, value_high,\n                                        expected_low, expected_high, kind,\n                                        offset);\n  }\n\n private:\n  bool CanEncodeOffset(int32_t offset, bool tagged_base) const {\n    // If the base is tagged we also need to subtract the kHeapObjectTag\n    // eventually.\n    const int32_t min = kMinOffset + (tagged_base ? kHeapObjectTag : 0);\n    if (min <= offset && offset <= kMaxOffset) {\n      DCHECK(LoadOp::OffsetIsValid(offset, tagged_base));\n      return true;\n    }\n    return false;\n  }\n\n  bool CanEncodeAtomic(OptionalOpIndex index, uint8_t element_size_log2,\n                       int32_t offset) const {\n    if (element_size_log2 != 0) return false;\n    return !(index.has_value() && offset != 0);\n  }\n\n  void SimplifyLoadStore(OpIndex& base, OptionalOpIndex& index,\n                         LoadOp::Kind& kind, int32_t& offset,\n                         uint8_t& element_size_log2) {\n    if (element_size_log2 > kMaxElementSizeLog2) {\n      DCHECK(index.valid());\n      index = __ WordPtrShiftLeft(index.value(), element_size_log2);\n      element_size_log2 = 0;\n    }\n\n    if (kNeedsUntaggedBase) {\n      if (kind.tagged_base) {\n        kind.tagged_base = false;\n        DCHECK_LE(std::numeric_limits<int32_t>::min() + kHeapObjectTag, offset);\n        offset -= kHeapObjectTag;\n        base = __ BitcastHeapObjectToWordPtr(base);\n      }\n    }\n\n    // TODO(nicohartmann@): Remove the case for atomics once crrev.com/c/5237267\n    // is ported to x64.\n    if (!CanEncodeOffset(offset, kind.tagged_base) ||\n        (kind.is_atomic &&\n         !CanEncodeAtomic(index, element_size_log2, offset))) {\n      // If an index is present, the element_size_log2 is changed to zero.\n      // So any load follows the form *(base + offset). To simplify\n      // instruction selection, both static and dynamic offsets are stored in\n      // the index input.\n      // As tagged loads result in modifying the offset by -1, those loads are\n      // converted into raw loads (above).\n      if (!index.has_value() || matcher_.MatchIntegralZero(index.value())) {\n        index = __ IntPtrConstant(offset);\n        element_size_log2 = 0;\n        offset = 0;\n      } else if (element_size_log2 != 0) {\n        index = __ WordPtrShiftLeft(index.value(), element_size_log2);\n        element_size_log2 = 0;\n      }\n      if (offset != 0) {\n        index = __ WordPtrAdd(index.value(), offset);\n        offset = 0;\n      }\n      DCHECK_EQ(offset, 0);\n      DCHECK_EQ(element_size_log2, 0);\n    }\n  }\n\n  OperationMatcher matcher_{__ output_graph()};\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SimplifyLoadStore\",\n                \"parent\": \"LoadStoreSimplificationReducer\",\n                \"about\": \"Simplifies the parameters of a load or store operation to fit the target architecture's capabilities.\",\n                \"logic\": \"Adjusts the index, offset, and element size of load/store operations based on the architecture's limitations.  It handles tagged bases, element size log2, and offset encoding. It checks if the offset can be directly encoded, otherwise it incorporates the offset into the index.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"base\",\n                        \"type\": \"OpIndex&\",\n                        \"purpose\": \"The base address of the load/store operation (modified in place).\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"OptionalOpIndex&\",\n                        \"purpose\": \"The index of the load/store operation (modified in place).\"\n                    },\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"LoadOp::Kind&\",\n                        \"purpose\": \"The kind of the load operation (modified in place).\"\n                    },\n                    {\n                        \"name\": \"offset\",\n                        \"type\": \"int32_t&\",\n                        \"purpose\": \"The offset of the load/store operation (modified in place).\"\n                    },\n                    {\n                        \"name\": \"element_size_log2\",\n                        \"type\": \"uint8_t&\",\n                        \"purpose\": \"The log2 of the element size (modified in place).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"kMaxElementSizeLog2\",\n                    \"kNeedsUntaggedBase\",\n                    \"kHeapObjectTag\",\n                    \"CanEncodeOffset\",\n                    \"CanEncodeAtomic\",\n                    \"OperationMatcher\",\n                    \"LoadOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void SimplifyLoadStore(OpIndex& base, OptionalOpIndex& index,\n                         LoadOp::Kind& kind, int32_t& offset,\n                         uint8_t& element_size_log2) {\n    if (element_size_log2 > kMaxElementSizeLog2) {\n      DCHECK(index.valid());\n      index = __ WordPtrShiftLeft(index.value(), element_size_log2);\n      element_size_log2 = 0;\n    }\n\n    if (kNeedsUntaggedBase) {\n      if (kind.tagged_base) {\n        kind.tagged_base = false;\n        DCHECK_LE(std::numeric_limits<int32_t>::min() + kHeapObjectTag, offset);\n        offset -= kHeapObjectTag;\n        base = __ BitcastHeapObjectToWordPtr(base);\n      }\n    }\n\n    // TODO(nicohartmann@): Remove the case for atomics once crrev.com/c/5237267\n    // is ported to x64.\n    if (!CanEncodeOffset(offset, kind.tagged_base) ||\n        (kind.is_atomic &&\n         !CanEncodeAtomic(index, element_size_log2, offset))) {\n      // If an index is present, the element_size_log2 is changed to zero.\n      // So any load follows the form *(base + offset). To simplify\n      // instruction selection, both static and dynamic offsets are stored in\n      // the index input.\n      // As tagged loads result in modifying the offset by -1, those loads are\n      // converted into raw loads (above).\n      if (!index.has_value() || matcher_.MatchIntegralZero(index.value())) {\n        index = __ IntPtrConstant(offset);\n        element_size_log2 = 0;\n        offset = 0;\n      } else if (element_size_log2 != 0) {\n        index = __ WordPtrShiftLeft(index.value(), element_size_log2);\n        element_size_log2 = 0;\n      }\n      if (offset != 0) {\n        index = __ WordPtrAdd(index.value(), offset);\n        offset = 0;\n      }\n      DCHECK_EQ(offset, 0);\n      DCHECK_EQ(element_size_log2, 0);\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CanEncodeOffset\",\n                \"parent\": \"LoadStoreSimplificationReducer\",\n                \"about\": \"Checks if a given offset can be directly encoded in a load/store instruction for the target architecture.\",\n                \"logic\": \"Determines if the offset falls within the acceptable range defined by kMinOffset and kMaxOffset, optionally adjusting for tagged bases by adding kHeapObjectTag to the minimum offset. It uses LoadOp::OffsetIsValid for extra validation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"offset\",\n                        \"type\": \"int32_t\",\n                        \"purpose\": \"The offset value to check.\"\n                    },\n                    {\n                        \"name\": \"tagged_base\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the base address is tagged (points to a heap object).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the offset can be encoded, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"kMinOffset\",\n                    \"kMaxOffset\",\n                    \"kHeapObjectTag\",\n                    \"LoadOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  bool CanEncodeOffset(int32_t offset, bool tagged_base) const {\n    // If the base is tagged we also need to subtract the kHeapObjectTag\n    // eventually.\n    const int32_t min = kMinOffset + (tagged_base ? kHeapObjectTag : 0);\n    if (min <= offset && offset <= kMaxOffset) {\n      DCHECK(LoadOp::OffsetIsValid(offset, tagged_base));\n      return true;\n    }\n    return false;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CanEncodeAtomic\",\n                \"parent\": \"LoadStoreSimplificationReducer\",\n                \"about\": \"Checks if a load or store can be encoded as an atomic operation.\",\n                \"logic\": \"Checks element size log2 and if index or offset aren't present it returns false. Otherwise it returns true\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"OptionalOpIndex\",\n                        \"purpose\": \"Memory index offset\"\n                    },\n                    {\n                        \"name\": \"element_size_log2\",\n                        \"type\": \"uint8_t\",\n                        \"purpose\": \"Log 2 of element size\"\n                    },\n                    {\n                        \"name\": \"offset\",\n                        \"type\": \"int32_t\",\n                        \"purpose\": \"Memory offset\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if can be encoded as an atomic, false otherwise\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  bool CanEncodeAtomic(OptionalOpIndex index, uint8_t element_size_log2,\n                       int32_t offset) const {\n    if (element_size_log2 != 0) return false;\n    return !(index.has_value() && offset != 0);\n  }\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Next\",\n                    \"about\": \"A template parameter representing the next reducer in the chain.  This isn't defined in this file.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            template <class Next> class LoadStoreSimplificationReducer : public Next\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"LoadOp\",\n                    \"about\": \"Class representing a load operation. Relevant for offset validation and kind.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class LoadOp {\n                    public:\n                        struct Kind {\n                          bool tagged_base;\n                          bool is_atomic;\n                        };\n                        static bool OffsetIsValid(int32_t offset, bool tagged_base);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ConstantOp\",\n                    \"about\": \"Represents a constant value operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass ConstantOp {\n public:\n  enum class Kind { kInteger, kFloat, kSmi };\n  bool IsIntegral() const { return kind == Kind::kInteger; }\n  Kind kind;\n};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}