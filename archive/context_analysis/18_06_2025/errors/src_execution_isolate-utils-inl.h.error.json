{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/isolate-utils-inl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 51, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/isolate-utils-inl.h\",\n        \"file_name\": \"isolate-utils-inl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Inline implementations for isolate-related utility functions, providing efficient access to isolate and heap information from HeapObjects.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for isolate management, memory chunks, heap objects, and pointer compression.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/isolate-utils.h\"\n// Include the non-inl header before the rest of the headers.\n\n#include \"src/common/ptr-compr-inl.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/sandbox/isolate.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetHeapFromWritableObject\",\n            \"about\": \"Retrieves the Heap associated with a writable HeapObject.\",\n            \"logic\": \"Obtains the MemoryChunk from the HeapObject, checks if it's in a writable shared space (and asserts if it is, because this function is not intended for shared objects), and returns the Heap associated with the chunk.  Using this method on shared objects will return the shared space isolate, which might be different from the current isolate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The HeapObject to retrieve the Heap from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Heap*\",\n                \"description\": \"A pointer to the Heap associated with the HeapObject.\"\n            },\n            \"dependencies\": [\n                \"MemoryChunk\",\n                \"HeapObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE Heap* GetHeapFromWritableObject(Tagged<HeapObject> object) {\n  MemoryChunk* chunk = MemoryChunk::FromHeapObject(object);\n  // Do not use this method on shared objects. This method would always return\n  // the shared space isolate for shared objects. However, on worker isolates\n  // this might be different from the current isolate. In such cases either\n  // require the current isolate as an additional argument from the caller or\n  // use Isolate::Current(). From there you can access the shared space isolate\n  // with `isolate->shared_space_isolate()` if needed.\n  DCHECK(!chunk->InWritableSharedSpace());\n  return chunk->GetHeap();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetIsolateFromWritableObject\",\n            \"about\": \"Retrieves the Isolate associated with a writable HeapObject.\",\n            \"logic\": \"Calls GetHeapFromWritableObject to get the Heap, and then uses Isolate::FromHeap to get the Isolate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The HeapObject to retrieve the Isolate from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Isolate*\",\n                \"description\": \"A pointer to the Isolate associated with the HeapObject.\"\n            },\n            \"dependencies\": [\n                \"GetHeapFromWritableObject\",\n                \"Isolate\",\n                \"HeapObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE Isolate* GetIsolateFromWritableObject(Tagged<HeapObject> object) {\n  return Isolate::FromHeap(GetHeapFromWritableObject(object));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetHeapFromWritableObject\",\n            \"about\": \"Retrieves the Heap associated with a writable HeapObjectLayout object.\",\n            \"logic\": \"Converts the HeapObjectLayout to a Tagged<HeapObject> and calls the other GetHeapFromWritableObject overload.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"const HeapObjectLayout&\",\n                    \"purpose\": \"The HeapObjectLayout object to retrieve the Heap from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Heap*\",\n                \"description\": \"A pointer to the Heap associated with the HeapObjectLayout object.\"\n            },\n            \"dependencies\": [\n                \"GetHeapFromWritableObject\",\n                \"HeapObjectLayout\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE Heap* GetHeapFromWritableObject(const HeapObjectLayout& object) {\n  return GetHeapFromWritableObject(Tagged(&object));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetIsolateFromWritableObject\",\n            \"about\": \"Retrieves the Isolate associated with a writable HeapObjectLayout object.\",\n            \"logic\": \"Converts the HeapObjectLayout to a Tagged<HeapObject> and calls the other GetIsolateFromWritableObject overload.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"const HeapObjectLayout&\",\n                    \"purpose\": \"The HeapObjectLayout object to retrieve the Isolate from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Isolate*\",\n                \"description\": \"A pointer to the Isolate associated with the HeapObjectLayout object.\"\n            },\n            \"dependencies\": [\n                \"GetIsolateFromWritableObject\",\n                \"HeapObjectLayout\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE Isolate* GetIsolateFromWritableObject(\n    const HeapObjectLayout& object) {\n  return GetIsolateFromWritableObject(Tagged(&object));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetIsolateFromHeapObject\",\n            \"about\": \"Retrieves the Isolate associated with a HeapObject, returning a boolean indicating success.\",\n            \"logic\": \"Obtains the MemoryChunk from the HeapObject, checks if it's in read-only space. If so, sets the isolate pointer to null and returns false. Otherwise, gets the Heap and then the Isolate from the Heap, sets the isolate pointer, and returns true.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The HeapObject to retrieve the Isolate from.\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate**\",\n                    \"purpose\": \"A pointer to store the resulting Isolate pointer.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if an Isolate was found, false if the object is in read-only space.\"\n            },\n            \"dependencies\": [\n                \"MemoryChunk\",\n                \"HeapObject\",\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE bool GetIsolateFromHeapObject(Tagged<HeapObject> object,\n                                        Isolate** isolate) {\n  MemoryChunk* chunk = MemoryChunk::FromHeapObject(object);\n  if (chunk->InReadOnlySpace()) {\n    *isolate = nullptr;\n    return false;\n  }\n  *isolate = Isolate::FromHeap(chunk->GetHeap());\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetIsolateForSandbox\",\n            \"about\": \"Retrieves the IsolateForSandbox associated with a HeapObject (only in sandbox mode).\",\n            \"logic\": \"In sandbox mode, obtains the MemoryChunk from the HeapObject, gets the Isolate from the Heap, and returns it. In non-sandbox mode, returns an empty IsolateForSandbox object. This function can be used on shared objects. The returned isolate is the sandbox isolate, and may not be the same as `Isolate::Current()`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The HeapObject to retrieve the IsolateForSandbox from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"IsolateForSandbox\",\n                \"description\": \"The IsolateForSandbox associated with the HeapObject (in sandbox mode), or an empty object in non-sandbox mode.\"\n            },\n            \"dependencies\": [\n                \"MemoryChunk\",\n                \"HeapObject\",\n                \"Isolate\",\n                \"IsolateForSandbox\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE IsolateForSandbox GetIsolateForSandbox(Tagged<HeapObject> object) {\n#ifdef V8_ENABLE_SANDBOX\n  // This method can be used on shared objects as opposed to\n  // GetHeapFromWritableObject because it only returns IsolateForSandbox instead\n  // of the Isolate. This is because shared objects will go to shared external\n  // pointer table which is the same for main and all worker isolates.\n  MemoryChunk* chunk = MemoryChunk::FromHeapObject(object);\n  Isolate* isolate = Isolate::FromHeap(chunk->GetHeap());\n  // TODO(396607238): Enable the following line, which requires resolving some\n  // inl-header cycles.\n  // SBXCHECK_EQ(isolate, Isolate::Current());\n  return isolate;\n#else\n  // Not used in non-sandbox mode.\n  return {};\n#endif\n}\n        ]]></code>\n    </func>\n</file>\n```"
}