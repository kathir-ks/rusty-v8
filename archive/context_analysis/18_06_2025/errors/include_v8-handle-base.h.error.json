{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-handle-base.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 61, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-handle-base.h\",\n        \"file_name\": \"v8-handle-base.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines base classes for handles used in the V8 JavaScript engine to manage objects. Includes `StackAllocated`, `IndirectHandleBase`, and conditionally `DirectHandleBase`.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary V8 internal definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"v8-internal.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackAllocated\",\n            \"about\": \"A template class to check if an object is allocated on the stack.  It either performs a stack check or does nothing, based on the template parameter `check_statically_enabled`.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <bool check_statically_enabled>\n            class StackAllocated {\n            public:\n              V8_INLINE StackAllocated() = default;\n\n             protected:\n              struct no_checking_tag {};\n              static constexpr no_checking_tag do_not_check{};\n\n              V8_INLINE explicit StackAllocated(no_checking_tag) {}\n              V8_INLINE explicit StackAllocated(const StackAllocated& other,\n                                                no_checking_tag) {}\n\n              V8_INLINE void VerifyOnStack() const {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackAllocated<true>\",\n            \"extends\": \"StackAllocated<false>\",\n            \"about\": \"Specialization of `StackAllocated` that performs the stack check via `VerifyOnStack`.  The `V8_TRIVIAL_ABI` macro conditionally affects copyability.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            class V8_TRIVIAL_ABI StackAllocated<true> : public StackAllocated<false> {\n            public:\n              V8_INLINE StackAllocated() { VerifyOnStack(); }\n\n            #if V8_HAS_ATTRIBUTE_TRIVIAL_ABI\n              // In this case, StackAllocated becomes not trivially copyable.\n              V8_INLINE StackAllocated(const StackAllocated& other) { VerifyOnStack(); }\n              StackAllocated& operator=(const StackAllocated&) = default;\n            #endif\n\n             protected:\n              V8_INLINE explicit StackAllocated(no_checking_tag tag)\n                  : StackAllocated<false>(tag) {}\n              V8_INLINE explicit StackAllocated(const StackAllocated& other,\n                                                no_checking_tag tag)\n                  : StackAllocated<false>(other, tag) {}\n\n            #ifdef ENABLE_SLOW_DCHECKS\n              V8_EXPORT void VerifyOnStack() const;\n            #else\n              V8_INLINE V8_EXPORT void VerifyOnStack() const {}\n            #endif\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IndirectHandleBase\",\n            \"about\": \"Base class for handles that store a pointer to a memory location containing the actual object's address. Used when direct local support is not enabled.\",\n            \"attributes\": [\n                {\n                    \"name\": \"location_\",\n                    \"type\": \"internal::Address*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the address of the memory location that holds the object's address.\"\n                }\n            ],\n            \"dependencies\": [\n                \"internal::ValueHelper\",\n                \"internal::HandleHelper\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * A base class for abstract handles containing indirect pointers.\n             * These are useful regardless of whether direct local support is enabled.\n             */\n            class IndirectHandleBase {\n            public:\n              // Returns true if the handle is empty.\n              V8_INLINE bool IsEmpty() const { return location_ == nullptr; }\n\n              // Sets the handle to be empty. IsEmpty() will then return true.\n              V8_INLINE void Clear() { location_ = nullptr; }\n\n             protected:\n              friend class internal::ValueHelper;\n              friend class internal::HandleHelper;\n\n              V8_INLINE IndirectHandleBase() = default;\n              V8_INLINE IndirectHandleBase(const IndirectHandleBase& other) = default;\n              V8_INLINE IndirectHandleBase& operator=(const IndirectHandleBase& that) =\n                  default;\n\n              V8_INLINE explicit IndirectHandleBase(internal::Address* location)\n                  : location_(location) {}\n\n              // Returns the address of the actual heap object (tagged).\n              // This method must be called only if the handle is not empty, otherwise it\n              // will crash.\n              V8_INLINE internal::Address ptr() const { return *location_; }\n\n              // Returns a reference to the slot (indirect pointer).\n              V8_INLINE internal::Address* const& slot() const { return location_; }\n              V8_INLINE internal::Address*& slot() { return location_; }\n\n              // Returns the handler's \"value\" (direct or indirect pointer, depending on\n              // whether direct local support is enabled).\n              template <typename T, bool check_null = false>\n              V8_INLINE T* value() const {\n                return internal::ValueHelper::SlotAsValue<T, check_null>(slot());\n              }\n\n            #ifdef V8_ENABLE_DIRECT_HANDLE\n              V8_INLINE internal::ValueHelper::InternalRepresentationType repr() const {\n                return location_ ? *location_ : internal::ValueHelper::kEmpty;\n              }\n            #else\n              V8_INLINE internal::ValueHelper::InternalRepresentationType repr() const {\n                return location_;\n              }\n            #endif  // V8_ENABLE_DIRECT_HANDLE\n\n             private:\n              internal::Address* location_ = nullptr;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DirectHandleBase\",\n            \"about\": \"Base class for handles that directly store the object's address.  Only enabled when `V8_ENABLE_DIRECT_HANDLE` is defined (conservative stack scanning).\",\n            \"attributes\": [\n                {\n                    \"name\": \"ptr_\",\n                    \"type\": \"internal::Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the direct address of the object.\"\n                }\n            ],\n            \"dependencies\": [\n                \"internal::ValueHelper\",\n                \"internal::HandleHelper\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_ENABLE_DIRECT_HANDLE\n\n            /**\n             * A base class for abstract handles containing direct pointers.\n             * These are only possible when conservative stack scanning is enabled.\n             */\n            class DirectHandleBase {\n            public:\n              // Returns true if the handle is empty.\n              V8_INLINE bool IsEmpty() const {\n                return ptr_ == internal::ValueHelper::kEmpty;\n              }\n\n              // Sets the handle to be empty. IsEmpty() will then return true.\n              V8_INLINE void Clear() { ptr_ = internal::ValueHelper::kEmpty; }\n\n             protected:\n              friend class internal::ValueHelper;\n              friend class internal::HandleHelper;\n\n              V8_INLINE DirectHandleBase() = default;\n              V8_INLINE DirectHandleBase(const DirectHandleBase& other) = default;\n              V8_INLINE DirectHandleBase& operator=(const DirectHandleBase& that) = default;\n\n              V8_INLINE explicit DirectHandleBase(internal::Address ptr) : ptr_(ptr) {}\n\n              // Returns the address of the referenced object.\n              V8_INLINE internal::Address ptr() const { return ptr_; }\n\n              // Returns the handler's \"value\" (direct pointer, as direct local support\n              // is guaranteed to be enabled here).\n              template <typename T, bool check_null = false>\n              V8_INLINE T* value() const {\n                return reinterpret_cast<T*>(ptr_);\n              }\n\n              V8_INLINE internal::ValueHelper::InternalRepresentationType repr() const {\n                return ptr_;\n              }\n\n             private:\n              internal::Address ptr_ = internal::ValueHelper::kEmpty;\n            };\n\n            #endif  // V8_ENABLE_DIRECT_HANDLE\n        ]]></code>\n    </class>\n</file>\n```"
}