{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/snapshot-source-sink.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 180, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/snapshot-source-sink.h\",\n            \"file_name\": \"snapshot-source-sink.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines classes for reading and writing snapshot files, used for serialization and deserialization of the V8 heap.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for utility, data structures, atomics, logging, and global definitions.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <utility>\n#include <vector>\n\n#include \"src/base/atomicops.h\"\n#include \"src/base/logging.h\"\n#include \"src/common/globals.h\"\n#include \"src/utils/utils.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SnapshotByteSource\",\n                \"about\": \"Provides an interface for reading byte data from a snapshot or builtins file.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"data_\",\n                        \"type\": \"const uint8_t*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the start of the data buffer.\"\n                    },\n                    {\n                        \"name\": \"length_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The length of the data buffer.\"\n                    },\n                    {\n                        \"name\": \"position_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current reading position in the data buffer.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"base::Vector\",\n                    \"base::AtomicWord\",\n                    \"base::Relaxed_Store\",\n                    \"Tagged_t\",\n                    \"AtomicTagged_t\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass SnapshotByteSource final {\n public:\n  SnapshotByteSource(const char* data, int length)\n      : data_(reinterpret_cast<const uint8_t*>(data)),\n        length_(length),\n        position_(0) {}\n\n  explicit SnapshotByteSource(base::Vector<const uint8_t> payload)\n      : data_(payload.begin()), length_(payload.length()), position_(0) {}\n\n  ~SnapshotByteSource() = default;\n  SnapshotByteSource(const SnapshotByteSource&) = delete;\n  SnapshotByteSource& operator=(const SnapshotByteSource&) = delete;\n\n  bool HasMore() { return position_ < length_; }\n\n  uint8_t Get() {\n    DCHECK(position_ < length_);\n    return data_[position_++];\n  }\n\n  uint8_t Peek() const {\n    DCHECK(position_ < length_);\n    return data_[position_];\n  }\n\n  void Advance(int by) { position_ += by; }\n\n  void CopyRaw(void* to, int number_of_bytes) {\n    DCHECK_LE(position_ + number_of_bytes, length_);\n    memcpy(to, data_ + position_, number_of_bytes);\n    position_ += number_of_bytes;\n  }\n\n  void CopySlots(Address* dest, int number_of_slots) {\n    base::AtomicWord* start = reinterpret_cast<base::AtomicWord*>(dest);\n    base::AtomicWord* end = start + number_of_slots;\n    for (base::AtomicWord* p = start; p < end;\n         ++p, position_ += sizeof(base::AtomicWord)) {\n      base::AtomicWord val;\n      memcpy(&val, data_ + position_, sizeof(base::AtomicWord));\n      base::Relaxed_Store(p, val);\n    }\n  }\n\n#ifdef V8_COMPRESS_POINTERS\n  void CopySlots(Tagged_t* dest, int number_of_slots) {\n    AtomicTagged_t* start = reinterpret_cast<AtomicTagged_t*>(dest);\n    AtomicTagged_t* end = start + number_of_slots;\n    for (AtomicTagged_t* p = start; p < end;\n         ++p, position_ += sizeof(AtomicTagged_t)) {\n      AtomicTagged_t val;\n      memcpy(&val, data_ + position_, sizeof(AtomicTagged_t));\n      base::Relaxed_Store(p, val);\n    }\n  }\n#endif\n\n  // Decode a uint30 with run-length encoding. Must have been encoded with\n  // PutUint30.\n  inline uint32_t GetUint30() {\n    // This way of decoding variable-length encoded integers does not\n    // suffer from branch mispredictions.\n    DCHECK_LT(position_ + 3, length_);\n    uint32_t answer = data_[position_];\n    answer |= data_[position_ + 1] << 8;\n    answer |= data_[position_ + 2] << 16;\n    answer |= data_[position_ + 3] << 24;\n    int bytes = (answer & 3) + 1;\n    Advance(bytes);\n    uint32_t mask = 0xffffffffu;\n    mask >>= 32 - (bytes << 3);\n    answer &= mask;\n    answer >>= 2;\n    return answer;\n  }\n\n  uint32_t GetUint32() {\n    uint32_t integer;\n    CopyRaw(reinterpret_cast<uint8_t*>(&integer), sizeof(integer));\n    return integer;\n  }\n\n  // Returns length.\n  int GetBlob(const uint8_t** data);\n\n  int position() const { return position_; }\n  void set_position(int position) { position_ = position; }\n\n  const uint8_t* data() const { return data_; }\n  int length() const { return length_; }\n\n private:\n  const uint8_t* data_;\n  int length_;\n  int position_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SnapshotByteSink\",\n                \"about\": \"Provides an interface for writing byte data to a snapshot file.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"data_\",\n                        \"type\": \"std::vector<uint8_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the byte data to be written to the snapshot.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass SnapshotByteSink {\n public:\n  SnapshotByteSink() = default;\n  explicit SnapshotByteSink(int initial_size) : data_(initial_size) {}\n\n  ~SnapshotByteSink() = default;\n\n  void Put(uint8_t b, const char* description) { data_.push_back(b); }\n\n  void PutN(int number_of_bytes, const uint8_t v, const char* description);\n  // Append a uint30 with run-length encoding. Must be decoded with GetUint30.\n  void PutUint30(uint32_t integer, const char* description);\n  void PutUint32(uint32_t integer, const char* description) {\n    PutRaw(reinterpret_cast<uint8_t*>(&integer), sizeof(integer), description);\n  }\n  void PutRaw(const uint8_t* data, int number_of_bytes,\n              const char* description);\n\n  void Append(const SnapshotByteSink& other);\n  int Position() const { return static_cast<int>(data_.size()); }\n\n  const std::vector<uint8_t>* data() const { return &data_; }\n\n private:\n  std::vector<uint8_t> data_;\n};\n        ]]></code>\n    </class>\n</file>\n```"
}