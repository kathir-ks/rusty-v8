{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/variable-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 88, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/variable-reducer.h\",\n            \"file_name\": \"variable-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the VariableReducer class, which manages variables and their associated operations within a Turboshaft graph.  It handles variable assignment, retrieval, and merging in control flow merges (including loops) by inserting Phi nodes where necessary.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard library headers for algorithms, optional values, and containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <algorithm>\n#include <optional>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 base library headers for logging and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/logging.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 codegen header for machine types.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/codegen/machine-type.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Turboshaft specific headers for the assembler, graph, operations, representations, and other reducers and snapshot table\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/compiler/turboshaft/required-optimization-reducer.h\"\n#include \"src/compiler/turboshaft/snapshot-table.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"VariableReducer\",\n                \"extends\": \"RequiredOptimizationReducer<AfterNext>\",\n                \"implements\": [],\n                \"about\": \"Manages variables within a Turboshaft graph, handling assignment, retrieval, and merging using Phi nodes. Adds a RequiredOptimizationReducer, because phis with constant inputs introduced by `VariableReducer` need to be eliminated.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"RequiredOptimizationReducer\",\n                    \"SnapshotTable\",\n                    \"Block\",\n                    \"OpIndex\",\n                    \"Variable\",\n                    \"VariableData\",\n                    \"Assembler\",\n                    \"Zone\",\n                    \"Graph\",\n                    \"BlockIndex\",\n                    \"ZoneAbslFlatHashMap\",\n                    \"ZoneIntrusiveSet\",\n                    \"FrameStateOp\",\n                    \"FrameState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class AfterNext>\nclass VariableReducer : public RequiredOptimizationReducer<AfterNext> {\n  using Next = RequiredOptimizationReducer<AfterNext>;\n  using Snapshot = SnapshotTable<OpIndex, VariableData>::Snapshot;\n\n  struct GetActiveLoopVariablesIndex {\n    IntrusiveSetIndex& operator()(Variable var) const {\n      return var.data().active_loop_variables_index;\n    }\n  };\n\n  struct VariableTable\n      : ChangeTrackingSnapshotTable<VariableTable, OpIndex, VariableData> {\n    explicit VariableTable(Zone* zone)\n        : ChangeTrackingSnapshotTable<VariableTable, OpIndex, VariableData>(\n              zone),\n          active_loop_variables(zone) {}\n\n    ZoneIntrusiveSet<Variable, GetActiveLoopVariablesIndex>\n        active_loop_variables;\n\n    void OnNewKey(Variable var, OpIndex value) { DCHECK(!value.valid()); }\n    void OnValueChange(Variable var, OpIndex old_value, OpIndex new_value) {\n      if (var.data().loop_invariant) {\n        return;\n      }\n      if (old_value.valid() && !new_value.valid()) {\n        active_loop_variables.Remove(var);\n      } else if (!old_value.valid() && new_value.valid()) {\n        active_loop_variables.Add(var);\n      }\n    }\n  };\n\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(VariableReducer)\n\n  void Bind(Block* new_block) {\n    Next::Bind(new_block);\n\n    SealAndSaveVariableSnapshot();\n\n    predecessors_.clear();\n    for (const Block* pred : new_block->PredecessorsIterable()) {\n      std::optional<Snapshot> pred_snapshot =\n          block_to_snapshot_mapping_[pred->index()];\n      DCHECK(pred_snapshot.has_value());\n      predecessors_.push_back(pred_snapshot.value());\n    }\n    std::reverse(predecessors_.begin(), predecessors_.end());\n\n    auto merge_variables =\n        [&](Variable var, base::Vector<const OpIndex> predecessors) -> OpIndex {\n      for (OpIndex idx : predecessors) {\n        if (!idx.valid()) {\n          // If any of the predecessors' value is Invalid, then we shouldn't\n          // merge {var}.\n          return OpIndex::Invalid();\n        } else if (__ output_graph()\n                       .Get(idx)\n                       .template Is<LoadRootRegisterOp>()) {\n          // Variables that once contain the root register never contain another\n          // value.\n          return __ LoadRootRegister();\n        }\n      }\n      return MergeOpIndices(predecessors, var.data().rep);\n    };\n\n    table_.StartNewSnapshot(base::VectorOf(predecessors_), merge_variables);\n    current_block_ = new_block;\n    if (new_block->IsLoop()) {\n      // When starting a loop, we need to create a PendingLoopPhi for each\n      // currently active variable (except those that are marked as\n      // loop-invariant).\n      auto active_loop_variables_begin = table_.active_loop_variables.begin();\n      auto active_loop_variables_end = table_.active_loop_variables.end();\n      if (active_loop_variables_begin != active_loop_variables_end) {\n        ZoneVector<std::pair<Variable, OpIndex>> pending_phis(__ phase_zone());\n        for (Variable var : table_.active_loop_variables) {\n          MaybeRegisterRepresentation rep = var.data().rep;\n          DCHECK_NE(rep, MaybeRegisterRepresentation::None());\n          V<Any> pending_loop_phi =\n              __ PendingLoopPhi(table_.Get(var), RegisterRepresentation(rep));\n          SetVariable(var, pending_loop_phi);\n          pending_phis.push_back({var, pending_loop_phi});\n        }\n        loop_pending_phis_[new_block->index()].emplace(pending_phis);\n      }\n    }\n  }\n\n  void RestoreTemporaryVariableSnapshotAfter(const Block* block) {\n    DCHECK(table_.IsSealed());\n    DCHECK(block_to_snapshot_mapping_[block->index()].has_value());\n    table_.StartNewSnapshot(*block_to_snapshot_mapping_[block->index()]);\n    is_temporary_ = true;\n  }\n  void CloseTemporaryVariableSnapshot() {\n    DCHECK(is_temporary_);\n    table_.Seal();\n    is_temporary_ = false;\n  }\n\n  V<None> REDUCE(Goto)(Block* destination, bool is_backedge) {\n    V<None> result = Next::ReduceGoto(destination, is_backedge);\n    if (!destination->IsBound()) {\n      return result;\n    }\n\n    // For loops, we have to \"fix\" the PendingLoopPhis (= replace them with\n    // regular loop phis).\n    DCHECK(destination->IsLoop());\n    DCHECK_EQ(destination->PredecessorCount(), 2);\n\n    if (loop_pending_phis_.contains(destination->index())) {\n      for (auto [var, pending_phi_idx] :\n           loop_pending_phis_[destination->index()].value()) {\n        const PendingLoopPhiOp& pending_phi =\n            __ Get(pending_phi_idx).template Cast<PendingLoopPhiOp>();\n        __ output_graph().template Replace<PhiOp>(\n            pending_phi_idx,\n            base::VectorOf({pending_phi.first(), GetVariable(var)}),\n            pending_phi.rep);\n      }\n    }\n\n    return result;\n  }\n\n  OpIndex GetVariable(Variable var) { return table_.Get(var); }\n\n  OpIndex GetPredecessorValue(Variable var, int predecessor_index) {\n    return table_.GetPredecessorValue(var, predecessor_index);\n  }\n\n  void SetVariable(Variable var, OpIndex new_index) {\n    DCHECK(!is_temporary_);\n    if (V8_UNLIKELY(__ generating_unreachable_operations())) return;\n    table_.Set(var, new_index);\n  }\n  template <typename Rep>\n  void Set(Variable var, V<Rep> value) {\n    DCHECK(!is_temporary_);\n    if (V8_UNLIKELY(__ generating_unreachable_operations())) return;\n    DCHECK(\n        V<Rep>::allows_representation(RegisterRepresentation(var.data().rep)));\n    table_.Set(var, value);\n  }\n\n  Variable NewLoopInvariantVariable(MaybeRegisterRepresentation rep) {\n    DCHECK(!is_temporary_);\n    return table_.NewKey(VariableData{rep, true}, OpIndex::Invalid());\n  }\n  Variable NewVariable(MaybeRegisterRepresentation rep) {\n    DCHECK(!is_temporary_);\n    return table_.NewKey(VariableData{rep, false}, OpIndex::Invalid());\n  }\n\n  // SealAndSaveVariableSnapshot seals the current snapshot, and stores it in\n  // {block_to_snapshot_mapping_}, so that it can be used for later merging.\n  void SealAndSaveVariableSnapshot() {\n    if (table_.IsSealed()) {\n      DCHECK_EQ(current_block_, nullptr);\n      return;\n    }\n\n    DCHECK_NOT_NULL(current_block_);\n    block_to_snapshot_mapping_[current_block_->index()] = table_.Seal();\n    current_block_ = nullptr;\n  }\n\n private:\n  OpIndex MergeOpIndices(base::Vector<const OpIndex> inputs,\n                         MaybeRegisterRepresentation maybe_rep) {\n    if (maybe_rep != MaybeRegisterRepresentation::None()) {\n      // Every Operation that has a RegisterRepresentation can be merged with a\n      // simple Phi.\n      return __ Phi(base::VectorOf(inputs), RegisterRepresentation(maybe_rep));\n    } else if (__ output_graph().Get(inputs[0]).template Is<FrameStateOp>()) {\n      // Frame states need be be merged recursively, because they represent\n      // multiple scalar values that will lead to multiple phi nodes.\n      return MergeFrameState(inputs);\n    } else {\n      return OpIndex::Invalid();\n    }\n  }\n\n  OpIndex MergeFrameState(base::Vector<const OpIndex> frame_states_indices) {\n    base::SmallVector<const FrameStateOp*, 32> frame_states;\n    for (OpIndex idx : frame_states_indices) {\n      frame_states.push_back(\n          &__ output_graph().Get(idx).template Cast<FrameStateOp>());\n    }\n    const FrameStateOp* first_frame = frame_states[0];\n\n#if DEBUG\n    // Making sure that all frame states have the same number of inputs, the\n    // same \"inlined\" field, and the same data.\n    for (auto frame_state : frame_states) {\n      DCHECK_EQ(first_frame->input_count, frame_state->input_count);\n      DCHECK_EQ(first_frame->inlined, frame_state->inlined);\n      DCHECK_EQ(*first_frame->data, *frame_state->data);\n    }\n#endif\n\n    base::SmallVector<OpIndex, 32> new_inputs;\n\n    // Merging the parent frame states.\n    if (first_frame->inlined) {\n      ZoneVector<OpIndex> indices_to_merge(__ phase_zone());\n      bool all_parent_frame_states_are_the_same = true;\n      for (auto frame_state : frame_states) {\n        indices_to_merge.push_back(frame_state->parent_frame_state());\n        all_parent_frame_states_are_the_same =\n            all_parent_frame_states_are_the_same &&\n            first_frame->parent_frame_state() ==\n                frame_state->parent_frame_state();\n      }\n      if (all_parent_frame_states_are_the_same) {\n        new_inputs.push_back(first_frame->parent_frame_state());\n      } else {\n        OpIndex merged_parent_frame_state =\n            MergeFrameState(base::VectorOf(indices_to_merge));\n        new_inputs.push_back(merged_parent_frame_state);\n      }\n    }\n\n    // Merging the state values.\n    for (int i = 0; i < first_frame->state_values_count(); i++) {\n      ZoneVector<OpIndex> indices_to_merge(__ phase_zone());\n      bool all_inputs_are_the_same = true;\n      for (auto frame_state : frame_states) {\n        indices_to_merge.push_back(frame_state->state_value(i));\n        all_inputs_are_the_same =\n            all_inputs_are_the_same &&\n            first_frame->state_value(i) == frame_state->state_value(i);\n      }\n      if (all_inputs_are_the_same) {\n        // This input does not need to be merged, since its identical for all of\n        // the frame states.\n        new_inputs.push_back(first_frame->state_value(i));\n      } else {\n        RegisterRepresentation rep = first_frame->state_value_rep(i);\n        OpIndex new_input =\n            MergeOpIndices(base::VectorOf(indices_to_merge), rep);\n        new_inputs.push_back(new_input);\n      }\n    }\n\n    return __ FrameState(base::VectorOf(new_inputs), first_frame->inlined,\n                         first_frame->data);\n  }\n\n  VariableTable table_{__ phase_zone()};\n  const Block* current_block_ = nullptr;\n  GrowingBlockSidetable<std::optional<Snapshot>> block_to_snapshot_mapping_{\n      __ input_graph().block_count(), std::nullopt, __ phase_zone()};\n  bool is_temporary_ = false;\n\n  // {predecessors_} is used during merging, but we use an instance variable for\n  // it, in order to save memory and not reallocate it for each merge.\n  ZoneVector<Snapshot> predecessors_{__ phase_zone()};\n\n  // Map from loop headers to the pending loop phis in these headers which have\n  // to be patched on backedges.\n  ZoneAbslFlatHashMap<BlockIndex,\n                      std::optional<ZoneVector<std::pair<Variable, OpIndex>>>>\n      loop_pending_phis_{__ phase_zone()};\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RequiredOptimizationReducer\",\n                    \"about\": \"Base class for reducers that require optimization.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass RequiredOptimizationReducer {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SnapshotTable\",\n                    \"about\": \"Manages snapshots of variable values at different program points.\"\n                }\n            </metadata>\n            <code><![CDATA[\ntemplate <typename K, typename V>\nclass SnapshotTable {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Block\",\n                    \"about\": \"Represents a basic block in the control flow graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Block {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"OpIndex\",\n                    \"about\": \"Index of an operation in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass OpIndex {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Variable\",\n                    \"about\": \"Represents a variable in the Turboshaft graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Variable {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"VariableData\",\n                    \"about\": \"Stores data associated with a variable.\"\n                }\n            </metadata>\n            <code><![CDATA[\nstruct VariableData {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Assembler\",\n                    \"about\": \"Helper class to construct Turboshaft graphs.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Assembler {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Zone\",\n                    \"about\": \"Memory management zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Zone {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Graph\",\n                    \"about\": \"The Turboshaft graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass Graph {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"BlockIndex\",\n                    \"about\": \"Index of a block in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass BlockIndex {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ZoneAbslFlatHashMap\",\n                    \"about\": \"Hash map with zone allocation.\"\n                }\n            </metadata>\n            <code><![CDATA[\ntemplate <typename K, typename V>\nclass ZoneAbslFlatHashMap {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n        <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ZoneIntrusiveSet\",\n                    \"about\": \"Intrusive set with zone allocation.\"\n                }\n            </metadata>\n            <code><![CDATA[\ntemplate <typename T, typename Index>\nclass ZoneIntrusiveSet {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n        <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"FrameStateOp\",\n                    \"about\": \"Represents the frame state in the Turboshaft graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass FrameStateOp {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n        <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"FrameState\",\n                    \"about\": \"Holds the frame state data.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass FrameState {\n    //...\n};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}