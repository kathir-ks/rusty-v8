{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/utils.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 93, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/utils.h\",\n        \"file_name\": \"utils.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides utility templates and functions for the Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers for input/output, limits, tuples, and V8 base headers for logging and macros.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <iostream>\n#include <limits>\n#include <tuple>\n\n#include \"src/base/logging.h\"\n#include \"src/base/macros.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"any_of\",\n            \"about\": \"A template class that allows checking if a value is equal to any of the provided arguments.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"std::tuple\",\n                \"std::index_sequence\",\n                \"std::get\",\n                \"base::PrintCheckOperand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class... Ts>\nstruct any_of : std::tuple<const Ts&...> {\n  explicit any_of(const Ts&... args) : std::tuple<const Ts&...>(args...) {}\n\n  template <class T, size_t... indices>\n  bool Contains(const T& value, std::index_sequence<indices...>) {\n    return ((value == std::get<indices>(*this)) || ...);\n  }\n\n  template <size_t... indices>\n  std::ostream& PrintTo(std::ostream& os, std::index_sequence<indices...>) {\n    bool first = true;\n    os << \"any_of(\";\n    (((first ? (first = false, os) : os << \", \"),\n      os << base::PrintCheckOperand(std::get<indices>(*this))),\n     ...);\n    return os << \")\";\n  }\n};\ntemplate <class... Args>\nany_of(const Args&...) -> any_of<Args...>;\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Overloads the == operator to compare a value with an any_of object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The value to compare.\"\n                },\n                {\n                    \"name\": \"options\",\n                    \"type\": \"any_of<Ts...>\",\n                    \"purpose\": \"The any_of object containing the options to compare against.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the value is equal to any of the options, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"any_of\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, class... Ts>\nbool operator==(const T& value, any_of<Ts...> options) {\n  return options.Contains(value, std::index_sequence_for<Ts...>{});\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator to print an any_of object to an output stream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream to print to.\"\n                },\n                {\n                    \"name\": \"any\",\n                    \"type\": \"any_of<Ts...>\",\n                    \"purpose\": \"The any_of object to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": [\n                \"any_of\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class... Ts>\nstd::ostream& operator<<(std::ostream& os, any_of<Ts...> any) {\n  return any.PrintTo(os, std::index_sequence_for<Ts...>{});\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"all_of\",\n            \"about\": \"A template class that allows checking if a value is equal to all of the provided arguments.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"std::tuple\",\n                \"std::index_sequence\",\n                \"std::get\",\n                \"base::PrintCheckOperand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class... Ts>\nstruct all_of : std::tuple<const Ts&...> {\n  explicit all_of(const Ts&... args) : std::tuple<const Ts&...>(args...) {}\n\n  template <class T, size_t... indices>\n  bool AllEqualTo(const T& value, std::index_sequence<indices...>) {\n    return ((value == std::get<indices>(*this)) && ...);\n  }\n\n  template <size_t... indices>\n  std::ostream& PrintTo(std::ostream& os, std::index_sequence<indices...>) {\n    bool first = true;\n    os << \"all_of(\";\n    (((first ? (first = false, os) : os << \", \"),\n      os << base::PrintCheckOperand(std::get<indices>(*this))),\n     ...);\n    return os << \")\";\n  }\n};\ntemplate <class... Args>\nall_of(const Args&...) -> all_of<Args...>;\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Overloads the == operator to compare an all_of object with a value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"values\",\n                    \"type\": \"all_of<Ts...>\",\n                    \"purpose\": \"The all_of object containing the values to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The value to compare.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all values in the all_of object are equal to the target, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"all_of\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, class... Ts>\nbool operator==(all_of<Ts...> values, const T& target) {\n  return values.AllEqualTo(target, std::index_sequence_for<Ts...>{});\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator to print an all_of object to an output stream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream to print to.\"\n                },\n                {\n                    \"name\": \"all\",\n                    \"type\": \"all_of<Ts...>\",\n                    \"purpose\": \"The all_of object to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": [\n                \"all_of\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class... Ts>\nstd::ostream& operator<<(std::ostream& os, all_of<Ts...> all) {\n  return all.PrintTo(os, std::index_sequence_for<Ts...>{});\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ShouldSkipOptimizationStep\",\n            \"about\": \"Determines whether the optimization step should be skipped based on the DEBUG macro.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the optimization step should be skipped, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nV8_EXPORT_PRIVATE bool ShouldSkipOptimizationStep();\n#else\nV8_EXPORT_PRIVATE inline bool ShouldSkipOptimizationStep() { return false; }\n#endif\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ScopedModification\",\n            \"about\": \"A template class that modifies a value within a scope and resets it to the original value upon destruction.\",\n            \"attributes\": [\n                {\n                    \"name\": \"ptr_\",\n                    \"type\": \"T*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the value being modified.\"\n                },\n                {\n                    \"name\": \"old_value_\",\n                    \"type\": \"T\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the original value of the modified variable.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nclass ScopedModification {\n public:\n  ScopedModification(T* ptr, T new_value)\n      : ptr_(ptr), old_value_(std::move(*ptr)) {\n    *ptr = std::move(new_value);\n  }\n\n  ~ScopedModification() { *ptr_ = std::move(old_value_); }\n\n  const T& old_value() const { return old_value_; }\n\n private:\n  T* ptr_;\n  T old_value_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"MultiSwitch\",\n            \"about\": \"A template struct used for multi-value switching. Requires specialization for specific types.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T, typename Enable = void>\nstruct MultiSwitch;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"MultiSwitchIntegral\",\n            \"about\": \"A template struct used for multi-value switching for integral types.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T, uint64_t MaxValue>\nstruct MultiSwitchIntegral {\n  static constexpr uint64_t max_value = MaxValue;\n  static constexpr uint64_t encode(T value) {\n    const uint64_t v = static_cast<uint64_t>(value);\n    DCHECK_LT(v, max_value);\n    return v;\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DEFINE_MULTI_SWITCH_INTEGRAL\",\n            \"about\": \"A macro that defines a specialization of MultiSwitch for integral types.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"MultiSwitch\",\n                \"MultiSwitchIntegral\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define DEFINE_MULTI_SWITCH_INTEGRAL(name, max_value) \\\n  template <>                                         \\\n  struct MultiSwitch<name> : MultiSwitchIntegral<name, max_value> {};\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"multi_encode\",\n            \"parent\": \"detail\",\n            \"about\": \"Helper function for encoding multiple values for the multi-switch mechanism.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"uint64_t\",\n                \"description\": \"Encoded value\"\n            },\n            \"dependencies\": [\n                \"MultiSwitch\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace detail {\ntemplate <typename T>\nconstexpr uint64_t multi_encode(const T& value) {\n  return MultiSwitch<T>::encode(value);\n}\n\ntemplate <typename Head, typename Next, typename... Rest>\nconstexpr uint64_t multi_encode(const Head& head, const Next& next,\n                                const Rest&... rest) {\n  uint64_t v = multi_encode(next, rest...);\n  DCHECK_LT(\n      v, std::numeric_limits<uint64_t>::max() / MultiSwitch<Head>::max_value);\n  return (v * MultiSwitch<Head>::max_value) + MultiSwitch<Head>::encode(head);\n}\n}  // namespace detail\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"multi\",\n            \"about\": \"Encodes multiple values into a single uint64_t for use in a switch statement.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"uint64_t\",\n                \"description\": \"The encoded value.\"\n            },\n            \"dependencies\": [\n                \"detail::multi_encode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename... Ts>\ninline constexpr uint64_t multi(const Ts&... values) {\n  return detail::multi_encode(values...);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DEFINE_MULTI_SWITCH_INTEGRAL\",\n            \"about\": \"Specializes the multi switch for boolean values\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"MultiSwitch\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDEFINE_MULTI_SWITCH_INTEGRAL(bool, 2)\n        ]]></code>\n    </func>\n</file>\n```"
}