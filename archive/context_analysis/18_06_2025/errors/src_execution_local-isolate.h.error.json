{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/local-isolate.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 116, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/local-isolate.h\",\n            \"file_name\": \"local-isolate.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the LocalIsolate class, a lightweight Isolate-like class for off-thread use, primarily for heap access and object creation without full Isolate overhead.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for standard library features, V8 base macros, mutex guards, thread IDs, handle management, local heaps, local factories, runtime call stats, and optional types.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/macros.h\"\n#include \"src/execution/mutex-guard-if-off-thread.h\"\n#include \"src/execution/thread-id.h\"\n#include \"src/handles/handles.h\"\n#include \"src/handles/local-handles.h\"\n#include \"src/handles/maybe-handles.h\"\n#include \"src/heap/local-factory.h\"\n#include \"src/heap/local-heap.h\"\n#include \"src/logging/runtime-call-stats.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"HiddenLocalFactory\",\n                \"extends\": \"LocalFactory\",\n                \"about\": \"A private class that parallels Isolate's HiddenFactory, providing a local factory for object creation.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"LocalFactory\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// HiddenLocalFactory parallels Isolate's HiddenFactory\nclass V8_EXPORT_PRIVATE HiddenLocalFactory : private LocalFactory {\n public:\n  // Forward constructors.\n  using LocalFactory::LocalFactory;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalIsolate\",\n                \"about\": \"An Isolate-like class usable off-thread, holding a LocalFactory and LocalHeap for object allocation. It's a stub implementation and doesn't support exceptions.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"heap_\",\n                        \"type\": \"LocalHeap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The local heap associated with this LocalIsolate.\"\n                    },\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the main Isolate.\"\n                    },\n                    {\n                        \"name\": \"logger_\",\n                        \"type\": \"std::unique_ptr<LocalLogger>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A unique pointer to a local logger.\"\n                    },\n                    {\n                        \"name\": \"thread_id_\",\n                        \"type\": \"ThreadId\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The ID of the thread associated with this LocalIsolate.\"\n                    },\n                    {\n                        \"name\": \"stack_limit_\",\n                        \"type\": \"Address\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The stack limit for this LocalIsolate.\"\n                    },\n                    {\n                        \"name\": \"bigint_processor_\",\n                        \"type\": \"bigint::Processor*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the BigInt processor, lazily initialized.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"HiddenLocalFactory\",\n                    \"LocalHeap\",\n                    \"Isolate\",\n                    \"LocalLogger\",\n                    \"RuntimeCallStats\",\n                    \"bigint::Processor\",\n                    \"StringTable\",\n                    \"AstStringConstants\",\n                    \"LazyCompileDispatcher\",\n                    \"V8FileLogger\",\n                    \"IsolateGroup\",\n                    \"AccountingAllocator\",\n                    \"JSDispatchTable\",\n                    \"StartupData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// And Isolate-like class that can be passed in to templated methods that need\n// an isolate syntactically, but are usable off-thread.\n//\n// This class holds an LocalFactory, but is otherwise effectively a stub\n// implementation of an Isolate. In particular, it doesn't allow throwing\n// exceptions, and hard crashes if you try.\nclass V8_EXPORT_PRIVATE LocalIsolate final : private HiddenLocalFactory {\n public:\n  using HandleScopeType = LocalHandleScope;\n\n  explicit LocalIsolate(Isolate* isolate, ThreadKind kind);\n  ~LocalIsolate();\n\n  // Kinda sketchy.\n  static LocalIsolate* FromHeap(LocalHeap* heap) {\n    return reinterpret_cast<LocalIsolate*>(reinterpret_cast<Address>(heap) -\n                                           OFFSET_OF(LocalIsolate, heap_));\n  }\n\n  bool is_main_thread() const { return heap()->is_main_thread(); }\n\n  LocalHeap* heap() { return &heap_; }\n  const LocalHeap* heap() const { return &heap_; }\n\n  inline Address cage_base() const;\n  inline Address code_cage_base() const;\n  inline ReadOnlyHeap* read_only_heap() const;\n  inline RootsTable& roots_table();\n  inline const RootsTable& roots_table() const;\n  inline Tagged<Object> root(RootIndex index) const;\n  inline Handle<Object> root_handle(RootIndex index) const;\n\n  base::RandomNumberGenerator* fuzzer_rng() const {\n    return isolate_->fuzzer_rng();\n  }\n\n  StringTable* string_table() const { return isolate_->string_table(); }\n  base::Mutex* internalized_string_access() {\n    return isolate_->internalized_string_access();\n  }\n  base::Mutex* shared_function_info_access() {\n    return isolate_->shared_function_info_access();\n  }\n  const AstStringConstants* ast_string_constants() {\n    return isolate_->ast_string_constants();\n  }\n  LazyCompileDispatcher* lazy_compile_dispatcher() {\n    return isolate_->lazy_compile_dispatcher();\n  }\n  V8FileLogger* main_thread_logger() {\n    // TODO(leszeks): This is needed for logging in ParseInfo. Figure out a way\n    // to use the LocalLogger for this instead.\n    return isolate_->v8_file_logger();\n  }\n\n  bool is_precise_binary_code_coverage() const {\n    return isolate_->is_precise_binary_code_coverage();\n  }\n\n  v8::internal::LocalFactory* factory() {\n    // Upcast to the privately inherited base-class using c-style casts to avoid\n    // undefined behavior (as static_cast cannot cast across private bases).\n    return (v8::internal::LocalFactory*)this;\n  }\n\n  IsolateGroup* isolate_group() const { return isolate_->isolate_group(); }\n\n  AccountingAllocator* allocator() { return isolate_->allocator(); }\n\n  bool has_exception() const { return false; }\n  bool serializer_enabled() const { return isolate_->serializer_enabled(); }\n\n  void RegisterDeserializerStarted();\n  void RegisterDeserializerFinished();\n  bool has_active_deserializer() const;\n\n  void Throw(Tagged<Object> exception) { UNREACHABLE(); }\n  [[noreturn]] void FatalProcessOutOfHeapMemory(const char* location) {\n    UNREACHABLE();\n  }\n\n  int GetNextScriptId();\n  uint32_t GetAndIncNextUniqueSfiId() {\n    return isolate_->GetAndIncNextUniqueSfiId();\n  }\n\n  // TODO(cbruni): rename this back to logger() once the V8FileLogger\n  // refactoring is completed.\n  LocalLogger* v8_file_logger() const { return logger_.get(); }\n  ThreadId thread_id() const { return thread_id_; }\n  Address stack_limit() const { return stack_limit_; }\n#ifdef V8_RUNTIME_CALL_STATS\n  RuntimeCallStats* runtime_call_stats() const { return runtime_call_stats_; }\n#else\n  RuntimeCallStats* runtime_call_stats() const { return nullptr; }\n#endif\n  bigint::Processor* bigint_processor() {\n    if (!bigint_processor_) InitializeBigIntProcessor();\n    return bigint_processor_;\n  }\n\n#ifdef V8_ENABLE_LEAPTIERING\n  JSDispatchTable::Space* GetJSDispatchTableSpaceFor(Address owning_slot) {\n    return isolate_->GetJSDispatchTableSpaceFor(owning_slot);\n  }\n#endif  // V8_ENABLE_LEAPTIERING\n\n  // AsIsolate is only allowed on the main-thread.\n  Isolate* AsIsolate() {\n    DCHECK(is_main_thread());\n    DCHECK_EQ(ThreadId::Current(), isolate_->thread_id());\n    return isolate_;\n  }\n  LocalIsolate* AsLocalIsolate() { return this; }\n\n  LocalIsolate* shared_space_isolate() const {\n    return isolate_->shared_space_isolate()->main_thread_local_isolate();\n  }\n\n  // TODO(victorgomes): Remove this when/if MacroAssembler supports LocalIsolate\n  // only constructor.\n  Isolate* GetMainThreadIsolateUnsafe() const { return isolate_; }\n\n  const v8::StartupData* snapshot_blob() const {\n    return isolate_->snapshot_blob();\n  }\n  Tagged<Object>* pending_message_address() {\n    return isolate_->pending_message_address();\n  }\n\n  int NextOptimizationId() { return isolate_->NextOptimizationId(); }\n\n  template <typename Callback>\n  V8_INLINE void ExecuteMainThreadWhileParked(Callback callback);\n\n  template <typename Callback>\n  V8_INLINE void ParkIfOnBackgroundAndExecute(Callback callback);\n\n#ifdef V8_INTL_SUPPORT\n  // WARNING: This might be out-of-sync with the main-thread.\n  const std::string& DefaultLocale();\n#endif\n\n private:\n  friend class v8::internal::LocalFactory;\n  friend class LocalIsolateFactory;\n  friend class IsolateForPointerCompression;\n  friend class IsolateForSandbox;\n\n  // See IsolateForSandbox.\n  Isolate* ForSandbox() { return isolate_; }\n\n  void InitializeBigIntProcessor();\n\n  LocalHeap heap_;\n\n  // TODO(leszeks): Extract out the fields of the Isolate we want and store\n  // those instead of the whole thing.\n  Isolate* const isolate_;\n\n  std::unique_ptr<LocalLogger> logger_;\n  ThreadId const thread_id_;\n  Address const stack_limit_;\n\n  bigint::Processor* bigint_processor_{nullptr};\n\n#ifdef V8_RUNTIME_CALL_STATS\n  std::optional<WorkerThreadRuntimeCallStatsScope> rcs_scope_;\n  RuntimeCallStats* runtime_call_stats_;\n#endif\n#ifdef V8_INTL_SUPPORT\n  std::string default_locale_;\n#endif\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MutexGuardIfOffThread\",\n                \"about\": \"A mutex guard that only acquires the mutex if the LocalIsolate is not on the main thread. This avoids unnecessary locking on the main thread.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"mutex_guard_\",\n                        \"type\": \"std::optional<base::MutexGuard>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An optional mutex guard that is only initialized if the LocalIsolate is not on the main thread.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"LocalIsolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nclass V8_NODISCARD MutexGuardIfOffThread<LocalIsolate> final {\n public:\n  MutexGuardIfOffThread(base::Mutex* mutex, LocalIsolate* isolate) {\n    DCHECK_NOT_NULL(mutex);\n    DCHECK_NOT_NULL(isolate);\n    if (!isolate->is_main_thread()) mutex_guard_.emplace(mutex);\n  }\n\n  MutexGuardIfOffThread(const MutexGuardIfOffThread&) = delete;\n  MutexGuardIfOffThread& operator=(const MutexGuardIfOffThread&) = delete;\n\n private:\n  std::optional<base::MutexGuard> mutex_guard_;\n};\n        ]]></code>\n    </class>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"The main Isolate class in V8.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalLogger\",\n                \"about\": \"A logger for the LocalIsolate.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class LocalLogger;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RuntimeCallStats\",\n                \"about\": \"Class for collecting runtime call statistics.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class RuntimeCallStats;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalFactory\",\n                \"about\": \"A factory for creating objects in the LocalHeap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class LocalFactory;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalHeap\",\n                \"about\": \"A local heap for the LocalIsolate.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class LocalHeap;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StringTable\",\n                \"about\": \"The string table.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class StringTable;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AstStringConstants\",\n                \"about\": \"AST string constants.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class AstStringConstants;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LazyCompileDispatcher\",\n                \"about\": \"Dispatcher for lazy compilation.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class LazyCompileDispatcher;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"V8FileLogger\",\n                \"about\": \"A file logger for V8.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class V8FileLogger;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"IsolateGroup\",\n                \"about\": \"An isolate group.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class IsolateGroup;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AccountingAllocator\",\n                \"about\": \"An accounting allocator.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class AccountingAllocator;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSDispatchTable\",\n                \"about\": \"A JS dispatch table.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class JSDispatchTable;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StartupData\",\n                \"about\": \"Startup data.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class StartupData;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReadOnlyHeap\",\n                \"about\": \"The read only heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ReadOnlyHeap;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RootsTable\",\n                \"about\": \"The roots table.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class RootsTable;\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}