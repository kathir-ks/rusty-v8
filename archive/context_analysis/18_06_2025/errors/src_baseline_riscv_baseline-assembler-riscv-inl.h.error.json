{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/riscv/baseline-assembler-riscv-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/riscv/baseline-assembler-riscv-inl.h\",\n        \"file_name\": \"baseline-assembler-riscv-inl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides inline implementations for the BaselineAssembler class on the RISC-V architecture.  It offers a higher-level interface for generating RISC-V assembly code within the V8 baseline compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for baseline assembler functionality, assembler utilities, interface descriptors, and literal objects.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/baseline/baseline-assembler.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/objects/literal-objects-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BaselineAssembler::ScratchRegisterScope\",\n            \"about\": \"Manages the allocation and deallocation of scratch registers within a BaselineAssembler.  It uses a stack-like structure to ensure proper nesting of scratch register usage.\",\n            \"attributes\": [\n                {\n                    \"name\": \"assembler_\",\n                    \"type\": \"BaselineAssembler*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the BaselineAssembler instance this scope belongs to.\"\n                },\n                {\n                    \"name\": \"prev_scope_\",\n                    \"type\": \"ScratchRegisterScope*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the previous ScratchRegisterScope in the stack.\"\n                },\n                {\n                    \"name\": \"wrapped_scope_\",\n                    \"type\": \"UseScratchRegisterScope\",\n                    \"access\": \"private\",\n                    \"purpose\": \"An instance of UseScratchRegisterScope used to manage scratch registers within the assembler.\"\n                }\n            ],\n            \"dependencies\": [\n                \"BaselineAssembler\",\n                \"UseScratchRegisterScope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass BaselineAssembler::ScratchRegisterScope {\n public:\n  explicit ScratchRegisterScope(BaselineAssembler* assembler)\n      : assembler_(assembler),\n        prev_scope_(assembler->scratch_register_scope_),\n        wrapped_scope_(assembler->masm()) {\n    if (!assembler_->scratch_register_scope_) {\n      // If we haven't opened a scratch scope yet, for the first one add a\n      // couple of extra registers.\n      wrapped_scope_.Include(kScratchReg, kScratchReg2);\n    }\n    assembler_->scratch_register_scope_ = this;\n  }\n  ~ScratchRegisterScope() { assembler_->scratch_register_scope_ = prev_scope_; }\n\n  Register AcquireScratch() { return wrapped_scope_.Acquire(); }\n\n private:\n  BaselineAssembler* assembler_;\n  ScratchRegisterScope* prev_scope_;\n  UseScratchRegisterScope wrapped_scope_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Clobbers\",\n            \"parent\": \"detail\",\n            \"about\": \"Checks if a register is clobbered by a MemOperand (i.e., if the MemOperand refers to the same register).\",\n            \"logic\": \"This is a debug-only function. It checks if the given `target` register is the same as the register used in the `MemOperand op`.  It returns true if they are the same, indicating that the register would be clobbered if the memory operand is used to write to that register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"op\",\n                    \"type\": \"MemOperand\",\n                    \"purpose\": \"The memory operand to check against the register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the register is clobbered by the memory operand; false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ninline bool Clobbers(Register target, MemOperand op) {\n  return op.is_reg() && op.rm() == target;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterFrameOperand\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Calculates the MemOperand for accessing a register in the interpreter's register file within the current stack frame.\",\n            \"logic\": \"Calculates the memory operand by offsetting from the frame pointer (fp) by the register's operand number multiplied by the system pointer size.\",\n            \"parameters\": [\n                {\n                    \"name\": \"interpreter_register\",\n                    \"type\": \"interpreter::Register\",\n                    \"purpose\": \"The interpreter register to access.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"The MemOperand representing the location of the interpreter register in the stack frame.\"\n            },\n            \"dependencies\": [\n                \"interpreter::Register\",\n                \"kSystemPointerSize\",\n                \"fp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::RegisterFrameOperand(\n    interpreter::Register interpreter_register) {\n  return MemOperand(fp, interpreter_register.ToOperand() * kSystemPointerSize);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterFrameAddress\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Loads the address of an interpreter register within the frame to a scratch register.\",\n            \"logic\": \"Adds the offset of the interpreter register to the frame pointer and stores the result in the scratch register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"interpreter_register\",\n                    \"type\": \"interpreter::Register\",\n                    \"purpose\": \"The interpreter register to access.\"\n                },\n                {\n                    \"name\": \"rscratch\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to store the address in.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"interpreter::Register\",\n                \"kSystemPointerSize\",\n                \"fp\",\n                \"__ AddWord\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::RegisterFrameAddress(\n    interpreter::Register interpreter_register, Register rscratch) {\n  return __ AddWord(rscratch, fp,\n                    interpreter_register.ToOperand() * kSystemPointerSize);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FeedbackVectorOperand\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Calculates the MemOperand for accessing the FeedbackVector in the current stack frame.\",\n            \"logic\": \"Creates a MemOperand relative to the frame pointer using the offset defined by BaselineFrameConstants::kFeedbackVectorFromFp.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"The MemOperand representing the location of the FeedbackVector.\"\n            },\n            \"dependencies\": [\n                \"BaselineFrameConstants::kFeedbackVectorFromFp\",\n                \"fp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackVectorOperand() {\n  return MemOperand(fp, BaselineFrameConstants::kFeedbackVectorFromFp);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FeedbackCellOperand\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Calculates the MemOperand for accessing the FeedbackCell in the current stack frame.\",\n            \"logic\": \"Creates a MemOperand relative to the frame pointer using the offset defined by BaselineFrameConstants::kFeedbackCellFromFp.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"The MemOperand representing the location of the FeedbackCell.\"\n            },\n            \"dependencies\": [\n                \"BaselineFrameConstants::kFeedbackCellFromFp\",\n                \"fp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackCellOperand() {\n  return MemOperand(fp, BaselineFrameConstants::kFeedbackCellFromFp);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Bind\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Binds a label to the current assembly position.\",\n            \"parameters\": [\n                {\n                    \"name\": \"label\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to bind.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"__ bind\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::Bind(Label* label) { __ bind(label); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpTarget\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Placeholder function indicating a jump target. It doesn't generate any code.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpTarget() {\n  // Nop\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Jump\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Unconditionally jumps to a target label.\",\n            \"parameters\": [\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"__ jmp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::Jump(Label* target, Label::Distance distance) {\n  __ jmp(target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfRoot\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register's value is equal to a specific root value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The index of the root value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"__ JumpIfRoot\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfRoot(Register value, RootIndex index,\n                                   Label* target, Label::Distance distance) {\n  __ JumpIfRoot(value, index, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfNotRoot\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register's value is not equal to a specific root value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The index of the root value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"__ JumpIfNotRoot\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotRoot(Register value, RootIndex index,\n                                      Label* target, Label::Distance distance) {\n  __ JumpIfNotRoot(value, index, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register's value is a Smi (small integer).\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"__ JumpIfSmi\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Register value, Label* target,\n                                  Label::Distance distance) {\n  __ JumpIfSmi(value, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfNotSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register's value is not a Smi (small integer).\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"__ JumpIfNotSmi\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotSmi(Register value, Label* target,\n                                     Label::Distance distance) {\n  __ JumpIfNotSmi(value, target);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfImmediate\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label based on a condition code after comparing a register with an immediate value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition code to check.\"\n                },\n                {\n                    \"name\": \"left\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"right\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The immediate value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"JumpIf\",\n                \"Operand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfImmediate(Condition cc, Register left, int right,\n                                        Label* target,\n                                        Label::Distance distance) {\n  JumpIf(cc, left, Operand(right), target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TestAndBranch\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Performs a bitwise AND operation and jumps to a target label based on the result and a condition code.\",\n            \"logic\": \"Allocates a scratch register, performs a bitwise AND between the input register and the mask, and then branches to the target label based on the specified condition code and whether the result is zero.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the value to test.\"\n                },\n                {\n                    \"name\": \"mask\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The bitmask to apply.\"\n                },\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition code to check.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\",\n                \"__ And\",\n                \"__ Branch\",\n                \"Operand\",\n                \"zero_reg\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::TestAndBranch(Register value, int mask, Condition cc,\n                                      Label* target, Label::Distance distance) {\n  ScratchRegisterScope temps(this);\n  Register tmp = temps.AcquireScratch();\n  __ And(tmp, value, Operand(mask));\n  __ Branch(target, cc, tmp, Operand(zero_reg), distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIf\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label based on a condition code after comparing a register with an operand.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition code to check.\"\n                },\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const Operand&\",\n                    \"purpose\": \"The operand to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"__ Branch\",\n                \"Operand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIf(Condition cc, Register lhs, const Operand& rhs,\n                               Label* target, Label::Distance distance) {\n  __ Branch(target, cc, lhs, Operand(rhs), distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfJSAnyIsPrimitive\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a JSAny value is a primitive (Smi or immediate value). This is conditionally compiled based on V8_STATIC_ROOTS_BOOL.\",\n            \"parameters\": [\n                {\n                    \"name\": \"heap_object\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the JSAny value.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"__ AssertNotSmi\",\n                \"ScratchRegisterScope\",\n                \"__ JumpIfJSAnyIsPrimitive\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfJSAnyIsPrimitive(Register heap_object,\n                                               Label* target,\n                                               Label::Distance distance) {\n  __ AssertNotSmi(heap_object);\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  __ JumpIfJSAnyIsPrimitive(heap_object, scratch, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfObjectTypeFast\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label based on a condition code and the instance type of an object.  A fast path is used for equality and inequality conditions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition code to check.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the object.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\",\n                \"__ JumpIfObjectType\",\n                \"JumpIfObjectType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectTypeFast(Condition cc, Register object,\n                                             InstanceType instance_type,\n                                             Label* target,\n                                             Label::Distance distance) {\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  if (cc == eq || cc == ne) {\n    __ JumpIfObjectType(target, cc, object, instance_type, scratch);\n    return;\n  }\n  JumpIfObjectType(cc, object, instance_type, scratch, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfObjectType\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label based on a condition code and the instance type of an object, using a map register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition code to check.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the object.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type to compare against.\"\n                },\n                {\n                    \"name\": \"map\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to store the map in.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\",\n                \"__ GetObjectType\",\n                \"__ Branch\",\n                \"Operand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectType(Condition cc, Register object,\n                                         InstanceType instance_type,\n                                         Register map, Label* target,\n                                         Label::Distance distance) {\n  ScratchRegisterScope temps(this);\n  Register type = temps.AcquireScratch();\n  __ GetObjectType(object, map, type);\n  __ Branch(target, cc, type, Operand(instance_type), distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfInstanceType\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label based on a condition code and the instance type loaded from a map.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition code to check.\"\n                },\n                {\n                    \"name\": \"map\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the map.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\",\n                \"__ AssertNotSmi\",\n                \"__ GetObjectType\",\n                \"__ LoadWord\",\n                \"FieldMemOperand\",\n                \"Map::kInstanceTypeOffset\",\n                \"__ Branch\",\n                \"Operand\",\n                \"MAP_TYPE\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfInstanceType(Condition cc, Register map,\n                                           InstanceType instance_type,\n                                           Label* target,\n                                           Label::Distance distance) {\n  ScratchRegisterScope temps(this);\n  Register type = temps.AcquireScratch();\n  if (v8_flags.debug_code) {\n    __ AssertNotSmi(map);\n    __ GetObjectType(map, type, type);\n    __ Assert(eq, AbortReason::kUnexpectedValue, type, Operand(MAP_TYPE));\n  }\n  __ LoadWord(type, FieldMemOperand(map, Map::kInstanceTypeOffset));\n  __ Branch(target, cc, type, Operand(instance_type), distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfPointer\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label based on a condition code after comparing a register's value with a value loaded from memory.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition code to check.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the value to compare.\"\n                },\n                {\n                    \"name\": \"operand\",\n                    \"type\": \"MemOperand\",\n                    \"purpose\": \"The memory operand to load the value from.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\",\n                \"__ LoadWord\",\n                \"__ Branch\",\n                \"Operand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfPointer(Condition cc, Register value,\n                                      MemOperand operand, Label* target,\n                                      Label::Distance distance) {\n  ScratchRegisterScope temps(this);\n  Register temp = temps.AcquireScratch();\n  __ LoadWord(temp, operand);\n  __ Branch(target, cc, value, Operand(temp), distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label based on a condition code after comparing a register's value with a Smi (small integer) immediate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition code to check.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the value to compare.\"\n                },\n                {\n                    \"name\": \"smi\",\n                    \"type\": \"Tagged<Smi>\",\n                    \"purpose\": \"The Smi value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the jump.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"__ CompareTaggedAndBranch\",\n                \"Operand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Condition cc, Register value, Tagged<Smi> smi,\n                                  Label* target, Label::Distance distance) {\n  __ CompareTaggedAndBranch(target, cc, value, Operand(smi));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label based on a condition code after comparing two registers, assuming both contain Smi (small integer) values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition code to check.\"\n                },\n                {\n                    \"name\":"
}