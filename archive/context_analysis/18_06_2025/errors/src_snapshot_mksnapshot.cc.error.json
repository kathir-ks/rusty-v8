{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/mksnapshot.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 197, column 49",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/mksnapshot.cc\",\n            \"file_name\": \"mksnapshot.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Generates a snapshot of the V8 VM's heap, which can be used to speed up the startup time of V8.\"\n        }\n    </metadata>\n\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ and V8 headers necessary for snapshot creation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n\n#include <iomanip>\n\n#include \"include/libplatform/libplatform.h\"\n#include \"include/v8-initialization.h\"\n#include \"src/base/platform/elapsed-timer.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/base/platform/wrappers.h\"\n#include \"src/base/vector.h\"\n#include \"src/codegen/cpu-features.h\"\n#include \"src/common/globals.h\"\n#include \"src/flags/flags.h\"\n#include \"src/snapshot/embedded/embedded-file-writer.h\"\n#include \"src/snapshot/snapshot.h\"\n#include \"src/snapshot/static-roots-gen.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SnapshotFileWriter\",\n                \"about\": \"Writes the snapshot data to a C++ file and a binary blob file.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"snapshot_cpp_path_\",\n                        \"type\": \"const char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Path to the C++ file where the snapshot data will be written.\"\n                    },\n                    {\n                        \"name\": \"snapshot_blob_path_\",\n                        \"type\": \"const char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Path to the binary blob file where the snapshot data will be written.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"v8::StartupData\",\n                    \"v8::base::Vector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass SnapshotFileWriter {\n public:\n  void SetSnapshotFile(const char* snapshot_cpp_file) {\n    snapshot_cpp_path_ = snapshot_cpp_file;\n  }\n\n  void SetStartupBlobFile(const char* snapshot_blob_file) {\n    snapshot_blob_path_ = snapshot_blob_file;\n  }\n\n  void WriteSnapshot(v8::StartupData blob) const {\n    // TODO(crbug/633159): if we crash before the files have been fully created,\n    // we end up with a corrupted snapshot file. The build step would succeed,\n    // but the build target is unusable. Ideally we would write out temporary\n    // files and only move them to the final destination as last step.\n    v8::base::Vector<const uint8_t> blob_vector(\n        reinterpret_cast<const uint8_t*>(blob.data), blob.raw_size);\n    MaybeWriteSnapshotFile(blob_vector);\n    MaybeWriteStartupBlob(blob_vector);\n  }\n\n private:\n  void MaybeWriteStartupBlob(v8::base::Vector<const uint8_t> blob) const {\n    if (!snapshot_blob_path_) return;\n\n    FILE* fp = GetFileDescriptorOrDie(snapshot_blob_path_);\n    size_t written = fwrite(blob.begin(), 1, blob.length(), fp);\n    v8::base::Fclose(fp);\n    if (written != static_cast<size_t>(blob.length())) {\n      i::PrintF(\"Writing snapshot file failed.. Aborting.\\n\");\n      remove(snapshot_blob_path_);\n      exit(1);\n    }\n  }\n\n  void MaybeWriteSnapshotFile(v8::base::Vector<const uint8_t> blob) const {\n    if (!snapshot_cpp_path_) return;\n\n    FILE* fp = GetFileDescriptorOrDie(snapshot_cpp_path_);\n\n    WriteSnapshotFilePrefix(fp);\n    WriteSnapshotFileData(fp, blob);\n    WriteSnapshotFileSuffix(fp);\n\n    v8::base::Fclose(fp);\n  }\n\n  static void WriteSnapshotFilePrefix(FILE* fp) {\n    fprintf(fp, \"// Autogenerated snapshot file. Do not edit.\\n\\n\");\n    fprintf(fp, \"#include \\\"src/init/v8.h\\\"\\n\");\n    fprintf(fp, \"#include \\\"src/base/platform/platform.h\\\"\\n\\n\");\n    fprintf(fp, \"#include \\\"src/flags/flags.h\\\"\\n\");\n    fprintf(fp, \"#include \\\"src/snapshot/snapshot.h\\\"\\n\\n\");\n    fprintf(fp, \"namespace v8 {\\n\");\n    fprintf(fp, \"namespace internal {\\n\\n\");\n  }\n\n  static void WriteSnapshotFileSuffix(FILE* fp) {\n    fprintf(fp, \"const v8::StartupData* Snapshot::DefaultSnapshotBlob() {\\n\");\n    fprintf(fp, \"  return &blob;\\n\");\n    fprintf(fp, \"}\\n\");\n    fprintf(fp, \"\\n\");\n    fprintf(\n        fp,\n        \"bool Snapshot::ShouldVerifyChecksum(const v8::StartupData* data) {\\n\");\n    fprintf(fp, \"  return v8_flags.verify_snapshot_checksum;\\n\");\n    fprintf(fp, \"}\\n\");\n    fprintf(fp, \"}  // namespace internal\\n\");\n    fprintf(fp, \"}  // namespace v8\\n\");\n  }\n\n  static void WriteSnapshotFileData(FILE* fp,\n                                    v8::base::Vector<const uint8_t> blob) {\n    fprintf(\n        fp,\n        \"alignas(kPointerAlignment) static const uint8_t blob_data[] = {\\n\");\n    WriteBinaryContentsAsCArray(fp, blob);\n    fprintf(fp, \"};\\n\");\n    fprintf(fp, \"static const int blob_size = %d;\\n\", blob.length());\n    fprintf(fp, \"static const v8::StartupData blob =\\n\");\n    fprintf(fp, \"{ (const char*) blob_data, blob_size };\\n\");\n  }\n\n  static void WriteBinaryContentsAsCArray(\n      FILE* fp, v8::base::Vector<const uint8_t> blob) {\n    for (int i = 0; i < blob.length(); i++) {\n      if ((i & 0x1F) == 0x1F) fprintf(fp, \"\\n\");\n      if (i > 0) fprintf(fp, \",\");\n      fprintf(fp, \"%u\", static_cast<unsigned char>(blob.at(i)));\n    }\n    fprintf(fp, \"\\n\");\n  }\n\n  static FILE* GetFileDescriptorOrDie(const char* filename) {\n    FILE* fp = v8::base::OS::FOpen(filename, \"wb\");\n    if (fp == nullptr) {\n      i::PrintF(\"Unable to open file \\\"%s\\\" for writing.\\n\", filename);\n      exit(1);\n    }\n    return fp;\n  }\n\n  const char* snapshot_cpp_path_ = nullptr;\n  const char* snapshot_blob_path_ = nullptr;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetExtraCode\",\n                \"about\": \"Reads the contents of a file into a dynamically allocated char array.\",\n                \"logic\": \"Opens the specified file in binary read mode, determines its size, allocates a buffer, reads the file content into the buffer, and returns a unique pointer to the buffer. Exits if the file cannot be opened or read.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"filename\",\n                        \"type\": \"char*\",\n                        \"purpose\": \"The path to the file to read.\"\n                    },\n                    {\n                        \"name\": \"description\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"A description of the file's purpose (e.g., 'embedding', 'warm up').\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::unique_ptr<char[]>\",\n                    \"description\": \"A unique pointer to a char array containing the file contents, or nullptr if the filename is empty.\"\n                },\n                \"dependencies\": [\n                    \"v8::base::OS::FOpen\",\n                    \"v8::base::Fclose\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<char[]> GetExtraCode(char* filename, const char* description) {\n  if (filename == nullptr || strlen(filename) == 0) return nullptr;\n  ::printf(\"Loading script for %s: %s\\n\", description, filename);\n  FILE* file = v8::base::OS::FOpen(filename, \"rb\");\n  if (file == nullptr) {\n    fprintf(stderr, \"Failed to open '%s': errno %d\\n\", filename, errno);\n    exit(1);\n  }\n  fseek(file, 0, SEEK_END);\n  size_t size = ftell(file);\n  rewind(file);\n  char* chars = new char[size + 1];\n  chars[size] = '\\0';\n  for (size_t i = 0; i < size;) {\n    size_t read = fread(&chars[i], 1, size - i, file);\n    if (ferror(file)) {\n      fprintf(stderr, \"Failed to read '%s': errno %d\\n\", filename, errno);\n      exit(1);\n    }\n    i += read;\n  }\n  v8::base::Fclose(file);\n  return std::unique_ptr<char[]>(chars);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CreateSnapshotDataBlob\",\n                \"about\": \"Creates the snapshot data blob using the provided snapshot creator and embedded source.\",\n                \"logic\": \"Uses the internal CreateSnapshotDataBlobInternal function to create the snapshot. Measures the time taken for snapshot creation if profile_deserialization flag is enabled.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"snapshot_creator\",\n                        \"type\": \"v8::SnapshotCreator&\",\n                        \"purpose\": \"The snapshot creator object.\"\n                    },\n                    {\n                        \"name\": \"embedded_source\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The embedded source code to include in the snapshot.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"v8::StartupData\",\n                    \"description\": \"The created snapshot data blob.\"\n                },\n                \"dependencies\": [\n                    \"i::CreateSnapshotDataBlobInternal\",\n                    \"v8::SnapshotCreator::FunctionCodeHandling::kClear\",\n                    \"v8::base::ElapsedTimer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nv8::StartupData CreateSnapshotDataBlob(v8::SnapshotCreator& snapshot_creator,\n                                       const char* embedded_source) {\n  v8::base::ElapsedTimer timer;\n  timer.Start();\n\n  v8::StartupData result = i::CreateSnapshotDataBlobInternal(\n      v8::SnapshotCreator::FunctionCodeHandling::kClear, embedded_source,\n      snapshot_creator);\n\n  if (i::v8_flags.profile_deserialization) {\n    i::PrintF(\"[Creating snapshot took %0.3f ms]\\n\",\n              timer.Elapsed().InMillisecondsF());\n  }\n\n  timer.Stop();\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"WarmUpSnapshotDataBlob\",\n                \"about\": \"Warms up the snapshot data blob using the provided warmup source.\",\n                \"logic\": \"Uses the internal WarmUpSnapshotDataBlobInternal function to warm up the snapshot. Measures the time taken for warming up if profile_deserialization flag is enabled.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cold_snapshot_blob\",\n                        \"type\": \"v8::StartupData\",\n                        \"purpose\": \"The cold snapshot data blob to warm up.\"\n                    },\n                    {\n                        \"name\": \"warmup_source\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The warmup source code to use.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"v8::StartupData\",\n                    \"description\": \"The warmed-up snapshot data blob.\"\n                },\n                \"dependencies\": [\n                    \"i::WarmUpSnapshotDataBlobInternal\",\n                    \"v8::base::ElapsedTimer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nv8::StartupData WarmUpSnapshotDataBlob(v8::StartupData cold_snapshot_blob,\n                                       const char* warmup_source) {\n  v8::base::ElapsedTimer timer;\n  timer.Start();\n\n  v8::StartupData result =\n      i::WarmUpSnapshotDataBlobInternal(cold_snapshot_blob, warmup_source);\n\n  if (i::v8_flags.profile_deserialization) {\n    i::PrintF(\"Warming up snapshot took %0.3f ms\\n\",\n              timer.Elapsed().InMillisecondsF());\n  }\n\n  timer.Stop();\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"WriteEmbeddedFile\",\n                \"about\": \"Writes the embedded data to a file using the provided EmbeddedFileWriter.\",\n                \"logic\": \"Retrieves embedded data from blob using i::EmbeddedData::FromBlob(), then use writer->WriteEmbedded()\",\n                \"parameters\": [\n                    {\n                        \"name\": \"writer\",\n                        \"type\": \"i::EmbeddedFileWriter*\",\n                        \"purpose\": \"The EmbeddedFileWriter object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"i::EmbeddedData::FromBlob\",\n                    \"i::EmbeddedFileWriter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WriteEmbeddedFile(i::EmbeddedFileWriter* writer) {\n  i::EmbeddedData embedded_blob = i::EmbeddedData::FromBlob();\n  writer->WriteEmbedded(&embedded_blob);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MaybeSetCounterFunction\",\n                \"about\": \"Sets a counter function on the isolate if the native_code_counters flag is enabled.\",\n                \"logic\": \"If native_code_counters is enabled, this function creates a counter map and sets a counter function on the isolate. The counter function returns distinct addresses for each counter name.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"v8::Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"v8::Isolate\",\n                    \"CounterMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing CounterMap = std::map<std::string, int>;\nCounterMap* counter_map_ = nullptr;\n\nvoid MaybeSetCounterFunction(v8::Isolate* isolate) {\n  // If --native-code-counters is on then we enable all counters to make\n  // sure we generate code to increment them from the snapshot.\n  //\n  // Note: For the sake of the mksnapshot, the counter function must only\n  // return distinct addresses for each counter s.t. the serializer can properly\n  // distinguish between them. In theory it should be okay to just return an\n  // incremented int value each time this function is called, but we play it\n  // safe and return a real distinct memory location tied to every counter name.\n  if (i::v8_flags.native_code_counters) {\n    counter_map_ = new CounterMap();\n    isolate->SetCounterFunction([](const char* name) -> int* {\n      auto map_entry = counter_map_->find(name);\n      if (map_entry == counter_map_->end()) {\n        counter_map_->emplace(name, 0);\n      }\n      return &counter_map_->at(name);\n    });\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"main\",\n                \"about\": \"The main function of the mksnapshot tool.  It parses command line flags, initializes V8, creates a snapshot, and writes it to a file.\",\n                \"logic\": \"Parses command line flags, initializes the V8 platform and isolate, creates a snapshot using SnapshotCreator, and writes the snapshot data to a file using SnapshotFileWriter. Handles embedded files and warmup scripts if provided.  Configures isolate with counter function based on flags.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"argc\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of command-line arguments.\"\n                    },\n                    {\n                        \"name\": \"argv\",\n                        \"type\": \"char**\",\n                        \"purpose\": \"An array of command-line argument strings.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"0 on success, non-zero on failure.\"\n                },\n                \"dependencies\": [\n                    \"v8::base::EnsureConsoleOutput\",\n                    \"i::FlagList::SetFlagsFromCommandLine\",\n                    \"i::CpuFeatures::Probe\",\n                    \"v8::V8::InitializeICUDefaultLocation\",\n                    \"v8::platform::NewDefaultPlatform\",\n                    \"v8::V8::InitializePlatform\",\n                    \"v8::V8::Initialize\",\n                    \"SnapshotFileWriter\",\n                    \"i::EmbeddedFileWriter\",\n                    \"GetExtraCode\",\n                    \"v8::StartupData\",\n                    \"v8::Isolate::Allocate\",\n                    \"MaybeSetCounterFunction\",\n                    \"v8::ArrayBuffer::Allocator::NewDefaultAllocator\",\n                    \"v8::Isolate::CreateParams\",\n                    \"v8::SnapshotCreator\",\n                    \"CreateSnapshotDataBlob\",\n                    \"WriteEmbeddedFile\",\n                    \"WarmUpSnapshotDataBlob\",\n                    \"v8::V8::Dispose\",\n                    \"v8::V8::DisposePlatform\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nint main(int argc, char** argv) {\n  v8::base::EnsureConsoleOutput();\n\n  // Make mksnapshot runs predictable to create reproducible snapshots.\n  i::v8_flags.predictable = true;\n\n  // Disable ICs globally in mksnapshot to avoid problems with Code handlers.\n  // See https://crbug.com/345280736.\n  // TODO(jgruber): Re-enable once a better fix is available.\n  i::v8_flags.use_ic = false;\n\n  // Print the usage if an error occurs when parsing the command line\n  // flags or if the help flag is set.\n  using HelpOptions = i::FlagList::HelpOptions;\n  std::string usage = \"Usage: \" + std::string(argv[0]) +\n                      \" [--startup-src=file]\" + \" [--startup-blob=file]\" +\n                      \" [--embedded-src=file]\" + \" [--embedded-variant=label]\" +\n                      \" [--static-roots-src=file]\" + \" [--target-arch=arch]\" +\n                      \" [--target-os=os] [extras]\\n\\n\";\n  int result = i::FlagList::SetFlagsFromCommandLine(\n      &argc, argv, true, HelpOptions(HelpOptions::kExit, usage.c_str()));\n  if (result > 0 || (argc > 3)) {\n    i::PrintF(stdout, \"%s\", usage.c_str());\n    return result;\n  }\n\n  i::CpuFeatures::Probe(true);\n  v8::V8::InitializeICUDefaultLocation(argv[0]);\n  std::unique_ptr<v8::Platform> platform = v8::platform::NewDefaultPlatform();\n  v8::V8::InitializePlatform(platform.get());\n  v8::V8::Initialize();\n\n  {\n    SnapshotFileWriter snapshot_writer;\n    snapshot_writer.SetSnapshotFile(i::v8_flags.startup_src);\n    snapshot_writer.SetStartupBlobFile(i::v8_flags.startup_blob);\n\n    i::EmbeddedFileWriter embedded_writer;\n    embedded_writer.SetEmbeddedFile(i::v8_flags.embedded_src);\n    embedded_writer.SetEmbeddedVariant(i::v8_flags.embedded_variant);\n    embedded_writer.SetTargetArch(i::v8_flags.target_arch);\n    embedded_writer.SetTargetOs(i::v8_flags.target_os);\n\n    std::unique_ptr<char[]> embed_script =\n        GetExtraCode(argc >= 2 ? argv[1] : nullptr, \"embedding\");\n    std::unique_ptr<char[]> warmup_script =\n        GetExtraCode(argc >= 3 ? argv[2] : nullptr, \"warm up\");\n\n    v8::StartupData blob;\n    {\n      v8::Isolate* isolate = v8::Isolate::Allocate();\n\n      MaybeSetCounterFunction(isolate);\n\n      // The isolate contains data from builtin compilation that needs\n      // to be written out if builtins are embedded.\n      i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n      i_isolate->RegisterEmbeddedFileWriter(&embedded_writer);\n\n      std::unique_ptr<v8::ArrayBuffer::Allocator> array_buffer_allocator(\n          v8::ArrayBuffer::Allocator::NewDefaultAllocator());\n      v8::Isolate::CreateParams create_params;\n      create_params.array_buffer_allocator = array_buffer_allocator.get();\n\n      // Set code range such that relative jumps for builtins to\n      // builtin calls in the snapshot are possible.\n      size_t code_range_size_mb =\n          i::kMaximalCodeRangeSize == 0\n              ? i::kMaxPCRelativeCodeRangeInMB\n              : std::min(i::kMaximalCodeRangeSize / i::MB,\n                         i::kMaxPCRelativeCodeRangeInMB);\n      create_params.constraints.set_code_range_size_in_bytes(\n          code_range_size_mb * i::MB);\n\n      {\n        v8::SnapshotCreator creator(isolate, create_params);\n\n        blob = CreateSnapshotDataBlob(creator, embed_script.get());\n\n        WriteEmbeddedFile(&embedded_writer);\n\n#if V8_STATIC_ROOTS_GENERATION_BOOL\n        if (i::v8_flags.static_roots_src) {\n          i::StaticRootsTableGen::write(i_isolate,\n                                        i::v8_flags.static_roots_src);\n        }\n#endif\n      }\n      isolate->Dispose();\n    }\n\n    if (warmup_script) {\n      v8::StartupData cold = blob;\n      blob = WarmUpSnapshotDataBlob(cold, warmup_script.get());\n      delete[] cold.data;\n    }\n\n    delete counter_map_;\n\n    CHECK(blob.data);\n    snapshot_writer.WriteSnapshot(blob);\n    delete[] blob.data;\n  }\n\n  v8::V8::Dispose();\n  v8::V8::DisposePlatform();\n  return 0;\n}\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"v8::SnapshotCreator\",\n                    \"about\": \"Creates a snapshot of the V8 heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 { class SnapshotCreator { }; }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"i::EmbeddedFileWriter\",\n                    \"about\": \"Writes embedded data to a file.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace i { class EmbeddedFileWriter { public: void SetEmbeddedFile(const char* file) {} void SetEmbeddedVariant(const char* variant) {} void SetTargetArch(const char* arch) {} void SetTargetOs(const char* os) {} }; }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"v8::Platform\",\n                    \"about\": \"Abstract interface for platform-specific operations.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 { class Platform { }; }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"i::Isolate\",\n                    \"about\": \"Internal representation of a V8 isolate.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace i { class Isolate { public: void RegisterEmbeddedFileWriter(i::EmbeddedFileWriter* writer) {} }; }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"v8::ArrayBuffer::Allocator\",\n                    \"about\": \"Allocator for ArrayBuffers.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 { namespace ArrayBuffer { class Allocator { public: static Allocator* NewDefaultAllocator() { return nullptr; } }; } }\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}