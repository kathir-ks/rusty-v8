{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-callbacks.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-callbacks.h\",\n            \"file_name\": \"v8-callbacks.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines various callback types used by the V8 JavaScript engine for interacting with the embedder (the application using V8).\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers and V8-specific headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <stddef.h>\n\n#include <functional>\n#include <string>\n\n#include \"cppgc/common.h\"\n#include \"v8-data.h\"          // NOLINT(build/include_directory)\n#include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n#include \"v8-promise.h\"       // NOLINT(build/include_directory)\n#include \"v8config.h\"         // NOLINT(build/include_directory)\n\n#if defined(V8_OS_WIN)\nstruct _EXCEPTION_POINTERS;\n#endif\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FunctionCallbackInfo\",\n                \"about\": \"Forward declaration for FunctionCallbackInfo. Used in several callback signatures.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass FunctionCallbackInfo;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Forward declaration for Isolate. Represents an isolated instance of the V8 engine.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Isolate;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Message\",\n                \"about\": \"Forward declaration for Message. Represents a JavaScript message (e.g., an error message).\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Message;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Module\",\n                \"about\": \"Forward declaration for Module. Represents an ES module.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Module;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Object\",\n                \"about\": \"Forward declaration for Object. Represents a JavaScript object.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Object;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Promise\",\n                \"about\": \"Forward declaration for Promise. Represents a JavaScript Promise.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Promise;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ScriptOrModule\",\n                \"about\": \"Forward declaration for ScriptOrModule. Represents a JavaScript Script or ES Module.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass ScriptOrModule;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"String\",\n                \"about\": \"Forward declaration for String. Represents a JavaScript string.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass String;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UnboundScript\",\n                \"about\": \"Forward declaration for UnboundScript. Represents a compiled JavaScript script that is not yet bound to a context.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass UnboundScript;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Value\",\n                \"about\": \"Forward declaration for Value. Base class for all JavaScript values.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Value;\n        ]]></code>\n    </class>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"JitCodeEvent\",\n                \"about\": \"Structure that defines the data passed to JitCodeEventHandler callbacks.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"EventType\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Type of event.\"\n                    },\n                    {\n                        \"name\": \"code_type\",\n                        \"type\": \"CodeType\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Type of code (JIT, bytecode, WASM).\"\n                    },\n                    {\n                        \"name\": \"code_start\",\n                        \"type\": \"void*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Start address of the code.\"\n                    },\n                    {\n                        \"name\": \"code_len\",\n                        \"type\": \"size_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Length of the code.\"\n                    },\n                    {\n                        \"name\": \"script\",\n                        \"type\": \"Local<UnboundScript>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Script info for CODE_ADDED event.\"\n                    },\n                    {\n                        \"name\": \"user_data\",\n                        \"type\": \"void*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"User-defined data for *_LINE_INFO_* event.\"\n                    },\n                    {\n                        \"name\": \"wasm_source_info\",\n                        \"type\": \"wasm_source_info_t*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Pointer to wasm source information.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"name_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Name of the object associated with the code (only valid for CODE_ADDED).\"\n                    },\n                    {\n                        \"name\": \"line_info\",\n                        \"type\": \"line_info_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Line info (only valid for CODE_ADD_LINE_POS_INFO).\"\n                    },\n                    {\n                        \"name\": \"new_code_start\",\n                        \"type\": \"void*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"New location of instructions (only valid for CODE_MOVED).\"\n                    },\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Pointer to the isolate.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"UnboundScript\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct JitCodeEvent {\n  enum EventType {\n    CODE_ADDED,\n    CODE_MOVED,\n    CODE_REMOVED,\n    CODE_ADD_LINE_POS_INFO,\n    CODE_START_LINE_INFO_RECORDING,\n    CODE_END_LINE_INFO_RECORDING\n  };\n  // Definition of the code position type. The \"POSITION\" type means the place\n  // in the source code which are of interest when making stack traces to\n  // pin-point the source location of a stack frame as close as possible.\n  // The \"STATEMENT_POSITION\" means the place at the beginning of each\n  // statement, and is used to indicate possible break locations.\n  enum PositionType { POSITION, STATEMENT_POSITION };\n\n  // There are three different kinds of CodeType, one for JIT code generated\n  // by the optimizing compiler, one for byte code generated for the\n  // interpreter, and one for code generated from Wasm. For JIT_CODE and\n  // WASM_CODE, |code_start| points to the beginning of jitted assembly code,\n  // while for BYTE_CODE events, |code_start| points to the first bytecode of\n  // the interpreted function.\n  enum CodeType { BYTE_CODE, JIT_CODE, WASM_CODE };\n\n  // Type of event.\n  EventType type;\n  CodeType code_type;\n  // Start of the instructions.\n  void* code_start;\n  // Size of the instructions.\n  size_t code_len;\n  // Script info for CODE_ADDED event.\n  Local<UnboundScript> script;\n  // User-defined data for *_LINE_INFO_* event. It's used to hold the source\n  // code line information which is returned from the\n  // CODE_START_LINE_INFO_RECORDING event. And it's passed to subsequent\n  // CODE_ADD_LINE_POS_INFO and CODE_END_LINE_INFO_RECORDING events.\n  void* user_data;\n\n  struct name_t {\n    // Name of the object associated with the code, note that the string is not\n    // zero-terminated.\n    const char* str;\n    // Number of chars in str.\n    size_t len;\n  };\n\n  struct line_info_t {\n    // PC offset\n    size_t offset;\n    // Code position\n    size_t pos;\n    // The position type.\n    PositionType position_type;\n  };\n\n  struct wasm_source_info_t {\n    // Source file name.\n    const char* filename;\n    // Length of filename.\n    size_t filename_size;\n    // Line number table, which maps offsets of JITted code to line numbers of\n    // source file.\n    const line_info_t* line_number_table;\n    // Number of entries in the line number table.\n    size_t line_number_table_size;\n  };\n\n  wasm_source_info_t* wasm_source_info = nullptr;\n\n  union {\n    // Only valid for CODE_ADDED.\n    struct name_t name;\n\n    // Only valid for CODE_ADD_LINE_POS_INFO\n    struct line_info_t line_info;\n\n    // New location of instructions. Only valid for CODE_MOVED.\n    void* new_code_start;\n  };\n\n  Isolate* isolate;\n};\n        ]]></code>\n    </struct>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"JitCodeEventOptions\",\n                \"about\": \"Option flags passed to the SetJitCodeEventHandler function.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum JitCodeEventOptions {\n  kJitCodeEventDefault = 0,\n  // Generate callbacks for already existent code.\n  kJitCodeEventEnumExisting = 1,\n\n  kLastJitCodeEventOption = kJitCodeEventEnumExisting\n};\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"JitCodeEventHandler\",\n                \"about\": \"Callback function passed to SetJitCodeEventHandler.\",\n                \"dependencies\": [\n                    \"JitCodeEvent\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing JitCodeEventHandler = void (*)(const JitCodeEvent* event);\n        ]]></code>\n    </typedef>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"GCType\",\n                \"about\": \"Enum for different types of garbage collection.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum GCType {\n  kGCTypeScavenge = 1 << 0,\n  kGCTypeMinorMarkSweep = 1 << 1,\n  kGCTypeMarkSweepCompact = 1 << 2,\n  kGCTypeIncrementalMarking = 1 << 3,\n  kGCTypeProcessWeakCallbacks = 1 << 4,\n  kGCTypeAll = kGCTypeScavenge | kGCTypeMinorMarkSweep |\n               kGCTypeMarkSweepCompact | kGCTypeIncrementalMarking |\n               kGCTypeProcessWeakCallbacks\n};\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"GCCallbackFlags\",\n                \"about\": \"Flags providing additional information about the GC callback.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum GCCallbackFlags {\n  kNoGCCallbackFlags = 0,\n  kGCCallbackFlagConstructRetainedObjectInfos = 1 << 1,\n  kGCCallbackFlagForced = 1 << 2,\n  kGCCallbackFlagSynchronousPhantomCallbackProcessing = 1 << 3,\n  kGCCallbackFlagCollectAllAvailableGarbage = 1 << 4,\n  kGCCallbackFlagCollectAllExternalMemory = 1 << 5,\n  kGCCallbackScheduleIdleGarbageCollection = 1 << 6,\n};\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"GCCallback\",\n                \"about\": \"Callback function for garbage collection events.\",\n                \"dependencies\": [\n                    \"GCType\",\n                    \"GCCallbackFlags\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing GCCallback = void (*)(GCType type, GCCallbackFlags flags);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"InterruptCallback\",\n                \"about\": \"Callback function for interrupts.\",\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing InterruptCallback = void (*)(Isolate* isolate, void* data);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"PrintCurrentStackTraceFilterCallback\",\n                \"about\": \"Callback function used to filter which scripts are printed in the stack trace.\",\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"String\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing PrintCurrentStackTraceFilterCallback =\n    bool (*)(Isolate* isolate, Local<String> script_name);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"NearHeapLimitCallback\",\n                \"about\": \"Callback function invoked when the heap size is close to the limit.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing NearHeapLimitCallback = size_t (*)(void* data, size_t current_heap_limit,\n                                         size_t initial_heap_limit);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"UnhandledExceptionCallback\",\n                \"about\": \"Callback function passed to SetUnhandledExceptionCallback.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#if defined(V8_OS_WIN)\nusing UnhandledExceptionCallback =\n    int (*)(_EXCEPTION_POINTERS* exception_pointers);\n#endif\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"CounterLookupCallback\",\n                \"about\": \"Callback function for looking up counters.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing CounterLookupCallback = int* (*)(const char* name);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"CreateHistogramCallback\",\n                \"about\": \"Callback function for creating histograms.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing CreateHistogramCallback = void* (*)(const char* name, int min, int max,\n                                          size_t buckets);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"AddHistogramSampleCallback\",\n                \"about\": \"Callback function for adding samples to histograms.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing AddHistogramSampleCallback = void (*)(void* histogram, int sample);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"FatalErrorCallback\",\n                \"about\": \"Callback function for handling fatal errors.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing FatalErrorCallback = void (*)(const char* location, const char* message);\n        ]]></code>\n    </typedef>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"OOMDetails\",\n                \"about\": \"Structure containing details about out-of-memory errors.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"is_heap_oom\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether the error is a heap out-of-memory.\"\n                    },\n                    {\n                        \"name\": \"detail\",\n                        \"type\": \"const char*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"A string describing the OOM error in more detail.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstruct OOMDetails {\n  bool is_heap_oom = false;\n  const char* detail = nullptr;\n};\n        ]]></code>\n    </struct>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"OOMErrorCallback\",\n                \"about\": \"Callback function for handling out-of-memory errors.\",\n                \"dependencies\": [\n                    \"OOMDetails\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing OOMErrorCallback = void (*)(const char* location,\n                                  const OOMDetails& details);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"MessageCallback\",\n                \"about\": \"Callback function for handling messages.\",\n                \"dependencies\": [\n                    \"Message\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing MessageCallback = void (*)(Local<Message> message, Local<Value> data);\n        ]]></code>\n    </typedef>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"LogEventStatus\",\n                \"about\": \"Enum for log event status.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum LogEventStatus : int { kStart = 0, kEnd = 1, kLog = 2 };\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"LogEventCallback\",\n                \"about\": \"Callback function for log events.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing LogEventCallback = void (*)(const char* name,\n                                  int /* LogEventStatus */ status);\n        ]]></code>\n    </typedef>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"CrashKeyId\",\n                \"about\": \"Enum for crash key identifiers.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class CrashKeyId {\n  kIsolateAddress,\n  kReadonlySpaceFirstPageAddress,\n  kMapSpaceFirstPageAddress V8_ENUM_DEPRECATE_SOON(\"Map space got removed\"),\n  kOldSpaceFirstPageAddress,\n  kCodeRangeBaseAddress,\n  kCodeSpaceFirstPageAddress,\n  kDumpType,\n  kSnapshotChecksumCalculated,\n  kSnapshotChecksumExpected,\n};\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"AddCrashKeyCallback\",\n                \"about\": \"Callback function for adding crash keys.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing AddCrashKeyCallback = void (*)(CrashKeyId id, const std::string& value);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"BeforeCallEnteredCallback\",\n                \"about\": \"Callback function called before a script is entered.\",\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing BeforeCallEnteredCallback = void (*)(Isolate*);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"CallCompletedCallback\",\n                \"about\": \"Callback function called after a script has completed.\",\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing CallCompletedCallback = void (*)(Isolate*);\n        ]]></code>\n    </typedef>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"ModifyCodeGenerationFromStringsResult\",\n                \"about\": \"Structure containing the result of modifying code generation from strings.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"codegen_allowed\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether code generation is allowed.\"\n                    },\n                    {\n                        \"name\": \"modified_source\",\n                        \"type\": \"MaybeLocal<String>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The modified source string, if present.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"String\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct ModifyCodeGenerationFromStringsResult {\n  // If true, proceed with the codegen algorithm. Otherwise, block it.\n  bool codegen_allowed = false;\n  // Overwrite the original source with this string, if present.\n  // Use the original source if empty.\n  // This field is considered only if codegen_allowed is true.\n  MaybeLocal<String> modified_source;\n};\n        ]]></code>\n    </struct>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"ModifyCodeGenerationFromStringsCallback\",\n                \"about\": \"Callback to check if codegen is allowed from a source object.\",\n                \"dependencies\": [\n                    \"Context\",\n                    \"Value\",\n                    \"ModifyCodeGenerationFromStringsResult\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing ModifyCodeGenerationFromStringsCallback =\n    ModifyCodeGenerationFromStringsResult (*)(Local<Context> context,\n                                              Local<Value> source);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"ModifyCodeGenerationFromStringsCallback2\",\n                \"about\": \"Callback to check if codegen is allowed from a source object. (Alternative signature)\",\n                \"dependencies\": [\n                    \"Context\",\n                    \"Value\",\n                    \"ModifyCodeGenerationFromStringsResult\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing ModifyCodeGenerationFromStringsCallback2 =\n    ModifyCodeGenerationFromStringsResult (*)(Local<Context> context,\n                                              Local<Value> source,\n                                              bool is_code_like);\n        ]]></code>\n    </typedef>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"AccessType\",\n                \"about\": \"Enum specifying the type of access check.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum AccessType {\n  ACCESS_GET,\n  ACCESS_SET,\n  ACCESS_HAS,\n  ACCESS_DELETE,\n  ACCESS_KEYS\n};\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"FailedAccessCheckCallback\",\n                \"about\": \"Callback function for failed access checks.\",\n                \"dependencies\": [\n                    \"Object\",\n                    \"AccessType\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing FailedAccessCheckCallback = void (*)(Local<Object> target,\n                                           AccessType type, Local<Value> data);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"ExtensionCallback\",\n                \"about\": \"Callback function for extensions.\",\n                \"dependencies\": [\n                    \"FunctionCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing ExtensionCallback = bool (*)(const FunctionCallbackInfo<Value>&);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"AllowWasmCodeGenerationCallback\",\n                \"about\": \"Callback function to determine if Wasm code generation is allowed.\",\n                \"dependencies\": [\n                    \"Context\",\n                    \"String\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing AllowWasmCodeGenerationCallback = bool (*)(Local<Context> context,\n                                                 Local<String> source);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"ApiImplementationCallback\",\n                \"about\": \"Callback function for APIs implemented by the embedder (e.g., WebAssembly.compileStreaming).\",\n                \"dependencies\": [\n                    \"FunctionCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing ApiImplementationCallback = void (*)(const FunctionCallbackInfo<Value>&);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"WasmStreamingCallback\",\n                \"about\": \"Callback function for WebAssembly.compileStreaming.\",\n                \"dependencies\": [\n                    \"FunctionCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing WasmStreamingCallback = void (*)(const FunctionCallbackInfo<Value>&);\n        ]]></code>\n    </typedef>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"WasmAsyncSuccess\",\n                \"about\": \"Enum for WebAssembly async success/fail.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class WasmAsyncSuccess { kSuccess, kFail };\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"WasmAsyncResolvePromiseCallback\",\n                \"about\": \"Callback function called when async WebAssembly operations finish.\",\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Context\",\n                    \"Promise::Resolver\",\n                    \"Value\",\n                    \"WasmAsyncSuccess\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing WasmAsyncResolvePromiseCallback = void (*)(\n    Isolate* isolate, Local<Context> context, Local<Promise::Resolver> resolver,\n    Local<Value> result, WasmAsyncSuccess success);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"WasmLoadSourceMapCallback\",\n                \"about\": \"Callback for loading source map file for Wasm profiling support.\",\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"String\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing WasmLoadSourceMapCallback = Local<String> (*)(Isolate* isolate,\n                                                    const char* name);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"WasmImportedStringsEnabledCallback\",\n                \"about\": \"Callback for checking if WebAssembly imported strings are enabled\",\n                \"dependencies\": [\n                    \"Context\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing WasmImportedStringsEnabledCallback = bool (*)(Local<Context> context);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"SharedArrayBufferConstructorEnabledCallback\",\n                \"about\": \"Callback for checking if the SharedArrayBuffer constructor is enabled\",\n                \"dependencies\": [\n                    \"Context\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing SharedArrayBufferConstructorEnabledCallback =\n    bool (*)(Local<Context> context);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"JavaScriptCompileHintsMagicEnabledCallback\",\n                \"about\": \"Callback for checking if the compile hints magic comments are enabled\",\n                \"dependencies\": [\n                    \"Context\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing JavaScriptCompileHintsMagicEnabledCallback =\n    bool (*)(Local<Context> context);\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"WasmJSPIEnabledCallback\",\n                \"about\": \"Callback for checking if WebAssembly JSPI is enabled\",\n                \"dependencies\": [\n                    \"Context\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing WasmJSPIEnabledCallback = bool (*)(Local<Context> context);\n        ]]></code>\n    </typedef>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"ModuleImportPhase\",\n                \"about\": \"Import phases in import requests.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class ModuleImportPhase {\n  kSource,\n  kEvaluation,\n};\n        ]]></code>\n    </enum>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"HostImportModuleDynamicallyCallback\",\n                \"about\": \"Callback function called when the embedder needs to load a module (dynamic import).\",\n                \"dependencies\": [\n                    \"Context\",\n                    \"Data\",\n                    \"Value\",\n                    \"String\",\n                    \"FixedArray\",\n                    \"Promise\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing HostImportModuleDynamicallyCallback = MaybeLocal<Promise> (*)(\n    Local<Context> context, Local<Data> host_defined_options,\n    Local<Value> resource_name, Local<String> specifier,\n    Local<FixedArray> import_attributes);\n        ]]></code>\n    </typedef>\n\n   <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"HostImportModuleWithPhaseDynamicallyCallback\",\n                \"about\": \"Callback function called when the embedder needs to load a module with a specific phase (dynamic import).\",\n                \"dependencies\": [\n                    \"Context\",\n                    \"Data\",\n"
}