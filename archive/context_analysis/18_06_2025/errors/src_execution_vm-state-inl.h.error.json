{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/vm-state-inl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 185, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/vm-state-inl.h\",\n        \"file_name\": \"vm-state-inl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines inline implementations for VM state management classes, including VMState and ExternalCallbackScope, used for tracking and managing the VM's execution state within the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for isolate management, simulator support, VM state definitions, logging, and tracing.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/isolate-inl.h\"\n#include \"src/execution/simulator.h\"\n#include \"src/execution/vm-state.h\"\n#include \"src/logging/log.h\"\n#include \"src/tracing/trace-event.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"StateToString\",\n            \"about\": \"Converts a StateTag enum value to a human-readable string representation.\",\n            \"logic\": \"Uses a switch statement to map each StateTag value to its corresponding string. This function is essential for debugging and logging purposes, providing a textual description of the current VM state.\",\n            \"parameters\": [\n                {\n                    \"name\": \"state\",\n                    \"type\": \"StateTag\",\n                    \"purpose\": \"The StateTag enum value to convert to a string.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const char*\",\n                \"description\": \"A pointer to a null-terminated string representing the state.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ninline const char* StateToString(StateTag state) {\n  switch (state) {\n    case JS:\n      return \"JS\";\n    case GC:\n      return \"GC\";\n    case PARSER:\n      return \"PARSER\";\n    case BYTECODE_COMPILER:\n      return \"BYTECODE_COMPILER\";\n    case COMPILER:\n      return \"COMPILER\";\n    case OTHER:\n      return \"OTHER\";\n    case EXTERNAL:\n      return \"EXTERNAL\";\n    case ATOMICS_WAIT:\n      return \"ATOMICS_WAIT\";\n    case IDLE:\n      return \"IDLE\";\n    case LOGGING:\n      return \"LOGGING\";\n  }\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"VMState\",\n            \"about\": \"Represents a VM state with a specific tag. Pushes and pops the state from the isolate's current VM state stack.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the isolate associated with this VM state.\"\n                },\n                {\n                    \"name\": \"previous_tag_\",\n                    \"type\": \"StateTag\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The VM state tag that was active before this state was pushed.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"StateTag\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <StateTag Tag>\nclass VMState {\n public:\n  VMState(Isolate* isolate)\n      : isolate_(isolate), previous_tag_(isolate->current_vm_state()) {\n    isolate_->set_current_vm_state(Tag);\n  }\n\n  ~VMState() {\n    isolate_->set_current_vm_state(previous_tag_);\n  }\n\n private:\n  Isolate* isolate_;\n  StateTag previous_tag_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ExternalCallbackScope\",\n            \"about\": \"Represents the scope of an external callback executed by the V8 engine.  Manages VM state, exception context, and performance counters during the execution of external callbacks.\",\n            \"attributes\": [\n                {\n                    \"name\": \"callback_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The address of the external callback function.\"\n                },\n                {\n                    \"name\": \"callback_info_\",\n                    \"type\": \"const void*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Optional data passed to the callback function.\"\n                },\n                {\n                    \"name\": \"previous_scope_\",\n                    \"type\": \"ExternalCallbackScope*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the previous ExternalCallbackScope in the stack.\"\n                },\n                {\n                    \"name\": \"vm_state_\",\n                    \"type\": \"VMState<EXTERNAL>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"VMState object to manage the EXTERNAL state.\"\n                },\n                {\n                    \"name\": \"exception_context_\",\n                    \"type\": \"v8::ExceptionContext\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Context associated with any exceptions thrown during the callback.\"\n                },\n                {\n                    \"name\": \"pause_timed_histogram_scope_\",\n                    \"type\": \"PauseTimedHistogramScope\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Scope for tracking the execution time of the callback.\"\n                },\n                {\n                    \"name\": \"js_stack_comparable_address_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Address used for comparing JS stack frames, used with simulators or sanitizers.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Address\",\n                \"v8::ExceptionContext\",\n                \"VMState\",\n                \"Counters\",\n                \"TRACE_EVENT_BEGIN0\",\n                \"TRACE_EVENT_END0\",\n                \"SimulatorStack\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ExternalCallbackScope {\n public:\n  ExternalCallbackScope(\n      Isolate* isolate, Address callback, v8::ExceptionContext exception_context,\n      const void* callback_info)\n      : callback_(callback),\n        callback_info_(callback_info),\n        previous_scope_(isolate->external_callback_scope()),\n        vm_state_(isolate),\n        exception_context_(exception_context),\n        pause_timed_histogram_scope_(isolate->counters()->execute()) {\n#if USE_SIMULATOR || V8_USE_ADDRESS_SANITIZER || V8_USE_SAFE_STACK\n    js_stack_comparable_address_ =\n        i::SimulatorStack::RegisterJSStackComparableAddress(isolate);\n#endif\n    vm_state_.isolate_->set_external_callback_scope(this);\n#ifdef V8_RUNTIME_CALL_STATS\n    TRACE_EVENT_BEGIN0(TRACE_DISABLED_BY_DEFAULT(\"v8.runtime\"),\n                       \"V8.ExternalCallback\");\n#endif\n    // The external callback might be called via different code paths and on some\n    // of them it's not guaranteed that the topmost_script_having_context value\n    // is still valid (in particular, when the callback call is initiated by\n    // embedder via V8 Api). So, clear it to ensure correctness of\n    // Isolate::GetIncumbentContext().\n    vm_state_.isolate_->clear_topmost_script_having_context();\n  }\n\n  ~ExternalCallbackScope() {\n    vm_state_.isolate_->set_external_callback_scope(previous_scope_);\n    // JS code might have been executed by the callback and it could have changed\n    // {topmost_script_having_context}, clear it to ensure correctness of\n    // Isolate::GetIncumbentContext() in case it'll be called after returning\n    // from the callback.\n    vm_state_.isolate_->clear_topmost_script_having_context();\n#ifdef V8_RUNTIME_CALL_STATS\n    TRACE_EVENT_END0(TRACE_DISABLED_BY_DEFAULT(\"v8.runtime\"),\n                     \"V8.ExternalCallback\");\n#endif\n#if USE_SIMULATOR || V8_USE_ADDRESS_SANITIZER || V8_USE_SAFE_STACK\n    i::SimulatorStack::UnregisterJSStackComparableAddress(vm_state_.isolate_);\n#endif\n  }\n\n  Address JSStackComparableAddress() {\n#if USE_SIMULATOR || V8_USE_ADDRESS_SANITIZER || V8_USE_SAFE_STACK\n    return js_stack_comparable_address_;\n#else\n    return reinterpret_cast<Address>(this);\n#endif\n  }\n\n private:\n  Address callback_;\n  const void* callback_info_;\n  ExternalCallbackScope* previous_scope_;\n  VMState<EXTERNAL> vm_state_;\n  v8::ExceptionContext exception_context_;\n  PauseTimedHistogramScope pause_timed_histogram_scope_;\n#if USE_SIMULATOR || V8_USE_ADDRESS_SANITIZER || V8_USE_SAFE_STACK\n  Address js_stack_comparable_address_;\n#endif\n};\n        ]]></code>\n    </class>\n</file>\n```"
}