{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/csa-load-elimination.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/csa-load-elimination.cc\",\n        \"file_name\": \"csa-load-elimination.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements CSA (CodeStubAssembler) load elimination optimization for the V8 compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for compiler, node manipulation, and operator definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/csa-load-elimination.h\"\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CsaLoadElimination\",\n            \"about\": \"Performs load elimination based on CodeStubAssembler (CSA) information.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"AbstractState\",\n                \"HalfState\",\n                \"Node\",\n                \"Reduction\",\n                \"ObjectAccess\",\n                \"Zone\",\n                \"NodeProperties\",\n                \"MachineRepresentation\",\n                \"MachineType\",\n                \"IntPtrMatcher\",\n                \"ExternalReferenceMatcher\",\n                \"CommonOperatorBuilder\",\n                \"MachineOperatorBuilder\",\n                \"TFGraph\",\n                \"Isolate\",\n                \"FieldInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass CsaLoadElimination {\n public:\n  CsaLoadElimination(Editor* editor, Zone* zone, JSGraph* jsgraph)\n      : editor_(editor),\n        zone_(zone),\n        jsgraph_(jsgraph),\n        node_states_(zone),\n        empty_(zone) {}\n\n  Reduction Reduce(Node* node);\n\n private:\n  struct FieldInfo {\n    Node* value = nullptr;\n    MachineRepresentation representation = MachineRepresentation::kNone;\n\n    FieldInfo() = default;\n    FieldInfo(Node* value, MachineRepresentation representation)\n        : value(value), representation(representation) {}\n\n    bool IsEmpty() const { return value == nullptr; }\n\n    bool operator!=(const FieldInfo& other) const {\n      return value != other.value || representation != other.representation;\n    }\n\n    bool operator==(const FieldInfo& other) const { return !(*this != other); }\n  };\n\n  class HalfState {\n   public:\n    using InnerMap = ZoneMap<Node*, FieldInfo>;\n    using ConstantOffsetInfos = ZoneMap<uint32_t, InnerMap>;\n    using UnknownOffsetInfos = ZoneMap<Node*, InnerMap>;\n    using OuterMap = ZoneMap<uint32_t, InnerMap>;\n\n    HalfState() = default;\n    explicit HalfState(Zone* zone) : zone_(zone) {}\n    HalfState(const HalfState& that)\n        : zone_(that.zone_),\n          fresh_entries_(that.fresh_entries_, zone_),\n          constant_entries_(that.constant_entries_, zone_),\n          arbitrary_entries_(that.arbitrary_entries_, zone_),\n          fresh_unknown_entries_(that.fresh_unknown_entries_, zone_),\n          constant_unknown_entries_(that.constant_unknown_entries_, zone_),\n          arbitrary_unknown_entries_(that.arbitrary_unknown_entries_, zone_) {}\n\n    HalfState const* KillField(Node* object, Node* offset,\n                               MachineRepresentation repr) const;\n    HalfState const* AddField(Node* object, Node* offset, Node* value,\n                               MachineRepresentation repr) const;\n    FieldInfo Lookup(Node* object, Node* offset) const;\n\n    void Print() const;\n\n   private:\n    static void IntersectWith(ConstantOffsetInfos& to,\n                              const ConstantOffsetInfos& from);\n    static void IntersectWith(UnknownOffsetInfos& to,\n                              const UnknownOffsetInfos& from);\n    template <typename OuterKey>\n    static void IntersectWith(OuterMap<OuterKey>& to,\n                              const OuterMap<OuterKey>& from);\n\n    void IntersectWith(HalfState const* that);\n\n    static void KillOffset(ConstantOffsetInfos& infos, uint32_t offset,\n                           MachineRepresentation repr, Zone* zone);\n\n    void KillOffsetInFresh(Node* const object, uint32_t offset,\n                           MachineRepresentation repr);\n\n    Zone* zone_ = nullptr;\n\n    // {fresh_entries_} maps offsets to {object} -> {value} for\n    // allocations done in the current function. This is used for very precise\n    // reasoning about memory. If an object is allocated in the same function as\n    // the load/store we can track all the offsets of the object precisely and\n    // perform load elimination.\n    ConstantOffsetInfos fresh_entries_{zone_};\n    // {constant_entries_} maps offsets to {object} -> {value} for\n    // constant objects (or objects that are transitively loaded from constants).\n    // This is used for field access of constant objects.\n    ConstantOffsetInfos constant_entries_{zone_};\n    // {arbitrary_entries_} maps offsets to {object} -> {value} for\n    // arbitrary objects (objects that are parameters, or loaded from\n    // parameters). The precision here is lower as we do not know which object\n    // we are accessing exactly.\n    ConstantOffsetInfos arbitrary_entries_{zone_};\n    // Similarly to the above, but for unknown offsets.\n    UnknownOffsetInfos fresh_unknown_entries_{zone_};\n    UnknownOffsetInfos constant_unknown_entries_{zone_};\n    UnknownOffsetInfos arbitrary_unknown_entries_{zone_};\n\n    static void Print(const ConstantOffsetInfos& infos);\n    static void Print(const UnknownOffsetInfos& infos);\n\n    template <typename OuterKey>\n    static void Update(ZoneMap<OuterKey, InnerMap>& map, OuterKey outer_key,\n                       Node* inner_key, FieldInfo info) {\n      InnerMap inner_map = map.Get(outer_key);\n      inner_map.Set(inner_key, info);\n      map.Set(outer_key, inner_map);\n    }\n  };\n\n  class AbstractState {\n   public:\n    AbstractState() = default;\n    AbstractState(Zone* zone) : mutable_state(zone), immutable_state(zone) {}\n    AbstractState(HalfState const& mutable_state,\n                  HalfState const& immutable_state)\n        : mutable_state(mutable_state), immutable_state(immutable_state) {}\n    AbstractState(const AbstractState& that)\n        : mutable_state(that.mutable_state),\n          immutable_state(that.immutable_state) {}\n\n    void IntersectWith(AbstractState const* that) {\n      mutable_state.IntersectWith(&that->mutable_state);\n      immutable_state.IntersectWith(&that->immutable_state);\n    }\n\n    bool Equals(AbstractState const* that) const {\n      return mutable_state.Equals(&that->mutable_state) &&\n             immutable_state.Equals(&that->immutable_state);\n    }\n\n    void Print() const {\n      PrintF(\"  mutable_state:\\n\");\n      mutable_state.Print();\n      PrintF(\"  immutable_state:\\n\");\n      immutable_state.Print();\n    }\n\n    HalfState mutable_state;\n    HalfState immutable_state;\n\n   private:\n    bool Equals(HalfState const* that) const { return &mutable_state == that; }\n  };\n\n  Reduction ReduceLoadFromObject(Node* node, ObjectAccess const& access);\n  Reduction ReduceStoreToObject(Node* node, ObjectAccess const& access);\n  Reduction ReduceEffectPhi(Node* node);\n  Reduction ReduceStart(Node* node);\n  Reduction ReduceCall(Node* node);\n  Reduction ReduceOtherNode(Node* node);\n  Reduction UpdateState(Node* node, AbstractState const* state);\n  Reduction PropagateInputState(Node* node);\n  AbstractState const* ComputeLoopState(Node* node,\n                                        AbstractState const* state) const;\n  Node* TruncateAndExtend(Node* node, MachineRepresentation from,\n                          MachineType to);\n  Reduction AssertUnreachable(Node* node);\n\n  CommonOperatorBuilder* common() const;\n  MachineOperatorBuilder* machine() const;\n  TFGraph* graph() const;\n  Isolate* isolate() const;\n\n  AbstractState const* empty_state() { return &empty_; }\n\n  Editor* editor() const { return editor_; }\n  void Revisit(Node* node) { editor()->Revisit(node); }\n  Reduction Replace(Node* node) { return editor()->Replace(node); }\n  void ReplaceWithValue(Node* node, Node* value, Node* effect) {\n    editor()->ReplaceWithValue(node, value, effect);\n  }\n  void ReplaceWithValue(Node* node, Node* value, Node* effect, Node* control) {\n    editor()->ReplaceWithValue(node, value, effect, control);\n  }\n  Reduction NoChange() { return Reduction::NoChange(); }\n  Reduction Changed(Node* node) { return Reduction::Changed(node); }\n\n  Zone* zone() const { return zone_; }\n  JSGraph* jsgraph() const { return jsgraph_; }\n\n  ZoneMap<Node*, AbstractState const*> node_states_;\n\n  Editor* editor_;\n  Zone* zone_;\n  JSGraph* jsgraph_;\n  AbstractState empty_;\n};\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Reduces a node based on its opcode, attempting to perform load elimination.\",\n            \"logic\": \"This function acts as the main dispatcher for the load elimination pass. It switches on the opcode of the input node and calls the appropriate handler function.  It also includes debug tracing if the `v8_flags.trace_turbo_load_elimination` flag is set. The function handles various opcodes including `kLoadFromObject`, `kStoreToObject`, `kEffectPhi`, and others.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A reduction indicating whether the node was changed.\"\n            },\n            \"dependencies\": [\n                \"ReduceLoadFromObject\",\n                \"ReduceStoreToObject\",\n                \"ReduceCall\",\n                \"ReduceEffectPhi\",\n                \"ReduceStart\",\n                \"ReduceOtherNode\",\n                \"ObjectAccessOf\",\n                \"NodeProperties\",\n                \"PrintF\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction CsaLoadElimination::Reduce(Node* node) {\n  if (v8_flags.trace_turbo_load_elimination) {\n    if (node->op()->EffectInputCount() > 0) {\n      PrintF(\" visit #%d:%s\", node->id(), node->op()->mnemonic());\n      if (node->op()->ValueInputCount() > 0) {\n        PrintF(\"(\");\n        for (int i = 0; i < node->op()->ValueInputCount(); ++i) {\n          if (i > 0) PrintF(\", \");\n          Node* const value = NodeProperties::GetValueInput(node, i);\n          PrintF(\"#%d:%s\", value->id(), value->op()->mnemonic());\n        }\n        PrintF(\")\");\n      }\n      PrintF(\"\\n\");\n      for (int i = 0; i < node->op()->EffectInputCount(); ++i) {\n        Node* const effect = NodeProperties::GetEffectInput(node, i);\n        if (AbstractState const* const state = node_states_.Get(effect)) {\n          PrintF(\"  state[%i]: #%d:%s\\n\", i, effect->id(),\n                 effect->op()->mnemonic());\n          state->mutable_state.Print();\n          state->immutable_state.Print();\n        } else {\n          PrintF(\"  no state[%i]: #%d:%s\\n\", i, effect->id(),\n                 effect->op()->mnemonic());\n        }\n      }\n    }\n  }\n  switch (node->opcode()) {\n    case IrOpcode::kLoadFromObject:\n    case IrOpcode::kLoadImmutableFromObject:\n      return ReduceLoadFromObject(node, ObjectAccessOf(node->op()));\n    case IrOpcode::kStoreToObject:\n    case IrOpcode::kInitializeImmutableInObject:\n      return ReduceStoreToObject(node, ObjectAccessOf(node->op()));\n    case IrOpcode::kDebugBreak:\n    case IrOpcode::kAbortCSADcheck:\n      // Avoid changing optimizations in the presence of debug instructions.\n      return PropagateInputState(node);\n    case IrOpcode::kCall:\n      return ReduceCall(node);\n    case IrOpcode::kEffectPhi:\n      return ReduceEffectPhi(node);\n    case IrOpcode::kDead:\n      return NoChange();\n    case IrOpcode::kStart:\n      return ReduceStart(node);\n    default:\n      return ReduceOtherNode(node);\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"CsaLoadEliminationHelpers\",\n            \"purpose\": \"Provides helper functions for CsaLoadElimination.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace CsaLoadEliminationHelpers {\n\nbool Subsumes(MachineRepresentation from, MachineRepresentation to) {\n  if (from == to) return true;\n  if (IsAnyTagged(from)) return IsAnyTagged(to);\n  if (IsIntegral(from)) {\n    return IsIntegral(to) && ElementSizeInBytes(from) >= ElementSizeInBytes(to);\n  }\n  return false;\n}\n\nbool IsConstantObject(Node* object) {\n  return object->opcode() == IrOpcode::kParameter ||\n         object->opcode() == IrOpcode::kLoadImmutable ||\n         NodeProperties::IsConstant(object);\n}\n\nbool IsFreshObject(Node* object) {\n  return object->opcode() == IrOpcode::kAllocate ||\n         object->opcode() == IrOpcode::kAllocateRaw;\n}\n\n}  // namespace CsaLoadEliminationHelpers\n        ]]></code>\n    </namespace>\n   <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"Helpers\",\n            \"purpose\": \"Alias for CsaLoadEliminationHelpers.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace Helpers = CsaLoadEliminationHelpers;\n        ]]></code>\n    </namespace>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IntersectWith\",\n            \"parent\": \"CsaLoadElimination::HalfState\",\n            \"about\": \"Intersects two OuterMaps, updating the 'to' map with the intersection of values from 'from'.\",\n            \"logic\": \"This template function iterates through the 'to' map and checks if each entry exists in the 'from' map with the same value. If not, the entry in the 'to' map is set to an empty FieldInfo.\",\n            \"parameters\": [\n                {\n                    \"name\": \"to\",\n                    \"type\": \"OuterMap<OuterKey>&\",\n                    \"purpose\": \"The map to be updated with the intersection.\"\n                },\n                {\n                    \"name\": \"from\",\n                    \"type\": \"const OuterMap<OuterKey>&\",\n                    \"purpose\": \"The map to intersect with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"OuterMap\",\n                \"InnerMap\",\n                \"FieldInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename OuterKey>\nvoid CsaLoadElimination::HalfState::IntersectWith(\n    OuterMap<OuterKey>& to, const OuterMap<OuterKey>& from) {\n  FieldInfo empty_info;\n  for (const std::pair<OuterKey, InnerMap>& to_map : to) {\n    InnerMap to_map_copy(to_map.second);\n    OuterKey key = to_map.first;\n    InnerMap current_map = from.Get(key);\n    for (std::pair<Node*, FieldInfo> info : to_map.second) {\n      if (current_map.Get(info.first) != info.second) {\n        to_map_copy.Set(info.first, empty_info);\n      }\n    }\n    to.Set(key, to_map_copy);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IntersectWith\",\n            \"parent\": \"CsaLoadElimination::HalfState\",\n            \"about\": \"Intersects the current HalfState with another HalfState.\",\n            \"logic\": \"Calls the template IntersectWith function for all the different maps within the HalfState.\",\n            \"parameters\": [\n                {\n                    \"name\": \"that\",\n                    \"type\": \"HalfState const*\",\n                    \"purpose\": \"The HalfState to intersect with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"IntersectWith\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CsaLoadElimination::HalfState::IntersectWith(HalfState const* that) {\n  IntersectWith(fresh_entries_, that->fresh_entries_);\n  IntersectWith(constant_entries_, that->constant_entries_);\n  IntersectWith(arbitrary_entries_, that->arbitrary_entries_);\n  IntersectWith(fresh_unknown_entries_, that->fresh_unknown_entries_);\n  IntersectWith(constant_unknown_entries_, that->constant_unknown_entries_);\n  IntersectWith(arbitrary_unknown_entries_, that->arbitrary_unknown_entries_);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"KillField\",\n            \"parent\": \"CsaLoadElimination::HalfState\",\n            \"about\": \"Kills (invalidates) a field in the HalfState, removing any previously known value.\",\n            \"logic\": \"Creates a new HalfState with the specified field removed. It handles different cases based on whether the object is fresh, constant, or arbitrary, and whether the offset is known or unknown.  It ensures that any potential aliasing with other fields is also handled by removing overlapping entries.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The object containing the field.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The offset of the field.\"\n                },\n                {\n                    \"name\": \"repr\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The machine representation of the field.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CsaLoadElimination::HalfState const*\",\n                \"description\": \"A new HalfState with the field killed.\"\n            },\n            \"dependencies\": [\n                \"Helpers::IsFreshObject\",\n                \"Helpers::IsConstantObject\",\n                \"IntPtrMatcher\",\n                \"KillOffset\",\n                \"KillOffsetInFresh\",\n                \"ElementSizeInBytes\",\n                \"kMaximumReprSizeInBytes\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCsaLoadElimination::HalfState const* CsaLoadElimination::HalfState::KillField(\n    Node* object, Node* offset, MachineRepresentation repr) const {\n  HalfState* result = zone_->New<HalfState>(*this);\n  UnknownOffsetInfos empty_unknown(zone_, InnerMap(zone_));\n  IntPtrMatcher m(offset);\n  if (m.HasResolvedValue()) {\n    uint32_t num_offset = static_cast<uint32_t>(m.ResolvedValue());\n    if (Helpers::IsFreshObject(object)) {\n      // May alias with:\n      // - The same object/offset\n      // - Arbitrary objects with the same offset\n      // - The same object, unkwown offset\n      // - Arbitrary objects with unkwown offset\n      result->KillOffsetInFresh(object, num_offset, repr);\n      KillOffset(result->arbitrary_entries_, num_offset, repr, zone_);\n      result->fresh_unknown_entries_.Set(object, InnerMap(zone_));\n      result->arbitrary_unknown_entries_ = empty_unknown;\n    } else if (Helpers::IsConstantObject(object)) {\n      // May alias with:\n      // - Constant/arbitrary objects with the same offset\n      // - Constant/arbitrary objects with unkwown offset\n      KillOffset(result->constant_entries_, num_offset, repr, zone_);\n      KillOffset(result->arbitrary_entries_, num_offset, repr, zone_);\n      result->constant_unknown_entries_ = empty_unknown;\n      result->arbitrary_unknown_entries_ = empty_unknown;\n    } else {\n      // May alias with:\n      // - Any object with the same or unknown offset\n      KillOffset(result->fresh_entries_, num_offset, repr, zone_);\n      KillOffset(result->constant_entries_, num_offset, repr, zone_);\n      KillOffset(result->arbitrary_entries_, num_offset, repr, zone_);\n      result->fresh_unknown_entries_ = empty_unknown;\n      result->constant_unknown_entries_ = empty_unknown;\n      result->arbitrary_unknown_entries_ = empty_unknown;\n    }\n  } else {\n    ConstantOffsetInfos empty_constant(zone_, InnerMap(zone_));\n    if (Helpers::IsFreshObject(object)) {\n      // May alias with:\n      // - The same object with any known/unknown offset\n      // - Arbitrary objects with any known/unknown offset\n      for (auto map : result->fresh_entries_) {\n        // TODO(manoskouk): Consider adding a map from fresh objects to offsets\n        // to implement this efficiently.\n        InnerMap map_copy(map.second);\n        map_copy.Set(object, FieldInfo());\n        result->fresh_entries_.Set(map.first, map_copy);\n      }\n      result->fresh_unknown_entries_.Set(object, InnerMap(zone_));\n      result->arbitrary_entries_ = empty_constant;\n      result->arbitrary_unknown_entries_ = empty_unknown;\n    } else if (Helpers::IsConstantObject(object)) {\n      // May alias with:\n      // - Constant/arbitrary objects with the any known/unknown offset\n      result->constant_entries_ = empty_constant;\n      result->constant_unknown_entries_ = empty_unknown;\n      result->arbitrary_entries_ = empty_constant;\n      result->arbitrary_unknown_entries_ = empty_unknown;\n    } else {\n      // May alias with anything. Clear the state.\n      return zone_->New<HalfState>(zone_);\n    }\n  }\n\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddField\",\n            \"parent\": \"CsaLoadElimination::HalfState\",\n            \"about\": \"Adds a field to the HalfState, recording its value and representation.\",\n            \"logic\": \"Creates a new HalfState with the specified field added.  It handles different cases based on whether the object is fresh, constant, or arbitrary, and whether the offset is known or unknown. The `Update` function is then called to update the corresponding inner map with the new field information.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The object containing the field.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The offset of the field.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The value of the field.\"\n                },\n                {\n                    \"name\": \"repr\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The machine representation of the field.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CsaLoadElimination::HalfState const*\",\n                \"description\": \"A new HalfState with the field added.\"\n            },\n            \"dependencies\": [\n                \"Helpers::IsFreshObject\",\n                \"Helpers::IsConstantObject\",\n                \"IntPtrMatcher\",\n                \"Update\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCsaLoadElimination::HalfState const* CsaLoadElimination::HalfState::AddField(\n    Node* object, Node* offset, Node* value, MachineRepresentation repr) const {\n  HalfState* new_state = zone_->New<HalfState>(*this);\n  IntPtrMatcher m(offset);\n  if (m.HasResolvedValue()) {\n    uint32_t offset_num = static_cast<uint32_t>(m.ResolvedValue());\n    ConstantOffsetInfos& infos = Helpers::IsFreshObject(object)\n                                     ? new_state->fresh_entries_\n                                     : Helpers::IsConstantObject(object)\n                                           ? new_state->constant_entries_\n                                           : new_state->arbitrary_entries_;\n    Update(infos, offset_num, object, FieldInfo(value, repr));\n  } else {\n    UnknownOffsetInfos& infos =\n        Helpers::IsFreshObject(object)\n            ? new_state->fresh_unknown_entries_\n            : Helpers::IsConstantObject(object)\n                  ? new_state->constant_unknown_entries_\n                  : new_state->arbitrary_unknown_entries_;\n    Update(infos, object, offset, FieldInfo(value, repr));\n  }\n  return new_state;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Lookup\",\n            \"parent\": \"CsaLoadElimination::HalfState\",\n            \"about\": \"Looks up a field in the HalfState, returning its value and representation.\",\n            \"logic\": \"Looks up the field's information based on the object and offset. It checks if the object is fresh, constant, or arbitrary, and whether the offset is known or unknown. Then it retrieves the corresponding `FieldInfo` from the appropriate data structure.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The object containing the field.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The offset of the field.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CsaLoadElimination::FieldInfo\",\n                \"description\": \"The FieldInfo for the field, or an empty FieldInfo if the field is not found.\"\n            },\n            \"dependencies\": [\n                \"Helpers::IsFreshObject\",\n                \"Helpers::IsConstantObject\",\n                \"IntPtrMatcher\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCsaLoadElimination::FieldInfo CsaLoadElimination::HalfState::Lookup(\n    Node* object, Node* offset) const {\n  IntPtrMatcher m(offset);\n  if (m.HasResolvedValue()) {\n    uint32_t num_offset = static_cast<uint32_t>(m.ResolvedValue());\n    const ConstantOffsetInfos& infos = Helpers::IsFreshObject(object)\n                                           ? fresh_entries_\n                                           : Helpers::IsConstantObject(object)\n                                                 ? constant_entries_\n                                                 : arbitrary_entries_;\n    return infos.Get(num_offset).Get(object);\n  } else {\n    const UnknownOffsetInfos& infos = Helpers::IsFreshObject(object)\n                                          ? fresh_unknown_entries_\n                                          : Helpers::IsConstantObject(object)\n                                                ? constant_unknown_entries_\n                                                : arbitrary_unknown_entries_;\n    return infos.Get(object).Get(offset);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"KillOffset\",\n            \"parent\": \"CsaLoadElimination::HalfState\",\n            \"about\": \"Kills all elements in {infos} that overlap with an element with {offset} and size {ElementSizeInBytes(repr)}.\",\n            \"logic\": \"This function clears entries in the `ConstantOffsetInfos` map that overlap with the specified offset and size.  It iterates through the relevant range of offsets and clears the corresponding inner maps.  It also handles overlapping entries by resetting elements that are large enough to overlap with the given offset.\",\n            \"parameters\": [\n                {\n                    \"name\": \"infos\",\n                    \"type\": \"ConstantOffsetInfos&\",\n                    \"purpose\": \"The ConstantOffsetInfos map to update.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"The offset to kill.\"\n                },\n                {\n                    \"name\": \"repr\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The machine representation of the field.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ElementSizeInBytes\",\n                \"kMaximumReprSizeInBytes\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CsaLoadElimination::HalfState::KillOffset(ConstantOffsetInfos& infos,\n                                               uint32_t offset,\n                                               MachineRepresentation repr,\n                                               Zone* zone) {\n  // All elements in the range [{offset}, {offset + ElementSizeInBytes(repr)})\n  // are in the killed range. We do not need to traverse the inner maps, we can\n  // just clear them.\n  for (int i = 0; i < ElementSizeInBytes(repr); i++) {\n    infos.Set(offset + i, InnerMap(zone));\n  }\n\n  // Now we have to remove all elements in earlier offsets that overlap with an\n  // element in {offset}.\n  // The earliest offset that may overlap with {offset} is\n  // {kMaximumReprSizeInBytes - 1} before.\n  uint32_t initial_offset = offset >= kMaximumReprSizeInBytes - 1\n                                ? offset - (kMaximumReprSizeInBytes - 1)\n                                : 0;\n  // For all offsets from {initial_offset} to {offset}, we traverse the\n  // respective inner map, and reset all elements that are large enough to\n  // overlap with {offset}.\n  for (uint32_t i = initial_offset; i < offset; i++) {\n    InnerMap map_copy(infos.Get(i));\n    for (const std::pair<Node*, FieldInfo> info : infos.Get(i)) {\n      if (info.second.representation != MachineRepresentation::kNone &&\n          ElementSizeInBytes(info.second.representation) >\n              static_cast<int>(offset - i)) {\n        map_copy.Set(info.first, {});\n      }\n    }\n    infos.Set(i, map_copy);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"KillOffsetInFresh\",\n            \"parent\": \"CsaLoadElimination::HalfState\",\n            \"about\": \"Kills the offset in a fresh object, handling potential overlaps.\",\n            \"logic\": \"Iterates through the range of offsets covered by the given offset and representation, updating the `fresh_entries_` map to remove the value associated with the object. It also handles potential overlaps with earlier offsets by checking the size of the existing `FieldInfo` and clearing the entry if it overlaps.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node* const\",\n                    \"purpose\": \"The fresh object.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"The offset to kill.\"\n                },\n                {\n                    \"name\": \"repr\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The machine representation of the field.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Update\",\n                \"ElementSizeInBytes\",\n                \"kMaximumReprSizeInBytes\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CsaLoadElimination::HalfState::KillOffsetInFresh(\n    Node* const object, uint32_t offset, MachineRepresentation repr) {\n  for (int i = 0; i < ElementSizeInBytes(repr); i++) {\n    Update(fresh_entries_, offset + i, object, {});\n  }\n  uint32_t initial_offset = offset >= kMaximumReprSizeInBytes - 1\n                                ? offset - (kMaximumReprSizeInBytes - 1)\n                                : 0;\n  for (uint32_t i = initial_offset; i < offset; i++) {\n    const FieldInfo& info = fresh_entries_.Get(i).Get(object);\n    if (info.representation != MachineRepresentation::kNone &&\n        ElementSizeInBytes(info.representation) >\n            "
}