{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/loop-variable-optimizer.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 71, column 43",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/loop-variable-optimizer.cc\",\n        \"file_name\": \"loop-variable-optimizer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements loop variable optimization techniques within the Turbofan compiler for the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for compiler, common operators, node marking, node properties, turbofan graph, zone containers, and zone management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/loop-variable-optimizer.h\"\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/node-marker.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/zone/zone-containers.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LoopVariableOptimizer\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"This class performs loop variable optimization on a Turbofan graph. It identifies induction variables, tracks their limits, and potentially transforms the graph to exploit loop invariants.\",\n            \"attributes\": [\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"TFGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Turbofan graph being optimized.\"\n                },\n                {\n                    \"name\": \"common_\",\n                    \"type\": \"CommonOperatorBuilder*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A builder for common operators used in the graph.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone used for memory allocation.\"\n                },\n                {\n                    \"name\": \"limits_\",\n                    \"type\": \"ZoneVector<VariableLimits>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the variable limits for each node in the graph.\"\n                },\n                {\n                    \"name\": \"reduced_\",\n                    \"type\": \"ZoneVector<bool>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A marker to track which nodes have been processed.\"\n                },\n                {\n                    \"name\": \"induction_vars_\",\n                    \"type\": \"ZoneMap<NodeId, InductionVariable*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A map from node ID to InductionVariable objects.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TFGraph\",\n                \"CommonOperatorBuilder\",\n                \"Zone\",\n                \"VariableLimits\",\n                \"NodeMarker\",\n                \"InductionVariable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\n// Macro for outputting trace information from representation inference.\n#define TRACE(...)                                      \\\n  do {                                                  \\\n    if (v8_flags.trace_turbo_loop) PrintF(__VA_ARGS__); \\\n  } while (false)\n\nLoopVariableOptimizer::LoopVariableOptimizer(TFGraph* graph,\n                                             CommonOperatorBuilder* common,\n                                             Zone* zone)\n    : graph_(graph),\n      common_(common),\n      zone_(zone),\n      limits_(graph->NodeCount(), zone),\n      reduced_(graph->NodeCount(), zone),\n      induction_vars_(zone) {}\n\nvoid LoopVariableOptimizer::Run() {\n  ZoneQueue<Node*> queue(zone());\n  queue.push(graph()->start());\n  NodeMarker<bool> queued(graph(), 2);\n  while (!queue.empty()) {\n    Node* node = queue.front();\n    queue.pop();\n    queued.Set(node, false);\n\n    DCHECK(!reduced_.Get(node));\n    bool all_inputs_visited = true;\n    int inputs_end = (node->opcode() == IrOpcode::kLoop)\n                         ? kFirstBackedge\n                         : node->op()->ControlInputCount();\n    for (int i = 0; i < inputs_end; i++) {\n      if (!reduced_.Get(NodeProperties::GetControlInput(node, i))) {\n        all_inputs_visited = false;\n        break;\n      }\n    }\n    if (!all_inputs_visited) continue;\n\n    VisitNode(node);\n    reduced_.Set(node, true);\n\n    // Queue control outputs.\n    for (Edge edge : node->use_edges()) {\n      if (NodeProperties::IsControlEdge(edge) &&\n          edge.from()->op()->ControlOutputCount() > 0) {\n        Node* use = edge.from();\n        if (use->opcode() == IrOpcode::kLoop &&\n            edge.index() != kAssumedLoopEntryIndex) {\n          VisitBackedge(node, use);\n        } else if (!queued.Get(use)) {\n          queue.push(use);\n          queued.Set(use, true);\n        }\n      }\n    }\n  }\n}\n\nvoid LoopVariableOptimizer::VisitBackedge(Node* from, Node* loop) {\n  if (loop->op()->ControlInputCount() != 2) return;\n\n  // Go through the constraints, and update the induction variables in\n  // this loop if they are involved in the constraint.\n  for (Constraint constraint : limits_.Get(from)) {\n    if (constraint.left->opcode() == IrOpcode::kPhi &&\n        NodeProperties::GetControlInput(constraint.left) == loop) {\n      auto var = induction_vars_.find(constraint.left->id());\n      if (var != induction_vars_.end()) {\n        var->second->AddUpperBound(constraint.right, constraint.kind);\n      }\n    }\n    if (constraint.right->opcode() == IrOpcode::kPhi &&\n        NodeProperties::GetControlInput(constraint.right) == loop) {\n      auto var = induction_vars_.find(constraint.right->id());\n      if (var != induction_vars_.end()) {\n        var->second->AddLowerBound(constraint.left, constraint.kind);\n      }\n    }\n  }\n}\n\nvoid LoopVariableOptimizer::VisitNode(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kMerge:\n      return VisitMerge(node);\n    case IrOpcode::kLoop:\n      return VisitLoop(node);\n    case IrOpcode::kIfFalse:\n      return VisitIf(node, false);\n    case IrOpcode::kIfTrue:\n      return VisitIf(node, true);\n    case IrOpcode::kStart:\n      return VisitStart(node);\n    case IrOpcode::kLoopExit:\n      return VisitLoopExit(node);\n    default:\n      return VisitOtherControl(node);\n  }\n}\n\nvoid LoopVariableOptimizer::VisitMerge(Node* node) {\n  // Merge the limits of all incoming edges.\n  VariableLimits merged = limits_.Get(node->InputAt(0));\n  for (int i = 1; i < node->InputCount(); i++) {\n    merged.ResetToCommonAncestor(limits_.Get(node->InputAt(i)));\n  }\n  limits_.Set(node, merged);\n}\n\nvoid LoopVariableOptimizer::VisitLoop(Node* node) {\n  DetectInductionVariables(node);\n  // Conservatively take the limits from the loop entry here.\n  return TakeConditionsFromFirstControl(node);\n}\n\nvoid LoopVariableOptimizer::VisitIf(Node* node, bool polarity) {\n  Node* branch = node->InputAt(0);\n  Node* cond = branch->InputAt(0);\n  VariableLimits limits = limits_.Get(branch);\n  // Normalize to less than comparison.\n  switch (cond->opcode()) {\n    case IrOpcode::kJSLessThan:\n    case IrOpcode::kNumberLessThan:\n    case IrOpcode::kSpeculativeNumberLessThan:\n      AddCmpToLimits(&limits, cond, InductionVariable::kStrict, polarity);\n      break;\n    case IrOpcode::kJSGreaterThan:\n      AddCmpToLimits(&limits, cond, InductionVariable::kNonStrict, !polarity);\n      break;\n    case IrOpcode::kJSLessThanOrEqual:\n    case IrOpcode::kNumberLessThanOrEqual:\n    case IrOpcode::kSpeculativeNumberLessThanOrEqual:\n      AddCmpToLimits(&limits, cond, InductionVariable::kNonStrict, polarity);\n      break;\n    case IrOpcode::kJSGreaterThanOrEqual:\n      AddCmpToLimits(&limits, cond, InductionVariable::kStrict, !polarity);\n      break;\n    default:\n      break;\n  }\n  limits_.Set(node, limits);\n}\n\nvoid LoopVariableOptimizer::AddCmpToLimits(\n    VariableLimits* limits, Node* node, InductionVariable::ConstraintKind kind,\n    bool polarity) {\n  Node* left = node->InputAt(0);\n  Node* right = node->InputAt(1);\n  if (FindInductionVariable(left) || FindInductionVariable(right)) {\n    if (polarity) {\n      limits->PushFront(Constraint{left, kind, right}, zone());\n    } else {\n      kind = (kind == InductionVariable::kStrict)\n                 ? InductionVariable::kNonStrict\n                 : InductionVariable::kStrict;\n      limits->PushFront(Constraint{right, kind, left}, zone());\n    }\n  }\n}\n\nvoid LoopVariableOptimizer::VisitStart(Node* node) { limits_.Set(node, {}); }\n\nvoid LoopVariableOptimizer::VisitLoopExit(Node* node) {\n  return TakeConditionsFromFirstControl(node);\n}\n\nvoid LoopVariableOptimizer::VisitOtherControl(Node* node) {\n  DCHECK_EQ(1, node->op()->ControlInputCount());\n  return TakeConditionsFromFirstControl(node);\n}\n\nvoid LoopVariableOptimizer::TakeConditionsFromFirstControl(Node* node) {\n  limits_.Set(node, limits_.Get(NodeProperties::GetControlInput(node, 0)));\n}\n\nconst InductionVariable* LoopVariableOptimizer::FindInductionVariable(\n    Node* node) {\n  auto var = induction_vars_.find(node->id());\n  if (var != induction_vars_.end()) {\n    return var->second;\n  }\n  return nullptr;\n}\n\nInductionVariable* LoopVariableOptimizer::TryGetInductionVariable(Node* phi) {\n  DCHECK_EQ(2, phi->op()->ValueInputCount());\n  Node* loop = NodeProperties::GetControlInput(phi);\n  DCHECK_EQ(IrOpcode::kLoop, loop->opcode());\n  Node* initial = phi->InputAt(0);\n  Node* arith = phi->InputAt(1);\n  InductionVariable::ArithmeticType arithmeticType;\n  if (arith->opcode() == IrOpcode::kJSAdd ||\n      arith->opcode() == IrOpcode::kNumberAdd ||\n      arith->opcode() == IrOpcode::kSpeculativeNumberAdd ||\n      arith->opcode() == IrOpcode::kSpeculativeAdditiveSafeIntegerAdd ||\n      arith->opcode() == IrOpcode::kSpeculativeAdditiveSafeIntegerSubtract ||\n      arith->opcode() == IrOpcode::kSpeculativeSmallIntegerAdd) {\n    arithmeticType = InductionVariable::ArithmeticType::kAddition;\n  } else if (arith->opcode() == IrOpcode::kJSSubtract ||\n             arith->opcode() == IrOpcode::kNumberSubtract ||\n             arith->opcode() == IrOpcode::kSpeculativeNumberSubtract ||\n             arith->opcode() == IrOpcode::kSpeculativeSmallIntegerSubtract) {\n    arithmeticType = InductionVariable::ArithmeticType::kSubtraction;\n  } else {\n    return nullptr;\n  }\n\n  // We allow a few additional conversions on the lhs of the arithmetic\n  // operation. This needs to be kept in sync with the corresponding code in\n  // {Typer::Visitor::InductionVariablePhiTypeIsPrefixedPoint}.\n  // TODO(jarin) Support both sides.\n  Node* input = arith->InputAt(0);\n  if (input->opcode() == IrOpcode::kSpeculativeToNumber ||\n      input->opcode() == IrOpcode::kJSToNumber ||\n      input->opcode() == IrOpcode::kJSToNumberConvertBigInt) {\n    input = input->InputAt(0);\n  }\n  if (input != phi) return nullptr;\n\n  Node* effect_phi = nullptr;\n  for (Node* use : loop->uses()) {\n    if (use->opcode() == IrOpcode::kEffectPhi) {\n      DCHECK_NULL(effect_phi);\n      effect_phi = use;\n    }\n  }\n  if (!effect_phi) return nullptr;\n\n  Node* incr = arith->InputAt(1);\n  return zone()->New<InductionVariable>(phi, effect_phi, arith, incr, initial,\n                                        zone(), arithmeticType);\n}\n\nvoid LoopVariableOptimizer::DetectInductionVariables(Node* loop) {\n  if (loop->op()->ControlInputCount() != 2) return;\n  TRACE(\"Loop variables for loop %i:\", loop->id());\n  for (Edge edge : loop->use_edges()) {\n    if (NodeProperties::IsControlEdge(edge) &&\n        edge.from()->opcode() == IrOpcode::kPhi) {\n      Node* phi = edge.from();\n      InductionVariable* induction_var = TryGetInductionVariable(phi);\n      if (induction_var) {\n        induction_vars_[phi->id()] = induction_var;\n        TRACE(\" %i\", induction_var->phi()->id());\n      }\n    }\n  }\n  TRACE(\"\\n\");\n}\n\nvoid LoopVariableOptimizer::ChangeToInductionVariablePhis() {\n  for (auto entry : induction_vars_) {\n    // It only make sense to analyze the induction variables if\n    // there is a bound.\n    InductionVariable* induction_var = entry.second;\n    DCHECK_EQ(MachineRepresentation::kTagged,\n              PhiRepresentationOf(induction_var->phi()->op()));\n    if (induction_var->upper_bounds().empty() &&\n        induction_var->lower_bounds().empty()) {\n      continue;\n    }\n    // Insert the increment value to the value inputs.\n    induction_var->phi()->InsertInput(graph()->zone(),\n                                      induction_var->phi()->InputCount() - 1,\n                                      induction_var->increment());\n    // Insert the bound inputs to the value inputs.\n    for (auto bound : induction_var->lower_bounds()) {\n      induction_var->phi()->InsertInput(\n          graph()->zone(), induction_var->phi()->InputCount() - 1, bound.bound);\n    }\n    for (auto bound : induction_var->upper_bounds()) {\n      induction_var->phi()->InsertInput(\n          graph()->zone(), induction_var->phi()->InputCount() - 1, bound.bound);\n    }\n    NodeProperties::ChangeOp(\n        induction_var->phi(),\n        common()->InductionVariablePhi(induction_var->phi()->InputCount() - 1));\n  }\n}\n\nvoid LoopVariableOptimizer::ChangeToPhisAndInsertGuards() {\n  for (auto entry : induction_vars_) {\n    InductionVariable* induction_var = entry.second;\n    if (induction_var->phi()->opcode() == IrOpcode::kInductionVariablePhi) {\n      // Turn the induction variable phi back to normal phi.\n      int value_count = 2;\n      Node* control = NodeProperties::GetControlInput(induction_var->phi());\n      DCHECK_EQ(value_count, control->op()->ControlInputCount());\n      induction_var->phi()->TrimInputCount(value_count + 1);\n      induction_var->phi()->ReplaceInput(value_count, control);\n      NodeProperties::ChangeOp(\n          induction_var->phi(),\n          common()->Phi(MachineRepresentation::kTagged, value_count));\n\n      // If the backedge is not a subtype of the phi's type, we insert a sigma\n      // to get the typing right.\n      Node* backedge_value = induction_var->phi()->InputAt(1);\n      Type backedge_type = NodeProperties::GetType(backedge_value);\n      Type phi_type = NodeProperties::GetType(induction_var->phi());\n      if (!backedge_type.Is(phi_type)) {\n        Node* loop = NodeProperties::GetControlInput(induction_var->phi());\n        Node* backedge_control = loop->InputAt(1);\n        Node* backedge_effect =\n            NodeProperties::GetEffectInput(induction_var->effect_phi(), 1);\n        Node* rename =\n            graph()->NewNode(common()->TypeGuard(phi_type), backedge_value,\n                             backedge_effect, backedge_control);\n        induction_var->effect_phi()->ReplaceInput(1, rename);\n        induction_var->phi()->ReplaceInput(1, rename);\n      }\n    }\n  }\n}\n\n#undef TRACE\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"InductionVariable\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents an induction variable within a loop, tracking its properties and constraints.\",\n            \"attributes\": [\n                {\n                    \"name\": \"phi_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Phi node representing the induction variable.\"\n                },\n                {\n                    \"name\": \"effect_phi_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The effect Phi node associated with the induction variable.\"\n                },\n                {\n                    \"name\": \"arith_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The arithmetic node performing the induction update.\"\n                },\n                {\n                    \"name\": \"increment_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The increment value used in the induction update.\"\n                },\n                {\n                    \"name\": \"initial_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The initial value of the induction variable.\"\n                },\n                {\n                    \"name\": \"upper_bounds_\",\n                    \"type\": \"ZoneVector<Bound>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A list of upper bounds for the induction variable.\"\n                },\n                {\n                    \"name\": \"lower_bounds_\",\n                    \"type\": \"ZoneVector<Bound>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A list of lower bounds for the induction variable.\"\n                },\n                {\n                    \"name\": \"arithmetic_type_\",\n                    \"type\": \"ArithmeticType\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The type of arithmetic operation performed on the induction variable (addition or subtraction).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\",\n                \"Zone\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InductionVariable::AddUpperBound(Node* bound,\n                                      InductionVariable::ConstraintKind kind) {\n  if (v8_flags.trace_turbo_loop) {\n    StdoutStream{} << \"New upper bound for \" << phi()->id() << \" (loop \"\n                   << NodeProperties::GetControlInput(phi())->id()\n                   << \"): \" << *bound << std::endl;\n  }\n  upper_bounds_.push_back(Bound(bound, kind));\n}\n\nvoid InductionVariable::AddLowerBound(Node* bound,\n                                      InductionVariable::ConstraintKind kind) {\n  if (v8_flags.trace_turbo_loop) {\n    StdoutStream{} << \"New lower bound for \" << phi()->id() << \" (loop \"\n                   << NodeProperties::GetControlInput(phi())->id()\n                   << \"): \" << *bound;\n  }\n  lower_bounds_.push_back(Bound(bound, kind));\n}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"Constraint\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents a constraint on a variable, used for limit tracking.\",\n            \"attributes\": [\n                {\n                    \"name\": \"left\",\n                    \"type\": \"Node*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The left-hand side of the constraint (a variable or expression).\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"InductionVariable::ConstraintKind\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The type of constraint (e.g., strict, non-strict).\"\n                },\n                {\n                    \"name\": \"right\",\n                    \"type\": \"Node*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The right-hand side of the constraint (a constant or expression).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\",\n                \"InductionVariable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"VariableLimits\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents limits or constraints on variables within a specific scope.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"InductionVariable::ArithmeticType\",\n            \"about\": \"Specifies the types of arithmetic operations for induction variable.\",\n            \"values\": [\n                \"kAddition\",\n                \"kSubtraction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n\n        ]]></code>\n    </enum>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"InductionVariable::ConstraintKind\",\n            \"about\": \"Specifies the kinds of contraints for induction variables.\",\n            \"values\": [\n                \"kStrict\",\n                \"kNonStrict\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n\n        ]]></code>\n    </enum>\n</file>\n```"
}