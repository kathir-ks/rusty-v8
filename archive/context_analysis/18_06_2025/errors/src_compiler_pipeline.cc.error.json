{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/pipeline.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/pipeline.cc\",\n        \"file_name\": \"pipeline.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Turbofan compiler pipeline for JavaScript and WebAssembly. Defines the phases of the compiler, including graph building, optimization, lowering, scheduling, and code generation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ libraries for file operations, input/output streams, memory management, and optional types. Also includes V8-specific headers for compiler components, code generation, runtime statistics, and more.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/pipeline.h\"\n\n            #include <fstream>\n            #include <iostream>\n            #include <memory>\n            #include <optional>\n            #include <sstream>\n\n            #include \"src/builtins/builtins.h\"\n            #include \"src/builtins/profile-data-reader.h\"\n            #include \"src/codegen/bailout-reason.h\"\n            #include \"src/codegen/compiler.h\"\n            #include \"src/codegen/interface-descriptors-inl.h\"\n            #include \"src/codegen/optimized-compilation-info.h\"\n            #include \"src/codegen/register-configuration.h\"\n            #include \"src/codegen/reloc-info-inl.h\"\n            #include \"src/codegen/reloc-info.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/common/high-allocation-throughput-scope.h\"\n            #include \"src/compiler/add-type-assertions-reducer.h\"\n            #include \"src/compiler/backend/bitcast-elider.h\"\n            #include \"src/compiler/backend/code-generator.h\"\n            #include \"src/compiler/backend/instruction-selector.h\"\n            #include \"src/compiler/backend/instruction.h\"\n            #include \"src/compiler/backend/register-allocator-verifier.h\"\n            #include \"src/compiler/backend/register-allocator.h\"\n            #include \"src/compiler/basic-block-instrumentor.h\"\n            #include \"src/compiler/branch-elimination.h\"\n            #include \"src/compiler/bytecode-graph-builder.h\"\n            #include \"src/compiler/checkpoint-elimination.h\"\n            #include \"src/compiler/code-assembler-compilation-job.h\"\n            #include \"src/compiler/code-assembler.h\"\n            #include \"src/compiler/common-operator-reducer.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/compiler-source-position-table.h\"\n            #include \"src/compiler/constant-folding-reducer.h\"\n            #include \"src/compiler/csa-load-elimination.h\"\n            #include \"src/compiler/dead-code-elimination.h\"\n            #include \"src/compiler/escape-analysis-reducer.h\"\n            #include \"src/compiler/escape-analysis.h\"\n            #include \"src/compiler/graph-trimmer.h\"\n            #include \"src/compiler/js-call-reducer.h\"\n            #include \"src/compiler/js-context-specialization.h\"\n            #include \"src/compiler/js-create-lowering.h\"\n            #include \"src/compiler/js-generic-lowering.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/js-inlining-heuristic.h\"\n            #include \"src/compiler/js-intrinsic-lowering.h\"\n            #include \"src/compiler/js-native-context-specialization.h\"\n            #include \"src/compiler/js-typed-lowering.h\"\n            #include \"src/compiler/late-escape-analysis.h\"\n            #include \"src/compiler/linkage.h\"\n            #include \"src/compiler/load-elimination.h\"\n            #include \"src/compiler/loop-analysis.h\"\n            #include \"src/compiler/loop-peeling.h\"\n            #include \"src/compiler/loop-variable-optimizer.h\"\n            #include \"src/compiler/machine-graph-verifier.h\"\n            #include \"src/compiler/machine-operator-reducer.h\"\n            #include \"src/compiler/memory-optimizer.h\"\n            #include \"src/compiler/node-observer.h\"\n            #include \"src/compiler/node-origin-table.h\"\n            #include \"src/compiler/osr.h\"\n            #include \"src/compiler/pair-load-store-reducer.h\"\n            #include \"src/compiler/phase.h\"\n            #include \"src/compiler/pipeline-data-inl.h\"\n            #include \"src/compiler/pipeline-statistics.h\"\n            #include \"src/compiler/raw-machine-assembler.h\"\n            #include \"src/compiler/redundancy-elimination.h\"\n            #include \"src/compiler/schedule.h\"\n            #include \"src/compiler/scheduler.h\"\n            #include \"src/compiler/simplified-lowering.h\"\n            #include \"src/compiler/simplified-operator-reducer.h\"\n            #include \"src/compiler/simplified-operator.h\"\n            #include \"src/compiler/turbofan-graph-visualizer.h\"\n            #include \"src/compiler/turbofan-typer.h\"\n            #include \"src/compiler/turboshaft/build-graph-phase.h\"\n            #include \"src/compiler/turboshaft/debug-feature-lowering-phase.h\"\n            #include \"src/compiler/turboshaft/instruction-selection-phase.h\"\n            #include \"src/compiler/turboshaft/loop-peeling-phase.h\"\n            #include \"src/compiler/turboshaft/loop-unrolling-phase.h\"\n            #include \"src/compiler/turboshaft/phase.h\"\n            #include \"src/compiler/turboshaft/pipelines.h\"\n            #include \"src/compiler/turboshaft/simplify-tf-loops.h\"\n            #include \"src/compiler/turboshaft/tracing.h\"\n            #include \"src/compiler/type-narrowing-reducer.h\"\n            #include \"src/compiler/typed-optimization.h\"\n            #include \"src/compiler/value-numbering-reducer.h\"\n            #include \"src/compiler/verifier.h\"\n            #include \"src/compiler/zone-stats.h\"\n            #include \"src/diagnostics/code-tracer.h\"\n            #include \"src/diagnostics/disassembler.h\"\n            #include \"src/flags/flags.h\"\n            #include \"src/handles/handles-inl.h\"\n            #include \"src/heap/local-heap.h\"\n            #include \"src/logging/code-events.h\"\n            #include \"src/logging/counters.h\"\n            #include \"src/logging/runtime-call-stats-scope.h\"\n            #include \"src/logging/runtime-call-stats.h\"\n            #include \"src/objects/code-kind.h\"\n            #include \"src/objects/shared-function-info.h\"\n            #include \"src/objects/string-inl.h\"\n            #include \"src/tracing/trace-event.h\"\n            #include \"src/utils/ostreams.h\"\n            #include \"src/utils/utils.h\"\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/compiler/int64-lowering.h\"\n            #include \"src/compiler/turboshaft/int64-lowering-phase.h\"\n            #include \"src/compiler/turboshaft/wasm-dead-code-elimination-phase.h\"\n            #include \"src/compiler/turboshaft/wasm-debug-memory-lowering-phase.h\"\n            #include \"src/compiler/turboshaft/wasm-gc-optimize-phase.h\"\n            #include \"src/compiler/turboshaft/wasm-lowering-phase.h\"\n            #include \"src/compiler/turboshaft/wasm-optimize-phase.h\"\n            #include \"src/compiler/turboshaft/wasm-turboshaft-compiler.h\"\n            #include \"src/compiler/wasm-compiler.h\"\n            #include \"src/compiler/wasm-escape-analysis.h\"\n            #include \"src/compiler/wasm-gc-lowering.h\"\n            #include \"src/compiler/wasm-gc-operator-reducer.h\"\n            #include \"src/compiler/wasm-load-elimination.h\"\n            #include \"src/compiler/wasm-typer.h\"\n            #include \"src/wasm/function-body-decoder.h\"\n            #include \"src/wasm/function-compiler.h\"\n            #include \"src/wasm/turboshaft-graph-interface.h\"\n            #include \"src/wasm/wasm-builtin-list.h\"\n            #include \"src/wasm/wasm-disassembler.h\"\n            #include \"src/wasm/wasm-engine.h\"\n\n            #if V8_TARGET_ARCH_ARM64\n            #include \"src/compiler/turboshaft/wasm-simd-phase.h\"\n            #endif  // V8_TARGET_ARCH_ARM64\n\n            #endif  // V8_ENABLE_WEBASSEMBLY\n\n            #if V8_ENABLE_WASM_SIMD256_REVEC\n            #include \"src/compiler/revectorizer.h\"\n            #include \"src/compiler/turboshaft/wasm-revec-phase.h\"\n            #endif  // V8_ENABLE_WASM_SIMD256_REVEC\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PipelineImpl\",\n            \"about\": \"Implements the different phases of the Turbofan pipeline\",\n            \"attributes\": [\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"TFPipelineData*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the pipeline data structure\"\n                }\n            ],\n            \"dependencies\": [\n                \"TFPipelineData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class PipelineImpl final {\n             public:\n              explicit PipelineImpl(TFPipelineData* data) : data_(data) {}\n\n              // Helpers for executing pipeline phases.\n              template <turboshaft::TurbofanPhase Phase, typename... Args>\n              auto Run(Args&&... args);\n\n              // Step A.1. Initialize the heap broker.\n              void InitializeHeapBroker();\n\n              // Step A.2. Run the graph creation and initial optimization passes.\n              bool CreateGraph(Linkage* linkage);\n\n              // Step B. Run the concurrent optimization passes.\n              bool OptimizeTurbofanGraph(Linkage* linkage);\n\n              // Substep B.1. Produce a scheduled graph.\n              void ComputeScheduledGraph();\n\n            #if V8_ENABLE_WASM_SIMD256_REVEC\n              void Revectorize();\n            #endif  // V8_ENABLE_WASM_SIMD256_REVEC\n\n              // Substep B.3. Run register allocation on the instruction sequence.\n              bool AllocateRegisters(CallDescriptor* call_descriptor,\n                                     bool has_dummy_end_block);\n\n              // Step C. Run the code assembly pass.\n              void AssembleCode(Linkage* linkage);\n\n              // Step D. Run the code finalization pass.\n              MaybeDirectHandle<Code> FinalizeCode(bool retire_broker = true);\n\n              // Step E. Ensure all embedded maps are non-deprecated using\n              // CheckNoDeprecatedMaps.\n\n              // Step F. Install any code dependencies.\n              bool CommitDependencies(Handle<Code> code);\n\n              void RunPrintAndVerify(const char* phase, bool untyped = false);\n              void AllocateRegisters(const RegisterConfiguration* config,\n                                     CallDescriptor* call_descriptor, bool run_verifier);\n\n              TFPipelineData* data() const { return data_; }\n              OptimizedCompilationInfo* info() const;\n              Isolate* isolate() const;\n              CodeGenerator* code_generator() const;\n\n              ObserveNodeManager* observe_node_manager() const;\n\n             private:\n              TFPipelineData* const data_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeHeapBroker\",\n            \"parent\": \"PipelineImpl\",\n            \"about\": \"Initializes the heap broker, which manages interaction with the heap during compilation.\",\n            \"logic\": \"Attaches compilation info, starts serializing the native context, and adds decorators for source positions and node origins for tracing.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"TFPipelineData\",\n                \"OptimizedCompilationInfo\",\n                \"JSHeapBroker\",\n                \"CodeTracer\",\n                \"SourcePositionTable\",\n                \"NodeOriginTable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PipelineImpl::InitializeHeapBroker() {\n              TFPipelineData* data = data_;\n\n              data->BeginPhaseKind(\"V8.TFBrokerInitAndSerialization\");\n\n              if (info()->trace_turbo_json() || info()->trace_turbo_graph()) {\n                CodeTracer::StreamScope tracing_scope(data->GetCodeTracer());\n                tracing_scope.stream()\n                    << \"---------------------------------------------------\\n\"\n                    << \"Begin compiling method \" << info()->GetDebugName().get()\n                    << \" using TurboFan\" << std::endl;\n              }\n              if (info()->trace_turbo_json()) {\n                TurboCfgFile tcf(isolate());\n                tcf << AsC1VCompilation(info());\n              }\n              if (data->info()->has_bytecode_array()) {\n                if (data->info()->bytecode_array()->SourcePositionTable()->DataSize() ==\n                    0) {\n                  data->source_positions()->Disable();\n                }\n                data->source_positions()->AddDecorator();\n              }\n              if (data->info()->trace_turbo_json()) {\n                data->node_origins()->AddDecorator();\n              }\n\n              Run<HeapBrokerInitializationPhase>();\n              data->broker()->StopSerializing();\n              data->EndPhaseKind();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CreateGraph\",\n            \"parent\": \"PipelineImpl\",\n            \"about\": \"Creates the initial Turbofan graph from bytecode.\",\n            \"logic\": \"Builds the graph from bytecode, performs inlining, and sets flags based on shared function info.\",\n            \"parameters\": [\n                {\n                    \"name\": \"linkage\",\n                    \"type\": \"Linkage*\",\n                    \"purpose\": \"Provides information about the function's calling convention and linkage.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if graph creation was successful, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"TFPipelineData\",\n                \"Linkage\",\n                \"GraphBuilderPhase\",\n                \"InliningPhase\",\n                \"SharedFunctionInfo\",\n                \"Typer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool PipelineImpl::CreateGraph(Linkage* linkage) {\n              DCHECK(!v8_flags.turbolev);\n              TFPipelineData* data = this->data_;\n              UnparkedScopeIfNeeded unparked_scope(data->broker());\n\n              data->BeginPhaseKind(\"V8.TFGraphCreation\");\n\n              Run<GraphBuilderPhase>(linkage);\n              RunPrintAndVerify(GraphBuilderPhase::phase_name(), true);\n\n              // Perform function context specialization and inlining (if enabled).\n              Run<InliningPhase>();\n              RunPrintAndVerify(InliningPhase::phase_name(), true);\n\n              // Determine the Typer operation flags.\n              {\n                SharedFunctionInfoRef shared_info =\n                    MakeRef(data->broker(), info()->shared_info());\n                if (is_sloppy(shared_info.language_mode()) &&\n                    shared_info.IsUserJavaScript()) {\n                  // Sloppy mode functions always have an Object for this.\n                  data->AddTyperFlag(Typer::kThisIsReceiver);\n                }\n                if (IsClassConstructor(shared_info.kind())) {\n                  // Class constructors cannot be [[Call]]ed.\n                  data->AddTyperFlag(Typer::kNewTargetIsReceiver);\n                }\n              }\n\n              data->EndPhaseKind();\n\n              return true;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"OptimizeTurbofanGraph\",\n            \"parent\": \"PipelineImpl\",\n            \"about\": \"Runs the optimization phases of the Turbofan compiler.\",\n            \"logic\": \"Trims the graph, types it, performs typed lowering, loop peeling, load elimination, escape analysis, and simplified lowering.\",\n            \"parameters\": [\n                {\n                    \"name\": \"linkage\",\n                    \"type\": \"Linkage*\",\n                    \"purpose\": \"Provides information about the function's calling convention and linkage.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Always returns true.\"\n            },\n            \"dependencies\": [\n                \"TFPipelineData\",\n                \"Linkage\",\n                \"EarlyGraphTrimmingPhase\",\n                \"TyperPhase\",\n                \"TypedLoweringPhase\",\n                \"LoopPeelingPhase\",\n                \"LoopExitEliminationPhase\",\n                \"LoadEliminationPhase\",\n                \"EscapeAnalysisPhase\",\n                \"TypeAssertionsPhase\",\n                \"SimplifiedLoweringPhase\",\n                \"GenericLoweringPhase\",\n                \"EarlyOptimizationPhase\",\n                \"MachineOperatorReducer\",\n                \"SimplifiedOperatorReducer\",\n                \"CommonOperatorReducer\",\n                \"WasmOptimizationPhase\",\n                \"ComputeSchedulePhase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool PipelineImpl::OptimizeTurbofanGraph(Linkage* linkage) {\n              DCHECK(!v8_flags.turbolev);\n              TFPipelineData* data = this->data_;\n\n              data->BeginPhaseKind(\"V8.TFLowering\");\n\n              // Trim the graph before typing to ensure all nodes are typed.\n              Run<EarlyGraphTrimmingPhase>();\n              RunPrintAndVerify(EarlyGraphTrimmingPhase::phase_name(), true);\n\n              // Type the graph and keep the Typer running such that new nodes get\n              // automatically typed when they are created.\n              Run<TyperPhase>(data->CreateTyper());\n              RunPrintAndVerify(TyperPhase::phase_name());\n\n              Run<TypedLoweringPhase>();\n              RunPrintAndVerify(TypedLoweringPhase::phase_name());\n\n              if (data->info()->loop_peeling()) {\n                Run<LoopPeelingPhase>();\n                RunPrintAndVerify(LoopPeelingPhase::phase_name(), true);\n              } else {\n                Run<LoopExitEliminationPhase>();\n                RunPrintAndVerify(LoopExitEliminationPhase::phase_name(), true);\n              }\n\n              if (v8_flags.turbo_load_elimination) {\n                Run<LoadEliminationPhase>();\n                RunPrintAndVerify(LoadEliminationPhase::phase_name());\n              }\n              data->DeleteTyper();\n\n              if (v8_flags.turbo_escape) {\n                Run<EscapeAnalysisPhase>();\n                RunPrintAndVerify(EscapeAnalysisPhase::phase_name());\n              }\n\n              if (v8_flags.assert_types) {\n                Run<TypeAssertionsPhase>();\n                RunPrintAndVerify(TypeAssertionsPhase::phase_name());\n              }\n\n              // Perform simplified lowering. This has to run w/o the Typer decorator,\n              // because we cannot compute meaningful types anyways, and the computed\n              // types might even conflict with the representation/truncation logic.\n              Run<SimplifiedLoweringPhase>(linkage);\n              RunPrintAndVerify(SimplifiedLoweringPhase::phase_name(), true);\n\n            #if V8_ENABLE_WEBASSEMBLY\n              if (data->has_js_wasm_calls()) {\n                DCHECK(data->info()->inline_js_wasm_calls());\n                Run<JSWasmInliningPhase>();\n                RunPrintAndVerify(JSWasmInliningPhase::phase_name(), true);\n                Run<WasmTypingPhase>(-1);\n                RunPrintAndVerify(WasmTypingPhase::phase_name(), true);\n                if (v8_flags.wasm_opt) {\n                  Run<WasmGCOptimizationPhase>(data->wasm_module_for_inlining(),\n                                               data->jsgraph());\n                  RunPrintAndVerify(WasmGCOptimizationPhase::phase_name(), true);\n                }\n                Run<JSWasmLoweringPhase>();\n                RunPrintAndVerify(JSWasmLoweringPhase::phase_name(), true);\n                if (v8_flags.turbo_optimize_inlined_js_wasm_wrappers && v8_flags.wasm_opt) {\n                  wasm::WasmDetectedFeatures detected({wasm::WasmDetectedFeature::gc});\n                  Run<WasmOptimizationPhase>(MachineOperatorReducer::kSilenceSignallingNan,\n                                             detected);\n                  RunPrintAndVerify(WasmOptimizationPhase::phase_name(), true);\n                }\n              }\n            #endif  // V8_ENABLE_WEBASSEMBLY\n\n              // From now on it is invalid to look at types on the nodes, because the\n              // types on the nodes might not make sense after representation selection\n              // due to the way we handle truncations; if we'd want to look at types\n              // afterwards we'd essentially need to re-type (large portions of) the\n              // graph.\n\n              // In order to catch bugs related to type access after this point, we now\n              // remove the types from the nodes (currently only in Debug builds).\n            #ifdef DEBUG\n              Run<UntyperPhase>();\n              RunPrintAndVerify(UntyperPhase::phase_name(), true);\n            #endif\n\n              // Run generic lowering pass.\n              Run<GenericLoweringPhase>();\n              RunPrintAndVerify(GenericLoweringPhase::phase_name(), true);\n\n              data->BeginPhaseKind(\"V8.TFBlockBuilding\");\n\n              data->InitializeFrameData(linkage->GetIncomingDescriptor());\n\n              // Run early optimization pass.\n              Run<EarlyOptimizationPhase>();\n              RunPrintAndVerify(EarlyOptimizationPhase::phase_name(), true);\n\n              data->source_positions()->RemoveDecorator();\n              if (data->info()->trace_turbo_json()) {\n                data->node_origins()->RemoveDecorator();\n              }\n\n              ComputeScheduledGraph();\n\n              return true;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeScheduledGraph\",\n            \"parent\": \"PipelineImpl\",\n            \"about\": \"Computes the schedule for the Turbofan graph, determining the order in which nodes will be executed.\",\n            \"logic\": \"Uses the Scheduler class to compute a schedule based on the graph and optimization flags. Sets the schedule in the TFPipelineData object.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"TFPipelineData\",\n                \"Scheduler\",\n                \"Schedule\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PipelineImpl::ComputeScheduledGraph() {\n              TFPipelineData* data = this->data_;\n              Run<ComputeSchedulePhase>();\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PipelineCompilationJob\",\n            \"about\": \"A compilation job specifically for the Turbofan pipeline.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"TurbofanCompilationJob\",\n                \"Zone\",\n                \"ZoneStats\",\n                \"OptimizedCompilationInfo\",\n                \"TurbofanPipelineStatistics\",\n                \"TFPipelineData\",\n                \"Linkage\",\n                \"Handle\",\n                \"SharedFunctionInfo\",\n                \"JSFunction\",\n                \"BytecodeOffset\",\n                \"CodeKind\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class PipelineCompilationJob final : public TurbofanCompilationJob {\n             public:\n              PipelineCompilationJob(Isolate* isolate,\n                                     Handle<SharedFunctionInfo> shared_info,\n                                     Handle<JSFunction> function, BytecodeOffset osr_offset,\n                                     CodeKind code_kind);\n              ~PipelineCompilationJob() final;\n              PipelineCompilationJob(const PipelineCompilationJob&) = delete;\n              PipelineCompilationJob& operator=(const PipelineCompilationJob&) = delete;\n\n             protected:\n              Status PrepareJobImpl(Isolate* isolate) final;\n              Status ExecuteJobImpl(RuntimeCallStats* stats,\n                                    LocalIsolate* local_isolate) final;\n              Status FinalizeJobImpl(Isolate* isolate) final;\n\n             private:\n              Zone zone_;\n              ZoneStats zone_stats_;\n              OptimizedCompilationInfo compilation_info_;\n              std::unique_ptr<TurbofanPipelineStatistics> pipeline_statistics_;\n              TFPipelineData data_;\n              turboshaft::PipelineData turboshaft_data_;\n              PipelineImpl pipeline_;\n              Linkage* linkage_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PrepareJobImpl\",\n            \"parent\": \"PipelineCompilationJob\",\n            \"about\": \"Prepares the compilation job by initializing data structures and settings.\",\n            \"logic\": \"Initializes the OptimizedCompilationInfo, chooses a specialization context, determines various optimization settings based on flags, and initializes the linkage.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Status\",\n                \"description\": \"SUCCEEDED if preparation was successful, otherwise a failure status.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"OptimizedCompilationInfo\",\n                \"Flags\",\n                \"Linkage\",\n                \"TFPipelineData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            PipelineCompilationJob::Status PipelineCompilationJob::PrepareJobImpl(\n                Isolate* isolate) {\n              // Ensure that the RuntimeCallStats table of main thread is available for\n              // phases happening during PrepareJob.\n              PipelineJobScope scope(&data_, isolate->counters()->runtime_call_stats());\n\n              if (compilation_info()->bytecode_array()->length() >\n                  v8_flags.max_optimized_bytecode_size) {\n                return AbortOptimization(BailoutReason::kFunctionTooBig);\n              }\n\n              if (!v8_flags.always_turbofan) {\n                compilation_info()->set_bailout_on_uninitialized();\n              }\n              if (v8_flags.turbo_loop_peeling) {\n                compilation_info()->set_loop_peeling();\n              }\n              if (v8_flags.turbo_inlining) {\n                compilation_info()->set_inlining();\n              }\n              if (v8_flags.turbo_allocation_folding) {\n                compilation_info()->set_allocation_folding();\n              }\n\n              // Determine whether to specialize the code for the function's context.\n              // We can't do this in the case of OSR, because we want to cache the\n              // generated code on the native context keyed on SharedFunctionInfo.\n              // TODO(mythria): Check if it is better to key the OSR cache on JSFunction and\n              // allow context specialization for OSR code.\n              if (!compilation_info()\n                       ->shared_info()\n                       ->function_context_independent_compiled() &&\n                  compilation_info()->closure()->raw_feedback_cell()->map() ==\n                      ReadOnlyRoots(isolate).one_closure_cell_map() &&\n                  !compilation_info()->is_osr()) {\n                compilation_info()->set_function_context_specializing();\n                data_.ChooseSpecializationContext();\n              }\n\n              if (compilation_info()->source_positions()) {\n                SharedFunctionInfo::EnsureSourcePositionsAvailable(\n                    isolate, compilation_info()->shared_info());\n              }\n\n              data_.set_start_source_position(\n                  compilation_info()->shared_info()->StartPosition());\n\n              linkage_ = compilation_info()->zone()->New<Linkage>(\n                  Linkage::ComputeIncoming(compilation_info()->zone(), compilation_info()));\n\n              if (compilation_info()->is_osr()) data_.InitializeOsrHelper();\n\n              // InitializeHeapBroker() and CreateGraph() may already use\n              // IsPendingAllocation.\n              isolate->heap()->PublishMainThreadPendingAllocations();\n\n              pipeline_.InitializeHeapBroker();\n\n              // Serialization may have allocated.\n              isolate->heap()->PublishMainThreadPendingAllocations();\n\n              return SUCCEEDED;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ExecuteJobImpl\",\n            \"parent\": \"PipelineCompilationJob\",\n            \"about\": \"Executes the main compilation pipeline.\",\n            \"logic\": \"Creates a local isolate scope, builds the Turbofan graph and performs optimization phases, lowers the graph to machine code, and assembles the code.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stats\",\n                    \"type\": \"RuntimeCallStats*\",\n                    \"purpose\": \"Runtime call statistics.\"\n                },\n                {\n                    \"name\": \"local_isolate\",\n                    \"type\": \"LocalIsolate*\",\n                    \"purpose\": \"The local isolate for the compilation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Status\",\n                \"description\": \"SUCCEEDED if compilation was successful, otherwise a failure status.\"\n            },\n            \"dependencies\": [\n                \"LocalIsolateScope\",\n                \"TFPipelineData\",\n                \"PipelineImpl\",\n                \"Linkage\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            PipelineCompilationJob::Status PipelineCompilationJob::ExecuteJobImpl(\n                RuntimeCallStats* stats, LocalIsolate* local_isolate) {\n              // Ensure that the RuntimeCallStats table is only available during execution\n              // and not during finalization as that might be on a different thread.\n              PipelineJobScope scope(&data_, stats);\n              LocalIsolateScope local_isolate_scope(data_.broker(), data_.info(),\n                                                    local_isolate);\n\n              turboshaft_data_.InitializeBrokerAndDependencies(data_.broker_ptr(),\n                                                              data_.dependencies());\n              turboshaft::Pipeline turboshaft_pipeline(&turboshaft_data_);\n\n              if (V8_UNLIKELY(v8_flags.turbolev)) {\n                if (!turboshaft_pipeline.CreateGraphWithMaglev(linkage_)) {\n                  return AbortOptimization(BailoutReason::kGraphBuildingFailed);\n                }\n              } else {\n                if (!pipeline_.CreateGraph(linkage_)) {\n                  return AbortOptimization(BailoutReason::kGraphBuildingFailed);\n                }\n\n                // We selectively Unpark inside OptimizeTurbofanGraph.\n                if (!pipeline_.OptimizeTurbofanGraph(linkage_)) return FAILED;\n\n                // We convert the turbofan graph to turboshaft.\n                if (!turboshaft_pipeline.CreateGraphFromTurbofan(&data_, linkage_)) {\n                  data_.EndPhaseKind();\n                  return FAILED;\n                }\n              }\n\n              if (!turboshaft_pipeline.OptimizeTurboshaftGraph(linkage_)) {\n                return FAILED;\n              }\n\n              const bool success = GenerateCodeFromTurboshaftGraph(\n                  linkage_, turboshaft_pipeline, &pipeline_, data_.osr_helper_ptr());\n              return success ? SUCCEEDED : FAILED;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FinalizeJobImpl\",\n            \"parent\": \"PipelineCompilationJob\",\n            \"about\": \"Finalizes the compilation job.\",\n            \"logic\": \"Finalizes code generation, installs code dependencies, and registers weak objects.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Status\",\n                \"description\": \"SUCCEEDED if finalization was successful, otherwise a failure status.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"Handle\",\n                \"Code\",\n                \"NativeContext\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            PipelineCompilationJob::Status PipelineCompilationJob::FinalizeJobImpl(\n                Isolate* isolate) {\n              // Ensure that the RuntimeCallStats table of main thread is available for\n              // phases happening during PrepareJob.\n              PipelineJobScope scope(&data_, isolate->counters()->runtime_call_stats());\n              RCS_SCOPE(isolate, RuntimeCallCounterId::kOptimizeFinalizePipelineJob);\n              Handle<Code> code;\n              DirectHandle<NativeContext> context;\n              turboshaft::Pipeline turboshaft_pipeline(&turboshaft_data_);\n              MaybeHandle<Code> maybe_code = turboshaft_pipeline.FinalizeCode();\n              if (!maybe_code.ToHandle(&code)) {\n                if (compilation_info()->bailout_reason() == BailoutReason::kNoReason) {\n                  return AbortOptimization(BailoutReason::kCodeGenerationFailed);\n                }\n                return FAILED;\n              }\n              context ="
}