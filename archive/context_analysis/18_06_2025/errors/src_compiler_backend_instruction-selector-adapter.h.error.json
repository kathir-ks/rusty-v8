{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-selector-adapter.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-selector-adapter.h\",\n            \"file_name\": \"instruction-selector-adapter.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines an adapter class, TurboshaftAdapter, to interface between the instruction selector and the Turboshaft graph representation.  It provides methods to view and interact with Turboshaft operations in a way that's suitable for instruction selection.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for optional types, code generation, compiler backend, Turboshaft graph manipulation, operations, opmasks, and representations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/codegen/machine-type.h\"\n#include \"src/compiler/backend/instruction.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/operation-matcher.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/compiler/turboshaft/use-map.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TurboshaftAdapter\",\n                \"extends\": \"turboshaft::OperationMatcher\",\n                \"about\": \"Adapts the Turboshaft graph to the instruction selector. Provides utility functions to access and interpret Turboshaft operations.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"turboshaft::Graph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Turboshaft graph being adapted.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"turboshaft::Graph\",\n                    \"turboshaft::OperationMatcher\",\n                    \"CallView\",\n                    \"LoadView\",\n                    \"StoreView\",\n                    \"AtomicRMWView\",\n                    \"Word32AtomicPairStoreView\",\n                    \"SimdShuffleView\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct TurboshaftAdapter : public turboshaft::OperationMatcher {\n  static constexpr bool IsTurbofan = false;\n  static constexpr bool IsTurboshaft = true;\n  static constexpr bool AllowsImplicitWord64ToWord32Truncation = true;\n\n  explicit TurboshaftAdapter(turboshaft::Graph* graph)\n      : turboshaft::OperationMatcher(*graph), graph_(graph) {}\n\n  class CallView {\n   public:\n    explicit CallView(turboshaft::Graph* graph, turboshaft::OpIndex node)\n        : node_(node) {\n      call_op_ = graph->Get(node_).TryCast<turboshaft::CallOp>();\n      if (call_op_ != nullptr) return;\n      tail_call_op_ = graph->Get(node_).TryCast<turboshaft::TailCallOp>();\n      if (tail_call_op_ != nullptr) return;\n      UNREACHABLE();\n    }\n\n    int return_count() const {\n      if (call_op_) {\n        return static_cast<int>(call_op_->results_rep().size());\n      }\n      if (tail_call_op_) {\n        return static_cast<int>(tail_call_op_->outputs_rep().size());\n      }\n      UNREACHABLE();\n    }\n    turboshaft::OpIndex callee() const {\n      if (call_op_) return call_op_->callee();\n      if (tail_call_op_) return tail_call_op_->callee();\n      UNREACHABLE();\n    }\n    turboshaft::OpIndex frame_state() const {\n      if (call_op_) return call_op_->frame_state().value();\n      UNREACHABLE();\n    }\n    base::Vector<const turboshaft::OpIndex> arguments() const {\n      if (call_op_) return call_op_->arguments();\n      if (tail_call_op_) return tail_call_op_->arguments();\n      UNREACHABLE();\n    }\n    const CallDescriptor* call_descriptor() const {\n      if (call_op_) return call_op_->descriptor->descriptor;\n      if (tail_call_op_) return tail_call_op_->descriptor->descriptor;\n      UNREACHABLE();\n    }\n\n    const turboshaft::TSCallDescriptor* ts_call_descriptor() const {\n      if (call_op_) return call_op_->descriptor;\n      if (tail_call_op_) return tail_call_op_->descriptor;\n      UNREACHABLE();\n    }\n\n    operator turboshaft::OpIndex() const { return node_; }\n\n   private:\n    turboshaft::OpIndex node_;\n    const turboshaft::CallOp* call_op_;\n    const turboshaft::TailCallOp* tail_call_op_;\n  };\n\n  class LoadView {\n   public:\n    LoadView(turboshaft::Graph* graph, turboshaft::OpIndex node) : node_(node) {\n      switch (graph->Get(node_).opcode) {\n        case turboshaft::Opcode::kLoad:\n          load_ = &graph->Get(node_).Cast<turboshaft::LoadOp>();\n          break;\n#if V8_ENABLE_WEBASSEMBLY\n        case turboshaft::Opcode::kSimd128LoadTransform:\n          load_transform_ =\n              &graph->Get(node_).Cast<turboshaft::Simd128LoadTransformOp>();\n          break;\n#if V8_ENABLE_WASM_SIMD256_REVEC\n        case turboshaft::Opcode::kSimd256LoadTransform:\n          load_transform256_ =\n              &graph->Get(node_).Cast<turboshaft::Simd256LoadTransformOp>();\n          break;\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif  // V8_ENABLE_WEBASSEMBLY\n        default:\n          UNREACHABLE();\n      }\n    }\n    LoadRepresentation loaded_rep() const {\n      DCHECK_NOT_NULL(load_);\n      return load_->machine_type();\n    }\n    turboshaft::MemoryRepresentation ts_loaded_rep() const {\n      DCHECK_NOT_NULL(load_);\n      return load_->loaded_rep;\n    }\n    turboshaft::RegisterRepresentation ts_result_rep() const {\n      DCHECK_NOT_NULL(load_);\n      return load_->result_rep;\n    }\n    bool is_protected(bool* traps_on_null) const {\n      if (kind().with_trap_handler) {\n        if (load_) {\n          *traps_on_null = load_->kind.trap_on_null;\n#if V8_ENABLE_WEBASSEMBLY\n        } else {\n#if V8_ENABLE_WASM_SIMD256_REVEC\n          DCHECK(\n              (load_transform_ && !load_transform_->load_kind.trap_on_null) ||\n              (load_transform256_ &&\n               !load_transform256_->load_kind.trap_on_null));\n#else\n          DCHECK(load_transform_);\n          DCHECK(!load_transform_->load_kind.trap_on_null);\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n          *traps_on_null = false;\n#endif  // V8_ENABLE_WEBASSEMBLY\n        }\n        return true;\n      }\n      return false;\n    }\n    bool is_atomic() const { return kind().is_atomic; }\n\n    turboshaft::OpIndex base() const {\n      if (load_) return load_->base();\n#if V8_ENABLE_WEBASSEMBLY\n      if (load_transform_) return load_transform_->base();\n#if V8_ENABLE_WASM_SIMD256_REVEC\n      if (load_transform256_) return load_transform256_->base();\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif\n      UNREACHABLE();\n    }\n    turboshaft::OpIndex index() const {\n      if (load_) return load_->index().value_or_invalid();\n#if V8_ENABLE_WEBASSEMBLY\n      if (load_transform_) return load_transform_->index();\n#if V8_ENABLE_WASM_SIMD256_REVEC\n      if (load_transform256_) return load_transform256_->index();\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif\n      UNREACHABLE();\n    }\n    int32_t displacement() const {\n      static_assert(\n          std::is_same_v<decltype(turboshaft::StoreOp::offset), int32_t>);\n      if (load_) {\n        int32_t offset = load_->offset;\n        if (load_->kind.tagged_base) {\n          CHECK_GE(offset,\n                   std::numeric_limits<int32_t>::min() + kHeapObjectTag);\n          offset -= kHeapObjectTag;\n        }\n        return offset;\n#if V8_ENABLE_WEBASSEMBLY\n      } else if (load_transform_) {\n        int32_t offset = load_transform_->offset;\n        DCHECK(!load_transform_->load_kind.tagged_base);\n        return offset;\n#if V8_ENABLE_WASM_SIMD256_REVEC\n      } else if (load_transform256_) {\n        int32_t offset = load_transform256_->offset;\n        DCHECK(!load_transform256_->load_kind.tagged_base);\n        return offset;\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif\n      }\n      UNREACHABLE();\n    }\n    uint8_t element_size_log2() const {\n      static_assert(\n          std::is_same_v<decltype(turboshaft::StoreOp::element_size_log2),\n                         uint8_t>);\n      if (load_) return load_->element_size_log2;\n#if V8_ENABLE_WEBASSEMBLY\n      if (load_transform_) return 0;\n#if V8_ENABLE_WASM_SIMD256_REVEC\n      if (load_transform256_) return 0;\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif\n      UNREACHABLE();\n    }\n\n    operator turboshaft::OpIndex() const { return node_; }\n\n   private:\n    turboshaft::LoadOp::Kind kind() const {\n      if (load_) return load_->kind;\n#if V8_ENABLE_WEBASSEMBLY\n      if (load_transform_) return load_transform_->load_kind;\n#if V8_ENABLE_WASM_SIMD256_REVEC\n      if (load_transform256_) return load_transform256_->load_kind;\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif\n      UNREACHABLE();\n    }\n\n    turboshaft::OpIndex node_;\n    const turboshaft::LoadOp* load_ = nullptr;\n#if V8_ENABLE_WEBASSEMBLY\n    const turboshaft::Simd128LoadTransformOp* load_transform_ = nullptr;\n#if V8_ENABLE_WASM_SIMD256_REVEC\n    const turboshaft::Simd256LoadTransformOp* load_transform256_ = nullptr;\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif\n  };\n\n  class StoreView {\n   public:\n    StoreView(turboshaft::Graph* graph, turboshaft::OpIndex node)\n        : node_(node) {\n      op_ = &graph->Get(node_).Cast<turboshaft::StoreOp>();\n    }\n\n    StoreRepresentation stored_rep() const {\n      return {op_->stored_rep.ToMachineType().representation(),\n              op_->write_barrier};\n    }\n    turboshaft::MemoryRepresentation ts_stored_rep() const {\n      return op_->stored_rep;\n    }\n    std::optional<AtomicMemoryOrder> memory_order() const {\n      // TODO(nicohartmann@): Currently we don't support memory orders.\n      if (op_->kind.is_atomic) return AtomicMemoryOrder::kSeqCst;\n      return std::nullopt;\n    }\n    MemoryAccessKind access_kind() const {\n      return op_->kind.with_trap_handler\n                 ? MemoryAccessKind::kProtectedByTrapHandler\n                 : MemoryAccessKind::kNormal;\n    }\n    bool is_atomic() const { return op_->kind.is_atomic; }\n\n    turboshaft::OpIndex base() const { return op_->base(); }\n    turboshaft::OptionalOpIndex index() const { return op_->index(); }\n    turboshaft::OpIndex value() const { return op_->value(); }\n    IndirectPointerTag indirect_pointer_tag() const {\n      return static_cast<IndirectPointerTag>(op_->indirect_pointer_tag());\n    }\n    int32_t displacement() const {\n      static_assert(\n          std::is_same_v<decltype(turboshaft::StoreOp::offset), int32_t>);\n      int32_t offset = op_->offset;\n      if (op_->kind.tagged_base) {\n        CHECK_GE(offset, std::numeric_limits<int32_t>::min() + kHeapObjectTag);\n        offset -= kHeapObjectTag;\n      }\n      return offset;\n    }\n    uint8_t element_size_log2() const {\n      static_assert(\n          std::is_same_v<decltype(turboshaft::StoreOp::element_size_log2),\n                         uint8_t>);\n      return op_->element_size_log2;\n    }\n\n    bool is_store_trap_on_null() const {\n      return op_->kind.with_trap_handler && op_->kind.trap_on_null;\n    }\n\n    operator turboshaft::OpIndex() const { return node_; }\n\n   private:\n    turboshaft::OpIndex node_;\n    const turboshaft::StoreOp* op_;\n  };\n\n  class AtomicRMWView {\n   public:\n    AtomicRMWView(const turboshaft::Graph* graph, turboshaft::OpIndex node)\n        : node_(node) {\n      op_ = &graph->Get(node).Cast<turboshaft::AtomicRMWOp>();\n    }\n\n    turboshaft::OpIndex base() const { return op_->base(); }\n    turboshaft::OpIndex index() const { return op_->index(); }\n    turboshaft::OpIndex value() const { return op_->value(); }\n    turboshaft::OpIndex expected() const {\n      DCHECK_EQ(op_->bin_op, turboshaft::AtomicRMWOp::BinOp::kCompareExchange);\n      return op_->expected().value_or_invalid();\n    }\n\n    operator turboshaft::OpIndex() const { return node_; }\n\n   private:\n    turboshaft::OpIndex node_;\n    const turboshaft::AtomicRMWOp* op_;\n  };\n\n  class Word32AtomicPairStoreView {\n   public:\n    explicit Word32AtomicPairStoreView(const turboshaft::Graph* graph,\n                                       turboshaft::OpIndex node)\n        : store_(graph->Get(node).Cast<turboshaft::AtomicWord32PairOp>()) {}\n\n    turboshaft::OpIndex base() const { return store_.base(); }\n    turboshaft::OpIndex index() const { return store_.index().value(); }\n    turboshaft::OpIndex value_low() const { return store_.value_low().value(); }\n    turboshaft::OpIndex value_high() const {\n      return store_.value_high().value();\n    }\n\n   private:\n    const turboshaft::AtomicWord32PairOp& store_;\n  };\n\n#if V8_ENABLE_WEBASSEMBLY\n  // TODO(391750831): Inline this.\n  class SimdShuffleView {\n   public:\n    explicit SimdShuffleView(const turboshaft::Graph* graph,\n                             turboshaft::OpIndex node)\n        : node_(node) {\n      op128_ = &graph->Get(node).Cast<turboshaft::Simd128ShuffleOp>();\n      // Initialize input mapping.\n      for (int i = 0; i < op128_->input_count; ++i) {\n        input_mapping_.push_back(i);\n      }\n    }\n\n    bool isSimd128() const {\n      // TODO(nicohartmann@): Extend when we add support for Simd256.\n      return true;\n    }\n\n    const uint8_t* data() const { return op128_->shuffle; }\n\n    turboshaft::OpIndex input(int index) const {\n      DCHECK_LT(index, op128_->input_count);\n      return op128_->input(input_mapping_[index]);\n    }\n\n    void SwapInputs() { std::swap(input_mapping_[0], input_mapping_[1]); }\n\n    void DuplicateFirstInput() {\n      DCHECK_LE(2, input_mapping_.size());\n      input_mapping_[1] = input_mapping_[0];\n    }\n\n    operator turboshaft::OpIndex() const { return node_; }\n\n   private:\n    turboshaft::OpIndex node_;\n    base::SmallVector<int, 2> input_mapping_;\n    const turboshaft::Simd128ShuffleOp* op128_;\n  };\n#endif\n\n  bool is_load(turboshaft::OpIndex node) const {\n    return graph_->Get(node).Is<turboshaft::LoadOp>()\n#if V8_ENABLE_WEBASSEMBLY\n           || graph_->Get(node).Is<turboshaft::Simd128LoadTransformOp>()\n#if V8_ENABLE_WASM_SIMD256_REVEC\n           || graph_->Get(node).Is<turboshaft::Simd256LoadTransformOp>()\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif\n        ;\n  }\n  bool is_load_root_register(turboshaft::OpIndex node) const {\n    return graph_->Get(node).Is<turboshaft::LoadRootRegisterOp>();\n  }\n  CallView call_view(turboshaft::OpIndex node) {\n    return CallView{graph_, node};\n  }\n  LoadView load_view(turboshaft::OpIndex node) {\n    DCHECK(is_load(node));\n    return LoadView(graph_, node);\n  }\n  StoreView store_view(turboshaft::OpIndex node) {\n    return StoreView(graph_, node);\n  }\n  AtomicRMWView atomic_rmw_view(turboshaft::OpIndex node) {\n    return AtomicRMWView(graph_, node);\n  }\n  Word32AtomicPairStoreView word32_atomic_pair_store_view(\n      turboshaft::OpIndex node) {\n    return Word32AtomicPairStoreView(graph_, node);\n  }\n#if V8_ENABLE_WEBASSEMBLY\n  SimdShuffleView simd_shuffle_view(turboshaft::OpIndex node) {\n    return SimdShuffleView(graph_, node);\n  }\n#endif\n\n  turboshaft::Graph* turboshaft_graph() const { return graph_; }\n\n  turboshaft::Block* block(turboshaft::Graph* schedule,\n                           turboshaft::OpIndex node) const {\n    // TODO(nicohartmann@): This might be too slow and we should consider\n    // precomputing.\n    return &schedule->Get(schedule->BlockOf(node));\n  }\n\n  RpoNumber rpo_number(const turboshaft::Block* block) const {\n    return RpoNumber::FromInt(block->index().id());\n  }\n\n  const ZoneVector<turboshaft::Block*>& rpo_order(turboshaft::Graph* schedule) {\n    return schedule->blocks_vector();\n  }\n\n  bool IsLoopHeader(const turboshaft::Block* block) const {\n    return block->IsLoop();\n  }\n\n  size_t PredecessorCount(const turboshaft::Block* block) const {\n    return block->PredecessorCount();\n  }\n  turboshaft::Block* PredecessorAt(const turboshaft::Block* block,\n                                   size_t index) const {\n    return block->Predecessors()[index];\n  }\n\n  base::iterator_range<turboshaft::Graph::OpIndexIterator> nodes(\n      const turboshaft::Block* block) {\n    return graph_->OperationIndices(*block);\n  }\n\n  bool IsPhi(turboshaft::OpIndex node) const {\n    return graph_->Get(node).Is<turboshaft::PhiOp>();\n  }\n  MachineRepresentation phi_representation_of(turboshaft::OpIndex node) const {\n    DCHECK(IsPhi(node));\n    const turboshaft::PhiOp& phi = graph_->Get(node).Cast<turboshaft::PhiOp>();\n    return phi.rep.machine_representation();\n  }\n  bool IsRetain(turboshaft::OpIndex node) const {\n    return graph_->Get(node).Is<turboshaft::RetainOp>();\n  }\n  bool IsHeapConstant(turboshaft::OpIndex node) const {\n    turboshaft::ConstantOp* constant =\n        graph_->Get(node).TryCast<turboshaft::ConstantOp>();\n    if (constant == nullptr) return false;\n    return constant->kind == turboshaft::ConstantOp::Kind::kHeapObject;\n  }\n  bool IsExternalConstant(turboshaft::OpIndex node) const {\n    turboshaft::ConstantOp* constant =\n        graph_->Get(node).TryCast<turboshaft::ConstantOp>();\n    if (constant == nullptr) return false;\n    return constant->kind == turboshaft::ConstantOp::Kind::kExternal;\n  }\n  bool IsRelocatableWasmConstant(turboshaft::OpIndex node) const {\n    turboshaft::ConstantOp* constant =\n        graph_->Get(node).TryCast<turboshaft::ConstantOp>();\n    if (constant == nullptr) return false;\n    return constant->kind ==\n           turboshaft::any_of(\n               turboshaft::ConstantOp::Kind::kRelocatableWasmCall,\n               turboshaft::ConstantOp::Kind::kRelocatableWasmStubCall);\n  }\n  bool IsLoadOrLoadImmutable(turboshaft::OpIndex node) const {\n    return graph_->Get(node).opcode == turboshaft::Opcode::kLoad;\n  }\n  bool IsProtectedLoad(turboshaft::OpIndex node) const {\n#if V8_ENABLE_WEBASSEMBLY\n    if (graph_->Get(node).opcode == turboshaft::Opcode::kSimd128LoadTransform) {\n      return true;\n    }\n#if V8_ENABLE_WASM_SIMD256_REVEC\n    if (graph_->Get(node).opcode == turboshaft::Opcode::kSimd256LoadTransform) {\n      return true;\n    }\n#endif  // V8_ENABLE_WASM_SIMD256_REVEC\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n    if (!IsLoadOrLoadImmutable(node)) return false;\n\n    bool traps_on_null;\n    return LoadView(graph_, node).is_protected(&traps_on_null);\n  }\n\n  int value_input_count(turboshaft::OpIndex node) const {\n    return graph_->Get(node).input_count;\n  }\n  turboshaft::OpIndex input_at(turboshaft::OpIndex node, size_t index) const {\n    return graph_->Get(node).input(index);\n  }\n  base::Vector<const turboshaft::OpIndex> inputs(\n      turboshaft::OpIndex node) const {\n    return graph_->Get(node).inputs();\n  }\n  turboshaft::Opcode opcode(turboshaft::OpIndex node) const {\n    return graph_->Get(node).opcode;\n  }\n  bool is_exclusive_user_of(turboshaft::OpIndex user,\n                            turboshaft::OpIndex value) const {\n    DCHECK(user.valid());\n    DCHECK(value.valid());\n    const turboshaft::Operation& value_op = graph_->Get(value);\n    const turboshaft::Operation& user_op = graph_->Get(user);\n    size_t use_count = base::count_if(\n        user_op.inputs(),\n        [value](turboshaft::OpIndex input) { return input == value; });\n    if (V8_UNLIKELY(use_count == 0)) {\n      // We have a special case here:\n      //\n      //         value\n      //           |\n      // TruncateWord64ToWord32\n      //           |\n      //         user\n      //\n      // If emitting user performs the truncation implicitly, we end up calling\n      // CanCover with value and user such that user might have no (direct) uses\n      // of value. There are cases of other unnecessary operations that can lead\n      // to the same situation (e.g. bitwise and, ...). In this case, we still\n      // cover if value has only a single use and this is one of the direct\n      // inputs of user, which also only has a single use (in user).\n      // TODO(nicohartmann@): We might generalize this further if we see use\n      // cases.\n      if (!value_op.saturated_use_count.IsOne()) return false;\n      for (auto input : user_op.inputs()) {\n        const turboshaft::Operation& input_op = graph_->Get(input);\n        const size_t indirect_use_count = base::count_if(\n            input_op.inputs(),\n            [value](turboshaft::OpIndex input) { return input == value; });\n        if (indirect_use_count > 0) {\n          return input_op.saturated_use_count.IsOne();\n        }\n      }\n      return false;\n    }\n    if (value_op.Is<turboshaft::ProjectionOp>()) {\n      // Projections always have a Tuple use, but it shouldn't count as a use as\n      // far as is_exclusive_user_of is concerned, since no instructions are\n      // emitted for the TupleOp, which is just a Turboshaft \"meta operation\".\n      // We thus increase the use_count by 1, to attribute the TupleOp use to\n      // the current operation.\n      use_count++;\n    }\n    DCHECK_LE(use_count, graph_->Get(value).saturated_use_count.Get());\n    return (value_op.saturated_use_count.Get() == use_count) &&\n           !value_op.saturated_use_count.IsSaturated();\n  }\n\n  uint32_t id(turboshaft::OpIndex node) const { return node.id(); }\n  static turboshaft::OpIndex value(turboshaft::OptionalOpIndex node) {\n    DCHECK(node.valid());\n    return node.value();\n  }\n\n  turboshaft::OpIndex block_terminator(const turboshaft::Block* block) const {\n    return graph_->PreviousIndex(block->end());\n  }\n  turboshaft::OpIndex parent_frame_state(turboshaft::OpIndex node) const {\n    const turboshaft::FrameStateOp& frame_state =\n        graph_->Get(node).Cast<turboshaft::FrameStateOp>();\n    return frame_state.parent_frame_state();\n  }\n  bool IsRequiredWhenUnused(turboshaft::OpIndex node) const {\n    return graph_->Get(node).IsRequiredWhenUnused();\n  }\n  bool IsCommutative(turboshaft::OpIndex node) const {\n    const turboshaft::Operation& op = graph_->Get(node);\n    if (const auto word_binop = op.TryCast<turboshaft::WordBinopOp>()) {\n      return turboshaft::WordBinopOp::IsCommutative(word_binop->kind);\n    } else if (const auto overflow_binop =\n                   op.TryCast<turboshaft::OverflowCheckedBinopOp>()) {\n      return turboshaft::OverflowCheckedBinopOp::IsCommutative(\n          overflow_binop->kind);\n    } else if (const auto float_binop =\n                   op.TryCast<turboshaft::FloatBinopOp>()) {\n      return turboshaft::FloatBinopOp::IsCommutative(float_binop->kind);\n    } else if (const auto comparison = op.TryCast<turboshaft::ComparisonOp>()) {\n      return turboshaft::ComparisonOp::IsCommutative(comparison->kind);\n    }\n    return false;\n  }\n\n private:\n  turboshaft::Graph* graph_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CallView\",\n                \"about\": \"Provides a view of call operations (CallOp and TailCallOp) within the Turboshaft graph.  It encapsulates the logic for accessing information specific to call nodes.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"node_\",\n                        \"type\": \"turboshaft::OpIndex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The index of the call operation node.\"\n                    },\n                    {\n                        \"name\": \"call_op_\",\n                        \"type\": \"const turboshaft::CallOp*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the CallOp if the node represents a regular call.\"\n                    },\n                    {\n                        \"name\": \"tail_call_op_\",\n                        \"type\": \"const turboshaft::TailCallOp*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the TailCallOp if the node represents a tail call.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"turboshaft::OpIndex\",\n                    \"turboshaft::CallOp\",\n                    \"turboshaft::TailCallOp\",\n                    \"CallDescriptor\",\n                    \"turboshaft::TSCallDescriptor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class CallView {\n   public:\n    explicit CallView(turboshaft::Graph* graph, turboshaft::OpIndex node)\n        : node_(node) {\n      call_op_ = graph->Get(node_).TryCast<turboshaft::CallOp>();\n      if (call_op_ != nullptr) return;\n      tail_call_op_ = graph->Get(node_).TryCast<turboshaft::TailCallOp>();\n      if (tail_call_op_ != nullptr) return;\n      UNREACHABLE();\n    }\n\n    int return_count() const {\n      if (call_op_) {\n        return static_cast<int>(call_op_->results_rep().size());\n      }\n      if (tail_call_op_) {\n        return static_cast<int>(tail_call_op_->outputs_rep().size());\n      }\n      UNREACHABLE();\n    }\n    turboshaft::OpIndex callee() const {\n      if (call_op_) return call_op_->callee();\n      if (tail_call_op_) return tail_call_op_->callee();\n      UNREACHABLE();\n    }\n    turboshaft::OpIndex frame_state() const {\n      if (call_op_) return call_op_->frame_state().value();\n      UNREACHABLE();\n    }\n    base::Vector<const turboshaft::OpIndex> arguments() const {\n      if (call_op_) return call_op_->arguments();\n      if (tail_call_op_) return tail_call_op_->arguments();\n      UNREACHABLE();\n    }\n    const CallDescriptor* call_descriptor() const {\n      if (call_op_) return call_op_->descriptor->descriptor;\n      if (tail_call_op_) return tail_call_op_->descriptor->descriptor;\n      UNREACHABLE();\n    }\n\n    const turboshaft::TSCallDescriptor* ts_call_descriptor() const {\n      if (call_op_) return call_op_->descriptor;\n      if (tail_call_op_) return tail_call_op_->descriptor;\n      UNREACHABLE();\n    }\n\n    operator turboshaft::OpIndex() const { return node_; }\n\n   private:\n    turboshaft::OpIndex node_;\n    const turboshaft::CallOp* call_op_;\n    const turboshaft::TailCallOp* tail_call_op_;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoadView\",\n                \"about\": \"Provides a view of load operations within the Turboshaft graph, allowing access to load-specific information such as loaded representation, base and index operands, and displacement.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"node_\",\n                        \"type\": \"turboshaft::OpIndex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The index of the load operation node.\"\n                    },\n                    {\n                        \"name\": \"load_\",\n                        \"type\": \"const turboshaft::LoadOp*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the LoadOp if the node represents a regular load.\"\n                    },\n                    {\n                        \"name\": \"load_transform_\",\n                        \"type"
}