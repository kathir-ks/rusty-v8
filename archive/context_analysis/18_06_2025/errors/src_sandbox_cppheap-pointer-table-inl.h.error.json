{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/sandbox/cppheap-pointer-table-inl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 383, column 58",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/sandbox/cppheap-pointer-table-inl.h\",\n            \"file_name\": \"cppheap-pointer-table-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Inline implementation of the CppHeapPointerTable and CppHeapPointerTableEntry classes for managing pointers in the C++ heap, specifically when pointer compression is enabled.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for external entity table functionality and the CppHeapPointerTable class definition.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/sandbox/compactible-external-entity-table-inl.h\"\n#include \"src/sandbox/cppheap-pointer-table.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MakePointerEntry\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Creates a new pointer entry in the table.\",\n                \"logic\": \"Sets the value and tag for a pointer entry.  It performs checks to ensure the value fits within the available bits and that the tag is valid.  It also allows marking the entry as alive.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Address\",\n                        \"purpose\": \"The address to store in the entry.\"\n                    },\n                    {\n                        \"name\": \"tag\",\n                        \"type\": \"CppHeapPointerTag\",\n                        \"purpose\": \"The tag associated with the pointer.\"\n                    },\n                    {\n                        \"name\": \"mark_as_alive\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether to mark the entry as alive.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerTag\",\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CppHeapPointerTableEntry::MakePointerEntry(Address value,\n                                                CppHeapPointerTag tag,\n                                                bool mark_as_alive) {\n  // Top bits must be zero, otherwise we'd loose information when shifting.\n  DCHECK_EQ(0, value >> (kBitsPerSystemPointer - kCppHeapPointerPayloadShift));\n  DCHECK_NE(tag, CppHeapPointerTag::kFreeEntryTag);\n  DCHECK_NE(tag, CppHeapPointerTag::kEvacuationEntryTag);\n\n  Payload new_payload(value, tag);\n  DCHECK(!new_payload.HasMarkBitSet());\n  if (V8_UNLIKELY(mark_as_alive)) {\n    new_payload.SetMarkBit();\n  }\n  payload_.store(new_payload, std::memory_order_relaxed);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetPointer\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Retrieves the pointer from the entry.\",\n                \"logic\": \"Loads the payload and extracts the pointer after removing the tag.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"tag_range\",\n                        \"type\": \"CppHeapPointerTagRange\",\n                        \"purpose\": \"The expected tag range of the pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Address\",\n                    \"description\": \"The pointer value.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerTagRange\",\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nAddress CppHeapPointerTableEntry::GetPointer(\n    CppHeapPointerTagRange tag_range) const {\n  auto payload = payload_.load(std::memory_order_relaxed);\n  DCHECK(payload.ContainsPointer());\n  return payload.Untag(tag_range);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetPointer\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Sets the pointer in the entry.\",\n                \"logic\": \"Sets the value and tag for a pointer entry.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Address\",\n                        \"purpose\": \"The address to store in the entry.\"\n                    },\n                    {\n                        \"name\": \"tag\",\n                        \"type\": \"CppHeapPointerTag\",\n                        \"purpose\": \"The tag associated with the pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerTag\",\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CppHeapPointerTableEntry::SetPointer(Address value,\n                                          CppHeapPointerTag tag) {\n  // Top bits must be zero, otherwise we'd loose information when shifting.\n  DCHECK_EQ(0, value >> (kBitsPerSystemPointer - kCppHeapPointerPayloadShift));\n  DCHECK_NE(tag, CppHeapPointerTag::kFreeEntryTag);\n  DCHECK_NE(tag, CppHeapPointerTag::kEvacuationEntryTag);\n  DCHECK(payload_.load(std::memory_order_relaxed).ContainsPointer());\n\n  Payload new_payload(value, tag);\n  payload_.store(new_payload, std::memory_order_relaxed);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HasPointer\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Checks if the entry has a pointer within the given tag range.\",\n                \"logic\": \"Checks if the entry's tag falls within the given range.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"tag_range\",\n                        \"type\": \"CppHeapPointerTagRange\",\n                        \"purpose\": \"The tag range to check against.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the entry has a pointer within the range, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerTagRange\",\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CppHeapPointerTableEntry::HasPointer(\n    CppHeapPointerTagRange tag_range) const {\n  auto payload = payload_.load(std::memory_order_relaxed);\n  return payload.IsTaggedWithTagIn(tag_range);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MakeZappedEntry\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Marks the entry as zapped (invalid).\",\n                \"logic\": \"Sets the entry to a zapped state using a null address and the kZappedEntryTag.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerTag\",\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CppHeapPointerTableEntry::MakeZappedEntry() {\n  Payload new_payload(kNullAddress, CppHeapPointerTag::kZappedEntryTag);\n  payload_.store(new_payload, std::memory_order_relaxed);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MakeFreelistEntry\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Marks the entry as a free list entry.\",\n                \"logic\": \"Sets the entry to a free list state using the index of the next free entry and the kFreeEntryTag.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"next_entry_index\",\n                        \"type\": \"uint32_t\",\n                        \"purpose\": \"The index of the next free entry in the list.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerTag\",\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CppHeapPointerTableEntry::MakeFreelistEntry(uint32_t next_entry_index) {\n  static_assert(kMaxCppHeapPointers <= std::numeric_limits<uint32_t>::max());\n  Payload new_payload(next_entry_index, CppHeapPointerTag::kFreeEntryTag);\n  payload_.store(new_payload, std::memory_order_relaxed);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetNextFreelistEntryIndex\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Retrieves the index of the next free list entry.\",\n                \"logic\": \"Loads the payload and extracts the index of the next free entry.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"uint32_t\",\n                    \"description\": \"The index of the next free entry.\"\n                },\n                \"dependencies\": [\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nuint32_t CppHeapPointerTableEntry::GetNextFreelistEntryIndex() const {\n  auto payload = payload_.load(std::memory_order_relaxed);\n  return payload.ExtractFreelistLink();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Mark\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Marks the entry as alive.\",\n                \"logic\": \"Sets the mark bit in the payload using a compare-and-exchange operation. It avoids infinite loops when the mutator modifies the value.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CppHeapPointerTableEntry::Mark() {\n  auto old_payload = payload_.load(std::memory_order_relaxed);\n  DCHECK(old_payload.ContainsPointer());\n\n  auto new_payload = old_payload;\n  new_payload.SetMarkBit();\n\n  // We don't need to perform the CAS in a loop: if the new value is not equal\n  // to the old value, then the mutator must've just written a new value into\n  // the entry. The mutator will also set the markbit through the write barrier.\n  payload_.compare_exchange_strong(old_payload, new_payload,\n                                   std::memory_order_relaxed);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MakeEvacuationEntry\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Marks the entry as an evacuation entry.\",\n                \"logic\": \"Sets the entry to an evacuation state with the handle location and the kEvacuationEntryTag.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle_location\",\n                        \"type\": \"Address\",\n                        \"purpose\": \"The location of the handle being evacuated.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerTag\",\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CppHeapPointerTableEntry::MakeEvacuationEntry(Address handle_location) {\n  Payload new_payload(handle_location, CppHeapPointerTag::kEvacuationEntryTag);\n  payload_.store(new_payload, std::memory_order_relaxed);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HasEvacuationEntry\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Checks if the entry is an evacuation entry.\",\n                \"logic\": \"Checks the payload to see if it contains an evacuation entry.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the entry is an evacuation entry, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Payload\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CppHeapPointerTableEntry::HasEvacuationEntry() const {\n  auto payload = payload_.load(std::memory_order_relaxed);\n  return payload.ContainsEvacuationEntry();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Evacuate\",\n                \"parent\": \"CppHeapPointerTableEntry\",\n                \"about\": \"Evacuates the entry to another entry.\",\n                \"logic\": \"Copies the payload from the source entry to the destination entry and then zaps the source entry.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"dest\",\n                        \"type\": \"CppHeapPointerTableEntry&\",\n                        \"purpose\": \"The destination entry to evacuate to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Payload\",\n                    \"MakeZappedEntry\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CppHeapPointerTableEntry::Evacuate(CppHeapPointerTableEntry& dest) {\n  auto payload = payload_.load(std::memory_order_relaxed);\n  // We expect to only evacuate entries containing external pointers.\n  DCHECK(payload.ContainsPointer());\n  // Currently, evacuation only happens during table compaction. In that case,\n  // the marking bit must be unset as the entry has already been visited by the\n  // sweeper (which clears the marking bit). If this ever changes, we'll need\n  // to let the caller specify what to do with the marking bit during\n  // evacuation.\n  DCHECK(!payload.HasMarkBitSet());\n\n  dest.payload_.store(payload, std::memory_order_relaxed);\n\n  // The destination entry takes ownership of the pointer.\n  MakeZappedEntry();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Get\",\n                \"parent\": \"CppHeapPointerTable\",\n                \"about\": \"Retrieves a pointer from the table.\",\n                \"logic\": \"Converts the handle to an index, then uses the index to get the pointer from the corresponding entry.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"CppHeapPointerHandle\",\n                        \"purpose\": \"The handle of the pointer to retrieve.\"\n                    },\n                    {\n                        \"name\": \"tag_range\",\n                        \"type\": \"CppHeapPointerTagRange\",\n                        \"purpose\": \"The expected tag range of the pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Address\",\n                    \"description\": \"The pointer value.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerHandle\",\n                    \"CppHeapPointerTagRange\",\n                    \"HandleToIndex\",\n                    \"at\",\n                    \"CppHeapPointerTableEntry::GetPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nAddress CppHeapPointerTable::Get(CppHeapPointerHandle handle,\n                                 CppHeapPointerTagRange tag_range) const {\n  uint32_t index = HandleToIndex(handle);\n  DCHECK(index == 0 || at(index).HasPointer(tag_range));\n  return at(index).GetPointer(tag_range);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Set\",\n                \"parent\": \"CppHeapPointerTable\",\n                \"about\": \"Sets a pointer in the table.\",\n                \"logic\": \"Converts the handle to an index, then uses the index to set the pointer in the corresponding entry.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"CppHeapPointerHandle\",\n                        \"purpose\": \"The handle of the pointer to set.\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Address\",\n                        \"purpose\": \"The address to store.\"\n                    },\n                    {\n                        \"name\": \"tag\",\n                        \"type\": \"CppHeapPointerTag\",\n                        \"purpose\": \"The tag associated with the pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerHandle\",\n                    \"CppHeapPointerTag\",\n                    \"HandleToIndex\",\n                    \"at\",\n                    \"CppHeapPointerTableEntry::SetPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CppHeapPointerTable::Set(CppHeapPointerHandle handle, Address value,\n                              CppHeapPointerTag tag) {\n  DCHECK_NE(kNullCppHeapPointerHandle, handle);\n  uint32_t index = HandleToIndex(handle);\n  at(index).SetPointer(value, tag);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AllocateAndInitializeEntry\",\n                \"parent\": \"CppHeapPointerTable\",\n                \"about\": \"Allocates and initializes a new entry in the table.\",\n                \"logic\": \"Allocates a new entry using AllocateEntry, then initializes it with the provided value and tag.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"space\",\n                        \"type\": \"Space*\",\n                        \"purpose\": \"The space the pointer belongs to.\"\n                    },\n                    {\n                        \"name\": \"initial_value\",\n                        \"type\": \"Address\",\n                        \"purpose\": \"The initial value of the pointer.\"\n                    },\n                    {\n                        \"name\": \"tag\",\n                        \"type\": \"CppHeapPointerTag\",\n                        \"purpose\": \"The tag associated with the pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"CppHeapPointerHandle\",\n                    \"description\": \"The handle of the newly allocated entry.\"\n                },\n                \"dependencies\": [\n                    \"Space\",\n                    \"CppHeapPointerTag\",\n                    \"AllocateEntry\",\n                    \"at\",\n                    \"CppHeapPointerTableEntry::MakePointerEntry\",\n                    \"IndexToHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nCppHeapPointerHandle CppHeapPointerTable::AllocateAndInitializeEntry(\n    Space* space, Address initial_value, CppHeapPointerTag tag) {\n  DCHECK(space->BelongsTo(this));\n  uint32_t index = AllocateEntry(space);\n  at(index).MakePointerEntry(initial_value, tag, space->allocate_black());\n\n  CppHeapPointerHandle handle = IndexToHandle(index);\n\n  return handle;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Mark\",\n                \"parent\": \"CppHeapPointerTable\",\n                \"about\": \"Marks the entry associated with the handle as alive.\",\n                \"logic\": \"Converts the handle to an index, checks if the table is being compacted, and marks the entry. It also handles lazy initialization scenarios.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"space\",\n                        \"type\": \"Space*\",\n                        \"purpose\": \"The space the pointer belongs to.\"\n                    },\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"CppHeapPointerHandle\",\n                        \"purpose\": \"The handle of the entry to mark.\"\n                    },\n                    {\n                        \"name\": \"handle_location\",\n                        \"type\": \"Address\",\n                        \"purpose\": \"The memory location where the handle is stored.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Space\",\n                    \"CppHeapPointerHandle\",\n                    \"HandleToIndex\",\n                    \"Contains\",\n                    \"MaybeCreateEvacuationEntry\",\n                    \"at\",\n                    \"CppHeapPointerTableEntry::Mark\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CppHeapPointerTable::Mark(Space* space, CppHeapPointerHandle handle,\n                               Address handle_location) {\n  DCHECK(space->BelongsTo(this));\n\n  // The handle_location must always contain the given handle. Except if the\n  // slot is lazily-initialized. In that case, the handle may transition from\n  // the null handle to a valid handle. However, in that case the\n  // newly-allocated entry will already have been marked as alive during\n  // allocation, and so we don't need to do anything here.\n#ifdef DEBUG\n  CppHeapPointerHandle current_handle = base::AsAtomic32::Acquire_Load(\n      reinterpret_cast<CppHeapPointerHandle*>(handle_location));\n  DCHECK(handle == kNullCppHeapPointerHandle || handle == current_handle);\n#endif\n\n  // If the handle is null, it doesn't have an EPT entry; no mark is needed.\n  if (handle == kNullCppHeapPointerHandle) return;\n\n  uint32_t index = HandleToIndex(handle);\n  DCHECK(space->Contains(index));\n\n  // If the table is being compacted and the entry is inside the evacuation\n  // area, then allocate and set up an evacuation entry for it.\n  MaybeCreateEvacuationEntry(space, index, handle_location);\n\n  // Even if the entry is marked for evacuation, it still needs to be marked as\n  // alive as it may be visited during sweeping before being evacuation.\n  at(index).Mark();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsValidHandle\",\n                \"parent\": \"CppHeapPointerTable\",\n                \"about\": \"Checks if the provided handle is a valid handle.\",\n                \"logic\": \"Performs a bitwise operation to determine if the handle is correctly formed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"CppHeapPointerHandle\",\n                        \"purpose\": \"The handle to validate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the handle is valid, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nbool CppHeapPointerTable::IsValidHandle(CppHeapPointerHandle handle) {\n  uint32_t index = handle >> kCppHeapPointerIndexShift;\n  return handle == index << kCppHeapPointerIndexShift;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HandleToIndex\",\n                \"parent\": \"CppHeapPointerTable\",\n                \"about\": \"Converts a handle to its corresponding index.\",\n                \"logic\": \"Shifts the handle to the right to extract the index.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"CppHeapPointerHandle\",\n                        \"purpose\": \"The handle to convert.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"uint32_t\",\n                    \"description\": \"The corresponding index.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerHandle\",\n                    \"IsValidHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nuint32_t CppHeapPointerTable::HandleToIndex(CppHeapPointerHandle handle) {\n  DCHECK(IsValidHandle(handle));\n  uint32_t index = handle >> kCppHeapPointerIndexShift;\n  DCHECK_LE(index, kMaxCppHeapPointers);\n  return index;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IndexToHandle\",\n                \"parent\": \"CppHeapPointerTable\",\n                \"about\": \"Converts an index to its corresponding handle.\",\n                \"logic\": \"Shifts the index to the left to create the handle.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"uint32_t\",\n                        \"purpose\": \"The index to convert.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"CppHeapPointerHandle\",\n                    \"description\": \"The corresponding handle.\"\n                },\n                \"dependencies\": [\n                    \"CppHeapPointerHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nCppHeapPointerHandle CppHeapPointerTable::IndexToHandle(uint32_t index) {\n  DCHECK_LE(index, kMaxCppHeapPointers);\n  CppHeapPointerHandle handle = index << kCppHeapPointerIndexShift;\n  DCHECK_NE(handle, kNullCppHeapPointerHandle);\n  return handle;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Contains\",\n                \"parent\": \"CppHeapPointerTable\",\n                \"about\": \"Checks if the table contains the given handle within the specified space.\",\n                \"logic\": \"Verifies the handle is within the space and then calls HandleToIndex.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"space\",\n                        \"type\": \"Space*\",\n                        \"purpose\": \"The memory space being checked.\"\n                    },\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"CppHeapPointerHandle\",\n                        \"purpose\": \"The handle to check for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the handle is in the space, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Space\",\n                    \"CppHeapPointerHandle\",\n                    \"HandleToIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CppHeapPointerTable::Contains(Space* space,\n                                   CppHeapPointerHandle handle) const {\n  DCHECK(space->BelongsTo(this));\n  return space->Contains(HandleToIndex(handle));\n}\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CppHeapPointerTableEntry\",\n                    \"about\": \"Represents an entry in the CppHeapPointerTable.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class CppHeapPointerTableEntry {\n                  public:\n                    void MakePointerEntry(Address value, CppHeapPointerTag tag, bool mark_as_alive);\n                    Address GetPointer(CppHeapPointerTagRange tag_range) const;\n                    void SetPointer(Address value, CppHeapPointerTag tag);\n                    bool HasPointer(CppHeapPointerTagRange tag_range) const;\n                    void MakeZappedEntry();\n                    void MakeFreelistEntry(uint32_t next_entry_index);\n                    uint32_t GetNextFreelistEntryIndex() const;\n                    void Mark();\n                    void MakeEvacuationEntry(Address handle_location);\n                    bool HasEvacuationEntry() const;\n                    void Evacuate(CppHeapPointerTableEntry& dest);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CppHeapPointerTable\",\n                    \"about\": \"A table for managing pointers in the C++ heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class CppHeapPointerTable {\n                  public:\n                    Address Get(CppHeapPointerHandle handle, CppHeapPointerTagRange tag_range) const;\n                    void Set(CppHeapPointerHandle handle, Address value, CppHeapPointerTag tag);\n                    CppHeapPointerHandle AllocateAndInitializeEntry(Space* space, Address initial_value, CppHeapPointerTag tag);\n                    void Mark(Space* space, CppHeapPointerHandle handle, Address handle_location);\n                    static bool IsValidHandle(CppHeapPointerHandle handle);\n                    static uint32_t HandleToIndex(CppHeapPointerHandle handle);\n                    static CppHeapPointerHandle IndexToHandle(uint32_t index);\n                    bool Contains(Space* space, CppHeapPointerHandle handle) const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Space\",\n                    \"about\": \"Represents a memory space.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Space {\n                 public:\n                  bool BelongsTo(CppHeapPointerTable* table);\n                  bool allocate_black();\n                  bool Contains(uint32_t index);\n                };\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"CppHeapPointerTag\",\n                    \"about\": \"Enum for pointer tags.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum class CppHeapPointerTag {\n                  kFreeEntryTag,\n                  kEvacuationEntryTag,\n                  kZappedEntryTag\n                };\n            ]]></code>\n        </enum>\n        <typedef>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"typedef\",\n                    \"name\": \"Address\",\n                    \"about\": \"Represents a memory address.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                typedef uintptr_t Address;\n            ]]></code>\n        </typedef>\n        <typedef>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"typedef\",\n                    \"name\": \"CppHeapPointerHandle\",\n                    \"about\": \"Represents a handle to a pointer in the C++ heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                typedef uint32_t CppHeapPointerHandle;\n            ]]></code>\n        </typedef>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CppHeapPointerTagRange\",\n                    \"about\": \"Represents a range of pointer tags.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class CppHeapPointerTagRange {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Payload\",\n                    \"about\": \"Internal class to hold pointer and tag information.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class Payload {\n             public:\n              Payload(Address value, CppHeapPointerTag tag);\n              bool HasMarkBitSet() const;\n              void SetMarkBit();\n              bool ContainsPointer() const;\n              Address Untag(CppHeapPointerTagRange tag_range);\n              bool IsTaggedWithTagIn(CppHeapPointerTagRange tag_range) const;\n              uint32_t ExtractFreelistLink() const;\n              bool ContainsEvacuationEntry() const;\n            };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}