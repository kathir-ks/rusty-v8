{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler-dispatcher/optimizing-compile-dispatcher.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 65, column 66",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler-dispatcher/optimizing-compile-dispatcher.h\",\n            \"file_name\": \"optimizing-compile-dispatcher.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares classes for managing and dispatching Turbofan compilation jobs in a multi-threaded environment.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers for threading, data structures, and V8-specific headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <atomic>\n#include <queue>\n\n#include \"src/base/platform/condition-variable.h\"\n#include \"src/base/platform/mutex.h\"\n#include \"src/base/vector.h\"\n#include \"src/common/globals.h\"\n#include \"src/flags/flags.h\"\n#include \"src/utils/allocation.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"OptimizingCompileTaskState\",\n                \"about\": \"Represents the state of a compilation task, primarily the isolate it's associated with.  Aligned to cache line size.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Pointer to the V8 Isolate associated with the compilation task.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct alignas(PROCESSOR_CACHE_LINE_SIZE) OptimizingCompileTaskState {\n  Isolate* isolate;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OptimizingCompileInputQueue\",\n                \"about\": \"A circular queue for incoming Turbofan compilation jobs.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"queue_\",\n                        \"type\": \"std::deque<TurbofanCompilationJob*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The queue of compilation jobs.\"\n                    },\n                    {\n                        \"name\": \"capacity_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The maximum number of jobs the queue can hold.\"\n                    },\n                    {\n                        \"name\": \"mutex_\",\n                        \"type\": \"base::Mutex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mutex to protect access to the queue.\"\n                    },\n                    {\n                        \"name\": \"task_finished_\",\n                        \"type\": \"base::ConditionVariable\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Condition variable to signal when a task has finished.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TurbofanCompilationJob\",\n                    \"Isolate\",\n                    \"SharedFunctionInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT OptimizingCompileInputQueue {\n public:\n  inline bool IsAvailable() {\n    base::MutexGuard access(&mutex_);\n    return queue_.size() < capacity_;\n  }\n\n  inline size_t Length() {\n    base::MutexGuard access_queue(&mutex_);\n    return queue_.size();\n  }\n\n  explicit OptimizingCompileInputQueue(int capacity) : capacity_(capacity) {}\n\n  TurbofanCompilationJob* Dequeue(OptimizingCompileTaskState& task_state);\n  TurbofanCompilationJob* DequeueIfIsolateMatches(Isolate* isolate);\n\n  bool Enqueue(std::unique_ptr<TurbofanCompilationJob>& job);\n\n  void FlushJobsForIsolate(Isolate* isolate);\n  bool HasJobForIsolate(Isolate* isolate);\n\n  void Prioritize(Isolate* isolate, Tagged<SharedFunctionInfo> function);\n\n private:\n  std::deque<TurbofanCompilationJob*> queue_;\n  size_t capacity_;\n\n  base::Mutex mutex_;\n  base::ConditionVariable task_finished_;\n\n  friend class OptimizingCompileTaskExecutor;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OptimizingCompileTaskExecutor\",\n                \"about\": \"Executes compilation tasks in a thread pool.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"input_queue_\",\n                        \"type\": \"OptimizingCompileInputQueue\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The input queue for compilation jobs.\"\n                    },\n                    {\n                        \"name\": \"recompilation_delay_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Copy of v8_flags.concurrent_recompilation_delay.\"\n                    },\n                    {\n                        \"name\": \"job_handle_\",\n                        \"type\": \"std::unique_ptr<JobHandle>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handle to the job running the compilation tasks.\"\n                    },\n                    {\n                        \"name\": \"task_states_\",\n                        \"type\": \"base::OwnedVector<OptimizingCompileTaskState>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of task states, one for each thread.\"\n                    },\n                    {\n                        \"name\": \"is_initialized_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag to indicate if the executor has been initialized.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"OptimizingCompileInputQueue\",\n                    \"TurbofanCompilationJob\",\n                    \"Isolate\",\n                    \"LocalIsolate\",\n                    \"OptimizingCompileTaskState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT OptimizingCompileTaskExecutor {\n public:\n  OptimizingCompileTaskExecutor();\n  ~OptimizingCompileTaskExecutor();\n\n  // Creates Job with PostJob.\n  void EnsureInitialized();\n\n  // Invokes and runs Turbofan for this particular job.\n  void CompileNext(Isolate* isolate, LocalIsolate& local_isolate,\n                   TurbofanCompilationJob* job);\n\n  // Gets the next job from the input queue.\n  TurbofanCompilationJob* NextInput(OptimizingCompileTaskState& task_state);\n\n  // Gets the next job from the input queue but only if the job is also for the\n  // given isolate.\n  TurbofanCompilationJob* NextInputIfIsolateMatches(Isolate* isolate);\n\n  // Returns true when one of the currently running compilation tasks is\n  // operating on the given isolate. If the return value is false, the caller\n  // can also assume that no LocalHeap/LocalIsolate exists for the isolate\n  // anymore as well.\n  bool IsTaskRunningForIsolate(Isolate* isolate);\n\n  // Clears the state for a task/thread once it is done with a job. This mainly\n  // clears the current isolate for this task. Only invoke this after the\n  // LocalHeap/LocalIsolate for this thread was destroyed as well.\n  void ClearTaskState(OptimizingCompileTaskState& task_state);\n\n  // Tries to append a new compilation job to the input queue. This may fail if\n  // the input queue was already full.\n  bool TryQueueForOptimization(std::unique_ptr<TurbofanCompilationJob>& job);\n\n  // Waits until all running and queued compilation jobs for this isolate are\n  // done.\n  void WaitUntilCompilationJobsDoneForIsolate(Isolate* isolate);\n\n  // Returns true if there exists a currently running or queued compilation job\n  // for this isolate..\n  bool HasCompilationJobsForIsolate(Isolate* isolate);\n\n private:\n  class CompileTask;\n\n  static constexpr TaskPriority kTaskPriority = TaskPriority::kUserVisible;\n  static constexpr TaskPriority kEfficiencyTaskPriority =\n      TaskPriority::kBestEffort;\n\n  OptimizingCompileInputQueue input_queue_;\n\n  // Copy of v8_flags.concurrent_recompilation_delay that will be used from the\n  // background thread.\n  //\n  // Since flags might get modified while the background thread is running, it\n  // is not safe to access them directly.\n  int recompilation_delay_;\n\n  std::unique_ptr<JobHandle> job_handle_;\n\n  base::OwnedVector<OptimizingCompileTaskState> task_states_;\n\n  // Used to avoid creating the JobHandle twice.\n  bool is_initialized_ = false;\n\n  friend class OptimizingCompileDispatcher;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OptimizingCompileOutputQueue\",\n                \"about\": \"A queue for compilation jobs that are ready to be installed.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"queue_\",\n                        \"type\": \"std::deque<TurbofanCompilationJob*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The queue of compilation jobs.\"\n                    },\n                    {\n                        \"name\": \"mutex_\",\n                        \"type\": \"base::Mutex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mutex to protect access to the queue.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TurbofanCompilationJob\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass OptimizingCompileOutputQueue {\n public:\n  void Enqueue(TurbofanCompilationJob* job);\n  std::unique_ptr<TurbofanCompilationJob> Dequeue();\n\n  int InstallGeneratedBuiltins(Isolate* isolate, int installed_count);\n\n  size_t size() const;\n  bool empty() const;\n\n private:\n  // Queue of recompilation tasks ready to be installed (excluding OSR).\n  std::deque<TurbofanCompilationJob*> queue_;\n\n  // Used for job based recompilation which has multiple producers on\n  // different threads.\n  base::Mutex mutex_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OptimizingCompileDispatcher\",\n                \"about\": \"An isolate-specific class to enqueue Turbofan compilation jobs and retrieve results.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The V8 Isolate associated with this dispatcher.\"\n                    },\n                    {\n                        \"name\": \"task_executor_\",\n                        \"type\": \"OptimizingCompileTaskExecutor*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The task executor used to run compilation jobs.\"\n                    },\n                    {\n                        \"name\": \"output_queue_\",\n                        \"type\": \"OptimizingCompileOutputQueue\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The output queue for completed compilation jobs.\"\n                    },\n                    {\n                        \"name\": \"finalize_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag to indicate whether to finalize and install the optimized code.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"OptimizingCompileTaskExecutor\",\n                    \"OptimizingCompileOutputQueue\",\n                    \"TurbofanCompilationJob\",\n                    \"SharedFunctionInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE OptimizingCompileDispatcher {\n public:\n  explicit OptimizingCompileDispatcher(\n      Isolate* isolate, OptimizingCompileTaskExecutor* task_executor);\n\n  ~OptimizingCompileDispatcher();\n\n  // Flushes input and output queue for compilation jobs. If blocking behavior\n  // is used, it will also wait until the running compilation jobs are done\n  // before flushing the output queue.\n  void Flush(BlockingBehavior blocking_behavior);\n\n  // Tries to append the compilation job to the input queue. Takes ownership of\n  // |job| if successful. Fails if the input queue is already full.\n  bool TryQueueForOptimization(std::unique_ptr<TurbofanCompilationJob>& job);\n\n  // Waits until all running and queued compilation jobs have finished.\n  void WaitUntilCompilationJobsDone();\n\n  void InstallOptimizedFunctions();\n\n  // Install generated builtins in the output queue in contiguous finalization\n  // order, starting with installed_count. Returns the finalization order of the\n  // last job that was finalized.\n  int InstallGeneratedBuiltins(int installed_count);\n\n  // Returns true if there is space available in the input queue.\n  inline bool IsQueueAvailable() { return input_queue().IsAvailable(); }\n\n  static bool Enabled() { return v8_flags.concurrent_recompilation; }\n\n  // This method must be called on the main thread.\n  bool HasJobs();\n\n  // Whether to finalize and thus install the optimized code.  Defaults to true.\n  // Only set to false for testing (where finalization is then manually\n  // requested using %FinalizeOptimization) and when compiling embedded builtins\n  // concurrently. For the latter, builtins are installed manually using\n  // InstallGeneratedBuiltins().\n  bool finalize() const { return finalize_; }\n  void set_finalize(bool finalize) {\n    CHECK(!HasJobs());\n    finalize_ = finalize;\n  }\n\n  void Prioritize(Tagged<SharedFunctionInfo> function);\n\n  void StartTearDown();\n  void FinishTearDown();\n\n  void QueueFinishedJob(TurbofanCompilationJob* job);\n\n private:\n  enum ModeFlag { COMPILE, FLUSH };\n\n  void FlushQueues(BlockingBehavior blocking_behavior);\n  void FlushInputQueue();\n  void FlushOutputQueue();\n\n  OptimizingCompileInputQueue& input_queue() {\n    return task_executor_->input_queue_;\n  }\n\n  int recompilation_delay() const {\n    return task_executor_->recompilation_delay_;\n  }\n\n  Isolate* isolate_;\n\n  OptimizingCompileTaskExecutor* task_executor_;\n\n  OptimizingCompileOutputQueue output_queue_;\n\n  bool finalize_ = true;\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Isolate\",\n                    \"about\": \"Represents a V8 isolate.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TurbofanCompilationJob\",\n                    \"about\": \"Represents a Turbofan compilation job.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class TurbofanCompilationJob;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RuntimeCallStats\",\n                    \"about\": \"Collects runtime call statistics.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class RuntimeCallStats;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SharedFunctionInfo\",\n                    \"about\": \"Stores shared information about a function.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class SharedFunctionInfo;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"LocalHeap\",\n                    \"about\": \"Represents a local heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class LocalHeap;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"LocalIsolate\",\n                    \"about\": \"Represents a local isolate.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class LocalIsolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JobHandle\",\n                    \"about\": \"Handle to manage background jobs.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class JobHandle;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"BlockingBehavior\",\n                    \"about\": \"Enum to define blocking behavior.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum BlockingBehavior;\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}