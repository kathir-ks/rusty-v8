{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/operation-typer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/operation-typer.cc\",\n            \"file_name\": \"operation-typer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the OperationTyper class, which is responsible for determining the types of operations in the Turbofan compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for compiler operations, type representation, heap access and object manipulation within the V8 engine.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/operation-typer.h\"\n\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/turbofan-types.h\"\n            #include \"src/compiler/type-cache.h\"\n            #include \"src/objects/oddball.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OperationTyper\",\n                \"about\": \"The OperationTyper class determines the types of operations in the Turbofan compiler.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The zone used for memory allocation.\"\n                    },\n                    {\n                        \"name\": \"cache_\",\n                        \"type\": \"TypeCache&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A cache of commonly used types.\"\n                    },\n                    {\n                        \"name\": \"infinity_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents positive infinity as a Type.\"\n                    },\n                    {\n                        \"name\": \"minus_infinity_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents negative infinity as a Type.\"\n                    },\n                    {\n                        \"name\": \"singleton_empty_string_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the empty string as a Type.\"\n                    },\n                    {\n                        \"name\": \"singleton_NaN_string_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the NaN string as a Type.\"\n                    },\n                    {\n                        \"name\": \"singleton_zero_string_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the zero string as a Type.\"\n                    },\n                    {\n                        \"name\": \"singleton_false_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the false value as a Type.\"\n                    },\n                    {\n                        \"name\": \"singleton_true_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the true value as a Type.\"\n                    },\n                    {\n                        \"name\": \"signed32ish_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the union of Signed32 and truncating to zero as a Type.\"\n                    },\n                    {\n                        \"name\": \"unsigned32ish_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the union of Unsigned32 and truncating to zero as a Type.\"\n                    },\n                    {\n                        \"name\": \"falsish_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents a Type that evaluates to false in a boolean context.\"\n                    },\n                    {\n                        \"name\": \"truish_\",\n                        \"type\": \"Type\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents a Type that evaluates to true in a boolean context.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"Zone\",\n                    \"TypeCache\",\n                    \"Type\",\n                    \"V8_INFINITY\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            namespace internal {\n            namespace compiler {\n\n            class OperationTyper {\n            public:\n                OperationTyper(JSHeapBroker* broker, Zone* zone);\n\n                Type Merge(Type left, Type right);\n                Type WeakenRange(Type previous_range, Type current_range);\n                Type Rangify(Type type);\n                Type AddRanger(double lhs_min, double lhs_max, double rhs_min,\n                                   double rhs_max);\n                Type SubtractRanger(double lhs_min, double lhs_max,\n                                        double rhs_min, double rhs_max);\n                Type MultiplyRanger(double lhs_min, double lhs_max,\n                                        double rhs_min, double rhs_max);\n                Type ConvertReceiver(Type type);\n                Type ToNumber(Type type);\n                Type ToNumberConvertBigInt(Type type);\n                Type ToBigInt(Type type);\n                Type ToBigIntConvertNumber(Type type);\n                Type ToNumeric(Type type);\n                Type NumberAbs(Type type);\n                Type NumberAcos(Type type);\n                Type NumberAcosh(Type type);\n                Type NumberAsin(Type type);\n                Type NumberAsinh(Type type);\n                Type NumberAtan(Type type);\n                Type NumberAtanh(Type type);\n                Type NumberCbrt(Type type);\n                Type NumberCeil(Type type);\n                Type NumberClz32(Type type);\n                Type NumberCos(Type type);\n                Type NumberCosh(Type type);\n                Type NumberExp(Type type);\n                Type NumberExpm1(Type type);\n                Type NumberFloor(Type type);\n                Type NumberFround(Type type);\n                Type NumberLog(Type type);\n                Type NumberLog1p(Type type);\n                Type NumberLog2(Type type);\n                Type NumberLog10(Type type);\n                Type NumberRound(Type type);\n                Type NumberSign(Type type);\n                Type NumberSin(Type type);\n                Type NumberSinh(Type type);\n                Type NumberSqrt(Type type);\n                Type NumberTan(Type type);\n                Type NumberTanh(Type type);\n                Type NumberTrunc(Type type);\n                Type NumberToBoolean(Type type);\n                Type NumberToInt32(Type type);\n                Type NumberToString(Type type);\n                Type NumberToUint32(Type type);\n                Type NumberToUint8Clamped(Type type);\n                Type Integral32OrMinusZeroToBigInt(Type type);\n                Type NumberSilenceNaN(Type type);\n                Type SpeculativeBigIntAsIntN(Type);\n                Type SpeculativeBigIntAsUintN(Type);\n                Type CheckBigInt(Type type);\n                Type CheckedBigIntToBigInt64(Type type);\n                Type NumberAdd(Type lhs, Type rhs);\n                Type NumberSubtract(Type lhs, Type rhs);\n                Type SpeculativeAdditiveSafeIntegerAdd(Type lhs, Type rhs);\n                Type SpeculativeAdditiveSafeIntegerSubtract(Type lhs,\n                                                                    Type rhs);\n                Type SpeculativeSmallIntegerAdd(Type lhs, Type rhs);\n                Type SpeculativeSmallIntegerSubtract(Type lhs, Type rhs);\n                Type NumberMultiply(Type lhs, Type rhs);\n                Type NumberDivide(Type lhs, Type rhs);\n                Type NumberModulus(Type lhs, Type rhs);\n                Type NumberBitwiseOr(Type lhs, Type rhs);\n                Type NumberBitwiseAnd(Type lhs, Type rhs);\n                Type NumberBitwiseXor(Type lhs, Type rhs);\n                Type NumberShiftLeft(Type lhs, Type rhs);\n                Type NumberShiftRight(Type lhs, Type rhs);\n                Type NumberShiftRightLogical(Type lhs, Type rhs);\n                Type NumberAtan2(Type lhs, Type rhs);\n                Type NumberImul(Type lhs, Type rhs);\n                Type NumberMax(Type lhs, Type rhs);\n                Type NumberMin(Type lhs, Type rhs);\n                Type NumberPow(Type lhs, Type rhs);\n                Type SpeculativeNumberAdd(Type lhs, Type rhs);\n                Type SpeculativeNumberSubtract(Type lhs, Type rhs);\n                Type SpeculativeNumberMultiply(Type lhs, Type rhs);\n                Type SpeculativeNumberPow(Type lhs, Type rhs);\n                Type SpeculativeNumberDivide(Type lhs, Type rhs);\n                Type SpeculativeNumberModulus(Type lhs, Type rhs);\n                Type SpeculativeNumberBitwiseOr(Type lhs, Type rhs);\n                Type SpeculativeNumberBitwiseAnd(Type lhs, Type rhs);\n                Type SpeculativeNumberBitwiseXor(Type lhs, Type rhs);\n                Type SpeculativeNumberShiftLeft(Type lhs, Type rhs);\n                Type SpeculativeNumberShiftRight(Type lhs, Type rhs);\n                Type SpeculativeNumberShiftRightLogical(Type lhs, Type rhs);\n                Type ChangeUint32ToUint64(Type input);\n                Type BigIntAdd(Type lhs, Type rhs);\n                Type BigIntSubtract(Type lhs, Type rhs);\n                Type BigIntMultiply(Type lhs, Type rhs);\n                Type BigIntDivide(Type lhs, Type rhs);\n                Type BigIntModulus(Type lhs, Type rhs);\n                Type BigIntBitwiseAnd(Type lhs, Type rhs);\n                Type BigIntBitwiseOr(Type lhs, Type rhs);\n                Type BigIntBitwiseXor(Type lhs, Type rhs);\n                Type BigIntShiftLeft(Type lhs, Type rhs);\n                Type BigIntShiftRight(Type lhs, Type rhs);\n                Type BigIntNegate(Type type);\n                Type SpeculativeBigIntAdd(Type lhs, Type rhs);\n                Type SpeculativeBigIntSubtract(Type lhs, Type rhs);\n                Type SpeculativeBigIntMultiply(Type lhs, Type rhs);\n                Type SpeculativeBigIntDivide(Type lhs, Type rhs);\n                Type SpeculativeBigIntModulus(Type lhs, Type rhs);\n                Type SpeculativeBigIntBitwiseAnd(Type lhs, Type rhs);\n                Type SpeculativeBigIntBitwiseOr(Type lhs, Type rhs);\n                Type SpeculativeBigIntBitwiseXor(Type lhs, Type rhs);\n                Type SpeculativeBigIntShiftLeft(Type lhs, Type rhs);\n                Type SpeculativeBigIntShiftRight(Type lhs, Type rhs);\n                Type SpeculativeBigIntNegate(Type type);\n                Type SpeculativeToBigInt(Type type);\n                Type SpeculativeToNumber(Type type);\n                Type ToPrimitive(Type type);\n                Type Invert(Type type);\n                ComparisonOutcome Invert(ComparisonOutcome outcome);\n                Type FalsifyUndefined(ComparisonOutcome outcome);\n                Type SameValue(Type lhs, Type rhs);\n                Type SameValueNumbersOnly(Type lhs, Type rhs);\n                Type StrictEqual(Type lhs, Type rhs);\n                Type CheckBounds(Type index, Type length);\n                Type CheckFloat64Hole(Type type);\n                Type CheckNumber(Type type);\n                Type CheckNumberFitsInt32(Type type);\n                Type TypeTypeGuard(const Operator* sigma_op, Type input);\n                Type ConvertTaggedHoleToUndefined(Type input);\n                Type ToBoolean(Type type);\n\n            private:\n                Zone* zone() const { return zone_; }\n\n                TypeGuardOf TypeGuardTypeOf(const Operator* op) {\n                    return op->ValueInput<TypeGuardOf>();\n                }\n\n                Zone* zone_;\n                TypeCache& cache_;\n                Type infinity_;\n                Type minus_infinity_;\n                Type singleton_empty_string_;\n                Type singleton_NaN_string_;\n                Type singleton_zero_string_;\n                Type singleton_false_;\n                Type singleton_true_;\n                Type signed32ish_;\n                Type unsigned32ish_;\n\n                Type falsish_;\n                Type truish_;\n            };\n\n            }  // namespace compiler\n            }  // namespace internal\n            }  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"OperationTyper\",\n                \"parent\": \"OperationTyper\",\n                \"about\": \"Constructor for the OperationTyper class.\",\n                \"logic\": \"Initializes the OperationTyper with a JSHeapBroker and a Zone.  It predefines several commonly used types as constants for faster access and type unioning.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker used to access heap objects.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The Zone used for memory allocation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"Zone\",\n                    \"TypeCache\",\n                    \"Type\",\n                    \"V8_INFINITY\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            OperationTyper::OperationTyper(JSHeapBroker* broker, Zone* zone)\n                : zone_(zone), cache_(TypeCache::Get()) {\n            infinity_ = Type::Constant(V8_INFINITY, zone);\n            minus_infinity_ = Type::Constant(-V8_INFINITY, zone);\n            Type truncating_to_zero = Type::MinusZeroOrNaN();\n            DCHECK(!truncating_to_zero.Maybe(Type::Integral32()));\n\n            singleton_empty_string_ =\n                Type::Constant(broker, broker->empty_string(), zone);\n            singleton_NaN_string_ = Type::Constant(broker, broker->NaN_string(), zone);\n            singleton_zero_string_ = Type::Constant(broker, broker->zero_string(), zone);\n            singleton_false_ = Type::Constant(broker, broker->false_value(), zone);\n            singleton_true_ = Type::Constant(broker, broker->true_value(), zone);\n            signed32ish_ = Type::Union(Type::Signed32(), truncating_to_zero, zone);\n            unsigned32ish_ = Type::Union(Type::Unsigned32(), truncating_to_zero, zone);\n\n            falsish_ = Type::Union(\n                Type::Undetectable(),\n                Type::Union(Type::Union(singleton_false_, cache_->kZeroish, zone),\n                            singleton_empty_string_, zone),\n                zone);\n            truish_ = Type::Union(\n                singleton_true_,\n                Type::Union(Type::DetectableReceiver(), Type::Symbol(), zone), zone);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Merge\",\n                \"parent\": \"OperationTyper\",\n                \"about\": \"Merges two types by creating a union of them.\",\n                \"logic\": \"Calls Type::Union to create the union type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"left\",\n                        \"type\": \"Type\",\n                        \"purpose\": \"The first type to merge.\"\n                    },\n                    {\n                        \"name\": \"right\",\n                        \"type\": \"Type\",\n                        \"purpose\": \"The second type to merge.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type\",\n                    \"description\": \"The union of the two input types.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Type OperationTyper::Merge(Type left, Type right) {\n            return Type::Union(left, right, zone());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"WeakenRange\",\n                \"parent\": \"OperationTyper\",\n                \"about\": \"Weakens a numeric range type by rounding its boundaries to predefined limits.\",\n                \"logic\": \"The function iterates through predefined minimum and maximum limits to find the closest allowed boundaries for the given range, weakening the range if necessary.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"previous_range\",\n                        \"type\": \"Type\",\n                        \"purpose\": \"The previous range type.\"\n                    },\n                    {\n                        \"name\": \"current_range\",\n                        \"type\": \"Type\",\n                        \"purpose\": \"The current range type to weaken.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type\",\n                    \"description\": \"The weakened range type.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"V8_INFINITY\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Type OperationTyper::WeakenRange(Type previous_range, Type current_range) {\n            static const double kWeakenMinLimits[] = {0.0,\n                                                        -1073741824.0,\n                                                        -2147483648.0,\n                                                        -4294967296.0,\n                                                        -8589934592.0,\n                                                        -17179869184.0,\n                                                        -34359738368.0,\n                                                        -68719476736.0,\n                                                        -137438953472.0,\n                                                        -274877906944.0,\n                                                        -549755813888.0,\n                                                        -1099511627776.0,\n                                                        -2199023255552.0,\n                                                        -4398046511104.0,\n                                                        -8796093022208.0,\n                                                        -17592186044416.0,\n                                                        -35184372088832.0,\n                                                        -70368744177664.0,\n                                                        -140737488355328.0,\n                                                        -281474976710656.0,\n                                                        -562949953421312.0};\n            static const double kWeakenMaxLimits[] = {0.0,\n                                                        1073741823.0,\n                                                        2147483647.0,\n                                                        4294967295.0,\n                                                        8589934591.0,\n                                                        17179869183.0,\n                                                        34359738367.0,\n                                                        68719476735.0,\n                                                        137438953471.0,\n                                                        274877906943.0,\n                                                        549755813887.0,\n                                                        1099511627775.0,\n                                                        2199023255551.0,\n                                                        4398046511103.0,\n                                                        8796093022207.0,\n                                                        17592186044415.0,\n                                                        35184372088831.0,\n                                                        70368744177663.0,\n                                                        140737488355327.0,\n                                                        281474976710655.0,\n                                                        562949953421311.0};\n            static_assert(arraysize(kWeakenMinLimits) == arraysize(kWeakenMaxLimits));\n\n            double current_min = current_range.Min();\n            double new_min = current_min;\n            // Find the closest lower entry in the list of allowed\n            // minima (or negative infinity if there is no such entry).\n            if (current_min != previous_range.Min()) {\n                new_min = -V8_INFINITY;\n                for (double const min : kWeakenMinLimits) {\n                if (min <= current_min) {\n                    new_min = min;\n                    break;\n                }\n                }\n            }\n\n            double current_max = current_range.Max();\n            double new_max = current_max;\n            // Find the closest greater entry in the list of allowed\n            // maxima (or infinity if there is no such entry).\n            if (current_max != previous_range.Max()) {\n                new_max = V8_INFINITY;\n                for (double const max : kWeakenMaxLimits) {\n                if (max >= current_max) {\n                    new_max = max;\n                    break;\n                }\n                }\n            }\n\n            return Type::Range(new_min, new_max, zone());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Rangify\",\n                \"parent\": \"OperationTyper\",\n                \"about\": \"Converts a Type to a Range Type if it is an integer.\",\n                \"logic\": \"If the given type is already a range or is not an integer, it is returned as is. Otherwise, it creates a range type with the min and max values of the input type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"Type\",\n                        \"purpose\": \"The type to be converted to a range.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type\",\n                    \"description\": \"The range type if the input was an integer, otherwise the original type.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"TypeCache\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Type OperationTyper::Rangify(Type type) {\n            if (type.IsRange()) return type;  // Shortcut.\n            if (!type.Is(cache_->kInteger)) {\n                return type;  // Give up on non-integer types.\n            }\n            return Type::Range(type.Min(), type.Max(), zone());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"array_min\",\n                \"parent\": null,\n                \"about\": \"Helper function to find the minimum value in a double array, ignoring NaN values.\",\n                \"logic\": \"Iterates through the array, tracking the minimum non-NaN value. Converts -0 to 0.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"double[]\",\n                        \"purpose\": \"The array to find the minimum in.\"\n                    },\n                    {\n                        \"name\": \"n\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The size of the array.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"double\",\n                    \"description\": \"The minimum non-NaN value in the array.\"\n                },\n                \"dependencies\": [\n                    \"V8_INFINITY\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n\n            // Returns the array's least element, ignoring NaN.\n            // There must be at least one non-NaN element.\n            // Any -0 is converted to 0.\n            double array_min(double a[], size_t n) {\n            DCHECK_NE(0, n);\n            double x = +V8_INFINITY;\n            for (size_t i = 0; i < n; ++i) {\n                if (!std::isnan(a[i])) {\n                x = std::min(a[i], x);\n                }\n            }\n            DCHECK(!std::isnan(x));\n            return x == 0 ? 0 : x;  // -0 -> 0\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"array_max\",\n                \"parent\": null,\n                \"about\": \"Helper function to find the maximum value in a double array, ignoring NaN values.\",\n                \"logic\": \"Iterates through the array, tracking the maximum non-NaN value. Converts -0 to 0.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"double[]\",\n                        \"purpose\": \"The array to find the maximum in.\"\n                    },\n                    {\n                        \"name\": \"n\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The size of the array.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"double\",\n                    \"description\": \"The maximum non-NaN value in the array.\"\n                },\n                \"dependencies\": [\n                    \"V8_INFINITY\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // Returns the array's greatest element, ignoring NaN.\n            // There must be at least one non-NaN element.\n            // Any -0 is converted to 0.\n            double array_max(double a[], size_t n) {\n            DCHECK_NE(0, n);\n            double x = -V8_INFINITY;\n            for (size_t i = 0; i < n; ++i) {\n                if (!std::isnan(a[i])) {\n                x = std::max(a[i], x);\n                }\n            }\n            DCHECK(!std::isnan(x));\n            return x == 0 ? 0 : x;  // -0 -> 0\n            }\n\n            }  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddRanger\",\n                \"parent\": \"OperationTyper\",\n                \"about\": \"Calculates the range type resulting from the addition of two range types.\",\n                \"logic\": \"Calculates all four possible sums of the minimum and maximum values of the two ranges.  If the result may contain NaN, it is unioned with the NaN type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs_min\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The minimum value of the left-hand side range.\"\n                    },\n                    {\n                        \"name\": \"lhs_max\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The maximum value of the left-hand side range.\"\n                    },\n                    {\n                        \"name\": \"rhs_min\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The minimum value of the right-hand side range.\"\n                    },\n                    {\n                        \"name\": \"rhs_max\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The maximum value of the right-hand side range.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type\",\n                    \"description\": \"The resulting range type after addition.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"array_min\",\n                    \"array_max\",\n                    \"V8_INFINITY\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Type OperationTyper::AddRanger(double lhs_min, double lhs_max, double rhs_min,\n                                    double rhs_max) {\n            double results[4];\n            results[0] = lhs_min + rhs_min;\n            results[1] = lhs_min + rhs_max;\n            results[2] = lhs_max + rhs_min;\n            results[3] = lhs_max + rhs_max;\n            // Since none of the inputs can be -0, the result cannot be -0 either.\n            // However, it can be nan (the sum of two infinities of opposite sign).\n            // On the other hand, if none of the \"results\" above is nan, then the\n            // actual result cannot be nan either.\n            int nans = 0;\n            for (int i = 0; i < 4; ++i) {\n                if (std::isnan(results[i])) ++nans;\n            }\n            if (nans == 4) return Type::NaN();\n            Type type = Type::Range(array_min(results, 4), array_max(results, 4), zone());\n            if (nans > 0) type = Type::Union(type, Type::NaN(), zone());\n            // Examples:\n            //   [-inf, -inf] + [+inf, +inf] = NaN\n            //   [-inf, -inf] + [n, +inf] = [-inf, -inf] \\/ NaN\n            //   [-inf, +inf] + [n, +inf] = [-inf, +inf] \\/ NaN\n            //   [-inf, m] + [n, +inf] = [-inf, +inf] \\/ NaN\n            return type;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SubtractRanger\",\n                \"parent\": \"OperationTyper\",\n                \"about\": \"Calculates the range type resulting from the subtraction of two range types.\",\n                \"logic\": \"Calculates all four possible differences of the minimum and maximum values of the two ranges.  If the result may contain NaN, it is unioned with the NaN type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs_min\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The minimum value of the left-hand side range.\"\n                    },\n                    {\n                        \"name\": \"lhs_max\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The maximum value of the left-hand side range.\"\n                    },\n                    {\n                        \"name\": \"rhs_min\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The minimum value of the right-hand side range.\"\n                    },\n                    {\n                        \"name\": \"rhs_max\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The maximum value of the right-hand side range.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type\",\n                    \"description\": \"The resulting range type after subtraction.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"array_min\",\n                    \"array_max\",\n                    \"V8_INFINITY\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Type OperationTyper::SubtractRanger(double lhs_min, double lhs_max,\n                                        double rhs_min, double rhs_max) {\n            double results[4];\n            results[0] = lhs_min - rhs_min;\n            results[1] = lhs_min - rhs_max;\n            results[2] = lhs_max - rhs_min;\n            results[3] = lhs_max - rhs_max;\n            // Since none of the inputs can be -0, the result cannot be -0.\n            // However, it can be nan (the subtraction of two infinities of same sign).\n            // On the other hand, if none of the \"results\" above is nan, then the actual\n            // result cannot be nan either.\n            int nans = 0;\n            for (int i = 0; i < 4; ++i) {\n                if (std::isnan(results[i])) ++nans;\n            }\n            if (nans == 4) return Type::NaN();  // [inf..inf] - [inf..inf] (all same sign)\n            Type type = Type::Range(array_min(results, 4), array_max(results, 4), zone());\n            return nans == 0 ? type : Type::Union(type, Type::NaN(), zone());\n            // Examples:\n            //   [-inf, +inf] - [-inf, +inf] = [-inf, +inf] \\/ NaN\n            //   [-inf, -inf] - [-inf, -inf] = NaN\n            //   [-inf, -inf] - [n, +inf] = [-inf, -inf] \\/ NaN\n            //   [m, +inf] - [-inf, n] = [-inf, +inf] \\/ NaN\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MultiplyRanger\",\n                \"parent\": \"OperationTyper\",\n                \"about\": \"Calculates the range type resulting from the multiplication of two range types.\",\n                \"logic\": \"Calculates all four possible products of the minimum and maximum values of the two ranges.  If the result may contain NaN, it returns kIntegerOrMinusZeroOrNaN. If -0 might be a result, it's added as a union.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs_min\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The minimum value of the left-hand side range.\"\n                    },\n                    {\n                        \"name\": \"lhs_max\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The maximum value of the left-hand side range.\"\n                    },\n                    {\n                        \"name\": \"rhs_min\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The minimum value of the right-hand side range.\"\n                    },\n                    {\n                        \"name\": \"rhs_max\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The maximum value of the right-hand side range.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type\",\n                    \"description\": \"The resulting range type after multiplication.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"TypeCache\",\n                    \"array_min\","
}