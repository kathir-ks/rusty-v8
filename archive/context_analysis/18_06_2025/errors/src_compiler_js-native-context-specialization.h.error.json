{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-native-context-specialization.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-native-context-specialization.h\",\n            \"file_name\": \"js-native-context-specialization.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the JSNativeContextSpecialization class, which specializes a JSGraph to a given native context, performing constant folding and strength reduction.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for optional, flags, graph assembly, graph reduction, heap broker, deoptimization reasons, and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/flags.h\"\n#include \"src/compiler/graph-assembler.h\"\n#include \"src/compiler/graph-reducer.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/deoptimizer/deoptimize-reason.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSNativeContextSpecialization\",\n                \"extends\": \"AdvancedReducer\",\n                \"about\": \"Specializes a given JSGraph to a given native context, potentially constant folding some {LoadGlobal} nodes or strength reducing some {StoreGlobal} nodes. And also specializes {LoadNamed} and {SetNamedProperty} nodes according to type feedback (if available).\",\n                \"attributes\": [\n                    {\n                        \"name\": \"jsgraph_\",\n                        \"type\": \"JSGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSGraph being specialized.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSHeapBroker used for accessing heap objects.\"\n                    },\n                    {\n                        \"name\": \"flags_\",\n                        \"type\": \"Flags\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flags that control the mode of operation.\"\n                    },\n                    {\n                        \"name\": \"global_object_\",\n                        \"type\": \"Handle<JSGlobalObject>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handle to the JSGlobalObject.\"\n                    },\n                    {\n                        \"name\": \"global_proxy_\",\n                        \"type\": \"Handle<JSGlobalProxy>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Handle to the JSGlobalProxy.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the zone used for allocating memory.\"\n                    },\n                    {\n                        \"name\": \"shared_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the shared zone used for allocating memory.\"\n                    },\n                    {\n                        \"name\": \"type_cache_\",\n                        \"type\": \"TypeCache const*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to type cache\"\n                    },\n                    {\n                        \"name\": \"created_strings_\",\n                        \"type\": \"ZoneUnorderedSet<IndirectHandle<String>, IndirectHandle<String>::hash, IndirectHandle<String>::equal_to>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores created strings.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"JSGraph\",\n                    \"JSHeapBroker\",\n                    \"CompilationDependencies\",\n                    \"Zone\",\n                    \"JSGlobalObject\",\n                    \"JSGlobalProxy\",\n                    \"CommonOperatorBuilder\",\n                    \"JSOperatorBuilder\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"TypeCache\",\n                    \"Node\",\n                    \"NameRef\",\n                    \"OptionalNameRef\",\n                    \"FeedbackSource\",\n                    \"PropertyCellRef\",\n                    \"ElementAccessFeedback\",\n                    \"NamedAccessFeedback\",\n                    \"MegaDOMPropertyAccessFeedback\",\n                    \"KeyedAccessMode\",\n                    \"MapRef\",\n                    \"HeapObjectRef\",\n                    \"FunctionTemplateInfoRef\",\n                    \"Effect\",\n                    \"Isolate\",\n                    \"Factory\",\n                    \"NativeContextRef\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE JSNativeContextSpecialization final\n    : public AdvancedReducer {\n public:\n  // Flags that control the mode of operation.\n  enum Flag {\n    kNoFlags = 0u,\n    kBailoutOnUninitialized = 1u << 0,\n  };\n  using Flags = base::Flags<Flag>;\n\n  JSNativeContextSpecialization(Editor* editor, JSGraph* jsgraph,\n                                JSHeapBroker* broker, Flags flags, Zone* zone,\n                                Zone* shared_zone);\n  JSNativeContextSpecialization(const JSNativeContextSpecialization&) = delete;\n  JSNativeContextSpecialization& operator=(\n      const JSNativeContextSpecialization&) = delete;\n\n  const char* reducer_name() const override {\n    return \"JSNativeContextSpecialization\";\n  }\n\n  Reduction Reduce(Node* node) final;\n\n  // Utility for folding string constant concatenation.\n  // Supports JSAdd nodes and nodes typed as string or number.\n  // Public for the sake of unit testing.\n  static std::optional<size_t> GetMaxStringLength(JSHeapBroker* broker,\n                                                  Node* node);\n\n private:\n  Reduction ReduceJSAdd(Node* node);\n  Reduction ReduceJSAsyncFunctionEnter(Node* node);\n  Reduction ReduceJSAsyncFunctionReject(Node* node);\n  Reduction ReduceJSAsyncFunctionResolve(Node* node);\n  Reduction ReduceJSGetSuperConstructor(Node* node);\n  Reduction ReduceJSFindNonDefaultConstructorOrConstruct(Node* node);\n  Reduction ReduceJSInstanceOf(Node* node);\n  Reduction ReduceJSHasInPrototypeChain(Node* node);\n  Reduction ReduceJSOrdinaryHasInstance(Node* node);\n  Reduction ReduceJSPromiseResolve(Node* node);\n  Reduction ReduceJSResolvePromise(Node* node);\n  Reduction ReduceJSLoadGlobal(Node* node);\n  Reduction ReduceJSStoreGlobal(Node* node);\n  Reduction ReduceJSLoadNamed(Node* node);\n  Reduction ReduceJSLoadNamedFromSuper(Node* node);\n  Reduction ReduceJSGetIterator(Node* node);\n  Reduction ReduceJSSetNamedProperty(Node* node);\n  Reduction ReduceJSHasProperty(Node* node);\n  Reduction ReduceJSLoadProperty(Node* node);\n  Reduction ReduceJSSetKeyedProperty(Node* node);\n  Reduction ReduceJSDefineKeyedOwnProperty(Node* node);\n  Reduction ReduceJSDefineNamedOwnProperty(Node* node);\n  Reduction ReduceJSDefineKeyedOwnPropertyInLiteral(Node* node);\n  Reduction ReduceJSStoreInArrayLiteral(Node* node);\n  Reduction ReduceJSToObject(Node* node);\n\n  Reduction ReduceElementAccess(Node* node, Node* index, Node* value,\n                                ElementAccessFeedback const& feedback);\n  // In the case of non-keyed (named) accesses, pass the name as {static_name}\n  // and use {nullptr} for {key} (load/store modes are irrelevant).\n  Reduction ReducePropertyAccess(Node* node, Node* key,\n                                 OptionalNameRef static_name, Node* value,\n                                 FeedbackSource const& source,\n                                 AccessMode access_mode);\n  Reduction ReduceNamedAccess(Node* node, Node* value,\n                              NamedAccessFeedback const& feedback,\n                              AccessMode access_mode, Node* key = nullptr);\n  Reduction ReduceMegaDOMPropertyAccess(\n      Node* node, Node* value, MegaDOMPropertyAccessFeedback const& feedback,\n      FeedbackSource const& source);\n  Reduction ReduceGlobalAccess(Node* node, Node* lookup_start_object,\n                               Node* receiver, Node* value, NameRef name,\n                               AccessMode access_mode, Node* key,\n                               PropertyCellRef property_cell,\n                               Node* effect = nullptr);\n  Reduction ReduceElementLoadFromHeapConstant(Node* node, Node* key,\n                                              AccessMode access_mode,\n                                              KeyedAccessLoadMode load_mode);\n  Reduction ReduceElementAccessOnString(Node* node, Node* index, Node* value,\n                                        KeyedAccessMode const& keyed_mode);\n\n  Reduction ReduceEagerDeoptimize(Node* node, DeoptimizeReason reason);\n  Reduction ReduceJSToString(Node* node);\n\n  Reduction ReduceJSLoadPropertyWithEnumeratedKey(Node* node);\n\n  Handle<String> CreateStringConstant(Node* node);\n\n  // A triple of nodes that represents a continuation.\n  class ValueEffectControl final {\n   public:\n    ValueEffectControl()\n        : value_(nullptr), effect_(nullptr), control_(nullptr) {}\n    ValueEffectControl(Node* value, Node* effect, Node* control)\n        : value_(value), effect_(effect), control_(control) {}\n\n    Node* value() const { return value_; }\n    Node* effect() const { return effect_; }\n    Node* control() const { return control_; }\n\n   private:\n    Node* value_;\n    Node* effect_;\n    Node* control_;\n  };\n\n  // Construct the appropriate subgraph for property access. Return {} if the\n  // property access couldn't be built.\n  std::optional<ValueEffectControl> BuildPropertyAccess(\n      Node* lookup_start_object, Node* receiver, Node* value, Node* context,\n      Node* frame_state, Node* effect, Node* control, NameRef name,\n      ZoneVector<Node*>* if_exceptions, PropertyAccessInfo const& access_info,\n      AccessMode access_mode);\n  std::optional<ValueEffectControl> BuildPropertyLoad(\n      Node* lookup_start_object, Node* receiver, Node* context,\n      Node* frame_state, Node* effect, Node* control, NameRef name,\n      ZoneVector<Node*>* if_exceptions, PropertyAccessInfo const& access_info);\n\n  ValueEffectControl BuildPropertyStore(Node* receiver, Node* value,\n                                        Node* context, Node* frame_state,\n                                        Node* effect, Node* control,\n                                        NameRef name,\n                                        ZoneVector<Node*>* if_exceptions,\n                                        PropertyAccessInfo const& access_info,\n                                        AccessMode access_mode);\n\n  ValueEffectControl BuildPropertyTest(Node* effect, Node* control,\n                                       PropertyAccessInfo const& access_info);\n\n  // Helpers for accessor inlining.\n  Node* InlinePropertyGetterCall(Node* receiver,\n                                 ConvertReceiverMode receiver_mode,\n                                 Node* lookup_start_object, Node* context,\n                                 Node* frame_state, Node** effect,\n                                 Node** control,\n                                 ZoneVector<Node*>* if_exceptions,\n                                 PropertyAccessInfo const& access_info);\n  void InlinePropertySetterCall(Node* receiver, Node* value, Node* context,\n                                Node* frame_state, Node** effect,\n                                Node** control,\n                                ZoneVector<Node*>* if_exceptions,\n                                PropertyAccessInfo const& access_info);\n  Node* InlineApiCall(Node* receiver, Node* frame_state, Node* value,\n                      Node** effect, Node** control,\n                      FunctionTemplateInfoRef function_template_info,\n                      const FeedbackSource& feedback);\n\n  // Construct the appropriate subgraph for element access.\n  ValueEffectControl BuildElementAccess(Node* receiver, Node* index,\n                                        Node* value, Node* effect,\n                                        Node* control, Node* context,\n                                        ElementAccessInfo const& access_info,\n                                        KeyedAccessMode const& keyed_mode);\n  ValueEffectControl BuildElementAccessForTypedArrayOrRabGsabTypedArray(\n      Node* receiver, Node* index, Node* value, Node* effect, Node* control,\n      Node* context, ElementsKind elements_kind,\n      KeyedAccessMode const& keyed_mode);\n\n  // Construct appropriate subgraph to load from a String.\n  Node* BuildIndexedStringLoad(Node* receiver, Node* index, Node* length,\n                               Node** effect, Node** control,\n                               KeyedAccessLoadMode load_mode);\n\n  // Construct appropriate subgraph to extend properties backing store.\n  Node* BuildExtendPropertiesBackingStore(MapRef map, Node* properties,\n                                          Node* effect, Node* control);\n\n  // Construct appropriate subgraph to check that the {value} matches\n  // the previously recorded {name} feedback.\n  Node* BuildCheckEqualsName(NameRef name, Node* value, Node* effect,\n                             Node* control);\n\n  // Concatenates {left} and {right}.\n  Handle<String> Concatenate(Handle<String> left, Handle<String> right);\n\n  // Returns true if {str} can safely be read:\n  //   - if we are on the main thread, then any string can safely be read\n  //   - in the background, we can only read some string shapes, except if we\n  //     created the string ourselves.\n  // {node} is the node from which we got {str}, but which is still taken as\n  // parameter to simplify the checks.\n  bool StringCanSafelyBeRead(Node* const node, Handle<String> str);\n\n  // Checks if we can turn the hole into undefined when loading an element\n  // from an object with one of the {receiver_maps}; sets up appropriate\n  // code dependencies and might use the array protector cell.\n  bool CanTreatHoleAsUndefined(ZoneVector<MapRef> const& receiver_maps);\n\n  void RemoveImpossibleMaps(Node* object, ZoneVector<MapRef>* maps) const;\n\n  ElementAccessFeedback const& TryRefineElementAccessFeedback(\n      ElementAccessFeedback const& feedback, Node* receiver,\n      Effect effect) const;\n\n  // Try to infer maps for the given {object} at the current {effect}.\n  bool InferMaps(Node* object, Effect effect, ZoneVector<MapRef>* maps) const;\n\n  // Try to infer a root map for the {object} independent of the current program\n  // location.\n  OptionalMapRef InferRootMap(Node* object) const;\n\n  // Checks if we know at compile time that the {receiver} either definitely\n  // has the {prototype} in it's prototype chain, or the {receiver} definitely\n  // doesn't have the {prototype} in it's prototype chain.\n  enum InferHasInPrototypeChainResult {\n    kIsInPrototypeChain,\n    kIsNotInPrototypeChain,\n    kMayBeInPrototypeChain\n  };\n  InferHasInPrototypeChainResult InferHasInPrototypeChain(\n      Node* receiver, Effect effect, HeapObjectRef prototype);\n\n  Node* BuildLoadPrototypeFromObject(Node* object, Node* effect, Node* control);\n\n  std::pair<Node*, Node*> ReleaseEffectAndControlFromAssembler(\n      JSGraphAssembler* assembler);\n\n  TFGraph* graph() const;\n  JSGraph* jsgraph() const { return jsgraph_; }\n\n  JSHeapBroker* broker() const { return broker_; }\n  Isolate* isolate() const;\n  Factory* factory() const;\n  CommonOperatorBuilder* common() const;\n  JSOperatorBuilder* javascript() const;\n  SimplifiedOperatorBuilder* simplified() const;\n  Flags flags() const { return flags_; }\n  DirectHandle<JSGlobalObject> global_object() const { return global_object_; }\n  DirectHandle<JSGlobalProxy> global_proxy() const { return global_proxy_; }\n  NativeContextRef native_context() const {\n    return broker()->target_native_context();\n  }\n  CompilationDependencies* dependencies() const {\n    return broker()->dependencies();\n  }\n  Zone* zone() const { return zone_; }\n  Zone* shared_zone() const { return shared_zone_; }\n\n  JSGraph* const jsgraph_;\n  JSHeapBroker* const broker_;\n  Flags const flags_;\n  Handle<JSGlobalObject> global_object_;\n  Handle<JSGlobalProxy> global_proxy_;\n  Zone* const zone_;\n  Zone* const shared_zone_;\n  TypeCache const* type_cache_;\n  ZoneUnorderedSet<IndirectHandle<String>, IndirectHandle<String>::hash,\n                   IndirectHandle<String>::equal_to>\n      created_strings_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"reducer_name\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Returns the name of the reducer.\",\n                \"logic\": \"Simply returns the string \\\"JSNativeContextSpecialization\\\".\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"const char*\",\n                    \"description\": \"The name of the reducer.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  const char* reducer_name() const override {\n    return \"JSNativeContextSpecialization\";\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reduce\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a given node.\",\n                \"logic\": \"This is the main entry point for the reducer. It dispatches to other Reduce methods based on the node's operator.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction Reduce(Node* node) final;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetMaxStringLength\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Utility for folding string constant concatenation.  Supports JSAdd nodes and nodes typed as string or number.  Public for the sake of unit testing.\",\n                \"logic\": \"Calculates the maximum string length by inspecting the node type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The heap broker.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to inspect.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<size_t>\",\n                    \"description\": \"The maximum string length, or std::nullopt if it cannot be determined.\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  static std::optional<size_t> GetMaxStringLength(JSHeapBroker* broker,\n                                                  Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSAdd\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSAdd node.\",\n                \"logic\": \"Performs specialization and constant folding for JSAdd operations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSAdd node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSAdd(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSAsyncFunctionEnter\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSAsyncFunctionEnter node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSAsyncFunctionEnter node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSAsyncFunctionEnter(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSAsyncFunctionReject\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSAsyncFunctionReject node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSAsyncFunctionReject node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSAsyncFunctionReject(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSAsyncFunctionResolve\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSAsyncFunctionResolve node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSAsyncFunctionResolve node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSAsyncFunctionResolve(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSGetSuperConstructor\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSGetSuperConstructor node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSGetSuperConstructor node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSGetSuperConstructor(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSFindNonDefaultConstructorOrConstruct\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSFindNonDefaultConstructorOrConstruct node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSFindNonDefaultConstructorOrConstruct node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSFindNonDefaultConstructorOrConstruct(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSInstanceOf\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSInstanceOf node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSInstanceOf node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSInstanceOf(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSHasInPrototypeChain\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSHasInPrototypeChain node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSHasInPrototypeChain node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSHasInPrototypeChain(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSOrdinaryHasInstance\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSOrdinaryHasInstance node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSOrdinaryHasInstance node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSOrdinaryHasInstance(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSPromiseResolve\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSPromiseResolve node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSPromiseResolve node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSPromiseResolve(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSResolvePromise\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSResolvePromise node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSResolvePromise node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSResolvePromise(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSLoadGlobal\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSLoadGlobal node.\",\n                \"logic\": \"Performs specialization and constant folding for JSLoadGlobal operations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSLoadGlobal node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSLoadGlobal(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSStoreGlobal\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSStoreGlobal node.\",\n                \"logic\": \"Performs specialization and strength reduction for JSStoreGlobal operations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSStoreGlobal node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSStoreGlobal(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSLoadNamed\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSLoadNamed node.\",\n                \"logic\": \"Specializes JSLoadNamed nodes according to type feedback (if available).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSLoadNamed node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSLoadNamed(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSLoadNamedFromSuper\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSLoadNamedFromSuper node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSLoadNamedFromSuper node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSLoadNamedFromSuper(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSGetIterator\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSGetIterator node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSGetIterator node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSGetIterator(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSSetNamedProperty\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSSetNamedProperty node.\",\n                \"logic\": \"Specializes JSSetNamedProperty nodes according to type feedback (if available).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSSetNamedProperty node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceJSSetNamedProperty(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSHasProperty\",\n                \"parent\": \"JSNativeContextSpecialization\",\n                \"about\": \"Reduces a JSHasProperty node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSHasProperty node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\","
}