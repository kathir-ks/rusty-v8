{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction.cc\",\n            \"file_name\": \"instruction.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the Instruction class and related classes for representing machine instructions in the compiler backend.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for instruction representation, register allocation, and code generation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/backend/instruction.h\"\n\n#include <cstddef>\n#include <iomanip>\n\n#include \"src/base/iterator.h\"\n#include \"src/codegen/aligned-slot-allocator.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/codegen/register-configuration.h\"\n#include \"src/codegen/source-position.h\"\n#include \"src/compiler/backend/instruction-codes.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/frame-states.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/schedule.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/loop-finder.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/deoptimizer/deoptimizer.h\"\n#include \"src/execution/frames.h\"\n#include \"src/execution/isolate-utils-inl.h\"\n#include \"src/objects/heap-object-inl.h\"\n#include \"src/objects/instance-type-inl.h\"\n#include \"src/utils/ostreams.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/value-type.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CommuteFlagsCondition\",\n                \"about\": \"Commutes a FlagsCondition.\",\n                \"logic\": \"Switches the flags condition to its opposite based on signed or unsigned comparison.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"condition\",\n                        \"type\": \"FlagsCondition\",\n                        \"purpose\": \"The original flags condition.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"FlagsCondition\",\n                    \"description\": \"The commuted flags condition.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nFlagsCondition CommuteFlagsCondition(FlagsCondition condition) {\n  switch (condition) {\n    case kSignedLessThan:\n      return kSignedGreaterThan;\n    case kSignedGreaterThanOrEqual:\n      return kSignedLessThanOrEqual;\n    case kSignedLessThanOrEqual:\n      return kSignedGreaterThanOrEqual;\n    case kSignedGreaterThan:\n      return kSignedLessThan;\n    case kUnsignedLessThan:\n      return kUnsignedGreaterThan;\n    case kUnsignedGreaterThanOrEqual:\n      return kUnsignedLessThanOrEqual;\n    case kUnsignedLessThanOrEqual:\n      return kUnsignedGreaterThanOrEqual;\n    case kUnsignedGreaterThan:\n      return kUnsignedLessThan;\n    case kFloatLessThanOrUnordered:\n      return kFloatGreaterThanOrUnordered;\n    case kFloatGreaterThanOrEqual:\n      return kFloatLessThanOrEqual;\n    case kFloatLessThanOrEqual:\n      return kFloatGreaterThanOrEqual;\n    case kFloatGreaterThanOrUnordered:\n      return kFloatLessThanOrUnordered;\n    case kFloatLessThan:\n      return kFloatGreaterThan;\n    case kFloatGreaterThanOrEqualOrUnordered:\n      return kFloatLessThanOrEqualOrUnordered;\n    case kFloatLessThanOrEqualOrUnordered:\n      return kFloatGreaterThanOrEqualOrUnordered;\n    case kFloatGreaterThan:\n      return kFloatLessThan;\n    case kPositiveOrZero:\n    case kNegative:\n      UNREACHABLE();\n    case kEqual:\n    case kNotEqual:\n    case kOverflow:\n    case kNotOverflow:\n    case kUnorderedEqual:\n    case kUnorderedNotEqual:\n    case kIsNaN:\n    case kIsNotNaN:\n      return condition;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InterferesWith\",\n                \"parent\": \"InstructionOperand\",\n                \"about\": \"Checks if two InstructionOperands interfere with each other.\",\n                \"logic\": \"Determines if two operands conflict during register allocation, considering FP aliasing and stack slot overlaps.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"other\",\n                        \"type\": \"const InstructionOperand&\",\n                        \"purpose\": \"The other instruction operand to check for interference.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the operands interfere, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"AlignedSlotAllocator\",\n                    \"LocationOperand\",\n                    \"GetRegConfig\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool InstructionOperand::InterferesWith(const InstructionOperand& other) const {\n  const bool combine_fp_aliasing = kFPAliasing == AliasingKind::kCombine &&\n                                   this->IsFPLocationOperand() &&\n                                   other.IsFPLocationOperand();\n  const bool stack_slots = this->IsAnyStackSlot() && other.IsAnyStackSlot();\n  if (!combine_fp_aliasing && !stack_slots) {\n    return EqualsCanonicalized(other);\n  }\n  const LocationOperand& loc = *LocationOperand::cast(this);\n  const LocationOperand& other_loc = LocationOperand::cast(other);\n  MachineRepresentation rep = loc.representation();\n  MachineRepresentation other_rep = other_loc.representation();\n  LocationOperand::LocationKind kind = loc.location_kind();\n  LocationOperand::LocationKind other_kind = other_loc.location_kind();\n  if (kind != other_kind) return false;\n\n  if (combine_fp_aliasing && !stack_slots) {\n    if (rep == other_rep) return EqualsCanonicalized(other);\n    DCHECK_EQ(kind, LocationOperand::REGISTER);\n    // FP register-register interference.\n    return GetRegConfig()->AreAliases(rep, loc.register_code(), other_rep,\n                                      other_loc.register_code());\n  }\n\n  DCHECK(stack_slots);\n  int num_slots =\n      AlignedSlotAllocator::NumSlotsForWidth(ElementSizeInBytes(rep));\n  int num_slots_other =\n      AlignedSlotAllocator::NumSlotsForWidth(ElementSizeInBytes(other_rep));\n  const bool complex_stack_slot_interference =\n      (num_slots > 1 || num_slots_other > 1);\n  if (!complex_stack_slot_interference) {\n    return EqualsCanonicalized(other);\n  }\n\n  // Complex multi-slot operand interference:\n  // - slots of different FP reps can alias because the gap resolver may break a\n  // move into 2 or 4 equivalent smaller moves,\n  // - stack layout can be rearranged for tail calls\n  DCHECK_EQ(LocationOperand::STACK_SLOT, kind);\n  int index_hi = loc.index();\n  int index_lo =\n      index_hi -\n      AlignedSlotAllocator::NumSlotsForWidth(ElementSizeInBytes(rep)) + 1;\n  int other_index_hi = other_loc.index();\n  int other_index_lo =\n      other_index_hi -\n      AlignedSlotAllocator::NumSlotsForWidth(ElementSizeInBytes(other_rep)) + 1;\n  return other_index_hi >= index_lo && index_hi >= other_index_lo;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsCompatible\",\n                \"parent\": \"LocationOperand\",\n                \"about\": \"Checks if two LocationOperands are compatible for moves.\",\n                \"logic\": \"Determines if two location operands can be used interchangeably, considering register types and FP aliasing.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"LocationOperand*\",\n                        \"purpose\": \"The other location operand to check for compatibility.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the operands are compatible, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool LocationOperand::IsCompatible(LocationOperand* op) {\n  if (IsRegister() || IsStackSlot()) {\n    return op->IsRegister() || op->IsStackSlot();\n  } else if (kFPAliasing != AliasingKind::kCombine) {\n    // A backend may choose to generate the same instruction sequence regardless\n    // of the FP representation. As a result, we can relax the compatibility and\n    // allow a Double to be moved in a Float for example. However, this is only\n    // allowed if registers do not overlap.\n    return (IsFPRegister() || IsFPStackSlot()) &&\n           (op->IsFPRegister() || op->IsFPStackSlot());\n  } else if (IsFloatRegister() || IsFloatStackSlot()) {\n    return op->IsFloatRegister() || op->IsFloatStackSlot();\n  } else if (IsDoubleRegister() || IsDoubleStackSlot()) {\n    return op->IsDoubleRegister() || op->IsDoubleStackSlot();\n  } else {\n    return (IsSimd128Register() || IsSimd128StackSlot()) &&\n           (op->IsSimd128Register() || op->IsSimd128StackSlot());\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Print\",\n                \"parent\": \"InstructionOperand\",\n                \"about\": \"Prints the InstructionOperand to the standard output stream.\",\n                \"logic\": \"Uses the overloaded operator<< to format and output the operand's details.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionOperand::Print() const { StdoutStream{} << *this << std::endl; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator to print InstructionOperand objects to an output stream.\",\n                \"logic\": \"Formats the InstructionOperand based on its type (UNALLOCATED, CONSTANT, IMMEDIATE, PENDING, ALLOCATED).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const InstructionOperand&\",\n                        \"purpose\": \"The InstructionOperand to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": [\n                    \"UnallocatedOperand\",\n                    \"ConstantOperand\",\n                    \"ImmediateOperand\",\n                    \"PendingOperand\",\n                    \"LocationOperand\",\n                    \"RegisterName\",\n                    \"DoubleRegister\",\n                    \"FloatRegister\",\n                    \"Simd128Register\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const InstructionOperand& op) {\n  switch (op.kind()) {\n    case InstructionOperand::UNALLOCATED: {\n      const UnallocatedOperand* unalloc = UnallocatedOperand::cast(&op);\n      os << \"v\" << unalloc->virtual_register();\n      if (unalloc->basic_policy() == UnallocatedOperand::FIXED_SLOT) {\n        return os << \"(=\" << unalloc->fixed_slot_index() << \"S)\";\n      }\n      switch (unalloc->extended_policy()) {\n        case UnallocatedOperand::NONE:\n          return os;\n        case UnallocatedOperand::FIXED_REGISTER:\n          return os << \"(=\"\n                    << Register::from_code(unalloc->fixed_register_index())\n                    << \")\";\n        case UnallocatedOperand::FIXED_FP_REGISTER:\n          return os << \"(=\"\n                    << (unalloc->IsSimd128Register()\n                            ? i::RegisterName((Simd128Register::from_code(\n                                  unalloc->fixed_register_index())))\n                            : i::RegisterName(DoubleRegister::from_code(\n                                  unalloc->fixed_register_index())))\n                    << \")\";\n        case UnallocatedOperand::MUST_HAVE_REGISTER:\n          return os << \"(R)\";\n        case UnallocatedOperand::MUST_HAVE_SLOT:\n          return os << \"(S)\";\n        case UnallocatedOperand::SAME_AS_INPUT:\n          return os << \"(\" << unalloc->input_index() << \")\";\n        case UnallocatedOperand::REGISTER_OR_SLOT:\n          return os << \"(-)\";\n        case UnallocatedOperand::REGISTER_OR_SLOT_OR_CONSTANT:\n          return os << \"(*)\";\n      }\n    }\n    case InstructionOperand::CONSTANT:\n      return os << \"[constant:v\" << ConstantOperand::cast(op).virtual_register()\n                << \"]\";\n    case InstructionOperand::IMMEDIATE: {\n      ImmediateOperand imm = ImmediateOperand::cast(op);\n      switch (imm.type()) {\n        case ImmediateOperand::INLINE_INT32:\n          return os << \"#\" << imm.inline_int32_value();\n        case ImmediateOperand::INLINE_INT64:\n          return os << \"#\" << imm.inline_int64_value();\n        case ImmediateOperand::INDEXED_RPO:\n          return os << \"[rpo_immediate:\" << imm.indexed_value() << \"]\";\n        case ImmediateOperand::INDEXED_IMM:\n          return os << \"[immediate:\" << imm.indexed_value() << \"]\";\n      }\n    }\n    case InstructionOperand::PENDING:\n      return os << \"[pending: \" << PendingOperand::cast(op).next() << \"]\";\n    case InstructionOperand::ALLOCATED: {\n      LocationOperand allocated = LocationOperand::cast(op);\n      if (op.IsStackSlot()) {\n        os << \"[stack:\" << allocated.index();\n      } else if (op.IsFPStackSlot()) {\n        os << \"[fp_stack:\" << allocated.index();\n      } else if (op.IsRegister()) {\n        const char* name =\n            allocated.register_code() < Register::kNumRegisters\n                ? RegisterName(Register::from_code(allocated.register_code()))\n                : Register::GetSpecialRegisterName(allocated.register_code());\n        os << \"[\" << name << \"|R\";\n      } else if (op.IsDoubleRegister()) {\n        os << \"[\" << DoubleRegister::from_code(allocated.register_code())\n           << \"|R\";\n      } else if (op.IsFloatRegister()) {\n        os << \"[\" << FloatRegister::from_code(allocated.register_code())\n           << \"|R\";\n#if V8_TARGET_ARCH_X64\n      } else if (op.IsSimd256Register()) {\n        os << \"[\" << Simd256Register::from_code(allocated.register_code())\n           << \"|R\";\n#endif  // V8_TARGET_ARCH_X64\n      } else {\n        DCHECK(op.IsSimd128Register());\n        os << \"[\" << Simd128Register::from_code(allocated.register_code())\n           << \"|R\";\n      }\n      switch (allocated.representation()) {\n        case MachineRepresentation::kNone:\n          os << \"|-\";\n          break;\n        case MachineRepresentation::kBit:\n          os << \"|b\";\n          break;\n        case MachineRepresentation::kWord8:\n          os << \"|w8\";\n          break;\n        case MachineRepresentation::kWord16:\n          os << \"|w16\";\n          break;\n        case MachineRepresentation::kWord32:\n          os << \"|w32\";\n          break;\n        case MachineRepresentation::kWord64:\n          os << \"|w64\";\n          break;\n        case MachineRepresentation::kFloat16:\n          os << \"|f16\";\n          break;\n        case MachineRepresentation::kFloat32:\n          os << \"|f32\";\n          break;\n        case MachineRepresentation::kFloat64:\n          os << \"|f64\";\n          break;\n        case MachineRepresentation::kSimd128:\n          os << \"|s128\";\n          break;\n        case MachineRepresentation::kSimd256:\n          os << \"|s256\";\n          break;\n        case MachineRepresentation::kTaggedSigned:\n          os << \"|ts\";\n          break;\n        case MachineRepresentation::kTaggedPointer:\n          os << \"|tp\";\n          break;\n        case MachineRepresentation::kTagged:\n          os << \"|t\";\n          break;\n        case MachineRepresentation::kCompressedPointer:\n          os << \"|cp\";\n          break;\n        case MachineRepresentation::kCompressed:\n          os << \"|c\";\n          break;\n        case MachineRepresentation::kProtectedPointer:\n          os << \"|pp\";\n          break;\n        case MachineRepresentation::kIndirectPointer:\n          os << \"|ip\";\n          break;\n        case MachineRepresentation::kSandboxedPointer:\n          os << \"|sb\";\n          break;\n        case MachineRepresentation::kMapWord:\n        case MachineRepresentation::kFloat16RawBits:\n          UNREACHABLE();\n      }\n      return os << \"]\";\n    }\n    case InstructionOperand::INVALID:\n      return os << \"(x)\";\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Print\",\n                \"parent\": \"MoveOperands\",\n                \"about\": \"Prints the MoveOperands to the standard output stream.\",\n                \"logic\": \"Formats and outputs the source and destination operands.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid MoveOperands::Print() const {\n  StdoutStream{} << destination() << \" = \" << source() << std::endl;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator to print MoveOperands objects to an output stream.\",\n                \"logic\": \"Formats the MoveOperands by showing source and destination if they are different.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"mo\",\n                        \"type\": \"const MoveOperands&\",\n                        \"purpose\": \"The MoveOperands to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const MoveOperands& mo) {\n  os << mo.destination();\n  if (!mo.source().Equals(mo.destination())) {\n    os << \" = \" << mo.source();\n  }\n  return os;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsRedundant\",\n                \"parent\": \"ParallelMove\",\n                \"about\": \"Checks if a ParallelMove is redundant, meaning all its MoveOperands are redundant.\",\n                \"logic\": \"Iterates through MoveOperands and returns false if any is not redundant.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if all MoveOperands are redundant, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool ParallelMove::IsRedundant() const {\n  for (MoveOperands* move : *this) {\n    if (!move->IsRedundant()) return false;\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PrepareInsertAfter\",\n                \"parent\": \"ParallelMove\",\n                \"about\": \"Prepares a MoveOperands to be inserted into the ParallelMove, handling aliasing and eliminations.\",\n                \"logic\": \"Adjusts source and eliminates conflicting moves to ensure correct insertion order.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"move\",\n                        \"type\": \"MoveOperands*\",\n                        \"purpose\": \"The MoveOperands to be inserted.\"\n                    },\n                    {\n                        \"name\": \"to_eliminate\",\n                        \"type\": \"ZoneVector<MoveOperands*>*\",\n                        \"purpose\": \"Vector to collect moves to be eliminated.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ParallelMove::PrepareInsertAfter(\n    MoveOperands* move, ZoneVector<MoveOperands*>* to_eliminate) const {\n  bool no_aliasing = kFPAliasing != AliasingKind::kCombine ||\n                     !move->destination().IsFPLocationOperand();\n  MoveOperands* replacement = nullptr;\n  MoveOperands* eliminated = nullptr;\n  for (MoveOperands* curr : *this) {\n    if (curr->IsEliminated()) continue;\n    if (curr->destination().EqualsCanonicalized(move->source())) {\n      // We must replace move's source with curr's destination in order to\n      // insert it into this ParallelMove.\n      DCHECK(!replacement);\n      replacement = curr;\n      if (no_aliasing && eliminated != nullptr) break;\n    } else if (curr->destination().InterferesWith(move->destination())) {\n      // We can eliminate curr, since move overwrites at least a part of its\n      // destination, implying its value is no longer live.\n      eliminated = curr;\n      to_eliminate->push_back(curr);\n      if (no_aliasing && replacement != nullptr) break;\n    }\n  }\n  if (replacement != nullptr) move->set_source(replacement->source());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Equals\",\n                \"parent\": \"ParallelMove\",\n                \"about\": \"Checks if two ParallelMove objects are equal.\",\n                \"logic\": \"Compares each MoveOperands within the ParallelMove objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"that\",\n                        \"type\": \"const ParallelMove&\",\n                        \"purpose\": \"The ParallelMove to compare against.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the ParallelMove objects are equal, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool ParallelMove::Equals(const ParallelMove& that) const {\n  if (this->size() != that.size()) return false;\n  for (size_t i = 0; i < this->size(); ++i) {\n    if (!(*this)[i]->Equals(*that[i])) return false;\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Eliminate\",\n                \"parent\": \"ParallelMove\",\n                \"about\": \"Eliminates all MoveOperands within the ParallelMove.\",\n                \"logic\": \"Iterates through and calls Eliminate() on each MoveOperands.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ParallelMove::Eliminate() {\n  for (MoveOperands* move : *this) {\n    move->Eliminate();\n  }\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Instruction\",\n                \"about\": \"Represents a single machine instruction.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"opcode_\",\n                        \"type\": \"InstructionCode\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The opcode of the instruction.\"\n                    },\n                    {\n                        \"name\": \"bit_field_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Bit field for storing output, input, and temp counts.\"\n                    },\n                    {\n                        \"name\": \"reference_map_\",\n                        \"type\": \"ReferenceMap*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the reference map for GC.\"\n                    },\n                    {\n                        \"name\": \"block_\",\n                        \"type\": \"InstructionBlock*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The block this instruction belongs to.\"\n                    },\n                    {\n                        \"name\": \"parallel_moves_\",\n                        \"type\": \"ParallelMove*[2]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Parallel moves before and after the instruction.\"\n                    },\n                    {\n                        \"name\": \"operands_\",\n                        \"type\": \"InstructionOperand[kMaxOperands]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of instruction operands.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nInstruction::Instruction(InstructionCode opcode)\n    : opcode_(opcode),\n      bit_field_(OutputCountField::encode(0) | InputCountField::encode(0) |\n                 TempCountField::encode(0) | IsCallField::encode(false)),\n      reference_map_(nullptr),\n      block_(nullptr) {\n  parallel_moves_[0] = nullptr;\n  parallel_moves_[1] = nullptr;\n\n  // PendingOperands are required to be 8 byte aligned.\n  static_assert(offsetof(Instruction, operands_) % 8 == 0);\n}\n\nInstruction::Instruction(InstructionCode opcode, size_t output_count,\n                         InstructionOperand* outputs, size_t input_count,\n                         InstructionOperand* inputs, size_t temp_count,\n                         InstructionOperand* temps)\n    : opcode_(opcode),\n      bit_field_(OutputCountField::encode(output_count) |\n                 InputCountField::encode(input_count) |\n                 TempCountField::encode(temp_count) |\n                 IsCallField::encode(false)),\n      reference_map_(nullptr),\n      block_(nullptr) {\n  parallel_moves_[0] = nullptr;\n  parallel_moves_[1] = nullptr;\n  size_t offset = 0;\n  for (size_t i = 0; i < output_count; ++i) {\n    DCHECK(!outputs[i].IsInvalid());\n    operands_[offset++] = outputs[i];\n  }\n  for (size_t i = 0; i < input_count; ++i) {\n    DCHECK(!inputs[i].IsInvalid());\n    operands_[offset++] = inputs[i];\n  }\n  for (size_t i = 0; i < temp_count; ++i) {\n    DCHECK(!temps[i].IsInvalid());\n    operands_[offset++] = temps[i];\n  }\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AreMovesRedundant\",\n                \"parent\": \"Instruction\",\n                \"about\": \"Checks if all parallel moves associated with an instruction are redundant.\",\n                \"logic\": \"Iterates through parallel moves at the beginning and end of the instruction.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if all parallel moves are redundant, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool Instruction::AreMovesRedundant() const {\n  for (int i = Instruction::FIRST_GAP_POSITION;\n       i <= Instruction::LAST_GAP_POSITION; i++) {\n    if (parallel_moves_[i] != nullptr && !parallel_moves_[i]->IsRedundant()) {\n      return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Print\",\n                \"parent\": \"Instruction\",\n                \"about\": \"Prints the Instruction to the standard output stream.\",\n                \"logic\": \"Uses the overloaded operator<< to format and output the instruction's details.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Instruction::Print() const { StdoutStream{} << *this << std::endl; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator to print ParallelMove objects to an output stream.\",\n                \"logic\": \"Formats the ParallelMove by showing the MoveOperands within.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"pm\",\n                        \"type\": \"const ParallelMove&\",\n                        \"purpose\": \"The ParallelMove to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const ParallelMove& pm) {\n  const char* delimiter = \"\";\n  for (MoveOperands* move : pm) {\n    if (move->IsEliminated()) continue;\n    os << delimiter << *move;\n    delimiter = \"; \";\n  }\n  return os;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReferenceMap\",\n                \"about\": \"Represents a reference map for garbage collection purposes.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"reference_operands_\",\n                        \"type\": \"ZoneVector<InstructionOperand>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of operands that are references.\"\n                    },\n                    {\n                        \"name\": \"instruction_position_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Position of the instruction in the instruction sequence.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ReferenceMap::RecordReference(const AllocatedOperand& op) {\n  // Do not record arguments as pointers.\n  if (op.IsStackSlot() && LocationOperand::cast(op).index() < 0) return;\n  DCHECK(!op.IsFPRegister() && !op.IsFPStackSlot());\n  reference_operands_.push_back(op);\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator to print ReferenceMap objects to an output stream.\",\n                \"logic\": \"Formats the ReferenceMap by showing operands that are references.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"pm\",\n                        \"type\": \"const ReferenceMap&\",\n                        \"purpose\": \"The ReferenceMap to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const ReferenceMap& pm) {\n  os << \"{\";\n  const char* separator = \"\";\n  for (const InstructionOperand& op : pm.reference_operands_) {\n    os << separator << op;\n    separator = \";\";\n  }\n  return os << \"}\";\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n"
}