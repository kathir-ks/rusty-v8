{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/late-escape-analysis.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 43, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/late-escape-analysis.cc\",\n            \"file_name\": \"late-escape-analysis.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements a late escape analysis to remove allocations that do not escape the function.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for escape analysis, optional types, graph manipulation, and node properties.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/late-escape-analysis.h\"\n\n#include <optional>\n\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/node-properties.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LateEscapeAnalysis\",\n                \"extends\": \"AdvancedReducer\",\n                \"about\": \"Performs late escape analysis to identify and remove allocations that do not escape the function.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"dead_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents a dead node for replacing removed allocations.\"\n                    },\n                    {\n                        \"name\": \"all_allocations_\",\n                        \"type\": \"ZoneSet<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores all allocation nodes in the graph.\"\n                    },\n                    {\n                        \"name\": \"escaping_allocations_\",\n                        \"type\": \"ZoneMap<Node*, int>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Counts the number of times an allocation is witnessed as escaping.\"\n                    },\n                    {\n                        \"name\": \"revisit_\",\n                        \"type\": \"ZoneDeque<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A queue of allocation nodes to revisit.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Editor\",\n                    \"TFGraph\",\n                    \"CommonOperatorBuilder\",\n                    \"Zone\",\n                    \"AdvancedReducer\",\n                    \"Node\",\n                    \"ZoneSet\",\n                    \"ZoneMap\",\n                    \"ZoneDeque\",\n                    \"Edge\",\n                    \"NodeProperties\",\n                    \"IrOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass LateEscapeAnalysis : public AdvancedReducer {\n public:\n  LateEscapeAnalysis(Editor* editor, TFGraph* graph,\n                       CommonOperatorBuilder* common,\n                       Zone* zone);\n\n  Reduction Reduce(Node* node) override;\n  void Finalize() override;\n\n private:\n  bool IsEscaping(Node* node);\n  void RemoveAllocation(Node* node);\n  void RecordEscapingAllocation(Node* allocation);\n  void RemoveWitness(Node* allocation);\n\n  Node* dead_;\n  ZoneSet<Node*> all_allocations_;\n  ZoneMap<Node*, int> escaping_allocations_;\n  ZoneDeque<Node*> revisit_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LateEscapeAnalysis\",\n                \"parent\": \"LateEscapeAnalysis\",\n                \"about\": \"Constructor for LateEscapeAnalysis.\",\n                \"logic\": \"Initializes the members of the class.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"editor\",\n                        \"type\": \"Editor*\",\n                        \"purpose\": \"The graph editor.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The graph being analyzed.\"\n                    },\n                    {\n                        \"name\": \"common\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"purpose\": \"The common operator builder.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"TFGraph\",\n                    \"CommonOperatorBuilder\",\n                    \"Zone\",\n                    \"dead_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nLateEscapeAnalysis::LateEscapeAnalysis(Editor* editor, TFGraph* graph,\n                                       CommonOperatorBuilder* common,\n                                       Zone* zone)\n    : AdvancedReducer(editor),\n      dead_(graph->NewNode(common->Dead())),\n      all_allocations_(zone),\n      escaping_allocations_(zone),\n      revisit_(zone) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsStore\",\n                \"parent\": null,\n                \"about\": \"Determines if an edge represents a store operation.\",\n                \"logic\": \"Checks the opcode of the node that the edge originates from to see if it's a store-like operation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"edge\",\n                        \"type\": \"Edge\",\n                        \"purpose\": \"The edge to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the edge represents a store operation, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Edge\",\n                    \"IrOpcode\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nbool IsStore(Edge edge) {\n  DCHECK_EQ(edge.to()->opcode(), IrOpcode::kAllocateRaw);\n  DCHECK(NodeProperties::IsValueEdge(edge));\n\n  switch (edge.from()->opcode()) {\n    case IrOpcode::kInitializeImmutableInObject:\n    case IrOpcode::kStore:\n    case IrOpcode::kStoreElement:\n    case IrOpcode::kStoreField:\n    case IrOpcode::kStoreToObject:\n      return edge.index() == 0;\n    default:\n      return false;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsEscapingAllocationWitness\",\n                \"parent\": null,\n                \"about\": \"Determines if an edge is a witness that the allocation escapes.\",\n                \"logic\": \"Checks that the edge points to an AllocateRaw node, is a value edge, and is not a store.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"edge\",\n                        \"type\": \"Edge\",\n                        \"purpose\": \"The edge to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the edge is an escaping allocation witness, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Edge\",\n                    \"IrOpcode\",\n                    \"NodeProperties\",\n                    \"IsStore\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool IsEscapingAllocationWitness(Edge edge) {\n  if (edge.to()->opcode() != IrOpcode::kAllocateRaw) return false;\n  if (!NodeProperties::IsValueEdge(edge)) return false;\n  return !IsStore(edge);\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reduce\",\n                \"parent\": \"LateEscapeAnalysis\",\n                \"about\": \"Reduces a node in the graph by checking for escaping allocations.\",\n                \"logic\": \"If the node is an AllocateRaw, it's added to the list of all allocations.  It then iterates through the input edges, checking for escaping allocation witnesses and recording them.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"NoChange if no reduction occurred.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"Edge\",\n                    \"NodeProperties\",\n                    \"IsEscapingAllocationWitness\",\n                    \"RecordEscapingAllocation\",\n                    \"all_allocations_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction LateEscapeAnalysis::Reduce(Node* node) {\n  if (node->opcode() == IrOpcode::kAllocateRaw) {\n    all_allocations_.insert(node);\n    return NoChange();\n  }\n\n  for (Edge edge : node->input_edges()) {\n    if (IsEscapingAllocationWitness(edge)) {\n      RecordEscapingAllocation(edge.to());\n    }\n  }\n\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Finalize\",\n                \"parent\": \"LateEscapeAnalysis\",\n                \"about\": \"Finalizes the escape analysis by removing allocations that do not escape.\",\n                \"logic\": \"Iterates through all allocations and removes those that are not escaping. Also revisits allocation nodes until no more changes occur.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IsEscaping\",\n                    \"RemoveAllocation\",\n                    \"revisit_\",\n                    \"all_allocations_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LateEscapeAnalysis::Finalize() {\n  for (Node* alloc : all_allocations_) {\n    if (!IsEscaping(alloc)) {\n      RemoveAllocation(alloc);\n    }\n  }\n  while (!revisit_.empty()) {\n    Node* alloc = revisit_.front();\n    revisit_.pop_front();\n    if (!IsEscaping(alloc) && !alloc->IsDead()) {\n      RemoveAllocation(alloc);\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TryGetStoredValue\",\n                \"parent\": null,\n                \"about\": \"Tries to get the value stored by a store node.\",\n                \"logic\": \"Checks the opcode of the node and returns the appropriate value input index. Returns an empty optional if the node is not a store.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<Node*>\",\n                    \"description\": \"The stored value if the node is a store, an empty optional otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nstd::optional<Node*> TryGetStoredValue(Node* node) {\n  int value_index;\n  switch (node->opcode()) {\n    case IrOpcode::kInitializeImmutableInObject:\n    case IrOpcode::kStore:\n    case IrOpcode::kStoreElement:\n    case IrOpcode::kStoreToObject:\n      value_index = 2;\n      break;\n    case IrOpcode::kStoreField:\n      value_index = 1;\n      break;\n    default:\n      return {};\n  }\n\n  return NodeProperties::GetValueInput(node, value_index);\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsEscaping\",\n                \"parent\": \"LateEscapeAnalysis\",\n                \"about\": \"Checks if an allocation node is escaping.\",\n                \"logic\": \"Looks up the allocation node in the escaping_allocations_ map and checks if its count is greater than 0.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The allocation node to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the allocation is escaping, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"escaping_allocations_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool LateEscapeAnalysis::IsEscaping(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kAllocateRaw);\n  auto escaping = escaping_allocations_.find(node);\n  if (escaping == escaping_allocations_.end()) return false;\n  return escaping->second != 0;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RemoveAllocation\",\n                \"parent\": \"LateEscapeAnalysis\",\n                \"about\": \"Removes an allocation node and its uses from the graph.\",\n                \"logic\": \"Iterates through the use edges of the allocation node, replacing them with the dead node and killing the uses.  It also removes the allocation from the effect and control chains.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The allocation node to remove.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"Edge\",\n                    \"NodeProperties\",\n                    \"TryGetStoredValue\",\n                    \"RemoveWitness\",\n                    \"revisit_\",\n                    \"dead_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LateEscapeAnalysis::RemoveAllocation(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kAllocateRaw);\n  for (Edge edge : node->use_edges()) {\n    if (!NodeProperties::IsValueEdge(edge)) continue;\n    Node* use = edge.from();\n    if (use->IsDead()) continue;\n    // The value stored by this Store node might be another allocation which has\n    // no more uses. Affected allocations are revisited.\n    if (std::optional<Node*> stored_value = TryGetStoredValue(use);\n        stored_value.has_value() &&\n        stored_value.value()->opcode() == IrOpcode::kAllocateRaw &&\n        stored_value.value() != node) {\n      RemoveWitness(stored_value.value());\n      revisit_.push_back(stored_value.value());\n    }\n    ReplaceWithValue(use, dead());\n    use->Kill();\n  }\n\n  // Remove the allocation from the effect and control chains.\n  ReplaceWithValue(node, dead());\n  node->Kill();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RecordEscapingAllocation\",\n                \"parent\": \"LateEscapeAnalysis\",\n                \"about\": \"Records that an allocation node is escaping.\",\n                \"logic\": \"Increments the count of the allocation node in the escaping_allocations_ map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"allocation\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The allocation node that is escaping.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"escaping_allocations_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LateEscapeAnalysis::RecordEscapingAllocation(Node* allocation) {\n  DCHECK_EQ(allocation->opcode(), IrOpcode::kAllocateRaw);\n  escaping_allocations_[allocation]++;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RemoveWitness\",\n                \"parent\": \"LateEscapeAnalysis\",\n                \"about\": \"Removes a witness that an allocation node is escaping.\",\n                \"logic\": \"Decrements the count of the allocation node in the escaping_allocations_ map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"allocation\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The allocation node to remove the witness from.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"escaping_allocations_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LateEscapeAnalysis::RemoveWitness(Node* allocation) {\n  DCHECK_EQ(allocation->opcode(), IrOpcode::kAllocateRaw);\n  DCHECK_GT(escaping_allocations_[allocation], 0);\n  escaping_allocations_[allocation]--;\n}\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </func>\n</file>\n```"
}