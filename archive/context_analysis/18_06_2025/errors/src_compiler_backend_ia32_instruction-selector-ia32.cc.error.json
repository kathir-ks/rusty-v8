{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ia32/instruction-selector-ia32.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ia32/instruction-selector-ia32.cc\",\n      \"file_name\": \"instruction-selector-ia32.cc\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Implements the IA32-specific instruction selection for the Turboshaft compiler backend in V8.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes standard C++ headers and V8-specific headers for compiler, code generation, and architecture-specific functionalities.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include <stddef.h>\n#include <stdint.h>\n\n#include <limits>\n#include <optional>\n#include <type_traits>\n#include <vector>\n\n#include \"src/base/bits.h\"\n#include \"src/base/flags.h\"\n#include \"src/base/iterator.h\"\n#include \"src/base/logging.h\"\n#include \"src/base/macros.h\"\n#include \"src/codegen/cpu-features.h\"\n#include \"src/codegen/ia32/assembler-ia32.h\"\n#include \"src/codegen/ia32/register-ia32.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/codegen/macro-assembler-base.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/backend/instruction-codes.h\"\n#include \"src/compiler/backend/instruction-selector-adapter.h\"\n#include \"src/compiler/backend/instruction-selector-impl.h\"\n#include \"src/compiler/backend/instruction-selector.h\"\n#include \"src/compiler/backend/instruction.h\"\n#include \"src/compiler/frame.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n#include \"src/compiler/write-barrier-kind.h\"\n#include \"src/flags/flags.h\"\n#include \"src/utils/utils.h\"\n#include \"src/zone/zone-containers.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/simd-shuffle.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n    ]]></code>\n  </imports>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"struct\",\n        \"name\": \"LoadStoreView\",\n        \"about\": \"Helper struct to extract common properties from LoadOp and StoreOp.\",\n        \"attributes\": [\n          {\n            \"name\": \"base\",\n            \"type\": \"OpIndex\",\n            \"access\": \"public\",\n            \"purpose\": \"Base OpIndex for memory access.\"\n          },\n          {\n            \"name\": \"index\",\n            \"type\": \"OptionalOpIndex\",\n            \"access\": \"public\",\n            \"purpose\": \"Index OpIndex for memory access (optional).\"\n          },\n          {\n            \"name\": \"offset\",\n            \"type\": \"int32_t\",\n            \"access\": \"public\",\n            \"purpose\": \"Offset for memory access.\"\n          }\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstruct LoadStoreView {\n  explicit LoadStoreView(const Operation& op) {\n    DCHECK(op.Is<LoadOp>() || op.Is<StoreOp>());\n    if (const LoadOp* load = op.TryCast<LoadOp>()) {\n      base = load->base();\n      index = load->index();\n      offset = load->offset;\n    } else {\n      DCHECK(op.Is<StoreOp>());\n      const StoreOp& store = op.Cast<StoreOp>();\n      base = store->base();\n      index = store->index();\n      offset = store->offset;\n    }\n  }\n  OpIndex base;\n  OptionalOpIndex index;\n  int32_t offset;\n};\n    ]]></code>\n  </class>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"struct\",\n        \"name\": \"ScaledIndexMatch\",\n        \"about\": \"Helper struct to represent a scaled index match.\",\n        \"attributes\": [\n          {\n            \"name\": \"base\",\n            \"type\": \"OpIndex\",\n            \"access\": \"public\",\n            \"purpose\": \"Base OpIndex.\"\n          },\n          {\n            \"name\": \"index\",\n            \"type\": \"OpIndex\",\n            \"access\": \"public\",\n            \"purpose\": \"Index OpIndex.\"\n          },\n          {\n            \"name\": \"scale\",\n            \"type\": \"int\",\n            \"access\": \"public\",\n            \"purpose\": \"Scale factor.\"\n          }\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstruct ScaledIndexMatch {\n  OpIndex base;\n  OpIndex index;\n  int scale;\n};\n    ]]></code>\n  </class>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"struct\",\n        \"name\": \"BaseWithScaledIndexAndDisplacementMatch\",\n        \"about\": \"Helper struct for representing base with scaled index and displacement.\",\n        \"attributes\": [\n          {\n            \"name\": \"base\",\n            \"type\": \"OpIndex\",\n            \"access\": \"public\",\n            \"purpose\": \"Base OpIndex.\"\n          },\n          {\n            \"name\": \"index\",\n            \"type\": \"OpIndex\",\n            \"access\": \"public\",\n            \"purpose\": \"Index OpIndex.\"\n          },\n          {\n            \"name\": \"scale\",\n            \"type\": \"int\",\n            \"access\": \"public\",\n            \"purpose\": \"Scale factor.\"\n          },\n          {\n            \"name\": \"displacement\",\n            \"type\": \"int32_t\",\n            \"access\": \"public\",\n            \"purpose\": \"Displacement value.\"\n          },\n          {\n            \"name\": \"displacement_mode\",\n            \"type\": \"DisplacementMode\",\n            \"access\": \"public\",\n            \"purpose\": \"Displacement mode (positive or negative).\"\n          }\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstruct BaseWithScaledIndexAndDisplacementMatch {\n  OpIndex base = {};\n  OpIndex index = {};\n  int scale = 0;\n  int32_t displacement = 0;\n  DisplacementMode displacement_mode = kPositiveDisplacement;\n};\n    ]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"MatchScaledIndex\",\n        \"about\": \"Matches scaled index pattern for addressing modes.\",\n        \"logic\": \"Tries to match a node with either WordBinopOp::Kind::kMul or ShiftOp::Kind::kShiftLeft, to identify a scaled index. Populates index and scale. Returns true if a scaled index is matched, false otherwise.\",\n        \"parameters\": [\n          {\n            \"name\": \"selector\",\n            \"type\": \"InstructionSelectorT*\",\n            \"purpose\": \"Instruction selector instance\"\n          },\n          {\n            \"name\": \"node\",\n            \"type\": \"OpIndex\",\n            \"purpose\": \"OpIndex of the node to match\"\n          },\n          {\n            \"name\": \"index\",\n            \"type\": \"OpIndex*\",\n            \"purpose\": \"Output parameter to store the index\"\n          },\n          {\n            \"name\": \"scale\",\n            \"type\": \"int*\",\n            \"purpose\": \"Output parameter to store the scale\"\n          },\n          {\n            \"name\": \"power_of_two_plus_one\",\n            \"type\": \"bool*\",\n            \"purpose\": \"Output parameter to indicate if scale is power of two plus one\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if scaled index is matched, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"ConstantOp\",\n          \"WordBinopOp\",\n          \"ShiftOp\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool MatchScaledIndex(InstructionSelectorT* selector, OpIndex node,\n                      OpIndex* index, int* scale, bool* power_of_two_plus_one) {\n  DCHECK_NOT_NULL(index);\n  DCHECK_NOT_NULL(scale);\n\n  auto MatchScaleConstant = [](const Operation& op, int& scale,\n                               bool* plus_one) {\n    const ConstantOp* constant = op.TryCast<ConstantOp>();\n    if (constant == nullptr) return false;\n    if (constant->kind != ConstantOp::Kind::kWord32) return false;\n\n    uint64_t value = constant->integral();\n    if (plus_one) *plus_one = false;\n    if (value == 1) return (scale = 0), true;\n    if (value == 2) return (scale = 1), true;\n    if (value == 4) return (scale = 2), true;\n    if (value == 8) return (scale = 3), true;\n    if (plus_one == nullptr) return false;\n    *plus_one = true;\n    if (value == 3) return (scale = 1), true;\n    if (value == 5) return (scale = 2), true;\n    if (value == 9) return (scale = 3), true;\n    return false;\n  };\n\n  const Operation& op = selector->Get(node);\n  if (const WordBinopOp* binop = op.TryCast<WordBinopOp>()) {\n    if (binop->kind != WordBinopOp::Kind::kMul) return false;\n    if (MatchScaleConstant(selector->Get(binop->right()), *scale,\n                           power_of_two_plus_one)) {\n      *index = binop->left();\n      return true;\n    }\n    if (MatchScaleConstant(selector->Get(binop->left()), *scale,\n                           power_of_two_plus_one)) {\n      *index = binop->right();\n      return true;\n    }\n    return false;\n  } else if (const ShiftOp* shift = op.TryCast<ShiftOp>()) {\n    if (shift->kind != ShiftOp::Kind::kShiftLeft) return false;\n    int32_t scale_value;\n    if (selector->MatchIntegralWord32Constant(shift->right(), &scale_value)) {\n      if (scale_value < 0 || scale_value > 3) return false;\n      *index = shift->left();\n      *scale = static_cast<int>(scale_value);\n      if (power_of_two_plus_one) *power_of_two_plus_one = false;\n      return true;\n    }\n  }\n  return false;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"TryMatchScaledIndex\",\n        \"about\": \"Tries to match a scaled index for addressing modes, returning an optional ScaledIndexMatch struct.\",\n        \"logic\": \"Calls MatchScaledIndex and populates ScaledIndexMatch struct if successful. Returns std::nullopt if match fails.\",\n        \"parameters\": [\n          {\n            \"name\": \"selector\",\n            \"type\": \"InstructionSelectorT*\",\n            \"purpose\": \"Instruction selector instance\"\n          },\n          {\n            \"name\": \"node\",\n            \"type\": \"OpIndex\",\n            \"purpose\": \"OpIndex of the node to match\"\n          },\n          {\n            \"name\": \"allow_power_of_two_plus_one\",\n            \"type\": \"bool\",\n            \"purpose\": \"Flag indicating whether to allow scales that are a power of two plus one.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"std::optional<ScaledIndexMatch>\",\n          \"description\": \"Optional ScaledIndexMatch struct, or std::nullopt if no match.\"\n        },\n        \"dependencies\": [\n          \"MatchScaledIndex\",\n          \"ScaledIndexMatch\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstd::optional<ScaledIndexMatch> TryMatchScaledIndex(\n    InstructionSelectorT* selector, OpIndex node,\n    bool allow_power_of_two_plus_one) {\n  ScaledIndexMatch match;\n  bool plus_one = false;\n  if (MatchScaledIndex(selector, node, &match.index, &match.scale,\n                       allow_power_of_two_plus_one ? &plus_one : nullptr)) {\n    match.base = plus_one ? match.index : OpIndex{};\n    return match;\n  }\n  return std::nullopt;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"TryMatchBaseWithScaledIndexAndDisplacementForWordBinop\",\n        \"about\": \"Attempts to match a base with scaled index and displacement for a word binop (add/sub).\",\n        \"logic\": \"Matches patterns like (S + (B +/- D)), (S + B), (B + D), (B + B). Returns optional BaseWithScaledIndexAndDisplacementMatch struct.\",\n        \"parameters\": [\n          {\n            \"name\": \"selector\",\n            \"type\": \"InstructionSelectorT*\",\n            \"purpose\": \"Instruction selector instance\"\n          },\n          {\n            \"name\": \"left\",\n            \"type\": \"OpIndex\",\n            \"purpose\": \"Left operand of the binop\"\n          },\n          {\n            \"name\": \"right\",\n            \"type\": \"OpIndex\",\n            \"purpose\": \"Right operand of the binop\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"std::optional<BaseWithScaledIndexAndDisplacementMatch>\",\n          \"description\": \"Optional BaseWithScaledIndexAndDisplacementMatch struct, or std::nullopt if no match.\"\n        },\n        \"dependencies\": [\n          \"MatchScaledIndex\",\n          \"WordBinopOp\",\n          \"BaseWithScaledIndexAndDisplacementMatch\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstd::optional<BaseWithScaledIndexAndDisplacementMatch>\nTryMatchBaseWithScaledIndexAndDisplacementForWordBinop(\n    InstructionSelectorT* selector, OpIndex left, OpIndex right) {\n  BaseWithScaledIndexAndDisplacementMatch result;\n  result.displacement_mode = kPositiveDisplacement;\n\n  auto OwnedByAddressingOperand = [](OpIndex) {\n    // TODO(nicohartmann@): Consider providing this. For now we just allow\n    // everything to be covered regardless of other uses.\n    return true;\n  };\n\n  // Check (S + ...)\n  if (MatchScaledIndex(selector, left, &result.index, &result.scale, nullptr) &&\n      OwnedByAddressingOperand(left)) {\n    result.displacement_mode = kPositiveDisplacement;\n\n    // Check (S + (... binop ...))\n    if (const WordBinopOp* right_binop =\n            selector->Get(right).TryCast<WordBinopOp>()) {\n      // Check (S + (B - D))\n      if (right_binop->kind == WordBinopOp::Kind::kSub &&\n          OwnedByAddressingOperand(right)) {\n        if (!selector->MatchIntegralWord32Constant(right_binop->right(),\n                                                   &result.displacement)) {\n          return std::nullopt;\n        }\n        result.base = right_binop->left();\n        result.displacement_mode = kNegativeDisplacement;\n        return result;\n      }\n      // Check (S + (... + ...))\n      if (right_binop->kind == WordBinopOp::Kind::kAdd &&\n          OwnedByAddressingOperand(right)) {\n        if (selector->MatchIntegralWord32Constant(right_binop->right(),\n                                                  &result.displacement)) {\n          // (S + (B + D))\n          result.base = right_binop->left();\n        } else if (selector->MatchIntegralWord32Constant(\n                       right_binop->left(), &result.displacement)) {\n          // (S + (D + B))\n          result.base = right_binop->right();\n        } else {\n          // Treat it as (S + B)\n          result.base = right;\n          result.displacement = 0;\n        }\n        return result;\n      }\n    }\n\n    // Check (S + D)\n    if (selector->MatchIntegralWord32Constant(right, &result.displacement)) {\n      result.base = OpIndex{};\n      return result;\n    }\n\n    // Treat it as (S + B)\n    result.base = right;\n    result.displacement = 0;\n    return result;\n  }\n\n  // Check ((... + ...) + ...)\n  if (const WordBinopOp* left_add = selector->Get(left).TryCast<WordBinopOp>();\n      left_add && left_add->kind == WordBinopOp::Kind::kAdd &&\n      OwnedByAddressingOperand(left)) {\n    // Check ((S + ...) + ...)\n    if (MatchScaledIndex(selector, left_add->left(), &result.index,\n                         &result.scale, nullptr)) {\n      result.displacement_mode = kPositiveDisplacement;\n      // Check ((S + D) + B)\n      if (selector->MatchIntegralWord32Constant(left_add->right(),\n                                                &result.displacement)) {\n        result.base = right;\n        return result;\n      }\n      // Check ((S + B) + D)\n      if (selector->MatchIntegralWord32Constant(right, &result.displacement)) {\n        result.base = left_add->right();\n        return result;\n      }\n      // Treat it as (B + B) and use index as right B.\n      result.base = left;\n      result.index = right;\n      result.scale = 0;\n      DCHECK_EQ(result.displacement, 0);\n      return result;\n    }\n  }\n\n  DCHECK_EQ(result.index, OpIndex{});\n  DCHECK_EQ(result.scale, 0);\n  result.displacement_mode = kPositiveDisplacement;\n\n  // Check (B + D)\n  if (selector->MatchIntegralWord32Constant(right, &result.displacement)) {\n    result.base = left;\n    return result;\n  }\n\n  // Treat as (B + B) and use index as left B.\n  result.index = left;\n  result.base = right;\n  return result;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"TryMatchBaseWithScaledIndexAndDisplacement\",\n        \"about\": \"Attempts to match a base with scaled index and displacement for general memory access patterns (loads/stores).\",\n        \"logic\": \"This function attempts to match various addressing mode patterns common in memory access operations. The patterns considered are of the form (S + (B + D)), (S + (B + B)), (S + D), (S + B), ((S + D) + B), ((S + B) + D), ((B + D) + B), ((B + B) + D), (B + D), and (B + B), where S is the scaled index, B is the base input, and D is the displacement input.\",\n        \"parameters\": [\n          {\n            \"name\": \"selector\",\n            \"type\": \"InstructionSelectorT*\",\n            \"purpose\": \"Instruction selector instance.\"\n          },\n          {\n            \"name\": \"node\",\n            \"type\": \"OpIndex\",\n            \"purpose\": \"OpIndex of the node to match.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"std::optional<BaseWithScaledIndexAndDisplacementMatch>\",\n          \"description\": \"An optional BaseWithScaledIndexAndDisplacementMatch struct, or std::nullopt if no match is found.\"\n        },\n        \"dependencies\": [\n          \"LoadOp\",\n          \"StoreOp\",\n          \"WordBinopOp\",\n          \"TryMatchBaseWithScaledIndexAndDisplacementForWordBinop\",\n          \"BaseWithScaledIndexAndDisplacementMatch\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstd::optional<BaseWithScaledIndexAndDisplacementMatch>\nTryMatchBaseWithScaledIndexAndDisplacement(InstructionSelectorT* selector,\n                                           OpIndex node) {\n  // The BaseWithIndexAndDisplacementMatcher canonicalizes the order of\n  // displacements and scale factors that are used as inputs, so instead of\n  // enumerating all possible patterns by brute force, checking for node\n  // clusters using the following templates in the following order suffices\n  // to find all of the interesting cases (S = index * scale, B = base\n  // input, D = displacement input):\n  //\n  // (S + (B + D))\n  // (S + (B + B))\n  // (S + D)\n  // (S + B)\n  // ((S + D) + B)\n  // ((S + B) + D)\n  // ((B + D) + B)\n  // ((B + B) + D)\n  // (B + D)\n  // (B + B)\n  BaseWithScaledIndexAndDisplacementMatch result;\n  result.displacement_mode = kPositiveDisplacement;\n\n  const Operation& op = selector->Get(node);\n  if (const LoadOp* load = op.TryCast<LoadOp>()) {\n    result.base = load->base();\n    result.index = load->index().value_or_invalid();\n    result.scale = load->element_size_log2;\n    result.displacement = load->offset;\n    if (load->kind.tagged_base) result.displacement -= kHeapObjectTag;\n    return result;\n  } else if (const StoreOp* store = op.TryCast<StoreOp>()) {\n    result.base = store->base();\n    result.index = store->index().value_or_invalid();\n    result.scale = store->element_size_log2;\n    result.displacement = store->offset;\n    if (store->kind.tagged_base) result.displacement -= kHeapObjectTag;\n    return result;\n  } else if (op.Is<WordBinopOp>()) {\n    // Nothing to do here, fall into the case below.\n#ifdef V8_ENABLE_WEBASSEMBLY\n  } else if (const Simd128LaneMemoryOp* lane_op =\n                 op.TryCast<Simd128LaneMemoryOp>()) {\n    result.base = lane_op->base();\n    result.index = lane_op->index();\n    result.scale = 0;\n    result.displacement = 0;\n    if (lane_op->kind.tagged_base) result.displacement -= kHeapObjectTag;\n    return result;\n  } else if (const Simd128LoadTransformOp* load_transform =\n                 op.TryCast<Simd128LoadTransformOp>()) {\n    result.base = load_transform->base();\n    result.index = load_transform->index();\n    DCHECK_EQ(load_transform->offset, 0);\n    result.scale = 0;\n    result.displacement = 0;\n    DCHECK(!load_transform->load_kind.tagged_base);\n    return result;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  } else {\n    return std::nullopt;\n  }\n\n  const WordBinopOp& binop = op.Cast<WordBinopOp>();\n  OpIndex left = binop.left();\n  OpIndex right = binop.right();\n  return TryMatchBaseWithScaledIndexAndDisplacementForWordBinop(selector, left,\n                                                                right);\n}\n    ]]></code>\n  </func>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"IA32OperandGeneratorT\",\n        \"extends\": \"OperandGeneratorT\",\n        \"about\": \"IA32-specific operand generator, providing methods for generating operands suitable for IA32 instructions.\",\n        \"attributes\": []\n      }\n    </metadata>\n    <code><![CDATA[\nclass IA32OperandGeneratorT final : public OperandGeneratorT {\n public:\n  explicit IA32OperandGeneratorT(InstructionSelectorT* selector)\n      : OperandGeneratorT(selector) {}\n\n  InstructionOperand UseByteRegister(OpIndex node) {\n    // TODO(titzer): encode byte register use constraints.\n    return UseFixed(node, edx);\n  }\n\n  bool CanBeMemoryOperand(InstructionCode opcode, OpIndex node, OpIndex input,\n                          int effect_level) {\n    if (!this->IsLoadOrLoadImmutable(input)) return false;\n    if (!selector()->CanCover(node, input)) return false;\n    if (effect_level != selector()->GetEffectLevel(input)) {\n      return false;\n    }\n    MachineRepresentation rep =\n        this->load_view(input).loaded_rep().representation();\n    switch (opcode) {\n      case kIA32And:\n      case kIA32Or:\n      case kIA32Xor:\n      case kIA32Add:\n      case kIA32Sub:\n      case kIA32Cmp:\n      case kIA32Test:\n        return rep == MachineRepresentation::kWord32 || IsAnyTagged(rep);\n      case kIA32Cmp16:\n      case kIA32Test16:\n        return rep == MachineRepresentation::kWord16;\n      case kIA32Cmp8:\n      case kIA32Test8:\n        return rep == MachineRepresentation::kWord8;\n      default:\n        break;\n    }\n    return false;\n  }\n\n  bool CanBeImmediate(OpIndex node) {\n    if (this->IsExternalConstant(node)) return true;\n    if (const ConstantOp* constant = Get(node).TryCast<ConstantOp>()) {\n      switch (constant->kind) {\n        case ConstantOp::Kind::kWord32:\n        case ConstantOp::Kind::kRelocatableWasmCall:\n        case ConstantOp::Kind::kRelocatableWasmStubCall:\n        case ConstantOp::Kind::kSmi:\n          return true;\n        case ConstantOp::Kind::kNumber:\n          return constant->number().get_bits() == 0;\n        default:\n          break;\n      }\n    }\n    return false;\n  }\n\n  int32_t GetImmediateIntegerValue(OpIndex node) {\n    DCHECK(CanBeImmediate(node));\n    const ConstantOp& constant = Get(node).Cast<ConstantOp>();\n    if (constant.kind == ConstantOp::Kind::kWord32) return constant.word32();\n    if (constant.kind == ConstantOp::Kind::kSmi) {\n      return static_cast<int32_t>(constant.smi().ptr());\n    }\n    DCHECK_EQ(constant.kind, ConstantOp::Kind::kNumber);\n    DCHECK_EQ(constant.number().get_bits(), 0);\n    return 0;\n  }\n\n  bool ValueFitsIntoImmediate(int64_t value) const {\n    // int32_t min will overflow if displacement mode is kNegativeDisplacement.\n    return std::numeric_limits<int32_t>::min() < value &&\n           value <= std::numeric_limits<int32_t>::max();\n  }\n\n  AddressingMode GenerateMemoryOperandInputs(\n      OptionalOpIndex index, int scale, OpIndex base, int32_t displacement,\n      DisplacementMode displacement_mode, InstructionOperand inputs[],\n      size_t* input_count,\n      RegisterMode register_mode = RegisterMode::kRegister) {\n    AddressingMode mode = kMode_MRI;\n    if (displacement_mode == kNegativeDisplacement) {\n      displacement = base::bits::WraparoundNeg32(displacement);\n    }\n    if (base.valid()) {\n      if (const ConstantOp* constant = Get(base).TryCast<ConstantOp>()) {\n        if (constant->kind == ConstantOp::Kind::kWord32) {\n          displacement =\n              base::bits::WraparoundAdd32(displacement, constant->word32());\n          base = OpIndex{};\n        } else if (constant->kind == ConstantOp::Kind::kSmi) {\n          displacement = base::bits::WraparoundAdd32(\n              displacement, static_cast<int32_t>(constant->smi().ptr()));\n          base = OpIndex{};\n        }\n      }\n    }\n    if (base.valid()) {\n      inputs[(*input_count)++] = UseRegisterWithMode(base, register_mode);\n      if (index.valid()) {\n        DCHECK(scale >= 0 && scale <= 3);\n        inputs[(*input_count)++] =\n            UseRegisterWithMode(this->value(index), register_mode);\n        if (displacement != 0) {\n          inputs[(*input_count)++] = TempImmediate(displacement);\n          static const AddressingMode kMRnI_modes[] = {kMode_MR1I, kMode_MR2I,\n                                                       kMode_MR4I, kMode_MR8I};\n          mode = kMRnI_modes[scale];\n        } else {\n          static const AddressingMode kMRn_modes[] = {kMode_MR1, kMode_MR2,\n                                                      kMode_MR4, kMode_MR8};\n          mode = kMRn_modes[scale];\n        }\n      } else {\n        if (displacement == 0) {\n          mode = kMode_MR;\n        } else {\n          inputs[(*input_count)++] = TempImmediate(displacement);\n          mode = kMode_MRI;\n        }\n      }\n    } else {\n      DCHECK(scale >= 0 && scale <= 3);\n      if (index.valid()) {\n        inputs[(*input_count)++] =\n            UseRegisterWithMode(this->value(index), register_mode);\n        if (displacement != 0) {\n          inputs[(*input_count)++] = TempImmediate(displacement);\n          static const AddressingMode kMnI_modes[] = {kMode_MRI, kMode_M2I,\n                                                      kMode_M4I, kMode_M8I};\n          mode = kMnI_modes[scale];\n        } else {\n          static const AddressingMode kMn_modes[] = {kMode_MR, kMode_M2,\n                                                     kMode_M4, kMode_M8};\n          mode = kMn_modes[scale];\n        }\n      } else {\n        inputs[(*input_count)++] = TempImmediate(displacement);\n        return kMode_MI;\n      }\n    }\n    return mode;\n  }\n\n  AddressingMode GetEffectiveAddressMemoryOperand(\n      OpIndex node, InstructionOperand inputs[], size_t* input_count,\n      RegisterMode register_mode = RegisterMode::kRegister) {\n    const Operation& op = this->Get(node);\n    if (op.Is<LoadOp>() || op.Is<StoreOp>()) {\n      LoadStoreView load_or_store(op);\n      if (ExternalReference reference;\n          this->MatchExternalConstant(load_or_store.base, &reference) &&\n          !load_or_store.index.valid()) {\n        if (selector()->CanAddressRelativeToRootsRegister(reference)) {\n          const ptrdiff_t delta =\n              load_or_store.offset +\n              MacroAssemblerBase::RootRegisterOffsetForExternalReference(\n                  selector()->isolate(), reference);\n          if (is_int32(delta)) {\n            inputs[(*input_count)++] =\n                TempImmediate(static_cast<int32_t>(delta));\n            return kMode_Root;\n          }\n        }\n      }\n    }\n\n    auto m = TryMatchBaseWithScaledIndexAndDisplacement(selector(), node);\n    DCHECK(m.has_value());\n    if (m->base.valid() &&\n        this->Get(m->base).template Is<LoadRootRegisterOp>()) {\n      DCHECK(!m->index.valid());\n      DCHECK_EQ(m->scale, 0);\n      DCHECK(ValueFitsIntoImmediate(m->displacement));\n      inputs[(*input_count)++] =\n          UseImmediate(static_cast<int>(m->displacement));\n      return kMode_Root;\n    } else if (ValueFitsIntoImmediate(m->displacement)) {\n      return GenerateMemoryOperandInputs(m->index, m->scale, m->base,\n                                         m->displacement, m->displacement_mode,\n                                         inputs, input_count, register_mode);\n    } else if (!m->base.valid() &&\n               m->displacement_mode == kPositiveDisplacement) {\n      // The displacement cannot be an immediate, but we can use the\n      // displacement as base instead and still benefit from addressing\n      // modes for the scale.\n      UNIMPLEMENTED();\n    } else {\n      // TODO(nicohartmann@): Turn this into a `DCHECK` once we have some\n      // coverage.\n      CHECK_EQ(m->displacement, 0);\n      inputs[(*input_count)++] = UseRegisterWithMode(m->base, register_mode);\n      inputs[(*input_count)++] = UseRegisterWithMode(m->index, register_mode);\n      return kMode_MR1;\n    }\n  }\n\n  InstructionOperand GetEffectiveIndexOperand(OpIndex index,\n                                              AddressingMode* mode) {\n    if (CanBeImmediate(index)) {\n      *mode = kMode_MRI;\n      return UseImmediate(index);\n    } else {\n      *mode = kMode_MR1;\n      return UseUniqueRegister(index);\n    }\n  }\n\n  bool CanBeBetterLeftOperand(OpIndex node) const {\n    return !selector()->IsLive(node);\n  }\n};\n    ]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        "
}