{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/interpreter/bytecode-array-builder.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/interpreter/bytecode-array-builder.cc\",\n        \"file_name\": \"bytecode-array-builder.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implementation of the BytecodeArrayBuilder class, which is responsible for constructing bytecode arrays for the V8 interpreter.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for bytecode array building, AST traversal, common utilities, interpreter intrinsics, and object manipulation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/interpreter/bytecode-array-builder.h\"\n\n            #include <optional>\n\n            #include \"src/ast/scopes.h\"\n            #include \"src/ast/variables.h\"\n            #include \"src/common/assert-scope.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/interpreter/bytecode-array-writer.h\"\n            #include \"src/interpreter/bytecode-jump-table.h\"\n            #include \"src/interpreter/bytecode-label.h\"\n            #include \"src/interpreter/bytecode-node.h\"\n            #include \"src/interpreter/bytecode-register-optimizer.h\"\n            #include \"src/interpreter/bytecode-source-info.h\"\n            #include \"src/interpreter/interpreter-intrinsics.h\"\n            #include \"src/objects/feedback-vector-inl.h\"\n            #include \"src/objects/smi.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RegisterTransferWriter\",\n            \"about\": \"Helper class to emit register transfer operations during bytecode optimization\",\n            \"extends\": \"BytecodeRegisterOptimizer::BytecodeWriter\",\n            \"implements\": [],\n            \"attributes\": [],\n            \"dependencies\": [\n                \"BytecodeArrayBuilder\",\n                \"BytecodeRegisterOptimizer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class RegisterTransferWriter final\n                : public NON_EXPORTED_BASE(BytecodeRegisterOptimizer::BytecodeWriter),\n                  public NON_EXPORTED_BASE(ZoneObject) {\n             public:\n              explicit RegisterTransferWriter(BytecodeArrayBuilder* builder)\n                  : builder_(builder) {}\n              ~RegisterTransferWriter() override = default;\n\n              void EmitLdar(Register input) override { builder_->OutputLdarRaw(input); }\n\n              void EmitStar(Register output) override { builder_->OutputStarRaw(output); }\n\n              void EmitMov(Register input, Register output) override {\n                builder_->OutputMovRaw(input, output);\n              }\n\n             private:\n              BytecodeArrayBuilder* builder_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BytecodeArrayBuilder\",\n            \"about\": \"Builds bytecode arrays for the V8 interpreter.  Manages registers, constants, handlers, and source positions.\",\n            \"extends\": null,\n            \"implements\": [],\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory zone for allocations\"\n                },\n                {\n                    \"name\": \"feedback_vector_spec_\",\n                    \"type\": \"FeedbackVectorSpec*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Specifies the structure of the feedback vector\"\n                },\n                {\n                    \"name\": \"bytecode_generated_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to indicate if bytecode has been generated\"\n                },\n                {\n                    \"name\": \"constant_array_builder_\",\n                    \"type\": \"ConstantArrayBuilder\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Builds the constant array\"\n                },\n                {\n                    \"name\": \"handler_table_builder_\",\n                    \"type\": \"HandlerTableBuilder\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Builds the handler table for exception handling\"\n                },\n                {\n                    \"name\": \"parameter_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of parameters for the function\"\n                },\n                {\n                    \"name\": \"max_arguments_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maximum number of arguments passed in calls\"\n                },\n                {\n                    \"name\": \"local_register_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of local registers\"\n                },\n                {\n                    \"name\": \"register_allocator_\",\n                    \"type\": \"RegisterAllocator\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Allocates registers\"\n                },\n                {\n                    \"name\": \"bytecode_array_writer_\",\n                    \"type\": \"BytecodeArrayWriter\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Writes bytecode into the array\"\n                },\n                {\n                    \"name\": \"register_optimizer_\",\n                    \"type\": \"BytecodeRegisterOptimizer*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Optimizes register usage (optional)\"\n                },\n                {\n                    \"name\": \"latest_source_info_\",\n                    \"type\": \"BytecodeSourceInfo\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the latest source position information\"\n                },\n                {\n                    \"name\": \"deferred_source_info_\",\n                    \"type\": \"BytecodeSourceInfo\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores source position to be attached to the next BytecodeNode\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"FeedbackVectorSpec\",\n                \"ConstantArrayBuilder\",\n                \"HandlerTableBuilder\",\n                \"BytecodeArrayWriter\",\n                \"BytecodeRegisterOptimizer\",\n                \"RegisterAllocator\",\n                \"Bytecode\",\n                \"BytecodeNode\",\n                \"BytecodeLabel\",\n                \"BytecodeLoopHeader\",\n                \"BytecodeJumpTable\",\n                \"BytecodeSourceInfo\",\n                \"Register\",\n                \"RegisterList\",\n                \"AstRawString\",\n                \"Scope\",\n                \"Smi\",\n                \"AstConsString\",\n                \"AstBigInt\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class BytecodeArrayBuilder {\n             public:\n              BytecodeArrayBuilder(\n                  Zone* zone, int parameter_count, int locals_count,\n                  FeedbackVectorSpec* feedback_vector_spec,\n                  SourcePositionTableBuilder::RecordingMode source_position_mode);\n\n              Register Parameter(int parameter_index) const;\n              Register Receiver() const;\n              Register Local(int index) const;\n\n              template <typename IsolateT>\n              Handle<BytecodeArray> ToBytecodeArray(IsolateT* isolate);\n\n            #ifdef DEBUG\n              int CheckBytecodeMatches(Tagged<BytecodeArray> bytecode);\n            #endif\n\n              template <typename IsolateT>\n              DirectHandle<TrustedByteArray> ToSourcePositionTable(\n                  IsolateT* isolate);\n\n              BytecodeSourceInfo CurrentSourcePosition(Bytecode bytecode);\n\n              void SetDeferredSourceInfo(\n                  BytecodeSourceInfo source_info);\n\n              void AttachOrEmitDeferredSourceInfo(BytecodeNode* node);\n\n              void Write(BytecodeNode* node);\n              void WriteJump(BytecodeNode* node, BytecodeLabel* label);\n              void WriteJumpLoop(BytecodeNode* node,\n                                              BytecodeLoopHeader* loop_header);\n              void WriteSwitch(BytecodeNode* node,\n                                            BytecodeJumpTable* jump_table);\n\n              void OutputLdarRaw(Register reg);\n              void OutputStarRaw(Register reg);\n              void OutputMovRaw(Register src, Register dest);\n\n              template <typename... Operands>\n              BytecodeNode CreateLdaZeroNode() {\n                return BytecodeNodeBuilder<Bytecode::kLdaZero, ImplicitRegisterUse::kNone>::Make(\n                    this);\n              }\n\n              template <typename... Operands>\n              void OutputLdaZero() {\n                BytecodeNode node(CreateLdaZeroNode());\n                Write(&node);\n              }\n\n              template <typename... Operands>\n              BytecodeNode CreateLdaSmiNode(int value) {\n                return BytecodeNodeBuilder<Bytecode::kLdaSmi, ImplicitRegisterUse::kNone,\n                                          OperandType::kImm>::Make(this, value);\n              }\n\n              template <typename... Operands>\n              void OutputLdaSmi(int value) {\n                BytecodeNode node(CreateLdaSmiNode(value));\n                Write(&node);\n              }\n\n              template <typename... Operands>\n              BytecodeNode CreateLdaConstantNode(size_t entry) {\n                return BytecodeNodeBuilder<Bytecode::kLdaConstant, ImplicitRegisterUse::kNone,\n                                          OperandType::kIdx>::Make(this, entry);\n              }\n\n              template <typename... Operands>\n              void OutputLdaConstant(size_t entry) {\n                BytecodeNode node(CreateLdaConstantNode(entry));\n                Write(&node);\n              }\n\n              template <typename... Operands>\n              BytecodeNode CreateLdaUndefinedNode() {\n                return BytecodeNodeBuilder<Bytecode::kLdaUndefined, ImplicitRegisterUse::kNone>::Make(\n                    this);\n              }\n\n              template <typename... Operands>\n              void OutputLdaUndefined() {\n                BytecodeNode node(CreateLdaUndefinedNode());\n                Write(&node);\n              }\n\n              template <typename... Operands>\n              BytecodeNode CreateLdaNullNode() {\n                return BytecodeNodeBuilder<Bytecode::kLdaNull, ImplicitRegisterUse::kNone>::Make(this);\n              }\n\n              template <typename... Operands>\n              void OutputLdaNull() {\n                BytecodeNode node(CreateLdaNullNode());\n                Write(&node);\n              }\n\n              template <typename... Operands>\n              BytecodeNode CreateLdaTheHoleNode() {\n                return BytecodeNodeBuilder<Bytecode::kLdaTheHole, ImplicitRegisterUse::kNone>::Make(\n                    this);\n              }\n\n              template <typename... Operands>\n              void OutputLdaTheHole() {\n                BytecodeNode node(CreateLdaTheHoleNode());\n                Write(&node);\n              }\n\n              template <typename... Operands>\n              BytecodeNode CreateLdaTrueNode() {\n                return BytecodeNodeBuilder<Bytecode::kLdaTrue, ImplicitRegisterUse::kNone>::Make(this);\n              }\n\n              template <typename... Operands>\n              void OutputLdaTrue() {\n                BytecodeNode node(CreateLdaTrueNode());\n                Write(&node);\n              }\n\n              template <typename... Operands>\n              BytecodeNode CreateLdaFalseNode() {\n                return BytecodeNodeBuilder<Bytecode::kLdaFalse, ImplicitRegisterUse::kNone>::Make(\n                    this);\n              }\n\n              template <typename... Operands>\n              void OutputLdaFalse() {\n                BytecodeNode node(CreateLdaFalseNode());\n                Write(&node);\n              }\n\n              BytecodeArrayBuilder& BinaryOperation(Token::Value op,\n                                                               Register reg,\n                                                               int feedback_slot);\n              BytecodeArrayBuilder& BinaryOperationSmiLiteral(\n                  Token::Value op, Tagged<Smi> literal, int feedback_slot);\n              BytecodeArrayBuilder& UnaryOperation(Token::Value op,\n                                                              int feedback_slot);\n              BytecodeArrayBuilder& LogicalNot(ToBooleanMode mode);\n              BytecodeArrayBuilder& TypeOf(int feedback_slot);\n              BytecodeArrayBuilder& GetSuperConstructor(Register out);\n              BytecodeArrayBuilder&\n                  FindNonDefaultConstructorOrConstruct(\n                      Register this_function, Register new_target, RegisterList output);\n              BytecodeArrayBuilder& CompareOperation(\n                  Token::Value op, Register reg, int feedback_slot);\n              BytecodeArrayBuilder& CompareReference(Register reg);\n              BytecodeArrayBuilder& CompareUndetectable();\n              BytecodeArrayBuilder& CompareUndefined();\n              BytecodeArrayBuilder& CompareNull();\n              BytecodeArrayBuilder& CompareNil(Token::Value op, NilValue nil);\n              BytecodeArrayBuilder& CompareTypeOf(\n                  TestTypeOfFlags::LiteralFlag literal_flag);\n\n              BytecodeArrayBuilder& LoadConstantPoolEntry(\n                  size_t entry);\n              BytecodeArrayBuilder& LoadLiteral(Tagged<Smi> smi);\n              BytecodeArrayBuilder& LoadLiteral(double value);\n              BytecodeArrayBuilder& LoadLiteral(\n                  const AstRawString* raw_string);\n              BytecodeArrayBuilder& LoadLiteral(\n                  const AstConsString* cons_string);\n              BytecodeArrayBuilder& LoadLiteral(const Scope* scope);\n              BytecodeArrayBuilder& LoadLiteral(AstBigInt bigint);\n              BytecodeArrayBuilder& LoadUndefined();\n              BytecodeArrayBuilder& LoadNull();\n              BytecodeArrayBuilder& LoadTheHole();\n              BytecodeArrayBuilder& LoadTrue();\n              BytecodeArrayBuilder& LoadFalse();\n              BytecodeArrayBuilder& LoadBoolean(bool value);\n              BytecodeArrayBuilder& LoadAccumulatorWithRegister(\n                  Register reg);\n              BytecodeArrayBuilder& StoreAccumulatorInRegister(\n                  Register reg);\n              BytecodeArrayBuilder& MoveRegister(Register from,\n                                                                 Register to);\n              BytecodeArrayBuilder& LoadGlobal(const AstRawString* name,\n                                                             int feedback_slot,\n                                                             TypeofMode typeof_mode);\n              BytecodeArrayBuilder& StoreGlobal(\n                  const AstRawString* name, int feedback_slot);\n              BytecodeArrayBuilder& LoadContextSlot(\n                  Register context, Variable* variable, int depth,\n                  ContextSlotMutability mutability);\n              BytecodeArrayBuilder& StoreContextSlot(Register context,\n                                                                  Variable* variable,\n                                                                  int depth);\n              BytecodeArrayBuilder& LoadLookupSlot(\n                  const AstRawString* name, TypeofMode typeof_mode);\n              BytecodeArrayBuilder& LoadLookupContextSlot(\n                  const AstRawString* name, TypeofMode typeof_mode, ContextKind context_kind,\n                  int slot_index, int depth);\n              BytecodeArrayBuilder& LoadLookupGlobalSlot(\n                  const AstRawString* name, TypeofMode typeof_mode, int feedback_slot,\n                  int depth);\n              BytecodeArrayBuilder& StoreLookupSlot(\n                  const AstRawString* name, LanguageMode language_mode,\n                  LookupHoistingMode lookup_hoisting_mode);\n\n              BytecodeArrayBuilder& LoadNamedProperty(\n                  Register object, const AstRawString* name, int feedback_slot);\n              BytecodeArrayBuilder& LoadNamedPropertyFromSuper(\n                  Register object, const AstRawString* name, int feedback_slot);\n              BytecodeArrayBuilder& LoadKeyedProperty(\n                  Register object, int feedback_slot);\n              BytecodeArrayBuilder& LoadEnumeratedKeyedProperty(\n                  Register object, Register enum_index, Register cache_type,\n                  int feedback_slot);\n              BytecodeArrayBuilder& LoadIteratorProperty(\n                  Register object, int feedback_slot);\n              BytecodeArrayBuilder& GetIterator(\n                  Register object, int load_feedback_slot, int call_feedback_slot);\n              BytecodeArrayBuilder& LoadAsyncIteratorProperty(\n                  Register object, int feedback_slot);\n              BytecodeArrayBuilder& DefineKeyedOwnPropertyInLiteral(\n                  Register object, Register name, DefineKeyedOwnPropertyInLiteralFlags flags,\n                  int feedback_slot);\n              BytecodeArrayBuilder& SetNamedProperty(\n                  Register object, size_t name_index, int feedback_slot,\n                  LanguageMode language_mode);\n              BytecodeArrayBuilder& SetNamedProperty(\n                  Register object, const AstRawString* name, int feedback_slot,\n                  LanguageMode language_mode);\n              BytecodeArrayBuilder& DefineNamedOwnProperty(\n                  Register object, const AstRawString* name, int feedback_slot);\n              BytecodeArrayBuilder& SetKeyedProperty(\n                  Register object, Register key, int feedback_slot,\n                  LanguageMode language_mode);\n              BytecodeArrayBuilder& DefineKeyedOwnProperty(\n                  Register object, Register key, DefineKeyedOwnPropertyFlags flags,\n                  int feedback_slot);\n              BytecodeArrayBuilder& StoreInArrayLiteral(\n                  Register array, Register index, int feedback_slot);\n              BytecodeArrayBuilder& StoreClassFieldsInitializer(\n                  Register constructor, int feedback_slot);\n              BytecodeArrayBuilder& LoadClassFieldsInitializer(\n                  Register constructor, int feedback_slot);\n              BytecodeArrayBuilder& CreateClosure(\n                  size_t shared_function_info_entry, int slot, int flags);\n              BytecodeArrayBuilder& CreateBlockContext(\n                  const Scope* scope);\n              BytecodeArrayBuilder& CreateCatchContext(\n                  Register exception, const Scope* scope);\n              BytecodeArrayBuilder& CreateFunctionContext(\n                  const Scope* scope, int slots);\n              BytecodeArrayBuilder& CreateEvalContext(\n                  const Scope* scope, int slots);\n              BytecodeArrayBuilder& CreateWithContext(\n                  Register object, const Scope* scope);\n              BytecodeArrayBuilder& CreateArguments(\n                  CreateArgumentsType type);\n              BytecodeArrayBuilder& CreateRegExpLiteral(\n                  const AstRawString* pattern, int literal_index, int flags);\n              BytecodeArrayBuilder& CreateEmptyArrayLiteral(\n                  int literal_index);\n              BytecodeArrayBuilder& CreateArrayLiteral(\n                  size_t constant_elements_entry, int literal_index, int flags);\n              BytecodeArrayBuilder& CreateArrayFromIterable();\n              BytecodeArrayBuilder& CreateObjectLiteral(\n                  size_t constant_properties_entry, int literal_index, int flags);\n              BytecodeArrayBuilder& CreateEmptyObjectLiteral();\n              BytecodeArrayBuilder& CloneObject(Register source,\n                                                                int flags,\n                                                                int feedback_slot);\n              BytecodeArrayBuilder& GetTemplateObject(\n                  size_t template_object_description_entry, int feedback_slot);\n\n              BytecodeArrayBuilder& PushContext(Register context);\n              BytecodeArrayBuilder& PopContext(Register context);\n\n              BytecodeArrayBuilder& ToObject(Register out);\n              BytecodeArrayBuilder& ToName();\n              BytecodeArrayBuilder& ToString();\n              BytecodeArrayBuilder& ToBoolean(ToBooleanMode mode);\n              BytecodeArrayBuilder& ToNumber(int feedback_slot);\n              BytecodeArrayBuilder& ToNumeric(int feedback_slot);\n\n              BytecodeArrayBuilder& Bind(BytecodeLabel* label);\n              BytecodeArrayBuilder& Bind(\n                  BytecodeLoopHeader* loop_header);\n              BytecodeArrayBuilder& Bind(BytecodeJumpTable* jump_table,\n                                                           int case_value);\n              BytecodeArrayBuilder& MarkHandler(\n                  int handler_id, HandlerTable::CatchPrediction catch_prediction);\n              BytecodeArrayBuilder& MarkTryBegin(int handler_id,\n                                                                  Register context);\n              BytecodeArrayBuilder& MarkTryEnd(int handler_id);\n\n              BytecodeArrayBuilder& Jump(BytecodeLabel* label);\n              BytecodeArrayBuilder& JumpIfTrue(ToBooleanMode mode,\n                                                                    BytecodeLabel* label);\n              BytecodeArrayBuilder& JumpIfFalse(ToBooleanMode mode,\n                                                                     BytecodeLabel* label);\n              BytecodeArrayBuilder& JumpIfNull(BytecodeLabel* label);\n              BytecodeArrayBuilder& JumpIfNotNull(\n                  BytecodeLabel* label);\n              BytecodeArrayBuilder& JumpIfUndefined(\n                  BytecodeLabel* label);\n              BytecodeArrayBuilder& JumpIfUndefinedOrNull(\n                  BytecodeLabel* label);\n              BytecodeArrayBuilder& JumpIfNotUndefined(\n                  BytecodeLabel* label);\n              BytecodeArrayBuilder& JumpIfNil(BytecodeLabel* label,\n                                                               Token::Value op,\n                                                               NilValue nil);\n              BytecodeArrayBuilder& JumpIfNotNil(BytecodeLabel* label,\n                                                                  Token::Value op,\n                                                                  NilValue nil);\n              BytecodeArrayBuilder& JumpIfJSReceiver(\n                  BytecodeLabel* label);\n              BytecodeArrayBuilder& JumpIfForInDone(\n                  BytecodeLabel* label, Register index, Register cache_length);\n              BytecodeArrayBuilder& JumpLoop(\n                  BytecodeLoopHeader* loop_header, int loop_depth, int position,\n                  int feedback_slot);\n              BytecodeArrayBuilder& SwitchOnSmiNoFeedback(\n                  BytecodeJumpTable* jump_table);\n\n              BytecodeArrayBuilder& SetPendingMessage();\n              BytecodeArrayBuilder& Throw();\n              BytecodeArrayBuilder& ReThrow();\n              BytecodeArrayBuilder& Abort(AbortReason reason);\n              BytecodeArrayBuilder& Return();\n              BytecodeArrayBuilder& ThrowReferenceErrorIfHole(\n                  const AstRawString* name);\n              BytecodeArrayBuilder& ThrowSuperNotCalledIfHole();\n              BytecodeArrayBuilder& ThrowSuperAlreadyCalledIfNotHole();\n              BytecodeArrayBuilder& ThrowIfNotSuperConstructor(\n                  Register constructor);\n              BytecodeArrayBuilder& Debugger();\n              BytecodeArrayBuilder& IncBlockCounter(\n                  int coverage_array_slot);\n\n              BytecodeArrayBuilder& ForInEnumerate(Register receiver);\n              BytecodeArrayBuilder& ForInPrepare(\n                  RegisterList cache_info_triple, int feedback_slot);\n              BytecodeArrayBuilder& ForInNext(\n                  Register receiver, Register index, RegisterList cache_type_array_pair,\n                  int feedback_slot);\n              BytecodeArrayBuilder& ForInStep(Register index);\n\n              BytecodeArrayBuilder& StoreModuleVariable(int cell_index,\n                                                                           int depth);\n              BytecodeArrayBuilder& LoadModuleVariable(int cell_index,\n                                                                          int depth);\n\n              BytecodeArrayBuilder& SuspendGenerator(\n                  Register generator, RegisterList registers, int suspend_id);\n              BytecodeArrayBuilder& SwitchOnGeneratorState(\n                  Register generator, BytecodeJumpTable* jump_table);\n              BytecodeArrayBuilder& ResumeGenerator(\n                  Register generator, RegisterList registers);\n\n              BytecodeArrayBuilder& CallProperty(Register callable,\n                                                                   RegisterList args,\n                                                                   int feedback_slot);\n              BytecodeArrayBuilder& CallUndefinedReceiver(\n                  Register callable, RegisterList args, int feedback_slot);\n              BytecodeArrayBuilder& CallAnyReceiver(Register callable,\n                                                                RegisterList args,\n                                                                int feedback_slot);\n              BytecodeArrayBuilder& CallWithSpread(Register callable,\n                                                                  RegisterList args,\n                                                                  int feedback_slot);\n              BytecodeArrayBuilder& Construct(Register constructor,\n                                                                RegisterList args,\n                                                                int feedback_slot_id);\n              BytecodeArrayBuilder& ConstructWithSpread(\n                  Register constructor, RegisterList args, int feedback_slot_id);\n              BytecodeArrayBuilder& ConstructForwardAllArgs(\n                  Register constructor, int feedback_slot_id);\n\n              BytecodeArrayBuilder& CallRuntime(\n                  Runtime::FunctionId function_id, RegisterList args);\n              BytecodeArrayBuilder& CallRuntime(\n                  Runtime::FunctionId function_id, Register arg);\n              BytecodeArrayBuilder& CallRuntime(\n                  Runtime::FunctionId function_id);\n              BytecodeArrayBuilder& CallRuntimeForPair(\n                  Runtime::FunctionId function_id, RegisterList args,\n                  RegisterList return_pair);\n              BytecodeArrayBuilder& CallRuntimeForPair(\n                  Runtime::FunctionId function_id, Register arg, RegisterList return_pair);\n              BytecodeArrayBuilder& CallJSRuntime(int context_index,\n                                                                    RegisterList args);\n\n              BytecodeArrayBuilder& Delete(Register object,\n                                                                 LanguageMode language_mode);\n\n              size_t GetConstantPoolEntry(\n                  const AstRawString* raw_string);\n              size_t GetConstantPoolEntry(\n                  const AstConsString* cons_string);\n              size_t GetConstantPoolEntry(AstBigInt bigint);\n              size_t GetConstantPoolEntry(const Scope* scope);\n              size_t GetConstantPoolEntry(double number);\n\n              static size_t AsyncIteratorSymbolConstantPoolEntry();\n              static size_t ClassFieldsSymbolConstantPoolEntry();\n              static size_t IteratorSymbolConstantPoolEntry();\n\n              BytecodeJumpTable* AllocateJumpTable(\n                  int size, int case_value_base);\n\n              size_t AllocateDeferredConstantPoolEntry();\n              void SetDeferredConstantPoolEntry(size_t entry,\n                                                                  Handle<Object> object);\n\n             private:\n              bool RegisterIsValid(Register reg) const;\n              bool RegisterListIsValid(RegisterList reg_list) const;\n\n              template <Bytecode bytecode, ImplicitRegisterUse implicit_register_use>\n              void PrepareToOutputBytecode();\n\n              uint32_t GetInputRegisterOperand(Register reg);\n              uint32_t GetOutputRegisterOperand(Register reg);\n              uint32_t GetInputOutputRegisterOperand(Register reg);\n              uint32_t GetInputRegisterListOperand(\n                  RegisterList reg_list);\n              uint32_t GetOutputRegisterListOperand(\n                  RegisterList reg_list);\n\n              Zone* zone() const { return zone_; }\n              ConstantArrayBuilder* constant_array_builder() {\n                return &constant_array_builder_;\n              }\n              HandlerTableBuilder* handler_table_builder() {\n                return &handler_table_builder_;\n              }\n              RegisterAllocator* register_allocator() { return &register_allocator_; }\n              int fixed_register_count() const { return local_register_count_; }\n              int locals_count() const { return local_register_count_; }\n              int parameter_count() const { return parameter_count_; }\n              int max_arguments() const { return max_arguments_; }\n              void set_max_arguments(int max_arguments) { max_arguments_ = max_arguments; }\n              int total_register_count() const {\n                return fixed_register_count() + register_allocator()->GetMaximumAllocated();\n              }\n              bool RemainderOfBlockIsDead() const {\n                return bytecode_array_writer_.RemainderOfBlockIsDead();\n              }\n\n              void EmitFunctionStartSourcePosition(int position);\n\n             public:\n              enum class ToBooleanMode {\n                kAlreadyBoolean,\n                kConvertToBoolean\n              };\n\n            private:\n              Zone* zone_;\n              FeedbackVectorSpec* feedback_vector_spec_;\n              bool bytecode_generated_;\n              ConstantArrayBuilder constant_array_builder_;\n              HandlerTableBuilder handler_table_builder_;\n              int parameter_count_;\n              int max_arguments_;\n              int local_register_count_;\n              RegisterAllocator register_allocator_;\n              BytecodeArrayWriter bytecode_array_writer_;\n              BytecodeRegisterOptimizer* register_optimizer_;\n              BytecodeSourceInfo latest_source_info_;\n              BytecodeSourceInfo deferred_source_info_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BytecodeArrayBuilder\",\n            \"parent\": \"BytecodeArrayBuilder\",\n            \"about\": \"Constructor for BytecodeArrayBuilder. Initializes internal state.\",\n            \"logic\": \"Initializes the member variables with provided values and creates instances of helper classes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"Memory zone for allocations\"\n                },\n                {\n                    \"name\": \"parameter_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Number of parameters of the function\"\n                },\n                {\n                    \"name\": \"locals_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Number of local variables\"\n                },\n                {\n                    \"name\": \"feedback_vector_spec\",\n                    \"type\": \"FeedbackVectorSpec*\",\n                    \"purpose\": \"Specifies the structure of feedback vector\"\n                },\n                {\n                    \"name\": \"source_position_mode\",\n                    \"type\": \"SourcePositionTableBuilder::RecordingMode\",\n                    \"purpose\": \"Specifies the recording mode of source positions\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"FeedbackVectorSpec\",\n                \"ConstantArrayBuilder\",\n                \"HandlerTableBuilder\",\n                \"BytecodeArrayWriter\",\n                \"BytecodeRegisterOptimizer\",\n                \"RegisterAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            BytecodeArrayBuilder::BytecodeArrayBuilder(\n                Zone* zone, int parameter_count, int locals_count,\n                FeedbackVectorSpec* feedback_vector_spec,\n                SourcePositionTableBuilder::RecordingMode source_position_mode)\n                : zone_(zone),\n                  feedback_vector_spec_(feedback_vector_spec),\n                  bytecode_generated_(false),\n                  constant_array_builder_(zone),\n                  handler_table_builder_(zone),\n                  parameter_count_(parameter_count),\n                  max_arguments_(0),\n                  local_register_count_(locals_count),\n                  register_allocator_(fixed_register_count()),\n                  bytecode_array_writer_(zone, &constant_array_builder_,\n                                         source_position_mode),\n                  register_optimizer_(nullptr) {\n              DCHECK_GE(parameter_count_, 0);\n              DCHECK_LE(parameter_count_, std::numeric_limits<uint16_t>::max());\n              DCHECK_GE(local_register_count_, 0);\n\n              if (v8_flags.ignition_reo) {\n                register_optimizer_ = zone->New<BytecodeRegisterOptimizer>(\n                    zone, &register_allocator_, fixed_register_count(), parameter_count,\n                    zone->New<RegisterTransferWriter>(this));\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Parameter\",\n            \"parent\": \"BytecodeArrayBuilder\",\n            \"about\": \"Calculates the register for a parameter given its index.\",\n            \"logic\": \"Parameter indices are shifted by 1 because the receiver is the first entry.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parameter_index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Index of the parameter\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Register\",\n                \"description\": \"The Register representing the parameter\"\n            },\n            \"dependencies\": [\n                \"Register\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Register BytecodeArrayBuilder::Parameter(int parameter_index) const {\n              DCHECK_GE(parameter_index, 0);\n              // The parameter indices are shifted by 1 (receiver is the\n              // first entry).\n              return Register::FromParameterIndex(parameter_index + 1);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Receiver\",\n            \"parent\": \"BytecodeArrayBuilder\",\n            \"about\": \"Returns the register for the receiver.\",\n            \"logic\": \"Returns register from parameter index 0 which represents the receiver.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Register\",\n                \"description\": \"The Register representing the receiver\"\n            },\n            \"dependencies\": [\n                \"Register\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Register BytecodeArrayBuilder::Receiver() const {\n              return Register::FromParameterIndex(0);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Local\",\n            \"parent\": \"BytecodeArrayBuilder\",\n            \"about\": \"Calculates the register for a local variable given its index.\",\n            \"logic\": \"Index of local registers starts from 0.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Index of the local variable\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Register\",\n                \"description\": \"The Register representing the local variable\"\n            },\n            \"dependencies\": [\n                \"Register\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Register BytecodeArrayBuilder::Local(int index) const {\n              DCHECK_LT(index, locals_count());\n              return Register(index);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ToBytecodeArray\",\n            \"parent\": \"BytecodeArrayBuilder\",\n            \"about\": \"Converts the built bytecode to a BytecodeArray object.\",\n            \"logic\": \"Flushes the register optimizer, calculates register count, retrieves the handler table, and delegates the final bytecode array creation to bytecode_array_writer_.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"IsolateT*\",\n                    \"purpose\": \"The isolate to allocate the BytecodeArray in\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Handle<BytecodeArray>\",\n                \"description\": \"The resulting BytecodeArray.\"\n            },\n            \"dependencies\": [\n                \"BytecodeArray\",\n                \"TrustedByteArray\",\n                \"BytecodeArrayWriter\",\n                \"BytecodeRegisterOptimizer\",\n                \"HandlerTableBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename IsolateT>\n            Handle<BytecodeArray> BytecodeArrayBuilder::ToBytecodeArray(IsolateT* isolate) {\n              DCHECK(RemainderOfBlockIsDead());\n              DCHECK(!bytecode_generated_);\n              bytecode_generated_ = true;\n\n              int register_count = total_register_count();\n\n              if (register_optimizer_) {\n                register_optimizer_->Flush();\n                register_count = register_optimizer_->maxiumum_register_index() + 1;\n              }\n\n              DirectHandle<TrustedByteArray> handler_table =\n                  handler_table_builder()->ToHandlerTable(isolate);\n              return bytecode_array_writer_.ToBytecodeArray(isolate, register_count,\n                                                            parameter_count(),\n                                                            max_arguments(), handler_table);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n"
}