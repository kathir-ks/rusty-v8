{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/torque-code-generator.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 34, column 52",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/torque-code-generator.h\",\n        \"file_name\": \"torque-code-generator.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the TorqueCodeGenerator class, which is responsible for generating code from a ControlFlowGraph in the Torque language.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ libraries and Torque-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <iostream>\n\n            #include \"src/torque/cfg.h\"\n            #include \"src/torque/declarable.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TorqueCodeGenerator\",\n            \"about\": \"Abstract class for generating code from a ControlFlowGraph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"cfg_\",\n                    \"type\": \"const ControlFlowGraph&\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The ControlFlowGraph to generate code from.\"\n                },\n                {\n                    \"name\": \"out_\",\n                    \"type\": \"std::ostream*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The output stream for the generated code.\"\n                },\n                {\n                    \"name\": \"out_decls_\",\n                    \"type\": \"std::ostream*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The output stream for declarations.\"\n                },\n                {\n                    \"name\": \"fresh_id_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Counter for generating unique names.\"\n                },\n                {\n                    \"name\": \"previous_position_\",\n                    \"type\": \"SourcePosition\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Stores the previous source position.\"\n                },\n                {\n                    \"name\": \"location_map_\",\n                    \"type\": \"std::map<DefinitionLocation, std::string>\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Maps DefinitionLocations to variable names.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ControlFlowGraph\",\n                \"std::ostream\",\n                \"SourcePosition\",\n                \"DefinitionLocation\",\n                \"Block\",\n                \"Instruction\",\n                \"Stack\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class TorqueCodeGenerator {\n            public:\n            TorqueCodeGenerator(const ControlFlowGraph& cfg, std::ostream& out)\n                : cfg_(cfg),\n                out_(&out),\n                out_decls_(&out),\n                previous_position_(SourcePosition::Invalid()) {}\n\n            protected:\n            const ControlFlowGraph& cfg_;\n            std::ostream* out_;\n            std::ostream* out_decls_;\n            size_t fresh_id_ = 0;\n            SourcePosition previous_position_;\n            std::map<DefinitionLocation, std::string> location_map_;\n\n            std::string DefinitionToVariable(const DefinitionLocation& location) {\n                if (location.IsPhi()) {\n                std::stringstream stream;\n                stream << \"phi_bb\" << location.GetPhiBlock()->id() << \"_\"\n                    << location.GetPhiIndex();\n                return stream.str();\n                } else if (location.IsParameter()) {\n                auto it = location_map_.find(location);\n                DCHECK_NE(it, location_map_.end());\n                return it->second;\n                } else {\n                DCHECK(location.IsInstruction());\n                auto it = location_map_.find(location);\n                if (it == location_map_.end()) {\n                    it = location_map_.insert(std::make_pair(location, FreshNodeName()))\n                            .first;\n                }\n                return it->second;\n                }\n            }\n\n            void SetDefinitionVariable(const DefinitionLocation& definition,\n                                    const std::string& str) {\n                DCHECK_EQ(location_map_.find(definition), location_map_.end());\n                location_map_.insert(std::make_pair(definition, str));\n            }\n\n            std::ostream& out() { return *out_; }\n            std::ostream& decls() { return *out_decls_; }\n\n            static bool IsEmptyInstruction(const Instruction& instruction);\n            virtual void EmitSourcePosition(SourcePosition pos,\n                                            bool always_emit = false) = 0;\n\n            std::string FreshNodeName() { return \"tmp\" + std::to_string(fresh_id_++); }\n            std::string FreshCatchName() { return \"catch\" + std::to_string(fresh_id_++); }\n            std::string FreshLabelName() { return \"label\" + std::to_string(fresh_id_++); }\n            std::string BlockName(const Block* block) {\n                return \"block\" + std::to_string(block->id());\n            }\n\n            void EmitInstruction(const Instruction& instruction,\n                                Stack<std::string>* stack);\n\n            template <typename T>\n            void EmitIRAnnotation(const T& instruction, Stack<std::string>* stack) {\n                out() << \"    // \" << instruction\n                    << \", starting stack size: \" << stack->Size() << \"\\n\";\n            }\n\n#define EMIT_INSTRUCTION_DECLARATION(T) \\\n            void EmitInstruction(const T& instruction, Stack<std::string>* stack);\n            TORQUE_BACKEND_AGNOSTIC_INSTRUCTION_LIST(EMIT_INSTRUCTION_DECLARATION)\n#undef EMIT_INSTRUCTION_DECLARATION\n\n#define EMIT_INSTRUCTION_DECLARATION(T)              \\\n            virtual void EmitInstruction(const T& instruction, \\\n                                        Stack<std::string>* stack) = 0;\n            TORQUE_BACKEND_DEPENDENT_INSTRUCTION_LIST(EMIT_INSTRUCTION_DECLARATION)\n#undef EMIT_INSTRUCTION_DECLARATION\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DefinitionToVariable\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Converts a DefinitionLocation to a variable name.\",\n            \"logic\": \"Generates a unique variable name based on the type of definition location (Phi, Parameter, or Instruction).\",\n            \"parameters\": [\n                {\n                    \"name\": \"location\",\n                    \"type\": \"const DefinitionLocation&\",\n                    \"purpose\": \"The DefinitionLocation to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The variable name.\"\n            },\n            \"dependencies\": [\n                \"DefinitionLocation\",\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::string DefinitionToVariable(const DefinitionLocation& location) {\n                if (location.IsPhi()) {\n                std::stringstream stream;\n                stream << \"phi_bb\" << location.GetPhiBlock()->id() << \"_\"\n                    << location.GetPhiIndex();\n                return stream.str();\n                } else if (location.IsParameter()) {\n                auto it = location_map_.find(location);\n                DCHECK_NE(it, location_map_.end());\n                return it->second;\n                } else {\n                DCHECK(location.IsInstruction());\n                auto it = location_map_.find(location);\n                if (it == location_map_.end()) {\n                    it = location_map_.insert(std::make_pair(location, FreshNodeName()))\n                            .first;\n                }\n                return it->second;\n                }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetDefinitionVariable\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Sets a variable name for a DefinitionLocation.\",\n            \"logic\": \"Stores the mapping between a DefinitionLocation and a variable name in the location_map_.\",\n            \"parameters\": [\n                {\n                    \"name\": \"definition\",\n                    \"type\": \"const DefinitionLocation&\",\n                    \"purpose\": \"The DefinitionLocation to set the variable name for.\"\n                },\n                {\n                    \"name\": \"str\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The variable name to set.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DefinitionLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void SetDefinitionVariable(const DefinitionLocation& definition,\n                                    const std::string& str) {\n                DCHECK_EQ(location_map_.find(definition), location_map_.end());\n                location_map_.insert(std::make_pair(definition, str));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"out\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Returns the output stream.\",\n            \"logic\": \"Returns the output stream *out_.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": [\n                \"std::ostream\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& out() { return *out_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"decls\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Returns the declaration output stream.\",\n            \"logic\": \"Returns the declaration output stream *out_decls_.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The declaration output stream.\"\n            },\n            \"dependencies\": [\n                \"std::ostream\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& decls() { return *out_decls_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsEmptyInstruction\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Checks if an instruction is empty.\",\n            \"logic\": \"Checks if the provided instruction is empty. Static method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const Instruction&\",\n                    \"purpose\": \"The instruction to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the instruction is empty, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool IsEmptyInstruction(const Instruction& instruction);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitSourcePosition\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Emits the source position to the output stream.\",\n            \"logic\": \"Emits the source position information to the output stream for debugging purposes. Abstract method, must be implemented by derived classes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pos\",\n                    \"type\": \"SourcePosition\",\n                    \"purpose\": \"The source position to emit.\"\n                },\n                {\n                    \"name\": \"always_emit\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether to always emit the source position, even if it's the same as the previous one.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"SourcePosition\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            virtual void EmitSourcePosition(SourcePosition pos,\n                                            bool always_emit = false) = 0;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FreshNodeName\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Generates a unique node name.\",\n            \"logic\": \"Generates a unique node name using the fresh_id_ counter.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The unique node name.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            std::string FreshNodeName() { return \"tmp\" + std::to_string(fresh_id_++); }\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FreshCatchName\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Generates a unique catch block name.\",\n            \"logic\": \"Generates a unique catch block name using the fresh_id_ counter.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The unique catch block name.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            std::string FreshCatchName() { return \"catch\" + std::to_string(fresh_id_++); }\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FreshLabelName\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Generates a unique label name.\",\n            \"logic\": \"Generates a unique label name using the fresh_id_ counter.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The unique label name.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            std::string FreshLabelName() { return \"label\" + std::to_string(fresh_id_++); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BlockName\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Generates a block name based on the block ID.\",\n            \"logic\": \"Generates a block name by concatenating 'block' with the block's ID.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const Block*\",\n                    \"purpose\": \"The block to generate a name for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The block name.\"\n            },\n            \"dependencies\": [\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::string BlockName(const Block* block) {\n                return \"block\" + std::to_string(block->id());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Emits an instruction.\",\n            \"logic\": \"Dispatches the instruction to the correct EmitInstruction overload based on its type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const Instruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Instruction\",\n                \"Stack\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void EmitInstruction(const Instruction& instruction,\n                                Stack<std::string>* stack);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitIRAnnotation\",\n            \"parent\": \"TorqueCodeGenerator\",\n            \"about\": \"Emits an IR annotation (comment) to the output stream.\",\n            \"logic\": \"Outputs the given instruction as a comment to the output stream, along with the current stack size. Used for debugging and tracing the code generation process.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The instruction to annotate.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Instruction\",\n                \"Stack\",\n                \"std::ostream\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void EmitIRAnnotation(const T& instruction, Stack<std::string>* stack) {\n                out() << \"    // \" << instruction\n                    << \", starting stack size: \" << stack->Size() << \"\\n\";\n            }\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ControlFlowGraph\",\n                \"about\": \"Represents the control flow graph of a program.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ControlFlowGraph {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SourcePosition\",\n                \"about\": \"Represents a position in the source code.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SourcePosition {\n                public:\n                    static SourcePosition Invalid();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DefinitionLocation\",\n                \"about\": \"Represents the location where a value is defined.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class DefinitionLocation {\n                public:\n                    bool IsPhi() const;\n                    bool IsParameter() const;\n                    bool IsInstruction() const;\n                    const class Block* GetPhiBlock() const;\n                    int GetPhiIndex() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Block\",\n                \"about\": \"Represents a basic block in the control flow graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Block {\n                public:\n                    int id() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Instruction\",\n                \"about\": \"Represents an instruction in the control flow graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Instruction {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Stack\",\n                \"about\": \"Represents a stack data structure.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class Stack {\n                public:\n                    size_t Size() const;\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}