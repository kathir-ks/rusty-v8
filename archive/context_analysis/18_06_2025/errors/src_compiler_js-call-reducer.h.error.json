{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-call-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 62, column 46",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-call-reducer.h\",\n            \"file_name\": \"js-call-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the JSCallReducer class, which performs strength reduction on JSConstruct and JSCall nodes in the compiler graph.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for optional types, base flags, compiler globals, graph reduction, node properties, and deoptimization reasons.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/flags.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/graph-reducer.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/deoptimizer/deoptimize-reason.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSCallReducer\",\n                \"extends\": \"AdvancedReducer\",\n                \"about\": \"Performs strength reduction on {JSConstruct} and {JSCall} nodes.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"jsgraph_\",\n                        \"type\": \"JSGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSGraph.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSHeapBroker.\"\n                    },\n                    {\n                        \"name\": \"temp_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to a temporary Zone for allocations.\"\n                    },\n                    {\n                        \"name\": \"flags_\",\n                        \"type\": \"Flags\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flags controlling the mode of operation.\"\n                    },\n                    {\n                        \"name\": \"waitlist_\",\n                        \"type\": \"std::set<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A set of nodes to revisit for reduction.\"\n                    },\n                    {\n                        \"name\": \"generated_calls_with_array_like_or_spread_\",\n                        \"type\": \"std::unordered_set<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set to prevent infinite recursion.\"\n                    },\n                    {\n                        \"name\": \"wasm_module_for_inlining_\",\n                        \"type\": \"const wasm::WasmModule*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"wasm module for inlining.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"JSGraph\",\n                    \"JSHeapBroker\",\n                    \"Zone\",\n                    \"CallFrequency\",\n                    \"FeedbackSource\",\n                    \"FieldAccess\",\n                    \"JSCallReducerAssembler\",\n                    \"JSOperatorBuilder\",\n                    \"MapInference\",\n                    \"NodeProperties\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"SharedFunctionInfoRef\",\n                    \"wasm::WasmModule\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE JSCallReducer final : public AdvancedReducer {\n public:\n  // Flags that control the mode of operation.\n  enum Flag {\n    kNoFlags = 0u,\n    kBailoutOnUninitialized = 1u << 0,\n    kInlineJSToWasmCalls = 1u << 1,\n  };\n  using Flags = base::Flags<Flag>;\n\n  JSCallReducer(Editor* editor, JSGraph* jsgraph, JSHeapBroker* broker,\n                Zone* temp_zone, Flags flags)\n      : AdvancedReducer(editor),\n        jsgraph_(jsgraph),\n        broker_(broker),\n        temp_zone_(temp_zone),\n        flags_(flags) {}\n\n  // Max string length for inlining entire match sequence for\n  // String.prototype.startsWith in JSCallReducer.\n  static constexpr int kMaxInlineMatchSequence = 3;\n\n  const char* reducer_name() const override { return \"JSCallReducer\"; }\n\n  Reduction Reduce(Node* node) final;\n\n  // Processes the waitlist gathered while the reducer was running,\n  // and does a final attempt to reduce the nodes in the waitlist.\n  void Finalize() final;\n\n  // JSCallReducer outsources much work to a graph assembler.\n  void RevisitForGraphAssembler(Node* node) { Revisit(node); }\n  Zone* ZoneForGraphAssembler() const { return temp_zone(); }\n  JSGraph* JSGraphForGraphAssembler() const { return jsgraph(); }\n\n#if V8_ENABLE_WEBASSEMBLY\n  bool has_js_wasm_calls() const {\n    return wasm_module_for_inlining_ != nullptr;\n  }\n  const wasm::WasmModule* wasm_module_for_inlining() const {\n    return wasm_module_for_inlining_;\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n  CompilationDependencies* dependencies() const;\n  JSHeapBroker* broker() const { return broker_; }\n\n private:\n  Reduction ReduceBooleanConstructor(Node* node);\n  Reduction ReduceCallApiFunction(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceCallWasmFunction(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceFunctionPrototypeApply(Node* node);\n  Reduction ReduceFunctionPrototypeBind(Node* node);\n  Reduction ReduceFunctionPrototypeCall(Node* node);\n  Reduction ReduceFunctionPrototypeHasInstance(Node* node);\n  Reduction ReduceObjectConstructor(Node* node);\n  Reduction ReduceObjectGetPrototype(Node* node, Node* object);\n  Reduction ReduceObjectGetPrototypeOf(Node* node);\n  Reduction ReduceObjectIs(Node* node);\n  Reduction ReduceObjectPrototypeGetProto(Node* node);\n  Reduction ReduceObjectPrototypeHasOwnProperty(Node* node);\n  Reduction ReduceObjectPrototypeIsPrototypeOf(Node* node);\n  Reduction ReduceObjectCreate(Node* node);\n  Reduction ReduceReflectApply(Node* node);\n  Reduction ReduceReflectConstruct(Node* node);\n  Reduction ReduceReflectGet(Node* node);\n  Reduction ReduceReflectGetPrototypeOf(Node* node);\n  Reduction ReduceReflectHas(Node* node);\n\n  Reduction ReduceArrayConstructor(Node* node);\n  Reduction ReduceArrayEvery(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceArrayFilter(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceArrayFindIndex(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceArrayFind(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceArrayForEach(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceArrayIncludes(Node* node);\n  Reduction ReduceArrayIndexOf(Node* node);\n  Reduction ReduceArrayIsArray(Node* node);\n  Reduction ReduceArrayMap(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceArrayPrototypeAt(Node* node);\n  Reduction ReduceArrayPrototypePop(Node* node);\n  Reduction ReduceArrayPrototypePush(Node* node);\n  Reduction ReduceArrayPrototypeShift(Node* node);\n  Reduction ReduceArrayPrototypeSlice(Node* node);\n  Reduction ReduceArrayReduce(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceArrayReduceRight(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceArraySome(Node* node, SharedFunctionInfoRef shared);\n\n  enum class ArrayIteratorKind { kArrayLike, kTypedArray };\n  Reduction ReduceArrayIterator(Node* node, ArrayIteratorKind array_kind,\n                                IterationKind iteration_kind);\n  Reduction ReduceArrayIteratorPrototypeNext(Node* node);\n  Reduction ReduceFastArrayIteratorNext(InstanceType type, Node* node,\n                                        IterationKind kind);\n\n  Reduction ReduceCallOrConstructWithArrayLikeOrSpreadOfCreateArguments(\n      Node* node, Node* arguments_list, int arraylike_or_spread_index,\n      CallFrequency const& frequency, FeedbackSource const& feedback,\n      SpeculationMode speculation_mode, CallFeedbackRelation feedback_relation);\n  Reduction ReduceCallOrConstructWithArrayLikeOrSpread(\n      Node* node, int argument_count, int arraylike_or_spread_index,\n      CallFrequency const& frequency, FeedbackSource const& feedback_source,\n      SpeculationMode speculation_mode, CallFeedbackRelation feedback_relation,\n      Node* target, Effect effect, Control control);\n  Reduction ReduceJSConstruct(Node* node);\n  Reduction ReduceJSConstructWithArrayLike(Node* node);\n  Reduction ReduceJSConstructWithSpread(Node* node);\n  Reduction ReduceJSConstructForwardAllArgs(Node* node);\n  Reduction ReduceJSCall(Node* node);\n  Reduction ReduceJSCall(Node* node, SharedFunctionInfoRef shared);\n  Reduction ReduceJSCallWithArrayLike(Node* node);\n  Reduction ReduceJSCallWithSpread(Node* node);\n  Reduction ReduceRegExpPrototypeTest(Node* node);\n  Reduction ReduceReturnReceiver(Node* node);\n\n  Reduction ReduceStringConstructor(Node* node, JSFunctionRef constructor);\n  enum class StringIndexOfIncludesVariant { kIncludes, kIndexOf };\n  Reduction ReduceStringPrototypeIndexOfIncludes(\n      Node* node, StringIndexOfIncludesVariant variant);\n  Reduction ReduceStringPrototypeSubstring(Node* node);\n  Reduction ReduceStringPrototypeSlice(Node* node);\n  Reduction ReduceStringPrototypeSubstr(Node* node);\n  Reduction ReduceStringPrototypeStringAt(\n      const Operator* string_access_operator, Node* node);\n  Reduction ReduceStringPrototypeCharAt(Node* node);\n  Reduction ReduceStringPrototypeStartsWith(Node* node);\n  Reduction ReduceStringPrototypeEndsWith(Node* node);\n\n#ifdef V8_INTL_SUPPORT\n  Reduction ReduceStringPrototypeLocaleCompareIntl(Node* node);\n  Reduction ReduceStringPrototypeToLowerCaseIntl(Node* node);\n  Reduction ReduceStringPrototypeToUpperCaseIntl(Node* node);\n#endif  // V8_INTL_SUPPORT\n\n  Reduction ReduceStringFromCharCode(Node* node);\n  Reduction ReduceStringFromCodePoint(Node* node);\n  Reduction ReduceStringPrototypeIterator(Node* node);\n  Reduction ReduceStringIteratorPrototypeNext(Node* node);\n  Reduction ReduceStringPrototypeConcat(Node* node);\n\n  Reduction ReducePromiseConstructor(Node* node);\n  Reduction ReducePromiseInternalConstructor(Node* node);\n  Reduction ReducePromiseInternalReject(Node* node);\n  Reduction ReducePromiseInternalResolve(Node* node);\n  Reduction ReducePromisePrototypeCatch(Node* node);\n  Reduction ReducePromisePrototypeFinally(Node* node);\n  Reduction ReducePromisePrototypeThen(Node* node);\n  Reduction ReducePromiseResolveTrampoline(Node* node);\n\n  Reduction ReduceTypedArrayConstructor(Node* node,\n                                        SharedFunctionInfoRef shared);\n  Reduction ReduceTypedArrayPrototypeToStringTag(Node* node);\n  Reduction ReduceArrayBufferViewByteLengthAccessor(Node* node,\n                                                    InstanceType instance_type,\n                                                    Builtin builtin);\n  Reduction ReduceArrayBufferViewByteOffsetAccessor(Node* node,\n                                                    InstanceType instance_type,\n                                                    Builtin builtin);\n  Reduction ReduceTypedArrayPrototypeLength(Node* node);\n\n  Reduction ReduceForInsufficientFeedback(Node* node, DeoptimizeReason reason);\n\n  Reduction ReduceMathUnary(Node* node, const Operator* op);\n  Reduction ReduceMathBinary(Node* node, const Operator* op);\n  Reduction ReduceMathImul(Node* node);\n  Reduction ReduceMathClz32(Node* node);\n  Reduction ReduceMathMinMax(Node* node, const Operator* op, Node* empty_value);\n\n  Reduction ReduceNumberIsFinite(Node* node);\n  Reduction ReduceNumberIsInteger(Node* node);\n  Reduction ReduceNumberIsSafeInteger(Node* node);\n  Reduction ReduceNumberIsNaN(Node* node);\n\n  Reduction ReduceGlobalIsFinite(Node* node);\n  Reduction ReduceGlobalIsNaN(Node* node);\n\n  Reduction ReduceMapPrototypeHas(Node* node);\n  Reduction ReduceMapPrototypeGet(Node* node);\n  Reduction ReduceSetPrototypeHas(Node* node);\n  Reduction ReduceCollectionPrototypeHas(Node* node,\n                                         CollectionKind collection_kind);\n  Reduction ReduceCollectionIteration(Node* node,\n                                      CollectionKind collection_kind,\n                                      IterationKind iteration_kind);\n  Reduction ReduceCollectionPrototypeSize(Node* node,\n                                          CollectionKind collection_kind);\n  Reduction ReduceCollectionIteratorPrototypeNext(\n      Node* node, int entry_size, Handle<HeapObject> empty_collection,\n      InstanceType collection_iterator_instance_type_first,\n      InstanceType collection_iterator_instance_type_last);\n\n  Reduction ReduceArrayBufferIsView(Node* node);\n  Reduction ReduceArrayBufferViewAccessor(Node* node,\n                                          InstanceType instance_type,\n                                          FieldAccess const& access,\n                                          Builtin builtin);\n\n  enum class DataViewAccess { kGet, kSet };\n  Reduction ReduceDataViewAccess(Node* node, DataViewAccess access,\n                                 ExternalArrayType element_type);\n\n  Reduction ReduceDatePrototypeGetTime(Node* node);\n  Reduction ReduceDateNow(Node* node);\n  Reduction ReduceNumberParseInt(Node* node);\n\n  Reduction ReduceNumberConstructor(Node* node);\n  Reduction ReduceBigIntConstructor(Node* node);\n  Reduction ReduceBigIntAsN(Node* node, Builtin builtin);\n\n  std::optional<Reduction> TryReduceJSCallMathMinMaxWithArrayLike(Node* node);\n  Reduction ReduceJSCallMathMinMaxWithArrayLike(Node* node, Builtin builtin);\n\n#ifdef V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\n  Reduction ReduceGetContinuationPreservedEmbedderData(Node* node);\n  Reduction ReduceSetContinuationPreservedEmbedderData(Node* node);\n#endif  // V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\n\n  // The pendant to ReplaceWithValue when using GraphAssembler-based reductions.\n  Reduction ReplaceWithSubgraph(JSCallReducerAssembler* gasm, Node* subgraph);\n  std::pair<Node*, Node*> ReleaseEffectAndControlFromAssembler(\n      JSCallReducerAssembler* gasm);\n\n  // Helper to verify promise receiver maps are as expected.\n  // On bailout from a reduction, be sure to return inference.NoChange().\n  bool DoPromiseChecks(MapInference* inference);\n\n  Node* CreateClosureFromBuiltinSharedFunctionInfo(SharedFunctionInfoRef shared,\n                                                   Node* context, Node* effect,\n                                                   Node* control);\n\n  void CheckIfElementsKind(Node* receiver_elements_kind, ElementsKind kind,\n                           Node* control, Node** if_true, Node** if_false);\n  Node* LoadReceiverElementsKind(Node* receiver, Effect* effect,\n                                 Control control);\n\n  bool IsBuiltinOrApiFunction(JSFunctionRef target_ref) const;\n\n  // Check whether an array has the expected length. Returns the new effect.\n  Node* CheckArrayLength(Node* array, ElementsKind elements_kind,\n                         uint32_t array_length,\n                         const FeedbackSource& feedback_source, Effect effect,\n                         Control control);\n\n  // Check whether the given new target value is a constructor function.\n  void CheckIfConstructor(Node* call);\n\n  Node* ConvertHoleToUndefined(Node* value, ElementsKind elements_kind);\n\n  TFGraph* graph() const;\n  JSGraph* jsgraph() const { return jsgraph_; }\n  Zone* temp_zone() const { return temp_zone_; }\n  Isolate* isolate() const;\n  Factory* factory() const;\n  NativeContextRef native_context() const;\n  CommonOperatorBuilder* common() const;\n  JSOperatorBuilder* javascript() const;\n  SimplifiedOperatorBuilder* simplified() const;\n  Flags flags() const { return flags_; }\n\n  JSGraph* const jsgraph_;\n  JSHeapBroker* const broker_;\n  Zone* const temp_zone_;\n  Flags const flags_;\n  std::set<Node*> waitlist_;\n\n  // For preventing infinite recursion via ReduceJSCallWithArrayLikeOrSpread.\n  std::unordered_set<Node*> generated_calls_with_array_like_or_spread_;\n\n#if V8_ENABLE_WEBASSEMBLY\n  const wasm::WasmModule* wasm_module_for_inlining_ = nullptr;\n#endif  // V8_ENABLE_WEBASSEMBLY\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"AdvancedReducer\",\n                    \"about\": \"Abstract base class for graph reducers.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class AdvancedReducer {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSGraph\",\n                    \"about\": \"Represents the graph of JS operations.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class JSGraph {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSHeapBroker\",\n                    \"about\": \"Provides access to the JS heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class JSHeapBroker {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Zone\",\n                    \"about\": \"Memory allocation zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Zone {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CompilationDependencies\",\n                    \"about\": \"Represents dependencies on compilation state.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class CompilationDependencies {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CallFrequency\",\n                    \"about\": \"Frequency with which a call occurs.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class CallFrequency {\n                public:\n                  CallFrequency() = default;\n              };\n            ]]></code>\n        </class>\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"FeedbackSource\",\n                    \"about\": \"Source of feedback information for optimization.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              struct FeedbackSource {};\n            ]]></code>\n        </struct>\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"FieldAccess\",\n                    \"about\": \"Represents access to a field in an object.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              struct FieldAccess {};\n            ]]></code>\n        </struct>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSCallReducerAssembler\",\n                    \"about\": \"Assembler for building graph subgraphs for JSCallReducer.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class JSCallReducerAssembler {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSOperatorBuilder\",\n                    \"about\": \"Builder for JS operators.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class JSOperatorBuilder {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"MapInference\",\n                    \"about\": \"Infers the map (shape) of objects.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class MapInference {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NodeProperties\",\n                    \"about\": \"Properties of nodes in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class NodeProperties {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SimplifiedOperatorBuilder\",\n                    \"about\": \"Builder for simplified operators.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class SimplifiedOperatorBuilder {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SharedFunctionInfoRef\",\n                    \"about\": \"Reference to a SharedFunctionInfo object.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class SharedFunctionInfoRef {};\n            ]]></code>\n        </class>\n        <namespace>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"namespace\",\n                    \"name\": \"wasm\",\n                    \"about\": \"Namespace for WebAssembly-related classes.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              namespace wasm {\n                class WasmModule {};\n              }\n            ]]></code>\n        </namespace>\n        <typedef>\n          <metadata>\n            {\n              \"language\": \"cpp\",\n              \"type\": \"typedef\",\n              \"name\": \"TFGraph\",\n              \"about\": \"Alias for the type of the graph.\"\n            }\n          </metadata>\n          <code><![CDATA[\n            class TFGraph {};\n          ]]></code>\n        </typedef>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Isolate\",\n                    \"about\": \"Represents a V8 isolate.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class Isolate {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Factory\",\n                    \"about\": \"Creates objects in the V8 heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class Factory {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NativeContextRef\",\n                    \"about\": \"Reference to a native context.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class NativeContextRef {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CommonOperatorBuilder\",\n                    \"about\": \"Builds common operators.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class CommonOperatorBuilder {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSFunctionRef\",\n                    \"about\": \"Reference to a JS function.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class JSFunctionRef {};\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"ElementsKind\",\n                    \"about\": \"Represents the kind of elements in an array.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              enum class ElementsKind {};\n            ]]></code>\n        </enum>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Builtin\",\n                    \"about\": \"Represents a built-in function.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              class Builtin {};\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"InstanceType\",\n                    \"about\": \"Represents the type of an object instance.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              enum class InstanceType {};\n            ]]></code>\n        </enum>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"ExternalArrayType\",\n                    \"about\": \"Type of elements in external array.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              enum class ExternalArrayType {};\n            ]]></code>\n        </enum>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"CollectionKind\",\n                    \"about\": \"The kind of collection object, e.g. Map or Set.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              enum class CollectionKind {};\n            ]]></code>\n        </enum>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"IterationKind\",\n                    \"about\": \"The kind of iteration over a collection, e.g. keys, values, or entries.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              enum class IterationKind {};\n            ]]></code>\n        </enum>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"CallFeedbackRelation\",\n                    \"about\": \"Indicates how call feedback information is related to the call site.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              enum class CallFeedbackRelation {};\n            ]]></code>\n        </enum>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"SpeculationMode\",\n                    \"about\": \"Indicates the level of speculation that can be used.\"\n                }\n            </metadata>\n            <code><![CDATA[\n              enum class SpeculationMode {};\n            ]]></code>\n        </enum>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Editor\",\n                    \"about\": \"Interface for graph editing operations\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class Editor {\n                public:\n                    virtual ~Editor() {}\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Node\",\n                    \"about\": \"Base class for nodes in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class Node {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Operator\",\n                    \"about\": \"Base class for operators in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class Operator {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Control\",\n                    \"about\": \"Represents control flow in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class Control {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Effect\",\n                    \"about\": \"Represents side effects in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class Effect {};\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"DeoptimizeReason\",\n                    \"about\": \"Represents the reason for deoptimization.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            enum class DeoptimizeReason {};\n            ]]></code>\n        </enum>\n    </dependencies>\n</file>\n```"
}