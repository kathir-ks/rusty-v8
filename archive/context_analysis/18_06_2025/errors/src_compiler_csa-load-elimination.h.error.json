{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/csa-load-elimination.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/csa-load-elimination.h\",\n        \"file_name\": \"csa-load-elimination.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the CsaLoadElimination class, which performs load elimination optimization in the compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for base utilities, code generation, compiler components, graph manipulation, and persistent data structures.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/compiler-specific.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/compiler/graph-reducer.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/node-aux-data.h\"\n#include \"src/compiler/persistent-map.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CsaLoadElimination\",\n            \"extends\": \"AdvancedReducer\",\n            \"about\": \"Performs Common Subexpression Elimination (CSE) for loads, specifically focusing on load elimination based on CodeStubAssembler (CSA) generated code. It leverages abstract interpretation to track the state of memory locations and eliminate redundant loads.\",\n            \"attributes\": [\n                {\n                    \"name\": \"empty_state_\",\n                    \"type\": \"AbstractState const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Represents an empty abstract state (no known information).\"\n                },\n                {\n                    \"name\": \"node_states_\",\n                    \"type\": \"NodeAuxData<AbstractState const*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the abstract state associated with each node in the graph.\"\n                },\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the JSGraph, providing access to the graph, isolate, and other compiler resources.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the memory zone used for allocating data structures.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AdvancedReducer\",\n                \"Editor\",\n                \"JSGraph\",\n                \"Zone\",\n                \"Reduction\",\n                \"Node\",\n                \"FieldInfo\",\n                \"HalfState\",\n                \"AbstractState\",\n                \"ObjectAccess\",\n                \"MachineRepresentation\",\n                \"MachineType\",\n                \"CommonOperatorBuilder\",\n                \"MachineOperatorBuilder\",\n                \"Isolate\",\n                \"TFGraph\",\n                \"NodeAuxData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE CsaLoadElimination final\n    : public NON_EXPORTED_BASE(AdvancedReducer) {\n public:\n  CsaLoadElimination(Editor* editor, JSGraph* jsgraph, Zone* zone)\n      : AdvancedReducer(editor),\n        empty_state_(zone),\n        node_states_(jsgraph->graph()->NodeCount(), zone),\n        jsgraph_(jsgraph),\n        zone_(zone) {}\n  ~CsaLoadElimination() final = default;\n  CsaLoadElimination(const CsaLoadElimination&) = delete;\n  CsaLoadElimination& operator=(const CsaLoadElimination&) = delete;\n\n  const char* reducer_name() const override { return \"CsaLoadElimination\"; }\n\n  Reduction Reduce(Node* node) final;\n\n private:\n  struct FieldInfo {\n    FieldInfo() = default;\n    FieldInfo(Node* value, MachineRepresentation representation)\n        : value(value), representation(representation) {}\n\n    bool operator==(const FieldInfo& other) const {\n      return value == other.value && representation == other.representation;\n    }\n\n    bool operator!=(const FieldInfo& other) const { return !(*this == other); }\n\n    bool IsEmpty() const { return value == nullptr; }\n\n    Node* value = nullptr;\n    MachineRepresentation representation = MachineRepresentation::kNone;\n  };\n\n  // Design doc: https://bit.ly/36MfD6Y\n  class HalfState final : public ZoneObject {\n   public:\n    explicit HalfState(Zone* zone)\n        : zone_(zone),\n          fresh_entries_(zone, InnerMap(zone)),\n          constant_entries_(zone, InnerMap(zone)),\n          arbitrary_entries_(zone, InnerMap(zone)),\n          fresh_unknown_entries_(zone, InnerMap(zone)),\n          constant_unknown_entries_(zone, InnerMap(zone)),\n          arbitrary_unknown_entries_(zone, InnerMap(zone)) {}\n\n    bool Equals(HalfState const* that) const {\n      return fresh_entries_ == that->fresh_entries_ &&\n             constant_entries_ == that->constant_entries_ &&\n             arbitrary_entries_ == that->arbitrary_entries_ &&\n             fresh_unknown_entries_ == that->fresh_unknown_entries_ &&\n             constant_unknown_entries_ == that->constant_unknown_entries_ &&\n             arbitrary_unknown_entries_ == that->arbitrary_unknown_entries_;\n    }\n    void IntersectWith(HalfState const* that);\n    HalfState const* KillField(Node* object, Node* offset,\n                               MachineRepresentation repr) const;\n    HalfState const* AddField(Node* object, Node* offset, Node* value,\n                              MachineRepresentation repr) const;\n    FieldInfo Lookup(Node* object, Node* offset) const;\n    void Print() const;\n\n   private:\n    using InnerMap = PersistentMap<Node*, FieldInfo>;\n    template <typename OuterKey>\n    using OuterMap = PersistentMap<OuterKey, InnerMap>;\n    // offset -> object -> info\n    using ConstantOffsetInfos = OuterMap<uint32_t>;\n    // object -> offset -> info\n    using UnknownOffsetInfos = OuterMap<Node*>;\n\n    // Update {map} so that {map.Get(outer_key).Get(inner_key)} returns {info}.\n    template <typename OuterKey>\n    static void Update(OuterMap<OuterKey>& map, OuterKey outer_key,\n                       Node* inner_key, FieldInfo info) {\n      InnerMap map_copy(map.Get(outer_key));\n      map_copy.Set(inner_key, info);\n      map.Set(outer_key, map_copy);\n    }\n\n    // Kill all elements in {infos} which may alias with offset.\n    static void KillOffset(ConstantOffsetInfos& infos, uint32_t offset,\n                           MachineRepresentation repr, Zone* zone);\n    void KillOffsetInFresh(Node* object, uint32_t offset,\n                           MachineRepresentation repr);\n    template <typename OuterKey>\n    static void IntersectWith(OuterMap<OuterKey>& to,\n                              const OuterMap<OuterKey>& from);\n    static void Print(const ConstantOffsetInfos& infos);\n    static void Print(const UnknownOffsetInfos& infos);\n\n    Zone* zone_;\n    ConstantOffsetInfos fresh_entries_;\n    ConstantOffsetInfos constant_entries_;\n    ConstantOffsetInfos arbitrary_entries_;\n    UnknownOffsetInfos fresh_unknown_entries_;\n    UnknownOffsetInfos constant_unknown_entries_;\n    UnknownOffsetInfos arbitrary_unknown_entries_;\n  };\n\n  // An {AbstractState} consists of two {HalfState}s, representing the mutable\n  // and immutable sets of known fields, respectively. These sets correspond to\n  // LoadFromObject/StoreToObject and LoadImmutableFromObject/\n  // InitializeImmutableInObject respectively. The two half-states should not\n  // overlap.\n  struct AbstractState : public ZoneObject {\n    explicit AbstractState(Zone* zone)\n        : mutable_state(zone), immutable_state(zone) {}\n    explicit AbstractState(HalfState mutable_state, HalfState immutable_state)\n        : mutable_state(mutable_state), immutable_state(immutable_state) {}\n\n    bool Equals(AbstractState const* that) const {\n      return this->immutable_state.Equals(&that->immutable_state) &&\n             this->mutable_state.Equals(&that->mutable_state);\n    }\n    void IntersectWith(AbstractState const* that) {\n      mutable_state.IntersectWith(&that->mutable_state);\n      immutable_state.IntersectWith(&that->immutable_state);\n    }\n\n    HalfState mutable_state;\n    HalfState immutable_state;\n  };\n\n  Reduction ReduceLoadFromObject(Node* node, ObjectAccess const& access);\n  Reduction ReduceStoreToObject(Node* node, ObjectAccess const& access);\n  Reduction ReduceEffectPhi(Node* node);\n  Reduction ReduceStart(Node* node);\n  Reduction ReduceCall(Node* node);\n  Reduction ReduceOtherNode(Node* node);\n\n  Reduction UpdateState(Node* node, AbstractState const* state);\n  Reduction PropagateInputState(Node* node);\n\n  AbstractState const* ComputeLoopState(Node* node,\n                                        AbstractState const* state) const;\n  Node* TruncateAndExtend(Node* node, MachineRepresentation from,\n                          MachineType to);\n  Reduction AssertUnreachable(Node* node);\n\n  CommonOperatorBuilder* common() const;\n  MachineOperatorBuilder* machine() const;\n  Isolate* isolate() const;\n  TFGraph* graph() const;\n  JSGraph* jsgraph() const { return jsgraph_; }\n  Zone* zone() const { return zone_; }\n  AbstractState const* empty_state() const { return &empty_state_; }\n\n  AbstractState const empty_state_;\n  NodeAuxData<AbstractState const*> node_states_;\n  JSGraph* const jsgraph_;\n  Zone* zone_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"FieldInfo\",\n            \"about\": \"Represents information about a field in an object, including its value and machine representation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Node*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The node representing the value of the field.\"\n                },\n                {\n                    \"name\": \"representation\",\n                    \"type\": \"MachineRepresentation\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The machine representation of the field (e.g., kWord32, kFloat64).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  struct FieldInfo {\n    FieldInfo() = default;\n    FieldInfo(Node* value, MachineRepresentation representation)\n        : value(value), representation(representation) {}\n\n    bool operator==(const FieldInfo& other) const {\n      return value == other.value && representation == other.representation;\n    }\n\n    bool operator!=(const FieldInfo& other) const { return !(*this == other); }\n\n    bool IsEmpty() const { return value == nullptr; }\n\n    Node* value = nullptr;\n    MachineRepresentation representation = MachineRepresentation::kNone;\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"HalfState\",\n            \"extends\": \"ZoneObject\",\n            \"about\": \"Represents half of the abstract state, tracking known fields (mutable or immutable). Uses persistent maps for efficient updates and lookups.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The memory zone used for allocating data structures.\"\n                },\n                {\n                    \"name\": \"fresh_entries_\",\n                    \"type\": \"ConstantOffsetInfos\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps constant offsets to field information for fresh objects.\"\n                },\n                {\n                    \"name\": \"constant_entries_\",\n                    \"type\": \"ConstantOffsetInfos\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps constant offsets to field information for constant objects.\"\n                },\n                {\n                    \"name\": \"arbitrary_entries_\",\n                    \"type\": \"ConstantOffsetInfos\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps constant offsets to field information for arbitrary objects.\"\n                },\n                {\n                    \"name\": \"fresh_unknown_entries_\",\n                    \"type\": \"UnknownOffsetInfos\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps objects to field information at unknown offsets for fresh objects.\"\n                },\n                {\n                    \"name\": \"constant_unknown_entries_\",\n                    \"type\": \"UnknownOffsetInfos\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps objects to field information at unknown offsets for constant objects.\"\n                },\n                {\n                    \"name\": \"arbitrary_unknown_entries_\",\n                    \"type\": \"UnknownOffsetInfos\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps objects to field information at unknown offsets for arbitrary objects.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"Zone\",\n                \"PersistentMap\",\n                \"Node\",\n                \"FieldInfo\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  // Design doc: https://bit.ly/36MfD6Y\n  class HalfState final : public ZoneObject {\n   public:\n    explicit HalfState(Zone* zone)\n        : zone_(zone),\n          fresh_entries_(zone, InnerMap(zone)),\n          constant_entries_(zone, InnerMap(zone)),\n          arbitrary_entries_(zone, InnerMap(zone)),\n          fresh_unknown_entries_(zone, InnerMap(zone)),\n          constant_unknown_entries_(zone, InnerMap(zone)),\n          arbitrary_unknown_entries_(zone, InnerMap(zone)) {}\n\n    bool Equals(HalfState const* that) const {\n      return fresh_entries_ == that->fresh_entries_ &&\n             constant_entries_ == that->constant_entries_ &&\n             arbitrary_entries_ == that->arbitrary_entries_ &&\n             fresh_unknown_entries_ == that->fresh_unknown_entries_ &&\n             constant_unknown_entries_ == that->constant_unknown_entries_ &&\n             arbitrary_unknown_entries_ == that->arbitrary_unknown_entries_;\n    }\n    void IntersectWith(HalfState const* that);\n    HalfState const* KillField(Node* object, Node* offset,\n                               MachineRepresentation repr) const;\n    HalfState const* AddField(Node* object, Node* offset, Node* value,\n                              MachineRepresentation repr) const;\n    FieldInfo Lookup(Node* object, Node* offset) const;\n    void Print() const;\n\n   private:\n    using InnerMap = PersistentMap<Node*, FieldInfo>;\n    template <typename OuterKey>\n    using OuterMap = PersistentMap<OuterKey, InnerMap>;\n    // offset -> object -> info\n    using ConstantOffsetInfos = OuterMap<uint32_t>;\n    // object -> offset -> info\n    using UnknownOffsetInfos = OuterMap<Node*>;\n\n    // Update {map} so that {map.Get(outer_key).Get(inner_key)} returns {info}.\n    template <typename OuterKey>\n    static void Update(OuterMap<OuterKey>& map, OuterKey outer_key,\n                       Node* inner_key, FieldInfo info) {\n      InnerMap map_copy(map.Get(outer_key));\n      map_copy.Set(inner_key, info);\n      map.Set(outer_key, map_copy);\n    }\n\n    // Kill all elements in {infos} which may alias with offset.\n    static void KillOffset(ConstantOffsetInfos& infos, uint32_t offset,\n                           MachineRepresentation repr, Zone* zone);\n    void KillOffsetInFresh(Node* object, uint32_t offset,\n                           MachineRepresentation repr);\n    template <typename OuterKey>\n    static void IntersectWith(OuterMap<OuterKey>& to,\n                              const OuterMap<OuterKey>& from);\n    static void Print(const ConstantOffsetInfos& infos);\n    static void Print(const UnknownOffsetInfos& infos);\n\n    Zone* zone_;\n    ConstantOffsetInfos fresh_entries_;\n    ConstantOffsetInfos constant_entries_;\n    ConstantOffsetInfos arbitrary_entries_;\n    UnknownOffsetInfos fresh_unknown_entries_;\n    UnknownOffsetInfos constant_unknown_entries_;\n    UnknownOffsetInfos arbitrary_unknown_entries_;\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"AbstractState\",\n            \"extends\": \"ZoneObject\",\n            \"about\": \"Represents the abstract state of memory, consisting of two HalfState objects: one for mutable fields and one for immutable fields.\",\n            \"attributes\": [\n                {\n                    \"name\": \"mutable_state\",\n                    \"type\": \"HalfState\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The HalfState representing mutable fields.\"\n                },\n                {\n                    \"name\": \"immutable_state\",\n                    \"type\": \"HalfState\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The HalfState representing immutable fields.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"HalfState\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  // An {AbstractState} consists of two {HalfState}s, representing the mutable\n  // and immutable sets of known fields, respectively. These sets correspond to\n  // LoadFromObject/StoreToObject and LoadImmutableFromObject/\n  // InitializeImmutableInObject respectively. The two half-states should not\n  // overlap.\n  struct AbstractState : public ZoneObject {\n    explicit AbstractState(Zone* zone)\n        : mutable_state(zone), immutable_state(zone) {}\n    explicit AbstractState(HalfState mutable_state, HalfState immutable_state)\n        : mutable_state(mutable_state), immutable_state(immutable_state) {}\n\n    bool Equals(AbstractState const* that) const {\n      return this->immutable_state.Equals(&that->immutable_state) &&\n             this->mutable_state.Equals(&that->mutable_state);\n    }\n    void IntersectWith(AbstractState const* that) {\n      mutable_state.IntersectWith(&that->mutable_state);\n      immutable_state.IntersectWith(&that->immutable_state);\n    }\n\n    HalfState mutable_state;\n    HalfState immutable_state;\n  };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"The main entry point for the reducer. It attempts to reduce the given node by performing load elimination.\",\n            \"logic\": \"This function determines which reduction to perform based on the operator of the given node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\",\n                \"ReduceLoadFromObject\",\n                \"ReduceStoreToObject\",\n                \"ReduceEffectPhi\",\n                \"ReduceStart\",\n                \"ReduceCall\",\n                \"ReduceOtherNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction Reduce(Node* node) final;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceLoadFromObject\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Reduces a LoadFromObject node by attempting to eliminate it based on the current abstract state.\",\n            \"logic\": \"Checks if the value being loaded is already known in the current state. If so, replaces the load with the known value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The LoadFromObject node to be reduced.\"\n                },\n                {\n                    \"name\": \"access\",\n                    \"type\": \"ObjectAccess const&\",\n                    \"purpose\": \"The object access information for the load.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\",\n                \"ObjectAccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceLoadFromObject(Node* node, ObjectAccess const& access);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceStoreToObject\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Reduces a StoreToObject node by updating the abstract state with the stored value.\",\n            \"logic\": \"Updates the abstract state to reflect the store operation. This may involve killing existing information about aliasing fields.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The StoreToObject node to be reduced.\"\n                },\n                {\n                    \"name\": \"access\",\n                    \"type\": \"ObjectAccess const&\",\n                    \"purpose\": \"The object access information for the store.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\",\n                \"ObjectAccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceStoreToObject(Node* node, ObjectAccess const& access);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceEffectPhi\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Reduces an EffectPhi node by intersecting the abstract states of its inputs.\",\n            \"logic\": \"Calculates the intersection of the abstract states reaching the EffectPhi node. This represents the state that is known to be true regardless of the path taken to reach the node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The EffectPhi node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceEffectPhi(Node* node);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceStart\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Reduces a Start node by initializing the abstract state to empty.\",\n            \"logic\": \"Sets the initial abstract state for the start node to an empty state, indicating no known information at the beginning of the graph.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The Start node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceStart(Node* node);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCall\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Reduces a Call node by invalidating the abstract state, because calls can potentially modify memory in unknown ways.\",\n            \"logic\": \"Resets the abstract state to empty, effectively killing all known information, since the call may have side effects that are not tracked by the analysis.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The Call node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceCall(Node* node);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceOtherNode\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Reduces other nodes, propagating the abstract state from inputs to outputs. Used as a default case for nodes that don't require special handling.\",\n            \"logic\": \"Simply propagates the abstract state from the inputs to the output node, assuming that the operation performed by the node does not affect memory in a way that needs to be tracked.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceOtherNode(Node* node);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UpdateState\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Updates the abstract state associated with a node.\",\n            \"logic\": \"Stores the given abstract state in the node_states_ map, associating it with the specified node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to update the state for.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"AbstractState const*\",\n                    \"purpose\": \"The abstract state to associate with the node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\",\n                \"AbstractState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction UpdateState(Node* node, AbstractState const* state);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PropagateInputState\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Propagates the abstract state from the inputs of a node to the node itself.\",\n            \"logic\": \"Retrieves the abstract state of the first input node and associates it with the current node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to propagate the state to.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction PropagateInputState(Node* node);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeLoopState\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Computes the abstract state for a loop node by iteratively intersecting the states until a fixed point is reached.\",\n            \"logic\": \"Performs a fixed-point iteration to determine the abstract state that is valid at the loop header. Starts with the initial state and iteratively intersects it with the state computed from the loop body until the state no longer changes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The loop node.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"AbstractState const*\",\n                    \"purpose\": \"The initial abstract state at the loop header.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AbstractState const*\",\n                \"description\": \"The computed abstract state for the loop.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"AbstractState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  AbstractState const* ComputeLoopState(Node* node,\n                                        AbstractState const* state) const;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TruncateAndExtend\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Truncates and extends a node to a different machine type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to be truncated and extended.\"\n                },\n                {\n                    \"name\": \"from\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The original machine representation.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"MachineType\",\n                    \"purpose\": \"The target machine type.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The new node.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"MachineRepresentation\",\n                \"MachineType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Node* TruncateAndExtend(Node* node, MachineRepresentation from,\n                          MachineType to);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssertUnreachable\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Handles nodes that should be unreachable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to be handled.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The reduction result.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Reduction AssertUnreachable(Node* node);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"common\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Returns a pointer to the CommonOperatorBuilder.\",\n            \"return\": {\n                \"type\": \"CommonOperatorBuilder*\",\n                \"description\": \"The common operator builder.\"\n            },\n            \"dependencies\": [\n                \"CommonOperatorBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  CommonOperatorBuilder* common() const;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"machine\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Returns a pointer to the MachineOperatorBuilder.\",\n            \"return\": {\n                \"type\": \"MachineOperatorBuilder*\",\n                \"description\": \"The machine operator builder.\"\n            },\n            \"dependencies\": [\n                \"MachineOperatorBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  MachineOperatorBuilder* machine() const;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"isolate\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Returns a pointer to the Isolate.\",\n            \"return\": {\n                \"type\": \"Isolate*\",\n                \"description\": \"The isolate.\"\n            },\n            \"dependencies\": [\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Isolate* isolate() const;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"graph\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Returns a pointer to the TFGraph.\",\n            \"return\": {\n                \"type\": \"TFGraph*\",\n                \"description\": \"The TFGraph.\"\n            },\n            \"dependencies\": [\n                \"TFGraph\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  TFGraph* graph() const;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"jsgraph\",\n            \"parent\": \"CsaLoadElimination\",\n            \"about\": \"Returns a pointer to the JSGraph.\",\n            \"return\": {\n                \"type\": \"JSGraph*\",\n                \"description\": \"The JSGraph.\"\n            },\n            \""
}