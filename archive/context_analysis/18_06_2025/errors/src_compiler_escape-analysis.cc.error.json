{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/escape-analysis.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/escape-analysis.cc\",\n        \"file_name\": \"escape-analysis.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Performs escape analysis on the IR graph to determine if objects can be allocated on the stack or if they need to be allocated on the heap.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for escape analysis, code generation, and compiler utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/escape-analysis.h\"\n\n#include \"src/codegen/tick-counter.h\"\n#include \"src/compiler/frame-states.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/state-values-utils.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/objects/map-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Sidetable\",\n            \"about\": \"A simple table that maps nodes to values.\",\n            \"attributes\": [\n                {\n                    \"name\": \"map_\",\n                    \"type\": \"ZoneVector<T>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying vector that stores the mapping.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nclass Sidetable {\n public:\n  explicit Sidetable(Zone* zone) : map_(zone) {}\n  T& operator[](const Node* node) {\n    NodeId id = node->id();\n    if (id >= map_.size()) {\n      map_.resize(id + 1);\n    }\n    return map_[id];\n  }\n\n private:\n  ZoneVector<T> map_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SparseSidetable\",\n            \"about\": \"A sparse table that maps nodes to values, providing a default value if no mapping exists.\",\n            \"attributes\": [\n                {\n                    \"name\": \"def_value_\",\n                    \"type\": \"T\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The default value to return if no mapping exists.\"\n                },\n                {\n                    \"name\": \"map_\",\n                    \"type\": \"ZoneUnorderedMap<NodeId, T>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying unordered map that stores the mapping.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nclass SparseSidetable {\n public:\n  explicit SparseSidetable(Zone* zone, T def_value = T())\n      : def_value_(std::move(def_value)), map_(zone) {}\n  void Set(const Node* node, T value) {\n    auto iter = map_.find(node->id());\n    if (iter != map_.end()) {\n      iter->second = std::move(value);\n    } else if (value != def_value_) {\n      map_.insert(iter, std::make_pair(node->id(), std::move(value)));\n    }\n  }\n  const T& Get(const Node* node) const {\n    auto iter = map_.find(node->id());\n    return iter != map_.end() ? iter->second : def_value_;\n  }\n\n private:\n  T def_value_;\n  ZoneUnorderedMap<NodeId, T> map_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ReduceScope\",\n            \"about\": \"Keeps track of the changes to the current node during reduction.\",\n            \"attributes\": [\n                {\n                    \"name\": \"current_node_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current node being reduced.\"\n                },\n                {\n                    \"name\": \"reduction_\",\n                    \"type\": \"Reduction*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The reduction object that tracks changes.\"\n                }\n            ],\n            \"dependencies\": [\n                \"EffectGraphReducer::Reduction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ReduceScope {\n public:\n  using Reduction = EffectGraphReducer::Reduction;\n  explicit ReduceScope(Node* node, Reduction* reduction)\n      : current_node_(node), reduction_(reduction) {}\n\n  void SetValueChanged() { reduction()->set_value_changed(); }\n\n protected:\n  Node* current_node() const { return current_node_; }\n  Reduction* reduction() { return reduction_; }\n\n private:\n  Node* current_node_;\n  Reduction* reduction_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"VariableTracker\",\n            \"about\": \"Keeps track of the values of variables at all points of the effect chain and introduces new phi nodes when necessary.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone used for memory allocation.\"\n                },\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The JSGraph object representing the graph.\"\n                },\n                {\n                    \"name\": \"table_\",\n                    \"type\": \"SparseSidetable<State>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The sparse sidetable that stores the variable states.\"\n                },\n                {\n                    \"name\": \"buffer_\",\n                    \"type\": \"ZoneVector<Node*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A buffer used for merging variable states.\"\n                },\n                {\n                    \"name\": \"reducer_\",\n                    \"type\": \"EffectGraphReducer*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The effect graph reducer.\"\n                },\n                {\n                    \"name\": \"next_variable_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The next available variable ID.\"\n                },\n                 {\n                    \"name\": \"tick_counter_\",\n                    \"type\": \"TickCounter* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The tick counter.\"\n                }\n            ],\n            \"dependencies\": [\n                \"PersistentMap\",\n                \"SparseSidetable\",\n                \"State\",\n                \"EffectGraphReducer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass VariableTracker {\n private:\n  // The state of all variables at one point in the effect chain.\n  class State {\n   public:\n    using Map = PersistentMap<Variable, Node*>;\n\n    explicit State(Zone* zone) : map_(zone) {}\n    Node* Get(Variable var) const {\n      CHECK(var != Variable::Invalid());\n      return map_.Get(var);\n    }\n    void Set(Variable var, Node* node) {\n      CHECK(var != Variable::Invalid());\n      return map_.Set(var, node);\n    }\n    Map::iterator begin() const { return map_.begin(); }\n    Map::iterator end() const { return map_.end(); }\n    bool operator!=(const State& other) const { return map_ != other.map_; }\n\n   private:\n    Map map_;\n  };\n\n public:\n  VariableTracker(JSGraph* graph, EffectGraphReducer* reducer, Zone* zone);\n  VariableTracker(const VariableTracker&) = delete;\n  VariableTracker& operator=(const VariableTracker&) = delete;\n\n  Variable NewVariable() { return Variable(next_variable_++); }\n  Node* Get(Variable var, Node* effect) { return table_.Get(effect).Get(var); }\n  Zone* zone() { return zone_; }\n\n  class V8_NODISCARD Scope : public ReduceScope {\n   public:\n    Scope(VariableTracker* tracker, Node* node, Reduction* reduction);\n    ~Scope();\n    Maybe<Node*> Get(Variable var) {\n      Node* node = current_state_.Get(var);\n      if (node && node->opcode() == IrOpcode::kDead) {\n        // TODO(turbofan): We use {Dead} as a sentinel for uninitialized memory.\n        // Reading uninitialized memory can only happen in unreachable code. In\n        // this case, we have to mark the object as escaping to avoid dead nodes\n        // in the graph. This is a workaround that should be removed once we can\n        // handle dead nodes everywhere.\n        return Nothing<Node*>();\n      }\n      return Just(node);\n    }\n    void Set(Variable var, Node* node) { current_state_.Set(var, node); }\n\n   private:\n    VariableTracker* states_;\n    State current_state_;\n  };\n\n private:\n  State MergeInputs(Node* effect_phi);\n  Zone* zone_;\n  JSGraph* graph_;\n  SparseSidetable<State> table_;\n  ZoneVector<Node*> buffer_;\n  EffectGraphReducer* reducer_;\n  int next_variable_ = 0;\n  TickCounter* const tick_counter_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EscapeAnalysisTracker\",\n            \"about\": \"Encapsulates the current state of the escape analysis reducer to preserve invariants regarding changes and re-visitation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"virtual_objects_\",\n                    \"type\": \"SparseSidetable<VirtualObject*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A sparse sidetable that maps nodes to virtual objects.\"\n                },\n                {\n                    \"name\": \"replacements_\",\n                    \"type\": \"Sidetable<Node*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A sidetable that maps nodes to their replacements.\"\n                },\n                {\n                    \"name\": \"framestate_might_lazy_deopt_\",\n                    \"type\": \"ZoneUnorderedMap<Node*, bool>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A map that stores whether a framestate might lazy deopt.\"\n                },\n                {\n                    \"name\": \"variable_states_\",\n                    \"type\": \"VariableTracker\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The variable tracker.\"\n                },\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The JSGraph object representing the graph.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone used for memory allocation.\"\n                },\n                {\n                    \"name\": \"next_object_id_\",\n                    \"type\": \"VirtualObject::Id\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The next available virtual object ID.\"\n                },\n                {\n                    \"name\": \"number_of_tracked_bytes_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of tracked bytes.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SparseSidetable\",\n                \"Sidetable\",\n                \"VariableTracker\",\n                \"VirtualObject\",\n                \"EffectGraphReducer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass EscapeAnalysisTracker : public ZoneObject {\n public:\n  EscapeAnalysisTracker(JSGraph* jsgraph, EffectGraphReducer* reducer,\n                        Zone* zone)\n      : virtual_objects_(zone),\n        replacements_(zone),\n        framestate_might_lazy_deopt_(zone),\n        variable_states_(jsgraph, reducer, zone),\n        jsgraph_(jsgraph),\n        zone_(zone) {}\n  EscapeAnalysisTracker(const EscapeAnalysisTracker&) = delete;\n  EscapeAnalysisTracker& operator=(const EscapeAnalysisTracker&) = delete;\n\n  class V8_NODISCARD Scope : public VariableTracker::Scope {\n   public:\n    Scope(EffectGraphReducer* reducer, EscapeAnalysisTracker* tracker,\n          Node* node, Reduction* reduction)\n        : VariableTracker::Scope(&tracker->variable_states_, node, reduction),\n          tracker_(tracker),\n          reducer_(reducer) {}\n    const VirtualObject* GetVirtualObject(Node* node) {\n      VirtualObject* vobject = tracker_->virtual_objects_.Get(node);\n      if (vobject) vobject->AddDependency(current_node());\n      return vobject;\n    }\n    // Create or retrieve a virtual object for the current node.\n    const VirtualObject* InitVirtualObject(int size) {\n      DCHECK_EQ(IrOpcode::kAllocate, current_node()->opcode());\n      VirtualObject* vobject = tracker_->virtual_objects_.Get(current_node());\n      if (vobject) {\n        CHECK(vobject->size() == size);\n      } else {\n        vobject = tracker_->NewVirtualObject(size);\n      }\n      if (vobject) vobject->AddDependency(current_node());\n      vobject_ = vobject;\n      return vobject;\n    }\n\n    void SetVirtualObject(Node* object) {\n      vobject_ = tracker_->virtual_objects_.Get(object);\n    }\n\n    void SetEscaped(Node* node) {\n      if (VirtualObject* object = tracker_->virtual_objects_.Get(node)) {\n        if (object->HasEscaped()) return;\n        TRACE(\"Setting %s#%d to escaped because of use by %s#%d\\n\",\n              node->op()->mnemonic(), node->id(),\n              current_node()->op()->mnemonic(), current_node()->id());\n        object->SetEscaped();\n        object->RevisitDependants(reducer_);\n      }\n    }\n    // The inputs of the current node have to be accessed through the scope to\n    // ensure that they respect the node replacements.\n    Node* ValueInput(int i) {\n      return tracker_->ResolveReplacement(\n          NodeProperties::GetValueInput(current_node(), i));\n    }\n    Node* ContextInput() {\n      return tracker_->ResolveReplacement(\n          NodeProperties::GetContextInput(current_node()));\n    }\n    // Accessing the current node is fine for `FrameState nodes.\n    Node* CurrentNode() {\n      DCHECK_EQ(current_node()->opcode(), IrOpcode::kFrameState);\n      return current_node();\n    }\n\n    void SetReplacement(Node* replacement) {\n      replacement_ = replacement;\n      vobject_ =\n          replacement ? tracker_->virtual_objects_.Get(replacement) : nullptr;\n      if (replacement) {\n        TRACE(\"Set %s#%d as replacement.\\n\", replacement->op()->mnemonic(),\n              replacement->id());\n      } else {\n        TRACE(\"Set nullptr as replacement.\\n\");\n      }\n    }\n\n    void MarkForDeletion() { SetReplacement(tracker_->jsgraph_->Dead()); }\n\n    bool FrameStateMightLazyDeopt(Node* framestate) {\n      DCHECK_EQ(IrOpcode::kFrameState, framestate->opcode());\n      if (auto it = tracker_->framestate_might_lazy_deopt_.find(framestate);\n          it != tracker_->framestate_might_lazy_deopt_.end()) {\n        return it->second;\n      }\n      for (Node* use : framestate->uses()) {\n        switch (use->opcode()) {\n          case IrOpcode::kCheckpoint:\n          case IrOpcode::kDeoptimize:\n          case IrOpcode::kDeoptimizeIf:\n          case IrOpcode::kDeoptimizeUnless:\n            // These nodes only cause eager deopts.\n            break;\n          default:\n            if (use->opcode() == IrOpcode::kFrameState &&\n                !FrameStateMightLazyDeopt(use)) {\n              break;\n            }\n            return tracker_->framestate_might_lazy_deopt_[framestate] = true;\n        }\n      }\n      return tracker_->framestate_might_lazy_deopt_[framestate] = false;\n    }\n\n    ~Scope() {\n      if (replacement_ != tracker_->replacements_[current_node()] ||\n          vobject_ != tracker_->virtual_objects_.Get(current_node())) {\n        reduction()->set_value_changed();\n      }\n      tracker_->replacements_[current_node()] = replacement_;\n      tracker_->virtual_objects_.Set(current_node(), vobject_);\n    }\n\n   private:\n    EscapeAnalysisTracker* tracker_;\n    EffectGraphReducer* reducer_;\n    VirtualObject* vobject_ = nullptr;\n    Node* replacement_ = nullptr;\n  };\n\n  Node* GetReplacementOf(Node* node) { return replacements_[node]; }\n  Node* ResolveReplacement(Node* node) {\n    if (Node* replacement = GetReplacementOf(node)) {\n      return replacement;\n    }\n    return node;\n  }\n\n private:\n  friend class EscapeAnalysisResult;\n  static constexpr int kTrackingBudget = 600;\n\n  VirtualObject* NewVirtualObject(int size) {\n    if (number_of_tracked_bytes_ + size >= kTrackingBudget) return nullptr;\n    number_of_tracked_bytes_ += size;\n    return zone_->New<VirtualObject>(&variable_states_, next_object_id_++,\n                                     size);\n  }\n\n  SparseSidetable<VirtualObject*> virtual_objects_;\n  Sidetable<Node*> replacements_;\n  ZoneUnorderedMap<Node*, bool> framestate_might_lazy_deopt_;\n  VariableTracker variable_states_;\n  VirtualObject::Id next_object_id_ = 0;\n  int number_of_tracked_bytes_ = 0;\n  JSGraph* const jsgraph_;\n  Zone* const zone_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EffectGraphReducer\",\n            \"about\": \"Reduces the effect graph to perform escape analysis.\",\n            \"attributes\": [\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"TFGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The TFGraph object representing the graph.\"\n                },\n                {\n                    \"name\": \"state_\",\n                    \"type\": \"ZoneVector<State>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The state of each node in the graph.\"\n                },\n                {\n                    \"name\": \"revisit_\",\n                    \"type\": \"ZoneVector<Node*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector of nodes that need to be revisited.\"\n                },\n                {\n                    \"name\": \"stack_\",\n                    \"type\": \"ZoneVector<std::pair<Node*, int>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A stack used for depth-first traversal of the graph.\"\n                },\n                {\n                    \"name\": \"reduce_\",\n                    \"type\": \"std::function<void(Node*, Reduction*)>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The function that reduces a node.\"\n                },\n                 {\n                    \"name\": \"tick_counter_\",\n                    \"type\": \"TickCounter*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The tick counter.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nEffectGraphReducer::EffectGraphReducer(\n    TFGraph* graph, std::function<void(Node*, Reduction*)> reduce,\n    TickCounter* tick_counter, Zone* zone)\n    : graph_(graph),\n      state_(graph, kNumStates),\n      revisit_(zone),\n      stack_(zone),\n      reduce_(std::move(reduce)),\n      tick_counter_(tick_counter) {}\n\nvoid EffectGraphReducer::ReduceFrom(Node* node) {\n  // Perform DFS and eagerly trigger revisitation as soon as possible.\n  // A stack element {node, i} indicates that input i of node should be visited\n  // next.\n  DCHECK(stack_.empty());\n  stack_.push({node, 0});\n  while (!stack_.empty()) {\n    tick_counter_->TickAndMaybeEnterSafepoint();\n    Node* current = stack_.top().node;\n    int& input_index = stack_.top().input_index;\n    if (input_index < current->InputCount()) {\n      Node* input = current->InputAt(input_index);\n      input_index++;\n      switch (state_.Get(input)) {\n        case State::kVisited:\n          // The input is already reduced.\n          break;\n        case State::kOnStack:\n          // The input is on the DFS stack right now, so it will be revisited\n          // later anyway.\n          break;\n        case State::kUnvisited:\n        case State::kRevisit: {\n          state_.Set(input, State::kOnStack);\n          stack_.push({input, 0});\n          break;\n        }\n      }\n    } else {\n      stack_.pop();\n      Reduction reduction;\n      reduce_(current, &reduction);\n      for (Edge edge : current->use_edges()) {\n        // Mark uses for revisitation.\n        Node* use = edge.from();\n        if (NodeProperties::IsEffectEdge(edge)) {\n          if (reduction.effect_changed()) Revisit(use);\n        } else {\n          if (reduction.value_changed()) Revisit(use);\n        }\n      }\n      state_.Set(current, State::kVisited);\n      // Process the revisitation buffer immediately. This improves performance\n      // of escape analysis. Using a stack for {revisit_} reverses the order in\n      // which the revisitation happens. This also seems to improve performance.\n      while (!revisit_.empty()) {\n        Node* revisit = revisit_.top();\n        if (state_.Get(revisit) == State::kRevisit) {\n          state_.Set(revisit, State::kOnStack);\n          stack_.push({revisit, 0});\n        }\n        revisit_.pop();\n      }\n    }\n  }\n}\n\nvoid EffectGraphReducer::Revisit(Node* node) {\n  if (state_.Get(node) == State::kVisited) {\n    TRACE(\"  Queueing for revisit: %s#%d\\n\", node->op()->mnemonic(),\n          node->id());\n    state_.Set(node, State::kRevisit);\n    revisit_.push(node);\n  }\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MergeInputs\",\n            \"parent\": \"VariableTracker\",\n            \"about\": \"Merges the input states of an effect phi node.\",\n            \"logic\": \"The function iterates through the inputs of the effect phi node and merges the variable states. If a variable is mapped to nullptr in any of the inputs, it is mapped to nullptr in the result. If a variable is mapped to the same value in all inputs, it is mapped to that value in the result. Otherwise, a new phi node is created and the variable is mapped to the new phi node in the result.\",\n            \"parameters\": [\n                {\n                    \"name\": \"effect_phi\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The effect phi node to merge inputs for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"State\",\n                \"description\": \"The merged state.\"\n            },\n            \"dependencies\": [\n                \"IrOpcode\",\n                \"NodeProperties\",\n                \"State\",\n                \"graph_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nVariableTracker::State VariableTracker::MergeInputs(Node* effect_phi) {\n  // A variable that is mapped to [nullptr] was not assigned a value on every\n  // execution path to the current effect phi. Relying on the invariant that\n  // every variable is initialized (at least with a sentinel like the Dead\n  // node), this means that the variable initialization does not dominate the\n  // current point. So for loop effect phis, we can keep nullptr for a variable\n  // as long as the first input of the loop has nullptr for this variable. For\n  // non-loop effect phis, we can even keep it nullptr as long as any input has\n  // nullptr.\n  DCHECK_EQ(IrOpcode::kEffectPhi, effect_phi->opcode());\n  int arity = effect_phi->op()->EffectInputCount();\n  Node* control = NodeProperties::GetControlInput(effect_phi, 0);\n  TRACE(\"control: %s#%d\\n\", control->op()->mnemonic(), control->id());\n  bool is_loop = control->opcode() == IrOpcode::kLoop;\n  buffer_.reserve(arity + 1);\n\n  State first_input = table_.Get(NodeProperties::GetEffectInput(effect_phi, 0));\n  State result = first_input;\n  for (std::pair<Variable, Node*> var_value : first_input) {\n    tick_counter_->TickAndMaybeEnterSafepoint();\n    if (Node* value = var_value.second) {\n      Variable var = var_value.first;\n      TRACE(\"var %i:\\n\", var.id_);\n      buffer_.clear();\n      buffer_.push_back(value);\n      bool identical_inputs = true;\n      int num_defined_inputs = 1;\n      TRACE(\"  input 0: %s#%d\\n\", value->op()->mnemonic(), value->id());\n      for (int i = 1; i < arity; ++i) {\n        Node* next_value =\n            table_.Get(NodeProperties::GetEffectInput(effect_phi, i)).Get(var);\n        if (next_value != value) identical_inputs = false;\n        if (next_value != nullptr) {\n          num_defined_inputs++;\n          TRACE(\"  input %i: %s#%d\\n\", i, next_value->op()->mnemonic(),\n                next_value->id());\n        } else {\n          TRACE(\"  input %i: nullptr\\n\", i);\n        }\n        buffer_.push_back(next_value);\n      }\n\n      Node* old_value = table_.Get(effect_phi).Get(var);\n      if (old_value) {\n        TRACE(\"  old: %s#%d\\n\", old_value->op()->mnemonic(), old_value->id());\n      } else {\n        TRACE(\"  old: nullptr\\n\");\n      }\n      // Reuse a previously created phi node if possible.\n      if (old_value && old_value->opcode() == IrOpcode::kPhi &&\n          NodeProperties::GetControlInput(old_value, 0) == control) {\n        // Since a phi node can never dominate its control node,\n        // [old_value] cannot originate from the inputs. Thus [old_value]\n        // must have been created by a previous reduction of this [effect_phi].\n        for (int i = 0; i < arity; ++i) {\n          Node* old_input = NodeProperties::GetValueInput(old_value, i);\n          Node* new_input = buffer_[i] ? buffer_[i] : graph_->Dead();\n          if (old_input != new_input) {\n            NodeProperties::ReplaceValueInput(old_value, new_input, i);\n            reducer_->Revisit(old_value);\n          }\n        }\n        result.Set(var, old_value);\n      } else {\n        if (num_defined_inputs == 1 && is_loop) {\n          // For loop effect phis, the variable initialization dominates iff it\n          // dominates the first input.\n          DCHECK_EQ(2, arity);\n          DCHECK_EQ(value, buffer_[0]);\n          result.Set(var, value);\n        } else if (num_defined_inputs < arity) {\n          // If the variable is undefined on some input of this non-loop effect\n          // phi, then its initialization does not dominate this point.\n          result.Set(var, nullptr);\n        } else {\n          DCHECK_EQ(num_defined_inputs, arity);\n          // We only create a phi if the values are different.\n          if (identical_inputs) {\n            result.Set(var, value);\n          } else {\n            TRACE(\"Creating new phi\\n\");\n            buffer_.push_back(control);\n            Node* phi = graph_->graph()->NewNode(\n                graph_->common()->Phi(MachineRepresentation::kTagged, arity),\n                arity + 1, &buffer_.front());\n            // TODO(turbofan): Computing precise types here is tricky, because\n            // of the necessary revisitations. If we really need this, we should\n            // probably do it afterwards.\n            NodeProperties::SetType(phi, Type::Any());\n            reducer_->AddRoot(phi);\n            result.Set(var, phi);\n          }\n        }\n      }\n#ifdef DEBUG\n      if (Node* result_node = result.Get(var)) {\n        TRACE(\"  result: %s#%d\\n\", result_node->op()->mnemonic(),\n              result_node->id());\n      } else {\n        TRACE(\"  result: nullptr\\n\");\n      }\n#endif\n    }\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"OffsetOfFieldAccess\",\n            \"about\": \"Calculates the offset of a field access.\",\n            \"logic\": \"Extracts the offset from the FieldAccess object associated with the LoadField or StoreField operator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const Operator*\",\n                    \"purpose\": \"The LoadField or StoreField operator.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The offset of the field access.\"\n            },\n            \"dependencies\": [\n                \"FieldAccessOf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nint OffsetOfFieldAccess(const Operator* op) {\n  DCHECK(op->opcode() == IrOpcode::kLoadField ||\n         op->opcode() == IrOpcode::kStoreField);\n  FieldAccess access = FieldAccessOf(op);\n  return access.offset;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"OffsetOfElementAt\",\n            \"about\": \"Calculates the offset of an element at a given index.\",\n            \"logic\": \"Computes the offset based on the element size and index. Returns Nothing if double element accesses are not supported or if the index is invalid.\",\n            \"parameters\": [\n                {\n                    \"name\": \"access\",\n                    \"type\": \"ElementAccess const&\",\n                    \"purpose\": \"The element access information.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the element.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Maybe<int>\",\n                \"description\": \"The offset of the element, or Nothing if not supported.\"\n            },\n            \"dependencies\": [\n                \"MachineRepresentation\",\n                \"ElementSizeLog2Of\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMaybe<int> OffsetOfElementAt(ElementAccess const& access, int index) {\n  MachineRepresentation representation = access.machine_type.representation();\n  // Double elements accesses are not yet supported. See chromium:1237821.\n  if (representation == MachineRepresentation::kFloat64) return Nothing<int>();\n\n  DCHECK_GE(index, 0);\n  DCHECK_GE(ElementSizeLog2Of(representation), kTaggedSizeLog2);\n  return Just(access.header_size +\n              (index << ElementSizeLog2Of(representation)));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"OffsetOfElementsAccess\",\n            \"about\": \"Calculates the offset of an element access.\",\n            \"logic\": \"Checks if the index is a constant integer and then calculates the offset of the element using OffsetOfElementAt. Returns Nothing if the index is not a constant integer or if OffsetOfElementAt returns Nothing.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const Operator*\",\n                    \"purpose\": \"The LoadElement or StoreElement operator.\"\n                },\n                {\n                    \"name\": \"index_node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node representing the index.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Maybe<int>\",\n                \"description\": \"The offset of the element access, or Nothing if not supported.\"\n            },\n            \"dependencies\": [\n                \"Type\",\n                \"OffsetOfElementAt\",\n                \"ElementAccessOf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMaybe<int> OffsetOfElementsAccess(const Operator* op, Node* index_node) {\n  DCHECK(op->opcode() == IrOpcode::kLoadElement ||\n         op->opcode() == IrOpcode::kStoreElement);\n  Type index_type = NodeProperties::GetType(index_node);\n  if (!index_type.Is(Type::OrderedNumber())) return Nothing<int>();\n  double max = index_type.Max();\n  double min = index_type.Min();\n  int index = static_cast<int>(min);\n  if (index < 0 || index != min || index != max) return Nothing<int"
}