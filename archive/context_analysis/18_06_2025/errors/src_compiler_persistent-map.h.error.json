{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/persistent-map.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/persistent-map.h\",\n            \"file_name\": \"persistent-map.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines a persistent map data structure based on hash trees.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary standard library headers and V8 specific headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <array>\n#include <tuple>\n\n#include \"src/base/hashing.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"may_be_unequal\",\n                \"about\": \"A fast and possibly incomplete equality check.  If it returns false, the values are certainly not equal, otherwise we do not know.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nstruct may_be_unequal {\n  bool operator()(const T& a, const T& b) { return a != b; }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PersistentMap\",\n                \"about\": \"A persistent map datastructure based on hash trees.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"tree_\",\n                        \"type\": \"FocusedTree*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the root of the hash tree.\"\n                    },\n                    {\n                        \"name\": \"def_value_\",\n                        \"type\": \"Value\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Default value for keys not present in the map.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating nodes.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"base::hash\",\n                    \"HashValue\",\n                    \"FocusedTree\",\n                    \"std::pair\",\n                    \"std::tuple\",\n                    \"Zone\",\n                    \"ZoneMap\",\n                    \"iterator\",\n                    \"double_iterator\",\n                    \"ZipIterable\",\n                    \"may_be_unequal\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher = base::hash<Key>>\nclass PersistentMap {\n public:\n  using key_type = Key;\n  using mapped_type = Value;\n  using value_type = std::pair<Key, Value>;\n\n private:\n  static constexpr size_t kHashBits = 32;\n  enum Bit : int { kLeft = 0, kRight = 1 };\n\n  // Access hash bits starting from the high bits and compare them according to\n  // their unsigned value. This way, the order in the hash tree is compatible\n  // with numeric hash comparisons.\n  class HashValue;\n\n  struct KeyValue : std::pair<Key, Value> {\n    const Key& key() const { return this->first; }\n    const Value& value() const { return this->second; }\n    using std::pair<Key, Value>::pair;\n  };\n\n  struct FocusedTree;\n\n  friend struct may_be_unequal<PersistentMap<Key, Value, Hasher>>;\n\n public:\n  // Depth of the last added element. This is a cheap estimate for the size of\n  // the hash tree.\n  size_t last_depth() const {\n    if (tree_) {\n      return tree_->length;\n    } else {\n      return 0;\n    }\n  }\n\n  const Value& Get(const Key& key) const {\n    HashValue key_hash = HashValue(Hasher()(key));\n    const FocusedTree* tree = FindHash(key_hash);\n    return GetFocusedValue(tree, key);\n  }\n\n  // Add or overwrite an existing key-value pair.\n  void Set(Key key, Value value);\n  // Modify an entry in-place, avoiding repeated search.\n  // `F` is a functional that expects a `Value*` parameter to modify it.\n  template <class F>\n  void Modify(Key key, F f);\n\n  bool operator==(const PersistentMap& other) const {\n    if (tree_ == other.tree_) return true;\n    if (def_value_ != other.def_value_) return false;\n    for (std::tuple<Key, Value, Value> triple : Zip(other)) {\n      if (std::get<1>(triple) != std::get<2>(triple)) return false;\n    }\n    return true;\n  }\n\n  bool operator!=(const PersistentMap& other) const {\n    return !(*this == other);\n  }\n\n  // The iterator produces key-value pairs in the lexicographical order of\n  // hash value and key. It produces exactly the key-value pairs where the value\n  // is not the default value.\n  class iterator;\n\n  iterator begin() const {\n    if (!tree_) return end();\n    return iterator::begin(tree_, def_value_);\n  }\n  iterator end() const { return iterator::end(def_value_); }\n\n  // Iterator to traverse two maps in lockstep, producing matching value pairs\n  // for each key where at least one value is different from the respective\n  // default.\n  class double_iterator;\n\n  // An iterable to iterate over the two maps in lockstep.\n  struct ZipIterable {\n    PersistentMap a;\n    PersistentMap b;\n    double_iterator begin() { return double_iterator(a.begin(), b.begin()); }\n    double_iterator end() { return double_iterator(a.end(), b.end()); }\n  };\n\n  ZipIterable Zip(const PersistentMap& other) const { return {*this, other}; }\n\n  explicit PersistentMap(Zone* zone, Value def_value = Value())\n      : PersistentMap(nullptr, zone, def_value) {}\n\n private:\n  // Find the {FocusedTree} that contains a key-value pair with key hash {hash}.\n  const FocusedTree* FindHash(HashValue hash) const;\n\n  // Find the {FocusedTree} that contains a key-value pair with key hash {hash}.\n  // Output the path to this {FocusedTree} and its length. If no such\n  // {FocusedTree} exists, return {nullptr} and output the path to the last node\n  // with a matching hash prefix. Note that {length} is the length of the found\n  // path and may be less than the length of the found {FocusedTree}.\n  const FocusedTree* FindHash(HashValue hash,\n                              std::array<const FocusedTree*, kHashBits>* path,\n                              int* length) const;\n\n  // Load value from the leaf node on the focused path of {tree}.\n  const Value& GetFocusedValue(const FocusedTree* tree, const Key& key) const;\n\n  // Return the {FocusedTree} representing the left (bit==kLeft) or right\n  // (bit==kRight) child of the node on the path of {tree} at tree level\n  // {level}.\n  static const FocusedTree* GetChild(const FocusedTree* tree, int level,\n                                     Bit bit);\n\n  // Find the leftmost path in the tree, starting at the node at tree level\n  // {level} on the path of {start}. Output the level of the leaf to {level} and\n  // the path to {path}.\n  static const FocusedTree* FindLeftmost(\n      const FocusedTree* start, int* level,\n      std::array<const FocusedTree*, kHashBits>* path);\n\n  PersistentMap(const FocusedTree* tree, Zone* zone, Value def_value)\n      : tree_(tree), def_value_(def_value), zone_(zone) {}\n\n  const FocusedTree* tree_;\n  Value def_value_;\n  Zone* zone_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"may_be_unequal\",\n                \"about\": \"Specialization of may_be_unequal for PersistentMap.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"PersistentMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nstruct may_be_unequal<PersistentMap<Key, Value, Hasher>> {\n  bool operator()(const PersistentMap<Key, Value, Hasher>& a,\n                  const PersistentMap<Key, Value, Hasher>& b) {\n    return a.tree_ != b.tree_;\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"FocusedTree\",\n                \"about\": \"Represents a hash tree with one focused path to a specific leaf.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"key_value\",\n                        \"type\": \"KeyValue\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Key-value pair for the focused leaf.\"\n                    },\n                    {\n                        \"name\": \"length\",\n                        \"type\": \"int8_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Depth of the focused path.\"\n                    },\n                    {\n                        \"name\": \"key_hash\",\n                        \"type\": \"HashValue\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Hash value of the key.\"\n                    },\n                    {\n                        \"name\": \"more\",\n                        \"type\": \"ZoneMap<Key, Value>*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Out-of-line storage for hash collisions.\"\n                    },\n                    {\n                        \"name\": \"path_array\",\n                        \"type\": \"const FocusedTree* [1]\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Array of pointers to other FocusedTree nodes along the path.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"KeyValue\",\n                    \"HashValue\",\n                    \"ZoneMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nstruct PersistentMap<Key, Value, Hasher>::FocusedTree {\n  KeyValue key_value;\n  // The depth of the focused path, that is, the number of pointers stored in\n  // this structure.\n  int8_t length;\n  HashValue key_hash;\n  // Out-of-line storage for hash collisions.\n  const ZoneMap<Key, Value>* more;\n  using more_iterator = typename ZoneMap<Key, Value>::const_iterator;\n  // {path_array} has to be the last member: To store an array inline, we\n  // over-allocate memory for this structure and access memory beyond\n  // {path_array}. This corresponds to a flexible array member as defined in\n  // C99.\n  const FocusedTree* path_array[1];\n  const FocusedTree*& path(int i) {\n    DCHECK(i < length);\n    return reinterpret_cast<const FocusedTree**>(\n        reinterpret_cast<uint8_t*>(this) +\n        offsetof(FocusedTree, path_array))[i];\n  }\n  const FocusedTree* path(int i) const {\n    DCHECK(i < length);\n    return reinterpret_cast<const FocusedTree* const*>(\n        reinterpret_cast<const uint8_t*>(this) +\n        offsetof(FocusedTree, path_array))[i];\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"HashValue\",\n                \"about\": \"Represents a hash value for keys in the PersistentMap.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"bits_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the hash bits.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nclass PersistentMap<Key, Value, Hasher>::HashValue {\n public:\n  explicit HashValue(size_t hash) : bits_(static_cast<uint32_t>(hash)) {}\n\n  Bit operator[](int pos) const {\n    DCHECK_LT(pos, kHashBits);\n    return bits_ & (static_cast<decltype(bits_)>(1) << (kHashBits - pos - 1))\n               ? kRight\n               : kLeft;\n  }\n\n  bool operator<(HashValue other) const { return bits_ < other.bits_; }\n  bool operator==(HashValue other) const { return bits_ == other.bits_; }\n  bool operator!=(HashValue other) const { return bits_ != other.bits_; }\n  HashValue operator^(HashValue other) const {\n    return HashValue(bits_ ^ other.bits_);\n  }\n\n private:\n  static_assert(sizeof(uint32_t) * 8 == kHashBits, \"wrong type for bits_\");\n  uint32_t bits_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"iterator\",\n                \"about\": \"Iterator for the PersistentMap, producing key-value pairs in lexicographical order.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"level_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Current level in the hash tree.\"\n                    },\n                    {\n                        \"name\": \"more_iter_\",\n                        \"type\": \"typename FocusedTree::more_iterator\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Iterator for the ZoneMap in case of hash collisions.\"\n                    },\n                    {\n                        \"name\": \"current_\",\n                        \"type\": \"const FocusedTree*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the current FocusedTree node.\"\n                    },\n                    {\n                        \"name\": \"path_\",\n                        \"type\": \"std::array<const FocusedTree*, kHashBits>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Path from the root to the current node.\"\n                    },\n                    {\n                        \"name\": \"def_value_\",\n                        \"type\": \"Value\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Default value for the map.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"FocusedTree\",\n                    \"ZoneMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nclass PersistentMap<Key, Value, Hasher>::iterator {\n public:\n  const value_type operator*() const {\n    if (current_->more) {\n      return *more_iter_;\n    } else {\n      return current_->key_value;\n    }\n  }\n\n  iterator& operator++() {\n    do {\n      if (!current_) {\n        // Iterator is past the end.\n        return *this;\n      }\n      if (current_->more) {\n        DCHECK(more_iter_ != current_->more->end());\n        ++more_iter_;\n        if (more_iter_ != current_->more->end()) return *this;\n      }\n      if (level_ == 0) {\n        *this = end(def_value_);\n        return *this;\n      }\n      --level_;\n      while (current_->key_hash[level_] == kRight || path_[level_] == nullptr) {\n        if (level_ == 0) {\n          *this = end(def_value_);\n          return *this;\n        }\n        --level_;\n      }\n      const FocusedTree* first_right_alternative = path_[level_];\n      level_++;\n      current_ = FindLeftmost(first_right_alternative, &level_, &path_);\n      if (current_->more) {\n        more_iter_ = current_->more->begin();\n      }\n    } while (!((**this).second != def_value()));\n    return *this;\n  }\n\n  bool operator==(const iterator& other) const {\n    if (is_end()) return other.is_end();\n    if (other.is_end()) return false;\n    if (current_->key_hash != other.current_->key_hash) {\n      return false;\n    } else {\n      return (**this).first == (*other).first;\n    }\n  }\n  bool operator!=(const iterator& other) const { return !(*this == other); }\n\n  bool operator<(const iterator& other) const {\n    if (is_end()) return false;\n    if (other.is_end()) return true;\n    if (current_->key_hash == other.current_->key_hash) {\n      return (**this).first < (*other).first;\n    } else {\n      return current_->key_hash < other.current_->key_hash;\n    }\n  }\n\n  bool is_end() const { return current_ == nullptr; }\n\n  const Value& def_value() { return def_value_; }\n\n  static iterator begin(const FocusedTree* tree, Value def_value) {\n    iterator i(def_value);\n    i.current_ = FindLeftmost(tree, &i.level_, &i.path_);\n    if (i.current_->more) {\n      i.more_iter_ = i.current_->more->begin();\n    }\n    // Skip entries with default value. PersistentMap iterators must never point\n    // to a default value.\n    while (!i.is_end() && !((*i).second != def_value)) ++i;\n    return i;\n  }\n\n  static iterator end(Value def_value) { return iterator(def_value); }\n\n private:\n  int level_;\n  typename FocusedTree::more_iterator more_iter_;\n  const FocusedTree* current_;\n  std::array<const FocusedTree*, kHashBits> path_;\n  Value def_value_;\n\n  explicit iterator(Value def_value)\n      : level_(0), current_(nullptr), def_value_(def_value) {}\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"double_iterator\",\n                \"about\": \"Iterator to traverse two maps in lockstep, producing matching value pairs for each key.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"first_\",\n                        \"type\": \"iterator\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Iterator for the first map.\"\n                    },\n                    {\n                        \"name\": \"second_\",\n                        \"type\": \"iterator\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Iterator for the second map.\"\n                    },\n                    {\n                        \"name\": \"first_current_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if the current key is from the first map.\"\n                    },\n                    {\n                        \"name\": \"second_current_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if the current key is from the second map.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"iterator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nclass PersistentMap<Key, Value, Hasher>::double_iterator {\n public:\n  std::tuple<Key, Value, Value> operator*() {\n    if (first_current_) {\n      auto pair = *first_;\n      return std::make_tuple(\n          pair.first, pair.second,\n          second_current_ ? (*second_).second : second_.def_value());\n    } else {\n      DCHECK(second_current_);\n      auto pair = *second_;\n      return std::make_tuple(pair.first, first_.def_value(), pair.second);\n    }\n  }\n\n  double_iterator& operator++() {\n#ifdef DEBUG\n    iterator old_first = first_;\n    iterator old_second = second_;\n#endif\n    if (first_current_) {\n      ++first_;\n      DCHECK(old_first < first_);\n    }\n    if (second_current_) {\n      ++second_;\n      DCHECK(old_second < second_);\n    }\n    return *this = double_iterator(first_, second_);\n  }\n\n  double_iterator(iterator first, iterator second)\n      : first_(first), second_(second) {\n    if (first_ == second_) {\n      first_current_ = second_current_ = true;\n    } else if (first_ < second_) {\n      first_current_ = true;\n      second_current_ = false;\n    } else {\n      DCHECK(second_ < first_);\n      first_current_ = false;\n      second_current_ = true;\n    }\n  }\n\n  bool operator!=(const double_iterator& other) {\n    return first_ != other.first_ || second_ != other.second_;\n  }\n\n  bool is_end() const { return first_.is_end() && second_.is_end(); }\n\n private:\n  iterator first_;\n  iterator second_;\n  bool first_current_;\n  bool second_current_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Set\",\n                \"parent\": \"PersistentMap\",\n                \"about\": \"Adds or overwrites an existing key-value pair in the map.\",\n                \"logic\": \"Calls Modify() to set the value associated with the given key.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"Key\",\n                        \"purpose\": \"The key to set or overwrite.\"\n                    },\n                    {\n                        \"name\": \"new_value\",\n                        \"type\": \"Value\",\n                        \"purpose\": \"The new value to associate with the key.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Modify\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nvoid PersistentMap<Key, Value, Hasher>::Set(Key key, Value new_value) {\n  Modify(key, [&](Value* value) { *value = std::move(new_value); });\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Modify\",\n                \"parent\": \"PersistentMap\",\n                \"about\": \"Modifies an entry in-place, avoiding repeated search.\",\n                \"logic\": \"Finds the FocusedTree containing the key, applies the modification function F to the value, and creates a new FocusedTree with the modified value. Handles hash collisions using ZoneMap.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"Key\",\n                        \"purpose\": \"The key to modify.\"\n                    },\n                    {\n                        \"name\": \"f\",\n                        \"type\": \"F\",\n                        \"purpose\": \"A function that modifies the value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"HashValue\",\n                    \"FindHash\",\n                    \"GetFocusedValue\",\n                    \"ZoneMap\",\n                    \"may_be_unequal\",\n                    \"Zone\",\n                    \"FocusedTree\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\ntemplate <class F>\nvoid PersistentMap<Key, Value, Hasher>::Modify(Key key, F f) {\n  static_assert(std::is_void_v<decltype(f(std::declval<Value*>()))>);\n  HashValue key_hash = HashValue(Hasher()(key));\n  std::array<const FocusedTree*, kHashBits> path;\n  int length = 0;\n  const FocusedTree* old = FindHash(key_hash, &path, &length);\n  ZoneMap<Key, Value>* more = nullptr;\n  const Value& old_value = GetFocusedValue(old, key);\n  Value new_value = old_value;\n  f(&new_value);\n  if (!may_be_unequal<Value>()(old_value, new_value)) return;\n  if (old && !(old->more == nullptr && old->key_value.key() == key)) {\n    more = zone_->New<ZoneMap<Key, Value>>(zone_);\n    if (old->more) {\n      *more = *old->more;\n    } else {\n      more->erase(old->key_value.key());\n      more->emplace(old->key_value.key(), old->key_value.value());\n    }\n    more->erase(key);\n    more->emplace(key, new_value);\n  }\n  size_t size = sizeof(FocusedTree) +\n                std::max(0, length - 1) * sizeof(const FocusedTree*);\n  FocusedTree* tree = new (zone_->Allocate<FocusedTree>(size))\n      FocusedTree{KeyValue(std::move(key), std::move(new_value)),\n                  static_cast<int8_t>(length),\n                  key_hash,\n                  more,\n                  {}};\n  for (int i = 0; i < length; ++i) {\n    tree->path(i) = path[i];\n  }\n  *this = PersistentMap(tree, zone_, def_value_);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FindHash\",\n                \"parent\": \"PersistentMap\",\n                \"about\": \"Finds the FocusedTree that contains a key-value pair with the given hash.\",\n                \"logic\": \"Traverses the hash tree based on the hash bits, returning the FocusedTree if found, otherwise nullptr.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"hash\",\n                        \"type\": \"HashValue\",\n                        \"purpose\": \"The hash value to search for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const FocusedTree*\",\n                    \"description\": \"Pointer to the FocusedTree if found, otherwise nullptr.\"\n                },\n                \"dependencies\": [\n                    \"FocusedTree\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nconst typename PersistentMap<Key, Value, Hasher>::FocusedTree*\nPersistentMap<Key, Value, Hasher>::FindHash(HashValue hash) const {\n  const FocusedTree* tree = tree_;\n  int level = 0;\n  while (tree && hash != tree->key_hash) {\n    while ((hash ^ tree->key_hash)[level] == 0) {\n      ++level;\n    }\n    tree = level < tree->length ? tree->path(level) : nullptr;\n    ++level;\n  }\n  return tree;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FindHash\",\n                \"parent\": \"PersistentMap\",\n                \"about\": \"Finds the FocusedTree that contains a key-value pair with the given hash, storing the path and length.\",\n                \"logic\": \"Traverses the hash tree based on the hash bits, storing the path to the node and the length of the path. Returns the FocusedTree if found, otherwise nullptr.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"hash\",\n                        \"type\": \"HashValue\",\n                        \"purpose\": \"The hash value to search for.\"\n                    },\n                    {\n                        \"name\": \"path\",\n                        \"type\": \"std::array<const FocusedTree*, kHashBits>*\",\n                        \"purpose\": \"Output array to store the path.\"\n                    },\n                    {\n                        \"name\": \"length\",\n                        \"type\": \"int*\",\n                        \"purpose\": \"Output variable to store the length of the path.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const FocusedTree*\",\n                    \"description\": \"Pointer to the FocusedTree if found, otherwise nullptr.\"\n                },\n                \"dependencies\": [\n                    \"FocusedTree\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nconst typename PersistentMap<Key, Value, Hasher>::FocusedTree*\nPersistentMap<Key, Value, Hasher>::FindHash(\n    HashValue hash, std::array<const FocusedTree*, kHashBits>* path,\n    int* length) const {\n  const FocusedTree* tree = tree_;\n  int level = 0;\n  while (tree && hash != tree->key_hash) {\n    int map_length = tree->length;\n    while ((hash ^ tree->key_hash)[level] == 0) {\n      (*path)[level] = level < map_length ? tree->path(level) : nullptr;\n      ++level;\n    }\n    (*path)[level] = tree;\n    tree = level < tree->length ? tree->path(level) : nullptr;\n    ++level;\n  }\n  if (tree) {\n    while (level < tree->length) {\n      (*path)[level] = tree->path(level);\n      ++level;\n    }\n  }\n  *length = level;\n  return tree;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetFocusedValue\",\n                \"parent\": \"PersistentMap\",\n                \"about\": \"Retrieves the value associated with a key from the FocusedTree.\",\n                \"logic\": \"If the FocusedTree exists, it checks for collisions using ZoneMap. If the key is found, the value is returned, otherwise the default value is returned.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"tree\",\n                        \"type\": \"const FocusedTree*\",\n                        \"purpose\": \"The FocusedTree to retrieve the value from.\"\n                    },\n                    {\n                        \"name\": \"key\",\n                        \"type\": \"const Key&\",\n                        \"purpose\": \"The key to retrieve the value for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const Value&\",\n                    \"description\": \"The value associated with the key, or the default value if not found.\"\n                },\n                \"dependencies\": [\n                    \"FocusedTree\",\n                    \"ZoneMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nconst Value& PersistentMap<Key, Value, Hasher>::GetFocusedValue(\n    const FocusedTree* tree, const Key& key) const {\n  if (!tree) {\n    return def_value_;\n  }\n  if (tree->more) {\n    auto it = tree->more->find(key);\n    if (it == tree->more->end())\n      return def_value_;\n    else\n      return it->second;\n  } else {\n    if (key == tree->key_value.key()) {\n      return tree->key_value.value();\n    } else {\n      return def_value_;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetChild\",\n                \"parent\": \"PersistentMap\",\n                \"about\": \"Returns the left or right child of a FocusedTree node at a given level.\",\n                \"logic\": \"Checks the hash bit at the specified level and returns the corresponding child node. If the bit matches the current node's hash, the current node is returned.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"tree\",\n                        \"type\": \"const FocusedTree*\",\n                        \"purpose\": \"The FocusedTree to get the child from.\"\n                    },\n                    {\n                        \"name\": \"level\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The level in the tree.\"\n                    },\n                    {\n                        \"name\": \"bit\",\n                        \"type\": \"Bit\",\n                        \"purpose\": \"The bit indicating the child (left or right).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const FocusedTree*\",\n                    \"description\": \"The child FocusedTree node, or nullptr if not found.\"\n                },\n                \"dependencies\": [\n                    \"FocusedTree\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value, class Hasher>\nconst typename PersistentMap<Key, Value, Hasher>::FocusedTree*\nPersistentMap<Key, Value, Hasher>::GetChild(const FocusedTree* tree, int level,\n                                            Bit bit) {\n  if (tree->key_hash[level] == bit) {\n    return tree;\n  } else if (level < tree->length) {\n    return tree->path(level);\n  } else {\n    return nullptr;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FindLeftmost\",\n                \"parent\": \"PersistentMap\",\n                \"about\": \"Finds the leftmost path in the tree, starting at a given node and level.\",\n                \"logic\": \"Traverses the tree, always choosing the left child if available, otherwise the right child. Returns the leftmost FocusedTree node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"start\",\n                        \"type\": \"const FocusedTree*\",\n                        \"purpose\": \"The starting FocusedTree node.\"\n                    },\n                    {"
}