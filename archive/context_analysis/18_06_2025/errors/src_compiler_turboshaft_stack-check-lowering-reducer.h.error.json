{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/stack-check-lowering-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 242, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/stack-check-lowering-reducer.h\",\n            \"file_name\": \"stack-check-lowering-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the StackCheckLoweringReducer class, which lowers stack check operations in the Turboshaft compiler pipeline.  It replaces high-level stack check nodes with lower-level operations like memory loads, comparisons, and runtime calls to handle stack overflow conditions.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for compiler globals, Turboshaft assembler, graph, index, operations, phase, representations, and the uniform reducer adapter.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/compiler/turboshaft/uniform-reducer-adapter.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StackCheckLoweringReducer\",\n                \"extends\": \"Next\",\n                \"about\": \"A reducer class that lowers stack check operations to platform-specific checks and runtime calls.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Isolate, used to access runtime functions and global data.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Next\",\n                    \"V\",\n                    \"Context\",\n                    \"FrameState\",\n                    \"JSStackCheckOp\",\n                    \"WordPtr\",\n                    \"ExternalConstant\",\n                    \"ExternalReference\",\n                    \"LoadOp\",\n                    \"MemoryRepresentation\",\n                    \"StackPointerGreaterThan\",\n                    \"StackCheckKind\",\n                    \"CallRuntime_StackGuardWithGap\",\n                    \"StackCheckOffset\",\n                    \"CallRuntime_StackGuard\",\n                    \"Word32\",\n                    \"Word32Equal\",\n                    \"CallRuntime_HandleNoHeapWritesInterrupts\",\n                    \"WasmStackCheckOp\",\n                    \"IsLeafFunction\",\n                    \"LoadRootRegister\",\n                    \"IsolateData\",\n                    \"CallDescriptor\",\n                    \"Linkage\",\n                    \"NoContextDescriptor\",\n                    \"Operator\",\n                    \"StubCallMode\",\n                    \"TSCallDescriptor\",\n                    \"Builtin\",\n                    \"RelocatableWasmBuiltinCallTarget\",\n                    \"Call\",\n                    \"OpEffects\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass StackCheckLoweringReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(StackCheckLowering)\n\n  V<None> REDUCE(JSStackCheck)(V<Context> context,\n                               OptionalV<FrameState> frame_state,\n                               JSStackCheckOp::Kind kind) {\n    switch (kind) {\n      case JSStackCheckOp::Kind::kFunctionEntry: {\n        // Loads of the stack limit should not be load-eliminated as it can be\n        // modified by another thread.\n        V<WordPtr> limit =\n            __ Load(__ ExternalConstant(\n                        ExternalReference::address_of_jslimit(isolate())),\n                    LoadOp::Kind::RawAligned().NotLoadEliminable(),\n                    MemoryRepresentation::UintPtr());\n\n        IF_NOT (LIKELY(__ StackPointerGreaterThan(\n                    limit, StackCheckKind::kJSFunctionEntry))) {\n          __ CallRuntime_StackGuardWithGap(isolate(), frame_state.value(),\n                                           context, __ StackCheckOffset());\n        }\n        break;\n      }\n      case JSStackCheckOp::Kind::kBuiltinEntry: {\n        V<WordPtr> stack_limit = __ LoadOffHeap(\n            __ ExternalConstant(\n                ExternalReference::address_of_jslimit(isolate())),\n            MemoryRepresentation::UintPtr());\n        IF_NOT (LIKELY(__ StackPointerGreaterThan(\n                    stack_limit, StackCheckKind::kCodeStubAssembler))) {\n          __ CallRuntime_StackGuard(isolate(), context);\n        }\n        break;\n      }\n      case JSStackCheckOp::Kind::kLoop: {\n        V<Word32> limit = __ Load(\n            __ ExternalConstant(\n                ExternalReference::address_of_no_heap_write_interrupt_request(\n                    isolate())),\n            LoadOp::Kind::RawAligned().NotLoadEliminable(),\n            MemoryRepresentation::Uint8());\n\n        IF_NOT (LIKELY(__ Word32Equal(limit, 0))) {\n          __ CallRuntime_HandleNoHeapWritesInterrupts(\n              isolate(), frame_state.value(), context);\n        }\n        break;\n      }\n    }\n\n    return V<None>::Invalid();\n  }\n\n#ifdef V8_ENABLE_WEBASSEMBLY\n  V<None> REDUCE(WasmStackCheck)(WasmStackCheckOp::Kind kind) {\n    if (kind == WasmStackCheckOp::Kind::kFunctionEntry && __ IsLeafFunction()) {\n      return V<None>::Invalid();\n    }\n\n    if (kind == WasmStackCheckOp::Kind::kFunctionEntry &&\n        v8_flags.experimental_wasm_growable_stacks) {\n      // WasmStackCheck should be lowered by GrowableStacksReducer\n      // in a special way.\n      return Next::ReduceWasmStackCheck(kind);\n    }\n\n    // Loads of the stack limit should not be load-eliminated as it can be\n    // modified by another thread.\n    V<WordPtr> limit = __ Load(\n        __ LoadRootRegister(), LoadOp::Kind::RawAligned().NotLoadEliminable(),\n        MemoryRepresentation::UintPtr(), IsolateData::jslimit_offset());\n\n    IF_NOT (LIKELY(__ StackPointerGreaterThan(limit, StackCheckKind::kWasm))) {\n      // TODO(14108): Cache descriptor.\n      const CallDescriptor* call_descriptor =\n          compiler::Linkage::GetStubCallDescriptor(\n              __ graph_zone(),                      // zone\n              NoContextDescriptor{},                // descriptor\n              0,                                    // stack parameter count\n              CallDescriptor::kNoFlags,             // flags\n              Operator::kNoProperties,              // properties\n              StubCallMode::kCallWasmRuntimeStub);  // stub call mode\n      const TSCallDescriptor* ts_call_descriptor =\n          TSCallDescriptor::Create(call_descriptor, compiler::CanThrow::kNo,\n                                   LazyDeoptOnThrow::kNo, __ graph_zone());\n      V<WordPtr> builtin =\n          __ RelocatableWasmBuiltinCallTarget(Builtin::kWasmStackGuard);\n      // Pass custom effects to the `Call` node to mark it as non-writing.\n      __ Call(\n          builtin, {}, ts_call_descriptor,\n          OpEffects().CanReadMemory().RequiredWhenUnused().CanCreateIdentity());\n    }\n\n    return V<None>::Invalid();\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n private:\n  Isolate* isolate() {\n    if (!isolate_) isolate_ = __ data() -> isolate();\n    return isolate_;\n  }\n\n  Isolate* isolate_ = nullptr;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE(JSStackCheck)\",\n                \"parent\": \"StackCheckLoweringReducer\",\n                \"about\": \"Reduces a JSStackCheck operation to lower-level operations.\",\n                \"logic\": \"This function handles stack checks for JavaScript functions, builtins, and loops. It loads the stack limit, compares it with the current stack pointer, and calls a runtime function if a stack overflow is detected.  The specific runtime function called depends on the kind of stack check (kFunctionEntry, kBuiltinEntry, kLoop).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"context\",\n                        \"type\": \"V<Context>\",\n                        \"purpose\": \"The current context.\"\n                    },\n                    {\n                        \"name\": \"frame_state\",\n                        \"type\": \"OptionalV<FrameState>\",\n                        \"purpose\": \"The frame state, if available.\"\n                    },\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"JSStackCheckOp::Kind\",\n                        \"purpose\": \"The kind of stack check (e.g., kFunctionEntry, kBuiltinEntry, kLoop).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<None>\",\n                    \"description\": \"Invalid V<None> if the reduction was successful (i.e., the stack check was lowered).\"\n                },\n                \"dependencies\": [\n                    \"V\",\n                    \"Context\",\n                    \"FrameState\",\n                    \"JSStackCheckOp\",\n                    \"WordPtr\",\n                    \"ExternalConstant\",\n                    \"ExternalReference\",\n                    \"LoadOp\",\n                    \"MemoryRepresentation\",\n                    \"StackPointerGreaterThan\",\n                    \"StackCheckKind\",\n                    \"CallRuntime_StackGuardWithGap\",\n                    \"StackCheckOffset\",\n                    \"CallRuntime_StackGuard\",\n                    \"Word32\",\n                    \"Word32Equal\",\n                    \"CallRuntime_HandleNoHeapWritesInterrupts\",\n                    \"isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<None> REDUCE(JSStackCheck)(V<Context> context,\n                               OptionalV<FrameState> frame_state,\n                               JSStackCheckOp::Kind kind) {\n    switch (kind) {\n      case JSStackCheckOp::Kind::kFunctionEntry: {\n        // Loads of the stack limit should not be load-eliminated as it can be\n        // modified by another thread.\n        V<WordPtr> limit =\n            __ Load(__ ExternalConstant(\n                        ExternalReference::address_of_jslimit(isolate())),\n                    LoadOp::Kind::RawAligned().NotLoadEliminable(),\n                    MemoryRepresentation::UintPtr());\n\n        IF_NOT (LIKELY(__ StackPointerGreaterThan(\n                    limit, StackCheckKind::kJSFunctionEntry))) {\n          __ CallRuntime_StackGuardWithGap(isolate(), frame_state.value(),\n                                           context, __ StackCheckOffset());\n        }\n        break;\n      }\n      case JSStackCheckOp::Kind::kBuiltinEntry: {\n        V<WordPtr> stack_limit = __ LoadOffHeap(\n            __ ExternalConstant(\n                ExternalReference::address_of_jslimit(isolate())),\n            MemoryRepresentation::UintPtr());\n        IF_NOT (LIKELY(__ StackPointerGreaterThan(\n                    stack_limit, StackCheckKind::kCodeStubAssembler))) {\n          __ CallRuntime_StackGuard(isolate(), context);\n        }\n        break;\n      }\n      case JSStackCheckOp::Kind::kLoop: {\n        V<Word32> limit = __ Load(\n            __ ExternalConstant(\n                ExternalReference::address_of_no_heap_write_interrupt_request(\n                    isolate())),\n            LoadOp::Kind::RawAligned().NotLoadEliminable(),\n            MemoryRepresentation::Uint8());\n\n        IF_NOT (LIKELY(__ Word32Equal(limit, 0))) {\n          __ CallRuntime_HandleNoHeapWritesInterrupts(\n              isolate(), frame_state.value(), context);\n        }\n        break;\n      }\n    }\n\n    return V<None>::Invalid();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE(WasmStackCheck)\",\n                \"parent\": \"StackCheckLoweringReducer\",\n                \"about\": \"Reduces a WasmStackCheck operation to lower-level operations.\",\n                \"logic\": \"This function handles stack checks for WebAssembly functions. It checks if the function is a leaf function or if experimental growable stacks are enabled. If not, it loads the stack limit from the Isolate data, compares it with the current stack pointer, and calls the kWasmStackGuard builtin if a stack overflow is detected.  It constructs a call descriptor to call the builtin, ensuring that it is marked as non-writing and allows memory reads.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"WasmStackCheckOp::Kind\",\n                        \"purpose\": \"The kind of Wasm stack check (currently only kFunctionEntry is handled).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<None>\",\n                    \"description\": \"Invalid V<None> if the reduction was successful.\"\n                },\n                \"dependencies\": [\n                    \"V\",\n                    \"WasmStackCheckOp\",\n                    \"IsLeafFunction\",\n                    \"LoadRootRegister\",\n                    \"MemoryRepresentation\",\n                    \"UintPtr\",\n                    \"LoadOp\",\n                    \"StackPointerGreaterThan\",\n                    \"StackCheckKind\",\n                    \"CallDescriptor\",\n                    \"Linkage\",\n                    \"NoContextDescriptor\",\n                    \"Operator\",\n                    \"StubCallMode\",\n                    \"TSCallDescriptor\",\n                    \"Builtin\",\n                    \"RelocatableWasmBuiltinCallTarget\",\n                    \"Call\",\n                    \"OpEffects\",\n                    \"isolate\",\n                    \"Next\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<None> REDUCE(WasmStackCheck)(WasmStackCheckOp::Kind kind) {\n    if (kind == WasmStackCheckOp::Kind::kFunctionEntry && __ IsLeafFunction()) {\n      return V<None>::Invalid();\n    }\n\n    if (kind == WasmStackCheckOp::Kind::kFunctionEntry &&\n        v8_flags.experimental_wasm_growable_stacks) {\n      // WasmStackCheck should be lowered by GrowableStacksReducer\n      // in a special way.\n      return Next::ReduceWasmStackCheck(kind);\n    }\n\n    // Loads of the stack limit should not be load-eliminated as it can be\n    // modified by another thread.\n    V<WordPtr> limit = __ Load(\n        __ LoadRootRegister(), LoadOp::Kind::RawAligned().NotLoadEliminable(),\n        MemoryRepresentation::UintPtr(), IsolateData::jslimit_offset());\n\n    IF_NOT (LIKELY(__ StackPointerGreaterThan(limit, StackCheckKind::kWasm))) {\n      // TODO(14108): Cache descriptor.\n      const CallDescriptor* call_descriptor =\n          compiler::Linkage::GetStubCallDescriptor(\n              __ graph_zone(),                      // zone\n              NoContextDescriptor{},                // descriptor\n              0,                                    // stack parameter count\n              CallDescriptor::kNoFlags,             // flags\n              Operator::kNoProperties,              // properties\n              StubCallMode::kCallWasmRuntimeStub);  // stub call mode\n      const TSCallDescriptor* ts_call_descriptor =\n          TSCallDescriptor::Create(call_descriptor, compiler::CanThrow::kNo,\n                                   LazyDeoptOnThrow::kNo, __ graph_zone());\n      V<WordPtr> builtin =\n          __ RelocatableWasmBuiltinCallTarget(Builtin::kWasmStackGuard);\n      // Pass custom effects to the `Call` node to mark it as non-writing.\n      __ Call(\n          builtin, {}, ts_call_descriptor,\n          OpEffects().CanReadMemory().RequiredWhenUnused().CanCreateIdentity());\n    }\n\n    return V<None>::Invalid();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"isolate\",\n                \"parent\": \"StackCheckLoweringReducer\",\n                \"about\": \"Gets the Isolate pointer.\",\n                \"logic\": \"Lazily initializes and returns the Isolate pointer.  It accesses the Isolate from the data passed into the reducer, using the `__ data() -> isolate()` method provided by the Turboshaft reducer framework.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Isolate*\",\n                    \"description\": \"The Isolate pointer.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n private:\n  Isolate* isolate() {\n    if (!isolate_) isolate_ = __ data() -> isolate();\n    return isolate_;\n  }\n        ]]></code>\n    </func>\n</file>\n```"
}