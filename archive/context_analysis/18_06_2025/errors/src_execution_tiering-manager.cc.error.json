{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/tiering-manager.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/tiering-manager.cc\",\n        \"file_name\": \"tiering-manager.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Manages the tiering of functions between different optimization levels (e.g., Ignition, Sparkplug, Maglev, Turbofan) in the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for tiering management, platform features, code generation, compilation cache, and object manipulation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/tiering-manager.h\"\n\n#include <optional>\n\n#include \"src/base/platform/platform.h\"\n#include \"src/baseline/baseline.h\"\n#include \"src/codegen/assembler.h\"\n#include \"src/codegen/compilation-cache.h\"\n#include \"src/codegen/compiler.h\"\n#include \"src/codegen/pending-optimization-table.h\"\n#include \"src/common/globals.h\"\n#include \"src/diagnostics/code-tracer.h\"\n#include \"src/execution/execution.h\"\n#include \"src/execution/frames-inl.h\"\n#include \"src/flags/flags.h\"\n#include \"src/handles/global-handles.h\"\n#include \"src/init/bootstrapper.h\"\n#include \"src/interpreter/interpreter.h\"\n#include \"src/objects/code-kind.h\"\n#include \"src/objects/code.h\"\n#include \"src/tracing/trace-event.h\"\n\n#ifdef V8_ENABLE_SPARKPLUG\n#include \"src/baseline/baseline-batch-compiler.h\"\n#endif  // V8_ENABLE_SPARKPLUG\n        ]]></code>\n    </imports>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"OptimizationReason\",\n            \"about\": \"Represents the reason why a function is being optimized.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#define OPTIMIZATION_REASON_LIST(V)   \\\n  V(DoNotOptimize, \"do not optimize\") \\\n  V(HotAndStable, \"hot and stable\")\n\nenum class OptimizationReason : uint8_t {\n#define OPTIMIZATION_REASON_CONSTANTS(Constant, message) k##Constant,\n  OPTIMIZATION_REASON_LIST(OPTIMIZATION_REASON_CONSTANTS)\n#undef OPTIMIZATION_REASON_CONSTANTS\n};\n        ]]></code>\n    </enum>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"OptimizationReasonToString\",\n            \"about\": \"Converts an OptimizationReason enum value to its string representation.\",\n            \"logic\": \"Uses a static array of strings to map the enum value to its corresponding string. Performs a bounds check to ensure the index is within the valid range.\",\n            \"parameters\": [\n                {\n                    \"name\": \"reason\",\n                    \"type\": \"OptimizationReason\",\n                    \"purpose\": \"The optimization reason to convert to a string.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"char const*\",\n                \"description\": \"A pointer to a null-terminated string representing the optimization reason.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nchar const* OptimizationReasonToString(OptimizationReason reason) {\n  static char const* reasons[] = {\n#define OPTIMIZATION_REASON_TEXTS(Constant, message) message,\n      OPTIMIZATION_REASON_LIST(OPTIMIZATION_REASON_TEXTS)\n#undef OPTIMIZATION_REASON_TEXTS\n  };\n  size_t const index = static_cast<size_t>(reason);\n  DCHECK_LT(index, arraysize(reasons));\n  return reasons[index];\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator to allow printing of OptimizationReason enum values to an output stream.\",\n            \"logic\": \"Calls OptimizationReasonToString to get the string representation of the enum value and inserts it into the output stream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream to write to.\"\n                },\n                {\n                    \"name\": \"reason\",\n                    \"type\": \"OptimizationReason\",\n                    \"purpose\": \"The optimization reason to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"A reference to the output stream.\"\n            },\n            \"dependencies\": [\n                \"OptimizationReasonToString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, OptimizationReason reason) {\n  return os << OptimizationReasonToString(reason);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OptimizationDecision\",\n            \"about\": \"Represents a decision about whether or not to optimize a function, and if so, which optimization pipeline to use.\",\n            \"attributes\": [\n                {\n                    \"name\": \"optimization_reason\",\n                    \"type\": \"OptimizationReason\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The reason for the optimization decision.\"\n                },\n                {\n                    \"name\": \"code_kind\",\n                    \"type\": \"CodeKind\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The code kind to compile to (e.g., Maglev, Turbofan).\"\n                },\n                {\n                    \"name\": \"concurrency_mode\",\n                    \"type\": \"ConcurrencyMode\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Whether the optimization can run concurrently.\"\n                }\n            ],\n            \"dependencies\": [\n                \"OptimizationReason\",\n                \"CodeKind\",\n                \"ConcurrencyMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass OptimizationDecision {\n public:\n  static constexpr OptimizationDecision Maglev() {\n    // TODO(v8:7700): Consider using another reason here.\n    return {OptimizationReason::kHotAndStable, CodeKind::MAGLEV,\n            ConcurrencyMode::kConcurrent};\n  }\n  static constexpr OptimizationDecision TurbofanHotAndStable() {\n    return {OptimizationReason::kHotAndStable, CodeKind::TURBOFAN_JS,\n            ConcurrencyMode::kConcurrent};\n  }\n  static constexpr OptimizationDecision DoNotOptimize() {\n    return {OptimizationReason::kDoNotOptimize,\n            // These values don't matter but we have to pass something.\n            CodeKind::TURBOFAN_JS, ConcurrencyMode::kConcurrent};\n  }\n\n  constexpr bool should_optimize() const {\n    return optimization_reason != OptimizationReason::kDoNotOptimize;\n  }\n\n  OptimizationReason optimization_reason;\n  CodeKind code_kind;\n  ConcurrencyMode concurrency_mode;\n\n private:\n  OptimizationDecision() = default;\n  constexpr OptimizationDecision(OptimizationReason optimization_reason,\n                                 CodeKind code_kind,\n                                 ConcurrencyMode concurrency_mode)\n      : optimization_reason(optimization_reason),\n        code_kind(code_kind),\n        concurrency_mode(concurrency_mode) {}\n};\n// Since we pass by value:\nstatic_assert(sizeof(OptimizationDecision) <= kInt32Size);\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TraceInOptimizationQueue\",\n            \"about\": \"Prints a message to the console indicating that a function is already in the optimization queue.\",\n            \"logic\": \"Checks the `v8_flags.trace_opt_verbose` flag and prints a message if it is enabled.  The message includes the function name and its current code kind.\",\n            \"parameters\": [\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function that is already in the optimization queue.\"\n                },\n                {\n                    \"name\": \"current_code_kind\",\n                    \"type\": \"CodeKind\",\n                    \"purpose\": \"The current code kind of the function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8_flags\",\n                \"PrintF\",\n                \"DebugNameCStr\",\n                \"CodeKindToString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TraceInOptimizationQueue(Tagged<JSFunction> function,\n                              CodeKind current_code_kind) {\n  if (v8_flags.trace_opt_verbose) {\n    PrintF(\"[not marking function %s (%s) for optimization: already queued]\\n\",\n           function->DebugNameCStr().get(),\n           CodeKindToString(current_code_kind));\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TraceHeuristicOptimizationDisallowed\",\n            \"about\": \"Prints a message to the console indicating that heuristic optimization is disallowed for a function.\",\n            \"logic\": \"Checks the `v8_flags.trace_opt_verbose` flag and prints a message if it is enabled.  The message indicates the function is marked for manual optimization.\",\n            \"parameters\": [\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function for which heuristic optimization is disallowed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8_flags\",\n                \"PrintF\",\n                \"DebugNameCStr\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TraceHeuristicOptimizationDisallowed(Tagged<JSFunction> function) {\n  if (v8_flags.trace_opt_verbose) {\n    PrintF(\n        \"[not marking function %s for optimization: marked with \"\n        \"%%PrepareFunctionForOptimization for manual optimization]\\n\",\n        function->DebugNameCStr().get());\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TraceRecompile\",\n            \"about\": \"Traces when a function is marked for recompilation (optimization).\",\n            \"logic\": \"If `v8_flags.trace_opt` is enabled, it uses CodeTracer to print a message indicating that the function is being marked for optimization, including the target code kind, concurrency mode, and optimization reason.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The current V8 isolate.\"\n                },\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function being marked for optimization.\"\n                },\n                {\n                    \"name\": \"d\",\n                    \"type\": \"OptimizationDecision\",\n                    \"purpose\": \"The optimization decision containing the code kind, concurrency mode, and reason.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8_flags\",\n                \"CodeTracer\",\n                \"PrintF\",\n                \"ShortPrint\",\n                \"CodeKindToString\",\n                \"ToString\",\n                \"OptimizationReasonToString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TraceRecompile(Isolate* isolate, Tagged<JSFunction> function,\n                    OptimizationDecision d) {\n  if (v8_flags.trace_opt) {\n    CodeTracer::Scope scope(isolate->GetCodeTracer());\n    PrintF(scope.file(), \"[marking \");\n    ShortPrint(function, scope.file());\n    PrintF(scope.file(), \" for optimization to %s, %s, reason: %s\",\n           CodeKindToString(d.code_kind), ToString(d.concurrency_mode),\n           OptimizationReasonToString(d.optimization_reason));\n    PrintF(scope.file(), \"]\\n\");\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TraceManualRecompile\",\n            \"about\": \"Traces when a function is manually marked for recompilation (optimization).\",\n            \"logic\": \"If `v8_flags.trace_opt` is enabled, it prints a message indicating that the function is being manually marked for optimization, including the target code kind and concurrency mode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function being manually marked for optimization.\"\n                },\n                {\n                    \"name\": \"code_kind\",\n                    \"type\": \"CodeKind\",\n                    \"purpose\": \"The code kind to compile to (e.g., Maglev, Turbofan).\"\n                },\n                {\n                    \"name\": \"concurrency_mode\",\n                    \"type\": \"ConcurrencyMode\",\n                    \"purpose\": \"Whether the optimization can run concurrently.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8_flags\",\n                \"PrintF\",\n                \"ShortPrint\",\n                \"CodeKindToString\",\n                \"ToString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TraceManualRecompile(Tagged<JSFunction> function, CodeKind code_kind,\n                          ConcurrencyMode concurrency_mode) {\n  if (v8_flags.trace_opt) {\n    PrintF(\"[manually marking \");\n    ShortPrint(function);\n    PrintF(\" for optimization to %s, %s]\\n\", CodeKindToString(code_kind),\n           ToString(concurrency_mode));\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Optimize\",\n            \"parent\": \"TieringManager\",\n            \"about\": \"Requests optimization of a function based on a given optimization decision.\",\n            \"logic\": \"Traces the recompilation and then requests optimization of the function with the specified code kind and concurrency mode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function to optimize.\"\n                },\n                {\n                    \"name\": \"d\",\n                    \"type\": \"OptimizationDecision\",\n                    \"purpose\": \"The optimization decision to apply.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TraceRecompile\",\n                \"RequestOptimization\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TieringManager::Optimize(Tagged<JSFunction> function,\n                              OptimizationDecision d) {\n  DCHECK(d.should_optimize());\n  TraceRecompile(isolate_, function, d);\n  function->RequestOptimization(isolate_, d.code_kind, d.concurrency_mode);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkForTurboFanOptimization\",\n            \"parent\": \"TieringManager\",\n            \"about\": \"Marks a function for Turbofan optimization with hot and stable settings.\",\n            \"logic\": \"Calls the `Optimize` method with an `OptimizationDecision` for Turbofan, indicating it's considered hot and stable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function to mark for Turbofan optimization.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Optimize\",\n                \"OptimizationDecision\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TieringManager::MarkForTurboFanOptimization(Tagged<JSFunction> function) {\n  Optimize(function, OptimizationDecision::TurbofanHotAndStable());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FirstTimeTierUpToSparkplug\",\n            \"about\": \"Determines if a function should be enqueued for Sparkplug compilation for the first time.\",\n            \"logic\": \"Returns true if the function doesn't have a feedback vector or if the function is currently running in Ignition and hasn't been enqueued for Sparkplug batch compilation yet.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The current V8 isolate.\"\n                },\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the function should be enqueued for Sparkplug compilation for the first time, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"has_feedback_vector\",\n                \"ActiveTierIsIgnition\",\n                \"CanCompileWithBaseline\",\n                \"cached_tiering_decision\",\n                \"CachedTieringDecision\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool FirstTimeTierUpToSparkplug(Isolate* isolate, Tagged<JSFunction> function) {\n  return !function->has_feedback_vector() ||\n         // We request sparkplug even in the presence of a fbv, if we are\n         // running ignition and haven't enqueued the function for sparkplug\n         // batch compilation yet. This ensures we tier-up to sparkplug when the\n         // feedback vector is allocated eagerly (e.g. for logging function\n         // events; see JSFunction::InitializeFeedbackCell()).\n         (function->ActiveTierIsIgnition(isolate) &&\n          CanCompileWithBaseline(isolate, function->shared()) &&\n          function->shared()->cached_tiering_decision() ==\n              CachedTieringDecision::kPending);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TiersUpToMaglev\",\n            \"about\": \"Determines if tiering up to Maglev is enabled based on the current code kind.\",\n            \"logic\": \"Checks if Maglev is enabled and if the code kind represents an unoptimized JavaScript function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code_kind\",\n                    \"type\": \"CodeKind\",\n                    \"purpose\": \"The current code kind.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if tiering up to Maglev is enabled, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"maglev::IsMaglevEnabled\",\n                \"CodeKindIsUnoptimizedJSFunction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TiersUpToMaglev(CodeKind code_kind) {\n  return V8_LIKELY(maglev::IsMaglevEnabled()) &&\n         CodeKindIsUnoptimizedJSFunction(code_kind);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TiersUpToMaglev\",\n            \"about\": \"Determines if tiering up to Maglev is enabled based on an optional code kind.\",\n            \"logic\": \"Checks if the optional code kind has a value and then delegates to the other TiersUpToMaglev function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code_kind\",\n                    \"type\": \"std::optional<CodeKind>\",\n                    \"purpose\": \"The current code kind, or empty if not available.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if tiering up to Maglev is enabled, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"TiersUpToMaglev(CodeKind)\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TiersUpToMaglev(std::optional<CodeKind> code_kind) {\n  return code_kind.has_value() && TiersUpToMaglev(code_kind.value());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"InterruptBudgetFor\",\n            \"about\": \"Calculates the interrupt budget for a function based on its code kind, bytecode length, and other factors.\",\n            \"logic\": \"Calculates an interrupt budget that determines when to interrupt execution for tiering. The budget depends on the current tier, cached tiering decision, and bytecode length. Avoids interrupts while tiering is in progress. Considers Maglev and Turbofan OSR.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The current V8 isolate.\"\n                },\n                {\n                    \"name\": \"code_kind\",\n                    \"type\": \"std::optional<CodeKind>\",\n                    \"purpose\": \"The current code kind of the function, or empty if not available.\"\n                },\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function to calculate the interrupt budget for.\"\n                },\n                {\n                    \"name\": \"cached_tiering_decision\",\n                    \"type\": \"CachedTieringDecision\",\n                    \"purpose\": \"The cached tiering decision for the function.\"\n                },\n                {\n                    \"name\": \"bytecode_length\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The length of the function's bytecode.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The calculated interrupt budget.\"\n            },\n            \"dependencies\": [\n                \"function->tiering_in_progress()\",\n                \"function->GetRequestedOptimizationIfAny()\",\n                \"CodeKind::TURBOFAN_JS\",\n                \"v8_flags.invocation_count_for_osr\",\n                \"maglev::IsMaglevOsrEnabled()\",\n                \"v8_flags.invocation_count_for_maglev_osr\",\n                \"TiersUpToMaglev()\",\n                \"function->IsTieringRequestedOrInProgress()\",\n                \"v8_flags.profile_guided_optimization\",\n                \"CachedTieringDecision\",\n                \"v8_flags.invocation_count_for_maglev\",\n                \"v8_flags.minimum_invocations_after_ic_update\",\n                \"v8_flags.invocation_count_for_maglev_with_delay\",\n                \"v8_flags.invocation_count_for_early_optimization\",\n                \"v8_flags.invocation_count_for_turbofan\",\n                \"SBXCHECK()\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint InterruptBudgetFor(Isolate* isolate, std::optional<CodeKind> code_kind,\n                       Tagged<JSFunction> function,\n                       CachedTieringDecision cached_tiering_decision,\n                       int bytecode_length) {\n  // Avoid interrupts while we're already tiering.\n  if (function->tiering_in_progress()) return INT_MAX / 2;\n\n  const std::optional<CodeKind> existing_request =\n      function->GetRequestedOptimizationIfAny(isolate);\n  if (existing_request == CodeKind::TURBOFAN_JS ||\n      (code_kind.has_value() && code_kind.value() == CodeKind::TURBOFAN_JS)) {\n    return v8_flags.invocation_count_for_osr * bytecode_length;\n  }\n  if (maglev::IsMaglevOsrEnabled() && existing_request == CodeKind::MAGLEV) {\n    return v8_flags.invocation_count_for_maglev_osr * bytecode_length;\n  }\n\n  if (TiersUpToMaglev(code_kind) &&\n      !function->IsTieringRequestedOrInProgress()) {\n    if (v8_flags.profile_guided_optimization) {\n      switch (cached_tiering_decision) {\n        case CachedTieringDecision::kDelayMaglev:\n          return (std::max(v8_flags.invocation_count_for_maglev,\n                           v8_flags.minimum_invocations_after_ic_update) +\n                  v8_flags.invocation_count_for_maglev_with_delay) *\n                 bytecode_length;\n        case CachedTieringDecision::kEarlyMaglev:\n        case CachedTieringDecision::kEarlyTurbofan:\n          return v8_flags.invocation_count_for_early_optimization *\n                 bytecode_length;\n        case CachedTieringDecision::kPending:\n        case CachedTieringDecision::kEarlySparkplug:\n        case CachedTieringDecision::kNormal:\n          return v8_flags.invocation_count_for_maglev * bytecode_length;\n      }\n      // The enum value is coming from inside the sandbox and while the switch\n      // is exhaustive, it's not guaranteed that value is one of the declared\n      // values.\n      SBXCHECK(false);\n    }\n    return v8_flags.invocation_count_for_maglev * bytecode_length;\n  }\n  return v8_flags.invocation_count_for_turbofan * bytecode_length;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InterruptBudgetFor\",\n            \"parent\": \"TieringManager\",\n            \"about\": \"Calculates the interrupt budget for a function, taking into account an optional override for the active tier.\",\n            \"logic\": \"This function determines the interrupt budget for a given JSFunction, which controls when the execution of that function might be interrupted for tiering purposes (e.g., optimizing the code). It factors in the function's bytecode length, whether it's the first time tiering up to Sparkplug, and a potentially overridden active tier. If the bytecode length exceeds a defined maximum, the budget is set to a high value to avoid frequent interrupts. Otherwise, it calls the internal `InterruptBudgetFor` function to calculate the budget based on the function's tiering state.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The current V8 isolate.\"\n                },\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function to calculate the interrupt budget for.\"\n                },\n                {\n                    \"name\": \"override_active_tier\",\n                    \"type\": \"std::optional<CodeKind>\",\n                    \"purpose\": \"An optional override for the active tier of the function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The calculated interrupt budget.\"\n            },\n            \"dependencies\": [\n                \"FirstTimeTierUpToSparkplug\",\n                \"bytecode_length\",\n                \"v8_flags.max_optimized_bytecode_size\",\n                \"InterruptBudgetFor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint TieringManager::InterruptBudgetFor(\n    Isolate* isolate, Tagged<JSFunction> function,\n    std::optional<CodeKind> override_active_tier) {\n  DCHECK(function->shared()->is_compiled());\n  const int bytecode_length =\n      function->shared()->GetBytecodeArray(isolate)->length();\n\n  if (FirstTimeTierUpToSparkplug(isolate, function)) {\n    return bytecode_length * v8_flags.invocation_count_for_feedback_allocation;\n  }\n\n  DCHECK(function->has_feedback_vector());\n  if (bytecode_length > v8_flags.max_optimized_bytecode_size) {\n    // Decrease times of interrupt budget underflow, the reason of not setting\n    // to INT_MAX is the interrupt budget may overflow when doing add\n    // operation for forward jump.\n    return INT_MAX / 2;\n  }\n  return ::i::InterruptBudgetFor(\n      isolate,\n      override_active_tier ? override_active_tier\n                           : function->GetActiveTier(isolate),\n      function, function->shared()->cached_tiering_decision(), bytecode_length);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TrySetOsrUrgency\",\n            \"about\": \"Attempts to set the OSR (On-Stack Replacement) urgency for a function.\",\n            \"logic\": \"Conditionally sets the OSR urgency of a JSFunction based on various flags and conditions. It first checks if OSR is enabled and the function's optimization is not disabled. It then increases the OSR urgency in the FeedbackVector if all conditions are met.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The current V8 isolate.\"\n                },\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function for which to set the OSR urgency.\"\n                },\n                {\n                    \"name\": \"osr_urgency\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The new OSR urgency value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8_flags.use_osr\",\n                \"shared->optimization_disabled()\",\n                \"CodeTracer\",\n                \"PrintF\",\n                \"function->DebugNameCStr().get()\",\n                \"fv->osr_urgency()\",\n                \"DCHECK_GE\",\n                \"fv->set_osr_urgency()\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TrySetOsrUrgency(Isolate* isolate, Tagged<JSFunction> function,\n                      int osr_urgency) {\n  Tagged<SharedFunctionInfo> shared = function->shared();\n  if (V8_UNLIKELY(!v8_flags.use_osr)) return;\n  if (V8_UNLIKELY(shared->optimization_disabled())) return;\n\n  // We've passed all checks - bump the OSR urgency.\n\n  Tagged<FeedbackVector> fv = function->feedback_vector();\n  if (V8_UNLIKELY(v8_flags.trace_osr)) {\n    CodeTracer::Scope scope(isolate->GetCodeTracer());\n    PrintF(scope.file(),\n           \"[OSR - setting osr urgency. function: %s, old urgency: %d, new \"\n           \"urgency: %d]\\n\",\n           function->DebugNameCStr().get(), fv->osr_urgency(), osr_urgency);\n  }\n\n  DCHECK_GE(osr_urgency, fv->osr_urgency());  // Never lower urgency here.\n  fv->set_osr_urgency(osr_urgency);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryIncrementOsrUrgency\",\n            \"about\": \"Attempts to increment the OSR (On-Stack Replacement) urgency for a function.\",\n            \"logic\": \"Increments the OSR urgency of the provided JSFunction if OSR is enabled and the function's optimization is not disabled. It caps the urgency at a maximum value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The current V8 isolate.\"\n                },\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Tagged<JSFunction>\",\n                    \"purpose\": \"The function for which to increment the OSR urgency.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"function->feedback_vector()\",\n                \"old_urgency\",\n                \"new_urgency\",\n                \"std::min()\",\n                \"FeedbackVector::kMaxOsrUrgency\",\n                \"TrySetOsrUrgency()\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid TryIncrementOsrUrgency(Isolate* isolate, Tagged<JSFunction> function) {\n  int old_urgency = function->feedback_vector()->osr_urgency();\n  int new_urgency = std::min(old_urgency + 1, FeedbackVector::kMaxOsrUrgency);\n  TrySetOsrUrgency(isolate, function, new_urgency);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryRequestOsrAtNextOpportunity\",\n            \"about\": \"Requests On-Stack Replacement (OSR) for a function at the next available opportunity.\",\n            \"logic\": \"Sets the OSR urgency of the given function to"
}