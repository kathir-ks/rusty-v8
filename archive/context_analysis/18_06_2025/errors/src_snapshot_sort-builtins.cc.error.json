{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/sort-builtins.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/sort-builtins.cc\",\n        \"file_name\": \"sort-builtins.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements a sorter for built-in functions based on profiling data to improve snapshot performance.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8 specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"sort-builtins.h\"\n\n#include <algorithm>\n#include <fstream>\n\n#include \"src/snapshot/embedded/embedded-data-inl.h\"\n#include \"src/snapshot/embedded/embedded-data.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Cluster\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents a cluster of built-in functions with similar execution characteristics.\",\n            \"attributes\": [\n                {\n                    \"name\": \"density_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Represents the execution density of the cluster (normalized execution count).\"\n                },\n                {\n                    \"name\": \"size_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Represents the total size of the built-in functions in the cluster.\"\n                },\n                {\n                    \"name\": \"targets_\",\n                    \"type\": \"std::vector<Builtin>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the list of built-in functions belonging to this cluster.\"\n                },\n                {\n                    \"name\": \"sorter_\",\n                    \"type\": \"BuiltinsSorter*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the BuiltinsSorter that manages this cluster.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Builtin\",\n                \"BuiltinsSorter\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nclass Cluster {\n public:\n  Cluster(uint32_t density, uint32_t size, Builtin target,\n                 BuiltinsSorter* sorter);\n  void Merge(Cluster* other);\n  uint64_t time_approximation();\n\n  uint32_t density() const { return density_; }\n  uint32_t size() const { return size_; }\n\n  const std::vector<Builtin>& targets() const { return targets_; }\n\n private:\n  uint32_t density_;\n  uint32_t size_;\n  std::vector<Builtin> targets_;\n  BuiltinsSorter* sorter_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"Cluster\",\n            \"parent\": \"Cluster\",\n            \"about\": \"Constructor for the Cluster class.\",\n            \"logic\": \"Initializes a new cluster with a given density, size, a target builtin and a pointer to the sorter.\",\n            \"parameters\": [\n                {\n                    \"name\": \"density\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"Initial density of the cluster.\"\n                },\n                {\n                    \"name\": \"size\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"Initial size of the cluster.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The initial built-in function to include in the cluster.\"\n                },\n                {\n                    \"name\": \"sorter\",\n                    \"type\": \"BuiltinsSorter*\",\n                    \"purpose\": \"A pointer to the BuiltinsSorter object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"Builtin\",\n                \"BuiltinsSorter\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCluster::Cluster(uint32_t density, uint32_t size, Builtin target,\n                 BuiltinsSorter* sorter)\n    : density_(density), size_(size), sorter_(sorter) {\n  CHECK(size_);\n  targets_.push_back(target);\n  sorter_->builtin_cluster_map_[target] = this;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Merge\",\n            \"parent\": \"Cluster\",\n            \"about\": \"Merges another cluster into the current cluster.\",\n            \"logic\": \"Combines the targets from the other cluster, updates the density and size, and clears the other cluster.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"Cluster*\",\n                    \"purpose\": \"The cluster to merge into the current cluster.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"Builtin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Cluster::Merge(Cluster* other) {\n  for (Builtin builtin : other->targets_) {\n    targets_.push_back(builtin);\n    sorter_->builtin_cluster_map_.emplace(builtin, this);\n  }\n  density_ = static_cast<uint32_t>(\n      (time_approximation() + other->time_approximation()) /\n      (size_ + other->size_));\n  size_ += other->size_;\n  other->density_ = 0;\n  other->size_ = 0;\n  other->targets_.clear();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"time_approximation\",\n            \"parent\": \"Cluster\",\n            \"about\": \"Calculates a time approximation for the cluster.\",\n            \"logic\": \"Calculates the time approximation by multiplying size by density.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"uint64_t\",\n                \"description\": \"Approximation of time.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nuint64_t Cluster::time_approximation() {\n  return static_cast<uint64_t>(size_) * density_;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BuiltinsSorter\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Sorts built-in functions based on profiling data and call graph information.\",\n            \"attributes\": [\n                {\n                    \"name\": \"clusters_\",\n                    \"type\": \"std::vector<Cluster*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the list of clusters.\"\n                },\n                {\n                    \"name\": \"builtin_cluster_map_\",\n                    \"type\": \"std::unordered_map<Builtin, Cluster*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps each builtin to its containing cluster.\"\n                },\n                {\n                    \"name\": \"builtin_density_map_\",\n                    \"type\": \"std::unordered_map<Builtin, int>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps each builtin to its execution density.\"\n                },\n                {\n                    \"name\": \"builtin_size_\",\n                    \"type\": \"std::vector<uint32_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the sizes of builtins.\"\n                },\n                {\n                    \"name\": \"builtin_density_order_\",\n                    \"type\": \"std::vector<BuiltinDensitySlot>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores builtins in the order of density.\"\n                },\n                {\n                   \"name\": \"call_graph_\",\n                   \"type\": \"std::unordered_map<Builtin, CallProbabilities>\",\n                   \"access\": \"private\",\n                   \"purpose\": \"Stores the call graph between builtins and their associated probabilities.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Cluster\",\n                \"Builtin\",\n                \"BuiltinsCallGraph\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass BuiltinsSorter {\n public:\n  BuiltinsSorter();\n  ~BuiltinsSorter();\n\n  void InitializeClusters();\n  Builtin FindBestPredecessorOf(Builtin callee);\n  void MergeBestPredecessors();\n  void SortClusters();\n\n  void ProcessBlockCountLineInfo(\n      std::istringstream& line_stream,\n      std::unordered_map<std::string, Builtin>& name2id);\n  void ProcessBuiltinDensityLineInfo(\n      std::istringstream& line_stream,\n      std::unordered_map<std::string, Builtin>& name2id);\n  void InitializeCallGraph(const char* profiling_file,\n                           const std::vector<uint32_t>& size);\n  std::vector<Builtin> SortBuiltins(const char* profiling_file,\n                                     const std::vector<uint32_t>& builtin_size);\n\n private:\n  struct BuiltinDensitySlot {\n    int density_;\n    Builtin builtin_;\n  };\n\n  using CallProbability = std::pair<int32_t, int32_t>;\n  using CallProbabilities = std::unordered_map<Builtin, CallProbability>;\n  using BuiltinCallees = std::unordered_map<int32_t, std::vector<Builtin>>;\n\n  static constexpr int kMinEdgeProbabilityThreshold = 5;\n  static constexpr int kMaxClusterSize = 256;\n  static constexpr int kMaxDensityDecreaseThreshold = 10;\n  static constexpr const char* kBuiltinDensityMarker = \"density\";\n  static constexpr const char* kBuiltinCallBlockDensityMarker = \"block\";\n\n  std::vector<Cluster*> clusters_;\n  std::unordered_map<Builtin, Cluster*> builtin_cluster_map_;\n  std::unordered_map<Builtin, int> builtin_density_map_;\n  std::vector<uint32_t> builtin_size_;\n  std::vector<BuiltinDensitySlot> builtin_density_order_;\n  std::unordered_map<Builtin, CallProbabilities> call_graph_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"BuiltinsSorter\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Constructor for the BuiltinsSorter class.\",\n            \"logic\": \"Initializes the BuiltinsSorter.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nBuiltinsSorter::BuiltinsSorter() {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"destructor\",\n            \"name\": \"~BuiltinsSorter\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Destructor for the BuiltinsSorter class.\",\n            \"logic\": \"Deallocates memory used by the clusters.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nBuiltinsSorter::~BuiltinsSorter() {\n  for (Cluster* cls : clusters_) {\n    delete cls;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeClusters\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Initializes the clusters of built-in functions.\",\n            \"logic\": \"Creates a cluster for each built-in function, excluding ASM and CPP builtins, and sorts them by density.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"Builtin\",\n                \"Builtins\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BuiltinsSorter::InitializeClusters() {\n  for (uint32_t i = 0; i < static_cast<uint32_t>(builtin_size_.size()); i++) {\n    Builtin id = Builtins::FromInt(i);\n    Builtins::Kind kind = Builtins::KindOf(id);\n    if (kind == Builtins::Kind::ASM || kind == Builtins::Kind::CPP) {\n      // CHECK there is no data for execution count for non TurboFan compiled\n      // builtin.\n      CHECK_EQ(builtin_density_map_[id], 0);\n      continue;\n    }\n    Cluster* cls =\n        new Cluster(builtin_density_map_[id], builtin_size_[i], id, this);\n    clusters_.push_back(cls);\n    builtin_density_order_.push_back(\n        BuiltinDensitySlot{builtin_density_map_[id], id});\n  }\n\n  std::sort(builtin_density_order_.begin(), builtin_density_order_.end(),\n            [](const BuiltinDensitySlot& x, const BuiltinDensitySlot& y) {\n              return x.density_ > y.density_;\n            });\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FindBestPredecessorOf\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Finds the best predecessor (caller) of a given built-in function based on call graph probabilities.\",\n            \"logic\": \"Iterates through the call graph to find the caller with the highest incoming call probability to the given callee. It considers constraints such as cluster size and density decrease to avoid merging unrelated clusters.\",\n            \"parameters\": [\n                {\n                    \"name\": \"callee\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The built-in function to find a predecessor for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Builtin\",\n                \"description\": \"The best predecessor built-in function, or Builtin::kNoBuiltinId if none is found.\"\n            },\n            \"dependencies\": [\n                \"Builtin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nBuiltin BuiltinsSorter::FindBestPredecessorOf(Builtin callee) {\n  Builtin bestPred = Builtin::kNoBuiltinId;\n  int32_t bestProb = 0;\n\n  for (auto caller_it = call_graph_.begin(); caller_it != call_graph_.end();\n       caller_it++) {\n    Builtin caller = caller_it->first;\n    const CallProbabilities& callees_prob = caller_it->second;\n    if (callees_prob.count(callee) > 0) {\n      int32_t incoming_prob = callees_prob.at(callee).incoming_;\n      if (incoming_prob == -1) {\n        // We dont want to merge any cluster with -1 prob, because it means it's\n        // either a non TurboFan compiled builtin or its execution count too\n        // small.\n        continue;\n      }\n      if (bestPred == Builtin::kNoBuiltinId || incoming_prob > bestProb) {\n        bestPred = caller;\n        bestProb = incoming_prob;\n      }\n    }\n\n    if (bestProb < kMinEdgeProbabilityThreshold ||\n        bestPred == Builtin::kNoBuiltinId)\n      continue;\n\n    Cluster* predCls = builtin_cluster_map_[bestPred];\n    Cluster* succCls = builtin_cluster_map_[callee];\n\n    // Don't merge if the caller and callee are already in same cluster.\n    if (predCls == succCls) continue;\n    // Don't merge clusters if the combined size is too big.\n    if (predCls->size_ + succCls->size_ > kMaxClusterSize) continue;\n    if (predCls->density_ == 0) {\n      // Some density of cluster after normalized may be 0, in that case we dont\n      // merge them.\n      continue;\n    }\n    CHECK(predCls->size_);\n\n    uint32_t new_density = static_cast<uint32_t>(\n        (predCls->time_approximation() + succCls->time_approximation()) /\n        (predCls->size_ + succCls->size_));\n\n    // Don't merge clusters if the new merged density is lower too many times\n    // than current cluster, to avoid a huge dropping in cluster density, it\n    // will harm locality of builtins.\n    if (predCls->density_ / kMaxDensityDecreaseThreshold > new_density)\n      continue;\n  }\n\n  return bestPred;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MergeBestPredecessors\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Merges each built-in function with its best predecessor, effectively clustering them based on call graph relationships.\",\n            \"logic\": \"Iterates through the sorted list of built-in functions and merges each one with its best predecessor using the FindBestPredecessorOf method.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"Builtin\",\n                \"FindBestPredecessorOf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BuiltinsSorter::MergeBestPredecessors() {\n  for (size_t i = 0; i < builtin_density_order_.size(); i++) {\n    Builtin id = builtin_density_order_[i].builtin_;\n    Cluster* succ_cluster = builtin_cluster_map_[id];\n\n    Builtin bestPred = FindBestPredecessorOf(id);\n    if (bestPred != Builtin::kNoBuiltinId) {\n      Cluster* pred_cluster = builtin_cluster_map_[bestPred];\n      pred_cluster->Merge(succ_cluster);\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SortClusters\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Sorts the clusters based on their density and removes empty clusters.\",\n            \"logic\": \"Sorts the clusters in descending order of density and then removes any clusters that are empty (have no targets).\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BuiltinsSorter::SortClusters() {\n  std::sort(clusters_.begin(), clusters_.end(),\n            [](const Cluster* x, const Cluster* y) {\n              return x->density_ > y->density_;\n            });\n\n  clusters_.erase(\n      std::remove_if(clusters_.begin(), clusters_.end(),\n                     [](const Cluster* x) { return x->targets_.empty(); }),\n      clusters_.end());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AddBuiltinIfNotProcessed\",\n            \"parent\": null,\n            \"about\": \"Adds a built-in function to a list if it hasn't been processed yet.\",\n            \"logic\": \"Checks if the built-in function is already in the set of processed built-ins. If not, it adds it to the list and the set.\",\n            \"parameters\": [\n                {\n                    \"name\": \"builtin\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The built-in function to add.\"\n                },\n                {\n                    \"name\": \"order\",\n                    \"type\": \"std::vector<Builtin>&\",\n                    \"purpose\": \"The list to add the built-in function to.\"\n                },\n                {\n                    \"name\": \"processed_builtins\",\n                    \"type\": \"std::unordered_set<Builtin>&\",\n                    \"purpose\": \"The set of already processed built-in functions.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the built-in function was added, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Builtin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool AddBuiltinIfNotProcessed(Builtin builtin, std::vector<Builtin>& order,\n                              std::unordered_set<Builtin>& processed_builtins) {\n  if (processed_builtins.count(builtin) == 0) {\n    order.push_back(builtin);\n    processed_builtins.emplace(builtin);\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessBlockCountLineInfo\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Processes a line of block count information from the profiling data to update the call graph.\",\n            \"logic\": \"Parses a line containing the normalized execution count of a basic block with a call, extracts caller and callee information, and updates the call graph with the call probabilities.\",\n            \"parameters\": [\n                {\n                    \"name\": \"line_stream\",\n                    \"type\": \"std::istringstream&\",\n                    \"purpose\": \"The input stream containing the line of profiling data.\"\n                },\n                {\n                    \"name\": \"name2id\",\n                    \"type\": \"std::unordered_map<std::string, Builtin>&\",\n                    \"purpose\": \"A map from built-in function names to their IDs.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"Builtin\",\n                \"BuiltinsCallGraph\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BuiltinsSorter::ProcessBlockCountLineInfo(\n    std::istringstream& line_stream,\n    std::unordered_map<std::string, Builtin>& name2id) {\n  // Any line starting with kBuiltinCallBlockDensityMarker is a normalized\n  // execution count of block with call. The format is:\n  //   literal kBuiltinCallBlockDensityMarker , caller , block ,\n  //   normalized_count\n  std::string token;\n  std::string caller_name;\n  CHECK(std::getline(line_stream, caller_name, ','));\n  Builtin caller_id = name2id[caller_name];\n\n  BuiltinsCallGraph* profiler = BuiltinsCallGraph::Get();\n\n  char* end = nullptr;\n  errno = 0;\n  CHECK(std::getline(line_stream, token, ','));\n  int32_t block_id = static_cast<int32_t>(strtoul(token.c_str(), &end, 0));\n  CHECK(errno == 0 && end != token.c_str());\n\n  CHECK(std::getline(line_stream, token, ','));\n  int32_t normalized_count =\n      static_cast<int32_t>(strtoul(token.c_str(), &end, 0));\n  CHECK(errno == 0 && end != token.c_str());\n  CHECK(line_stream.eof());\n\n  const BuiltinCallees* block_callees = profiler->GetBuiltinCallees(caller_id);\n  if (block_callees) {\n    int32_t outgoing_prob = 0;\n    int32_t incoming_prob = 0;\n    int caller_density = 0;\n    int callee_density = 0;\n\n    CHECK(builtin_density_map_.count(caller_id));\n    caller_density = builtin_density_map_.at(caller_id);\n\n    // TODO(v8:13938): Remove the below if check when we just store\n    // interesting blocks (contain call other builtins) execution count into\n    // profiling file.\n    if (block_callees->count(block_id)) {\n      // If the line of block density make sense (means it contain call to\n      // other builtins in this block).\n      for (const auto& callee_id : block_callees->at(block_id)) {\n        if (caller_density != 0) {\n          outgoing_prob = normalized_count * 100 / caller_density;\n        } else {\n          // If the caller density was normalized as 0 but the block density\n          // was not, we set caller prob as 100, otherwise it's 0. Because in\n          // the normalization, we may loss fidelity.\n          // For example, a caller was executed 8 times, but after\n          // normalization, it may be 0 time. At that time, if the\n          // normalized_count of this block (it may be a loop body) is a\n          // positive number, we could think normalized_count is bigger than the\n          // execution count of caller, hence we set it as 100, otherwise it's\n          // smaller than execution count of caller, we could set it as 0.\n          outgoing_prob = normalized_count ? 100 : 0;\n        }\n\n        if (builtin_density_map_.count(callee_id)) {\n          callee_density = builtin_density_map_.at(callee_id);\n          if (callee_density != 0) {\n            incoming_prob = normalized_count * 100 / callee_density;\n          } else {\n            // Same as caller prob when callee density exists but is 0.\n            incoming_prob = normalized_count ? 100 : 0;\n          }\n\n        } else {\n          // If callee_density does not exist, it means the callee was not\n          // compiled by TurboFan or execution count is too small (0 after\n          // normalization), we couldn't get the callee count, so we set it as\n          // -1. In that case we could avoid merging this callee builtin into\n          // any other cluster.\n          incoming_prob = -1;\n        }\n\n        CallProbability probs = CallProbability(incoming_prob, outgoing_prob);\n        if (call_graph_.count(caller_id) == 0) {\n          call_graph_.emplace(caller_id, CallProbabilities());\n        }\n        CallProbabilities& call_probs = call_graph_.at(caller_id);\n        call_probs.emplace(callee_id, probs);\n      }\n    }\n  }\n  CHECK(line_stream.eof());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessBuiltinDensityLineInfo\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Processes a line of built-in function density information from the profiling data.\",\n            \"logic\": \"Parses a line containing the normalized execution count of a built-in function and stores the density in the density map.\",\n            \"parameters\": [\n                {\n                    \"name\": \"line_stream\",\n                    \"type\": \"std::istringstream&\",\n                    \"purpose\": \"The input stream containing the line of profiling data.\"\n                },\n                {\n                    \"name\": \"name2id\",\n                    \"type\": \"std::unordered_map<std::string, Builtin>&\",\n                    \"purpose\": \"A map from built-in function names to their IDs.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"Builtin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BuiltinsSorter::ProcessBuiltinDensityLineInfo(\n    std::istringstream& line_stream,\n    std::unordered_map<std::string, Builtin>& name2id) {\n  // Any line starting with kBuiltinDensityMarker is normalized execution count\n  // for block 0 of a builtin, we take it as density of this builtin. The format\n  // is:\n  //   literal kBuiltinDensityMarker , builtin_name , density\n  std::string token;\n  std::string builtin_name;\n  CHECK(std::getline(line_stream, builtin_name, ','));\n  std::getline(line_stream, token, ',');\n  CHECK(line_stream.eof());\n  char* end = nullptr;\n  errno = 0;\n  int density = static_cast<int>(strtol(token.c_str(), &end, 0));\n  CHECK(errno == 0 && end != token.c_str());\n\n  Builtin builtin_id = name2id[builtin_name];\n  builtin_density_map_.emplace(builtin_id, density);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeCallGraph\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Initializes the call graph from a profiling file.\",\n            \"logic\": \"Reads the profiling file line by line, processing each line to extract built-in density and block count information, and populates the call graph.\",\n            \"parameters\": [\n                {\n                    \"name\": \"profiling_file\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The path to the profiling file.\"\n                },\n                {\n                    \"name\": \"size\",\n                    \"type\": \"const std::vector<uint32_t>&\",\n                    \"purpose\": \"A vector containing the sizes of the built-in functions.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"Builtin\",\n                \"ProcessBuiltinDensityLineInfo\",\n                \"ProcessBlockCountLineInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BuiltinsSorter::InitializeCallGraph(const char* profiling_file,\n                                         const std::vector<uint32_t>& size) {\n  std::ifstream file(profiling_file);\n  CHECK_WITH_MSG(file.good(), \"Can't read log file\");\n\n  std::unordered_map<std::string, Builtin> name2id;\n  for (Builtin i = Builtins::kFirst; i <= Builtins::kLast; ++i) {\n    std::string name = Builtins::name(i);\n    name2id.emplace(name, i);\n    builtin_size_.push_back(size.at(static_cast<uint32_t>(i)));\n  }\n\n  for (std::string line; std::getline(file, line);) {\n    std::string token;\n    std::istringstream line_stream(line);\n    // We must put lines start with kBuiltinDensityMarker before lines start\n    // with kBuiltinCallBlockDensityMarker, because we have to density to\n    // calculate call prob.\n    if (!std::getline(line_stream, token, ',')) continue;\n    if (token == kBuiltinCallBlockDensityMarker) {\n      ProcessBlockCountLineInfo(line_stream, name2id);\n    } else if (token == kBuiltinDensityMarker) {\n      ProcessBuiltinDensityLineInfo(line_stream, name2id);\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SortBuiltins\",\n            \"parent\": \"BuiltinsSorter\",\n            \"about\": \"Sorts the built-in functions based on profiling data and call graph information.\",\n            \"logic\": \"Initializes the call graph, creates clusters, merges them based on call probabilities, sorts the clusters, and then generates the final sorted list of built-in functions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"profiling_file\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The path to the profiling file.\"\n                },\n                {\n                    \"name\": \"builtin_size\",\n                    \"type\": \"const std::vector<uint32_t>&\",\n                    \"purpose\": \"A vector containing the sizes of the built-in functions.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::vector<Builtin>\",\n                \"description\": \"A sorted vector of built-in functions.\"\n            },\n            \"dependencies\": [\n                \"Builtin\",\n                \"InitializeCallGraph\",\n                \"InitializeClusters\",\n                \"MergeBestPredecessors\",\n                \"SortClusters\",\n                \"AddBuiltinIfNotProcessed\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::vector<Builtin> BuiltinsSorter::SortBuiltins(\n    const char* profiling_file, const std::vector<uint32_t>& builtin_size) {\n  InitializeCallGraph(profiling_file, builtin_size);\n\n  // Step 1: initialization.\n  InitializeClusters();\n\n  // Step 2: Merge best predecessors.\n  MergeBestPredecessors();\n\n  // Step 3: Sort clusters again"
}