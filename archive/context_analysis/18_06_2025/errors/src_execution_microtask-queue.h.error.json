{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/microtask-queue.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/microtask-queue.h\",\n            \"file_name\": \"microtask-queue.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the MicrotaskQueue class for managing and executing microtasks in V8.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for memory management, data structures, and microtask handling.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <stdint.h>\n\n#include <memory>\n#include <vector>\n\n#include \"include/v8-internal.h\"  // For Address.\n#include \"include/v8-microtask-queue.h\"\n#include \"src/base/macros.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MicrotaskQueue\",\n                \"extends\": \"v8::MicrotaskQueue\",\n                \"about\": \"Manages a queue of microtasks for execution within a V8 isolate.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"size_\",\n                        \"type\": \"intptr_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The number of microtasks currently in the queue.\"\n                    },\n                    {\n                        \"name\": \"capacity_\",\n                        \"type\": \"intptr_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The maximum number of microtasks that can be stored in the queue.\"\n                    },\n                    {\n                        \"name\": \"start_\",\n                        \"type\": \"intptr_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The index of the first microtask in the ring buffer.\"\n                    },\n                    {\n                        \"name\": \"ring_buffer_\",\n                        \"type\": \"Address*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A ring buffer storing the addresses of Microtask objects.\"\n                    },\n                    {\n                        \"name\": \"finished_microtask_count_\",\n                        \"type\": \"intptr_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The number of microtasks that have been completed.\"\n                    },\n                    {\n                        \"name\": \"next_\",\n                        \"type\": \"MicrotaskQueue*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the next MicrotaskQueue in a doubly-linked list.\"\n                    },\n                    {\n                        \"name\": \"prev_\",\n                        \"type\": \"MicrotaskQueue*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the previous MicrotaskQueue in a doubly-linked list.\"\n                    },\n                    {\n                        \"name\": \"microtasks_depth_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracks the depth of nested scopes controlling microtask invocation.\"\n                    },\n                    {\n                        \"name\": \"microtasks_suppressions_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracks the number of suppressions preventing microtasks from running.\"\n                    },\n                    {\n                        \"name\": \"debug_microtasks_depth_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracks the depth for debug purposes to ensure microtasks are correctly wrapped with scopes.\"\n                    },\n                    {\n                        \"name\": \"microtasks_policy_\",\n                        \"type\": \"v8::MicrotasksPolicy\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The policy governing when microtasks are executed.\"\n                    },\n                    {\n                        \"name\": \"is_running_microtasks_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if microtasks are currently being executed.\"\n                    },\n                    {\n                        \"name\": \"is_running_completed_callbacks_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if completed callbacks are currently running.\"\n                    },\n                    {\n                        \"name\": \"microtasks_completed_callbacks_\",\n                        \"type\": \"std::vector<CallbackWithData>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores callbacks to be executed after microtasks are completed.\"\n                    },\n                    {\n                        \"name\": \"microtasks_completed_callbacks_cow_\",\n                        \"type\": \"std::optional<std::vector<CallbackWithData>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores a copy-on-write list of completed callbacks\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"v8::Isolate\",\n                    \"Microtask\",\n                    \"Object\",\n                    \"RootVisitor\",\n                    \"Tagged\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE MicrotaskQueue final : public v8::MicrotaskQueue {\n public:\n  static void SetUpDefaultMicrotaskQueue(Isolate* isolate);\n  static std::unique_ptr<MicrotaskQueue> New(Isolate* isolate);\n\n  ~MicrotaskQueue() override;\n\n  // Uses raw Address values because it's called via ExternalReference.\n  // {raw_microtask} is a tagged Microtask pointer.\n  // Returns Smi::kZero due to CallCFunction.\n  static Address CallEnqueueMicrotask(Isolate* isolate,\n                                      intptr_t microtask_queue_pointer,\n                                      Address raw_microtask);\n\n  // v8::MicrotaskQueue implementations.\n  void EnqueueMicrotask(v8::Isolate* isolate,\n                        v8::Local<Function> microtask) override;\n  void EnqueueMicrotask(v8::Isolate* isolate, v8::MicrotaskCallback callback,\n                        void* data) override;\n  void PerformCheckpoint(v8::Isolate* isolate) override {\n    if (!ShouldPerfomCheckpoint()) return;\n    PerformCheckpointInternal(isolate);\n  }\n\n  bool ShouldPerfomCheckpoint() const {\n    return !IsRunningMicrotasks() && !GetMicrotasksScopeDepth() &&\n           !HasMicrotasksSuppressions();\n  }\n\n  void EnqueueMicrotask(Tagged<Microtask> microtask);\n  void AddMicrotasksCompletedCallback(\n      MicrotasksCompletedCallbackWithData callback, void* data) override;\n  void RemoveMicrotasksCompletedCallback(\n      MicrotasksCompletedCallbackWithData callback, void* data) override;\n  bool IsRunningMicrotasks() const override { return is_running_microtasks_; }\n\n  // Runs all queued Microtasks.\n  // Returns -1 if the execution is terminating, otherwise, returns the number\n  // of microtasks that ran in this round.\n  int RunMicrotasks(Isolate* isolate);\n\n  // Iterate all pending Microtasks in this queue as strong roots, so that\n  // builtins can update the queue directly without the write barrier.\n  void IterateMicrotasks(RootVisitor* visitor);\n\n  // Microtasks scope depth represents nested scopes controlling microtasks\n  // invocation, which happens when depth reaches zero.\n  void IncrementMicrotasksScopeDepth() { ++microtasks_depth_; }\n  void DecrementMicrotasksScopeDepth() { --microtasks_depth_; }\n  int GetMicrotasksScopeDepth() const override { return microtasks_depth_; }\n\n  // Possibly nested microtasks suppression scopes prevent microtasks\n  // from running.\n  void IncrementMicrotasksSuppressions() { ++microtasks_suppressions_; }\n  void DecrementMicrotasksSuppressions() { --microtasks_suppressions_; }\n  bool HasMicrotasksSuppressions() const {\n    return microtasks_suppressions_ != 0;\n  }\n\n#ifdef DEBUG\n  // In debug we check that calls not intended to invoke microtasks are\n  // still correctly wrapped with microtask scopes.\n  void IncrementDebugMicrotasksScopeDepth() { ++debug_microtasks_depth_; }\n  void DecrementDebugMicrotasksScopeDepth() { --debug_microtasks_depth_; }\n  bool DebugMicrotasksScopeDepthIsZero() const {\n    return debug_microtasks_depth_ == 0;\n  }\n#endif\n\n  void set_microtasks_policy(v8::MicrotasksPolicy microtasks_policy) {\n    microtasks_policy_ = microtasks_policy;\n  }\n  v8::MicrotasksPolicy microtasks_policy() const { return microtasks_policy_; }\n\n  intptr_t capacity() const { return capacity_; }\n  intptr_t size() const { return size_; }\n  intptr_t start() const { return start_; }\n\n  Tagged<Microtask> get(intptr_t index) const;\n\n  MicrotaskQueue* next() const { return next_; }\n  MicrotaskQueue* prev() const { return prev_; }\n\n  static const size_t kRingBufferOffset;\n  static const size_t kCapacityOffset;\n  static const size_t kSizeOffset;\n  static const size_t kStartOffset;\n  static const size_t kFinishedMicrotaskCountOffset;\n\n  static const intptr_t kMinimumCapacity;\n\n private:\n  void PerformCheckpointInternal(v8::Isolate* v8_isolate);\n\n  void OnCompleted(Isolate* isolate);\n\n  MicrotaskQueue();\n  void ResizeBuffer(intptr_t new_capacity);\n\n  // A ring buffer to hold Microtask instances.\n  // ring_buffer_[(start_ + i) % capacity_] contains |i|th Microtask for each\n  // |i| in [0, size_).\n  intptr_t size_ = 0;\n  intptr_t capacity_ = 0;\n  intptr_t start_ = 0;\n  Address* ring_buffer_ = nullptr;\n\n  // The number of finished microtask.\n  intptr_t finished_microtask_count_ = 0;\n\n  // MicrotaskQueue instances form a doubly linked list loop, so that all\n  // instances are reachable through |next_|.\n  MicrotaskQueue* next_ = nullptr;\n  MicrotaskQueue* prev_ = nullptr;\n\n  int microtasks_depth_ = 0;\n  int microtasks_suppressions_ = 0;\n#ifdef DEBUG\n  int debug_microtasks_depth_ = 0;\n#endif\n\n  v8::MicrotasksPolicy microtasks_policy_ = v8::MicrotasksPolicy::kAuto;\n\n  bool is_running_microtasks_ = false;\n  bool is_running_completed_callbacks_ = false;\n  using CallbackWithData =\n      std::pair<MicrotasksCompletedCallbackWithData, void*>;\n  std::vector<CallbackWithData> microtasks_completed_callbacks_;\n  std::optional<std::vector<CallbackWithData>>\n      microtasks_completed_callbacks_cow_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SetUpDefaultMicrotaskQueue\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Sets up the default microtask queue for an isolate.\",\n                \"logic\": \"Likely initializes and configures the microtask queue for a given isolate, ensuring it's ready for use.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate for which to set up the microtask queue.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  static void SetUpDefaultMicrotaskQueue(Isolate* isolate);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"New\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Creates a new MicrotaskQueue instance.\",\n                \"logic\": \"Allocates a new MicrotaskQueue object, possibly initializing its internal state.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate associated with the new microtask queue.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::unique_ptr<MicrotaskQueue>\",\n                    \"description\": \"A unique pointer to the newly created MicrotaskQueue.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"MicrotaskQueue\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  static std::unique_ptr<MicrotaskQueue> New(Isolate* isolate);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"~MicrotaskQueue\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Destructor for the MicrotaskQueue class.\",\n                \"logic\": \"Releases resources held by the MicrotaskQueue, such as the ring buffer.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  ~MicrotaskQueue() override;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CallEnqueueMicrotask\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Enqueues a microtask using raw Address values.\",\n                \"logic\": \"This function seems to be called via ExternalReference, dealing directly with memory addresses. It enqueues a tagged Microtask pointer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate to which the microtask belongs.\"\n                    },\n                    {\n                        \"name\": \"microtask_queue_pointer\",\n                        \"type\": \"intptr_t\",\n                        \"purpose\": \"A pointer to the microtask queue.\"\n                    },\n                    {\n                        \"name\": \"raw_microtask\",\n                        \"type\": \"Address\",\n                        \"purpose\": \"The memory address of the microtask to enqueue.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Address\",\n                    \"description\": \"Smi::kZero due to CallCFunction.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Microtask\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  static Address CallEnqueueMicrotask(Isolate* isolate,\n                                      intptr_t microtask_queue_pointer,\n                                      Address raw_microtask);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EnqueueMicrotask\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Enqueues a microtask from a v8::Local<Function>.\",\n                \"logic\": \"Wraps the v8::Local<Function> into a Microtask and enqueues it into the queue.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"v8::Isolate*\",\n                        \"purpose\": \"The V8 isolate to which the microtask belongs.\"\n                    },\n                    {\n                        \"name\": \"microtask\",\n                        \"type\": \"v8::Local<Function>\",\n                        \"purpose\": \"The function to be executed as a microtask.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"v8::Isolate\",\n                    \"v8::Local<Function>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void EnqueueMicrotask(v8::Isolate* isolate,\n                        v8::Local<Function> microtask) override;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EnqueueMicrotask\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Enqueues a microtask using a callback function and associated data.\",\n                \"logic\": \"Creates a Microtask from the given callback and data, and adds it to the queue.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"v8::Isolate*\",\n                        \"purpose\": \"The V8 isolate to which the microtask belongs.\"\n                    },\n                    {\n                        \"name\": \"callback\",\n                        \"type\": \"v8::MicrotaskCallback\",\n                        \"purpose\": \"The callback function to be executed as a microtask.\"\n                    },\n                    {\n                        \"name\": \"data\",\n                        \"type\": \"void*\",\n                        \"purpose\": \"Data to be passed to the callback function.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"v8::Isolate\",\n                    \"v8::MicrotaskCallback\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void EnqueueMicrotask(v8::Isolate* isolate, v8::MicrotaskCallback callback,\n                        void* data) override;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PerformCheckpoint\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Performs a checkpoint to execute microtasks if the queue is in a suitable state.\",\n                \"logic\": \"Checks if a checkpoint should be performed (no running microtasks, no suppression, scope depth is zero). If so, calls PerformCheckpointInternal.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"v8::Isolate*\",\n                        \"purpose\": \"The V8 isolate associated with the microtask queue.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"v8::Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void PerformCheckpoint(v8::Isolate* isolate) override {\n    if (!ShouldPerfomCheckpoint()) return;\n    PerformCheckpointInternal(isolate);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ShouldPerfomCheckpoint\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Determines if a microtask checkpoint should be performed.\",\n                \"logic\": \"Returns true if microtasks are not running, the microtask scope depth is zero, and there are no microtask suppressions.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if a checkpoint should be performed, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  bool ShouldPerfomCheckpoint() const {\n    return !IsRunningMicrotasks() && !GetMicrotasksScopeDepth() &&\n           !HasMicrotasksSuppressions();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EnqueueMicrotask\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Enqueues a Tagged<Microtask> directly.\",\n                \"logic\": \"Adds the given Tagged<Microtask> to the internal queue.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"microtask\",\n                        \"type\": \"Tagged<Microtask>\",\n                        \"purpose\": \"The microtask to enqueue.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Tagged<Microtask>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void EnqueueMicrotask(Tagged<Microtask> microtask);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddMicrotasksCompletedCallback\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Adds a callback to be executed when microtasks are completed.\",\n                \"logic\": \"Appends the provided callback and associated data to the list of completed callbacks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"callback\",\n                        \"type\": \"MicrotasksCompletedCallbackWithData\",\n                        \"purpose\": \"The callback function to be executed.\"\n                    },\n                    {\n                        \"name\": \"data\",\n                        \"type\": \"void*\",\n                        \"purpose\": \"Data to be passed to the callback function.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"MicrotasksCompletedCallbackWithData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void AddMicrotasksCompletedCallback(\n      MicrotasksCompletedCallbackWithData callback, void* data) override;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RemoveMicrotasksCompletedCallback\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Removes a callback from the list of callbacks to be executed when microtasks are completed.\",\n                \"logic\": \"Searches the list of completed callbacks and removes the specified callback with its associated data.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"callback\",\n                        \"type\": \"MicrotasksCompletedCallbackWithData\",\n                        \"purpose\": \"The callback function to be removed.\"\n                    },\n                    {\n                        \"name\": \"data\",\n                        \"type\": \"void*\",\n                        \"purpose\": \"Data associated with the callback function.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"MicrotasksCompletedCallbackWithData\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void RemoveMicrotasksCompletedCallback(\n      MicrotasksCompletedCallbackWithData callback, void* data) override;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsRunningMicrotasks\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Checks if microtasks are currently being executed.\",\n                \"logic\": \"Returns the value of the `is_running_microtasks_` flag.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if microtasks are currently running, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  bool IsRunningMicrotasks() const override { return is_running_microtasks_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RunMicrotasks\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Runs all queued microtasks.\",\n                \"logic\": \"Executes all microtasks in the queue until the queue is empty or the execution is terminated.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate associated with the microtask queue.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Returns -1 if the execution is terminating, otherwise, returns the number of microtasks that ran in this round.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  int RunMicrotasks(Isolate* isolate);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IterateMicrotasks\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Iterates all pending Microtasks in this queue as strong roots.\",\n                \"logic\": \"The visitor will be able to access all pending microtasks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"visitor\",\n                        \"type\": \"RootVisitor*\",\n                        \"purpose\": \"The visitor to apply on the microtasks\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RootVisitor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void IterateMicrotasks(RootVisitor* visitor);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IncrementMicrotasksScopeDepth\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Increments the microtask scope depth.\",\n                \"logic\": \"Increases the `microtasks_depth_` counter.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  void IncrementMicrotasksScopeDepth() { ++microtasks_depth_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DecrementMicrotasksScopeDepth\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Decrements the microtask scope depth.\",\n                \"logic\": \"Decreases the `microtasks_depth_` counter.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  void DecrementMicrotasksScopeDepth() { --microtasks_depth_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetMicrotasksScopeDepth\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Returns the current microtask scope depth.\",\n                \"logic\": \"Returns the value of the `microtasks_depth_` counter.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The current microtask scope depth.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  int GetMicrotasksScopeDepth() const override { return microtasks_depth_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IncrementMicrotasksSuppressions\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Increments the microtasks suppressions counter.\",\n                \"logic\": \"Increases the `microtasks_suppressions_` counter.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  void IncrementMicrotasksSuppressions() { ++microtasks_suppressions_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DecrementMicrotasksSuppressions\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Decrements the microtasks suppressions counter.\",\n                \"logic\": \"Decreases the `microtasks_suppressions_` counter.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  void DecrementMicrotasksSuppressions() { --microtasks_suppressions_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HasMicrotasksSuppressions\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Checks if there are any active microtask suppressions.\",\n                \"logic\": \"Returns true if `microtasks_suppressions_` is not zero.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if there are active suppressions, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  bool HasMicrotasksSuppressions() const {\n    return microtasks_suppressions_ != 0;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IncrementDebugMicrotasksScopeDepth\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Increments the debug microtasks scope depth (debug only).\",\n                \"logic\": \"Increases the `debug_microtasks_depth_` counter. Only available in debug builds.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\n  // In debug we check that calls not intended to invoke microtasks are\n  // still correctly wrapped with microtask scopes.\n  void IncrementDebugMicrotasksScopeDepth() { ++debug_microtasks_depth_; }\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DecrementDebugMicrotasksScopeDepth\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Decrements the debug microtasks scope depth (debug only).\",\n                \"logic\": \"Decreases the `debug_microtasks_depth_` counter. Only available in debug builds.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\n  void DecrementDebugMicrotasksScopeDepth() { --debug_microtasks_depth_; }\n#endif\n        ]]></code>\n    </func>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DebugMicrotasksScopeDepthIsZero\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Checks if the debug microtasks scope depth is zero (debug only).\",\n                \"logic\": \"Returns true if `debug_microtasks_depth_` is zero. Only available in debug builds.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if debug scope depth is zero, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\n  bool DebugMicrotasksScopeDepthIsZero() const {\n    return debug_microtasks_depth_ == 0;\n  }\n#endif\n        ]]></code>\n    </func>\n   <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"set_microtasks_policy\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Sets the microtasks policy.\",\n                \"logic\": \"Sets the value of `microtasks_policy_`.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"microtasks_policy\",\n                        \"type\": \"v8::MicrotasksPolicy\",\n                        \"purpose\": \"The new microtasks policy to set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  void set_microtasks_policy(v8::MicrotasksPolicy microtasks_policy) {\n    microtasks_policy_ = microtasks_policy;\n  }\n        ]]></code>\n    </func>\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"microtasks_policy\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Gets the microtasks policy.\",\n                \"logic\": \"Returns the value of `microtasks_policy_`.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"v8::MicrotasksPolicy\",\n                    \"description\": \"The current microtasks policy.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  v8::MicrotasksPolicy microtasks_policy() const { return microtasks_policy_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"capacity\",\n                \"parent\": \"MicrotaskQueue\",\n                \"about\": \"Returns the capacity of the microtask queue.\",\n                \"logic\": \"Returns the value of `capacity_`.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"intptr_t\",\n                    \"description\": \"The capacity of the queue"
}