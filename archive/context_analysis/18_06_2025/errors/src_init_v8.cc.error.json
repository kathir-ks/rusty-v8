{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/init/v8.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/init/v8.cc\",\n        \"file_name\": \"v8.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Initializes the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for V8 initialization, platform integration, and various V8 features.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/init/v8.h\"\n\n#include <fstream>\n\n#include \"include/cppgc/platform.h\"\n#include \"include/v8-sandbox.h\"\n#include \"src/api/api.h\"\n#include \"src/base/atomicops.h\"\n#include \"src/base/once.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/codegen/cpu-features.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/common/code-memory-access.h\"\n#include \"src/debug/debug.h\"\n#include \"src/deoptimizer/deoptimizer.h\"\n#include \"src/execution/frames.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/execution/simulator.h\"\n#include \"src/flags/flags.h\"\n#include \"src/init/bootstrapper.h\"\n#include \"src/libsampler/sampler.h\"\n#include \"src/objects/elements.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/profiler/heap-profiler.h\"\n#include \"src/sandbox/hardware-support.h\"\n#include \"src/sandbox/sandbox.h\"\n#include \"src/sandbox/testing.h\"\n#include \"src/snapshot/snapshot.h\"\n#if defined(V8_USE_PERFETTO)\n#include \"src/tracing/code-data-source.h\"\n#endif  // defined(V8_USE_PERFETTO)\n#include \"src/tracing/tracing-category-observer.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-engine.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n#if defined(V8_ENABLE_ETW_STACK_WALKING)\n#include \"src/diagnostics/etw-jit-win.h\"\n#endif  // V8_ENABLE_ETW_STACK_WALKING\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"V8\",\n            \"about\": \"Provides static methods for initializing and managing the V8 engine.\",\n            \"attributes\": [\n                {\n                    \"name\": \"platform_\",\n                    \"type\": \"v8::Platform*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the platform-specific implementation.\"\n                },\n                {\n                    \"name\": \"kNoOOMDetails\",\n                    \"type\": \"const OOMDetails\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Represents a situation with no OOM details\"\n                },\n                {\n                    \"name\": \"kHeapOOM\",\n                    \"type\": \"const OOMDetails\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Represents a heap out-of-memory situation.\"\n                }\n            ],\n            \"dependencies\": [\n                \"v8::Platform\",\n                \"OOMDetails\",\n                \"FlagList\",\n                \"IsolateGroup\",\n                \"Isolate\",\n                \"Simulator\",\n                \"CpuFeatures\",\n                \"ElementsAccessor\",\n                \"Bootstrapper\",\n                \"CallDescriptors\",\n                \"wasm::WasmEngine\",\n                \"ExternalReferenceTable\",\n                \"Sandbox\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\n// static\nv8::Platform* V8::platform_ = nullptr;\nconst OOMDetails V8::kNoOOMDetails{false, nullptr};\nconst OOMDetails V8::kHeapOOM{true, nullptr};\n\nnamespace {\nenum class V8StartupState {\n  kIdle,\n  kPlatformInitializing,\n  kPlatformInitialized,\n  kV8Initializing,\n  kV8Initialized,\n  kV8Disposing,\n  kV8Disposed,\n  kPlatformDisposing,\n  kPlatformDisposed\n};\n\nstd::atomic<V8StartupState> v8_startup_state_(V8StartupState::kIdle);\n\nvoid AdvanceStartupState(V8StartupState expected_next_state) {\n  V8StartupState current_state = v8_startup_state_;\n  CHECK_NE(current_state, V8StartupState::kPlatformDisposed);\n  V8StartupState next_state =\n      static_cast<V8StartupState>(static_cast<int>(current_state) + 1);\n  if (next_state != expected_next_state) {\n    // Ensure the following order:\n    // v8::V8::InitializePlatform(platform);\n    // v8::V8::Initialize();\n    // v8::Isolate* isolate = v8::Isolate::New(...);\n    // ...\n    // isolate->Dispose();\n    // v8::V8::Dispose();\n    // v8::V8::DisposePlatform();\n    FATAL(\"Wrong initialization order: from %d to %d, expected to %d!\",\n          static_cast<int>(current_state), static_cast<int>(next_state),\n          static_cast<int>(expected_next_state));\n  }\n  if (!v8_startup_state_.compare_exchange_strong(current_state, next_state)) {\n    FATAL(\n        \"Multiple threads are initializating V8 in the wrong order: expected \"\n        \"%d got %d!\",\n        static_cast<int>(current_state),\n        static_cast<int>(v8_startup_state_.load()));\n  }\n}\n\n}  // namespace\n\n#ifdef V8_USE_EXTERNAL_STARTUP_DATA\nV8_DECLARE_ONCE(init_snapshot_once);\n#endif\n\n// static\nvoid V8::InitializePlatform(v8::Platform* platform) {\n  AdvanceStartupState(V8StartupState::kPlatformInitializing);\n  CHECK(!platform_);\n  CHECK_NOT_NULL(platform);\n  platform_ = platform;\n  v8::base::SetPrintStackTrace(platform_->GetStackTracePrinter());\n  v8::tracing::TracingCategoryObserver::SetUp();\n#if defined(V8_ENABLE_ETW_STACK_WALKING)\n  if (v8_flags.enable_etw_stack_walking ||\n      v8_flags.enable_etw_by_custom_filter_only) {\n    v8::internal::ETWJITInterface::Register();\n  }\n#endif  // V8_ENABLE_ETW_STACK_WALKING\n\n  // Initialization needs to happen on platform-level, as this sets up some\n  // cppgc internals that are needed to allow gracefully failing during cppgc\n  // platform setup.\n  CppHeap::InitializeOncePerProcess();\n\n  AdvanceStartupState(V8StartupState::kPlatformInitialized);\n}\n\n// static\nvoid V8::InitializePlatformForTesting(v8::Platform* platform) {\n  if (v8_startup_state_ != V8StartupState::kIdle) {\n    FATAL(\n        \"The platform was initialized before. Note that running multiple tests \"\n        \"in the same process is not supported.\");\n  }\n  V8::InitializePlatform(platform);\n}\n\nvoid V8::Initialize() {\n  AdvanceStartupState(V8StartupState::kV8Initializing);\n  CHECK(platform_);\n\n  FlagList::EnforceFlagImplications();\n\n  // Initialize the default FlagList::Hash.\n  FlagList::Hash();\n\n  // Before initializing internals, freeze the flags such that further changes\n  // are not allowed. Global initialization of the Isolate or the WasmEngine\n  // already reads flags, so they should not be changed afterwards.\n  if (v8_flags.freeze_flags_after_init) FlagList::FreezeFlags();\n\n  if (v8_flags.trace_turbo) {\n    // Create an empty file shared by the process (e.g. the wasm engine).\n    std::ofstream(Isolate::GetTurboCfgFileName(nullptr).c_str(),\n                  std::ios_base::trunc);\n  }\n\n  // The --jitless and --interpreted-frames-native-stack flags are incompatible\n  // since the latter requires code generation while the former prohibits code\n  // generation.\n  CHECK(!v8_flags.interpreted_frames_native_stack || !v8_flags.jitless);\n\n  base::AbortMode abort_mode = base::AbortMode::kDefault;\n\n  if (v8_flags.sandbox_fuzzing || v8_flags.hole_fuzzing) {\n    // In this mode, controlled crashes are harmless. Furthermore, DCHECK\n    // failures should be ignored (and execution should continue past them) as\n    // they may otherwise hide issues.\n    abort_mode = base::AbortMode::kExitWithFailureAndIgnoreDcheckFailures;\n  } else if (v8_flags.sandbox_testing) {\n    // Similar to the above case, but here we want to exit with a status\n    // indicating success (e.g. zero on unix). This is useful for example for\n    // sandbox regression tests, which should \"pass\" if they crash in a\n    // controlled fashion (e.g. in a SBXCHECK).\n    abort_mode = base::AbortMode::kExitWithSuccessAndIgnoreDcheckFailures;\n  } else if (v8_flags.hard_abort) {\n    abort_mode = base::AbortMode::kImmediateCrash;\n  }\n\n  base::OS::Initialize(abort_mode, v8_flags.gc_fake_mmap);\n\n  if (v8_flags.random_seed) {\n    GetPlatformPageAllocator()->SetRandomMmapSeed(v8_flags.random_seed);\n    GetPlatformVirtualAddressSpace()->SetRandomSeed(v8_flags.random_seed);\n  }\n\n  if (v8_flags.print_flag_values) FlagList::PrintValues();\n\n  // Fetch the ThreadIsolatedAllocator once since we need to keep the pointer in\n  // protected memory.\n  ThreadIsolation::Initialize(\n      GetCurrentPlatform()->GetThreadIsolatedAllocator());\n\n#ifdef V8_ENABLE_SANDBOX\n  // If enabled, the sandbox must be initialized first.\n  Sandbox::InitializeDefaultOncePerProcess(GetPlatformVirtualAddressSpace());\n  CHECK_EQ(kSandboxSize, Sandbox::current()->size());\n\n  // Enable sandbox testing mode if requested.\n  //\n  // This will install the sandbox crash filter to ignore all crashes that do\n  // not represent sandbox violations.\n  //\n  // Note: this should happen before the Wasm trap handler is installed, so that\n  // the wasm trap handler is invoked first (and can handle Wasm OOB accesses),\n  // then forwards all \"real\" crashes to the sandbox crash filter.\n  if (v8_flags.sandbox_testing || v8_flags.sandbox_fuzzing) {\n    SandboxTesting::Mode mode = v8_flags.sandbox_testing\n                                    ? SandboxTesting::Mode::kForTesting\n                                    : SandboxTesting::Mode::kForFuzzing;\n    SandboxTesting::Enable(mode);\n  }\n#endif  // V8_ENABLE_SANDBOX\n\n#if defined(V8_USE_PERFETTO)\n  if (perfetto::Tracing::IsInitialized()) {\n    TrackEvent::Register();\n    if (v8_flags.perfetto_code_logger) {\n      v8::internal::CodeDataSource::Register();\n    }\n  }\n#endif\n  IsolateGroup::InitializeOncePerProcess();\n  Isolate::InitializeOncePerProcess();\n\n#if defined(USE_SIMULATOR)\n  Simulator::InitializeOncePerProcess();\n#endif\n  CpuFeatures::Probe(false);\n  ElementsAccessor::InitializeOncePerProcess();\n  Bootstrapper::InitializeOncePerProcess();\n  CallDescriptors::InitializeOncePerProcess();\n\n#if V8_ENABLE_WEBASSEMBLY\n  wasm::WasmEngine::InitializeOncePerProcess();\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n  ExternalReferenceTable::InitializeOncePerIsolateGroup(\n      IsolateGroup::current()->external_ref_table());\n  AdvanceStartupState(V8StartupState::kV8Initialized);\n}\n\nvoid V8::Dispose() {\n  AdvanceStartupState(V8StartupState::kV8Disposing);\n  CHECK(platform_);\n#if V8_ENABLE_WEBASSEMBLY\n  wasm::WasmEngine::GlobalTearDown();\n#endif  // V8_ENABLE_WEBASSEMBLY\n#if defined(USE_SIMULATOR)\n  Simulator::GlobalTearDown();\n#endif\n  CallDescriptors::TearDown();\n  ElementsAccessor::TearDown();\n  RegisteredExtension::UnregisterAll();\n  FlagList::ReleaseDynamicAllocations();\n  IsolateGroup::TearDownOncePerProcess();\n  AdvanceStartupState(V8StartupState::kV8Disposed);\n}\n\nvoid V8::DisposePlatform() {\n  AdvanceStartupState(V8StartupState::kPlatformDisposing);\n  CHECK(platform_);\n#if defined(V8_OS_WIN) && defined(V8_ENABLE_ETW_STACK_WALKING)\n  if (v8_flags.enable_etw_stack_walking ||\n      v8_flags.enable_etw_by_custom_filter_only) {\n    v8::internal::ETWJITInterface::Unregister();\n  }\n#endif\n  v8::tracing::TracingCategoryObserver::TearDown();\n  v8::base::SetPrintStackTrace(nullptr);\n\n#ifdef V8_ENABLE_SANDBOX\n  Sandbox::TearDownDefault();\n#endif  // V8_ENABLE_SANDBOX\n\n  platform_ = nullptr;\n\n#if DEBUG\n  internal::ThreadIsolation::CheckTrackedMemoryEmpty();\n#endif\n\n  AdvanceStartupState(V8StartupState::kPlatformDisposed);\n}\n\nv8::Platform* V8::GetCurrentPlatform() {\n  v8::Platform* platform = reinterpret_cast<v8::Platform*>(\n      base::Relaxed_Load(reinterpret_cast<base::AtomicWord*>(&platform_)));\n  DCHECK(platform);\n  return platform;\n}\n\nvoid V8::SetPlatformForTesting(v8::Platform* platform) {\n  base::Relaxed_Store(reinterpret_cast<base::AtomicWord*>(&platform_),\n                      reinterpret_cast<base::AtomicWord>(platform));\n}\n\nvoid V8::SetSnapshotBlob(StartupData* snapshot_blob) {\n#ifdef V8_USE_EXTERNAL_STARTUP_DATA\n  base::CallOnce(&init_snapshot_once, &SetSnapshotFromFile, snapshot_blob);\n#else\n  UNREACHABLE();\n#endif\n}\n}  // namespace internal\n\n// static\ndouble Platform::SystemClockTimeMillis() {\n  return base::OS::TimeCurrentMillis();\n}\n\n// static\nvoid ThreadIsolatedAllocator::SetDefaultPermissionsForSignalHandler() {\n#if V8_HAS_PKU_JIT_WRITE_PROTECT\n  internal::RwxMemoryWriteScope::SetDefaultPermissionsForSignalHandler();\n#endif\n  // TODO(sroettger): this could move to a more generic\n  // SecurityHardwareSupport::SetDefaultPermissionsForSignalHandler.\n  internal::SandboxHardwareSupport::SetDefaultPermissionsForSignalHandler();\n}\n\n// static\nvoid SandboxHardwareSupport::InitializeBeforeThreadCreation() {\n  internal::SandboxHardwareSupport::InitializeBeforeThreadCreation();\n}\n\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializePlatform\",\n            \"parent\": \"V8\",\n            \"about\": \"Initializes the V8 platform with a provided platform implementation.\",\n            \"logic\": \"Sets the platform, sets up stack trace printing, tracing category observer, and cppgc internals. Checks for null platform and correct startup state.\",\n            \"parameters\": [\n                {\n                    \"name\": \"platform\",\n                    \"type\": \"v8::Platform*\",\n                    \"purpose\": \"The platform implementation to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8::Platform\",\n                \"v8::base::SetPrintStackTrace\",\n                \"v8::tracing::TracingCategoryObserver\",\n                \"CppHeap\",\n                \"v8_flags\",\n                \"ETWJITInterface\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid V8::InitializePlatform(v8::Platform* platform) {\n  AdvanceStartupState(V8StartupState::kPlatformInitializing);\n  CHECK(!platform_);\n  CHECK_NOT_NULL(platform);\n  platform_ = platform;\n  v8::base::SetPrintStackTrace(platform_->GetStackTracePrinter());\n  v8::tracing::TracingCategoryObserver::SetUp();\n#if defined(V8_ENABLE_ETW_STACK_WALKING)\n  if (v8_flags.enable_etw_stack_walking ||\n      v8_flags.enable_etw_by_custom_filter_only) {\n    v8::internal::ETWJITInterface::Register();\n  }\n#endif  // V8_ENABLE_ETW_STACK_WALKING\n\n  // Initialization needs to happen on platform-level, as this sets up some\n  // cppgc internals that are needed to allow gracefully failing during cppgc\n  // platform setup.\n  CppHeap::InitializeOncePerProcess();\n\n  AdvanceStartupState(V8StartupState::kPlatformInitialized);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializePlatformForTesting\",\n            \"parent\": \"V8\",\n            \"about\": \"Initializes the V8 platform for testing purposes.\",\n            \"logic\": \"Checks if the platform has been initialized before, then calls InitializePlatform.\",\n            \"parameters\": [\n                {\n                    \"name\": \"platform\",\n                    \"type\": \"v8::Platform*\",\n                    \"purpose\": \"The platform implementation to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8::Platform\",\n                \"V8::InitializePlatform\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid V8::InitializePlatformForTesting(v8::Platform* platform) {\n  if (v8_startup_state_ != V8StartupState::kIdle) {\n    FATAL(\n        \"The platform was initialized before. Note that running multiple tests \"\n        \"in the same process is not supported.\");\n  }\n  V8::InitializePlatform(platform);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Initialize\",\n            \"parent\": \"V8\",\n            \"about\": \"Initializes the V8 engine.\",\n            \"logic\": \"Enforces flag implications, freezes flags, initializes various V8 components (OS, ThreadIsolation, Sandbox, tracing, IsolateGroup, Isolate, Simulator, CpuFeatures, ElementsAccessor, Bootstrapper, CallDescriptors, WasmEngine, ExternalReferenceTable).\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FlagList\",\n                \"Isolate\",\n                \"wasm::WasmEngine\",\n                \"base::OS\",\n                \"GetPlatformPageAllocator\",\n                \"GetPlatformVirtualAddressSpace\",\n                \"ThreadIsolation\",\n                \"GetCurrentPlatform\",\n                \"Sandbox\",\n                \"perfetto::Tracing\",\n                \"TrackEvent\",\n                \"IsolateGroup\",\n                \"Simulator\",\n                \"CpuFeatures\",\n                \"ElementsAccessor\",\n                \"Bootstrapper\",\n                \"CallDescriptors\",\n                \"ExternalReferenceTable\",\n                \"v8_flags\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid V8::Initialize() {\n  AdvanceStartupState(V8StartupState::kV8Initializing);\n  CHECK(platform_);\n\n  FlagList::EnforceFlagImplications();\n\n  // Initialize the default FlagList::Hash.\n  FlagList::Hash();\n\n  // Before initializing internals, freeze the flags such that further changes\n  // are not allowed. Global initialization of the Isolate or the WasmEngine\n  // already reads flags, so they should not be changed afterwards.\n  if (v8_flags.freeze_flags_after_init) FlagList::FreezeFlags();\n\n  if (v8_flags.trace_turbo) {\n    // Create an empty file shared by the process (e.g. the wasm engine).\n    std::ofstream(Isolate::GetTurboCfgFileName(nullptr).c_str(),\n                  std::ios_base::trunc);\n  }\n\n  // The --jitless and --interpreted-frames-native-stack flags are incompatible\n  // since the latter requires code generation while the former prohibits code\n  // generation.\n  CHECK(!v8_flags.interpreted_frames_native_stack || !v8_flags.jitless);\n\n  base::AbortMode abort_mode = base::AbortMode::kDefault;\n\n  if (v8_flags.sandbox_fuzzing || v8_flags.hole_fuzzing) {\n    // In this mode, controlled crashes are harmless. Furthermore, DCHECK\n    // failures should be ignored (and execution should continue past them) as\n    // they may otherwise hide issues.\n    abort_mode = base::AbortMode::kExitWithFailureAndIgnoreDcheckFailures;\n  } else if (v8_flags.sandbox_testing) {\n    // Similar to the above case, but here we want to exit with a status\n    // indicating success (e.g. zero on unix). This is useful for example for\n    // sandbox regression tests, which should \"pass\" if they crash in a\n    // controlled fashion (e.g. in a SBXCHECK).\n    abort_mode = base::AbortMode::kExitWithSuccessAndIgnoreDcheckFailures;\n  } else if (v8_flags.hard_abort) {\n    abort_mode = base::AbortMode::kImmediateCrash;\n  }\n\n  base::OS::Initialize(abort_mode, v8_flags.gc_fake_mmap);\n\n  if (v8_flags.random_seed) {\n    GetPlatformPageAllocator()->SetRandomMmapSeed(v8_flags.random_seed);\n    GetPlatformVirtualAddressSpace()->SetRandomSeed(v8_flags.random_seed);\n  }\n\n  if (v8_flags.print_flag_values) FlagList::PrintValues();\n\n  // Fetch the ThreadIsolatedAllocator once since we need to keep the pointer in\n  // protected memory.\n  ThreadIsolation::Initialize(\n      GetCurrentPlatform()->GetThreadIsolatedAllocator());\n\n#ifdef V8_ENABLE_SANDBOX\n  // If enabled, the sandbox must be initialized first.\n  Sandbox::InitializeDefaultOncePerProcess(GetPlatformVirtualAddressSpace());\n  CHECK_EQ(kSandboxSize, Sandbox::current()->size());\n\n  // Enable sandbox testing mode if requested.\n  //\n  // This will install the sandbox crash filter to ignore all crashes that do\n  // not represent sandbox violations.\n  //\n  // Note: this should happen before the Wasm trap handler is installed, so that\n  // the wasm trap handler is invoked first (and can handle Wasm OOB accesses),\n  // then forwards all \"real\" crashes to the sandbox crash filter.\n  if (v8_flags.sandbox_testing || v8_flags.sandbox_fuzzing) {\n    SandboxTesting::Mode mode = v8_flags.sandbox_testing\n                                    ? SandboxTesting::Mode::kForTesting\n                                    : SandboxTesting::Mode::kForFuzzing;\n    SandboxTesting::Enable(mode);\n  }\n#endif  // V8_ENABLE_SANDBOX\n\n#if defined(V8_USE_PERFETTO)\n  if (perfetto::Tracing::IsInitialized()) {\n    TrackEvent::Register();\n    if (v8_flags.perfetto_code_logger) {\n      v8::internal::CodeDataSource::Register();\n    }\n  }\n#endif\n  IsolateGroup::InitializeOncePerProcess();\n  Isolate::InitializeOncePerProcess();\n\n#if defined(USE_SIMULATOR)\n  Simulator::InitializeOncePerProcess();\n#endif\n  CpuFeatures::Probe(false);\n  ElementsAccessor::InitializeOncePerProcess();\n  Bootstrapper::InitializeOncePerProcess();\n  CallDescriptors::InitializeOncePerProcess();\n\n#if V8_ENABLE_WEBASSEMBLY\n  wasm::WasmEngine::InitializeOncePerProcess();\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n  ExternalReferenceTable::InitializeOncePerIsolateGroup(\n      IsolateGroup::current()->external_ref_table());\n  AdvanceStartupState(V8StartupState::kV8Initialized);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Dispose\",\n            \"parent\": \"V8\",\n            \"about\": \"Disposes of the V8 engine.\",\n            \"logic\": \"Tears down various V8 components (WasmEngine, Simulator, CallDescriptors, ElementsAccessor, RegisteredExtension, FlagList, IsolateGroup).\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"wasm::WasmEngine\",\n                \"Simulator\",\n                \"CallDescriptors\",\n                \"ElementsAccessor\",\n                \"RegisteredExtension\",\n                \"FlagList\",\n                \"IsolateGroup\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid V8::Dispose() {\n  AdvanceStartupState(V8StartupState::kV8Disposing);\n  CHECK(platform_);\n#if V8_ENABLE_WEBASSEMBLY\n  wasm::WasmEngine::GlobalTearDown();\n#endif  // V8_ENABLE_WEBASSEMBLY\n#if defined(USE_SIMULATOR)\n  Simulator::GlobalTearDown();\n#endif\n  CallDescriptors::TearDown();\n  ElementsAccessor::TearDown();\n  RegisteredExtension::UnregisterAll();\n  FlagList::ReleaseDynamicAllocations();\n  IsolateGroup::TearDownOncePerProcess();\n  AdvanceStartupState(V8StartupState::kV8Disposed);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DisposePlatform\",\n            \"parent\": \"V8\",\n            \"about\": \"Disposes of the V8 platform.\",\n            \"logic\": \"Tears down platform-specific components (ETW, tracing, sets print stack trace to null, Sandbox).\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8_flags\",\n                \"ETWJITInterface\",\n                \"v8::tracing::TracingCategoryObserver\",\n                \"v8::base::SetPrintStackTrace\",\n                \"Sandbox\",\n                \"ThreadIsolation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid V8::DisposePlatform() {\n  AdvanceStartupState(V8StartupState::kPlatformDisposing);\n  CHECK(platform_);\n#if defined(V8_OS_WIN) && defined(V8_ENABLE_ETW_STACK_WALKING)\n  if (v8_flags.enable_etw_stack_walking ||\n      v8_flags.enable_etw_by_custom_filter_only) {\n    v8::internal::ETWJITInterface::Unregister();\n  }\n#endif\n  v8::tracing::TracingCategoryObserver::TearDown();\n  v8::base::SetPrintStackTrace(nullptr);\n\n#ifdef V8_ENABLE_SANDBOX\n  Sandbox::TearDownDefault();\n#endif  // V8_ENABLE_SANDBOX\n\n  platform_ = nullptr;\n\n#if DEBUG\n  internal::ThreadIsolation::CheckTrackedMemoryEmpty();\n#endif\n\n  AdvanceStartupState(V8StartupState::kPlatformDisposed);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetCurrentPlatform\",\n            \"parent\": \"V8\",\n            \"about\": \"Gets the current V8 platform.\",\n            \"logic\": \"Loads the platform pointer using relaxed atomic operations.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"v8::Platform*\",\n                \"description\": \"The current V8 platform.\"\n            },\n            \"dependencies\": [\n                \"v8::Platform\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nv8::Platform* V8::GetCurrentPlatform() {\n  v8::Platform* platform = reinterpret_cast<v8::Platform*>(\n      base::Relaxed_Load(reinterpret_cast<base::AtomicWord*>(&platform_)));\n  DCHECK(platform);\n  return platform;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetPlatformForTesting\",\n            \"parent\": \"V8\",\n            \"about\": \"Sets the V8 platform for testing purposes.\",\n            \"logic\": \"Stores the platform pointer using relaxed atomic operations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"platform\",\n                    \"type\": \"v8::Platform*\",\n                    \"purpose\": \"The platform implementation to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8::Platform\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid V8::SetPlatformForTesting(v8::Platform* platform) {\n  base::Relaxed_Store(reinterpret_cast<base::AtomicWord*>(&platform_),\n                      reinterpret_cast<base::AtomicWord>(platform));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetSnapshotBlob\",\n            \"parent\": \"V8\",\n            \"about\": \"Sets the snapshot blob for V8.\",\n            \"logic\": \"Calls SetSnapshotFromFile once using base::CallOnce.\",\n            \"parameters\": [\n                {\n                    \"name\": \"snapshot_blob\",\n                    \"type\": \"StartupData*\",\n                    \"purpose\": \"The snapshot blob to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StartupData\",\n                \"base::CallOnce\",\n                \"SetSnapshotFromFile\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid V8::SetSnapshotBlob(StartupData* snapshot_blob) {\n#ifdef V8_USE_EXTERNAL_STARTUP_DATA\n  base::CallOnce(&init_snapshot_once, &SetSnapshotFromFile, snapshot_blob);\n#else\n  UNREACHABLE();\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SystemClockTimeMillis\",\n            \"parent\": \"Platform\",\n            \"about\": \"Returns the current system clock time in milliseconds.\",\n            \"logic\": \"Calls base::OS::TimeCurrentMillis().\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"double\",\n                \"description\": \"The current system clock time in milliseconds.\"\n            },\n            \"dependencies\": [\n                \"base::OS\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\ndouble Platform::SystemClockTimeMillis() {\n  return base::OS::TimeCurrentMillis();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetDefaultPermissionsForSignalHandler\",\n            \"parent\": \"ThreadIsolatedAllocator\",\n            \"about\": \"Sets default permissions for the signal handler.\",\n            \"logic\": \"Calls RwxMemoryWriteScope::SetDefaultPermissionsForSignalHandler and SandboxHardwareSupport::SetDefaultPermissionsForSignalHandler.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"RwxMemoryWriteScope\",\n                \"SandboxHardwareSupport\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid ThreadIsolatedAllocator::SetDefaultPermissionsForSignalHandler() {\n#if V8_HAS_PKU_JIT_WRITE_PROTECT\n  internal::RwxMemoryWriteScope::SetDefaultPermissionsForSignalHandler();\n#endif\n  // TODO(sroettger): this could move to a more generic\n  // SecurityHardwareSupport::SetDefaultPermissionsForSignalHandler.\n  internal::SandboxHardwareSupport::SetDefaultPermissionsForSignalHandler();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeBeforeThreadCreation\",\n            \"parent\": \"SandboxHardwareSupport\",\n            \"about\": \"Initializes the sandbox hardware support before thread creation.\",\n            \"logic\": \"Calls internal::SandboxHardwareSupport::InitializeBeforeThreadCreation().\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"SandboxHardwareSupport\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid SandboxHardwareSupport::InitializeBeforeThreadCreation() {\n  internal::SandboxHardwareSupport::InitializeBeforeThreadCreation();\n}\n        ]]></code>\n    </func>\n    <"
}