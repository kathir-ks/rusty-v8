{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/frames.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/frames.cc\",\n        \"file_name\": \"frames.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides classes and functions for stack frame management within the V8 JavaScript engine, including iteration, summarization, and access to frame data.  Supports various frame types including JavaScript, WASM, and native frames.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for stack frame manipulation, data structures, and platform-specific features.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/frames.h\"\n\n#include <cstdint>\n#include <memory>\n#include <optional>\n#include <sstream>\n\n#include \"src/api/api-arguments.h\"\n#include \"src/api/api-natives.h\"\n#include \"src/base/bits.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/codegen/linkage-location.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/codegen/maglev-safepoint-table.h\"\n#include \"src/codegen/register-configuration.h\"\n#include \"src/codegen/safepoint-table.h\"\n#include \"src/common/globals.h\"\n#include \"src/deoptimizer/deoptimizer.h\"\n#include \"src/execution/arguments.h\"\n#include \"src/execution/frame-constants.h\"\n#include \"src/execution/frames-inl.h\"\n#include \"src/execution/vm-state-inl.h\"\n#include \"src/ic/ic-stats.h\"\n#include \"src/logging/counters.h\"\n#include \"src/objects/casting-inl.h\"\n#include \"src/objects/code.h\"\n#include \"src/objects/instance-type-checker.h\"\n#include \"src/objects/slots.h\"\n#include \"src/objects/smi.h\"\n#include \"src/objects/visitors.h\"\n#include \"src/roots/roots.h\"\n#include \"src/snapshot/embedded/embedded-data-inl.h\"\n#include \"src/strings/string-stream.h\"\n#include \"src/zone/zone-containers.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/debug/debug-wasm-objects.h\"\n#include \"src/wasm/stacks.h\"\n#include \"src/wasm/wasm-code-manager.h\"\n#include \"src/wasm/wasm-engine.h\"\n#include \"src/wasm/wasm-linkage.h\"\n#include \"src/wasm/wasm-objects-inl.h\"\n#if V8_ENABLE_DRUMBRAKE\n#include \"src/wasm/interpreter/wasm-interpreter-runtime.h\"\n#endif  // V8_ENABLE_DRUMBRAKE\n#endif  // V8_ENABLE_WEBASSEMBLY\n]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackFrame\",\n            \"about\": \"Base class for all stack frame types in V8. Provides common functionality like accessing return addresses, looking up code objects, and iterating over frames.\",\n            \"attributes\": [\n                {\n                    \"name\": \"return_address_location_resolver_\",\n                    \"type\": \"ReturnAddressLocationResolver\",\n                    \"access\": \"static\",\n                    \"purpose\": \"Function pointer for resolving the return address location.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nReturnAddressLocationResolver StackFrame::return_address_location_resolver_ =\n    nullptr;\n]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AddressOf\",\n            \"about\": \"Helper function to retrieve the actual address of a StackHandler, accounting for ASan's shadow stack.\",\n            \"logic\": \"If ASan is enabled, the function checks for padding in the StackHandler metadata to determine the real stack address. Otherwise, it returns the raw handler address.\",\n            \"parameters\": [\n                {\n                    \"name\": \"handler\",\n                    \"type\": \"const StackHandler*\",\n                    \"purpose\": \"Pointer to the StackHandler whose address needs to be determined.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Address\",\n                \"description\": \"The actual address of the StackHandler.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nAddress AddressOf(const StackHandler* handler) {\n  Address raw = handler->address();\n#ifdef V8_USE_ADDRESS_SANITIZER\n  // ASan puts C++-allocated StackHandler markers onto its fake stack.\n  // We work around that by storing the real stack address in the \"padding\"\n  // field. StackHandlers allocated from generated code have 0 as padding.\n  Address padding =\n      base::Memory<Address>(raw + StackHandlerConstants::kPaddingOffset);\n  if (padding != 0) return padding;\n#endif\n  return raw;\n}\n\n}  // namespace\n]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackHandlerIterator\",\n            \"about\": \"Iterator for traversing the stack handlers of a particular stack frame.\",\n            \"attributes\": [\n                {\n                    \"name\": \"limit_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The upper bound (address) of the frame being iterated.\"\n                },\n                {\n                    \"name\": \"handler_\",\n                    \"type\": \"StackHandler*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current StackHandler in the iteration.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n// Iterator that supports traversing the stack handlers of a\n// particular frame. Needs to know the top of the handler chain.\nclass StackHandlerIterator {\n public:\n  StackHandlerIterator(const StackFrame* frame, StackHandler* handler)\n      : limit_(frame->fp()), handler_(handler) {\n#if V8_ENABLE_WEBASSEMBLY\n#if !V8_ENABLE_DRUMBRAKE && !USE_SIMULATOR\n    // Make sure the handler has already been unwound to this frame. With stack\n    // switching this is not equivalent to the inequality below, because the\n    // frame and the handler could be in different stacks.\n    DCHECK_IMPLIES(frame->isolate()->wasm_stacks().empty(),\n                   frame->InFastCCall() || frame->sp() <= AddressOf(handler));\n#endif  // !V8_ENABLE_DRUMBRAKE || !USE_SIMULATOR\n\n    // For CWasmEntry frames, the handler was registered by the last C++\n    // frame (Execution::CallWasm), so even though its address is already\n    // beyond the limit, we know we always want to unwind one handler.\n    if (frame->is_c_wasm_entry()) {\n      handler_ = handler_->next();\n#if V8_ENABLE_DRUMBRAKE\n    // Do the same for GenericWasmToJsInterpreterWrapper frames.\n    } else if (v8_flags.wasm_jitless && frame->is_wasm_to_js()) {\n      handler_ = handler_->next();\n#ifdef USE_SIMULATOR\n      // If we are running in the simulator, the handler_ address here will\n      // refer to the 'actual' stack, not to the 'simulated' stack, so we need\n      // to fix 'limit_' to make sure that the StackHandlerIterator won't skip\n      // any handler.\n      limit_ = 0;\n#endif  // USE_SIMULATOR\n#endif  // V8_ENABLE_DRUMBRAKE\n    }\n#else\n    // Make sure the handler has already been unwound to this frame.\n    DCHECK_LE(frame->sp(), AddressOf(handler));\n#endif  // V8_ENABLE_WEBASSEMBLY\n  }\n\n  StackHandler* handler() const { return handler_; }\n\n  bool done() { return handler_ == nullptr || AddressOf(handler_) > limit_; }\n  void Advance() {\n    DCHECK(!done());\n    handler_ = handler_->next();\n  }\n\n private:\n#if V8_ENABLE_DRUMBRAKE && USE_SIMULATOR\n  Address limit_;\n#else\n  const Address limit_;\n#endif  // V8_ENABLE_DRUMBRAKE && USE_SIMULATOR\n\n  StackHandler* handler_;\n};\n]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackFrameIteratorBase\",\n            \"about\": \"Base class for stack frame iterators, providing common functionality like accessing the isolate and current frame.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Pointer to the isolate.\"\n                },\n                {\n                    \"name\": \"frame_\",\n                    \"type\": \"StackFrame*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Pointer to the current stack frame.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n// -------------------------------------------------------------------------\n\nStackFrameIteratorBase::StackFrameIteratorBase(Isolate* isolate)\n    : isolate_(isolate), frame_(nullptr), handler_(nullptr) {}\n]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackFrameIterator\",\n            \"extends\": \"StackFrameIteratorBase\",\n            \"about\": \"Concrete stack frame iterator class used to traverse the stack frames.\",\n            \"attributes\": [\n                {\n                    \"name\": \"handler_\",\n                    \"type\": \"StackHandler*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current stack handler being processed.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nStackFrameIterator::StackFrameIterator(Isolate* isolate)\n    : StackFrameIterator(isolate, isolate->thread_local_top()) {}\n\nStackFrameIterator::StackFrameIterator(Isolate* isolate, ThreadLocalTop* t)\n    : StackFrameIteratorBase(isolate) {\n  Reset(t);\n}\n\n#if V8_ENABLE_WEBASSEMBLY\nStackFrameIterator::StackFrameIterator(Isolate* isolate, ThreadLocalTop* t,\n                                       NoHandles)\n    : StackFrameIteratorBase(isolate) {\n  no_gc_.emplace();\n  Reset(t);\n}\n\nStackFrameIterator::StackFrameIterator(Isolate* isolate, ThreadLocalTop* t,\n                                       FirstStackOnly)\n    : StackFrameIteratorBase(isolate) {\n  first_stack_only_ = true;\n  Reset(t);\n}\n\nStackFrameIterator::StackFrameIterator(Isolate* isolate,\n                                       wasm::StackMemory* stack)\n    : StackFrameIteratorBase(isolate) {\n  first_stack_only_ = true;\n  Reset(isolate->thread_local_top(), stack);\n}\n#else\nStackFrameIterator::StackFrameIterator(Isolate* isolate, ThreadLocalTop* t,\n                                       NoHandles)\n    : StackFrameIteratorBase(isolate) {\n  Reset(t);\n}\n#endif\n\nvoid StackFrameIterator::Advance() {\n  DCHECK(!done());\n  // Compute the state of the calling frame before restoring\n  // callee-saved registers and unwinding handlers. This allows the\n  // frame code that computes the caller state to access the top\n  // handler and the value of any callee-saved register if needed.\n  StackFrame::State state;\n  StackFrame::Type type;\n#if V8_ENABLE_WEBASSEMBLY\n  if (frame_->type() == StackFrame::STACK_SWITCH &&\n      Memory<Address>(frame_->fp() +\n                      StackSwitchFrameConstants::kCallerFPOffset) ==\n          kNullAddress &&\n      !first_stack_only_) {\n    // Handle stack switches here.\n    // Note: both the \"callee\" frame (outermost frame of the child stack) and\n    // the \"caller\" frame (top frame of the parent stack) have frame type\n    // STACK_SWITCH. We use the caller FP to distinguish them: the callee frame\n    // does not have a caller fp.\n    auto parent = continuation()->parent();\n    CHECK(!IsUndefined(parent));\n    set_continuation(\n        GCSafeCast<WasmContinuationObject>(parent, isolate_->heap()));\n    wasm_stack_ = reinterpret_cast<wasm::StackMemory*>(continuation()->stack());\n    CHECK_EQ(wasm_stack_->jmpbuf()->state, wasm::JumpBuffer::Inactive);\n    StackSwitchFrame::GetStateForJumpBuffer(wasm_stack_->jmpbuf(), &state);\n    SetNewFrame(StackFrame::STACK_SWITCH, &state);\n    return;\n  }\n#endif\n  type = frame_->GetCallerState(&state);\n\n  // {StackHandlerIterator} assumes that frame pointers strictly go from lower\n  // to higher addresses as we iterate the stack. This breaks with\n  // stack-switching, so only unwind the stack handlers for frames that are\n  // known to use them.\n  if (frame_->type() == StackFrame::ENTRY ||\n      frame_->type() == StackFrame::CONSTRUCT_ENTRY\n#if V8_ENABLE_WEBASSEMBLY\n      || frame_->type() == StackFrame::C_WASM_ENTRY\n#endif\n  ) {\n    StackHandlerIterator it(frame_, handler_);\n    while (!it.done()) it.Advance();\n    handler_ = it.handler();\n  }\n\n  // Advance to the calling frame.\n  SetNewFrame(type, &state);\n  // When we're done iterating over the stack frames, the handler\n  // chain must have been completely unwound. Except if we are only iterating\n  // the first stack of the chain for wasm stack-switching.\n#if V8_ENABLE_WEBASSEMBLY\n  DCHECK_IMPLIES(done() && !first_stack_only_, handler_ == nullptr);\n#else\n  DCHECK_IMPLIES(done(), handler_ == nullptr);\n#endif\n}\n\nStackFrame* StackFrameIterator::Reframe() {\n  StackFrame::State state = frame_->state_;\n  StackFrame::Type type = ComputeStackFrameType(&state);\n  SetNewFrame(type, &state);\n  return frame();\n}\n\nnamespace {\nStackFrame::Type GetStateForFastCCallCallerFP(Isolate* isolate, Address fp,\n                                              Address pc, Address pc_address,\n                                              StackFrame::State* state) {\n  // 'Fast C calls' are a special type of C call where we call directly from\n  // JS to C without an exit frame in between. The CEntryStub is responsible\n  // for setting Isolate::c_entry_fp, meaning that it won't be set for fast C\n  // calls. To keep the stack iterable, we store the FP and PC of the caller\n  // of the fast C call on the isolate. This is guaranteed to be the topmost\n  // JS frame, because fast C calls cannot call back into JS. We start\n  // iterating the stack from this topmost JS frame.\n  DCHECK_NE(kNullAddress, pc);\n  state->fp = fp;\n  state->sp = kNullAddress;\n  state->pc_address = reinterpret_cast<Address*>(pc_address);\n  state->callee_pc = kNullAddress;\n  state->constant_pool_address = nullptr;\n#if V8_ENABLE_WEBASSEMBLY\n  if (wasm::WasmCode* code =\n          wasm::GetWasmCodeManager()->LookupCode(isolate, pc)) {\n    if (code->kind() == wasm::WasmCode::kWasmToJsWrapper) {\n      return StackFrame::WASM_TO_JS;\n    }\n    DCHECK_EQ(code->kind(), wasm::WasmCode::kWasmFunction);\n    return StackFrame::WASM;\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY\n  return StackFrame::TURBOFAN_JS;\n}\n}  // namespace\n\nvoid StackFrameIterator::Reset(ThreadLocalTop* top) {\n  StackFrame::State state;\n  StackFrame::Type type;\n\n  const Address fast_c_call_caller_fp =\n      isolate_->isolate_data()->fast_c_call_caller_fp();\n  if (fast_c_call_caller_fp != kNullAddress) {\n    const Address caller_pc = isolate_->isolate_data()->fast_c_call_caller_pc();\n    const Address caller_pc_address =\n        isolate_->isolate_data()->fast_c_call_caller_pc_address();\n    type = GetStateForFastCCallCallerFP(isolate_, fast_c_call_caller_fp,\n                                        caller_pc, caller_pc_address, &state);\n  } else {\n    type = ExitFrame::GetStateForFramePointer(Isolate::c_entry_fp(top), &state);\n  }\n#if V8_ENABLE_WEBASSEMBLY\n  auto active_continuation = isolate_->root(RootIndex::kActiveContinuation);\n  if (!IsUndefined(active_continuation, isolate_)) {\n    auto continuation = GCSafeCast<WasmContinuationObject>(active_continuation,\n                                                           isolate_->heap());\n    if (!first_stack_only_) {\n      set_continuation(continuation);\n    }\n    wasm_stack_ = reinterpret_cast<wasm::StackMemory*>(continuation->stack());\n  }\n#endif\n  handler_ = StackHandler::FromAddress(Isolate::handler(top));\n  SetNewFrame(type, &state);\n}\n\n#if V8_ENABLE_WEBASSEMBLY\nvoid StackFrameIterator::Reset(ThreadLocalTop* top, wasm::StackMemory* stack) {\n  if (stack->jmpbuf()->state == wasm::JumpBuffer::Retired) {\n    return;\n  }\n  StackFrame::State state;\n  StackSwitchFrame::GetStateForJumpBuffer(stack->jmpbuf(), &state);\n  handler_ = StackHandler::FromAddress(Isolate::handler(top));\n  wasm_stack_ = stack;\n  SetNewFrame(StackFrame::STACK_SWITCH, &state);\n}\n#endif\n\nvoid StackFrameIteratorBase::SetNewFrame(StackFrame::Type type,\n                                         StackFrame::State* state) {\n  SetNewFrame(type);\n  DCHECK_EQ(!frame_, type == StackFrame::NO_FRAME_TYPE);\n  if (frame_) frame_->state_ = *state;\n}\n\nvoid StackFrameIteratorBase::SetNewFrame(StackFrame::Type type) {\n  switch (type) {\n#define FRAME_TYPE_CASE(type, class)      \\\n  case StackFrame::type:                  \\\n    frame_ = new (&class##_) class(this); \\\n    return;\n    STACK_FRAME_TYPE_LIST(FRAME_TYPE_CASE)\n#undef FRAME_TYPE_CASE\n\n    case StackFrame::NO_FRAME_TYPE:\n    // We don't expect to see NUMBER_OF_TYPES or MANUAL, but stay robust against\n    // them rather than being UNREACHABLE in case stack frame iteration gets\n    // wonky.\n    case StackFrame::NUMBER_OF_TYPES:\n    case StackFrame::MANUAL:\n      break;\n  }\n  frame_ = nullptr;\n}\n\n#if V8_ENABLE_WEBASSEMBLY\nTagged<WasmContinuationObject> StackFrameIterator::continuation() {\n  return no_gc_.has_value() ? continuation_.obj_ : *continuation_.handle_;\n}\n\nvoid StackFrameIterator::set_continuation(\n    Tagged<WasmContinuationObject> continuation) {\n  if (no_gc_.has_value()) {\n    continuation_.obj_ = continuation;\n  } else {\n    continuation_.handle_ = handle(continuation, isolate_);\n  }\n}\n#endif\n]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetStateForFastCCallCallerFP\",\n            \"about\": \"Helper function for retrieving the stack frame state for a fast C call's caller frame.\",\n            \"logic\": \"Populates the provided 'state' structure with the frame pointer, stack pointer, and program counter information for the calling JS frame in a fast C call scenario.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"Pointer to the current Isolate.\"\n                },\n                {\n                    \"name\": \"fp\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The frame pointer of the caller frame.\"\n                },\n                {\n                    \"name\": \"pc\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The program counter of the caller frame.\"\n                },\n                {\n                    \"name\": \"pc_address\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The address of the program counter.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"StackFrame::State*\",\n                    \"purpose\": \"Pointer to a StackFrame::State structure to be populated.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"StackFrame::Type\",\n                \"description\": \"The type of stack frame (TURBOFAN_JS or WASM).\"\n            },\n            \"dependencies\": [\n                \"wasm::WasmCode\",\n                \"wasm::GetWasmCodeManager\",\n                \"StackFrame::WASM_TO_JS\",\n                \"StackFrame::WASM\",\n                \"StackFrame::TURBOFAN_JS\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\nStackFrame::Type GetStateForFastCCallCallerFP(Isolate* isolate, Address fp,\n                                              Address pc, Address pc_address,\n                                              StackFrame::State* state) {\n  // 'Fast C calls' are a special type of C call where we call directly from\n  // JS to C without an exit frame in between. The CEntryStub is responsible\n  // for setting Isolate::c_entry_fp, meaning that it won't be set for fast C\n  // calls. To keep the stack iterable, we store the FP and PC of the caller\n  // of the fast C call on the isolate. This is guaranteed to be the topmost\n  // JS frame, because fast C calls cannot call back into JS. We start\n  // iterating the stack from this topmost JS frame.\n  DCHECK_NE(kNullAddress, pc);\n  state->fp = fp;\n  state->sp = kNullAddress;\n  state->pc_address = reinterpret_cast<Address*>(pc_address);\n  state->callee_pc = kNullAddress;\n  state->constant_pool_address = nullptr;\n#if V8_ENABLE_WEBASSEMBLY\n  if (wasm::WasmCode* code =\n          wasm::GetWasmCodeManager()->LookupCode(isolate, pc)) {\n    if (code->kind() == wasm::WasmCode::kWasmToJsWrapper) {\n      return StackFrame::WASM_TO_JS;\n    }\n    DCHECK_EQ(code->kind(), wasm::WasmCode::kWasmFunction);\n    return StackFrame::WASM;\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY\n  return StackFrame::TURBOFAN_JS;\n}\n}  // namespace\n]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JavaScriptStackFrameIterator\",\n            \"about\": \"An iterator that only returns JavaScript frames.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n// -------------------------------------------------------------------------\n\nvoid JavaScriptStackFrameIterator::Advance() {\n  do {\n    iterator_.Advance();\n  } while (!iterator_.done() && !iterator_.frame()->is_javascript());\n}\n]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DebuggableStackFrameIterator\",\n            \"about\": \"A stack frame iterator that only returns frames that are valid for debugging.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n// -------------------------------------------------------------------------\n\nDebuggableStackFrameIterator::DebuggableStackFrameIterator(Isolate* isolate)\n    : iterator_(isolate) {\n  if (!done() && !IsValidFrame(iterator_.frame())) Advance();\n}\n\nDebuggableStackFrameIterator::DebuggableStackFrameIterator(Isolate* isolate,\n                                                           StackFrameId id)\n    : DebuggableStackFrameIterator(isolate) {\n  while (!done() && frame()->id() != id) Advance();\n}\n\nDebuggableStackFrameIterator::DebuggableStackFrameIterator(\n    Isolate* isolate, StackFrameIterator::NoHandles)\n    : iterator_(isolate, isolate->thread_local_top(),\n                StackFrameIterator::NoHandles{}) {\n  if (!done() && !IsValidFrame(iterator_.frame())) Advance();\n}\n\nDebuggableStackFrameIterator::DebuggableStackFrameIterator(\n    Isolate* isolate, StackFrameId id, StackFrameIterator::NoHandles)\n    : DebuggableStackFrameIterator(isolate, StackFrameIterator::NoHandles{}) {\n  while (!done() && frame()->id() != id) Advance();\n}\n\nvoid DebuggableStackFrameIterator::Advance() {\n  do {\n    iterator_.Advance();\n  } while (!done() && !IsValidFrame(iterator_.frame()));\n}\n\nint DebuggableStackFrameIterator::FrameFunctionCount() const {\n  DCHECK(!done());\n  if (!iterator_.frame()->is_optimized_js()) return 1;\n  std::vector<Tagged<SharedFunctionInfo>> infos;\n  TurbofanJSFrame::cast(iterator_.frame())->GetFunctions(&infos);\n  return static_cast<int>(infos.size());\n}\n\nFrameSummary DebuggableStackFrameIterator::GetTopValidFrame() const {\n  DCHECK(!done());\n  // Like FrameSummary::GetTop, but additionally observes\n  // DebuggableStackFrameIterator filtering semantics.\n  FrameSummaries summaries = frame()->Summarize();\n  if (is_javascript()) {\n    for (int i = summaries.size() - 1; i >= 0; i--) {\n      const FrameSummary& summary = summaries.frames[i];\n      if (summary.is_subject_to_debugging()) {\n        return summary;\n      }\n    }\n    UNREACHABLE();\n  }\n#if V8_ENABLE_WEBASSEMBLY\n  if (is_wasm()) return summaries.frames.back();\n#endif  // V8_ENABLE_WEBASSEMBLY\n  UNREACHABLE();\n}\n\n// static\nbool DebuggableStackFrameIterator::IsValidFrame(StackFrame* frame) {\n  if (frame->is_javascript()) {\n    Tagged<JSFunction> function =\n        static_cast<JavaScriptFrame*>(frame)->function();\n    return function->shared()->IsSubjectToDebugging();\n  }\n#if V8_ENABLE_WEBASSEMBLY\n  if (frame->is_wasm()) return true;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  return false;\n}\n]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsInterpreterFramePc\",\n            \"about\": \"Checks if a given program counter (PC) belongs to an interpreter frame.\",\n            \"logic\": \"Determines if the PC points to an interpreter trampoline or bytecode handler by looking up builtins and inspecting the frame type marker.  Also has fallbacks for architectures where inline stacktraces are impossible.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"pc\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The program counter address.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"StackFrame::State*\",\n                    \"purpose\": \"The state of the current stack frame.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<bool>\",\n                \"description\": \"An optional boolean indicating whether the PC belongs to an interpreter frame.  Returns std::nullopt if the lookup cannot be completed in the current state.\"\n            },\n            \"dependencies\": [\n                \"Builtin\",\n                \"OffHeapInstructionStream\",\n                \"Isolate\",\n                \"StackFrame\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nstd::optional<bool> IsInterpreterFramePc(Isolate* isolate, Address pc,\n                                         StackFrame::State* state) {\n  Builtin builtin = OffHeapInstructionStream::TryLookupCode(isolate, pc);\n  if (builtin != Builtin::kNoBuiltinId &&\n      (builtin == Builtin::kInterpreterEntryTrampoline ||\n       builtin == Builtin::kInterpreterEnterAtBytecode ||\n       builtin == Builtin::kInterpreterEnterAtNextBytecode)) {\n    return true;\n  } else if (isolate->interpreted_frames_native_stack()) {\n    intptr_t marker = Memory<intptr_t>(\n        state->fp + CommonFrameConstants::kContextOrFrameTypeOffset);\n    MSAN_MEMORY_IS_INITIALIZED(\n        state->fp + StandardFrameConstants::kFunctionOffset,\n        kSystemPointerSize);\n    Tagged<Object> maybe_function = Tagged<Object>(\n        Memory<Address>(state->fp + StandardFrameConstants::kFunctionOffset));\n    // There's no need to run a full ContainsSlow if we know the frame can't be\n    // an InterpretedFrame,  so we do these fast checks first\n    if (StackFrame::IsTypeMarker(marker) || IsSmi(maybe_function)) {\n      return false;\n    } else if (!isolate->heap()->InSpaceSlow(pc, CODE_SPACE)) {\n      return false;\n    }\n    if (!ThreadIsolation::CanLookupStartOfJitAllocationAt(pc)) {\n      return {};\n    }\n    Tagged<Code> interpreter_entry_trampoline =\n        isolate->heap()->FindCodeForInnerPointer(pc);\n    return interpreter_entry_trampoline->is_interpreter_trampoline_builtin();\n  } else {\n    return false;\n  }\n}\n\n}  // namespace\n]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsNoFrameBytecodeHandlerPc\",\n            \"about\": \"Determines if a PC address is inside a no-frame bytecode handler.\",\n            \"logic\": \"Checks if the provided address is within the bytecode handler range and that a frame has not been built by checking the frame type marker.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"pc\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The program counter address.\"\n                },\n                {\n                    \"name\": \"fp\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The frame pointer address.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the PC is in a no-frame bytecode handler, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"EmbeddedData\",\n                \"StackFrame\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool StackFrameIteratorForProfiler::IsNoFrameBytecodeHandlerPc(\n    Isolate* isolate, Address pc, Address fp) const {\n  EmbeddedData d = EmbeddedData::FromBlob(isolate);\n  if (pc < d.InstructionStartOfBytecodeHandlers() ||\n      pc >= d.InstructionEndOfBytecodeHandlers()) {\n    return false;\n  }\n\n  Address frame_type_address =\n      fp + CommonFrameConstants::kContextOrFrameTypeOffset;\n  if (!IsValidStackAddress(frame_type_address)) {\n    return false;\n  }\n\n  // Check if top stack frame is a bytecode handler stub frame.\n  MSAN_MEMORY_IS_INITIALIZED(frame_type_address, kSystemPointerSize);\n  intptr_t marker = Memory<intptr_t>(frame_type_address);\n  if (StackFrame::IsTypeMarker(marker) &&\n      StackFrame::MarkerToType(marker) == StackFrame::STUB) {\n    // Bytecode handler built a frame.\n    return false;\n  }\n  return true;\n}\n]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackFrameIteratorForProfiler\",\n            \"extends\": \"StackFrameIteratorBase\",\n            \"about\": \"Specialized stack frame iterator for use within the profiler.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nStackFrameIteratorForProfiler::StackFrameIteratorForProfiler(\n    Isolate* isolate, Address pc, Address fp, Address sp, Address lr,\n    Address js_entry_sp)\n    : StackFrameIteratorBase(isolate),\n      low_bound_(sp),\n      high_bound_(js_entry_sp),\n      top_frame_type_(StackFrame::NO_FRAME_TYPE),\n      external_callback_scope_(isolate->external_callback_scope()),\n      top_link_register_(lr)\n#if V8_ENABLE_WEBASSEMBLY\n      ,\n      wasm_stacks_(isolate->wasm_stacks())\n#endif\n{\n  if (!isolate->isolate_data()->stack_is_iterable()) {\n    // The stack is not iterable in a short time interval during deoptimization.\n    // See also: ExternalReference::stack_is_iterable_address.\n    DCHECK(done());\n    return"
}