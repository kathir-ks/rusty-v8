{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-shuffle-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 46, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-shuffle-reducer.h\",\n            \"file_name\": \"wasm-shuffle-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines classes and logic for reducing the size of Simd128Shuffle operations in the Turboshaft compiler for WebAssembly, optimizing shuffle operations based on how their results are used.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for optional values, template utilities, built-in functions, Turboshaft compiler components (assembler, operations, opmasks, phases, utilities), and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/template-utils.h\"\n#include \"src/builtins/builtins.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/utils.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DemandedElementAnalysis\",\n                \"about\": \"Analyzes the demanded elements of shuffle operations by tracing back from uses to definitions. Determines which lanes of a Simd128 shuffle are actually required by subsequent operations, enabling potential reductions in shuffle size.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"phase_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The zone allocator for the current compilation phase.\"\n                    },\n                    {\n                        \"name\": \"input_graph_\",\n                        \"type\": \"const Graph&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A reference to the input graph being analyzed.\"\n                    },\n                    {\n                        \"name\": \"demanded_elements_\",\n                        \"type\": \"DemandedElementMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map from Operation* to a LaneBitSet indicating the demanded lanes for that operation.\"\n                    },\n                    {\n                        \"name\": \"visited_\",\n                        \"type\": \"ZoneUnorderedSet<const Operation*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of visited operations during the analysis to prevent infinite loops.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Operation\",\n                    \"Simd128UnaryOp\",\n                    \"Simd128BinopOp\",\n                    \"Graph\",\n                    \"Zone\",\n                    \"ZoneVector\",\n                    \"std::pair\",\n                    \"LaneBitSet\",\n                    \"ZoneUnorderedSet\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass DemandedElementAnalysis {\n public:\n  static constexpr uint16_t k8x16 = 0xFFFF;\n  static constexpr uint16_t k8x8Low = 0xFF;\n  static constexpr uint16_t k8x4Low = 0xF;\n  static constexpr uint16_t k8x2Low = 0x3;\n\n  using LaneBitSet = std::bitset<16>;\n  using DemandedElementMap =\n      ZoneVector<std::pair<const Operation*, LaneBitSet>>;\n\n  DemandedElementAnalysis(Zone* phase_zone, const Graph& input_graph)\n      : phase_zone_(phase_zone), input_graph_(input_graph) {}\n\n  void AddUnaryOp(const Simd128UnaryOp& unop, LaneBitSet lanes);\n  void AddBinaryOp(const Simd128BinopOp& binop, LaneBitSet lanes);\n  void RecordOp(const Operation* op, LaneBitSet lanes);\n\n  const DemandedElementMap& demanded_elements() const {\n    return demanded_elements_;\n  }\n\n  const Graph& input_graph() const { return input_graph_; }\n\n  bool Visited(const Operation* op) const { return visited_.count(op); }\n\n private:\n  Zone* phase_zone_;\n  const Graph& input_graph_;\n  DemandedElementMap demanded_elements_{phase_zone_};\n  ZoneUnorderedSet<const Operation*> visited_{phase_zone_};\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmShuffleAnalyzer\",\n                \"about\": \"Analyzes Simd128Shuffle operations to determine if they can be reduced. Uses DemandedElementAnalysis to identify which shuffle operations can be narrowed based on consumer demand, or if their inputs should be modified.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"phase_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The zone allocator for the current compilation phase.\"\n                    },\n                    {\n                        \"name\": \"input_graph_\",\n                        \"type\": \"const Graph&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A reference to the input graph being analyzed.\"\n                    },\n                    {\n                        \"name\": \"demanded_element_analysis\",\n                        \"type\": \"DemandedElementAnalysis\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An instance of DemandedElementAnalysis used to analyze demanded elements.\"\n                    },\n                    {\n                        \"name\": \"shift_shuffles_\",\n                        \"type\": \"SmallZoneVector<const Simd128ShuffleOp*, 8>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores shuffles that needs to be adjusted because its input has been narrowed.\"\n                    },\n                    {\n                        \"name\": \"low_half_shuffles_\",\n                        \"type\": \"SmallZoneVector<const Simd128ShuffleOp*, 8>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores shuffles where the low half result comes exclusively from the high half of its operands.\"\n                    },\n                    {\n                        \"name\": \"high_half_shuffles_\",\n                        \"type\": \"SmallZoneVector<const Simd128ShuffleOp*, 8>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores shuffles where the high half result comes exclusively from the high half of its operands.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Zone\",\n                    \"Graph\",\n                    \"Simd128ShuffleOp\",\n                    \"DemandedElementAnalysis\",\n                    \"SmallZoneVector\",\n                    \"Operation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass WasmShuffleAnalyzer {\n public:\n  WasmShuffleAnalyzer(Zone* phase_zone, const Graph& input_graph)\n      : phase_zone_(phase_zone), input_graph_(input_graph) {\n    Run();\n  }\n\n  V8_EXPORT_PRIVATE void Run();\n\n  void Process(const Operation& op);\n  void ProcessUnary(const Simd128UnaryOp& unop);\n  void ProcessBinary(const Simd128BinopOp& binop);\n  void ProcessShuffle(const Simd128ShuffleOp& shuffle_op);\n  void ProcessShuffleOfShuffle(const Simd128ShuffleOp& shuffle_op,\n                               const Simd128ShuffleOp& shuffle,\n                               uint8_t lower_limit, uint8_t upper_limit);\n  bool ShouldReduce() const {\n    return !demanded_element_analysis.demanded_elements().empty();\n  }\n\n  const DemandedElementAnalysis::DemandedElementMap& ops_to_reduce() const {\n    return demanded_element_analysis.demanded_elements();\n  }\n\n  std::optional<DemandedElementAnalysis::LaneBitSet> DemandedByteLanes(\n      const Operation* op) const {\n    for (auto const& [narrow_op, lanes] : ops_to_reduce()) {\n      if (op == narrow_op) {\n        return lanes;\n      }\n    }\n    return {};\n  }\n\n  // Is only the top half (lanes 8...15) of the result of shuffle required?\n  // If so shuffle will need to be modified so that it writes the designed data\n  // into the low half lanes instead.\n  bool ShouldRewriteShuffleToLow(const Simd128ShuffleOp* shuffle) const {\n    for (auto shift_shuffle : shift_shuffles_) {\n      if (shift_shuffle == shuffle) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n#ifdef DEBUG\n  bool ShouldRewriteShuffleToLow(OpIndex op) const {\n    return ShouldRewriteShuffleToLow(\n        &input_graph().Get(op).Cast<Simd128ShuffleOp>());\n  }\n#endif\n\n  // Is the low half (lanes 0...7) result of shuffle coming exclusively from\n  // the high half of one of its operands.\n  bool DoesShuffleIntoLowHalf(const Simd128ShuffleOp* shuffle) const {\n    for (auto half_shuffle : low_half_shuffles_) {\n      if (half_shuffle == shuffle) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Is the high half (lanes: 8...15) result of shuffle coming exclusively from\n  // the high half of its operands.\n  bool DoesShuffleIntoHighHalf(const Simd128ShuffleOp* shuffle) const {\n    for (auto half_shuffle : high_half_shuffles_) {\n      if (half_shuffle == shuffle) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  const Graph& input_graph() const { return input_graph_; }\n\n private:\n  Zone* phase_zone_;\n  const Graph& input_graph_;\n  DemandedElementAnalysis demanded_element_analysis{phase_zone_, input_graph_};\n  SmallZoneVector<const Simd128ShuffleOp*, 8> shift_shuffles_{phase_zone_};\n  SmallZoneVector<const Simd128ShuffleOp*, 8> low_half_shuffles_{phase_zone_};\n  SmallZoneVector<const Simd128ShuffleOp*, 8> high_half_shuffles_{phase_zone_};\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmShuffleReducer\",\n                \"extends\": \"Next\",\n                \"about\": \"A reducer class that uses WasmShuffleAnalyzer to reduce the size of Simd128Shuffle operations during Turboshaft compilation.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"analyzer_\",\n                        \"type\": \"std::optional<WasmShuffleAnalyzer>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An optional WasmShuffleAnalyzer instance used for analyzing shuffle operations.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Next\",\n                    \"WasmShuffleAnalyzer\",\n                    \"Simd128ShuffleOp\",\n                    \"OpIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass WasmShuffleReducer : public Next {\n private:\n  std::optional<WasmShuffleAnalyzer> analyzer_;\n\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(WasmShuffleReducer)\n\n  void Analyze() {\n    analyzer_.emplace(__ phase_zone(), __ input_graph());\n    analyzer_->Run();\n    Next::Analyze();\n  }\n\n  OpIndex REDUCE_INPUT_GRAPH(Simd128Shuffle)(OpIndex ig_index,\n                                             const Simd128ShuffleOp& shuffle) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphSimd128Shuffle(ig_index, shuffle);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    if (shuffle.kind != Simd128ShuffleOp::Kind::kI8x16) goto no_change;\n\n    auto og_left = __ MapToNewGraph(shuffle.left());\n    auto og_right = __ MapToNewGraph(shuffle.right());\n    std::array<uint8_t, kSimd128Size> shuffle_bytes = {0};\n    std::copy(shuffle.shuffle, shuffle.shuffle + kSimd128Size,\n              shuffle_bytes.begin());\n    constexpr size_t half_lanes = kSimd128Size / 2;\n\n    bool does_shuffle_into_low_half =\n        analyzer_->DoesShuffleIntoLowHalf(&shuffle);\n    bool does_shuffle_into_high_half =\n        analyzer_->DoesShuffleIntoHighHalf(&shuffle);\n\n    // Shuffles to adjust because one, or both, of their inputs have been\n    // narrowed.\n    if (does_shuffle_into_low_half && does_shuffle_into_high_half) {\n      DCHECK(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()));\n      DCHECK(analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      // We have a shuffle where both inputs have been reduced and shifted, so\n      // something like this:\n      // |--------|--------|---a1---|---b3---|  shf0 = (a, b)\n      //\n      // |--------|--------|---c2---|---d4---|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      //\n      // Is being changed into this:\n      // |---a1---|---b3---|--------|--------|  shf0 = (a, b)\n      //\n      // |---c2---|---d4---|--------|--------|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      std::transform(shuffle_bytes.begin(), shuffle_bytes.end(),\n                     shuffle_bytes.begin(),\n                     [](uint8_t lane) { return lane - half_lanes; });\n    } else if (does_shuffle_into_low_half) {\n      DCHECK(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()) ||\n             analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      DCHECK_NE(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()),\n                analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      // We have a shuffle where both inputs have been reduced and one has\n      // been shifted, so something like this:\n      // |--------|--------|---a1---|---b3---|  shf0 = (a, b)\n      //\n      // |---c2---|---d4---|--------|--------|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      //\n      // Is being changed into this:\n      // |---a1---|---b3---|--------|--------|  shf0 = (a, b)\n      //\n      // |---c2---|---d4---|--------|--------|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      //\n      // Original shf2 lane-wise shuffle: [2, 3, 4, 5]\n      // Needs to be converted to: [0, 1, 4, 5]\n      std::transform(shuffle_bytes.begin(), shuffle_bytes.begin() + half_lanes,\n                     shuffle_bytes.begin(),\n                     [](uint8_t lane) { return lane - half_lanes; });\n    } else if (does_shuffle_into_high_half) {\n      DCHECK(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()) ||\n             analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      DCHECK_NE(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()),\n                analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      // We have a shuffle where both inputs have been reduced and one has\n      // been shifted, so something like this:\n      // |---a1---|---b3---|--------|--------|  shf0 = (a, b)\n      //\n      // |--------|--------|---c2---|---d4---|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      //\n      // Is being changed into this:\n      // |---a1---|---b3---|--------|--------|  shf0 = (a, b)\n      //\n      // |---c2---|---d4---|--------|--------|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      std::transform(shuffle_bytes.begin() + half_lanes, shuffle_bytes.end(),\n                     shuffle_bytes.begin() + half_lanes,\n                     [](uint8_t lane) { return lane - half_lanes; });\n    }\n\n    if (does_shuffle_into_low_half || does_shuffle_into_high_half) {\n      return __ Simd128Shuffle(og_left, og_right,\n                               Simd128ShuffleOp::Kind::kI8x16,\n                               shuffle_bytes.data());\n    }\n\n    // Shuffles to narrow.\n    if (auto maybe_lanes = analyzer_->DemandedByteLanes(&shuffle);\n        maybe_lanes.has_value()) {\n      auto lanes = maybe_lanes.value();\n      if (analyzer_->ShouldRewriteShuffleToLow(&shuffle)) {\n        DCHECK_EQ(lanes, DemandedElementAnalysis::k8x8Low);\n        // Take the top half of the shuffle bytes and these will now write\n        // those values into the low half of the result instead.\n        std::copy(shuffle.shuffle + half_lanes, shuffle.shuffle + kSimd128Size,\n                  shuffle_bytes.begin());\n      } else {\n        // Just truncate the lower half.\n        std::copy(shuffle.shuffle, shuffle.shuffle + half_lanes,\n                  shuffle_bytes.begin());\n      }\n\n      if (lanes == DemandedElementAnalysis::k8x2Low) {\n        return __ Simd128Shuffle(og_left, og_right,\n                                 Simd128ShuffleOp::Kind::kI8x2,\n                                 shuffle_bytes.data());\n      } else if (lanes == DemandedElementAnalysis::k8x4Low) {\n        return __ Simd128Shuffle(og_left, og_right,\n                                 Simd128ShuffleOp::Kind::kI8x4,\n                                 shuffle_bytes.data());\n      } else if (lanes == DemandedElementAnalysis::k8x8Low) {\n        return __ Simd128Shuffle(og_left, og_right,\n                                 Simd128ShuffleOp::Kind::kI8x8,\n                                 shuffle_bytes.data());\n      }\n    }\n    goto no_change;\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Analyze\",\n                \"parent\": \"WasmShuffleReducer\",\n                \"about\": \"Analyzes the input graph for shuffle operations that can be reduced, using the WasmShuffleAnalyzer. It initializes the analyzer and runs it before calling the base class's Analyze method.\",\n                \"logic\": \"Creates an instance of WasmShuffleAnalyzer, runs it, and then calls the Analyze method of the base class (Next).\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"WasmShuffleAnalyzer\",\n                    \"Next\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void Analyze() {\n    analyzer_.emplace(__ phase_zone(), __ input_graph());\n    analyzer_->Run();\n    Next::Analyze();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE_INPUT_GRAPH(Simd128Shuffle)\",\n                \"parent\": \"WasmShuffleReducer\",\n                \"about\": \"Reduces a Simd128Shuffle operation in the input graph. It checks if the shuffle can be narrowed or if its inputs need to be adjusted before creating a new shuffle operation.\",\n                \"logic\": \"The function checks if the current shuffle operation can be reduced. The reduction involves adjusting the shuffle based on whether the inputs have been narrowed (reduced in size) and potentially rewriting the shuffle to operate on the low half of the data. If no reductions are possible, it defers to the next reducer in the chain. The core logic involves:\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_index\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The index of the Simd128Shuffle operation in the input graph.\"\n                    },\n                    {\n                        \"name\": \"shuffle\",\n                        \"type\": \"const Simd128ShuffleOp&\",\n                        \"purpose\": \"A reference to the Simd128Shuffle operation to be reduced.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The index of the new (potentially reduced) Simd128Shuffle operation in the input graph.\"\n                },\n                \"dependencies\": [\n                    \"Simd128ShuffleOp\",\n                    \"analyzer_\",\n                    \"Next\",\n                    \"DemandedElementAnalysis\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  OpIndex REDUCE_INPUT_GRAPH(Simd128Shuffle)(OpIndex ig_index,\n                                             const Simd128ShuffleOp& shuffle) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphSimd128Shuffle(ig_index, shuffle);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    if (shuffle.kind != Simd128ShuffleOp::Kind::kI8x16) goto no_change;\n\n    auto og_left = __ MapToNewGraph(shuffle.left());\n    auto og_right = __ MapToNewGraph(shuffle.right());\n    std::array<uint8_t, kSimd128Size> shuffle_bytes = {0};\n    std::copy(shuffle.shuffle, shuffle.shuffle + kSimd128Size,\n              shuffle_bytes.begin());\n    constexpr size_t half_lanes = kSimd128Size / 2;\n\n    bool does_shuffle_into_low_half =\n        analyzer_->DoesShuffleIntoLowHalf(&shuffle);\n    bool does_shuffle_into_high_half =\n        analyzer_->DoesShuffleIntoHighHalf(&shuffle);\n\n    // Shuffles to adjust because one, or both, of their inputs have been\n    // narrowed.\n    if (does_shuffle_into_low_half && does_shuffle_into_high_half) {\n      DCHECK(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()));\n      DCHECK(analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      // We have a shuffle where both inputs have been reduced and shifted, so\n      // something like this:\n      // |--------|--------|---a1---|---b3---|  shf0 = (a, b)\n      //\n      // |--------|--------|---c2---|---d4---|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      //\n      // Is being changed into this:\n      // |---a1---|---b3---|--------|--------|  shf0 = (a, b)\n      //\n      // |---c2---|---d4---|--------|--------|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      std::transform(shuffle_bytes.begin(), shuffle_bytes.end(),\n                     shuffle_bytes.begin(),\n                     [](uint8_t lane) { return lane - half_lanes; });\n    } else if (does_shuffle_into_low_half) {\n      DCHECK(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()) ||\n             analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      DCHECK_NE(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()),\n                analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      // We have a shuffle where both inputs have been reduced and one has\n      // been shifted, so something like this:\n      // |--------|--------|---a1---|---b3---|  shf0 = (a, b)\n      //\n      // |---c2---|---d4---|--------|--------|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      //\n      // Is being changed into this:\n      // |---a1---|---b3---|--------|--------|  shf0 = (a, b)\n      //\n      // |---c2---|---d4---|--------|--------|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      //\n      // Original shf2 lane-wise shuffle: [2, 3, 4, 5]\n      // Needs to be converted to: [0, 1, 4, 5]\n      std::transform(shuffle_bytes.begin(), shuffle_bytes.begin() + half_lanes,\n                     shuffle_bytes.begin(),\n                     [](uint8_t lane) { return lane - half_lanes; });\n    } else if (does_shuffle_into_high_half) {\n      DCHECK(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()) ||\n             analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      DCHECK_NE(analyzer_->ShouldRewriteShuffleToLow(shuffle.left()),\n                analyzer_->ShouldRewriteShuffleToLow(shuffle.right()));\n      // We have a shuffle where both inputs have been reduced and one has\n      // been shifted, so something like this:\n      // |---a1---|---b3---|--------|--------|  shf0 = (a, b)\n      //\n      // |--------|--------|---c2---|---d4---|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      //\n      // Is being changed into this:\n      // |---a1---|---b3---|--------|--------|  shf0 = (a, b)\n      //\n      // |---c2---|---d4---|--------|--------|  shf1 = (c, d)\n      //\n      // |---a1---|---b3---|---c2---|---d4---|  shf2 = (shf0, shf1)\n      std::transform(shuffle_bytes.begin() + half_lanes, shuffle_bytes.end(),\n                     shuffle_bytes.begin() + half_lanes,\n                     [](uint8_t lane) { return lane - half_lanes; });\n    }\n\n    if (does_shuffle_into_low_half || does_shuffle_into_high_half) {\n      return __ Simd128Shuffle(og_left, og_right,\n                               Simd128ShuffleOp::Kind::kI8x16,\n                               shuffle_bytes.data());\n    }\n\n    // Shuffles to narrow.\n    if (auto maybe_lanes = analyzer_->DemandedByteLanes(&shuffle);\n        maybe_lanes.has_value()) {\n      auto lanes = maybe_lanes.value();\n      if (analyzer_->ShouldRewriteShuffleToLow(&shuffle)) {\n        DCHECK_EQ(lanes, DemandedElementAnalysis::k8x8Low);\n        // Take the top half of the shuffle bytes and these will now write\n        // those values into the low half of the result instead.\n        std::copy(shuffle.shuffle + half_lanes, shuffle.shuffle + kSimd128Size,\n                  shuffle_bytes.begin());\n      } else {\n        // Just truncate the lower half.\n        std::copy(shuffle.shuffle, shuffle.shuffle + half_lanes,\n                  shuffle_bytes.begin());\n      }\n\n      if (lanes == DemandedElementAnalysis::k8x2Low) {\n        return __ Simd128Shuffle(og_left, og_right,\n                                 Simd128ShuffleOp::Kind::kI8x2,\n                                 shuffle_bytes.data());\n      } else if (lanes == DemandedElementAnalysis::k8x4Low) {\n        return __ Simd128Shuffle(og_left, og_right,\n                                 Simd128ShuffleOp::Kind::kI8x4,\n                                 shuffle_bytes.data());\n      } else if (lanes == DemandedElementAnalysis::k8x8Low) {\n        return __ Simd128Shuffle(og_left, og_right,\n                                 Simd128ShuffleOp::Kind::kI8x8,\n                                 shuffle_bytes.data());\n      }\n    }\n    goto no_change;\n  }\n        ]]></code>\n    </func>\n</file>\n```"
}