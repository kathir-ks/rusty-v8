{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/bigint/mul-fft.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/bigint/mul-fft.cc\",\n            \"file_name\": \"mul-fft.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements FFT-based multiplication for BigInts, following the Sch\u00f6nhage-Strassen algorithm.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for BigInt operations, digit arithmetic, and utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/bigint/bigint-internal.h\"\n            #include \"src/bigint/digit-arithmetic.h\"\n            #include \"src/bigint/util.h\"\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::bigint\",\n                \"purpose\": \"Encloses BigInt-related functionality within the V8 namespace.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            namespace bigint {\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::bigint::<anonymous>\",\n                \"purpose\": \"Encloses internal helper functions and classes.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n        ]]></code>\n    </namespace>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ModFn_Helper\",\n                \"about\": \"Helper for ModFn to perform modular reduction.\",\n                \"logic\": \"Performs modular reduction by adding or subtracting 2^K + 1, where K is derived from the length of the input array. Handles both positive and negative 'high' values to adjust the input 'x'.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"x\",\n                        \"type\": \"digit_t*\",\n                        \"purpose\": \"The input array to be modified (reduced modulo F_n).\"\n                    },\n                    {\n                        \"name\": \"len\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The length of the input array 'x'.\"\n                    },\n                    {\n                        \"name\": \"high\",\n                        \"type\": \"signed_digit_t\",\n                        \"purpose\": \"The value of the highest digit (x[len - 1]) which is used for modular reduction.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; the input 'x' is modified in place.\"\n                },\n                \"dependencies\": [\n                    \"digit_sub\",\n                    \"digit_add2\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ModFn_Helper(digit_t* x, int len, signed_digit_t high) {\n              if (high > 0) {\n                digit_t borrow = high;\n                x[len - 1] = 0;\n                for (int i = 0; i < len; i++) {\n                  x[i] = digit_sub(x[i], borrow, &borrow);\n                  if (borrow == 0) break;\n                }\n              } else {\n                digit_t carry = -high;\n                x[len - 1] = 0;\n                for (int i = 0; i < len; i++) {\n                  x[i] = digit_add2(x[i], carry, &carry);\n                  if (carry == 0) break;\n                }\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ModFn\",\n                \"about\": \"Reduces an integer modulo F_n (2^K + 1).\",\n                \"logic\": \"Reduces an integer represented by the array 'x' modulo F_n.  It repeatedly calls ModFn_Helper to handle the high digit until it's zero. Includes a check for x[K] being -1 and calls ModFn_Helper if necessary.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"x\",\n                        \"type\": \"digit_t*\",\n                        \"purpose\": \"The input array to be reduced modulo F_n.\"\n                    },\n                    {\n                        \"name\": \"len\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The length of the input array 'x'.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; the input 'x' is modified in place.\"\n                },\n                \"dependencies\": [\n                    \"ModFn_Helper\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ModFn(digit_t* x, int len) {\n              int K = len - 1;\n              signed_digit_t high = x[K];\n              if (high == 0) return;\n              ModFn_Helper(x, len, high);\n              high = x[K];\n              if (high == 0) return;\n              DCHECK(high == 1 || high == -1);\n              ModFn_Helper(x, len, high);\n              high = x[K];\n              if (high == -1) ModFn_Helper(x, len, high);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ModFnDoubleWidth\",\n                \"about\": \"Reduces a double-width integer modulo F_n.\",\n                \"logic\": \"Reduces a double-width integer (represented by 'src') modulo F_n, storing the result in 'dest'. It subtracts the higher half of 'src' from the lower half and then calls ModFn to normalize the result.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"dest\",\n                        \"type\": \"digit_t*\",\n                        \"purpose\": \"The destination array to store the reduced result.\"\n                    },\n                    {\n                        \"name\": \"src\",\n                        \"type\": \"const digit_t*\",\n                        \"purpose\": \"The source array representing the double-width integer.\"\n                    },\n                    {\n                        \"name\": \"len\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The length of the destination array 'dest'.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; the result is stored in 'dest'.\"\n                },\n                \"dependencies\": [\n                    \"digit_sub2\",\n                    \"ModFn\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ModFnDoubleWidth(digit_t* dest, const digit_t* src, int len) {\n              int K = len - 1;\n              digit_t borrow = 0;\n              for (int i = 0; i < K; i++) {\n                dest[i] = digit_sub2(src[i], src[i + K], borrow, &borrow);\n              }\n              dest[K] = digit_sub2(0, src[2 * K], borrow, &borrow);\n              // {borrow} may be non-zero here, that's OK as {ModFn} will take care of it.\n              ModFn(dest, len);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SumDiff\",\n                \"about\": \"Calculates the sum and difference of two arrays and normalizes them modulo F_n.\",\n                \"logic\": \"Calculates {a} + {b} and {a} - {b}, storing the results in {sum} and {diff} respectively.  It normalizes both results modulo F_n by calling ModFn.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"sum\",\n                        \"type\": \"digit_t*\",\n                        \"purpose\": \"The destination array to store the sum.\"\n                    },\n                    {\n                        \"name\": \"diff\",\n                        \"type\": \"digit_t*\",\n                        \"purpose\": \"The destination array to store the difference.\"\n                    },\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"const digit_t*\",\n                        \"purpose\": \"The first input array.\"\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"type\": \"const digit_t*\",\n                        \"purpose\": \"The second input array.\"\n                    },\n                    {\n                        \"name\": \"len\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The length of the input arrays.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; the sum and difference are stored in 'sum' and 'diff' respectively.\"\n                },\n                \"dependencies\": [\n                    \"digit_add3\",\n                    \"digit_sub2\",\n                    \"ModFn\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void SumDiff(digit_t* sum, digit_t* diff, const digit_t* a, const digit_t* b,\n                         int len) {\n              digit_t carry = 0;\n              digit_t borrow = 0;\n              for (int i = 0; i < len; i++) {\n                // Read both values first, because inputs and outputs can overlap.\n                digit_t ai = a[i];\n                digit_t bi = b[i];\n                sum[i] = digit_add3(ai, bi, carry, &carry);\n                diff[i] = digit_sub2(ai, bi, borrow, &borrow);\n              }\n              ModFn(sum, len);\n              ModFn(diff, len);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ShiftModFn_Large\",\n                \"about\": \"Shifts an integer modulo F_n by a large shift value (shift >= K).\",\n                \"logic\": \"Shifts the input array 'input' by a specified number of digits and bits (digit_shift, bits_shift) modulo F_n. This function is used when the shift amount is larger than K.  It involves subtracting (or adding) a shifted version of the input from a virtually initialized result (2^K + 1) to avoid underflow. Complex bit manipulation is performed to handle shifts not aligned to digit boundaries.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"result\",\n                        \"type\": \"digit_t*\",\n                        \"purpose\": \"The destination array to store the shifted result.\"\n                    },\n                    {\n                        \"name\": \"input\",\n                        \"type\": \"const digit_t*\",\n                        \"purpose\": \"The input array to be shifted.\"\n                    },\n                    {\n                        \"name\": \"digit_shift\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of digits to shift.\"\n                    },\n                    {\n                        \"name\": \"bits_shift\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of bits to shift within a digit.\"\n                    },\n                    {\n                        \"name\": \"K\",\n                        \"type\": \"int\",\n                        \"purpose\": \"Determines F_n = 2^K + 1; used in the modulo operation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; the shifted result is stored in 'result'.\"\n                },\n                \"dependencies\": [\n                    \"digit_add2\",\n                    \"digit_sub\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ShiftModFn_Large(digit_t* result, const digit_t* input, int digit_shift,\n                                  int bits_shift, int K) {\n              // If {digit_shift} is greater than K, we use the following transformation\n              // (where, since everything is mod 2^K + 1, we are allowed to add or\n              // subtract any multiple of 2^K + 1 at any time):\n              //      x * 2^{K+m}   mod 2^K + 1\n              //   == x * 2^K * 2^m - (2^K + 1)*(x * 2^m)   mod 2^K + 1\n              //   == x * 2^K * 2^m - x * 2^K * 2^m - x * 2^m   mod 2^K + 1\n              //   == -x * 2^m   mod 2^K + 1\n              // So the flow is the same as for m < K, but we invert the subtraction's\n              // operands. In order to avoid underflow, we virtually initialize the\n              // result to 2^K + 1:\n              //   input  =  [ iK ][iK-1] ....  .... [ i1 ][ i0 ]\n              //   result =  [   1][0000] ....  .... [0000][0001]\n              //            +                  [ iK ] .... [ iX ]\n              //            -      [iX-1] .... [ i0 ]\n              DCHECK(digit_shift >= K);\n              digit_shift -= K;\n              digit_t borrow = 0;\n              if (bits_shift == 0) {\n                digit_t carry = 1;\n                for (int i = 0; i < digit_shift; i++) {\n                  result[i] = digit_add2(input[i + K - digit_shift], carry, &carry);\n                }\n                result[digit_shift] = digit_sub(input[K] + carry, input[0], &borrow);\n                for (int i = digit_shift + 1; i < K; i++) {\n                  digit_t d = input[i - digit_shift];\n                  result[i] = digit_sub2(0, d, borrow, &borrow);\n                }\n              } else {\n                digit_t add_carry = 1;\n                digit_t input_carry =\n                    input[K - digit_shift - 1] >> (kDigitBits - bits_shift);\n                for (int i = 0; i < digit_shift; i++) {\n                  digit_t d = input[i + K - digit_shift];\n                  digit_t summand = (d << bits_shift) | input_carry;\n                  result[i] = digit_add2(summand, add_carry, &add_carry);\n                  input_carry = d >> (kDigitBits - bits_shift);\n                }\n                {\n                  // result[digit_shift] = (add_carry + iK_part) - i0_part\n                  digit_t d = input[K];\n                  digit_t iK_part = (d << bits_shift) | input_carry;\n                  digit_t iK_carry = d >> (kDigitBits - bits_shift);\n                  digit_t sum = digit_add2(add_carry, iK_part, &add_carry);\n                  // {iK_carry} is less than a full digit, so we can merge {add_carry}\n                  // into it without overflow.\n                  iK_carry += add_carry;\n                  d = input[0];\n                  digit_t i0_part = d << bits_shift;\n                  result[digit_shift] = digit_sub(sum, i0_part, &borrow);\n                  input_carry = d >> (kDigitBits - bits_shift);\n                  if (digit_shift + 1 < K) {\n                    d = input[1];\n                    digit_t subtrahend = (d << bits_shift) | input_carry;\n                    result[digit_shift + 1] =\n                        digit_sub2(iK_carry, subtrahend, borrow, &borrow);\n                    input_carry = d >> (kDigitBits - bits_shift);\n                  }\n                }\n                for (int i = digit_shift + 2; i < K; i++) {\n                  digit_t d = input[i - digit_shift];\n                  digit_t subtrahend = (d << bits_shift) | input_carry;\n                  result[i] = digit_sub2(0, subtrahend, borrow, &borrow);\n                  input_carry = d >> (kDigitBits - bits_shift);\n                }\n              }\n              // The virtual 1 in result[K] should be eliminated by {borrow}. If there\n              // is no borrow, then the virtual initialization was too much. Subtract\n              // 2^K + 1.\n              result[K] = 0;\n              if (borrow != 1) {\n                borrow = 1;\n                for (int i = 0; i < K; i++) {\n                  result[i] = digit_sub(result[i], borrow, &borrow);\n                  if (borrow == 0) break;\n                }\n                if (borrow != 0) {\n                  // The result must be 2^K.\n                  for (int i = 0; i < K; i++) result[i] = 0;\n                  result[K] = 1;\n                }\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ShiftModFn\",\n                \"about\": \"Shifts an integer modulo F_n by a power of two.\",\n                \"logic\": \"Shifts the input array 'input' by a specified power of two modulo F_n. It decomposes the shift into digit and bit shifts and calls ShiftModFn_Large if the digit shift is larger than or equal to K. Optimizations are performed for the case where bits_shift is zero.  It includes a virtual subtraction logic to handle modulo reduction and ensures correct underflow handling.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"result\",\n                        \"type\": \"digit_t*\",\n                        \"purpose\": \"The destination array to store the shifted result.\"\n                    },\n                    {\n                        \"name\": \"input\",\n                        \"type\": \"const digit_t*\",\n                        \"purpose\": \"The input array to be shifted.\"\n                    },\n                    {\n                        \"name\": \"power_of_two\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The power of two by which to shift the input.\"\n                    },\n                    {\n                        \"name\": \"K\",\n                        \"type\": \"int\",\n                        \"purpose\": \"Determines F_n = 2^K + 1; used in the modulo operation.\"\n                    },\n                    {\n                        \"name\": \"zero_above\",\n                        \"type\": \"int\",\n                        \"purpose\": \"Optimization hint; if the digits above this index are known to be zero, this can speed up the computation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; the shifted result is stored in 'result'.\"\n                },\n                \"dependencies\": [\n                    \"ShiftModFn_Large\",\n                    \"digit_sub2\",\n                    \"digit_sub\",\n                    \"digit_add3\",\n                    \"digit_add2\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ShiftModFn(digit_t* result, const digit_t* input, int power_of_two, int K,\n                            int zero_above = 0x7FFFFFFF) {\n              // The modulo-reduction amounts to a subtraction, which we combine\n              // with the shift as follows:\n              //   input  =  [ iK ][iK-1] ....  .... [ i1 ][ i0 ]\n              //   result =        [iX-1] .... [ i0 ] <---------- shift by {power_of_two}\n              //            -                  [ iK ] .... [ iX ]\n              // where \"X\" is the index \"K - digit_shift\".\n              int digit_shift = power_of_two / kDigitBits;\n              int bits_shift = power_of_two % kDigitBits;\n              // By an analogous construction to the \"digit_shift >= K\" case,\n              // it turns out that:\n              //    x * 2^{2K+m} == x * 2^m   mod 2^K + 1.\n              while (digit_shift >= 2 * K) digit_shift -= 2 * K;  // Faster than '%'!\n              if (digit_shift >= K) {\n                return ShiftModFn_Large(result, input, digit_shift, bits_shift, K);\n              }\n              digit_t borrow = 0;\n              if (bits_shift == 0) {\n                // We do a single pass over {input}, starting by copying digits [i1] to\n                // [iX-1] to result indices digit_shift+1 to K-1.\n                int i = 1;\n                // Read input digits unless we know they are zero.\n                int cap = std::min(K - digit_shift, zero_above);\n                for (; i < cap; i++) {\n                  result[i + digit_shift] = input[i];\n                }\n                // Any remaining work can hard-code the knowledge that input[i] == 0.\n                for (; i < K - digit_shift; i++) {\n                  DCHECK(input[i] == 0);\n                  result[i + digit_shift] = 0;\n                }\n                // Second phase: subtract input digits [iX] to [iK] from (virtually) zero-\n                // initialized result indices 0 to digit_shift-1.\n                cap = std::min(K, zero_above);\n                for (; i < cap; i++) {\n                  digit_t d = input[i];\n                  result[i - K + digit_shift] = digit_sub2(0, d, borrow, &borrow);\n                }\n                // Any remaining work can hard-code the knowledge that input[i] == 0.\n                for (; i < K; i++) {\n                  DCHECK(input[i] == 0);\n                  result[i - K + digit_shift] = digit_sub(0, borrow, &borrow);\n                }\n                // Last step: subtract [iK] from [i0] and store at result index digit_shift.\n                result[digit_shift] = digit_sub2(input[0], input[K], borrow, &borrow);\n              } else {\n                // Same flow as before, but taking bits_shift != 0 into account.\n                // First phase: result indices digit_shift+1 to K.\n                digit_t carry = 0;\n                int i = 0;\n                // Read input digits unless we know they are zero.\n                int cap = std::min(K - digit_shift, zero_above);\n                for (; i < cap; i++) {\n                  digit_t d = input[i];\n                  result[i + digit_shift] = (d << bits_shift) | carry;\n                  carry = d >> (kDigitBits - bits_shift);\n                }\n                // Any remaining work can hard-code the knowledge that input[i] == 0.\n                for (; i < K - digit_shift; i++) {\n                  DCHECK(input[i] == 0);\n                  result[i + digit_shift] = carry;\n                  carry = 0;\n                }\n                // Second phase: result indices 0 to digit_shift - 1.\n                cap = std::min(K, zero_above);\n                for (; i < cap; i++) {\n                  digit_t d = input[i];\n                  result[i - K + digit_shift] =\n                      digit_sub2(0, (d << bits_shift) | carry, borrow, &borrow);\n                  carry = d >> (kDigitBits - bits_shift);\n                }\n                // Any remaining work can hard-code the knowledge that input[i] == 0.\n                if (i < K) {\n                  DCHECK(input[i] == 0);\n                  result[i - K + digit_shift] = digit_sub2(0, carry, borrow, &borrow);\n                  carry = 0;\n                  i++;\n                }\n                for (; i < K; i++) {\n                  DCHECK(input[i] == 0);\n                  result[i - K + digit_shift] = digit_sub(0, borrow, &borrow);\n                }\n                // Last step: compute result[digit_shift].\n                digit_t d = input[K];\n                result[digit_shift] = digit_sub2(\n                    result[digit_shift], (d << bits_shift) | carry, borrow, &borrow);\n                // No carry left.\n                DCHECK((d >> (kDigitBits - bits_shift)) == 0);\n              }\n              result[K] = 0;\n              for (int i = digit_shift + 1; i <= K && borrow > 0; i++) {\n                result[i] = digit_sub(result[i], borrow, &borrow);\n              }\n              if (borrow > 0) {\n                // Underflow means we subtracted too much. Add 2^K + 1.\n                digit_t carry = 1;\n                for (int i = 0; i <= K; i++) {\n                  result[i] = digit_add2(result[i], carry, &carry);\n                  if (carry == 0) break;\n                }\n                result[K] = digit_add2(result[K], 1, &carry);\n              }\n            }\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"Parameters\",\n                \"about\": \"Holds parameters for FFT-based multiplication.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"m\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"A parameter related to the size of the FFT (2^m).\"\n                    },\n                    {\n                        \"name\": \"K\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Determines F_n = 2^K + 1; used in modulo arithmetic.\"\n                    },\n                    {\n                        \"name\": \"n\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The number of chunks.\"\n                    },\n                    {\n                        \"name\": \"s\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The chunk size.\"\n                    },\n                    {\n                        \"name\": \"r\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"A parameter related to the twiddle factor (omega = 2^r).\"\n                    }\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct Parameters {\n              // We never use the default values, but skipping zero-initialization\n              // of these fields saddens and confuses MSan.\n              int m{0};\n              int K{0};\n              int n{0};\n              int s{0};\n              int r{0};\n            };\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ComputeParameters\",\n                \"about\": \"Computes the parameters for the FFT multiplication algorithm, given the bit length and m.\",\n                \"logic\": \"Calculates parameters (n, s, K, r) based on the input bit length 'N' and 'm'. The computation involves rounding up values and ensuring that K is a multiple of certain factors based on a recursion threshold. Uses kDigitBits for calculations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"N\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The bit length of the input integers.\"\n                    },\n                    {\n                        \"name\": \"m\",\n                        \"type\": \"int\",\n                        \"purpose\": \"A parameter influencing the size of the FFT (2^m).\"\n                    },\n                    {\n                        \"name\": \"params\",\n                        \"type\": \"Parameters*\",\n                        \"purpose\": \"A pointer to the Parameters struct where the computed parameters will be stored.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; the computed parameters are stored in the 'params' struct.\"\n                },\n                \"dependencies\": [\n                    \"RoundUp\",\n                    \"kDigitBits\",\n                    \"base::bits::IsPowerOfTwo\",\n                    \"CountTrailingZeros\",\n                    \"kFftInnerThreshold\",\n                    \"kLog2DigitBits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ComputeParameters(int N, int m, Parameters* params) {\n              N *= kDigitBits;\n              int n = 1 << m;  // 2^m\n              int nhalf = n >> 1;\n              int s = (N + n - 1) >> m;  // ceil(N/n)\n              s = RoundUp(s, kDigitBits);\n              int K = m + 2 * s + 1;  // K must be at least this big...\n              K = RoundUp(K, nhalf);  // ...and a multiple of n/2.\n              int r = K >> (m - 1);   // Which multiple?\n\n              // We want recursive calls to make progress, so force K to be a multiple\n              // of 8 if it's above the recursion threshold. Otherwise, K must be a\n              // multiple of kDigitBits.\n              const int threshold = (K + 1 >= kFftInnerThreshold * kDigitBits)\n                                        ? 3 + kLog2DigitBits\n                                        : kLog2DigitBits;\n              int K_tz = CountTrailingZeros(K);\n              while (K_tz < threshold) {\n                K += (1 << K_tz);\n                r = K >> (m - 1);\n                K_tz = CountTrailingZeros(K);\n              }\n\n              DCHECK(K % kDigitBits == 0);\n              DCHECK(s % kDigitBits == 0);\n              params->K = K / kDigitBits;\n              params->s = s / kDigitBits;\n              params->n = n;\n              params->r = r;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ComputeParameters_Inner\",\n                \"about\": \"Computes parameters for recursive invocations of the FFT-based multiplication.\",\n                \"logic\": \"Calculates parameters for recursive inner layer FFT calls. It computes 'm' based on bit length of 'N' and ensures K is a multiple of n and kDigitBits. No rounding up of s is done in this inner layer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"N\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The bit length of the input for the inner FFT call.\"\n                    },\n                    {\n                        \"name\": \"params\",\n                        \"type\": \"Parameters*\",\n                        \"purpose\": \"A pointer to the Parameters struct where the computed parameters will be stored.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value; the computed parameters are stored in the 'params' struct.\"\n                },\n                \"dependencies\": [\n                    \"CountTrailingZeros\",\n                    \"BitLength\",\n                    \"kDigitBits\",\n                    \"RoundUp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void ComputeParameters_Inner(int N, Parameters* params) {\n              int max_m = CountTrailingZeros(N);\n              int N_bits = BitLength(N);\n              int m = N_bits - 4;  // Don't let s get too small.\n              m = std::min(max_m, m);\n              N *= kDigitBits;\n              int n = 1 << m;  // 2^m\n              // We can't round up s in the inner layer, because N = n*s is fixed.\n              int s = N >> m;\n              DCHECK(N == s * n);\n              int K = m + 2 * s + 1;  // K must be at least this big...\n              K = RoundUp(K, n);      // ...and a multiple of n and kDigitBits.\n              K = RoundUp(K, kDigitBits);\n              params->r = K >> m;           // Which multiple?\n              DCHECK(K % kDigitBits == 0);\n              DCHECK(s % kDigitBits == 0);\n              params->K = K / kDigitBits;\n              params->s = s / kDigitBits;\n              params->n = n;\n              params->m = m;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PredictInnerK\",\n                \"about\": \"Predicts the value of K for the inner FFT calculation.\",\n                \"logic\": \"Computes and returns the K parameter by calling ComputeParameters_Inner.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"N\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The bit length of the input.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The predicted value of K.\"\n                },\n                \"dependencies\": [\n                    \"ComputeParameters_Inner\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            int PredictInnerK(int N) {\n              Parameters params;\n              ComputeParameters_Inner(N, &params);\n              return params.K;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ShouldDecrementM\",\n                \"about\": \"Applies heuristics to determine whether the parameter 'm' should be decremented.\",\n                \"logic\": \"Evaluates whether 'm' should be decremented based on how"
}