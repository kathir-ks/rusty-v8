{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turbofan-graph.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 66, column 58",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turbofan-graph.h\",\n            \"file_name\": \"turbofan-graph.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the TFGraph class, which represents a graph data structure used in the Turbofan compiler for intermediate representation of code.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary standard library and V8-specific headers for data structures and compiler configurations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <array>\n\n#include \"src/base/compiler-specific.h\"\n#include \"src/zone/zone-containers.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TFGraph\",\n                \"extends\": \"ZoneObject\",\n                \"about\": \"Represents a directed graph used in the Turbofan compiler.  It manages nodes, edges, and associated metadata for representing code.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating graph nodes and data structures.\"\n                    },\n                    {\n                        \"name\": \"start_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The start node of the graph.\"\n                    },\n                    {\n                        \"name\": \"end_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The end node of the graph.\"\n                    },\n                    {\n                        \"name\": \"mark_max_\",\n                        \"type\": \"Mark\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maximum mark value used during graph traversals.\"\n                    },\n                    {\n                        \"name\": \"next_node_id_\",\n                        \"type\": \"NodeId\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The next available node ID.\"\n                    },\n                    {\n                        \"name\": \"decorators_\",\n                        \"type\": \"ZoneVector<GraphDecorator*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of graph decorators to apply to new nodes.\"\n                    },\n                    {\n                        \"name\": \"has_simd_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating if the graph contains SIMD operations.\"\n                    },\n                    {\n                        \"name\": \"simd_stores_\",\n                        \"type\": \"ZoneVector<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of nodes that are SIMD stores.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneObject\",\n                    \"Zone\",\n                    \"Node\",\n                    \"Operator\",\n                    \"GraphDecorator\",\n                    \"ZoneVector\",\n                    \"Mark\",\n                    \"NodeId\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE TFGraph final : public NON_EXPORTED_BASE(ZoneObject) {\n public:\n  explicit TFGraph(Zone* zone);\n  TFGraph(const TFGraph&) = delete;\n  TFGraph& operator=(const TFGraph&) = delete;\n\n  // Scope used when creating a subgraph for inlining. Automatically preserves\n  // the original start and end nodes of the graph, and resets them when you\n  // leave the scope.\n  class V8_NODISCARD SubgraphScope final {\n   public:\n    explicit SubgraphScope(TFGraph* graph)\n        : graph_(graph), start_(graph->start()), end_(graph->end()) {}\n    ~SubgraphScope() {\n      graph_->SetStart(start_);\n      graph_->SetEnd(end_);\n    }\n    SubgraphScope(const SubgraphScope&) = delete;\n    SubgraphScope& operator=(const SubgraphScope&) = delete;\n\n   private:\n    TFGraph* const graph_;\n    Node* const start_;\n    Node* const end_;\n  };\n\n  // Base implementation used by all factory methods.\n  Node* NewNodeUnchecked(const Operator* op, int input_count,\n                         Node* const* inputs, bool incomplete = false);\n\n  // Factory that checks the input count.\n  Node* NewNode(const Operator* op, int input_count, Node* const* inputs,\n                bool incomplete = false);\n\n  // Factory template for nodes with static input counts.\n  // Note: Template magic below is used to ensure this method is only considered\n  // for argument types convertible to Node* during overload resolution.\n  template <typename... Nodes>\n  Node* NewNode(const Operator* op, Nodes... nodes)\n    requires(std::conjunction_v<std::is_convertible<Nodes, Node*>...>)\n  {\n    std::array<Node*, sizeof...(nodes)> nodes_arr{\n        {static_cast<Node*>(nodes)...}};\n    return NewNode(op, nodes_arr.size(), nodes_arr.data());\n  }\n\n  // Clone the {node}, and assign a new node id to the copy.\n  Node* CloneNode(const Node* node);\n\n  Zone* zone() const { return zone_; }\n  Node* start() const { return start_; }\n  Node* end() const { return end_; }\n\n  void SetStart(Node* start) { start_ = start; }\n  void SetEnd(Node* end) { end_ = end; }\n\n  size_t NodeCount() const { return next_node_id_; }\n\n  void Decorate(Node* node);\n  void AddDecorator(GraphDecorator* decorator);\n  void RemoveDecorator(GraphDecorator* decorator);\n\n  // Very simple print API usable in a debugger.\n  void Print() const;\n\n  bool HasSimd() const { return has_simd_; }\n  void SetSimd(bool has_simd) { has_simd_ = has_simd; }\n\n  void RecordSimdStore(Node* store);\n  ZoneVector<Node*> const& GetSimdStoreNodes();\n\n private:\n  friend class NodeMarkerBase;\n\n  inline NodeId NextNodeId();\n\n  Zone* const zone_;\n  Node* start_;\n  Node* end_;\n  Mark mark_max_;\n  NodeId next_node_id_;\n  ZoneVector<GraphDecorator*> decorators_;\n  bool has_simd_;\n  ZoneVector<Node*> simd_stores_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TFGraph::SubgraphScope\",\n                \"about\": \"A nested class providing RAII to automatically preserve and restore graph start and end nodes during subgraph creation/inlining.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the parent graph.\"\n                    },\n                    {\n                        \"name\": \"start_\",\n                        \"type\": \"Node* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The original start node of the graph.\"\n                    },\n                    {\n                        \"name\": \"end_\",\n                        \"type\": \"Node* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The original end node of the graph.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TFGraph\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class V8_NODISCARD SubgraphScope final {\n   public:\n    explicit SubgraphScope(TFGraph* graph)\n        : graph_(graph), start_(graph->start()), end_(graph->end()) {}\n    ~SubgraphScope() {\n      graph_->SetStart(start_);\n      graph_->SetEnd(end_);\n    }\n    SubgraphScope(const SubgraphScope&) = delete;\n    SubgraphScope& operator=(const SubgraphScope&) = delete;\n\n   private:\n    TFGraph* const graph_;\n    Node* const start_;\n    Node* const end_;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GraphDecorator\",\n                \"extends\": \"ZoneObject\",\n                \"about\": \"An abstract class for adding behavior to node creation in a graph.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"ZoneObject\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass GraphDecorator : public ZoneObject {\n public:\n  virtual ~GraphDecorator() = default;\n  virtual void Decorate(Node* node) = 0;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TFGraph\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Constructor for the TFGraph class.\",\n                \"logic\": \"Initializes the graph with a given memory zone.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to use for allocating graph data structures.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  explicit TFGraph(Zone* zone);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"NewNodeUnchecked\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Base implementation for creating new nodes in the graph without input count checks.\",\n                \"logic\": \"Creates a new node with the given operator, input count, and input nodes.  Sets incomplete flag if requested.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The operator associated with the node.\"\n                    },\n                    {\n                        \"name\": \"input_count\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of input nodes.\"\n                    },\n                    {\n                        \"name\": \"inputs\",\n                        \"type\": \"Node* const*\",\n                        \"purpose\": \"An array of input nodes.\"\n                    },\n                    {\n                        \"name\": \"incomplete\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the node is incomplete.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The newly created node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Operator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* NewNodeUnchecked(const Operator* op, int input_count,\n                         Node* const* inputs, bool incomplete = false);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"NewNode\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Creates a new node in the graph with input count checks.\",\n                \"logic\": \"Creates a new node with the given operator, input count, and input nodes, after validating input count.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The operator associated with the node.\"\n                    },\n                    {\n                        \"name\": \"input_count\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of input nodes.\"\n                    },\n                    {\n                        \"name\": \"inputs\",\n                        \"type\": \"Node* const*\",\n                        \"purpose\": \"An array of input nodes.\"\n                    },\n                    {\n                        \"name\": \"incomplete\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the node is incomplete.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The newly created node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Operator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* NewNode(const Operator* op, int input_count, Node* const* inputs,\n                bool incomplete = false);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"NewNode\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Template method for creating new nodes with a static number of inputs.\",\n                \"logic\": \"Creates a new node with a fixed number of input nodes using template metaprogramming. Uses a requires clause to ensure proper argument types.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The operator associated with the node.\"\n                    },\n                    {\n                        \"name\": \"nodes\",\n                        \"type\": \"Nodes...\",\n                        \"purpose\": \"Variadic list of input nodes.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The newly created node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Operator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  template <typename... Nodes>\n  Node* NewNode(const Operator* op, Nodes... nodes)\n    requires(std::conjunction_v<std::is_convertible<Nodes, Node*>...>)\n  {\n    std::array<Node*, sizeof...(nodes)> nodes_arr{\n        {static_cast<Node*>(nodes)...}};\n    return NewNode(op, nodes_arr.size(), nodes_arr.data());\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CloneNode\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Clones a node in the graph.\",\n                \"logic\": \"Creates a copy of the given node and assigns a new node ID to the copy.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"const Node*\",\n                        \"purpose\": \"The node to clone.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The cloned node.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* CloneNode(const Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"zone\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Returns the memory zone associated with the graph.\",\n                \"logic\": \"Returns the pointer to the zone_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Zone*\",\n                    \"description\": \"The memory zone of the graph.\"\n                },\n                \"dependencies\": [\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Zone* zone() const { return zone_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"start\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Returns the start node of the graph.\",\n                \"logic\": \"Returns the pointer to the start_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The start node of the graph.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* start() const { return start_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"end\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Returns the end node of the graph.\",\n                \"logic\": \"Returns the pointer to the end_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The end node of the graph.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* end() const { return end_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetStart\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Sets the start node of the graph.\",\n                \"logic\": \"Sets the value of the start_ member.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"start\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The new start node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void SetStart(Node* start) { start_ = start; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetEnd\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Sets the end node of the graph.\",\n                \"logic\": \"Sets the value of the end_ member.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"end\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The new end node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void SetEnd(Node* end) { end_ = end; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"NodeCount\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Returns the number of nodes in the graph.\",\n                \"logic\": \"Returns the value of the next_node_id_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The number of nodes in the graph.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  size_t NodeCount() const { return next_node_id_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Decorate\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Applies decorators to the given node.\",\n                \"logic\": \"Iterates through the list of decorators and calls the Decorate method on each one.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to decorate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"GraphDecorator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void Decorate(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddDecorator\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Adds a decorator to the list of decorators.\",\n                \"logic\": \"Adds the given decorator to the decorators_ vector.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"decorator\",\n                        \"type\": \"GraphDecorator*\",\n                        \"purpose\": \"The decorator to add.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"GraphDecorator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void AddDecorator(GraphDecorator* decorator);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RemoveDecorator\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Removes a decorator from the list of decorators.\",\n                \"logic\": \"Removes the given decorator from the decorators_ vector.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"decorator\",\n                        \"type\": \"GraphDecorator*\",\n                        \"purpose\": \"The decorator to remove.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"GraphDecorator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void RemoveDecorator(GraphDecorator* decorator);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Print\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Prints the graph for debugging purposes.\",\n                \"logic\": \"Provides a simple print API for debugging.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  // Very simple print API usable in a debugger.\n  void Print() const;\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HasSimd\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Checks if the graph contains SIMD operations.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the graph has SIMD operations, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  bool HasSimd() const { return has_simd_; }\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetSimd\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Sets the SIMD flag for the graph.\",\n                \"parameters\": [\n                                        {\n                        \"name\": \"has_simd\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"The new value of the SIMD flag.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  void SetSimd(bool has_simd) { has_simd_ = has_simd; }\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RecordSimdStore\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Records a SIMD store node.\",\n                \"parameters\": [\n                                        {\n                        \"name\": \"store\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The SIMD store node to record.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                                        \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void RecordSimdStore(Node* store);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetSimdStoreNodes\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Returns the vector of SIMD store nodes.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"ZoneVector<Node*> const&\",\n                    \"description\": \"The vector of SIMD store nodes.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"ZoneVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  ZoneVector<Node*> const& GetSimdStoreNodes();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"NextNodeId\",\n                \"parent\": \"TFGraph\",\n                \"about\": \"Generates the next unique NodeId.\",\n                \"logic\": \"Increments and returns the next_node_id_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"NodeId\",\n                    \"description\": \"The next unique NodeId.\"\n                },\n                \"dependencies\": [\n                    \"NodeId\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  inline NodeId NextNodeId();\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ZoneObject\",\n                    \"about\": \"Base class for objects allocated in a Zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ZoneObject {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Zone\",\n                    \"about\": \"A memory allocation arena.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Zone {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Node\",\n                    \"about\": \"Represents a node in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Node {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Operator\",\n                    \"about\": \"Describes the operation performed by a node.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Operator {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ZoneVector\",\n                    \"about\": \"A vector-like container that allocates memory from a Zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> class ZoneVector {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}