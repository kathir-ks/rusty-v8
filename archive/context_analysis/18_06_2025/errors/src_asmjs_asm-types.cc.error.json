{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-types.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 449, column 47",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-types.cc\",\n        \"file_name\": \"asm-types.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the AsmType hierarchy and related classes for representing types in asm.js.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for asm.js types and standard integer types.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/asmjs/asm-types.h\"\n            #include <cinttypes>\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AsCallableType\",\n            \"parent\": \"AsmType\",\n            \"about\": \"Casts an AsmType to an AsmCallableType if possible.\",\n            \"logic\": \"Checks if the current type is not a value type. If it's not a value type, it assumes it's a callable type and performs a reinterpret cast.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"AsmCallableType*\",\n                \"description\": \"A pointer to the AsmCallableType, or nullptr if the type is not callable.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            AsmCallableType* AsmType::AsCallableType() {\n            if (AsValueType() != nullptr) {\n                return nullptr;\n            }\n\n            return reinterpret_cast<AsmCallableType*>(this);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Name\",\n            \"parent\": \"AsmType\",\n            \"about\": \"Returns a string representation of the AsmType.\",\n            \"logic\": \"If the type is a value type, it uses a switch statement to return the corresponding name. Otherwise, it delegates to the AsmCallableType::Name() method.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The name of the type as a string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            std::string AsmType::Name() {\n            AsmValueType* avt = this->AsValueType();\n            if (avt != nullptr) {\n                switch (avt->Bitset()) {\n            #define RETURN_TYPE_NAME(CamelName, string_name, number, parent_types) \\\n            case AsmValueType::kAsm##CamelName:                                  \\\n                return string_name;\n                FOR_EACH_ASM_VALUE_TYPE_LIST(RETURN_TYPE_NAME)\n            #undef RETURN_TYPE_NAME\n                default:\n                UNREACHABLE();\n                }\n            }\n\n            return this->AsCallableType()->Name();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsExactly\",\n            \"parent\": \"AsmType\",\n            \"about\": \"Checks if two AsmTypes are exactly the same.\",\n            \"logic\": \"Compares the bitsets of two AsmValueTypes if both are value types. Otherwise, it simply compares the pointers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"x\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The first type to compare.\"\n                },\n                {\n                    \"name\": \"y\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The second type to compare.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the types are exactly the same, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool AsmType::IsExactly(AsmType* x, AsmType* y) {\n            // TODO(jpp): maybe this can become x == y.\n            if (x == nullptr) return y == nullptr;\n            AsmValueType* avt = x->AsValueType();\n            if (avt != nullptr) {\n                AsmValueType* tavt = y->AsValueType();\n                if (tavt == nullptr) {\n                return false;\n                }\n                return avt->Bitset() == tavt->Bitset();\n            }\n\n            // TODO(jpp): is it useful to allow non-value types to be tested with\n            // IsExactly?\n            return x == y;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsA\",\n            \"parent\": \"AsmType\",\n            \"about\": \"Checks if one AsmType is a subtype of another (inheritance relationship).\",\n            \"logic\": \"For value types, it checks if the bitset of the first type contains the bitset of the second type. Otherwise, if it's a callable type, it delegates to the AsmCallableType::IsA() method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"that\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The potential supertype.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if 'this' is a subtype of 'that', false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool AsmType::IsA(AsmType* that) {\n            // IsA is used for querying inheritance relationships. Therefore it is only\n            // meaningful for basic types.\n            if (auto* avt = this->AsValueType()) {\n                if (auto* tavt = that->AsValueType()) {\n                return (avt->Bitset() & tavt->Bitset()) == tavt->Bitset();\n                }\n                return false;\n            }\n\n            if (auto* as_callable = this->AsCallableType()) {\n                return as_callable->IsA(that);\n            }\n\n            UNREACHABLE();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ElementSizeInBytes\",\n            \"parent\": \"AsmType\",\n            \"about\": \"Returns the element size in bytes for array types.\",\n            \"logic\": \"Uses a switch statement to determine the element size based on the AsmValueType. Returns kNotHeapType if not a heap type.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"int32_t\",\n                \"description\": \"The size of the element in bytes, or kNotHeapType if not applicable.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            int32_t AsmType::ElementSizeInBytes() {\n            auto* value = AsValueType();\n            if (value == nullptr) {\n                return AsmType::kNotHeapType;\n            }\n            switch (value->Bitset()) {\n                case AsmValueType::kAsmInt8Array:\n                case AsmValueType::kAsmUint8Array:\n                return 1;\n                case AsmValueType::kAsmInt16Array:\n                case AsmValueType::kAsmUint16Array:\n                return 2;\n                case AsmValueType::kAsmInt32Array:\n                case AsmValueType::kAsmUint32Array:\n                case AsmValueType::kAsmFloat32Array:\n                return 4;\n                case AsmValueType::kAsmFloat64Array:\n                return 8;\n                default:\n                return AsmType::kNotHeapType;\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LoadType\",\n            \"parent\": \"AsmType\",\n            \"about\": \"Returns the type to use when loading from an array.\",\n            \"logic\": \"Returns Intish for integer arrays, FloatQ for float32 arrays, DoubleQ for float64 arrays, and None otherwise.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"AsmType*\",\n                \"description\": \"The type to use when loading from the array.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            AsmType* AsmType::LoadType() {\n            auto* value = AsValueType();\n            if (value == nullptr) {\n                return AsmType::None();\n            }\n            switch (value->Bitset()) {\n                case AsmValueType::kAsmInt8Array:\n                case AsmValueType::kAsmUint8Array:\n                case AsmValueType::kAsmInt16Array:\n                case AsmValueType::kAsmUint16Array:\n                case AsmValueType::kAsmInt32Array:\n                case AsmValueType::kAsmUint32Array:\n                return AsmType::Intish();\n                case AsmValueType::kAsmFloat32Array:\n                return AsmType::FloatQ();\n                case AsmValueType::kAsmFloat64Array:\n                return AsmType::DoubleQ();\n                default:\n                return AsmType::None();\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"StoreType\",\n            \"parent\": \"AsmType\",\n            \"about\": \"Returns the type to use when storing to an array.\",\n            \"logic\": \"Returns Intish for integer arrays, FloatishDoubleQ for float32 arrays, FloatQDoubleQ for float64 arrays, and None otherwise.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"AsmType*\",\n                \"description\": \"The type to use when storing to the array.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            AsmType* AsmType::StoreType() {\n            auto* value = AsValueType();\n            if (value == nullptr) {\n                return AsmType::None();\n            }\n            switch (value->Bitset()) {\n                case AsmValueType::kAsmInt8Array:\n                case AsmValueType::kAsmUint8Array:\n                case AsmValueType::kAsmInt16Array:\n                case AsmValueType::kAsmUint16Array:\n                case AsmValueType::kAsmInt32Array:\n                case AsmValueType::kAsmUint32Array:\n                return AsmType::Intish();\n                case AsmValueType::kAsmFloat32Array:\n                return AsmType::FloatishDoubleQ();\n                case AsmValueType::kAsmFloat64Array:\n                return AsmType::FloatQDoubleQ();\n                default:\n                return AsmType::None();\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsA\",\n            \"parent\": \"AsmCallableType\",\n            \"about\": \"Checks if this AsmCallableType is a subtype of another AsmType.\",\n            \"logic\": \"Checks if the other type is the same as this one.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The type to check against.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the types are the same, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool AsmCallableType::IsA(AsmType* other) {\n            return other->AsCallableType() == this;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Name\",\n            \"parent\": \"AsmFunctionType\",\n            \"about\": \"Returns the name of the AsmFunctionType as a string.\",\n            \"logic\": \"Constructs a string representation of the function type, including the argument types and return type.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The name of the function type.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            std::string AsmFunctionType::Name() {\n            std::string ret;\n            ret += \"(\";\n            for (size_t ii = 0; ii < args_.size(); ++ii) {\n                ret += args_[ii]->Name();\n                if (ii != args_.size() - 1) {\n                ret += \", \";\n                }\n            }\n            ret += \") -> \";\n            ret += return_type_->Name();\n            return ret;\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsmFroundType\",\n            \"extends\": \"AsmCallableType\",\n            \"about\": \"Represents the fround type in asm.js.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n            class AsmFroundType final : public AsmCallableType {\n            public:\n            friend AsmType;\n\n            AsmFroundType() : AsmCallableType() {}\n\n            bool CanBeInvokedWith(AsmType* return_type,\n                                const ZoneVector<AsmType*>& args) override;\n\n            std::string Name() override { return \"fround\"; }\n            };\n            }  // namespace\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FroundType\",\n            \"parent\": \"AsmType\",\n            \"about\": \"Creates a new AsmFroundType.\",\n            \"logic\": \"Allocates a new AsmFroundType on the given zone.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate the type on.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AsmType*\",\n                \"description\": \"A pointer to the new AsmFroundType.\"\n            },\n            \"dependencies\": [\n                \"AsmFroundType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            AsmType* AsmType::FroundType(Zone* zone) {\n            auto* Fround = zone->New<AsmFroundType>();\n            return reinterpret_cast<AsmType*>(Fround);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CanBeInvokedWith\",\n            \"parent\": \"AsmFroundType\",\n            \"about\": \"Determines if the fround type can be invoked with the given return type and arguments.\",\n            \"logic\": \"Checks that there is exactly one argument and that the argument is a Floatish, DoubleQ, Signed, or Unsigned type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"return_type\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The return type of the invocation.\"\n                },\n                {\n                    \"name\": \"args\",\n                    \"type\": \"ZoneVector<AsmType*>&\",\n                    \"purpose\": \"The arguments of the invocation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the fround type can be invoked with the given types, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool AsmFroundType::CanBeInvokedWith(AsmType* return_type,\n                                        const ZoneVector<AsmType*>& args) {\n            if (args.size() != 1) {\n                return false;\n            }\n\n            auto* arg = args[0];\n            if (!arg->IsA(AsmType::Floatish()) && !arg->IsA(AsmType::DoubleQ()) &&\n                !arg->IsA(AsmType::Signed()) && !arg->IsA(AsmType::Unsigned())) {\n                return false;\n            }\n\n            return true;\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsmMinMaxType\",\n            \"extends\": \"AsmCallableType\",\n            \"about\": \"Represents the min/max type in asm.js.\",\n            \"attributes\": [\n                {\n                    \"name\": \"return_type_\",\n                    \"type\": \"AsmType*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The return type of the min/max function.\"\n                },\n                {\n                    \"name\": \"arg_\",\n                    \"type\": \"AsmType*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The argument type of the min/max function.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n            class AsmMinMaxType final : public AsmCallableType {\n            private:\n            friend AsmType;\n            friend Zone;\n\n            AsmMinMaxType(AsmType* dest, AsmType* src)\n                : AsmCallableType(), return_type_(dest), arg_(src) {}\n\n            bool CanBeInvokedWith(AsmType* return_type,\n                                const ZoneVector<AsmType*>& args) override {\n                if (!AsmType::IsExactly(return_type_, return_type)) {\n                return false;\n                }\n\n                if (args.size() < 2) {\n                return false;\n                }\n\n                for (size_t ii = 0; ii < args.size(); ++ii) {\n                if (!args[ii]->IsA(arg_)) {\n                    return false;\n                }\n                }\n\n                return true;\n            }\n\n            std::string Name() override {\n                return \"(\" + arg_->Name() + \", \" + arg_->Name() + \"...) -> \" +\n                    return_type_->Name();\n            }\n\n            AsmType* return_type_;\n            AsmType* arg_;\n            };\n            }  // namespace\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MinMaxType\",\n            \"parent\": \"AsmType\",\n            \"about\": \"Creates a new AsmMinMaxType.\",\n            \"logic\": \"Allocates a new AsmMinMaxType on the given zone with the specified return and argument types.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate the type on.\"\n                },\n                {\n                    \"name\": \"dest\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The return type of the min/max function.\"\n                },\n                {\n                    \"name\": \"src\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The argument type of the min/max function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AsmType*\",\n                \"description\": \"A pointer to the new AsmMinMaxType.\"\n            },\n            \"dependencies\": [\n                \"AsmMinMaxType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            AsmType* AsmType::MinMaxType(Zone* zone, AsmType* dest, AsmType* src) {\n            DCHECK_NOT_NULL(dest->AsValueType());\n            DCHECK_NOT_NULL(src->AsValueType());\n            auto* MinMax = zone->New<AsmMinMaxType>(dest, src);\n            return reinterpret_cast<AsmType*>(MinMax);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsA\",\n            \"parent\": \"AsmFunctionType\",\n            \"about\": \"Checks if this AsmFunctionType is a subtype of another AsmType.\",\n            \"logic\": \"Checks if the other type is an AsmFunctionType with the same return type and argument types.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The type to check against.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the types are the same, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool AsmFunctionType::IsA(AsmType* other) {\n            auto* that = other->AsFunctionType();\n            if (that == nullptr) {\n                return false;\n            }\n            if (!AsmType::IsExactly(return_type_, that->return_type_)) {\n                return false;\n            }\n\n            if (args_.size() != that->args_.size()) {\n                return false;\n            }\n\n            for (size_t ii = 0; ii < args_.size(); ++ii) {\n                if (!AsmType::IsExactly(args_[ii], that->args_[ii])) {\n                return false;\n                }\n            }\n\n            return true;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CanBeInvokedWith\",\n            \"parent\": \"AsmFunctionType\",\n            \"about\": \"Determines if the function type can be invoked with the given return type and arguments.\",\n            \"logic\": \"Checks that the return type and argument types match the function type's signature.\",\n            \"parameters\": [\n                {\n                    \"name\": \"return_type\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The return type of the invocation.\"\n                },\n                {\n                    \"name\": \"args\",\n                    \"type\": \"ZoneVector<AsmType*>&\",\n                    \"purpose\": \"The arguments of the invocation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the function type can be invoked with the given types, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool AsmFunctionType::CanBeInvokedWith(AsmType* return_type,\n                                            const ZoneVector<AsmType*>& args) {\n            if (!AsmType::IsExactly(return_type_, return_type)) {\n                return false;\n            }\n\n            if (args_.size() != args.size()) {\n                return false;\n            }\n\n            for (size_t ii = 0; ii < args_.size(); ++ii) {\n                if (!args[ii]->IsA(args_[ii])) {\n                return false;\n                }\n            }\n\n            return true;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Name\",\n            \"parent\": \"AsmOverloadedFunctionType\",\n            \"about\": \"Returns the name of the AsmOverloadedFunctionType as a string.\",\n            \"logic\": \"Concatenates the names of all overloaded function types, separated by ' /\\\\ '.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The name of the overloaded function type.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            std::string AsmOverloadedFunctionType::Name() {\n            std::string ret;\n\n            for (size_t ii = 0; ii < overloads_.size(); ++ii) {\n                if (ii != 0) {\n                ret += \" /\\\\ \";\n                }\n                ret += overloads_[ii]->Name();\n            }\n\n            return ret;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CanBeInvokedWith\",\n            \"parent\": \"AsmOverloadedFunctionType\",\n            \"about\": \"Determines if the overloaded function type can be invoked with the given return type and arguments.\",\n            \"logic\": \"Checks if any of the overloaded function types can be invoked with the given types.\",\n            \"parameters\": [\n                {\n                    \"name\": \"return_type\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The return type of the invocation.\"\n                },\n                {\n                    \"name\": \"args\",\n                    \"type\": \"ZoneVector<AsmType*>&\",\n                    \"purpose\": \"The arguments of the invocation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the overloaded function type can be invoked with the given types, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool AsmOverloadedFunctionType::CanBeInvokedWith(\n                AsmType* return_type, const ZoneVector<AsmType*>& args) {\n            for (size_t ii = 0; ii < overloads_.size(); ++ii) {\n                if (overloads_[ii]->AsCallableType()->CanBeInvokedWith(return_type, args)) {\n                return true;\n                }\n            }\n\n            return false;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddOverload\",\n            \"parent\": \"AsmOverloadedFunctionType\",\n            \"about\": \"Adds an overload to the AsmOverloadedFunctionType.\",\n            \"logic\": \"Adds the given AsmType to the list of overloads.\",\n            \"parameters\": [\n                {\n                    \"name\": \"overload\",\n                    \"type\": \"AsmType*\",\n                    \"purpose\": \"The overload to add.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void AsmOverloadedFunctionType::AddOverload(AsmType* overload) {\n            DCHECK_NOT_NULL(overload->AsCallableType());\n            overloads_.push_back(overload);\n            }\n        ]]></code>\n    </func>\n</file>\n```"
}