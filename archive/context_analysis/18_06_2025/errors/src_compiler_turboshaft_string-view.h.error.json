{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/string-view.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 82, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/string-view.h\",\n        \"file_name\": \"string-view.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements StringView class for iterating over string characters in the Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes operations definitions required for assembler instructions\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/turboshaft/operations.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StringView\",\n            \"about\": \"Implements the `ForeachIterable` concept for iterating the characters of a string.\",\n            \"attributes\": [\n                {\n                    \"name\": \"string_\",\n                    \"type\": \"V<String>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The string being viewed.\"\n                },\n                {\n                    \"name\": \"encoding_\",\n                    \"type\": \"String::Encoding\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The encoding of the string (ONE_BYTE_ENCODING or TWO_BYTE_ENCODING).\"\n                },\n                {\n                    \"name\": \"start_index_\",\n                    \"type\": \"ConstOrV<WordPtr>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The starting index for the view.\"\n                },\n                {\n                    \"name\": \"character_count_\",\n                    \"type\": \"ConstOrV<WordPtr>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of characters in the view.\"\n                },\n                {\n                    \"name\": \"end_offset_\",\n                    \"type\": \"V<WordPtr>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The calculated end offset for iteration.\"\n                },\n                {\n                    \"name\": \"can_rely_on_no_gc_\",\n                    \"type\": \"const DisallowGarbageCollection*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to DisallowGarbageCollection object, indicates if GC can occur during iteration\"\n                }\n            ],\n            \"dependencies\": [\n                \"V\",\n                \"String\",\n                \"WordPtr\",\n                \"Word32\",\n                \"ConstOrV\",\n                \"DisallowGarbageCollection\",\n                \"SeqOneByteString\",\n                \"SeqTwoByteString\",\n                \"OFFSET_OF_DATA_START\",\n                \"kHeapObjectTag\",\n                \"MemoryRepresentation\",\n                \"LoadOp\",\n                \"OptionalV\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class StringView {\n            public:\n            using value_type = V<Word32>;\n            using iterator_type = V<WordPtr>;\n\n            StringView(const DisallowGarbageCollection& can_rely_on_no_gc,\n                        V<String> string, String::Encoding encoding,\n                        ConstOrV<WordPtr> start_index = 0,\n                        ConstOrV<WordPtr> character_count = V<WordPtr>::Invalid())\n                : string_(string),\n                    encoding_(encoding),\n                    start_index_(start_index),\n                    character_count_(character_count),\n                    can_rely_on_no_gc_(&can_rely_on_no_gc) {}\n\n            StringView(V<String> string, String::Encoding encoding,\n                        ConstOrV<WordPtr> start_index = 0,\n                        ConstOrV<WordPtr> character_count = V<WordPtr>::Invalid())\n                : string_(string),\n                    encoding_(encoding),\n                    start_index_(start_index),\n                    character_count_(character_count),\n                    can_rely_on_no_gc_(nullptr) {}\n\n            template <typename A>\n            iterator_type Begin(A& assembler) {\n                static_assert(OFFSET_OF_DATA_START(SeqOneByteString) ==\n                            OFFSET_OF_DATA_START(SeqTwoByteString));\n                const size_t data_offset = OFFSET_OF_DATA_START(SeqOneByteString);\n                const int stride = (encoding_ == String::ONE_BYTE_ENCODING ? 1 : 2);\n                if (can_rely_on_no_gc_ == nullptr) {\n                // TODO(nicohartmann): If we cannot rely on no GC happening during\n                // iteration, we cannot operate on raw inner pointers but have to\n                // recompute the character address from the base on each dereferencing.\n                UNIMPLEMENTED();\n                }\n                V<WordPtr> begin_offset = assembler.WordPtrAdd(\n                    assembler.BitcastTaggedToWordPtr(string_),\n                    assembler.WordPtrAdd(\n                        data_offset - kHeapObjectTag,\n                        assembler.WordPtrMul(assembler.resolve(start_index_), stride)));\n                V<WordPtr> count;\n                if (character_count_.is_constant()) {\n                count = assembler.resolve(character_count_);\n                } else if (character_count_.value().valid()) {\n                count = character_count_.value();\n                } else {\n                // TODO(nicohartmann): Load from string.\n                UNIMPLEMENTED();\n                }\n                end_offset_ =\n                    assembler.WordPtrAdd(begin_offset, assembler.WordPtrMul(count, stride));\n                return begin_offset;\n            }\n\n            template <typename A>\n            OptionalV<Word32> IsEnd(A& assembler, iterator_type current_iterator) const {\n                return assembler.UintPtrLessThanOrEqual(end_offset_, current_iterator);\n            }\n\n            template <typename A>\n            iterator_type Advance(A& assembler, iterator_type current_iterator) const {\n                const int stride = (encoding_ == String::ONE_BYTE_ENCODING ? 1 : 2);\n                return assembler.WordPtrAdd(current_iterator, stride);\n            }\n\n            template <typename A>\n            value_type Dereference(A& assembler, iterator_type current_iterator) const {\n                const auto loaded_rep = encoding_ == String::ONE_BYTE_ENCODING\n                                    ? MemoryRepresentation::Uint8()\n                                    : MemoryRepresentation::Uint16();\n                return assembler.Load(current_iterator, LoadOp::Kind::RawAligned(),\n                                    loaded_rep);\n            }\n\n            private:\n            V<String> string_;\n            String::Encoding encoding_;\n            ConstOrV<WordPtr> start_index_;\n            ConstOrV<WordPtr> character_count_;\n            V<WordPtr> end_offset_;\n            const DisallowGarbageCollection* can_rely_on_no_gc_;\n            };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"V\",\n                \"about\": \"Template class representing a value in the Turboshaft graph. Requires special handling during migration.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class V {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"String\",\n                \"about\": \"Represents a string in the V8 heap. Migration needs to account for V8's string representation.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class String {\n                public:\n                    enum Encoding {\n                        ONE_BYTE_ENCODING,\n                        TWO_BYTE_ENCODING\n                    };\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WordPtr\",\n                \"about\": \"Represents a machine word pointer. Migration should consider target architecture's word size.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class WordPtr {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Word32\",\n                \"about\": \"Represents a 32-bit word. Migration should be aware of potential differences in integer sizes.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class Word32 {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ConstOrV\",\n                \"about\": \"Represents a value that can be either a constant or a 'V' type.\",\n                \"dependencies\": [\n                    \"V\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class ConstOrV {\n                public:\n                    bool is_constant() const { return false; }\n                    V<T> value() const { return V<T>(); }\n                    T resolve() const { return T(); }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DisallowGarbageCollection\",\n                \"about\": \"Used to disallow garbage collection within a specific scope.  This impacts memory management strategies during migration.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class DisallowGarbageCollection {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SeqOneByteString\",\n                \"about\": \"Represents a one-byte encoded string.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class SeqOneByteString {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SeqTwoByteString\",\n                \"about\": \"Represents a two-byte encoded string.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class SeqTwoByteString {};\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"OFFSET_OF_DATA_START\",\n                \"about\": \"Macro or function that returns the offset of the data start within a string object.  This offset is crucial for accessing string data and must be adapted to the target environment's memory layout.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                #define OFFSET_OF_DATA_START(type) 16\n            ]]></code>\n        </func>\n        <variable>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constant\",\n                \"name\": \"kHeapObjectTag\",\n                \"about\": \"Represents the heap object tag.  This is a V8 specific constant and needs careful consideration in migration.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                const int kHeapObjectTag = 1;\n            ]]></code>\n        </variable>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MemoryRepresentation\",\n                \"about\": \"Describes the memory representation of a value (e.g., Uint8, Uint16). Migration requires ensuring correct data type mappings.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class MemoryRepresentation {\n                public:\n                    static MemoryRepresentation Uint8() { return MemoryRepresentation(); }\n                    static MemoryRepresentation Uint16() { return MemoryRepresentation(); }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoadOp\",\n                \"about\": \"Describes the load operation. Migration requires ensuring correct memory access semantics.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class LoadOp {\n                public:\n                    enum class Kind {\n                        RawAligned\n                    };\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OptionalV\",\n                \"about\": \"Template class representing an optional value in the Turboshaft graph. Requires special handling during migration.\",\n                \"dependencies\": [\n                    \"V\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class OptionalV {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}