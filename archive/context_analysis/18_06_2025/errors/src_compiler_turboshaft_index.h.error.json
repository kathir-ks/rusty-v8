{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/index.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/index.h\",\n        \"file_name\": \"index.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines index types (OpIndex, BlockIndex) and related utilities for Turboshaft compiler intermediate representation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers for integer types, containers, type traits, and V8 specific headers for logging, codegen, compiler utilities, object representation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stdint.h>\n\n            #include <cstddef>\n            #include <optional>\n            #include <type_traits>\n\n            #include \"src/base/logging.h\"\n            #include \"src/codegen/tnode.h\"\n            #include \"src/compiler/turboshaft/fast-hash.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n            #include \"src/objects/heap-number.h\"\n            #include \"src/objects/js-function.h\"\n            #include \"src/objects/oddball.h\"\n            #include \"src/objects/string.h\"\n            #include \"src/objects/tagged.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OpIndex\",\n            \"about\": \"Represents an index into the operations buffer.  More memory efficient and stable than raw pointers.\",\n            \"attributes\": [\n                {\n                    \"name\": \"offset_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The offset into the operations buffer.\"\n                }\n            ],\n            \"dependencies\": [\n                \"OperationBuffer\",\n                \"ConstOrV\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class OpIndex {\n            protected:\n            // We make this constructor protected so that integers are not easily\n            // convertible to OpIndex. FromOffset should be used instead to create an\n            // OpIndex from an offset.\n            explicit constexpr OpIndex(uint32_t offset) : offset_(offset) {\n                SLOW_DCHECK(CheckInvariants());\n            }\n            friend class OperationBuffer;\n\n            public:\n            static constexpr OpIndex FromOffset(uint32_t offset) {\n                return OpIndex(offset);\n            }\n            constexpr OpIndex() : offset_(std::numeric_limits<uint32_t>::max()) {}\n            template <typename T, typename C>\n            OpIndex(const ConstOrV<T, C>&) {  // NOLINT(runtime/explicit)\n                static_assert(base::tmp::lazy_false<T>::value,\n                            \"Cannot initialize OpIndex from ConstOrV<>. Did you forget \"\n                            \"to resolve() it in the assembler?\");\n            }\n\n            constexpr uint32_t id() const {\n                // Operations are stored at an offset that's a multiple of\n                // `sizeof(OperationStorageSlot)`. In addition, an operation occupies at\n                // least `kSlotsPerId` many `OperationSlot`s. Therefore, we can assign id's\n                // by dividing by `kSlotsPerId`. A compact id space is important, because it\n                // makes side-tables smaller.\n                SLOW_DCHECK(CheckInvariants());\n                return offset_ / sizeof(OperationStorageSlot) / kSlotsPerId;\n            }\n            uint32_t hash() const {\n                // It can be useful to hash OpIndex::Invalid(), so we have this `hash`\n                // function, which returns the id, but without DCHECKing that Invalid is\n                // valid.\n                SLOW_DCHECK_IMPLIES(valid(), CheckInvariants());\n                return offset_ / sizeof(OperationStorageSlot) / kSlotsPerId;\n            }\n            uint32_t offset() const {\n                SLOW_DCHECK(CheckInvariants());\n            #ifdef DEBUG\n                return offset_ & kUnmaskGenerationMask;\n            #else\n                return offset_;\n            #endif\n            }\n\n            constexpr bool valid() const { return *this != Invalid(); }\n\n            static constexpr OpIndex Invalid() { return OpIndex(); }\n\n            // Encode a sea-of-nodes node id in the `OpIndex` type.\n            // Only used for node origins that actually point to sea-of-nodes graph nodes.\n            static OpIndex EncodeTurbofanNodeId(uint32_t id) {\n                OpIndex result = OpIndex(id * sizeof(OperationStorageSlot));\n                result.offset_ += kTurbofanNodeIdFlag;\n                return result;\n            }\n            uint32_t DecodeTurbofanNodeId() const {\n                DCHECK(IsTurbofanNodeId());\n                return offset_ / sizeof(OperationStorageSlot);\n            }\n            bool IsTurbofanNodeId() const {\n                return offset_ % sizeof(OperationStorageSlot) == kTurbofanNodeIdFlag;\n            }\n\n            constexpr bool operator==(OpIndex other) const {\n                return offset_ == other.offset_;\n            }\n            constexpr bool operator!=(OpIndex other) const {\n                return offset_ != other.offset_;\n            }\n            constexpr bool operator<(OpIndex other) const {\n                return offset_ < other.offset_;\n            }\n            constexpr bool operator>(OpIndex other) const {\n                return offset_ > other.offset_;\n            }\n            constexpr bool operator<=(OpIndex other) const {\n                return offset_ <= other.offset_;\n            }\n            constexpr bool operator>=(OpIndex other) const {\n                return offset_ >= other.offset_;\n            }\n\n            #ifdef DEBUG\n            int generation_mod2() const {\n                return (offset_ & kGenerationMask) >> kGenerationMaskShift;\n            }\n            void set_generation_mod2(int generation_mod2) {\n                DCHECK_LE(generation_mod2, 1);\n                offset_ |= generation_mod2 << kGenerationMaskShift;\n            }\n\n            constexpr bool CheckInvariants() const {\n                DCHECK(valid());\n                // The second lowest significant bit of the offset is used to store the\n                // graph generation modulo 2. The lowest and 3rd lowest bits should always\n                // be 0 (as long as sizeof(OperationStorageSlot) is 8).\n                static_assert(sizeof(OperationStorageSlot) == 8);\n                return (offset_ & 0b101) == 0;\n            }\n            #endif\n\n            protected:\n            static constexpr uint32_t kGenerationMaskShift = 1;\n            static constexpr uint32_t kGenerationMask = 1 << kGenerationMaskShift;\n            static constexpr uint32_t kUnmaskGenerationMask = ~kGenerationMask;\n\n            // In DEBUG builds, the offset's second lowest bit contains the graph\n            // generation % 2, so one should keep this in mind when looking at the value\n            // of the offset.\n            uint32_t offset_;\n\n            static constexpr uint32_t kTurbofanNodeIdFlag = 1;\n\n            template <typename H>\n            friend H AbslHashValue(H h, const OpIndex& idx) {\n                return H::combine(std::move(h), idx.offset_);\n            }\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for OpIndex to allow printing OpIndex objects to an output stream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream.\"\n                },\n                {\n                    \"name\": \"idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The OpIndex to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": [\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os, OpIndex idx);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OptionalOpIndex\",\n            \"extends\": \"OpIndex\",\n            \"about\": \"A wrapper around OpIndex that represents an optional OpIndex, similar to std::optional.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class OptionalOpIndex : protected OpIndex {\n            public:\n            using OpIndex::OpIndex;\n            using OpIndex::valid;\n\n            constexpr OptionalOpIndex(OpIndex other)  // NOLINT(runtime/explicit)\n                : OpIndex(other) {}\n\n            static constexpr OptionalOpIndex Nullopt() {\n                return OptionalOpIndex{OpIndex::Invalid()};\n            }\n\n            uint32_t hash() const { return OpIndex::hash(); }\n\n            constexpr bool has_value() const { return valid(); }\n            constexpr OpIndex value() const {\n                DCHECK(has_value());\n                return OpIndex(*this);\n            }\n            constexpr OpIndex value_or_invalid() const { return OpIndex(*this); }\n\n            template <typename H>\n            friend H AbslHashValue(H h, const OptionalOpIndex& idx) {\n                return H::combine(std::move(h), idx.offset_);\n            }\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for OptionalOpIndex to allow printing OptionalOpIndex objects to an output stream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream.\"\n                },\n                {\n                    \"name\": \"idx\",\n                    \"type\": \"OptionalOpIndex\",\n                    \"purpose\": \"The OptionalOpIndex to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": [\n                \"OptionalOpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE std::ostream& operator<<(std::ostream& os, OptionalOpIndex idx) {\n            return os << idx.value_or_invalid();\n            }\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"nullrep_t\",\n            \"about\": \"Dummy value for abstract representation classes that don't have a RegisterRepresentation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct nullrep_t {};\n        ]]></code>\n    </struct>\n    <variable>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"nullrep_t\",\n            \"name\": \"nullrep\",\n            \"about\": \"constexpr variable of type nullrep_t\"\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr nullrep_t nullrep;\n        ]]></code>\n    </variable>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Equality operator for nullrep_t and RegisterRepresentation\",\n            \"parameters\": [\n                {\n                    \"name\": \"nullrep_t\",\n                    \"type\": \"nullrep_t\",\n                    \"purpose\": \"Left hand side of equality\"\n                },\n                {\n                    \"name\": \"RegisterRepresentation\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"Right hand side of equality\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if equal\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr inline bool operator==(nullrep_t, nullrep_t) { return true; }\n            constexpr inline bool operator==(nullrep_t, RegisterRepresentation) {\n            return false;\n            }\n            constexpr inline bool operator==(RegisterRepresentation, nullrep_t) {\n            return false;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Inequality operator for nullrep_t and RegisterRepresentation\",\n            \"parameters\": [\n                {\n                    \"name\": \"nullrep_t\",\n                    \"type\": \"nullrep_t\",\n                    \"purpose\": \"Left hand side of inequality\"\n                },\n                {\n                    \"name\": \"RegisterRepresentation\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"Right hand side of inequality\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if not equal\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr inline bool operator!=(nullrep_t, nullrep_t) { return false; }\n            constexpr inline bool operator!=(nullrep_t, RegisterRepresentation) {\n            return true;\n            }\n            constexpr inline bool operator!=(RegisterRepresentation, nullrep_t) {\n            return true;\n            }\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"Any\",\n            \"about\": \"Abstract tag class for V<>.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct Any {};\n        ]]></code>\n    </struct>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"None\",\n            \"about\": \"Abstract tag class for V<>.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct None {};\n        ]]></code>\n    </struct>\n    <template>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"WordWithBits\",\n            \"extends\": \"Any\",\n            \"about\": \"Abstract tag class for word types with a specific number of bits.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Bits\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The number of bits in the word.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <size_t Bits>\n            struct WordWithBits : public Any {\n            static constexpr int bits = Bits;\n            static_assert(Bits == 32 || Bits == 64 || Bits == 128 || Bits == 256);\n            };\n        ]]></code>\n    </template>\n    <type_alias>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"type alias\",\n            \"name\": \"Word32\",\n            \"about\": \"Alias for WordWithBits<32>.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            using Word32 = WordWithBits<32>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"type alias\",\n            \"name\": \"Word64\",\n            \"about\": \"Alias for WordWithBits<64>.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            using Word64 = WordWithBits<64>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"type alias\",\n            \"name\": \"WordPtr\",\n            \"about\": \"Alias for Word64 if Is64() is true, otherwise Word32.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            using WordPtr = std::conditional_t<Is64(), Word64, Word32>;\n        ]]></code>\n    </type_alias>\n    <template>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"FloatWithBits\",\n            \"extends\": \"Any\",\n            \"about\": \"Abstract tag class for float types with a specific number of bits.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Bits\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The number of bits in the float.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <size_t Bits>\n            struct FloatWithBits : public Any {  // FloatAny {\n            static constexpr int bits = Bits;\n            static_assert(Bits == 32 || Bits == 64);\n            };\n        ]]></code>\n    </template>\n    <type_alias>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"type alias\",\n            \"name\": \"Float32\",\n            \"about\": \"Alias for FloatWithBits<32>.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            using Float32 = FloatWithBits<32>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"type alias\",\n            \"name\": \"Float64\",\n            \"about\": \"Alias for FloatWithBits<64>.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            using Float64 = FloatWithBits<64>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"type alias\",\n            \"name\": \"Simd128\",\n            \"about\": \"Alias for WordWithBits<128>.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            using Simd128 = WordWithBits<128>;\n        ]]></code>\n    </type_alias>\n    <type_alias>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"type alias\",\n            \"name\": \"Simd256\",\n            \"about\": \"Alias for WordWithBits<256>.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            using Simd256 = WordWithBits<256>;\n        ]]></code>\n    </type_alias>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"Compressed\",\n            \"about\": \"Abstract tag class for compressed values.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct Compressed : public Any {};\n        ]]></code>\n    </struct>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"InternalTag\",\n            \"about\": \"Abstract tag class for internal tags.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct InternalTag : public Any {};\n        ]]></code>\n    </struct>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"FrameState\",\n            \"extends\": \"InternalTag\",\n            \"about\": \"Abstract tag class for frame state.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            struct FrameState : public InternalTag {};\n        ]]></code>\n    </struct>\n    <template>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"UntaggedUnion\",\n            \"extends\": \"Any\",\n            \"about\": \"A Union type for untagged values.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename... Ts>\n            struct UntaggedUnion : public Any {\n            using to_list_t = base::tmp::list<Ts...>;\n            };\n        ]]></code>\n    </template>\n    <template>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"Tuple\",\n            \"extends\": \"Any\",\n            \"about\": \"Represents a tuple type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Ts\",\n                    \"type\": \"typename...\",\n                    \"purpose\": \"Tuple element types.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename... Ts>\n            struct Tuple : public Any {\n            using to_list_t = base::tmp::list<Ts...>;\n            template <int Index>\n            using element_t = base::tmp::element_t<to_list_t, Index>;\n            };\n        ]]></code>\n    </template>\n    <template>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"v_traits\",\n            \"about\": \"Traits classes `v_traits<T>` to provide additional T-specific information for V<T> and ConstOrV<T>.\",\n            \"parameters\": [\n                {\n                    \"name\": \"T\",\n                    \"type\": \"typename\",\n                    \"purpose\": \"The type to provide traits for.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename = void>\n            struct v_traits;\n        ]]></code>\n    </template>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<Any>\",\n            \"about\": \"Traits specialization for the `Any` type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct v_traits<Any> {\n            static constexpr bool is_abstract_tag = true;\n            using rep_type = RegisterRepresentation;\n            static constexpr auto rep = nullrep;\n            static constexpr bool allows_representation(RegisterRepresentation) {\n                return true;\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from : std::true_type {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<None>\",\n            \"about\": \"Traits specialization for the `None` type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct v_traits<None> {\n            static constexpr bool is_abstract_tag = true;\n            using rep_type = nullrep_t;\n            static constexpr auto rep = nullrep;\n            static constexpr bool allows_representation(RegisterRepresentation) {\n                return false;\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<std::is_same_v<U, None>> {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<Compressed>\",\n            \"about\": \"Traits specialization for the `Compressed` type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct v_traits<Compressed> {\n            static constexpr bool is_abstract_tag = true;\n            using rep_type = RegisterRepresentation;\n            static constexpr auto rep = RegisterRepresentation::Compressed();\n            static constexpr bool allows_representation(\n                RegisterRepresentation maybe_allowed_rep) {\n                return maybe_allowed_rep == RegisterRepresentation::Compressed();\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<std::is_base_of_v<Compressed, U>> {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<Word32>\",\n            \"about\": \"Traits specialization for the `Word32` type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct v_traits<Word32> {\n            static constexpr bool is_abstract_tag = true;\n            using rep_type = WordRepresentation;\n            static constexpr auto rep = WordRepresentation::Word32();\n            using constexpr_type = uint32_t;\n            static constexpr bool allows_representation(\n                RegisterRepresentation maybe_allowed_rep) {\n                return maybe_allowed_rep == RegisterRepresentation::Word32();\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<std::is_base_of_v<Word32, U>> {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<Word64>\",\n            \"about\": \"Traits specialization for the `Word64` type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct v_traits<Word64> {\n            static constexpr bool is_abstract_tag = true;\n            using rep_type = WordRepresentation;\n            static constexpr auto rep = WordRepresentation::Word64();\n            using constexpr_type = uint64_t;\n            static constexpr bool allows_representation(\n                RegisterRepresentation maybe_allowed_rep) {\n                return maybe_allowed_rep == RegisterRepresentation::Word64();\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<std::is_base_of_v<Word64, U>> {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<Float32>\",\n            \"about\": \"Traits specialization for the `Float32` type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct v_traits<Float32> {\n            static constexpr bool is_abstract_tag = true;\n            using rep_type = FloatRepresentation;\n            static constexpr auto rep = FloatRepresentation::Float32();\n            using constexpr_type = float;\n            static constexpr bool allows_representation(\n                RegisterRepresentation maybe_allowed_rep) {\n                return maybe_allowed_rep == RegisterRepresentation::Float32();\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<std::is_base_of_v<Float32, U>> {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<Float64>\",\n            \"about\": \"Traits specialization for the `Float64` type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct v_traits<Float64> {\n            static constexpr bool is_abstract_tag = true;\n            using rep_type = FloatRepresentation;\n            static constexpr auto rep = FloatRepresentation::Float64();\n            using constexpr_type = double;\n            static constexpr bool allows_representation(\n                RegisterRepresentation maybe_allowed_rep) {\n                return maybe_allowed_rep == RegisterRepresentation::Float64();\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<std::is_base_of_v<Float64, U>> {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<Simd128>\",\n            \"about\": \"Traits specialization for the `Simd128` type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct v_traits<Simd128> {\n            static constexpr bool is_abstract_tag = true;\n            using rep_type = RegisterRepresentation;\n            static constexpr auto rep = RegisterRepresentation::Simd128();\n            using constexpr_type = uint8_t[kSimd128Size];\n            static constexpr bool allows_representation(\n                RegisterRepresentation maybe_allowed_rep) {\n                return maybe_allowed_rep == RegisterRepresentation::Simd128();\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<std::is_base_of_v<Simd128, U>> {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<Simd256>\",\n            \"about\": \"Traits specialization for the `Simd256` type.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct v_traits<Simd256> {\n            static constexpr bool is_abstract_tag = true;\n            using rep_type = RegisterRepresentation;\n            static constexpr auto rep = RegisterRepresentation::Simd256();\n            using constexpr_type = uint8_t[kSimd256Size];\n            static constexpr bool allows_representation(\n                RegisterRepresentation maybe_allowed_rep) {\n                return maybe_allowed_rep == RegisterRepresentation::Simd256();\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<std::is_base_of_v<Simd256, U>> {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<T>\",\n            \"about\": \"Generic traits specialization for taggable types (Objects, Strings, etc.).\",\n            \"parameters\": [\n                {\n                    \"name\": \"T\",\n                    \"type\": \"typename\",\n                    \"purpose\": \"The taggable type.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            struct v_traits<T, std::enable_if_t<is_taggable_v<T> && !is_union_v<T>>> {\n            static constexpr bool is_abstract_tag = false;\n            using rep_type = RegisterRepresentation;\n            static constexpr auto rep = RegisterRepresentation::Tagged();\n            static constexpr bool allows_representation(\n                RegisterRepresentation maybe_allowed_rep) {\n                return maybe_allowed_rep == RegisterRepresentation::Tagged();\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<is_subtype<U, T>::value> {};\n            template <typename... Us>\n            struct implicitly_constructible_from<UntaggedUnion<Us...>>\n                : std::bool_constant<(\n                    v_traits<T>::template implicitly_constructible_from<Us>::value &&\n                    ...)> {};\n            };\n        ]]></code>\n    </template_specialization>\n    <template_specialization>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct specialization\",\n            \"name\": \"v_traits<Union<T, Ts...>>\",\n            \"about\": \"Traits specialization for Union types.\",\n            \"parameters\": [\n                {\n                    \"name\": \"T\",\n                    \"type\": \"typename\",\n                    \"purpose\": \"First type of the Union.\"\n                },\n                {\n                    \"name\": \"Ts\",\n                    \"type\": \"typename...\",\n                    \"purpose\": \"Remaining types of the Union.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename... Ts>\n            struct v_traits<Union<T, Ts...>> {\n            static_assert(!v_traits<T>::is_abstract_tag);\n            static_assert((!v_traits<Ts>::is_abstract_tag && ...));\n            static constexpr bool is_abstract_tag = false;\n            static_assert(((v_traits<T>::rep == v_traits<Ts>::rep) && ...));\n            static_assert((std::is_same_v<typename v_traits<T>::rep_type,\n                                        typename v_traits<Ts>::rep_type> &&\n                        ...));\n            using rep_type = typename v_traits<T>::rep_type;\n            static constexpr auto rep = v_traits<T>::rep;\n            static constexpr bool allows_representation(\n                RegisterRepresentation maybe_allowed_rep) {\n                return maybe_allowed_rep == rep;\n            }\n\n            template <typename U>\n            struct implicitly_constructible_from\n                : std::bool_constant<(\n                    v_traits<T>::template implicitly_constructible_from<U>::value ||\n                    ... ||\n                    "
}