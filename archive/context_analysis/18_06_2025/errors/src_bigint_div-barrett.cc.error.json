{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/bigint/div-barrett.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 63, column 129",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/bigint/div-barrett.cc\",\n        \"file_name\": \"div-barrett.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements Barrett division algorithm for large integers in V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library and V8 bigint headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <algorithm>\n\n            #include \"src/bigint/bigint-internal.h\"\n            #include \"src/bigint/digit-arithmetic.h\"\n            #include \"src/bigint/div-helpers.h\"\n            #include \"src/bigint/vector-arithmetic.h\"\n        ]]></code>\n    </imports>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8::bigint\",\n            \"purpose\": \"Groups bigint related code.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            namespace bigint {\n        ]]></code>\n    </namespace>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"anonymous\",\n            \"parent\": \"v8::bigint\",\n            \"purpose\": \"Contains internal helper functions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n        ]]></code>\n    </namespace>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DcheckIntegerPartRange\",\n            \"parent\": \"anonymous\",\n            \"about\": \"Checks if the most significant digit of a number is within a given range. Used for debugging.\",\n            \"logic\": \"Uses DCHECK macro to perform checks only in debug mode.  Checks that integer_part >= min and integer_part <= max.\",\n            \"parameters\": [\n                {\n                    \"name\": \"X\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The number to check.\"\n                },\n                {\n                    \"name\": \"min\",\n                    \"type\": \"digit_t\",\n                    \"purpose\": \"The minimum allowed value for the most significant digit.\"\n                },\n                {\n                    \"name\": \"max\",\n                    \"type\": \"digit_t\",\n                    \"purpose\": \"The maximum allowed value for the most significant digit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void DcheckIntegerPartRange(Digits X, digit_t min, digit_t max) {\n            #if DEBUG\n            digit_t integer_part = X.msd();\n            DCHECK(integer_part >= min);\n            DCHECK(integer_part <= max);\n            #else\n            USE(X);\n            USE(min);\n            USE(max);\n            #endif\n            }\n        ]]></code>\n    </func>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"anonymous\",\n            \"parent\": \"v8::bigint\",\n            \"purpose\": \"Closes anonymous namespace\"\n        }\n        </metadata>\n        <code><![CDATA[\n            }  // namespace\n        ]]></code>\n    </namespace>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InvertBasecase\",\n            \"parent\": \"ProcessorImpl\",\n            \"about\": \"Computes the inverse of a large integer using naive division.\",\n            \"logic\": \"Performs division via either schoolbook or Burnikel-Ziegler algorithm based on digit length.  Calculates the fractional part of 1/V.  Employs subtraction and division.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Z\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The output: the fractional part of the inverse of V.\"\n                },\n                {\n                    \"name\": \"V\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The input: the number to invert.\"\n                },\n                {\n                    \"name\": \"scratch\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"Scratch space for intermediate calculations.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DivideSchoolbook\",\n                \"DivideBurnikelZiegler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::InvertBasecase(RWDigits Z, Digits V, RWDigits scratch) {\n            DCHECK(Z.len() > V.len());\n            DCHECK(V.len() > 0);\n            DCHECK(scratch.len() >= 2 * V.len());\n            int n = V.len();\n            RWDigits X(scratch, 0, 2 * n);\n            digit_t borrow = 0;\n            int i = 0;\n            for (; i < n; i++) X[i] = 0;\n            for (; i < 2 * n; i++) X[i] = digit_sub2(0, V[i - n], borrow, &borrow);\n            DCHECK(borrow == 1);\n            RWDigits R(nullptr, 0);  // We don't need the remainder.\n            if (n < kBurnikelThreshold) {\n                DivideSchoolbook(Z, R, X, V);\n            } else {\n                DivideBurnikelZiegler(Z, R, X, V);\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InvertNewton\",\n            \"parent\": \"ProcessorImpl\",\n            \"about\": \"Computes the inverse of a large integer using Newton's method.\",\n            \"logic\": \"Implements Algorithm 4.2 from the paper 'Fast Division of Large Integers.' It iteratively refines an initial approximation of the inverse. Uses precision doubling loop, multiplication, subtraction and shifting.  Handles truncation carefully to maintain accuracy. Implements the Newton-Raphson method for finding the inverse of a number.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Z\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The output: the inverse of V.\"\n                },\n                {\n                    \"name\": \"V\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The input: the number to invert.\"\n                },\n                {\n                    \"name\": \"scratch\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"Scratch space for intermediate calculations.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InvertNewtonScratchSpace\",\n                \"IsBitNormalized\",\n                \"InvertBasecase\",\n                \"Multiply\",\n                \"should_terminate\",\n                \"DcheckIntegerPartRange\",\n                \"LeftShift\",\n                \"SubtractAndReturnBorrow\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::InvertNewton(RWDigits Z, Digits V, RWDigits scratch) {\n            const int vn = V.len();\n            DCHECK(Z.len() >= vn);\n            DCHECK(scratch.len() >= InvertNewtonScratchSpace(vn));\n            const int kSOffset = 0;\n            const int kWOffset = 0;  // S and W can share their scratch space.\n            const int kUOffset = vn + kInvertNewtonExtraSpace;\n\n            // The base case won't work otherwise.\n            DCHECK(V.len() >= 3);\n\n            constexpr int kBasecasePrecision = kNewtonInversionThreshold - 1;\n            // V must have more digits than the basecase.\n            DCHECK(V.len() > kBasecasePrecision);\n            DCHECK(IsBitNormalized(V));\n\n            // Step (1): Setup.\n            // Calculate precision required at each step.\n            // {k} is the number of fraction bits for the current iteration.\n            int k = vn * kDigitBits;\n            int target_fraction_bits[8 * sizeof(vn)];  // \"k_i\" in the paper.\n            int iteration = -1;  // \"i\" in the paper, except inverted to run downwards.\n            while (k > kBasecasePrecision * kDigitBits) {\n                iteration++;\n                target_fraction_bits[iteration] = k;\n                k = DIV_CEIL(k, 2);\n            }\n            // At this point, k <= kBasecasePrecision*kDigitBits is the number of\n            // fraction bits to use in the base case. {iteration} is the highest index\n            // in use for f[].\n\n            // Step (2): Initial approximation.\n            int initial_digits = DIV_CEIL(k + 1, kDigitBits);\n            Digits top_part_of_v(V, vn - initial_digits, initial_digits);\n            InvertBasecase(Z, top_part_of_v, scratch);\n            Z[initial_digits] = Z[initial_digits] + 1;  // Implicit top digit.\n            // From now on, we'll keep Z.len updated to the part that's already computed.\n            Z.set_len(initial_digits + 1);\n\n            // Step (3): Precision doubling loop.\n            while (true) {\n                DcheckIntegerPartRange(Z, 1, 2);\n\n                // (3b): S = Z^2\n                RWDigits S(scratch, kSOffset, 2 * Z.len());\n                Multiply(S, Z, Z);\n                if (should_terminate()) return;\n                S.TrimOne();  // Top digit of S is unused.\n                DcheckIntegerPartRange(S, 1, 4);\n\n                // (3c): T = V, truncated so that at least 2k+3 fraction bits remain.\n                int fraction_digits = DIV_CEIL(2 * k + 3, kDigitBits);\n                int t_len = std::min(V.len(), fraction_digits);\n                Digits T(V, V.len() - t_len, t_len);\n\n                // (3d): U = T * S, truncated so that at least 2k+1 fraction bits remain\n                // (U has one integer digit, which might be zero).\n                fraction_digits = DIV_CEIL(2 * k + 1, kDigitBits);\n                RWDigits U(scratch, kUOffset, S.len() + T.len());\n                DCHECK(U.len() > fraction_digits);\n                Multiply(U, S, T);\n                if (should_terminate()) return;\n                U = U + (U.len() - (1 + fraction_digits));\n                DcheckIntegerPartRange(U, 0, 3);\n\n                // (3e): W = 2 * Z, padded with \"0\" fraction bits so that it has the\n                // same number of fraction bits as U.\n                DCHECK(U.len() >= Z.len());\n                RWDigits W(scratch, kWOffset, U.len());\n                int padding_digits = U.len() - Z.len();\n                for (int i = 0; i < padding_digits; i++) W[i] = 0;\n                LeftShift(W + padding_digits, Z, 1);\n                DcheckIntegerPartRange(W, 2, 4);\n\n                // (3f): Z = W - U.\n                // This check is '<=' instead of '<' because U's top digit is its\n                // integer part, and we want vn fraction digits.\n                if (U.len() <= vn) {\n                // Normal subtraction.\n                // This is not the last iteration.\n                DCHECK(iteration > 0);\n                Z.set_len(U.len());\n                digit_t borrow = SubtractAndReturnBorrow(Z, W, U);\n                DCHECK(borrow == 0);\n                USE(borrow);\n                DcheckIntegerPartRange(Z, 1, 2);\n                } else {\n                // Truncate some least significant digits so that we get vn\n                // fraction digits, and compute the integer digit separately.\n                // This is the last iteration.\n                DCHECK(iteration == 0);\n                Z.set_len(vn);\n                Digits W_part(W, W.len() - vn - 1, vn);\n                Digits U_part(U, U.len() - vn - 1, vn);\n                digit_t borrow = SubtractAndReturnBorrow(Z, W_part, U_part);\n                digit_t integer_part = W.msd() - U.msd() - borrow;\n                DCHECK(integer_part == 1 || integer_part == 2);\n                if (integer_part == 2) {\n                    // This is the rare case where the correct result would be 2.0, but\n                    // since we can't express that by returning only the fractional part\n                    // with an implicit 1-digit, we have to return [1.]9999... instead.\n                    for (int i = 0; i < Z.len(); i++) Z[i] = ~digit_t{0};\n                }\n                break;\n                }\n                // (3g, 3h): Update local variables and loop.\n                k = target_fraction_bits[iteration];\n                iteration--;\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Invert\",\n            \"parent\": \"ProcessorImpl\",\n            \"about\": \"Computes the inverse of a large integer.\",\n            \"logic\": \"Selects either Newton's method or a basecase inversion based on the size of the input.  It manages special cases and normalizes the input before inversion.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Z\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The output: the inverse of V.\"\n                },\n                {\n                    \"name\": \"V\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The input: the number to invert.\"\n                },\n                {\n                    \"name\": \"scratch\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"Scratch space for intermediate calculations.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InvertScratchSpace\",\n                \"InvertNewton\",\n                \"InvertBasecase\",\n                \"IsBitNormalized\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::Invert(RWDigits Z, Digits V, RWDigits scratch) {\n            DCHECK(Z.len() > V.len());\n            DCHECK(V.len() >= 1);\n            DCHECK(IsBitNormalized(V));\n            DCHECK(scratch.len() >= InvertScratchSpace(V.len()));\n\n            int vn = V.len();\n            if (vn >= kNewtonInversionThreshold) {\n                return InvertNewton(Z, V, scratch);\n            }\n            if (vn == 1) {\n                digit_t d = V[0];\n                digit_t dummy_remainder;\n                Z[0] = digit_div(~d, ~digit_t{0}, d, &dummy_remainder);\n                Z[1] = 0;\n            } else {\n                InvertBasecase(Z, V, scratch);\n                if (Z[vn] == 1) {\n                for (int i = 0; i < vn; i++) Z[i] = ~digit_t{0};\n                Z[vn] = 0;\n                }\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DivideBarrett\",\n            \"parent\": \"ProcessorImpl\",\n            \"about\": \"Computes the quotient and remainder of a division using Barrett's division algorithm.\",\n            \"logic\": \"Implements Algorithm 3.5 from the paper. Uses a precomputed inverse to approximate the quotient and remainder, then adjusts the results to obtain the correct values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Q\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The output: the quotient of A/B.\"\n                },\n                {\n                    \"name\": \"R\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The output: the remainder of A/B.\"\n                },\n                {\n                    \"name\": \"A\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The dividend.\"\n                },\n                {\n                    \"name\": \"B\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The divisor.\"\n                },\n                {\n                    \"name\": \"I\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"A precomputed approximation of 1/B.\"\n                },\n                {\n                    \"name\": \"scratch\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"Scratch space for intermediate calculations.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DivideBarrettScratchSpace\",\n                \"Multiply\",\n                \"should_terminate\",\n                \"Add\",\n                \"SubtractAndReturnBorrow\",\n                \"GreaterThanOrEqual\",\n                \"Subtract\",\n                \"AddAndReturnCarry\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::DivideBarrett(RWDigits Q, RWDigits R, Digits A, Digits B,\n                                            Digits I, RWDigits scratch) {\n            DCHECK(Q.len() > A.len() - B.len());\n            DCHECK(R.len() >= B.len());\n            DCHECK(A.len() > B.len());  // Careful: This is *not* '>=' !\n            DCHECK(A.len() <= 2 * B.len());\n            DCHECK(B.len() > 0);\n            DCHECK(IsBitNormalized(B));\n            DCHECK(I.len() == A.len() - B.len());\n            DCHECK(scratch.len() >= DivideBarrettScratchSpace(A.len()));\n\n            int orig_q_len = Q.len();\n\n            // (1): A1 = A with B.len fewer digits.\n            Digits A1 = A + B.len();\n            DCHECK(A1.len() == I.len());\n\n            // (2): Q = A1*I with I.len fewer digits.\n            // {I} has an implicit high digit with value 1, so we add {A1} to the high\n            // part of the multiplication result.\n            RWDigits K(scratch, 0, 2 * I.len());\n            Multiply(K, A1, I);\n            if (should_terminate()) return;\n            Q.set_len(I.len() + 1);\n            Add(Q, K + I.len(), A1);\n            // K is no longer used, can reuse {scratch} for P.\n\n            // (3): R = A - B*Q (approximate remainder).\n            RWDigits P(scratch, 0, A.len() + 1);\n            Multiply(P, B, Q);\n            if (should_terminate()) return;\n            digit_t borrow = SubtractAndReturnBorrow(R, A, Digits(P, 0, B.len()));\n            // R may be allocated wider than B, zero out any extra digits if so.\n            for (int i = B.len(); i < R.len(); i++) R[i] = 0;\n            digit_t r_high = A[B.len()] - P[B.len()] - borrow;\n\n            // Adjust R and Q so that they become the correct remainder and quotient.\n            // The number of iterations is guaranteed to be at most some very small\n            // constant, unless the caller gave us a bad approximate quotient.\n            if (r_high >> (kDigitBits - 1) == 1) {\n                // (5b): R < 0, so R += B\n                digit_t q_sub = 0;\n                do {\n                r_high += AddAndReturnCarry(R, R, B);\n                q_sub++;\n                DCHECK(q_sub <= 5);\n                } while (r_high != 0);\n                Subtract(Q, q_sub);\n            } else {\n                digit_t q_add = 0;\n                while (r_high != 0 || GreaterThanOrEqual(R, B)) {\n                // (5c): R >= B, so R -= B\n                r_high -= SubtractAndReturnBorrow(R, R, B);\n                q_add++;\n                DCHECK(q_add <= 5);\n                }\n                Add(Q, q_add);\n            }\n            // (5a): Return.\n            int final_q_len = Q.len();\n            Q.set_len(orig_q_len);\n            for (int i = final_q_len; i < orig_q_len; i++) Q[i] = 0;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DivideBarrett\",\n            \"parent\": \"ProcessorImpl\",\n            \"about\": \"Computes the quotient and remainder of a division using Barrett division. Handles cases where A can be much larger than B by dividing A into chunks and processing each chunk individually. Generalizes the previous DivideBarrett function to handle arbitrary inputs, similar to Burnikel-Ziegler division.\",\n            \"logic\": \"Normalizes the divisor B, then calls the core DivideBarrett function or performs chunked division based on the relative sizes of the dividend A and divisor B.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Q\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The output: the quotient of A/B.\"\n                },\n                {\n                    \"name\": \"R\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The output: the remainder of A/B.\"\n                },\n                {\n                    \"name\": \"A\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The dividend.\"\n                },\n                {\n                    \"name\": \"B\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The divisor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ShiftedDigits\",\n                \"Invert\",\n                \"should_terminate\",\n                \"DivideBarrettScratchSpace\",\n                \"InvertScratchSpace\",\n                \"DivideBarrett\",\n                \"PutAt\",\n                \"Normalize\",\n                \"RightShift\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::DivideBarrett(RWDigits Q, RWDigits R, Digits A, Digits B) {\n            DCHECK(Q.len() > A.len() - B.len());\n            DCHECK(R.len() >= B.len());\n            DCHECK(A.len() > B.len());  // Careful: This is *not* '>=' !\n            DCHECK(B.len() > 0);\n\n            // Normalize B, and shift A by the same amount.\n            ShiftedDigits b_normalized(B);\n            ShiftedDigits a_normalized(A, b_normalized.shift());\n            // Keep the code below more concise.\n            B = b_normalized;\n            A = a_normalized;\n\n            // The core DivideBarrett function above only supports A having at most\n            // twice as many digits as B. We generalize this to arbitrary inputs\n            // similar to Burnikel-Ziegler division by performing a t-by-1 division\n            // of B-sized chunks. It's easy to special-case the situation where we\n            // don't need to bother.\n            int barrett_dividend_length = A.len() <= 2 * B.len() ? A.len() : 2 * B.len();\n            int i_len = barrett_dividend_length - B.len();\n            ScratchDigits I(i_len + 1);  // +1 is for temporary use by Invert().\n            int scratch_len =\n                std::max(InvertScratchSpace(i_len),\n                        DivideBarrettScratchSpace(barrett_dividend_length));\n            ScratchDigits scratch(scratch_len);\n            Invert(I, Digits(B, B.len() - i_len, i_len), scratch);\n            if (should_terminate()) return;\n            I.TrimOne();\n            DCHECK(I.len() == i_len);\n            if (A.len() > 2 * B.len()) {\n                // This follows the variable names and and algorithmic steps of\n                // DivideBurnikelZiegler().\n                int n = B.len();  // Chunk length.\n                // (5): {t} is the number of B-sized chunks of A.\n                int t = DIV_CEIL(A.len(), n);\n                DCHECK(t >= 3);\n                // (6)/(7): Z is used for the current 2-chunk block to be divided by B,\n                // initialized to the two topmost chunks of A.\n                int z_len = n * 2;\n                ScratchDigits Z(z_len);\n                PutAt(Z, A + n * (t - 2), z_len);\n                // (8): For i from t-2 downto 0 do\n                int qi_len = n + 1;\n                ScratchDigits Qi(qi_len);\n                ScratchDigits Ri(n);\n                // First iteration unrolled and specialized.\n                {\n                int i = t - 2;\n                DivideBarrett(Qi, Ri, Z, B, I, scratch);\n                if (should_terminate()) return;\n                RWDigits target = Q + n * i;\n                // In the first iteration, all qi_len = n + 1 digits may be used.\n                int to_copy = std::min(qi_len, target.len());\n                for (int j = 0; j < to_copy; j++) target[j] = Qi[j];\n                for (int j = to_copy; j < target.len(); j++) target[j] = 0;\n            #if DEBUG\n                for (int j = to_copy; j < Qi.len(); j++) {\n                    DCHECK(Qi[j] == 0);\n                }\n            #endif\n                }\n                // Now loop over any remaining iterations.\n                for (int i = t - 3; i >= 0; i--) {\n                // (8b): If i > 0, set Z_(i-1) = [Ri, A_(i-1)].\n                // (De-duped with unrolled first iteration, hence reading A_(i).)\n                PutAt(Z + n, Ri, n);\n                PutAt(Z, A + n * i, n);\n                // (8a): Compute Qi, Ri such that Zi = B*Qi + Ri.\n                DivideBarrett(Qi, Ri, Z, B, I, scratch);\n                DCHECK(Qi[qi_len - 1] == 0);\n                if (should_terminate()) return;\n                // (9): Return Q = [Q_(t-2), ..., Q_0]...\n                PutAt(Q + n * i, Qi, n);\n                }\n                Ri.Normalize();\n                DCHECK(Ri.len() <= R.len());\n                // (9): ...and R = R_0 * 2^(-leading_zeros).\n                RightShift(R, Ri, b_normalized.shift());\n            } else {\n                DivideBarrett(Q, R, A, B, I, scratch);\n                if (should_terminate()) return;\n                RightShift(R, R, b_normalized.shift());\n            }\n            }\n        ]]></code>\n    </func>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8::bigint\",\n            \"purpose\": \"Closes v8::bigint namespace\"\n        }\n        </metadata>\n        <code><![CDATA[\n            }  // namespace bigint\n            }  // namespace v8\n        ]]></code>\n    </namespace>\n</file>\n```"
}