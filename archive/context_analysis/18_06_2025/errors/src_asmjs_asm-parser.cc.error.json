{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-parser.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-parser.cc\",\n            \"file_name\": \"asm-parser.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Parses asm.js code and converts it to a Wasm module\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for asm.js parsing and Wasm module building.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/asmjs/asm-parser.h\"\n\n            #include <math.h>\n            #include <string.h>\n\n            #include <algorithm>\n            #include <optional>\n\n            #include \"src/asmjs/asm-js.h\"\n            #include \"src/asmjs/asm-types.h\"\n            #include \"src/base/overflowing-math.h\"\n            #include \"src/flags/flags.h\"\n            #include \"src/numbers/conversions-inl.h\"\n            #include \"src/parsing/scanner.h\"\n            #include \"src/wasm/wasm-limits.h\"\n            #include \"src/wasm/wasm-opcodes.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AsmJsParser\",\n                \"about\": \"Parses asm.js code and converts it to a Wasm module.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating data structures.\"\n                    },\n                    {\n                        \"name\": \"scanner_\",\n                        \"type\": \"AsmJsScanner\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Scanner for tokenizing the asm.js source code.\"\n                    },\n                    {\n                        \"name\": \"module_builder_\",\n                        \"type\": \"WasmModuleBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builder for constructing the Wasm module.\"\n                    },\n                    {\n                        \"name\": \"stack_limit_\",\n                        \"type\": \"uintptr_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Limit on the stack size for parsing to prevent stack overflows.\"\n                    },\n                    {\n                        \"name\": \"block_stack_\",\n                        \"type\": \"ZoneVector<BlockInfo>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stack for managing nested blocks during parsing.\"\n                    },\n                    {\n                        \"name\": \"global_imports_\",\n                        \"type\": \"ZoneVector<GlobalImport>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of global variables imported from the external environment.\"\n                    },\n                    {\n                        \"name\": \"stdlib_name_\",\n                        \"type\": \"AsmJsScanner::token_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Token representing the 'stdlib' parameter name.\"\n                    },\n                    {\n                        \"name\": \"foreign_name_\",\n                        \"type\": \"AsmJsScanner::token_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Token representing the 'foreign' parameter name.\"\n                    },\n                    {\n                        \"name\": \"heap_name_\",\n                        \"type\": \"AsmJsScanner::token_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Token representing the 'heap' parameter name.\"\n                    },\n                    {\n                        \"name\": \"failed_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether parsing has failed.\"\n                    },\n                    {\n                        \"name\": \"failure_message_\",\n                        \"type\": \"const char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Error message in case of parsing failure.\"\n                    },\n                    {\n                        \"name\": \"failure_location_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Location of the error in the source code.\"\n                    },\n                    {\n                        \"name\": \"return_type_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The return type of currently parsed function.\"\n                    },\n                    {\n                        \"name\": \"local_var_info_\",\n                        \"type\": \"base::Vector<VarInfo>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores local variables information.\"\n                    },\n                    {\n                        \"name\": \"global_var_info_\",\n                        \"type\": \"base::Vector<VarInfo>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores global variables information.\"\n                    },\n                    {\n                        \"name\": \"stdlib_uses_\",\n                        \"type\": \"StandardMemberSet\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Standard library elements being used in the code.\"\n                    },\n                    {\n                        \"name\": \"num_globals_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Total number of global variables\"\n                    },\n                    {\n                        \"name\": \"current_function_builder_\",\n                        \"type\": \"WasmFunctionBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Wasm Function builder instance.\"\n                    },\n                    {\n                        \"name\": \"heap_access_type_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Type of the memory being accessed.\"\n                    },\n                    {\n                        \"name\": \"call_coercion_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Type to which a function return needs coercion.\"\n                    },\n                    {\n                        \"name\": \"call_coercion_position_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Position where call coercion is applied.\"\n                    },\n                    {\n                        \"name\": \"call_coercion_deferred_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Deferred coercion type.\"\n                    },\n                    {\n                        \"name\": \"call_coercion_deferred_position_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Position of deferred call coercion.\"\n                    },\n                    {\n                        \"name\": \"cached_asm_type_p_vectors_\",\n                        \"type\": \"ZoneCachedVector<AsmType*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A cache of ZoneVectors, to avoid allocation in hot code.\"\n                    },\n                    {\n                        \"name\": \"cached_valuetype_vectors_\",\n                        \"type\": \"ZoneCachedVector<ValueType>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A cache of ZoneVectors, to avoid allocation in hot code.\"\n                    },\n                    {\n                        \"name\": \"cached_token_t_vectors_\",\n                        \"type\": \"ZoneCachedVector<AsmJsScanner::token_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A cache of ZoneVectors, to avoid allocation in hot code.\"\n                    },\n                    {\n                        \"name\": \"cached_int_vectors_\",\n                        \"type\": \"ZoneCachedVector<int32_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A cache of ZoneVectors, to avoid allocation in hot code.\"\n                    },\n                    {\n                        \"name\": \"pending_label_\",\n                        \"type\": \"AsmJsScanner::token_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pending block label name.\"\n                    },\n                    {\n                        \"name\": \"function_temp_locals_offset_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Offset for temporary locals used in function.\"\n                    },\n                    {\n                        \"name\": \"function_temp_locals_used_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"How many temporary locals used in function.\"\n                    },\n                    {\n                        \"name\": \"function_temp_locals_depth_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Depth for temporary locals used in function.\"\n                    },\n                    {\n                        \"name\": \"inside_heap_assignment_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Whether the parser is currently parsing a heap assignment expression.\"\n                    },\n                    {\n                        \"name\": \"heap_access_shift_position_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Heap shift position for memory access.\"\n                    },\n                    {\n                        \"name\": \"heap_access_shift_value_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Heap shift value.\"\n                    },\n                    {\n                        \"name\": \"stdlib_dq2d_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Signature for double? -> double stdlib function.\"\n                    },\n                    {\n                        \"name\": \"stdlib_dqdq2d_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Signature for (double?, double?) -> double stdlib function.\"\n                    },\n                    {\n                        \"name\": \"stdlib_i2s_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Signature for int -> signed stdlib function.\"\n                    },\n                    {\n                        \"name\": \"stdlib_ii2s_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Signature for (int, int) -> signed stdlib function.\"\n                    },\n                    {\n                        \"name\": \"stdlib_minmax_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Signature for min/max stdlib function.\"\n                    },\n                    {\n                        \"name\": \"stdlib_abs_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Signature for abs stdlib function.\"\n                    },\n                    {\n                        \"name\": \"stdlib_ceil_like_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Signature for ceil/floor/sqrt stdlib function.\"\n                    },\n                    {\n                        \"name\": \"stdlib_fround_\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Signature for fround stdlib function.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AsmJsScanner\",\n                    \"WasmModuleBuilder\",\n                    \"Zone\",\n                    \"Utf16CharacterStream\",\n                    \"AsmType\",\n                    \"FunctionSig\",\n                    \"ValueType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class AsmJsParser {\n            public:\n                explicit AsmJsParser(Zone* zone, uintptr_t stack_limit,\n                                     Utf16CharacterStream* stream);\n\n                bool Run();\n\n            private:\n                Zone* zone_;\n                AsmJsScanner scanner_;\n                WasmModuleBuilder* module_builder_;\n                uintptr_t stack_limit_;\n                ZoneVector<BlockInfo> block_stack_;\n                ZoneVector<GlobalImport> global_imports_;\n                AsmJsScanner::token_t stdlib_name_;\n                AsmJsScanner::token_t foreign_name_;\n                AsmJsScanner::token_t heap_name_;\n                bool failed_ = false;\n                const char* failure_message_ = nullptr;\n                int failure_location_ = 0;\n                AsmType* return_type_ = nullptr;\n                base::Vector<VarInfo> local_var_info_;\n                base::Vector<VarInfo> global_var_info_;\n                StandardMemberSet stdlib_uses_;\n                size_t num_globals_ = 0;\n                WasmFunctionBuilder* current_function_builder_ = nullptr;\n                AsmType* heap_access_type_ = nullptr;\n                AsmType* call_coercion_ = nullptr;\n                size_t call_coercion_position_ = 0;\n                AsmType* call_coercion_deferred_ = nullptr;\n                size_t call_coercion_deferred_position_ = 0;\n                ZoneCachedVector<AsmType*> cached_asm_type_p_vectors_;\n                ZoneCachedVector<ValueType> cached_valuetype_vectors_;\n                ZoneCachedVector<AsmJsScanner::token_t> cached_token_t_vectors_;\n                ZoneCachedVector<int32_t> cached_int_vectors_;\n                AsmJsScanner::token_t pending_label_ = 0;\n\n                uint32_t function_temp_locals_offset_ = 0;\n                int function_temp_locals_used_ = 0;\n                int function_temp_locals_depth_ = 0;\n                bool inside_heap_assignment_ = false;\n                size_t heap_access_shift_position_ = 0;\n                uint32_t heap_access_shift_value_ = 0;\n\n                AsmType* stdlib_dq2d_ = nullptr;\n                AsmType* stdlib_dqdq2d_ = nullptr;\n                AsmType* stdlib_i2s_ = nullptr;\n                AsmType* stdlib_ii2s_ = nullptr;\n                AsmType* stdlib_minmax_ = nullptr;\n                AsmType* stdlib_abs_ = nullptr;\n                AsmType* stdlib_ceil_like_ = nullptr;\n                AsmType* stdlib_fround_ = nullptr;\n\n                void InitializeStdlibTypes();\n                FunctionSig* ConvertSignature(AsmType* return_type,\n                                               const ZoneVector<AsmType*>& params);\n\n                class V8_NODISCARD TemporaryVariableScope;\n\n                VarInfo* GetVarInfo(AsmJsScanner::token_t token);\n                uint32_t VarIndex(VarInfo* info);\n                void AddGlobalImport(base::Vector<const char> name, AsmType* type,\n                                      ValueType vtype, bool mutable_variable,\n                                      VarInfo* info);\n                void DeclareGlobal(VarInfo* info, bool mutable_variable,\n                                    AsmType* type, ValueType vtype,\n                                    WasmInitExpr init);\n                void DeclareStdlibFunc(VarInfo* info, VarKind kind,\n                                        AsmType* type);\n                uint32_t TempVariable(int index);\n                base::Vector<const char> CopyCurrentIdentifierString();\n                void SkipSemicolon();\n                void Begin(AsmJsScanner::token_t label);\n                void Loop(AsmJsScanner::token_t label);\n                void End();\n                void BareBegin(BlockKind kind, AsmJsScanner::token_t label);\n                void BareEnd();\n                int FindContinueLabelDepth(AsmJsScanner::token_t label);\n                int FindBreakLabelDepth(AsmJsScanner::token_t label);\n\n                // 6.1 ValidateModule\n                void ValidateModule();\n\n                // 6.1 ValidateModule - parameters\n                void ValidateModuleParameters();\n\n                // 6.1 ValidateModule - variables\n                void ValidateModuleVars();\n\n                // 6.1 ValidateModule - one variable\n                void ValidateModuleVar(bool mutable_variable);\n\n                // 6.1 ValidateModule - global float declaration\n                void ValidateModuleVarFromGlobal(VarInfo* info,\n                                                  bool mutable_variable);\n\n                // 6.1 ValidateModule - foreign imports\n                void ValidateModuleVarImport(VarInfo* info,\n                                              bool mutable_variable);\n\n                // 6.1 ValidateModule - one variable\n                // 9 - Standard Library - heap types\n                void ValidateModuleVarNewStdlib(VarInfo* info);\n\n                // 6.1 ValidateModule - one variable\n                // 9 - Standard Library\n                void ValidateModuleVarStdlib(VarInfo* info);\n\n                // 6.2 ValidateExport\n                void ValidateExport();\n\n                // 6.3 ValidateFunctionTable\n                void ValidateFunctionTable();\n\n                // 6.4 ValidateFunction\n                void ValidateFunction();\n\n                // 6.4 ValidateFunction\n                void ValidateFunctionParams(ZoneVector<AsmType*>* params);\n\n                // 6.4 ValidateFunction - locals\n                void ValidateFunctionLocals(size_t param_count,\n                                             ZoneVector<ValueType>* locals);\n\n                // 6.5 ValidateStatement\n                void ValidateStatement();\n\n                // 6.5.1 Block\n                void Block();\n\n                // 6.5.2 ExpressionStatement\n                void ExpressionStatement();\n\n                // 6.5.3 EmptyStatement\n                void EmptyStatement();\n\n                // 6.5.4 IfStatement\n                void IfStatement();\n\n                // 6.5.5 ReturnStatement\n                void ReturnStatement();\n\n                // 6.5.6 IterationStatement\n                bool IterationStatement();\n\n                // 6.5.6 IterationStatement - while\n                void WhileStatement();\n\n                // 6.5.6 IterationStatement - do\n                void DoStatement();\n\n                // 6.5.6 IterationStatement - for\n                void ForStatement();\n\n                // 6.5.7 BreakStatement\n                void BreakStatement();\n\n                // 6.5.8 ContinueStatement\n                void ContinueStatement();\n\n                // 6.5.9 LabelledStatement\n                void LabelledStatement();\n\n                // 6.5.10 SwitchStatement\n                void SwitchStatement();\n\n                // 6.6. ValidateCase\n                void ValidateCase();\n\n                // 6.7 ValidateDefault\n                void ValidateDefault();\n\n                // 6.8 ValidateExpression\n                AsmType* ValidateExpression();\n\n                // 6.8.1 Expression\n                AsmType* Expression(AsmType* expected);\n\n                // 6.8.2 NumericLiteral\n                AsmType* NumericLiteral();\n\n                // 6.8.3 Identifier\n                AsmType* Identifier();\n\n                // 6.8.4 CallExpression\n                AsmType* CallExpression();\n\n                // 6.8.5 MemberExpression\n                AsmType* MemberExpression();\n\n                // 6.8.6 AssignmentExpression\n                AsmType* AssignmentExpression();\n\n                // 6.8.7 UnaryExpression\n                AsmType* UnaryExpression();\n\n                // 6.8.8 MultiplicativeExpression\n                AsmType* MultiplicativeExpression();\n\n                // 6.8.9 AdditiveExpression\n                AsmType* AdditiveExpression();\n\n                // 6.8.10 ShiftExpression\n                AsmType* ShiftExpression();\n\n                // 6.8.11 RelationalExpression\n                AsmType* RelationalExpression();\n\n                // 6.8.12 EqualityExpression\n                AsmType* EqualityExpression();\n\n                // 6.8.13 BitwiseANDExpression\n                AsmType* BitwiseANDExpression();\n\n                // 6.8.14 BitwiseXORExpression\n                AsmType* BitwiseXORExpression();\n\n                // 6.8.15 BitwiseORExpression\n                AsmType* BitwiseORExpression();\n\n                // 6.8.16 ConditionalExpression\n                AsmType* ConditionalExpression();\n\n                // 6.8.17 ParenthesiedExpression\n                AsmType* ParenthesizedExpression();\n\n                // 6.9 ValidateCall\n                AsmType* ValidateCall();\n\n                // 6.9 ValidateCall - helper\n                bool PeekCall();\n\n                // 6.10 ValidateHeapAccess\n                void ValidateHeapAccess();\n\n                // 6.11 ValidateFloatCoercion\n                void ValidateFloatCoercion();\n\n                void ScanToClosingParenthesis();\n\n                void GatherCases(ZoneVector<int32_t>* cases);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AsmJsParser::TemporaryVariableScope\",\n                \"about\": \"Manages the scope of temporary variables used during asm.js parsing.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"parser_\",\n                        \"type\": \"AsmJsParser*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the AsmJsParser instance.\"\n                    },\n                    {\n                        \"name\": \"local_depth_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The local depth used to allocate temporary local variable.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AsmJsParser\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_NODISCARD AsmJsParser::TemporaryVariableScope {\n            public:\n              explicit TemporaryVariableScope(AsmJsParser* parser) : parser_(parser) {\n                local_depth_ = parser_->function_temp_locals_depth_;\n                parser_->function_temp_locals_depth_++;\n              }\n              ~TemporaryVariableScope() {\n                DCHECK_EQ(local_depth_, parser_->function_temp_locals_depth_ - 1);\n                parser_->function_temp_locals_depth_--;\n              }\n              uint32_t get() const { return parser_->TempVariable(local_depth_); }\n\n            private:\n              AsmJsParser* parser_;\n              int local_depth_;\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"AsmJsParser::BlockInfo\",\n                \"about\": \"Structure to store information about a block.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"BlockKind\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Kind of the block.\"\n                    },\n                    {\n                        \"name\": \"label\",\n                        \"type\": \"AsmJsScanner::token_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Label of the block.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BlockKind\",\n                    \"AsmJsScanner\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct BlockInfo {\n              BlockKind kind;\n              AsmJsScanner::token_t label;\n            };\n        ]]></code>\n    </struct>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"AsmJsParser::VarInfo\",\n                \"about\": \"Stores information about a variable.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"VarKind\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Kind of the variable.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"AsmType*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Type of the variable.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Index of the variable in the Wasm module.\"\n                    },\n                    {\n                        \"name\": \"mutable_variable\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Whether the variable is mutable.\"\n                    },\n                    {\n                        \"name\": \"function_builder\",\n                        \"type\": \"WasmFunctionBuilder*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Builder to construct function.\"\n                    },\n                    {\n                        \"name\": \"function_defined\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Whether the function is defined.\"\n                    },\n                    {\n                        \"name\": \"import\",\n                        \"type\": \"FunctionImportInfo*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Function import info instance.\"\n                    },\n                    {\n                        \"name\": \"mask\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Mask of function table.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"VarKind\",\n                    \"AsmType\",\n                    \"WasmFunctionBuilder\",\n                    \"FunctionImportInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct VarInfo {\n              VarKind kind = VarKind::kUnused;\n              AsmType* type = AsmType::None();\n              uint32_t index = 0;\n              bool mutable_variable = false;\n              WasmFunctionBuilder* function_builder = nullptr;\n              bool function_defined = false;\n              FunctionImportInfo* import = nullptr;\n              uint32_t mask = 0;\n            };\n        ]]></code>\n    </struct>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"AsmJsParser::GlobalImport\",\n                \"about\": \"Structure for storing global import information.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"import_name\",\n                        \"type\": \"base::Vector<const char>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Name of the global to import.\"\n                    },\n                    {\n                        \"name\": \"value_type\",\n                        \"type\": \"ValueType\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Type of the global to import.\"\n                    },\n                    {\n                        \"name\": \"var_info\",\n                        \"type\": \"VarInfo*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Variable info instance for global import.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ValueType\",\n                    \"VarInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct GlobalImport {\n              base::Vector<const char> import_name;\n              ValueType value_type;\n              VarInfo* var_info;\n            };\n        ]]></code>\n    </struct>\n    <dependencies>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"BlockKind\",\n                    \"about\": \"Enumerates block kinds\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum class BlockKind {\n                  kRegular,  // break only.\n                  kLoop,     // continue and break.\n                  kNamed,    // only label break supported.\n                  kOther\n                };\n            ]]></code>\n        </enum>\n        <enum>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"VarKind\",\n                    \"about\": \"Enumerates kinds for variables\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum class VarKind {\n                  kUnused,\n                  kLocal,\n                  kGlobal,\n                  kFunction,\n\n                  // These have to be in order for >= kImportedFunction to work.\n                  kImportedFunction,\n\n                  // These have to be in order for < kImportedFunction to work.\n                  kSpecial,\n                  kTable,\n                  kMathAbs,\n                  kMathMin,\n                  kMathMax,\n                  kMathFround,\n                };\n            ]]></code>\n        </enum>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"FunctionImportInfo\",\n                    \"about\": \"Stores function import information.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class FunctionImportInfo {\n                public:\n                  FunctionImportInfo(base::Vector<const char> function_name, Zone* zone)\n                      : function_name(function_name), cache(zone) {}\n\n                  base::Vector<const char> function_name;\n                  std::unordered_map<FunctionSig, uint32_t> cache;\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AsmJsParser::AsmJsParser\",\n                \"parent\": \"AsmJsParser\",\n                \"about\": \"Constructor for the AsmJsParser.\",\n                \"logic\": \"Initializes the parser with the given memory zone, stack limit, and input stream.  Adds memory to the module builder.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"Memory zone for allocating data structures.\"\n                    },\n                    {\n                        \"name\": \"stack_limit\",\n                        \"type\": \"uintptr_t\",\n                        \"purpose\": \"Limit on the stack size for parsing to prevent stack overflows.\"\n                    },\n                    {\n                        \"name\": \"stream\",\n                        \"type\": \"Utf16CharacterStream*\",\n                        \"purpose\": \"Input stream containing the asm.js source code.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"WasmModuleBuilder\",\n                    \"AddMemory\",\n                    \"InitializeStdlibTypes\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            AsmJsParser::AsmJsParser(Zone* zone, uintptr_t stack_limit,\n                                 Utf16CharacterStream* stream)\n                : zone_(zone),\n                  scanner_(stream),\n                  module_builder_(zone->New<WasmModuleBuilder>(zone)),\n                  stack_limit_(stack_limit),\n                  block_stack_(zone),\n                  global_imports_(zone) {\n              module_builder_->AddMemory(0);\n              InitializeStdlibTypes();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AsmJsParser::InitializeStdlibTypes\",\n                \"parent\": \"AsmJsParser\",\n                \"about\": \"Initializes the AsmType signatures used in the stdlib.\",\n                \"logic\": \"Creates various AsmType function signatures corresponding to the asm.js standard library functions (e.g., Math.min, Math.abs, Math.ceil).\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"AsmType\",\n                    \"Function\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void AsmJsParser::InitializeStdlibTypes() {\n              auto* d = AsmType::Double();\n              auto* dq = AsmType::DoubleQ();\n              stdlib_dq2d_ = AsmType::Function(zone(), d);\n              stdlib_dq2d_->AsFunctionType()->AddArgument(dq);\n\n              stdlib_dqdq2d_ = AsmType::Function(zone(), d);\n              stdlib_dqdq2d_->AsFunctionType()->AddArgument(dq);\n              stdlib_dqdq2d_->AsFunctionType()->AddArgument(dq);\n\n              auto* f = AsmType::Float();\n              auto* fh = AsmType::Floatish();\n              auto* fq = AsmType::FloatQ();\n              auto* fq2fh = AsmType::Function(zone(), fh);\n              fq2fh->AsFunctionType()->AddArgument(fq);\n\n              auto* s = AsmType::Signed();\n              auto* u = AsmType::Unsigned();\n              auto* s2u = AsmType::Function(zone(), u);\n              s2u->AsFunctionType()->AddArgument(s);\n\n              auto* i = AsmType::Int();\n              stdlib_i2s_ = AsmType::Function(zone_, s);\n              stdlib_i2s_->AsFunctionType()->AddArgument(i);\n\n              stdlib_ii2s_ = AsmType::Function(zone(), s);\n              stdlib_ii2s_->AsFunctionType()->AddArgument(i);\n              stdlib_ii2s_->AsFunctionType()->AddArgument(i);\n\n              // The signatures in \"9 Standard Library\" of the spec draft are outdated and\n              // have been superseded with the following by an errata:\n              //  - Math.min/max : (signed, signed...) -> signed\n              //                   (double, double...) -> double\n              //                   (float, float...) -> float\n              auto* minmax_d = AsmType::MinMaxType(zone(), d, d);\n              auto* minmax_f = AsmType::MinMaxType(zone(), f, f);\n              auto* minmax_s = AsmType::MinMaxType(zone(), s, s);\n              stdlib_minmax_ = AsmType::OverloadedFunction(zone());\n              stdlib_minmax_->AsOverloadedFunctionType()->AddOverload(minmax_s);\n              stdlib_minmax_->AsOverloadedFunctionType()->AddOverload(minmax_f);\n              stdlib_minmax_->AsOverloadedFunctionType()->AddOverload(minmax_d);\n\n              // The signatures in \"9 Standard Library\" of the spec draft are outdated and\n              // have been superseded with the following by an errata:\n              //  - Math.abs : (signed) -> unsigned\n              //               (double?) -> double\n              //               (float?) -> floatish\n              stdlib_abs_ = AsmType::OverloadedFunction(zone());\n              stdlib_abs_->AsOverloadedFunctionType()->AddOverload(s2u);\n              stdlib_abs_->AsOverloadedFunctionType()->AddOverload(stdlib_dq2d_);\n              stdlib_abs_->AsOverloadedFunctionType()->AddOverload(fq2fh);\n\n              // The signatures in \"9 Standard Library\" of the spec draft are outdated and\n              // have been superseded with the following by an errata:\n              //  - Math.ceil/floor/sqrt : (double?) -> double\n              //                           (float?) -> floatish\n              stdlib_ceil_like_ = AsmType::OverloadedFunction(zone());\n              stdlib_ceil_like_->AsOverloadedFunctionType()->AddOverload(stdlib_dq2d_);\n              stdlib_ceil_like_->AsOverloadedFunctionType()->AddOverload(fq2fh);\n\n              stdlib_fround_ = AsmType::FroundType(zone());\n            }\n"
}