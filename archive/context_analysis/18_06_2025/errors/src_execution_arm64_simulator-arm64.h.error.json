{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm64/simulator-arm64.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm64/simulator-arm64.h\",\n        \"file_name\": \"simulator-arm64.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the ARM64 simulator class for running ARM64 code on other architectures\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for globals, standard library, assembler, decoder, diagnostics, simulator base, allocation utilities, and utils.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n\n            #if defined(USE_SIMULATOR)\n\n            #include <stdarg.h>\n\n            #include <vector>\n\n            #include \"src/base/compiler-specific.h\"\n            #include \"src/codegen/arm64/assembler-arm64.h\"\n            #include \"src/codegen/arm64/decoder-arm64.h\"\n            #include \"src/codegen/assembler.h\"\n            #include \"src/diagnostics/arm64/disasm-arm64.h\"\n            #include \"src/execution/simulator-base.h\"\n            #include \"src/utils/allocation.h\"\n            #include \"src/utils/utils.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FPRound\",\n            \"about\": \"Assembles the specified IEEE-754 components into the target type and applies appropriate rounding.\",\n            \"logic\": \"The function takes sign, exponent, mantissa, and rounding mode as input. It handles rounding based on the specified mode (FPTieEven or FPRoundOdd). It also takes care of overflow and subnormal values. The function calculates the shift required to move the top mantissa bit to the proper place in the destination type. Precision is lost due to shifting, so rounding is applied.\",\n            \"parameters\": [\n                {\n                    \"name\": \"sign\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"0 = positive, 1 = negative\"\n                },\n                {\n                    \"name\": \"exponent\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"Unbiased IEEE-754 exponent\"\n                },\n                {\n                    \"name\": \"mantissa\",\n                    \"type\": \"uint64_t\",\n                    \"purpose\": \"The mantissa of the input (top bit not omitted).\"\n                },\n                {\n                    \"name\": \"round_mode\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to apply\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T\",\n                \"description\": \"The rounded value in the target type T.\"\n            },\n            \"dependencies\": [\n                \"CountLeadingZeros\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T, int ebits, int mbits>\n            T FPRound(int64_t sign, int64_t exponent, uint64_t mantissa,\n                    FPRounding round_mode) {\n            static_assert((sizeof(T) * 8) >= (1 + ebits + mbits),\n                            \"destination type T not large enough\");\n            static_assert(sizeof(T) <= sizeof(uint64_t),\n                            \"maximum size of destination type T is 64 bits\");\n            static_assert(std::is_unsigned<T>::value,\n                            \"destination type T must be unsigned\");\n\n            DCHECK((sign == 0) || (sign == 1));\n\n            // Only FPTieEven and FPRoundOdd rounding modes are implemented.\n            DCHECK((round_mode == FPTieEven) || (round_mode == FPRoundOdd));\n\n            // Rounding can promote subnormals to normals, and normals to infinities. For\n            // example, a double with exponent 127 (FLT_MAX_EXP) would appear to be\n            // encodable as a float, but rounding based on the low-order mantissa bits\n            // could make it overflow. With ties-to-even rounding, this value would become\n            // an infinity.\n\n            // ---- Rounding Method ----\n            //\n            // The exponent is irrelevant in the rounding operation, so we treat the\n            // lowest-order bit that will fit into the result ('onebit') as having\n            // the value '1'. Similarly, the highest-order bit that won't fit into\n            // the result ('halfbit') has the value '0.5'. The 'point' sits between\n            // 'onebit' and 'halfbit':\n            //\n            //            These bits fit into the result.\n            //               |---------------------|\n            //  mantissa = 0bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n            //                                     ||\n            //                                    / |\n            //                                   /  halfbit\n            //                               onebit\n            //\n            // For subnormal outputs, the range of representable bits is smaller and\n            // the position of onebit and halfbit depends on the exponent of the\n            // input, but the method is otherwise similar.\n            //\n            //   onebit(frac)\n            //     |\n            //     | halfbit(frac)          halfbit(adjusted)\n            //     | /                      /\n            //     | |                      |\n            //  0b00.0 (exact)      -> 0b00.0 (exact)                    -> 0b00\n            //  0b00.0...           -> 0b00.0...                         -> 0b00\n            //  0b00.1 (exact)      -> 0b00.0111..111                    -> 0b00\n            //  0b00.1...           -> 0b00.1...                         -> 0b01\n            //  0b01.0 (exact)      -> 0b01.0 (exact)                    -> 0b01\n            //  0b01.0...           -> 0b01.0...                         -> 0b01\n            //  0b01.1 (exact)      -> 0b01.1 (exact)                    -> 0b10\n            //  0b01.1...           -> 0b01.1...                         -> 0b10\n            //  0b10.0 (exact)      -> 0b10.0 (exact)                    -> 0b10\n            //  0b10.0...           -> 0b10.0...                         -> 0b10\n            //  0b10.1 (exact)      -> 0b10.0111..111                    -> 0b10\n            //  0b10.1...           -> 0b10.1...                         -> 0b11\n            //  0b11.0 (exact)      -> 0b11.0 (exact)                    -> 0b11\n            //  ...                   /             |                      /   |\n            //                       /              |                     /    |\n            //                                                           /     |\n            // adjusted = frac - (halfbit(mantissa) & ~onebit(frac));   /      |\n            //\n            //                   mantissa = (mantissa >> shift) + halfbit(adjusted);\n\n            const int mantissa_offset = 0;\n            const int exponent_offset = mantissa_offset + mbits;\n            const int sign_offset = exponent_offset + ebits;\n            DCHECK_EQ(sign_offset, static_cast<int>(sizeof(T) * 8 - 1));\n\n            // Bail out early for zero inputs.\n            if (mantissa == 0) {\n                return static_cast<T>(sign << sign_offset);\n            }\n\n            // If all bits in the exponent are set, the value is infinite or NaN.\n            // This is true for all binary IEEE-754 formats.\n            const int infinite_exponent = (1 << ebits) - 1;\n            const int max_normal_exponent = infinite_exponent - 1;\n\n            // Apply the exponent bias to encode it for the result. Doing this early makes\n            // it easy to detect values that will be infinite or subnormal.\n            exponent += max_normal_exponent >> 1;\n\n            if (exponent > max_normal_exponent) {\n                // Overflow: the input is too large for the result type to represent.\n                if (round_mode == FPTieEven) {\n                // FPTieEven rounding mode handles overflows using infinities.\n                exponent = infinite_exponent;\n                mantissa = 0;\n                } else {\n                DCHECK_EQ(round_mode, FPRoundOdd);\n                // FPRoundOdd rounding mode handles overflows using the largest magnitude\n                // normal number.\n                exponent = max_normal_exponent;\n                mantissa = (UINT64_C(1) << exponent_offset) - 1;\n                }\n                return static_cast<T>((sign << sign_offset) |\n                                    (exponent << exponent_offset) |\n                                    (mantissa << mantissa_offset));\n            }\n\n            // Calculate the shift required to move the top mantissa bit to the proper\n            // place in the destination type.\n            const int highest_significant_bit = 63 - CountLeadingZeros(mantissa, 64);\n            int shift = highest_significant_bit - mbits;\n\n            if (exponent <= 0) {\n                // The output will be subnormal (before rounding).\n                // For subnormal outputs, the shift must be adjusted by the exponent. The +1\n                // is necessary because the exponent of a subnormal value (encoded as 0) is\n                // the same as the exponent of the smallest normal value (encoded as 1).\n                shift += -exponent + 1;\n\n                // Handle inputs that would produce a zero output.\n                //\n                // Shifts higher than highest_significant_bit+1 will always produce a zero\n                // result. A shift of exactly highest_significant_bit+1 might produce a\n                // non-zero result after rounding.\n                if (shift > (highest_significant_bit + 1)) {\n                if (round_mode == FPTieEven) {\n                    // The result will always be +/-0.0.\n                    return static_cast<T>(sign << sign_offset);\n                } else {\n                    DCHECK_EQ(round_mode, FPRoundOdd);\n                    DCHECK_NE(mantissa, 0U);\n                    // For FPRoundOdd, if the mantissa is too small to represent and\n                    // non-zero return the next \"odd\" value.\n                    return static_cast<T>((sign << sign_offset) | 1);\n                }\n                }\n\n                // Properly encode the exponent for a subnormal output.\n                exponent = 0;\n            } else {\n                // Clear the topmost mantissa bit, since this is not encoded in IEEE-754\n                // normal values.\n                mantissa &= ~(UINT64_C(1) << highest_significant_bit);\n            }\n\n            if (shift > 0) {\n                if (round_mode == FPTieEven) {\n                // We have to shift the mantissa to the right. Some precision is lost, so\n                // we need to apply rounding.\n                uint64_t onebit_mantissa = (mantissa >> (shift)) & 1;\n                uint64_t halfbit_mantissa = (mantissa >> (shift - 1)) & 1;\n                uint64_t adjustment = (halfbit_mantissa & ~onebit_mantissa);\n                uint64_t adjusted = mantissa - adjustment;\n                T halfbit_adjusted = (adjusted >> (shift - 1)) & 1;\n\n                T result =\n                    static_cast<T>((sign << sign_offset) | (exponent << exponent_offset) |\n                                ((mantissa >> shift) << mantissa_offset));\n\n                // A very large mantissa can overflow during rounding. If this happens,\n                // the exponent should be incremented and the mantissa set to 1.0\n                // (encoded as 0). Applying halfbit_adjusted after assembling the float\n                // has the nice side-effect that this case is handled for free.\n                //\n                // This also handles cases where a very large finite value overflows to\n                // infinity, or where a very large subnormal value overflows to become\n                // normal.\n                return result + halfbit_adjusted;\n                } else {\n                DCHECK_EQ(round_mode, FPRoundOdd);\n                // If any bits at position halfbit or below are set, onebit (ie. the\n                // bottom bit of the resulting mantissa) must be set.\n                uint64_t fractional_bits = mantissa & ((UINT64_C(1) << shift) - 1);\n                if (fractional_bits != 0) {\n                    mantissa |= UINT64_C(1) << shift;\n                }\n\n                return static_cast<T>((sign << sign_offset) |\n                                    (exponent << exponent_offset) |\n                                    ((mantissa >> shift) << mantissa_offset));\n                }\n            } else {\n                // We have to shift the mantissa to the left (or not at all). The input\n                // mantissa is exactly representable in the output mantissa, so apply no\n                // rounding correction.\n                return static_cast<T>((sign << sign_offset) |\n                                    (exponent << exponent_offset) |\n                                    ((mantissa << -shift) << mantissa_offset));\n            }\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CachePage\",\n            \"about\": \"Simulates instruction cache.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class CachePage {\n            // TODO(all): Simulate instruction cache.\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimMemory\",\n            \"about\": \"Representation of memory, with typed getters and setters for access.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class SimMemory {\n            public:\n            template <typename T>\n            static T AddressUntag(T address) {\n                // Cast the address using a C-style cast. A reinterpret_cast would be\n                // appropriate, but it can't cast one integral type to another.\n                uint64_t bits = (uint64_t)address;\n                return (T)(bits & ~kAddressTagMask);\n            }\n\n            template <typename T, typename A>\n            static T Read(A address) {\n                T value;\n                address = AddressUntag(address);\n                DCHECK((sizeof(value) == 1) || (sizeof(value) == 2) ||\n                    (sizeof(value) == 4) || (sizeof(value) == 8) ||\n                    (sizeof(value) == 16));\n                memcpy(&value, reinterpret_cast<const char*>(address), sizeof(value));\n                return value;\n            }\n\n            template <typename T, typename A>\n            static void Write(A address, T value) {\n                address = AddressUntag(address);\n                DCHECK((sizeof(value) == 1) || (sizeof(value) == 2) ||\n                    (sizeof(value) == 4) || (sizeof(value) == 8) ||\n                    (sizeof(value) == 16));\n                memcpy(reinterpret_cast<char*>(address), &value, sizeof(value));\n            }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimSystemRegister\",\n            \"about\": \"Represents a simulated system register (such as NZCV).\",\n            \"attributes\": [\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The value of the register.\"\n                },\n                {\n                    \"name\": \"write_ignore_mask_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Describes the bits which are not modifiable.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SystemRegister\",\n                \"unsigned_bitextract_32\",\n                \"signed_bitextract_32\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SimSystemRegister {\n            public:\n            // The default constructor represents a register which has no writable bits.\n            // It is not possible to set its value to anything other than 0.\n            SimSystemRegister() : value_(0), write_ignore_mask_(0xffffffff) {}\n\n            uint32_t RawValue() const { return value_; }\n\n            void SetRawValue(uint32_t new_value) {\n                value_ = (value_ & write_ignore_mask_) | (new_value & ~write_ignore_mask_);\n            }\n\n            uint32_t Bits(int msb, int lsb) const {\n                return unsigned_bitextract_32(msb, lsb, value_);\n            }\n\n            int32_t SignedBits(int msb, int lsb) const {\n                return signed_bitextract_32(msb, lsb, value_);\n            }\n\n            void SetBits(int msb, int lsb, uint32_t bits);\n\n            // Default system register values.\n            static SimSystemRegister DefaultValueFor(SystemRegister id);\n\n        #define DEFINE_GETTER(Name, HighBit, LowBit, Func, Type)                 \\\n            Type Name() const { return static_cast<Type>(Func(HighBit, LowBit)); } \\\n            void Set##Name(Type bits) {                                            \\\n            SetBits(HighBit, LowBit, static_cast<Type>(bits));                   \\\n            }\n        #define DEFINE_WRITE_IGNORE_MASK(Name, Mask) \\\n            static const uint32_t Name##WriteIgnoreMask = ~static_cast<uint32_t>(Mask);\n            SYSTEM_REGISTER_FIELDS_LIST(DEFINE_GETTER, DEFINE_WRITE_IGNORE_MASK)\n        #undef DEFINE_ZERO_BITS\n        #undef DEFINE_GETTER\n\n            protected:\n            // Most system registers only implement a few of the bits in the word. Other\n            // bits are \"read-as-zero, write-ignored\". The write_ignore_mask argument\n            // describes the bits which are not modifiable.\n            SimSystemRegister(uint32_t value, uint32_t write_ignore_mask)\n                : value_(value), write_ignore_mask_(write_ignore_mask) {}\n\n            uint32_t value_;\n            uint32_t write_ignore_mask_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimRegisterBase\",\n            \"about\": \"Represents a register (r0-r31, v0-v31).\",\n            \"attributes\": [\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"uint8_t[kSizeInBytes]\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The byte array holding the register's value.\"\n                },\n                {\n                    \"name\": \"written_since_last_log_\",\n                    \"type\": \"bool\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Indicates if the register has been written since the last log.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <int kSizeInBytes>\n            class SimRegisterBase {\n            public:\n            template <typename T>\n            void Set(T new_value) {\n                static_assert(sizeof(new_value) <= kSizeInBytes,\n                            \"Size of new_value must be <= size of template type.\");\n                if (sizeof(new_value) < kSizeInBytes) {\n                // All AArch64 registers are zero-extending.\n                memset(value_ + sizeof(new_value), 0, kSizeInBytes - sizeof(new_value));\n                }\n                memcpy(&value_, &new_value, sizeof(T));\n                NotifyRegisterWrite();\n            }\n\n            // Insert a typed value into a register, leaving the rest of the register\n            // unchanged. The lane parameter indicates where in the register the value\n            // should be inserted, in the range [ 0, sizeof(value_) / sizeof(T) ), where\n            // 0 represents the least significant bits.\n            template <typename T>\n            void Insert(int lane, T new_value) {\n                DCHECK_GE(lane, 0);\n                DCHECK_LE(sizeof(new_value) + (lane * sizeof(new_value)),\n                        static_cast<unsigned>(kSizeInBytes));\n                memcpy(&value_[lane * sizeof(new_value)], &new_value, sizeof(new_value));\n                NotifyRegisterWrite();\n            }\n\n            template <typename T>\n            T Get(int lane = 0) const {\n                T result;\n                DCHECK_GE(lane, 0);\n                DCHECK_LE(sizeof(result) + (lane * sizeof(result)),\n                        static_cast<unsigned>(kSizeInBytes));\n                memcpy(&result, &value_[lane * sizeof(result)], sizeof(result));\n                return result;\n            }\n\n            // TODO(all): Make this return a map of updated bytes, so that we can\n            // highlight updated lanes for load-and-insert. (That never happens for scalar\n            // code, but NEON has some instructions that can update individual lanes.)\n            bool WrittenSinceLastLog() const { return written_since_last_log_; }\n\n            void NotifyRegisterLogged() { written_since_last_log_ = false; }\n\n            protected:\n            uint8_t value_[kSizeInBytes];\n\n            // Helpers to aid with register tracing.\n            bool written_since_last_log_;\n\n            void NotifyRegisterWrite() { written_since_last_log_ = true; }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LogicVRegister\",\n            \"about\": \"Representation of a vector register, with typed getters and setters for lanes and additional information to represent lane state.\",\n            \"attributes\": [\n                {\n                    \"name\": \"register_\",\n                    \"type\": \"SimVRegister&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Reference to the underlying SimVRegister.\"\n                },\n                {\n                    \"name\": \"saturated_\",\n                    \"type\": \"Saturation[kQRegSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Saturation state for each lane of a vector.\"\n                },\n                {\n                    \"name\": \"round_\",\n                    \"type\": \"bool[kQRegSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Rounding state entry per lane.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SimVRegister\",\n                \"VectorFormat\",\n                \"LaneSizeInBitsFromFormat\",\n                \"UNREACHABLE\",\n                \"arraysize\",\n                \"LaneCountFromFormat\",\n                \"RegisterSizeInBytesFromFormat\",\n                \"Saturation\",\n                \"MaxIntFromFormat\",\n                \"MaxUintFromFormat\",\n                \"DCHECK_NE\",\n                \"kFormat1Q\",\n                \"kFormat2D\",\n                \"kFormat16B\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class LogicVRegister {\n            public:\n            inline LogicVRegister(SimVRegister& other)  // NOLINT\n                : register_(other) {\n                for (unsigned i = 0; i < arraysize(saturated_); i++) {\n                saturated_[i] = kNotSaturated;\n                }\n                for (unsigned i = 0; i < arraysize(round_); i++) {\n                round_[i] = false;\n                }\n            }\n\n            int64_t Int(VectorFormat vform, int index) const {\n                int64_t element;\n                switch (LaneSizeInBitsFromFormat(vform)) {\n                case 8:\n                    element = register_.Get<int8_t>(index);\n                    break;\n                case 16:\n                    element = register_.Get<int16_t>(index);\n                    break;\n                case 32:\n                    element = register_.Get<int32_t>(index);\n                    break;\n                case 64:\n                    element = register_.Get<int64_t>(index);\n                    break;\n                default:\n                    UNREACHABLE();\n                    return 0;\n                }\n                return element;\n            }\n\n            uint64_t Uint(VectorFormat vform, int index) const {\n                uint64_t element;\n                switch (LaneSizeInBitsFromFormat(vform)) {\n                case 8:\n                    element = register_.Get<uint8_t>(index);\n                    break;\n                case 16:\n                    element = register_.Get<uint16_t>(index);\n                    break;\n                case 32:\n                    element = register_.Get<uint32_t>(index);\n                    break;\n                case 64:\n                    element = register_.Get<uint64_t>(index);\n                    break;\n                default:\n                    UNREACHABLE();\n                    return 0;\n                }\n                return element;\n            }\n\n            uint64_t UintLeftJustified(VectorFormat vform, int index) const {\n                return Uint(vform, index) << (64 - LaneSizeInBitsFromFormat(vform));\n            }\n\n            int64_t IntLeftJustified(VectorFormat vform, int index) const {\n                uint64_t value = UintLeftJustified(vform, index);\n                int64_t result;\n                memcpy(&result, &value, sizeof(result));\n                return result;\n            }\n\n            void SetInt(VectorFormat vform, int index, int64_t value) const {\n                switch (LaneSizeInBitsFromFormat(vform)) {\n                case 8:\n                    register_.Insert(index, static_cast<int8_t>(value));\n                    break;\n                case 16:\n                    register_.Insert(index, static_cast<int16_t>(value));\n                    break;\n                case 32:\n                    register_.Insert(index, static_cast<int32_t>(value));\n                    break;\n                case 64:\n                    register_.Insert(index, static_cast<int64_t>(value));\n                    break;\n                default:\n                    UNREACHABLE();\n                    return;\n                }\n            }\n\n            void SetIntArray(VectorFormat vform, const int64_t* src) const {\n                ClearForWrite(vform);\n                for (int i = 0; i < LaneCountFromFormat(vform); i++) {\n                SetInt(vform, i, src[i]);\n                }\n            }\n\n            void SetUint(VectorFormat vform, int index, uint64_t value) const {\n                switch (LaneSizeInBitsFromFormat(vform)) {\n                case 8:\n                    register_.Insert(index, static_cast<uint8_t>(value));\n                    break;\n                case 16:\n                    register_.Insert(index, static_cast<uint16_t>(value));\n                    break;\n                case 32:\n                    register_.Insert(index, static_cast<uint32_t>(value));\n                    break;\n                case 64:\n                    register_.Insert(index, static_cast<uint64_t>(value));\n                    break;\n                default:\n                    UNREACHABLE();\n                    return;\n                }\n            }\n\n            void SetUint(VectorFormat vform, int index, sim_uint128_t value) const {\n                if (LaneSizeInBitsFromFormat(vform) <= 64) {\n                SetUint(vform, index, value.second);\n                return;\n                }\n                DCHECK((vform == kFormat1Q) && (index == 0));\n                SetUint(kFormat2D, 0, value.second);\n                SetUint(kFormat2D, 1, value.first);\n            }\n\n            void SetUintArray(VectorFormat vform, const uint64_t* src) const {\n                ClearForWrite(vform);\n                for (int i = 0; i < LaneCountFromFormat(vform); i++) {\n                SetUint(vform, i, src[i]);\n                }\n            }\n\n            void ReadUintFromMem(VectorFormat vform, int index, uint64_t addr) const;\n\n            void WriteUintToMem(VectorFormat vform, int index, uint64_t addr) const;\n\n            template <typename T>\n            T Float(int index) const {\n                return register_.Get<T>(index);\n            }\n\n            template <typename T>\n            void SetFloat(int index, T value) const {\n                register_.Insert(index, value);\n            }\n\n            // When setting a result in a register of size less than Q, the top bits of\n            // the Q register must be cleared.\n            void ClearForWrite(VectorFormat vform) const {\n                unsigned size = RegisterSizeInBytesFromFormat(vform);\n                for (unsigned i = size; i < kQRegSize; i++) {\n                SetUint(kFormat16B, i, 0);\n                }\n            }\n\n            // Saturation state for each lane of a vector.\n            enum Saturation {\n                kNotSaturated = 0,\n                kSignedSatPositive = 1 << 0,\n                kSignedSatNegative = 1 << 1,\n                kSignedSatMask = kSignedSatPositive | kSignedSatNegative,\n                kSignedSatUndefined = kSignedSatMask,\n                kUnsignedSatPositive = 1 << 2,\n                kUnsignedSatNegative = 1 << 3,\n                kUnsignedSatMask = kUnsignedSatPositive | kUnsignedSatNegative,\n                kUnsignedSatUndefined = kUnsignedSatMask\n            };\n\n            // Getters for saturation state.\n            Saturation GetSignedSaturation(int index) {\n                return static_cast<Saturation>(saturated_[index] & kSignedSatMask);\n            }\n\n            Saturation GetUnsignedSaturation(int index) {\n                return static_cast<Saturation>(saturated_[index] & kUnsignedSatMask);\n            }\n\n            // Setters for saturation state.\n            void ClearSat(int index) { saturated_[index] = kNotSaturated; }\n\n            void SetSignedSat(int index, bool positive) {\n                SetSatFlag(index, positive ? kSignedSatPositive : kSignedSatNegative);\n            }\n\n            void SetUnsignedSat(int index, bool positive) {\n                SetSatFlag(index, positive ? kUnsignedSatPositive : kUnsignedSatNegative);\n            }\n\n            void SetSatFlag(int index, Saturation sat) {\n                saturated_[index] = static_cast<Saturation>(saturated_[index] | sat);\n                DCHECK_NE(sat & kUnsignedSatMask, kUnsignedSatUndefined);\n                DCHECK_NE(sat & kSignedSatMask, kSignedSatUndefined);\n            }\n\n            // Saturate lanes of a vector based on saturation state.\n            LogicVRegister& SignedSaturate(VectorFormat vform) {\n                for (int i = 0; i < LaneCountFromFormat(vform); i++) {\n                Saturation sat = GetSignedSaturation(i);\n                if (sat == kSignedSatPositive) {\n                    SetInt(vform, i, MaxIntFromFormat(vform));\n                } else if (sat == kSignedSatNegative) {\n                    SetInt(vform, i, MinIntFromFormat(vform));\n                }\n                }\n                return *this;\n            }\n\n            LogicVRegister& UnsignedSaturate(VectorFormat vform) {\n                for (int i = 0; i < LaneCountFromFormat(vform); i++) {\n                Saturation sat = GetUnsignedSaturation(i);\n                if (sat == kUnsignedSatPositive) {\n                    SetUint(vform, i, MaxUintFromFormat(vform));\n                } else if (sat == kUnsignedSatNegative) {\n                    SetUint(vform, i, 0);\n                }\n                }\n                return *this;\n            }\n\n            // Getter for rounding state.\n            bool GetRounding(int index) { return round_[index]; }\n\n            // Setter for rounding state.\n            void SetRounding(int index, bool round) { round_[index] = round; }\n\n            // Round lanes of a vector based on rounding state.\n            LogicVRegister& Round(VectorFormat vform) {\n                for (int i = 0; i < LaneCountFromFormat(vform); i++) {\n                SetUint(vform, i, Uint(vform, i) + (GetRounding(i) ? 1 : 0));\n                }\n                return *this;\n            }\n\n            // Unsigned halve lanes of a vector, and use the saturation state to set the\n            // top bit.\n            LogicVRegister& Uhalve(VectorFormat vform) {\n                for (int i = 0; i < LaneCountFromFormat(vform); i++) {\n                uint64_t val = Uint(vform, i);\n                SetRounding(i, (val & 1) == 1);\n                val >>= 1;\n                if (GetUnsignedSaturation(i) != kNotSaturated) {\n                    // If the operation causes unsigned saturation, the bit shifted into the\n                    // most significant bit must be set.\n                    val |= (MaxUintFromFormat(vform) >> 1) + 1;\n                }\n                SetInt(vform, i, val);\n                }\n                return *this;\n            }\n\n            // Signed halve lanes of a vector, and use the carry state to set the"
}