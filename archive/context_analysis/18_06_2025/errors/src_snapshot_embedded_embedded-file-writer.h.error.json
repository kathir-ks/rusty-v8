{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/embedded-file-writer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/embedded-file-writer.h\",\n        \"file_name\": \"embedded-file-writer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the EmbeddedFileWriter class, which generates the embedded.S file containing the snapshot blob.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary standard library headers and V8 specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <cinttypes>\n#include <cstdio>\n#include <cstring>\n#include <memory>\n\n#include \"src/base/platform/wrappers.h\"\n#include \"src/base/strings.h\"\n#include \"src/common/globals.h\"\n#include \"src/snapshot/embedded/embedded-data.h\"\n#include \"src/snapshot/embedded/embedded-file-writer-interface.h\"\n#include \"src/snapshot/embedded/platform-embedded-file-writer-base.h\"\n\n#if defined(V8_OS_WIN64)\n#include \"src/diagnostics/unwinding-info-win64.h\"\n#endif  // V8_OS_WIN64\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EmbeddedFileWriter\",\n            \"extends\": \"EmbeddedFileWriterInterface\",\n            \"about\": \"Generates the embedded.S file containing the snapshot blob.  The blob is exported via two symbols: v8_<variant>_embedded_blob_ (intptr_t) and v8_<variant>_embedded_blob_size_ (uint32_t).\",\n            \"attributes\": [\n                {\n                    \"name\": \"source_positions_\",\n                    \"type\": \"std::vector<uint8_t>[Builtins::kBuiltinCount]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores source positions for each builtin.\"\n                },\n                {\n                    \"name\": \"label_info_\",\n                    \"type\": \"std::vector<LabelInfo>[Builtins::kBuiltinCount]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores label information for each builtin.\"\n                },\n                {\n                    \"name\": \"unwind_infos_\",\n                    \"type\": \"win64_unwindinfo::BuiltinUnwindInfo[Builtins::kBuiltinCount]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores unwind information for Windows x64 builds.\"\n                },\n                {\n                    \"name\": \"external_filenames_\",\n                    \"type\": \"std::map<const char*, int>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps external filenames to unique IDs.\"\n                },\n                {\n                    \"name\": \"external_filenames_by_index_\",\n                    \"type\": \"std::vector<const char*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores external filenames by index (ID).\"\n                },\n                {\n                    \"name\": \"embedded_src_path_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Path to the embedded.S file to generate.\"\n                },\n                {\n                    \"name\": \"embedded_variant_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Variant name used in multi-snapshot builds (e.g., 'Default').\"\n                },\n                {\n                    \"name\": \"target_arch_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Target architecture for the generated assembly.\"\n                },\n                {\n                    \"name\": \"target_os_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Target operating system for the generated assembly.\"\n                }\n            ],\n            \"dependencies\": [\n                \"EmbeddedFileWriterInterface\",\n                \"EmbeddedData\",\n                \"PlatformEmbeddedFileWriterBase\",\n                \"Builtins\",\n                \"win64_unwindinfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass EmbeddedFileWriter : public EmbeddedFileWriterInterface {\n public:\n  int LookupOrAddExternallyCompiledFilename(const char* filename) override;\n  const char* GetExternallyCompiledFilename(int fileid) const override;\n  int GetExternallyCompiledFilenameCount() const override;\n\n  void PrepareBuiltinSourcePositionMap(Builtins* builtins) override;\n\n#if defined(V8_OS_WIN64)\n  void SetBuiltinUnwindData(\n      Builtin builtin,\n      const win64_unwindinfo::BuiltinUnwindInfo& unwinding_info) override {\n    DCHECK_LT(static_cast<int>(builtin), Builtins::kBuiltinCount);\n    unwind_infos_[static_cast<int>(builtin)] = unwinding_info;\n  }\n#endif  // V8_OS_WIN64\n\n  void SetEmbeddedFile(const char* embedded_src_path) {\n    embedded_src_path_ = embedded_src_path;\n  }\n\n  void SetEmbeddedVariant(const char* embedded_variant) {\n    if (embedded_variant == nullptr) return;\n    embedded_variant_ = embedded_variant;\n  }\n\n  void SetTargetArch(const char* target_arch) { target_arch_ = target_arch; }\n\n  void SetTargetOs(const char* target_os) { target_os_ = target_os; }\n\n  void WriteEmbedded(const i::EmbeddedData* blob) const {\n    MaybeWriteEmbeddedFile(blob);\n  }\n\n private:\n  void MaybeWriteEmbeddedFile(const i::EmbeddedData* blob) const {\n    if (embedded_src_path_ == nullptr) return;\n\n    FILE* fp = GetFileDescriptorOrDie(embedded_src_path_);\n\n    std::unique_ptr<PlatformEmbeddedFileWriterBase> writer =\n        NewPlatformEmbeddedFileWriter(target_arch_, target_os_);\n    writer->SetFile(fp);\n\n    WriteFilePrologue(writer.get());\n    WriteExternalFilenames(writer.get());\n    WriteDataSection(writer.get(), blob);\n    WriteCodeSection(writer.get(), blob);\n    WriteFileEpilogue(writer.get(), blob);\n\n    base::Fclose(fp);\n  }\n\n  static FILE* GetFileDescriptorOrDie(const char* filename) {\n    FILE* fp = v8::base::OS::FOpen(filename, \"w\");\n\n    if (fp == nullptr) {\n      i::PrintF(\"Unable to open file \\\"%s\\\" for writing.\\n\", filename);\n      exit(1);\n    }\n    return fp;\n  }\n\n  void WriteFilePrologue(PlatformEmbeddedFileWriterBase* w) const {\n    w->Comment(\"Autogenerated file. Do not edit.\");\n    w->Newline();\n    w->FilePrologue();\n  }\n\n  void WriteExternalFilenames(PlatformEmbeddedFileWriterBase* w) const {\n#ifndef DEBUG\n    // Release builds must not contain debug infos.\n    CHECK_EQ(external_filenames_by_index_.size(), 0);\n#endif\n\n    w->Comment(\n        \"Source positions in the embedded blob refer to filenames by id.\");\n    w->Comment(\"Assembly directives here map the id to a filename.\");\n    w->Newline();\n\n    // Write external filenames.\n    int size = static_cast<int>(external_filenames_by_index_.size());\n    for (int i = 0; i < size; i++) {\n      w->DeclareExternalFilename(ExternalFilenameIndexToId(i),\n                                 external_filenames_by_index_[i]);\n    }\n  }\n\n  // Fairly arbitrary but should fit all symbol names.\n  static constexpr int kTemporaryStringLength = 256;\n\n  std::string EmbeddedBlobCodeSymbol() const {\n    base::EmbeddedVector<char, kTemporaryStringLength>\n        embedded_blob_code_symbol;\n    base::SNPrintF(embedded_blob_code_symbol, \"v8_%s_embedded_blob_code_\",\n                   embedded_variant_);\n    return std::string{embedded_blob_code_symbol.begin()};\n  }\n\n  std::string EmbeddedBlobDataSymbol() const {\n    base::EmbeddedVector<char, kTemporaryStringLength>\n        embedded_blob_data_symbol;\n    base::SNPrintF(embedded_blob_data_symbol, \"v8_%s_embedded_blob_data_\",\n                   embedded_variant_);\n    return std::string{embedded_blob_data_symbol.begin()};\n  }\n\n  void WriteDataSection(PlatformEmbeddedFileWriterBase* w,\n                        const i::EmbeddedData* blob) const {\n    w->Comment(\"The embedded blob data section starts here.\");\n    w->SectionRoData();\n    w->AlignToDataAlignment();\n    w->DeclareSymbolGlobal(EmbeddedBlobDataSymbol().c_str());\n    w->DeclareLabelProlog(EmbeddedBlobDataSymbol().c_str());\n    w->DeclareLabel(EmbeddedBlobDataSymbol().c_str());\n\n    WriteBinaryContentsAsInlineAssembly(w, blob->data(), blob->data_size());\n    w->DeclareLabelEpilogue();\n    w->Newline();\n  }\n\n  void WriteBuiltin(PlatformEmbeddedFileWriterBase* w,\n                    const i::EmbeddedData* blob, const Builtin builtin) const;\n\n  void WriteBuiltinLabels(PlatformEmbeddedFileWriterBase* w,\n                          std::string name) const;\n\n  void WriteCodeSection(PlatformEmbeddedFileWriterBase* w,\n                        const i::EmbeddedData* blob) const;\n\n  void WriteFileEpilogue(PlatformEmbeddedFileWriterBase* w,\n                         const i::EmbeddedData* blob) const;\n\n#if defined(V8_OS_WIN_X64)\n  void WriteUnwindInfoEntry(PlatformEmbeddedFileWriterBase* w,\n                            uint64_t rva_start, uint64_t rva_end) const;\n#endif\n\n  static void WriteBinaryContentsAsInlineAssembly(\n      PlatformEmbeddedFileWriterBase* w, const uint8_t* data, uint32_t size);\n\n  // In assembly directives, filename ids need to begin with 1.\n  static constexpr int kFirstExternalFilenameId = 1;\n  static int ExternalFilenameIndexToId(int index) {\n    return kFirstExternalFilenameId + index;\n  }\n  static int ExternalFilenameIdToIndex(int id) {\n    return id - kFirstExternalFilenameId;\n  }\n\n private:\n  std::vector<uint8_t> source_positions_[Builtins::kBuiltinCount];\n  std::vector<LabelInfo> label_info_[Builtins::kBuiltinCount];\n\n#if defined(V8_OS_WIN64)\n  win64_unwindinfo::BuiltinUnwindInfo unwind_infos_[Builtins::kBuiltinCount];\n#endif  // V8_OS_WIN64\n\n  std::map<const char*, int> external_filenames_;\n  std::vector<const char*> external_filenames_by_index_;\n\n  // The file to generate or nullptr.\n  const char* embedded_src_path_ = nullptr;\n\n  // The variant is only used in multi-snapshot builds and otherwise set to\n  // \"Default\".\n  const char* embedded_variant_ = kDefaultEmbeddedVariant;\n\n  // {target_arch} and {target_os} control the generated assembly format. Note\n  // these may differ from both host- and target-platforms specified through\n  // e.g. V8_OS_* and V8_TARGET_ARCH_* defines.\n  const char* target_arch_ = nullptr;\n  const char* target_os_ = nullptr;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LookupOrAddExternallyCompiledFilename\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Looks up or adds an externally compiled filename to the filename map.\",\n            \"logic\": \"This function is an override from the base class.  The exact implementation is not provided here.\",\n            \"parameters\": [\n                {\n                    \"name\": \"filename\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The filename to lookup or add.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The file ID of the filename.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  int LookupOrAddExternallyCompiledFilename(const char* filename) override;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetExternallyCompiledFilename\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Gets the externally compiled filename for the given file ID.\",\n            \"logic\": \"This function is an override from the base class.  The exact implementation is not provided here.\",\n            \"parameters\": [\n                {\n                    \"name\": \"fileid\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The file ID to lookup.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const char*\",\n                \"description\": \"The filename for the given ID.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  const char* GetExternallyCompiledFilename(int fileid) const override;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetExternallyCompiledFilenameCount\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Gets the number of externally compiled filenames.\",\n            \"logic\": \"This function is an override from the base class.  The exact implementation is not provided here.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The number of externally compiled filenames.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  int GetExternallyCompiledFilenameCount() const override;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PrepareBuiltinSourcePositionMap\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Prepares the source position map for builtins.\",\n            \"logic\": \"This function is an override from the base class. The exact implementation is not provided here.\",\n            \"parameters\": [\n                {\n                    \"name\": \"builtins\",\n                    \"type\": \"Builtins*\",\n                    \"purpose\": \"Pointer to the Builtins object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Builtins\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void PrepareBuiltinSourcePositionMap(Builtins* builtins) override;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetBuiltinUnwindData\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Sets the unwind data for a builtin (Windows x64 only).\",\n            \"logic\": \"This function is only defined when V8_OS_WIN64 is defined. It stores the unwind information for the given builtin.\",\n            \"parameters\": [\n                {\n                    \"name\": \"builtin\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin to set unwind data for.\"\n                },\n                {\n                    \"name\": \"unwinding_info\",\n                    \"type\": \"const win64_unwindinfo::BuiltinUnwindInfo&\",\n                    \"purpose\": \"The unwind information to set.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Builtin\",\n                \"win64_unwindinfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#if defined(V8_OS_WIN64)\n  void SetBuiltinUnwindData(\n      Builtin builtin,\n      const win64_unwindinfo::BuiltinUnwindInfo& unwinding_info) override {\n    DCHECK_LT(static_cast<int>(builtin), Builtins::kBuiltinCount);\n    unwind_infos_[static_cast<int>(builtin)] = unwinding_info;\n  }\n#endif  // V8_OS_WIN64\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetEmbeddedFile\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Sets the path to the embedded.S file.\",\n            \"logic\": \"Sets the `embedded_src_path_` member variable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"embedded_src_path\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The path to the embedded.S file.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void SetEmbeddedFile(const char* embedded_src_path) {\n    embedded_src_path_ = embedded_src_path;\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetEmbeddedVariant\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Sets the embedded variant name (used in multi-snapshot builds).\",\n            \"logic\": \"Sets the `embedded_variant_` member variable. If the provided name is nullptr, it returns immediately.\",\n            \"parameters\": [\n                {\n                    \"name\": \"embedded_variant\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The embedded variant name.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void SetEmbeddedVariant(const char* embedded_variant) {\n    if (embedded_variant == nullptr) return;\n    embedded_variant_ = embedded_variant;\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetTargetArch\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Sets the target architecture.\",\n            \"logic\": \"Sets the `target_arch_` member variable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"target_arch\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The target architecture.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void SetTargetArch(const char* target_arch) { target_arch_ = target_arch; }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetTargetOs\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Sets the target operating system.\",\n            \"logic\": \"Sets the `target_os_` member variable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"target_os\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The target operating system.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void SetTargetOs(const char* target_os) { target_os_ = target_os; }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteEmbedded\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Writes the embedded blob to the output file.\",\n            \"logic\": \"Calls the `MaybeWriteEmbeddedFile` function if the embedded file path is set.\",\n            \"parameters\": [\n                {\n                    \"name\": \"blob\",\n                    \"type\": \"const i::EmbeddedData*\",\n                    \"purpose\": \"Pointer to the embedded data blob.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"EmbeddedData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void WriteEmbedded(const i::EmbeddedData* blob) const {\n    MaybeWriteEmbeddedFile(blob);\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MaybeWriteEmbeddedFile\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Writes the embedded blob to the output file, if the file path is set.\",\n            \"logic\": \"Opens the output file, creates a PlatformEmbeddedFileWriter, and then calls the functions to write the file prologue, external filenames, data section, code section, and file epilogue. Finally, closes the file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"blob\",\n                    \"type\": \"const i::EmbeddedData*\",\n                    \"purpose\": \"Pointer to the embedded data blob.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PlatformEmbeddedFileWriterBase\",\n                \"EmbeddedData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void MaybeWriteEmbeddedFile(const i::EmbeddedData* blob) const {\n    if (embedded_src_path_ == nullptr) return;\n\n    FILE* fp = GetFileDescriptorOrDie(embedded_src_path_);\n\n    std::unique_ptr<PlatformEmbeddedFileWriterBase> writer =\n        NewPlatformEmbeddedFileWriter(target_arch_, target_os_);\n    writer->SetFile(fp);\n\n    WriteFilePrologue(writer.get());\n    WriteExternalFilenames(writer.get());\n    WriteDataSection(writer.get(), blob);\n    WriteCodeSection(writer.get(), blob);\n    WriteFileEpilogue(writer.get(), blob);\n\n    base::Fclose(fp);\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetFileDescriptorOrDie\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Opens the given file for writing and returns a FILE pointer, exiting if the file cannot be opened.\",\n            \"logic\": \"Uses `v8::base::OS::FOpen` to open the file in write mode ('w'). If the file cannot be opened (fopen returns NULL), an error message is printed, and the program exits with code 1.\",\n            \"parameters\": [\n                {\n                    \"name\": \"filename\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the file to open.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"FILE*\",\n                \"description\": \"A file pointer to the opened file.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  static FILE* GetFileDescriptorOrDie(const char* filename) {\n    FILE* fp = v8::base::OS::FOpen(filename, \"w\");\n\n    if (fp == nullptr) {\n      i::PrintF(\"Unable to open file \\\"%s\\\" for writing.\\n\", filename);\n      exit(1);\n    }\n    return fp;\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteFilePrologue\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Writes the file prologue to the output file using the provided `PlatformEmbeddedFileWriterBase` object.\",\n            \"logic\": \"Calls `w->Comment` to write a comment indicating that the file is autogenerated, `w->Newline` to insert a newline, and `w->FilePrologue` to write the architecture-specific prologue.\",\n            \"parameters\": [\n                {\n                    \"name\": \"w\",\n                    \"type\": \"PlatformEmbeddedFileWriterBase*\",\n                    \"purpose\": \"A pointer to the `PlatformEmbeddedFileWriterBase` object used to write to the output file.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PlatformEmbeddedFileWriterBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void WriteFilePrologue(PlatformEmbeddedFileWriterBase* w) const {\n    w->Comment(\"Autogenerated file. Do not edit.\");\n    w->Newline();\n    w->FilePrologue();\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteExternalFilenames\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Writes the external filenames to the output file as assembly directives.\",\n            \"logic\": \"Iterates through the `external_filenames_by_index_` vector and writes each filename to the file using `w->DeclareExternalFilename`. Skips if not in DEBUG mode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"w\",\n                    \"type\": \"PlatformEmbeddedFileWriterBase*\",\n                    \"purpose\": \"A pointer to the `PlatformEmbeddedFileWriterBase` object used to write to the output file.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PlatformEmbeddedFileWriterBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void WriteExternalFilenames(PlatformEmbeddedFileWriterBase* w) const {\n#ifndef DEBUG\n    // Release builds must not contain debug infos.\n    CHECK_EQ(external_filenames_by_index_.size(), 0);\n#endif\n\n    w->Comment(\n        \"Source positions in the embedded blob refer to filenames by id.\");\n    w->Comment(\"Assembly directives here map the id to a filename.\");\n    w->Newline();\n\n    // Write external filenames.\n    int size = static_cast<int>(external_filenames_by_index_.size());\n    for (int i = 0; i < size; i++) {\n      w->DeclareExternalFilename(ExternalFilenameIndexToId(i),\n                                 external_filenames_by_index_[i]);\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmbeddedBlobCodeSymbol\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Generates the symbol name for the embedded blob code.\",\n            \"logic\": \"Uses `base::SNPrintF` to format the symbol name based on the `embedded_variant_` member variable. The generated symbol name will be of the form `v8_<variant>_embedded_blob_code_`.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The symbol name for the embedded blob code.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  std::string EmbeddedBlobCodeSymbol() const {\n    base::EmbeddedVector<char, kTemporaryStringLength>\n        embedded_blob_code_symbol;\n    base::SNPrintF(embedded_blob_code_symbol, \"v8_%s_embedded_blob_code_\",\n                   embedded_variant_);\n    return std::string{embedded_blob_code_symbol.begin()};\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmbeddedBlobDataSymbol\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Generates the symbol name for the embedded blob data.\",\n            \"logic\": \"Uses `base::SNPrintF` to format the symbol name based on the `embedded_variant_` member variable. The generated symbol name will be of the form `v8_<variant>_embedded_blob_data_`.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The symbol name for the embedded blob data.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  std::string EmbeddedBlobDataSymbol() const {\n    base::EmbeddedVector<char, kTemporaryStringLength>\n        embedded_blob_data_symbol;\n    base::SNPrintF(embedded_blob_data_symbol, \"v8_%s_embedded_blob_data_\",\n                   embedded_variant_);\n    return std::string{embedded_blob_data_symbol.begin()};\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteDataSection\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Writes the data section of the embedded blob to the output file.\",\n            \"logic\": \"Uses the provided `PlatformEmbeddedFileWriterBase` object to write assembly directives to declare the data section. This includes setting the section to read-only data (`SectionRoData`), aligning to data alignment (`AlignToDataAlignment`), declaring the global symbol for the data section (`DeclareSymbolGlobal`), and declaring a label for the data section (`DeclareLabel`). The actual data is written using `WriteBinaryContentsAsInlineAssembly`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"w\",\n                    \"type\": \"PlatformEmbeddedFileWriterBase*\",\n                    \"purpose\": \"A pointer to the `PlatformEmbeddedFileWriterBase` object used to write to the output file.\"\n                },\n                {\n                    \"name\": \"blob\",\n                    \"type\": \"const i::EmbeddedData*\",\n                    \"purpose\": \"Pointer to the embedded data blob.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PlatformEmbeddedFileWriterBase\",\n                \"EmbeddedData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void WriteDataSection(PlatformEmbeddedFileWriterBase* w,\n                        const i::EmbeddedData* blob) const {\n    w->Comment(\"The embedded blob data section starts here.\");\n    w->SectionRoData();\n    w->AlignToDataAlignment();\n    w->DeclareSymbolGlobal(EmbeddedBlobDataSymbol().c_str());\n    w->DeclareLabelProlog(EmbeddedBlobDataSymbol().c_str());\n    w->DeclareLabel(EmbeddedBlobDataSymbol().c_str());\n\n    WriteBinaryContentsAsInlineAssembly(w, blob->data(), blob->data_size());\n    w->DeclareLabelEpilogue();\n    w->Newline();\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteBuiltin\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Writes the data for a specific builtin.\",\n            \"logic\": \"The exact implementation is not provided here.\",\n            \"parameters\": [\n                {\n                    \"name\": \"w\",\n                    \"type\": \"PlatformEmbeddedFileWriterBase*\",\n                    \"purpose\": \"Platform-specific file writer\"\n                },\n                {\n                    \"name\": \"blob\",\n                    \"type\": \"const i::EmbeddedData*\",\n                    \"purpose\": \"Embedded data\"\n                },\n                {\n                    \"name\": \"builtin\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin to write\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PlatformEmbeddedFileWriterBase\",\n                \"EmbeddedData\",\n                \"Builtin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void WriteBuiltin(PlatformEmbeddedFileWriterBase* w,\n                    const i::EmbeddedData* blob, const Builtin builtin) const;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteBuiltinLabels\",\n            \"parent\": \"EmbeddedFileWriter\",\n            \"about\": \"Writes the labels for a specific builtin.\",\n            \"logic\": \"The exact implementation is not provided here.\",\n            \"parameters\": [\n                {\n                    \"name\": \"w\",\n                    \"type\": \"PlatformEmbeddedFileWriterBase*\",\n                    \"purpose\": \"Platform-specific file writer\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The name of the builtin\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PlatformEmbeddedFileWriterBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void WriteBuiltinLabels(PlatformEmbeddedFileWriterBase* w,\n                          std::string name) const;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WriteCodeSection\",\n            \"parent\": \"EmbeddedFileWriter\",\n            "
}