{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/basic-block-instrumentor.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 468, column 57",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/basic-block-instrumentor.cc\",\n        \"file_name\": \"basic-block-instrumentor.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements basic block instrumentation for profiling, including adding increment instructions and call graph profiling.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for basic block instrumentation, code generation, graph manipulation, and object handling.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/basic-block-instrumentor.h\"\n\n#include <sstream>\n\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/schedule.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/operation-matcher.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/objects/objects-inl.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FindInsertionPoint\",\n            \"about\": \"Finds the first suitable place to insert new nodes in a basic block, avoiding register allocation issues.\",\n            \"logic\": \"Iterates through the block's nodes, skipping block begin markers, parameters, and phis, to find the first node where insertion is safe.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"BasicBlock*\",\n                    \"purpose\": \"The basic block to find the insertion point in\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"NodeVector::iterator\",\n                \"description\": \"Iterator pointing to the insertion point\"\n            },\n            \"dependencies\": [\n                \"OperatorProperties\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic NodeVector::iterator FindInsertionPoint(BasicBlock* block) {\n  NodeVector::iterator i = block->begin();\n  for (; i != block->end(); ++i) {\n    const Operator* op = (*i)->op();\n    if (OperatorProperties::IsBasicBlockBegin(op)) continue;\n    switch (op->opcode()) {\n      case IrOpcode::kParameter:\n      case IrOpcode::kPhi:\n      case IrOpcode::kEffectPhi:\n        continue;\n    }\n    break;\n  }\n  return i;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IntPtrConstant\",\n            \"about\": \"Creates an integer constant node of the appropriate size (32 or 64 bit) based on the system pointer size.\",\n            \"logic\": \"Uses CommonOperatorBuilder to create either an Int64Constant or Int32Constant based on the value of kSystemPointerSize.\",\n            \"parameters\": [\n                {\n                    \"name\": \"common\",\n                    \"type\": \"CommonOperatorBuilder*\",\n                    \"purpose\": \"The operator builder\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"intptr_t\",\n                    \"purpose\": \"The constant value\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const Operator*\",\n                \"description\": \"The operator representing the integer constant\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstatic const Operator* IntPtrConstant(CommonOperatorBuilder* common,\n                                      intptr_t value) {\n  return kSystemPointerSize == 8\n             ? common->Int64Constant(value)\n             : common->Int32Constant(static_cast<int32_t>(value));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PointerConstant\",\n            \"about\": \"Creates a pointer constant node by casting the pointer to an integer and then creating an integer constant.\",\n            \"logic\": \"Reinterprets the pointer as an intptr_t and then calls IntPtrConstant to create the constant node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"common\",\n                    \"type\": \"CommonOperatorBuilder*\",\n                    \"purpose\": \"The operator builder\"\n                },\n                {\n                    \"name\": \"ptr\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The pointer value\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const Operator*\",\n                \"description\": \"The operator representing the pointer constant\"\n            },\n            \"dependencies\": [\n                \"IntPtrConstant\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic const Operator* PointerConstant(CommonOperatorBuilder* common,\n                                       const void* ptr) {\n  intptr_t ptr_as_int = reinterpret_cast<intptr_t>(ptr);\n  return IntPtrConstant(common, ptr_as_int);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BasicBlockInstrumentor\",\n            \"about\": \"Instruments the code with increment instructions to profile basic block execution counts.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass BasicBlockInstrumentor {\n public:\n  BasicBlockProfilerData* Instrument(OptimizedCompilationInfo* info, TFGraph* graph, Schedule* schedule, Isolate* isolate);\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Instrument\",\n            \"parent\": \"BasicBlockInstrumentor\",\n            \"about\": \"Instruments the graph with increment instructions at the start of each basic block to track execution counts.\",\n            \"logic\": \"Iterates through the basic blocks, creating load, increment, and store instructions to update a counter for each block. It also handles on-heap counters (for builtins) and off-heap counters.  It adds branches for profiling.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"OptimizedCompilationInfo*\",\n                    \"purpose\": \"Compilation info\"\n                },\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"TFGraph*\",\n                    \"purpose\": \"The Turbofan graph\"\n                },\n                {\n                    \"name\": \"schedule\",\n                    \"type\": \"Schedule*\",\n                    \"purpose\": \"The schedule of the graph\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"BasicBlockProfilerData*\",\n                \"description\": \"Pointer to the BasicBlockProfilerData containing profiling information\"\n            },\n            \"dependencies\": [\n                \"BasicBlockProfiler\",\n                \"CommonOperatorBuilder\",\n                \"MachineOperatorBuilder\",\n                \"PointerConstant\",\n                \"IntPtrConstant\",\n                \"FindInsertionPoint\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nBasicBlockProfilerData* BasicBlockInstrumentor::Instrument(\n    OptimizedCompilationInfo* info, TFGraph* graph, Schedule* schedule,\n    Isolate* isolate) {\n  // Basic block profiling disables concurrent compilation, so handle deref is\n  // fine.\n  AllowHandleDereference allow_handle_dereference;\n  // Skip the exit block in profiles, since the register allocator can't handle\n  // it and entry into it means falling off the end of the function anyway.\n  size_t n_blocks = schedule->RpoBlockCount();\n  BasicBlockProfilerData* data = BasicBlockProfiler::Get()->NewData(n_blocks);\n  // Set the function name.\n  data->SetFunctionName(info->GetDebugName());\n  // Capture the schedule string before instrumentation.\n  if (v8_flags.turbo_profiling_verbose) {\n    std::ostringstream os;\n    os << *schedule;\n    data->SetSchedule(os);\n  }\n  // Check whether we should write counts to a JS heap object or to the\n  // BasicBlockProfilerData directly. The JS heap object is only used for\n  // builtins.\n  bool on_heap_counters = isolate && isolate->IsGeneratingEmbeddedBuiltins();\n  // Add the increment instructions to the start of every block.\n  CommonOperatorBuilder common(graph->zone());\n  MachineOperatorBuilder machine(graph->zone());\n  Node* counters_array = nullptr;\n  if (on_heap_counters) {\n    // Allocation is disallowed here, so rather than referring to an actual\n    // counters array, create a reference to a special marker object. This\n    // object will get fixed up later in the constants table (see\n    // PatchBasicBlockCountersReference). An important and subtle point: we\n    // cannot use the root handle basic_block_counters_marker_handle() and must\n    // create a new separate handle. Otherwise\n    // MacroAssemblerBase::IndirectLoadConstant would helpfully emit a\n    // root-relative load rather than putting this value in the constants table\n    // where we expect it to be for patching.\n    counters_array = graph->NewNode(common.HeapConstant(Handle<HeapObject>::New(\n        ReadOnlyRoots(isolate).basic_block_counters_marker(), isolate)));\n  } else {\n    counters_array = graph->NewNode(PointerConstant(&common, data->counts()));\n  }\n  Node* zero = graph->NewNode(common.Int32Constant(0));\n  Node* one = graph->NewNode(common.Int32Constant(1));\n  BasicBlockVector* blocks = schedule->rpo_order();\n  size_t block_number = 0;\n  for (BasicBlockVector::iterator it = blocks->begin(); block_number < n_blocks;\n       ++it, ++block_number) {\n    BasicBlock* block = (*it);\n    if (block == schedule->end()) continue;\n    // Iteration is already in reverse post-order.\n    DCHECK_EQ(block->rpo_number(), block_number);\n    data->SetBlockId(block_number, block->id().ToInt());\n    // It is unnecessary to wire effect and control deps for load and store\n    // since this happens after scheduling.\n    // Construct increment operation.\n    int offset_to_counter_value = static_cast<int>(block_number) * kInt32Size;\n    if (on_heap_counters) {\n      offset_to_counter_value +=\n          OFFSET_OF_DATA_START(ByteArray) - kHeapObjectTag;\n    }\n    Node* offset_to_counter =\n        graph->NewNode(IntPtrConstant(&common, offset_to_counter_value));\n    Node* load =\n        graph->NewNode(machine.Load(MachineType::Uint32()), counters_array,\n                       offset_to_counter, graph->start(), graph->start());\n    Node* inc = graph->NewNode(machine.Int32Add(), load, one);\n\n    // Branchless saturation, because we've already run the scheduler, so\n    // introducing extra control flow here would be surprising.\n    Node* overflow = graph->NewNode(machine.Uint32LessThan(), inc, load);\n    Node* overflow_mask = graph->NewNode(machine.Int32Sub(), zero, overflow);\n    Node* saturated_inc =\n        graph->NewNode(machine.Word32Or(), inc, overflow_mask);\n\n    Node* store =\n        graph->NewNode(machine.Store(StoreRepresentation(\n                           MachineRepresentation::kWord32, kNoWriteBarrier)),\n                       counters_array, offset_to_counter, saturated_inc,\n                       graph->start(), graph->start());\n    // Insert the new nodes.\n    static const int kArraySize = 10;\n    Node* to_insert[kArraySize] = {\n        counters_array, zero, one,      offset_to_counter,\n        load,           inc,  overflow, overflow_mask,\n        saturated_inc,  store};\n    // The first three Nodes are constant across all blocks.\n    int insertion_start = block_number == 0 ? 0 : 3;\n    NodeVector::iterator insertion_point = FindInsertionPoint(block);\n    block->InsertNodes(insertion_point, &to_insert[insertion_start],\n                       &to_insert[kArraySize]);\n    // Tell the scheduler about the new nodes.\n    for (int i = insertion_start; i < kArraySize; ++i) {\n      schedule->SetBlockForNode(block, to_insert[i]);\n    }\n    // The exit block is not instrumented and so we must ignore that block\n    // count.\n    if (block->control() == BasicBlock::kBranch &&\n        block->successors()[0] != schedule->end() &&\n        block->successors()[1] != schedule->end()) {\n      data->AddBranch(block->successors()[0]->id().ToInt(),\n                      block->successors()[1]->id().ToInt());\n    }\n  }\n  return data;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"StoreBuiltinCallForNode\",\n            \"about\": \"Stores builtin call information for a given node in the call graph profiler.\",\n            \"logic\": \"Checks if the node is a call or tail call to a builtin. If so, extracts the builtin ID and adds it to the call graph.\",\n            \"parameters\": [\n                {\n                    \"name\": \"n\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to check for a builtin call\"\n                },\n                {\n                    \"name\": \"builtin\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin ID of the current function being compiled\"\n                },\n                {\n                    \"name\": \"block_id\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The ID of the basic block containing the node\"\n                },\n                {\n                    \"name\": \"bcc_profiler\",\n                    \"type\": \"BuiltinsCallGraph*\",\n                    \"purpose\": \"The call graph profiler\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nvoid StoreBuiltinCallForNode(Node* n, Builtin builtin, int block_id,\n                             BuiltinsCallGraph* bcc_profiler) {\n  if (n == nullptr) return;\n  IrOpcode::Value opcode = n->opcode();\n  if (opcode == IrOpcode::kCall || opcode == IrOpcode::kTailCall) {\n    const CallDescriptor* des = CallDescriptorOf(n->op());\n    if (des->kind() == CallDescriptor::kCallCodeObject) {\n      Node* callee = n->InputAt(0);\n      Operator* op = const_cast<Operator*>(callee->op());\n      if (op->opcode() == IrOpcode::kHeapConstant) {\n        IndirectHandle<HeapObject> para =\n            OpParameter<IndirectHandle<HeapObject>>(op);\n        if (IsCode(*para)) {\n          DirectHandle<Code> code = Cast<Code>(para);\n          if (code->is_builtin()) {\n            bcc_profiler->AddBuiltinCall(builtin, code->builtin_id(), block_id);\n            return;\n          }\n        }\n      }\n    }\n  }\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"StoreCallGraph\",\n            \"parent\": \"BasicBlockCallGraphProfiler\",\n            \"about\": \"Stores the call graph information for a given schedule by iterating through the basic blocks and nodes.\",\n            \"logic\": \"Iterates through each basic block and its nodes, calling StoreBuiltinCallForNode to record any builtin calls. Also examines the control input node of branch blocks.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"OptimizedCompilationInfo*\",\n                    \"purpose\": \"Compilation info containing the builtin ID\"\n                },\n                {\n                    \"name\": \"schedule\",\n                    \"type\": \"Schedule*\",\n                    \"purpose\": \"The schedule of the graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"StoreBuiltinCallForNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BasicBlockCallGraphProfiler::StoreCallGraph(OptimizedCompilationInfo* info,\n                                                 Schedule* schedule) {\n  CHECK(Builtins::IsBuiltinId(info->builtin()));\n  BasicBlockVector* blocks = schedule->rpo_order();\n  size_t block_number = 0;\n  size_t n_blocks = schedule->RpoBlockCount();\n  for (BasicBlockVector::iterator it = blocks->begin(); block_number < n_blocks;\n       ++it, ++block_number) {\n    BasicBlock* block = (*it);\n    if (block == schedule->end()) continue;\n    // Iteration is already in reverse post-order.\n    DCHECK_EQ(block->rpo_number(), block_number);\n    int block_id = block->id().ToInt();\n\n    BuiltinsCallGraph* profiler = BuiltinsCallGraph::Get();\n\n    for (Node* node : *block) {\n      StoreBuiltinCallForNode(node, info->builtin(), block_id, profiler);\n    }\n\n    BasicBlock::Control control = block->control();\n    if (control != BasicBlock::kNone) {\n      Node* cnt_node = block->control_input();\n      StoreBuiltinCallForNode(cnt_node, info->builtin(), block_id, profiler);\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsBuiltinCall\",\n            \"about\": \"Determines whether a given Turboshaft operation is a call to a builtin.\",\n            \"logic\": \"Checks if the operation is a call or tail call with a code object call descriptor and if the callee is a heap constant that refers to a builtin code object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const turboshaft::Operation&\",\n                    \"purpose\": \"The Turboshaft operation to check\"\n                },\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"const turboshaft::Graph&\",\n                    \"purpose\": \"The Turboshaft graph containing the operation\"\n                },\n                {\n                    \"name\": \"called_builtin\",\n                    \"type\": \"Builtin*\",\n                    \"purpose\": \"Output parameter to store the called builtin ID\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the operation is a call to a builtin, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsBuiltinCall(const turboshaft::Operation& op,\n                   const turboshaft::Graph& graph, Builtin* called_builtin) {\n  using namespace turboshaft;  // NOLINT(build/namespaces)\n  DCHECK_NOT_NULL(called_builtin);\n  const TSCallDescriptor* ts_descriptor;\n  V<CallTarget> callee_index;\n  if (const auto* call_op = op.TryCast<CallOp>()) {\n    ts_descriptor = call_op->descriptor;\n    callee_index = call_op->callee();\n  } else if (const auto* tail_call_op = op.TryCast<TailCallOp>()) {\n    ts_descriptor = tail_call_op->descriptor;\n    callee_index = tail_call_op->callee();\n  } else {\n    return false;\n  }\n\n  DCHECK_NOT_NULL(ts_descriptor);\n  if (ts_descriptor->descriptor->kind() != CallDescriptor::kCallCodeObject) {\n    return false;\n  }\n\n  OperationMatcher matcher(graph);\n  Handle<HeapObject> heap_constant;\n  if (!matcher.MatchHeapConstant(callee_index, &heap_constant)) return false;\n  if (!IsCode(*heap_constant)) return false;\n  DirectHandle<Code> code = Cast<Code>(heap_constant);\n  if (!code->is_builtin()) return false;\n\n  *called_builtin = code->builtin_id();\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"StoreCallGraph\",\n            \"parent\": \"BasicBlockCallGraphProfiler\",\n            \"about\": \"Stores the call graph information for a Turboshaft graph by iterating through its blocks and operations.\",\n            \"logic\": \"Iterates through each basic block and its operations, calling IsBuiltinCall to check if each operation is a call to a builtin. If so, records the builtin call in the call graph profiler.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"OptimizedCompilationInfo*\",\n                    \"purpose\": \"Compilation info containing the builtin ID\"\n                },\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"const turboshaft::Graph&\",\n                    \"purpose\": \"The Turboshaft graph to analyze\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"IsBuiltinCall\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BasicBlockCallGraphProfiler::StoreCallGraph(\n    OptimizedCompilationInfo* info, const turboshaft::Graph& graph) {\n  using namespace turboshaft;  // NOLINT(build/namespaces)\n  CHECK(Builtins::IsBuiltinId(info->builtin()));\n  BuiltinsCallGraph* profiler = BuiltinsCallGraph::Get();\n\n  for (const Block* block : graph.blocks_vector()) {\n    const int block_id = block->index().id();\n    for (const auto& op : graph.operations(*block)) {\n      Builtin called_builtin;\n      if (IsBuiltinCall(op, graph, &called_builtin)) {\n        profiler->AddBuiltinCall(info->builtin(), called_builtin, block_id);\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BasicBlockCallGraphProfiler\",\n            \"about\": \"Profiles call graph of builtins functions within basic blocks.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass BasicBlockCallGraphProfiler {\n public:\n  static void StoreCallGraph(OptimizedCompilationInfo* info,\n                                                 Schedule* schedule);\n  static void StoreCallGraph(\n    OptimizedCompilationInfo* info, const turboshaft::Graph& graph);\n};\n        ]]></code>\n    </class>\n</file>\n```"
}