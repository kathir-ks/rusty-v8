{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/global-context.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 75, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/global-context.h\",\n        \"file_name\": \"global-context.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the GlobalContext class, which provides global state and utility functions for the Torque compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary standard library headers and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <map>\n#include <memory>\n\n#include \"src/base/contextual.h\"\n#include \"src/common/globals.h\"\n#include \"src/torque/ast.h\"\n#include \"src/torque/cpp-builder.h\"\n#include \"src/torque/declarable.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GlobalContext\",\n            \"extends\": \"base::ContextualClass<GlobalContext>\",\n            \"about\": \"Provides global state and utility functions for the Torque compiler.  It's a singleton accessible via static methods.\",\n            \"attributes\": [\n                {\n                    \"name\": \"collect_language_server_data_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to indicate if language server data should be collected.\"\n                },\n                {\n                    \"name\": \"collect_kythe_data_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to indicate if Kythe data should be collected.\"\n                },\n                {\n                    \"name\": \"force_assert_statements_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to force generation of assert statements.\"\n                },\n                {\n                    \"name\": \"annotate_ir_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to enable IR annotation.\"\n                },\n                {\n                    \"name\": \"default_namespace_\",\n                    \"type\": \"Namespace*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the default namespace.\"\n                },\n                {\n                    \"name\": \"ast_\",\n                    \"type\": \"Ast\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The abstract syntax tree.\"\n                },\n                {\n                    \"name\": \"declarables_\",\n                    \"type\": \"std::vector<std::unique_ptr<Declarable>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector of unique pointers to Declarable objects.\"\n                },\n                {\n                    \"name\": \"cpp_includes_\",\n                    \"type\": \"std::set<std::string>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A set of C++ include paths.\"\n                },\n                {\n                    \"name\": \"generated_per_file_\",\n                    \"type\": \"std::map<SourceId, PerFileStreams>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A map of PerFileStreams objects, keyed by SourceId.\"\n                },\n                {\n                    \"name\": \"fresh_ids_\",\n                    \"type\": \"std::map<std::string, size_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A map to generate unique names based on a base name.\"\n                },\n                {\n                    \"name\": \"macros_for_cc_output_\",\n                    \"type\": \"std::vector<std::pair<TorqueMacro*, SourceId>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector of TorqueMacro/SourceId pairs for C++ output.\"\n                },\n                {\n                    \"name\": \"macros_for_cc_output_set_\",\n                    \"type\": \"std::set<std::pair<TorqueMacro*, SourceId>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A set of TorqueMacro/SourceId pairs for C++ output (used for uniqueness).\"\n                },\n                {\n                    \"name\": \"macros_for_cc_debug_output_\",\n                    \"type\": \"std::vector<std::pair<TorqueMacro*, SourceId>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector of TorqueMacro/SourceId pairs for C++ debug output.\"\n                },\n                {\n                    \"name\": \"macros_for_cc_debug_output_set_\",\n                    \"type\": \"std::set<std::pair<TorqueMacro*, SourceId>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A set of TorqueMacro/SourceId pairs for C++ debug output (used for uniqueness).\"\n                },\n                {\n                    \"name\": \"instance_types_initialized_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to indicate if instance types are initialized.\"\n                }\n            ],\n            \"dependencies\": [\n                \"base::ContextualClass\",\n                \"Ast\",\n                \"Declarable\",\n                \"SourceId\",\n                \"TorqueMacro\",\n                \"Namespace\",\n                \"cpp::File\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass GlobalContext : public base::ContextualClass<GlobalContext> {\n public:\n  GlobalContext(GlobalContext&&) V8_NOEXCEPT = default;\n  GlobalContext& operator=(GlobalContext&&) V8_NOEXCEPT = default;\n  explicit GlobalContext(Ast ast);\n\n  static Namespace* GetDefaultNamespace() { return Get().default_namespace_; }\n  template <class T>\n  T* RegisterDeclarable(std::unique_ptr<T> d) {\n    T* ptr = d.get();\n    declarables_.push_back(std::move(d));\n    return ptr;\n  }\n\n  static const std::vector<std::unique_ptr<Declarable>>& AllDeclarables() {\n    return Get().declarables_;\n  }\n\n  static void AddCppInclude(std::string include_path) {\n    Get().cpp_includes_.insert(std::move(include_path));\n  }\n  static const std::set<std::string>& CppIncludes() {\n    return Get().cpp_includes_;\n  }\n\n  static void SetCollectLanguageServerData() {\n    Get().collect_language_server_data_ = true;\n  }\n  static bool collect_language_server_data() {\n    return Get().collect_language_server_data_;\n  }\n  static void SetCollectKytheData() { Get().collect_kythe_data_ = true; }\n  static bool collect_kythe_data() { return Get().collect_kythe_data_; }\n  static void SetForceAssertStatements() {\n    Get().force_assert_statements_ = true;\n  }\n  static bool force_assert_statements() {\n    return Get().force_assert_statements_;\n  }\n  static void SetAnnotateIR() { Get().annotate_ir_ = true; }\n  static bool annotate_ir() { return Get().annotate_ir_; }\n  static Ast* ast() { return &Get().ast_; }\n  static std::string MakeUniqueName(const std::string& base) {\n    return base + \"_\" + std::to_string(Get().fresh_ids_[base]++);\n  }\n\n  struct PerFileStreams {\n    PerFileStreams()\n        : file(SourceId::Invalid()),\n          csa_header(csa_headerfile),\n          csa_cc(csa_ccfile),\n          class_definition_cc(class_definition_ccfile) {}\n    SourceId file;\n    std::stringstream csa_headerfile;\n    cpp::File csa_header;\n    std::stringstream csa_ccfile;\n    cpp::File csa_cc;\n\n    std::stringstream class_definition_headerfile;\n\n    // The beginning of the generated -inl.inc file, which includes declarations\n    // for functions corresponding to Torque macros.\n    std::stringstream class_definition_inline_headerfile_macro_declarations;\n    // The second part of the generated -inl.inc file, which includes\n    // definitions for functions declared in the first part.\n    std::stringstream class_definition_inline_headerfile_macro_definitions;\n    // The portion of the generated -inl.inc file containing member function\n    // definitions for the generated class.\n    std::stringstream class_definition_inline_headerfile;\n\n    std::stringstream class_definition_ccfile;\n    cpp::File class_definition_cc;\n\n    std::set<SourceId> required_builtin_includes;\n  };\n  static PerFileStreams& GeneratedPerFile(SourceId file) {\n    PerFileStreams& result = Get().generated_per_file_[file];\n    result.file = file;\n    return result;\n  }\n\n  static void SetInstanceTypesInitialized() {\n    DCHECK(!Get().instance_types_initialized_);\n    Get().instance_types_initialized_ = true;\n  }\n  static bool IsInstanceTypesInitialized() {\n    return Get().instance_types_initialized_;\n  }\n  static void EnsureInCCOutputList(TorqueMacro* macro, SourceId source) {\n    GlobalContext& c = Get();\n    auto item = std::make_pair(macro, source);\n    if (c.macros_for_cc_output_set_.insert(item).second) {\n      c.macros_for_cc_output_.push_back(item);\n    }\n    EnsureInCCDebugOutputList(macro, source);\n  }\n  static const std::vector<std::pair<TorqueMacro*, SourceId>>&\n  AllMacrosForCCOutput() {\n    return Get().macros_for_cc_output_;\n  }\n  static void EnsureInCCDebugOutputList(TorqueMacro* macro, SourceId source) {\n    GlobalContext& c = Get();\n    auto item = std::make_pair(macro, source);\n    if (c.macros_for_cc_debug_output_set_.insert(item).second) {\n      c.macros_for_cc_debug_output_.push_back(item);\n    }\n  }\n  static const std::vector<std::pair<TorqueMacro*, SourceId>>&\n  AllMacrosForCCDebugOutput() {\n    return Get().macros_for_cc_debug_output_;\n  }\n\n private:\n  bool collect_language_server_data_;\n  bool collect_kythe_data_;\n  bool force_assert_statements_;\n  bool annotate_ir_;\n  Namespace* default_namespace_;\n  Ast ast_;\n  std::vector<std::unique_ptr<Declarable>> declarables_;\n  std::set<std::string> cpp_includes_;\n  std::map<SourceId, PerFileStreams> generated_per_file_;\n  std::map<std::string, size_t> fresh_ids_;\n  std::vector<std::pair<TorqueMacro*, SourceId>> macros_for_cc_output_;\n  std::set<std::pair<TorqueMacro*, SourceId>> macros_for_cc_output_set_;\n  std::vector<std::pair<TorqueMacro*, SourceId>> macros_for_cc_debug_output_;\n  std::set<std::pair<TorqueMacro*, SourceId>> macros_for_cc_debug_output_set_;\n  bool instance_types_initialized_ = false;\n\n  friend class LanguageServerData;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"RegisterDeclarable\",\n            \"about\": \"Registers a Declarable object in the global context.\",\n            \"logic\": \"This is a template function that calls the RegisterDeclarable method of the GlobalContext singleton.\",\n            \"parameters\": [\n                {\n                    \"name\": \"d\",\n                    \"type\": \"std::unique_ptr<T>\",\n                    \"purpose\": \"A unique pointer to the Declarable object to register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T*\",\n                \"description\": \"A raw pointer to the registered Declarable object.\"\n            },\n            \"dependencies\": [\n                \"GlobalContext\",\n                \"Declarable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nT* RegisterDeclarable(std::unique_ptr<T> d) {\n  return GlobalContext::Get().RegisterDeclarable(std::move(d));\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TargetArchitecture\",\n            \"extends\": \"base::ContextualClass<TargetArchitecture>\",\n            \"about\": \"Provides information about the target architecture, such as pointer sizes.\",\n            \"attributes\": [\n                {\n                    \"name\": \"tagged_size_\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The size of a tagged value.\"\n                },\n                {\n                    \"name\": \"raw_ptr_size_\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The size of a raw pointer.\"\n                },\n                {\n                    \"name\": \"smi_tag_and_shift_size_\",\n                    \"type\": \"const int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The size of the Smi tag and shift.\"\n                },\n                {\n                    \"name\": \"external_ptr_size_\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The size of an external pointer.\"\n                },\n                {\n                    \"name\": \"cppheap_ptr_size_\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The size of a C++ heap pointer.\"\n                },\n                {\n                    \"name\": \"trusted_ptr_size_\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The size of a trusted pointer.\"\n                }\n            ],\n            \"dependencies\": [\n                \"base::ContextualClass\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass TargetArchitecture : public base::ContextualClass<TargetArchitecture> {\n public:\n  explicit TargetArchitecture(bool force_32bit);\n\n  static size_t TaggedSize() { return Get().tagged_size_; }\n  static size_t RawPtrSize() { return Get().raw_ptr_size_; }\n  static size_t ExternalPointerSize() { return Get().external_ptr_size_; }\n  static size_t CppHeapPointerSize() { return Get().cppheap_ptr_size_; }\n  static size_t TrustedPointerSize() { return Get().trusted_ptr_size_; }\n  static size_t ProtectedPointerSize() { return TaggedSize(); }\n  static size_t MaxHeapAlignment() { return TaggedSize(); }\n  static bool ArePointersCompressed() { return TaggedSize() < RawPtrSize(); }\n  static int SmiTagAndShiftSize() { return Get().smi_tag_and_shift_size_; }\n\n private:\n  const size_t tagged_size_;\n  const size_t raw_ptr_size_;\n  const int smi_tag_and_shift_size_;\n  const size_t external_ptr_size_;\n  const size_t cppheap_ptr_size_;\n  const size_t trusted_ptr_size_;\n};\n        ]]></code>\n    </class>\n</file>\n```"
}