{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/server-data.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 51, column 46",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/server-data.cc\",\n        \"file_name\": \"server-data.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides data structures and functions for language server features in the Torque compiler, such as finding definitions and preparing symbols.\"\n    }\n    </metadata>\n\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for server data functionality, optional types, macros, declarables, and implementation visitor.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/server-data.h\"\n\n#include <optional>\n\n#include \"src/base/macros.h\"\n#include \"src/torque/declarable.h\"\n#include \"src/torque/implementation-visitor.h\"\n        ]]></code>\n    </imports>\n\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Imports the EXPORT_CONTEXTUAL_VARIABLE macro.  Not sure what it does.\"\n        }\n        </metadata>\n        <code><![CDATA[\nEXPORT_CONTEXTUAL_VARIABLE(v8::internal::torque::LanguageServerData)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LanguageServerData\",\n            \"about\": \"Provides data structures and functions for language server features in the Torque compiler.\",\n            \"attributes\": [\n                {\n                    \"name\": \"definitions_map_\",\n                    \"type\": \"std::map<SourceId, std::vector<DefinitionMapping>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps source IDs to lists of definition mappings (token and definition positions).\"\n                },\n                {\n                    \"name\": \"symbols_map_\",\n                    \"type\": \"std::map<SourceId, std::vector<Declarable*>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps source IDs to lists of Declarable pointers (symbols).\"\n                }\n            ],\n            \"dependencies\": [\n                \"SourceId\",\n                \"DefinitionMapping\",\n                \"Declarable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::torque {\n\nvoid LanguageServerData::AddDefinition(SourcePosition token,\n                                       SourcePosition definition) {\n  Get().definitions_map_[token.source].emplace_back(token, definition);\n}\n\nstd::optional<SourcePosition> LanguageServerData::FindDefinition(\n    SourceId source, LineAndColumn pos) {\n  if (!source.IsValid()) return std::nullopt;\n\n  auto iter = Get().definitions_map_.find(source);\n  if (iter == Get().definitions_map_.end()) return std::nullopt;\n\n  for (const DefinitionMapping& mapping : iter->second) {\n    SourcePosition current = mapping.first;\n    if (current.Contains(pos)) return mapping.second;\n  }\n\n  return std::nullopt;\n}\n\nvoid LanguageServerData::PrepareAllDeclarableSymbols() {\n  const std::vector<std::unique_ptr<Declarable>>& all_declarables =\n      global_context_->declarables_;\n\n  for (const auto& declarable : all_declarables) {\n    // Class field accessors and implicit specializations are\n    // auto-generated and should not show up.\n    if (!declarable->IsUserDefined()) continue;\n\n    SourceId source = declarable->Position().source;\n    symbols_map_[source].push_back(declarable.get());\n  }\n}\n\n}  // namespace v8::internal::torque\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddDefinition\",\n            \"parent\": \"LanguageServerData\",\n            \"about\": \"Adds a definition mapping to the definitions map.\",\n            \"logic\": \"Adds a mapping from a token's source position to its definition's source position to the definitions_map_.\",\n            \"parameters\": [\n                {\n                    \"name\": \"token\",\n                    \"type\": \"SourcePosition\",\n                    \"purpose\": \"The source position of the token.\"\n                },\n                {\n                    \"name\": \"definition\",\n                    \"type\": \"SourcePosition\",\n                    \"purpose\": \"The source position of the definition.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"SourcePosition\",\n                \"Get\",\n                \"definitions_map_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LanguageServerData::AddDefinition(SourcePosition token,\n                                       SourcePosition definition) {\n  Get().definitions_map_[token.source].emplace_back(token, definition);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FindDefinition\",\n            \"parent\": \"LanguageServerData\",\n            \"about\": \"Finds the definition corresponding to a given source ID and position.\",\n            \"logic\": \"Iterates through the definitions map for the given source ID and returns the definition if the given position is contained within a token's source position.\",\n            \"parameters\": [\n                {\n                    \"name\": \"source\",\n                    \"type\": \"SourceId\",\n                    \"purpose\": \"The source ID to search in.\"\n                },\n                {\n                    \"name\": \"pos\",\n                    \"type\": \"LineAndColumn\",\n                    \"purpose\": \"The line and column position to search for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<SourcePosition>\",\n                \"description\": \"The source position of the definition, or std::nullopt if not found.\"\n            },\n            \"dependencies\": [\n                \"SourceId\",\n                \"LineAndColumn\",\n                \"SourcePosition\",\n                \"Get\",\n                \"definitions_map_\",\n                \"DefinitionMapping\",\n                \"IsValid\",\n                \"Contains\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::optional<SourcePosition> LanguageServerData::FindDefinition(\n    SourceId source, LineAndColumn pos) {\n  if (!source.IsValid()) return std::nullopt;\n\n  auto iter = Get().definitions_map_.find(source);\n  if (iter == Get().definitions_map_.end()) return std::nullopt;\n\n  for (const DefinitionMapping& mapping : iter->second) {\n    SourcePosition current = mapping.first;\n    if (current.Contains(pos)) return mapping.second;\n  }\n\n  return std::nullopt;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PrepareAllDeclarableSymbols\",\n            \"parent\": \"LanguageServerData\",\n            \"about\": \"Prepares a map of declarable symbols for language server features.\",\n            \"logic\": \"Iterates through all declarables in the global context and adds them to the symbols map, excluding auto-generated class field accessors and implicit specializations.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Declarable\",\n                \"global_context_\",\n                \"declarables_\",\n                \"symbols_map_\",\n                \"IsUserDefined\",\n                \"Position\",\n                \"SourceId\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid LanguageServerData::PrepareAllDeclarableSymbols() {\n  const std::vector<std::unique_ptr<Declarable>>& all_declarables =\n      global_context_->declarables_;\n\n  for (const auto& declarable : all_declarables) {\n    // Class field accessors and implicit specializations are\n    // auto-generated and should not show up.\n    if (!declarable->IsUserDefined()) continue;\n\n    SourceId source = declarable->Position().source;\n    symbols_map_[source].push_back(declarable.get());\n  }\n}\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SourcePosition\",\n                \"about\": \"Represents a position in the source code.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SourcePosition {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SourceId\",\n                \"about\": \"Represents the ID of a source file.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SourceId {\n                 public:\n                  bool IsValid() {return true;}\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LineAndColumn\",\n                \"about\": \"Represents a line and column position in the source code.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class LineAndColumn {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Declarable\",\n                \"about\": \"Represents a declarable entity in the Torque language.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Declarable {\n                 public:\n                  bool IsUserDefined() {return true;}\n                  SourcePosition Position() {return SourcePosition();}\n                };\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Get\",\n                \"about\": \"Retrieves a singleton instance of LanguageServerData.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                LanguageServerData& Get();\n            ]]></code>\n        </func>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DefinitionMapping\",\n                \"about\": \"Pair of SourcePositions\"\n            }\n            </metadata>\n            <code><![CDATA[\n                using DefinitionMapping = std::pair<SourcePosition, SourcePosition>;\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}