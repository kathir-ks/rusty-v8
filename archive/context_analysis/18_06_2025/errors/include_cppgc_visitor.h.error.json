{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/visitor.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/visitor.h\",\n        \"file_name\": \"visitor.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Visitor class and related functionality for traversing garbage-collected objects in cppgc.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library and cppgc headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <type_traits>\n\n            #include \"cppgc/custom-space.h\"\n            #include \"cppgc/ephemeron-pair.h\"\n            #include \"cppgc/garbage-collected.h\"\n            #include \"cppgc/internal/logging.h\"\n            #include \"cppgc/internal/member-storage.h\"\n            #include \"cppgc/internal/pointer-policies.h\"\n            #include \"cppgc/liveness-broker.h\"\n            #include \"cppgc/member.h\"\n            #include \"cppgc/sentinel-pointer.h\"\n            #include \"cppgc/source-location.h\"\n            #include \"cppgc/trace-trait.h\"\n            #include \"cppgc/type-traits.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Visitor\",\n            \"about\": \"Base class for visitors used to traverse garbage-collected objects.  Provides Trace methods for different types of managed pointers.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Member\",\n                \"WeakMember\",\n                \"LivenessBroker\",\n                \"EphemeronPair\",\n                \"TraceTrait\",\n                \"kSentinelPointer\",\n                \"subtle::UncompressedMember\",\n                \"TraceDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Visitor {\n            public:\n            class Key {\n            private:\n                Key() = default;\n                friend class internal::VisitorFactory;\n            };\n\n            explicit Visitor(Key) {}\n\n            virtual ~Visitor() = default;\n\n            template <typename T>\n            void Trace(const Member<T>& member);\n\n            template <typename T>\n            void Trace(const WeakMember<T>& weak_member);\n\n            #if defined(CPPGC_POINTER_COMPRESSION)\n            template <typename T>\n            void Trace(const subtle::UncompressedMember<T>& member);\n            #endif  // defined(CPPGC_POINTER_COMPRESSION)\n\n            template <typename T>\n            void TraceMultiple(const subtle::UncompressedMember<T>* start, size_t len);\n\n            template <typename T,\n                        std::enable_if_t<!std::is_same_v<\n                            Member<T>, subtle::UncompressedMember<T>>>* = nullptr>\n            void TraceMultiple(const Member<T>* start, size_t len);\n\n            template <typename T>\n            void Trace(const T& object);\n\n            template <typename T>\n            void TraceMultiple(const T* start, size_t len);\n\n            template <typename T, void (T::*method)(const LivenessBroker&)>\n            void RegisterWeakCallbackMethod(const T* object);\n\n            template <typename K, typename V>\n            void Trace(const EphemeronPair<K, V>& ephemeron_pair);\n\n            template <typename KeyType, typename ValueType>\n            void TraceEphemeron(const WeakMember<KeyType>& weak_member_key,\n                                const Member<ValueType>* member_value);\n\n            template <typename KeyType, typename ValueType>\n            void TraceEphemeron(const WeakMember<KeyType>& weak_member_key,\n                                const ValueType* value);\n\n            template <typename T>\n            void TraceStrongly(const WeakMember<T>& weak_member);\n\n            template <typename T>\n            void TraceStrongContainer(const T* object);\n\n            template <typename T>\n            void TraceWeakContainer(const T* object, WeakCallback callback,\n                                    const void* callback_data);\n\n            template <typename T>\n            void RegisterMovableReference(const T** slot);\n\n            virtual void RegisterWeakCallback(WeakCallback callback, const void* data) {}\n\n            virtual V8_WARN_UNUSED_RESULT bool DeferTraceToMutatorThreadIfConcurrent(\n                const void* parameter, TraceCallback callback, size_t deferred_size);\n\n            protected:\n            virtual void Visit(const void* self, TraceDescriptor) {}\n            virtual void VisitWeak(const void* self, TraceDescriptor, WeakCallback,\n                                    const void* weak_member) {}\n            virtual void VisitEphemeron(const void* key, const void* value,\n                                        TraceDescriptor value_desc) {}\n            virtual void VisitWeakContainer(const void* self, TraceDescriptor strong_desc,\n                                            TraceDescriptor weak_desc,\n                                            WeakCallback callback, const void* data) {}\n            virtual void HandleMovableReference(const void**) {}\n\n            virtual void VisitMultipleUncompressedMember(\n                const void* start, size_t len,\n                TraceDescriptorCallback get_trace_descriptor);\n\n            #if defined(CPPGC_POINTER_COMPRESSION)\n            virtual void VisitMultipleCompressedMember(\n                const void* start, size_t len,\n                TraceDescriptorCallback get_trace_descriptor);\n            #endif  // defined(CPPGC_POINTER_COMPRESSION)\n\n            private:\n            template <typename T, void (T::*method)(const LivenessBroker&)>\n            static void WeakCallbackMethodDelegate(const LivenessBroker& info,\n                                                    const void* self);\n\n            template <typename PointerType>\n            static void HandleWeak(const LivenessBroker& info, const void* object);\n\n            template <typename T>\n            void TraceImpl(const T* t);\n\n            #if V8_ENABLE_CHECKS\n            void CheckObjectNotInConstruction(const void* address);\n            #endif  // V8_ENABLE_CHECKS\n\n            template <typename T, typename WeaknessPolicy, typename LocationPolicy,\n                        typename CheckingPolicy>\n            friend class internal::BasicCrossThreadPersistent;\n            template <typename T, typename WeaknessPolicy, typename LocationPolicy,\n                        typename CheckingPolicy>\n            friend class internal::BasicPersistent;\n            friend class internal::ConservativeTracingVisitor;\n            friend class internal::VisitorBase;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Trace\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a Member, marking the referenced object as reachable.\",\n            \"logic\": \"Gets the raw atomic pointer from the Member and calls TraceImpl to handle the actual tracing.\",\n            \"parameters\": [\n                {\n                    \"name\": \"member\",\n                    \"type\": \"const Member<T>&\",\n                    \"purpose\": \"The Member to trace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TraceImpl\",\n                \"kSentinelPointer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void Trace(const Member<T>& member) {\n                const T* value = member.GetRawAtomic();\n                CPPGC_DCHECK(value != kSentinelPointer);\n                TraceImpl(value);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Trace\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a WeakMember, registering a weak reference to the referenced object.\",\n            \"logic\": \"Gets the raw atomic pointer from the WeakMember. If the pointer is not null, registers a weak callback to clear the WeakMember if the object is collected.\",\n            \"parameters\": [\n                {\n                    \"name\": \"weak_member\",\n                    \"type\": \"const WeakMember<T>&\",\n                    \"purpose\": \"The WeakMember to trace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitWeak\",\n                \"TraceTrait\",\n                \"kSentinelPointer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void Trace(const WeakMember<T>& weak_member) {\n                static_assert(sizeof(T), \"Pointee type must be fully defined.\");\n                static_assert(internal::IsGarbageCollectedOrMixinType<T>::value,\n                            \"T must be GarbageCollected or GarbageCollectedMixin type\");\n                static_assert(!internal::IsAllocatedOnCompactableSpace<T>::value,\n                            \"Weak references to compactable objects are not allowed\");\n\n                const T* value = weak_member.GetRawAtomic();\n\n                // Bailout assumes that WeakMember emits write barrier.\n                if (!value) {\n                    return;\n                }\n\n                CPPGC_DCHECK(value != kSentinelPointer);\n                VisitWeak(value, TraceTrait<T>::GetTraceDescriptor(value),\n                        &HandleWeak<WeakMember<T>>, &weak_member);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Trace\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces an UncompressedMember, marking the referenced object as reachable.  Used when pointer compression is enabled.\",\n            \"logic\": \"Gets the raw atomic pointer from the UncompressedMember and calls TraceImpl to handle the actual tracing.\",\n            \"parameters\": [\n                {\n                    \"name\": \"member\",\n                    \"type\": \"const subtle::UncompressedMember<T>&\",\n                    \"purpose\": \"The UncompressedMember to trace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TraceImpl\",\n                \"kSentinelPointer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #if defined(CPPGC_POINTER_COMPRESSION)\n            template <typename T>\n            void Trace(const subtle::UncompressedMember<T>& member) {\n                const T* value = member.GetRawAtomic();\n                CPPGC_DCHECK(value != kSentinelPointer);\n                TraceImpl(value);\n            }\n            #endif  // defined(CPPGC_POINTER_COMPRESSION)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TraceMultiple\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a range of UncompressedMember objects.\",\n            \"logic\": \"Iterates through the array of UncompressedMember objects and calls VisitMultipleUncompressedMember.\",\n            \"parameters\": [\n                {\n                    \"name\": \"start\",\n                    \"type\": \"const subtle::UncompressedMember<T>*\",\n                    \"purpose\": \"Pointer to the start of the array.\"\n                },\n                {\n                    \"name\": \"len\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The number of elements in the array.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitMultipleUncompressedMember\",\n                \"TraceTrait\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void TraceMultiple(const subtle::UncompressedMember<T>* start, size_t len) {\n                static_assert(sizeof(T), \"Pointee type must be fully defined.\");\n                static_assert(internal::IsGarbageCollectedOrMixinType<T>::value,\n                            \"T must be GarbageCollected or GarbageCollectedMixin type\");\n                VisitMultipleUncompressedMember(start, len,\n                                                    &TraceTrait<T>::GetTraceDescriptor);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TraceMultiple\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a range of Member objects, used when pointer compression is enabled.\",\n            \"logic\": \"Iterates through the array of Member objects and calls VisitMultipleCompressedMember.  The enable_if prevents this overload from being used when Member and UncompressedMember are the same type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"start\",\n                    \"type\": \"const Member<T>*\",\n                    \"purpose\": \"Pointer to the start of the array.\"\n                },\n                {\n                    \"name\": \"len\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The number of elements in the array.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitMultipleCompressedMember\",\n                \"TraceTrait\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T,\n                        std::enable_if_t<!std::is_same_v<\n                            Member<T>, subtle::UncompressedMember<T>>>* = nullptr>\n            void TraceMultiple(const Member<T>* start, size_t len) {\n                static_assert(sizeof(T), \"Pointee type must be fully defined.\");\n                static_assert(internal::IsGarbageCollectedOrMixinType<T>::value,\n                            \"T must be GarbageCollected or GarbageCollectedMixin type\");\n            #if defined(CPPGC_POINTER_COMPRESSION)\n                static_assert(std::is_same_v<Member<T>, subtle::CompressedMember<T>>,\n                            \"Member and CompressedMember must be the same.\");\n                VisitMultipleCompressedMember(start, len,\n                                                &TraceTrait<T>::GetTraceDescriptor);\n            #endif  // defined(CPPGC_POINTER_COMPRESSION)\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Trace\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces an inlined object, marking it as reachable.\",\n            \"logic\": \"Calls the Trace method of the inlined object's class using the TraceTrait.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The inlined object to trace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TraceTrait\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void Trace(const T& object) {\n            #if V8_ENABLE_CHECKS\n                // This object is embedded in potentially multiple nested objects. The\n                // outermost object must not be in construction as such objects are (a) not\n                // processed immediately, and (b) only processed conservatively if not\n                // otherwise possible.\n                CheckObjectNotInConstruction(&object);\n            #endif  // V8_ENABLE_CHECKS\n                TraceTrait<T>::Trace(this, &object);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TraceMultiple\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a range of inlined objects, marking them as reachable.\",\n            \"logic\": \"Iterates through the array of inlined objects and calls the Trace method of each object's class using the TraceTrait.\",\n            \"parameters\": [\n                {\n                    \"name\": \"start\",\n                    \"type\": \"const T*\",\n                    \"purpose\": \"Pointer to the start of the array.\"\n                },\n                {\n                    \"name\": \"len\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The number of elements in the array.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TraceTrait\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void TraceMultiple(const T* start, size_t len) {\n            #if V8_ENABLE_CHECKS\n                // This object is embedded in potentially multiple nested objects. The\n                // outermost object must not be in construction as such objects are (a) not\n                // processed immediately, and (b) only processed conservatively if not\n                // otherwise possible.\n                CheckObjectNotInConstruction(start);\n            #endif  // V8_ENABLE_CHECKS\n                for (size_t i = 0; i < len; ++i) {\n                    const T* object = &start[i];\n                    if constexpr (std::is_polymorphic_v<T>) {\n                        // The object's vtable may be uninitialized in which case the object is\n                        // not traced.\n                        if (*reinterpret_cast<const uintptr_t*>(object) == 0) continue;\n                    }\n                    TraceTrait<T>::Trace(this, object);\n                }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterWeakCallbackMethod\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Registers a weak callback method to be called when the object is collected.\",\n            \"logic\": \"Registers a weak callback method on the object using the WeakCallbackMethodDelegate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"const T*\",\n                    \"purpose\": \"The object to register the callback for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"RegisterWeakCallback\",\n                \"WeakCallbackMethodDelegate\",\n                \"LivenessBroker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, void (T::*method)(const LivenessBroker&)>\n            void RegisterWeakCallbackMethod(const T* object) {\n                RegisterWeakCallback(&WeakCallbackMethodDelegate<T, method>, object);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Trace\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces an EphemeronPair, managing the weak key and strong value relationship.\",\n            \"logic\": \"Traces the key weakly and the value strongly. Registers a weak callback to clear the value if the key is collected.\",\n            \"parameters\": [\n                {\n                    \"name\": \"ephemeron_pair\",\n                    \"type\": \"const EphemeronPair<K, V>&\",\n                    \"purpose\": \"The EphemeronPair to trace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TraceEphemeron\",\n                \"RegisterWeakCallbackMethod\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename K, typename V>\n            void Trace(const EphemeronPair<K, V>& ephemeron_pair) {\n                TraceEphemeron(ephemeron_pair.key, &ephemeron_pair.value);\n                RegisterWeakCallbackMethod<EphemeronPair<K, V>,\n                                    &EphemeronPair<K, V>::ClearValueIfKeyIsDead>(\n                    &ephemeron_pair);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TraceEphemeron\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a raw ephemeron, managing the weak key and strong value relationship when key and value are separate.\",\n            \"logic\": \"Traces the key weakly (via WeakMember) and visits the value as an ephemeron, registering the relationship with the garbage collector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"weak_member_key\",\n                    \"type\": \"const WeakMember<KeyType>&\",\n                    \"purpose\": \"The WeakMember holding the key of the ephemeron.\"\n                },\n                {\n                    \"name\": \"member_value\",\n                    \"type\": \"const Member<ValueType>*\",\n                    \"purpose\": \"The Member holding the value of the ephemeron.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitEphemeron\",\n                \"TraceTrait\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename KeyType, typename ValueType>\n            void TraceEphemeron(const WeakMember<KeyType>& weak_member_key,\n                                const Member<ValueType>* member_value) {\n                const KeyType* key = weak_member_key.GetRawAtomic();\n                if (!key) return;\n\n                // `value` must always be non-null.\n                CPPGC_DCHECK(member_value);\n                const ValueType* value = member_value->GetRawAtomic();\n                if (!value) return;\n\n                // KeyType and ValueType may refer to GarbageCollectedMixin.\n                TraceDescriptor value_desc =\n                    TraceTrait<ValueType>::GetTraceDescriptor(value);\n                CPPGC_DCHECK(value_desc.base_object_payload);\n                const void* key_base_object_payload =\n                    TraceTrait<KeyType>::GetTraceDescriptor(key).base_object_payload;\n                CPPGC_DCHECK(key_base_object_payload);\n\n                VisitEphemeron(key_base_object_payload, value, value_desc);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TraceEphemeron\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a raw ephemeron where the value is a non-garbage-collected type.\",\n            \"logic\": \"Traces the key weakly and visits the value as an ephemeron.  This overload is used for non-garbage-collected values that can still be traced (e.g., have a custom TraceDescriptor).\",\n            \"parameters\": [\n                {\n                    \"name\": \"weak_member_key\",\n                    \"type\": \"const WeakMember<KeyType>&\",\n                    \"purpose\": \"The WeakMember holding the key of the ephemeron.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"const ValueType*\",\n                    \"purpose\": \"The value of the ephemeron (non-garbage-collected).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitEphemeron\",\n                \"TraceTrait\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename KeyType, typename ValueType>\n            void TraceEphemeron(const WeakMember<KeyType>& weak_member_key,\n                                const ValueType* value) {\n                static_assert(!IsGarbageCollectedOrMixinTypeV<ValueType>,\n                            \"garbage-collected types must use WeakMember and Member\");\n                const KeyType* key = weak_member_key.GetRawAtomic();\n                if (!key) return;\n\n                // `value` must always be non-null.\n                CPPGC_DCHECK(value);\n                TraceDescriptor value_desc =\n                    TraceTrait<ValueType>::GetTraceDescriptor(value);\n                // `value_desc.base_object_payload` must be null as this override is only\n                // taken for non-garbage-collected values.\n                CPPGC_DCHECK(!value_desc.base_object_payload);\n\n                // KeyType might be a GarbageCollectedMixin.\n                const void* key_base_object_payload =\n                    TraceTrait<KeyType>::GetTraceDescriptor(key).base_object_payload;\n                CPPGC_DCHECK(key_base_object_payload);\n\n                VisitEphemeron(key_base_object_payload, value, value_desc);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TraceStrongly\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a WeakMember, promoting it to a strong reference during the trace.\",\n            \"logic\": \"Gets the raw atomic pointer from the WeakMember and calls TraceImpl to handle the tracing, effectively making the reference strong for the duration of the trace.\",\n            \"parameters\": [\n                {\n                    \"name\": \"weak_member\",\n                    \"type\": \"const WeakMember<T>&\",\n                    \"purpose\": \"The WeakMember to trace strongly.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TraceImpl\",\n                \"kSentinelPointer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void TraceStrongly(const WeakMember<T>& weak_member) {\n                const T* value = weak_member.GetRawAtomic();\n                CPPGC_DCHECK(value != kSentinelPointer);\n                TraceImpl(value);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TraceStrongContainer\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a container object, marking it as reachable.\",\n            \"logic\": \"Calls TraceImpl to handle tracing the container object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"const T*\",\n                    \"purpose\": \"The container object to trace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TraceImpl\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void TraceStrongContainer(const T* object) {\n                TraceImpl(object);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TraceWeakContainer\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Traces a container object weakly, registering a weak reference to it.\",\n            \"logic\": \"Visits the container weakly using VisitWeakContainer, registering a callback to be invoked when the container is collected.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"const T*\",\n                    \"purpose\": \"The container object to trace weakly.\"\n                },\n                {\n                    \"name\": \"callback\",\n                    \"type\": \"WeakCallback\",\n                    \"purpose\": \"The callback to invoke when the container is collected.\"\n                },\n                {\n                    \"name\": \"callback_data\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"Custom data to pass to the callback.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitWeakContainer\",\n                \"TraceTrait\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void TraceWeakContainer(const T* object, WeakCallback callback,\n                                    const void* callback_data) {\n                if (!object) return;\n                VisitWeakContainer(object, TraceTrait<T>::GetTraceDescriptor(object),\n                                TraceTrait<T>::GetWeakTraceDescriptor(object), callback,\n                                callback_data);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterMovableReference\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Registers a slot containing a reference to an object allocated on a compactable space, allowing the garbage collector to move the object and update the reference.\",\n            \"logic\": \"Registers the slot with the garbage collector using HandleMovableReference.\",\n            \"parameters\": [\n                {\n                    \"name\": \"slot\",\n                    \"type\": \"const T**\",\n                    \"purpose\": \"The location of the reference to the movable object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"HandleMovableReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void RegisterMovableReference(const T** slot) {\n                static_assert(internal::IsAllocatedOnCompactableSpace<T>::value,\n                            \"Only references to objects allocated on compactable spaces \"\n                            \"should be registered as movable slots.\");\n                static_assert(!IsGarbageCollectedMixinTypeV<T>,\n                            \"Mixin types do not support compaction.\");\n                HandleMovableReference(reinterpret_cast<const void**>(slot));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterWeakCallback\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Registers a weak callback to be invoked during garbage collection.\",\n            \"logic\": \"This is a virtual function, so the actual implementation will be in a derived class.  The default implementation does nothing.\",\n            \"parameters\": [\n                {\n                    \"name\": \"callback\",\n                    \"type\": \"WeakCallback\",\n                    \"purpose\": \"The callback to invoke.\"\n                },\n                {\n                    \"name\": \"data\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"Custom data to pass to the callback.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            virtual void RegisterWeakCallback(WeakCallback callback, const void* data) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeferTraceToMutatorThreadIfConcurrent\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Defers tracing an object to the mutator thread if the current thread is concurrent.\",\n            \"logic\": \"This is a virtual function, so the actual implementation will be in a derived class.  The default implementation returns false.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parameter\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"A parameter for the trace callback.\"\n                },\n                {\n                    \"name\": \"callback\",\n                    \"type\": \"TraceCallback\",\n                    \"purpose\": \"The callback to invoke on the mutator thread.\"\n                },\n                {\n                    \"name\": \"deferred_size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The size of the deferred object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns false if tracing is not deferred, true otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            virtual V8_WARN_UNUSED_RESULT bool DeferTraceToMutatorThreadIfConcurrent(\n                const void* parameter, TraceCallback callback, size_t deferred_size) {\n                // By default tracing is not deferred.\n                return false;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Visit\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Visits an object during tracing.\",\n            \"logic\": \"This is a virtual function, so the actual implementation will be in a derived class.  The default implementation does nothing.\",\n            \"parameters\": [\n                {\n                    \"name\": \"self\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The object being visited.\"\n                },\n                {\n                    \"name\": \"TraceDescriptor\",\n                    \"type\": \"TraceDescriptor\",\n                    \"purpose\": \"A descriptor containing information about how to trace the object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            virtual void Visit(const void* self, TraceDescriptor) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitWeak\",\n            \"parent\": \"Visitor\",\n            \"about\": \"Visits a weak reference during tracing.\",\n            \"logic\": \"This is a virtual function, so the actual implementation will be in a derived class.  The default implementation does nothing.\",\n            \"parameters\": [\n                {\n                    \"name\": \"self\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The object being visited weakly.\"\n                },\n                {\n                    \"name\": \"TraceDescriptor\",\n                    \"type\": \"TraceDescriptor\",\n                    \"purpose\": \"A descriptor containing information about how to trace the object.\"\n                },\n                {\n                    \"name\": \"WeakCallback\",\n                    \"type\": \"WeakCallback\",\n                    \"purpose"
}