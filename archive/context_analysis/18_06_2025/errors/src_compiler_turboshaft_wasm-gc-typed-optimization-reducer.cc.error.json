{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-gc-typed-optimization-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-gc-typed-optimization-reducer.cc\",\n        \"file_name\": \"wasm-gc-typed-optimization-reducer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements a Turboshaft reducer pass for optimizing WebAssembly Garbage Collection (GC) typed code by refining and propagating type information.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for the implementation, including logging, analyzer iterator, and loop finder.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/wasm-gc-typed-optimization-reducer.h\"\n\n#include \"src/base/logging.h\"\n#include \"src/compiler/turboshaft/analyzer-iterator.h\"\n#include \"src/compiler/turboshaft/loop-finder.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Analyzes the Turboshaft graph to refine type information for WebAssembly GC instructions.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"LoopFinder\",\n                \"AnalyzerIterator\",\n                \"Block\",\n                \"Graph\",\n                \"Zone\",\n                \"TypeSnapshotTable\",\n                \"Operation\",\n                \"OpIndex\",\n                \"WasmTypeCastOp\",\n                \"WasmTypeCheckOp\",\n                \"AssertNotNullOp\",\n                \"NullOp\",\n                \"IsNullOp\",\n                \"ParameterOp\",\n                \"StructGetOp\",\n                \"StructSetOp\",\n                \"ArrayGetOp\",\n                \"ArrayLengthOp\",\n                \"GlobalGetOp\",\n                \"WasmRefFuncOp\",\n                \"WasmAllocateArrayOp\",\n                \"WasmAllocateStructOp\",\n                \"PhiOp\",\n                \"WasmTypeAnnotationOp\",\n                \"BranchOp\",\n                \"RttCanonOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::compiler::turboshaft {\n\n#define TRACE(...)                                      \\\n  do {                                                  \\\n    if (v8_flags.trace_wasm_typer) PrintF(__VA_ARGS__); \\\n  } while (false)\n\nclass WasmGCTypeAnalyzer {\n public:\n  void Run();\n  void ProcessBlock(const Block& block);\n\n private:\n  void StartNewSnapshotFor(const Block& block);\n  void ProcessOperations(const Block& block);\n\n  void ProcessTypeCast(const WasmTypeCastOp& type_cast);\n  void ProcessTypeCheck(const WasmTypeCheckOp& type_check);\n  void ProcessAssertNotNull(const AssertNotNullOp& assert_not_null);\n  void ProcessIsNull(const IsNullOp& is_null);\n  void ProcessParameter(const ParameterOp& parameter);\n  void ProcessStructGet(const StructGetOp& struct_get);\n  void ProcessStructSet(const StructSetOp& struct_set);\n  void ProcessArrayGet(const ArrayGetOp& array_get);\n  void ProcessArrayLength(const ArrayLengthOp& array_length);\n  void ProcessGlobalGet(const GlobalGetOp& global_get);\n  void ProcessRefFunc(const WasmRefFuncOp& ref_func);\n  void ProcessAllocateArray(const WasmAllocateArrayOp& allocate_array);\n  void ProcessAllocateStruct(const WasmAllocateStructOp& allocate_struct);\n  void ProcessPhi(const PhiOp& phi);\n  void ProcessTypeAnnotation(const WasmTypeAnnotationOp& type_annotation);\n  void ProcessBranchOnTarget(const BranchOp& branch, const Block& target);\n  void ProcessNull(const NullOp& null);\n\n  void CreateMergeSnapshot(const Block& block);\n  bool CreateMergeSnapshot(\n      base::Vector<const Snapshot> predecessors,\n      base::Vector<const bool> reachable);\n\n  wasm::ValueType RefineTypeKnowledge(\n      OpIndex object, wasm::ValueType new_type, const Operation& op);\n  wasm::ValueType RefineTypeKnowledgeNotNull(\n      OpIndex object, const Operation& op);\n\n  OpIndex ResolveAliases(OpIndex object) const;\n  bool IsReachable(const Block& block) const;\n  wasm::ValueType GetResolvedType(OpIndex object) const;\n\n  Zone* phase_zone_;\n  Graph& graph_;\n  const wasm::Module* module_;\n  const wasm::FunctionSig* signature_;\n  TypeSnapshotTable types_table_{phase_zone_};\n  ZoneSet<size_t> block_is_unreachable_{phase_zone_};\n  const Block* current_block_ = nullptr;\n  bool is_first_loop_header_evaluation_ = false;\n  std::unordered_map<OpIndex, wasm::ValueType> input_type_map_;\n};\n\n#undef TRACE\n\n}  // namespace v8::internal::compiler::turboshaft\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Run\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"The main entry point for the WasmGCTypeAnalyzer. Iterates through the blocks of the graph and processes them.\",\n            \"logic\": \"Uses AnalyzerIterator to traverse the graph. For each block, it calls ProcessBlock to analyze the operations and then potentially re-processes loop headers based on backedge information.  Uses a fixed point analysis for loops.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"LoopFinder\",\n                \"AnalyzerIterator\",\n                \"Block\",\n                \"GotoOp\",\n                \"ProcessBlock\",\n                \"IsReachable\",\n                \"CreateMergeSnapshot\",\n                \"MaybeSnapshot\",\n                \"Snapshot\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::Run() {\n  LoopFinder loop_finder(phase_zone_, &graph_);\n  AnalyzerIterator iterator(phase_zone_, graph_, loop_finder);\n  while (iterator.HasNext()) {\n    const Block& block = *iterator.Next();\n    ProcessBlock(block);\n\n    // Finish snapshot.\n    block_to_snapshot_[block.index()] = MaybeSnapshot(types_table_.Seal());\n\n    // Consider re-processing for loops.\n    if (const GotoOp* last = block.LastOperation(graph_).TryCast<GotoOp>()) {\n      if (IsReachable(block) && last->destination->IsLoop() &&\n          last->destination->LastPredecessor() == &block) {\n        TRACE(\"[b%u] Reprocessing loop header b%u at backedge #%u\\n\",\n              block.index().id(), last->destination->index().id(),\n              graph_.Index(block.LastOperation(graph_)).id());\n        const Block& loop_header = *last->destination;\n        // Create a merged snapshot state for the forward- and backedge and\n        // process all operations inside the loop header.\n        ProcessBlock(loop_header);\n        Snapshot old_snapshot = block_to_snapshot_[loop_header.index()].value();\n        Snapshot snapshot = types_table_.Seal();\n        // TODO(14108): The snapshot isn't needed at all, we only care about the\n        // information if two snapshots are equivalent. Unfortunately, currently\n        // this can only be answered by creating a merge snapshot.\n        bool needs_revisit =\n            CreateMergeSnapshot(base::VectorOf({old_snapshot, snapshot}),\n                                base::VectorOf({true, true}));\n        types_table_.Seal();  // Discard the snapshot.\n\n        TRACE(\"[b%u] Loop header b%u reprocessed at backedge #%u: %s\\n\",\n              block.index().id(), last->destination->index().id(),\n              graph_.Index(block.LastOperation(graph_)).id(),\n              needs_revisit ? \"Scheduling loop body revisitation\"\n                            : \"No revisit of loop body needed\");\n\n        // TODO(14108): This currently encodes a fixed point analysis where the\n        // analysis is finished once the backedge doesn't provide updated type\n        // information any more compared to the previous iteration. This could\n        // be stopped in cases where the backedge only refines types (i.e. only\n        // defines more precise types than the previous iteration).\n        if (needs_revisit) {\n          block_to_snapshot_[loop_header.index()] = MaybeSnapshot(snapshot);\n          if (block.index() != loop_header.index()) {\n            // This will push the successors of the loop header to the iterator\n            // stack, so the loop body will be visited in the next iteration.\n            iterator.MarkLoopForRevisitSkipHeader();\n          } else {\n            // A single-block loop doesn't have any successors which would be\n            // re-evaluated and which might trigger another re-evaluation of the\n            // loop header.\n            // TODO(mliedtke): This is not a great design: We don't just\n            // schedule revisiting the loop header but afterwards we revisit it\n            // once again to evaluate whether we need to revisit it more times,\n            // so for single block loops the revisitation count will always be a\n            // multiple of 2. While this is inefficient, single-block loops are\n            // rare and are either endless loops or need to trigger an exception\n            // (e.g. a wasm trap) to terminate.\n            iterator.MarkLoopForRevisit();\n          }\n        }\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessBlock\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes a single block by starting a new snapshot and processing operations in that block.\",\n            \"logic\": \"Sets the current block, starts a new snapshot using StartNewSnapshotFor, and then processes the operations using ProcessOperations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const Block&\",\n                    \"purpose\": \"The block to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"StartNewSnapshotFor\",\n                \"ProcessOperations\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessBlock(const Block& block) {\n  DCHECK_NULL(current_block_);\n  current_block_ = &block;\n  StartNewSnapshotFor(block);\n  ProcessOperations(block);\n  current_block_ = nullptr;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"StartNewSnapshotFor\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Starts a new snapshot for the given block based on its predecessors.\",\n            \"logic\": \"Handles different block types (first block, loop, branch target, merge) and creates a new snapshot accordingly.  For loops, it merges the forward and back edges. For branch targets, it refines type information based on the branch condition.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const Block&\",\n                    \"purpose\": \"The block for which to start a new snapshot\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"IsReachable\",\n                \"CreateMergeSnapshot\",\n                \"ProcessBranchOnTarget\",\n                \"BranchOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::StartNewSnapshotFor(const Block& block) {\n  is_first_loop_header_evaluation_ = false;\n  // Reset reachability information. This can be outdated in case of loop\n  // revisits. Below the reachability is calculated again and potentially\n  // re-added.\n  bool block_was_previously_reachable = IsReachable(block);\n  if (!block_was_previously_reachable) {\n    TRACE(\"[b%u] Removing unreachable flag as block is re-evaluated\\n\",\n          block.index().id());\n  }\n  block_is_unreachable_.Remove(block.index().id());\n  // Start new snapshot based on predecessor information.\n  if (block.HasPredecessors() == 0) {\n    // The first block just starts with an empty snapshot.\n    DCHECK_EQ(block.index().id(), 0);\n    types_table_.StartNewSnapshot();\n  } else if (block.IsLoop()) {\n    const Block& forward_predecessor =\n        *block.LastPredecessor()->NeighboringPredecessor();\n    if (!IsReachable(forward_predecessor)) {\n      // If a loop isn't reachable through its forward edge, it can't possibly\n      // become reachable via the backedge.\n      TRACE(\n          \"[b%uu] Loop unreachable as forward predecessor b%u is unreachable\\n\",\n          block.index().id(), forward_predecessor.index().id());\n      block_is_unreachable_.Add(block.index().id());\n    }\n    MaybeSnapshot back_edge_snap =\n        block_to_snapshot_[block.LastPredecessor()->index()];\n    if (back_edge_snap.has_value() && block_was_previously_reachable) {\n      // The loop was already visited at least once. In this case use the\n      // available information from the backedge.\n      // Note that we only do this if the loop wasn't marked as unreachable\n      // before. This solves an issue where a single block loop would think the\n      // backedge is reachable as we just removed the unreachable information\n      // above. Once the analyzer hits the backedge, it will re-evaluate if the\n      // backedge changes any analysis results and then potentially revisit\n      // this loop with forward edge and backedge.\n      CreateMergeSnapshot(block);\n    } else {\n      // The loop wasn't visited yet. There isn't any type information available\n      // for the backedge.\n      TRACE(\n          \"[b%u%s] First loop header evaluation: Ignoring all backedges on \"\n          \"phis\\n\",\n          block.index().id(), !IsReachable(*current_block_) ? \"u\" : \"\");\n      is_first_loop_header_evaluation_ = true;\n      Snapshot forward_edge_snap =\n          block_to_snapshot_[forward_predecessor.index()].value();\n      types_table_.StartNewSnapshot(forward_edge_snap);\n    }\n  } else if (block.IsBranchTarget()) {\n    DCHECK_EQ(block.PredecessorCount(), 1);\n    const Block& predecessor = *block.LastPredecessor();\n    types_table_.StartNewSnapshot(\n        block_to_snapshot_[predecessor.index()].value());\n    if (IsReachable(predecessor)) {\n      const BranchOp* branch =\n          block.Predecessors()[0]->LastOperation(graph_).TryCast<BranchOp>();\n      if (branch != nullptr) {\n        ProcessBranchOnTarget(*branch, block);\n      }\n    } else {\n      TRACE(\"[b%uu] Block unreachable as sole predecessor b%u is unreachable\\n\",\n            block.index().id(), predecessor.index().id());\n      block_is_unreachable_.Add(block.index().id());\n    }\n  } else {\n    DCHECK_EQ(block.kind(), Block::Kind::kMerge);\n    CreateMergeSnapshot(block);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessOperations\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes the operations within a block to refine type information.\",\n            \"logic\": \"Iterates through each operation in the block and calls the appropriate Process... method based on the opcode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const Block&\",\n                    \"purpose\": \"The block whose operations will be processed\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ProcessTypeCast\",\n                \"ProcessTypeCheck\",\n                \"ProcessAssertNotNull\",\n                \"ProcessNull\",\n                \"ProcessIsNull\",\n                \"ProcessParameter\",\n                \"ProcessStructGet\",\n                \"ProcessStructSet\",\n                \"ProcessArrayGet\",\n                \"ProcessArrayLength\",\n                \"ProcessGlobalGet\",\n                \"ProcessRefFunc\",\n                \"ProcessAllocateArray\",\n                \"ProcessAllocateStruct\",\n                \"ProcessPhi\",\n                \"ProcessTypeAnnotation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessOperations(const Block& block) {\n  for (OpIndex op_idx : graph_.OperationIndices(block)) {\n    Operation& op = graph_.Get(op_idx);\n    switch (op.opcode) {\n      case Opcode::kWasmTypeCast:\n        ProcessTypeCast(op.Cast<WasmTypeCastOp>());\n        break;\n      case Opcode::kWasmTypeCheck:\n        ProcessTypeCheck(op.Cast<WasmTypeCheckOp>());\n        break;\n      case Opcode::kAssertNotNull:\n        ProcessAssertNotNull(op.Cast<AssertNotNullOp>());\n        break;\n      case Opcode::kNull:\n        ProcessNull(op.Cast<NullOp>());\n        break;\n      case Opcode::kIsNull:\n        ProcessIsNull(op.Cast<IsNullOp>());\n        break;\n      case Opcode::kParameter:\n        ProcessParameter(op.Cast<ParameterOp>());\n        break;\n      case Opcode::kStructGet:\n        ProcessStructGet(op.Cast<StructGetOp>());\n        break;\n      case Opcode::kStructSet:\n        ProcessStructSet(op.Cast<StructSetOp>());\n        break;\n      case Opcode::kArrayGet:\n        ProcessArrayGet(op.Cast<ArrayGetOp>());\n        break;\n      case Opcode::kArrayLength:\n        ProcessArrayLength(op.Cast<ArrayLengthOp>());\n        break;\n      case Opcode::kGlobalGet:\n        ProcessGlobalGet(op.Cast<GlobalGetOp>());\n        break;\n      case Opcode::kWasmRefFunc:\n        ProcessRefFunc(op.Cast<WasmRefFuncOp>());\n        break;\n      case Opcode::kWasmAllocateArray:\n        ProcessAllocateArray(op.Cast<WasmAllocateArrayOp>());\n        break;\n      case Opcode::kWasmAllocateStruct:\n        ProcessAllocateStruct(op.Cast<WasmAllocateStructOp>());\n        break;\n      case Opcode::kPhi:\n        ProcessPhi(op.Cast<PhiOp>());\n        break;\n      case Opcode::kWasmTypeAnnotation:\n        ProcessTypeAnnotation(op.Cast<WasmTypeAnnotationOp>());\n        break;\n      case Opcode::kBranch:\n        // Handling branch conditions implying special values is handled on the\n        // beginning of the successor block.\n      default:\n        break;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessTypeCast\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes a WasmTypeCast operation to refine the input type.\",\n            \"logic\": \"Refines the type knowledge of the object being cast based on the target type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type_cast\",\n                    \"type\": \"const WasmTypeCastOp&\",\n                    \"purpose\": \"The type cast operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessTypeCast(const WasmTypeCastOp& type_cast) {\n  V<Object> object = type_cast.object();\n  wasm::ValueType target_type = type_cast.config.to;\n  wasm::ValueType known_input_type =\n      RefineTypeKnowledge(object, target_type, type_cast);\n  input_type_map_[graph_.Index(type_cast)] = known_input_type;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessTypeCheck\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes a WasmTypeCheck operation.\",\n            \"logic\": \"Gets the resolved type of the object being checked and stores it in the input type map.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type_check\",\n                    \"type\": \"const WasmTypeCheckOp&\",\n                    \"purpose\": \"The type check operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"GetResolvedType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessTypeCheck(const WasmTypeCheckOp& type_check) {\n  wasm::ValueType type = GetResolvedType(type_check.object());\n  input_type_map_[graph_.Index(type_check)] = type;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessAssertNotNull\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes an AssertNotNull operation.\",\n            \"logic\": \"Refines the type knowledge of the object, asserting that it is not null.\",\n            \"parameters\": [\n                {\n                    \"name\": \"assert_not_null\",\n                    \"type\": \"const AssertNotNullOp&\",\n                    \"purpose\": \"The assert not null operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessAssertNotNull(\n    const AssertNotNullOp& assert_not_null) {\n  V<Object> object = assert_not_null.object();\n  wasm::ValueType new_type = assert_not_null.type.AsNonNull();\n  wasm::ValueType known_input_type =\n      RefineTypeKnowledge(object, new_type, assert_not_null);\n  input_type_map_[graph_.Index(assert_not_null)] = known_input_type;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessIsNull\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes an IsNull operation.\",\n            \"logic\": \"Gets the resolved type of the object being checked for null and stores it in the input type map.\",\n            \"parameters\": [\n                {\n                    \"name\": \"is_null\",\n                    \"type\": \"const IsNullOp&\",\n                    \"purpose\": \"The is null operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"GetResolvedType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessIsNull(const IsNullOp& is_null) {\n  input_type_map_[graph_.Index(is_null)] = GetResolvedType(is_null.object());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessParameter\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes a Parameter operation.\",\n            \"logic\": \"Refines the type knowledge of the parameter based on the signature.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parameter\",\n                    \"type\": \"const ParameterOp&\",\n                    \"purpose\": \"The parameter operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessParameter(const ParameterOp& parameter) {\n  if (parameter.parameter_index != wasm::kWasmInstanceDataParameterIndex) {\n    RefineTypeKnowledge(graph_.Index(parameter),\n                        signature_->GetParam(parameter.parameter_index - 1),\n                        parameter);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessStructGet\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes a StructGet operation.\",\n            \"logic\": \"Performs a null check on the struct object and refines type knowledge of both the struct and the field.\",\n            \"parameters\": [\n                {\n                    \"name\": \"struct_get\",\n                    \"type\": \"const StructGetOp&\",\n                    \"purpose\": \"The struct get operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledgeNotNull\",\n                \"RefineTypeKnowledge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessStructGet(const StructGetOp& struct_get) {\n  // struct.get performs a null check.\n  wasm::ValueType type =\n      RefineTypeKnowledgeNotNull(struct_get.object(), struct_get);\n  input_type_map_[graph_.Index(struct_get)] = type;\n  RefineTypeKnowledge(graph_.Index(struct_get),\n                      struct_get.type->field(struct_get.field_index).Unpacked(),\n                      struct_get);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessStructSet\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes a StructSet operation.\",\n            \"logic\": \"Performs a null check on the struct object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"struct_set\",\n                    \"type\": \"const StructSetOp&\",\n                    \"purpose\": \"The struct set operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledgeNotNull\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessStructSet(const StructSetOp& struct_set) {\n  // struct.set performs a null check.\n  wasm::ValueType type =\n      RefineTypeKnowledgeNotNull(struct_set.object(), struct_set);\n  input_type_map_[graph_.Index(struct_set)] = type;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessArrayGet\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes an ArrayGet operation.\",\n            \"logic\": \"Performs a null check on the array and refines type knowledge of both the array and its element type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"array_get\",\n                    \"type\": \"const ArrayGetOp&\",\n                    \"purpose\": \"The array get operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledgeNotNull\",\n                \"RefineTypeKnowledge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessArrayGet(const ArrayGetOp& array_get) {\n  // array.get traps on null. (Typically already on the array length access\n  // needed for the bounds check.)\n  RefineTypeKnowledgeNotNull(array_get.array(), array_get);\n  // The result type is at least the static array element type.\n  RefineTypeKnowledge(graph_.Index(array_get),\n                      array_get.array_type->element_type().Unpacked(),\n                      array_get);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessArrayLength\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes an ArrayLength operation.\",\n            \"logic\": \"Performs a null check on the array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"array_length\",\n                    \"type\": \"const ArrayLengthOp&\",\n                    \"purpose\": \"The array length operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledgeNotNull\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessArrayLength(const ArrayLengthOp& array_length) {\n  // array.len performs a null check.\n  wasm::ValueType type =\n      RefineTypeKnowledgeNotNull(array_length.array(), array_length);\n  input_type_map_[graph_.Index(array_length)] = type;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessGlobalGet\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes a GlobalGet operation.\",\n            \"logic\": \"Refines type knowledge based on the global's type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"global_get\",\n                    \"type\": \"const GlobalGetOp&\",\n                    \"purpose\": \"The global get operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessGlobalGet(const GlobalGetOp& global_get) {\n  RefineTypeKnowledge(graph_.Index(global_get), global_get.global->type,\n                      global_get);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessRefFunc\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes a WasmRefFunc operation.\",\n            \"logic\": \"Refines type knowledge based on the function's signature index.\",\n            \"parameters\": [\n                {\n                    \"name\": \"ref_func\",\n                    \"type\": \"const WasmRefFuncOp&\",\n                    \"purpose\": \"The ref func operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessRefFunc(const WasmRefFuncOp& ref_func) {\n  wasm::ModuleTypeIndex sig_index =\n      module_->functions[ref_func.function_index].sig_index;\n  RefineTypeKnowledge(graph_.Index(ref_func),\n                      wasm::ValueType::Ref(module_->heap_type(sig_index)),\n                      ref_func);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessAllocateArray\",\n            \"parent\": \"WasmGCTypeAnalyzer\",\n            \"about\": \"Processes a WasmAllocateArray operation.\",\n            \"logic\": \"Refines type knowledge based on the type index of the array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"allocate_array\",\n                    \"type\": \"const WasmAllocateArrayOp&\",\n                    \"purpose\": \"The allocate array operation to process\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"RefineTypeKnowledge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid WasmGCTypeAnalyzer::ProcessAllocateArray(\n    const WasmAllocateArrayOp& allocate_array) {\n  wasm::ModuleTypeIndex type_index =\n      graph_.Get(allocate_array.rtt()).Cast<"
}