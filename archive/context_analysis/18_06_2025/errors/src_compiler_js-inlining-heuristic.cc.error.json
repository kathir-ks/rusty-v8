{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-inlining-heuristic.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-inlining-heuristic.cc\",\n        \"file_name\": \"js-inlining-heuristic.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements a heuristic for inlining JavaScript functions in the TurboFan compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for compiler components, data structures, and utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/js-inlining-heuristic.h\"\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/numbers/conversions.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsSmall\",\n            \"about\": \"Checks if a given size is considered small based on a flag.\",\n            \"logic\": \"Compares the input size against the `max_inlined_bytecode_size_small` flag.\",\n            \"parameters\": [\n                {\n                    \"name\": \"size\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The size to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the size is small, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsSmall(int const size) {\n  return size <= v8_flags.max_inlined_bytecode_size_small;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CanConsiderForInlining\",\n            \"about\": \"Determines if a function, represented by a FeedbackCellRef, is suitable for inlining based on various criteria.\",\n            \"logic\": \"Checks for the presence of a feedback vector, bytecode array, inlineability status, and verifies that the feedback vector hasn't changed. It also obtains and persists a handle to the bytecode to prevent garbage collection during compilation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"broker\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"purpose\": \"The JSHeapBroker for accessing heap objects.\"\n                },\n                {\n                    \"name\": \"feedback_cell\",\n                    \"type\": \"FeedbackCellRef\",\n                    \"purpose\": \"The FeedbackCellRef representing the function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the function can be considered for inlining, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"SharedFunctionInfoRef\",\n                \"OptionalFeedbackVectorRef\",\n                \"SharedFunctionInfo::Inlineability\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool CanConsiderForInlining(JSHeapBroker* broker,\n                            FeedbackCellRef feedback_cell) {\n  OptionalFeedbackVectorRef feedback_vector =\n      feedback_cell.feedback_vector(broker);\n  if (!feedback_vector.has_value()) {\n    TRACE(\"Cannot consider \" << feedback_cell\n                             << \" for inlining (no feedback vector)\");\n    return false;\n  }\n  SharedFunctionInfoRef shared = feedback_vector->shared_function_info(broker);\n\n  if (!shared.HasBytecodeArray()) {\n    TRACE(\"Cannot consider \" << shared << \" for inlining (no bytecode)\");\n    return false;\n  }\n  // Ensure we have a persistent handle to the bytecode in order to avoid\n  // flushing it during the remaining compilation.\n  shared.GetBytecodeArray(broker);\n\n  // Read feedback vector again in case it got flushed before we were able to\n  // prevent flushing above.\n  OptionalFeedbackVectorRef feedback_vector_again =\n      feedback_cell.feedback_vector(broker);\n  if (!feedback_vector_again.has_value()) {\n    TRACE(\"Cannot consider \" << shared << \" for inlining (no feedback vector)\");\n    return false;\n  }\n  if (!feedback_vector_again->equals(*feedback_vector)) {\n    // The new feedback vector likely contains lots of uninitialized slots, so\n    // it doesn't make much sense to inline this function now.\n    TRACE(\"Not considering \" << shared\n                             << \" for inlining (feedback vector changed)\");\n    return false;\n  }\n\n  SharedFunctionInfo::Inlineability inlineability =\n      shared.GetInlineability(broker);\n  if (inlineability != SharedFunctionInfo::kIsInlineable) {\n    TRACE(\"Cannot consider \"\n          << shared << \" for inlining (reason: \" << inlineability << \")\");\n    return false;\n  }\n\n  TRACE(\"Considering \" << shared << \" for inlining with \" << *feedback_vector);\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CanConsiderForInlining\",\n            \"about\": \"Overload of CanConsiderForInlining that takes a JSFunctionRef directly.\",\n            \"logic\": \"Retrieves the FeedbackCellRef from the JSFunctionRef and calls the other CanConsiderForInlining overload.\",\n            \"parameters\": [\n                {\n                    \"name\": \"broker\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"purpose\": \"The JSHeapBroker for accessing heap objects.\"\n                },\n                {\n                    \"name\": \"function\",\n                    \"type\": \"JSFunctionRef\",\n                    \"purpose\": \"The JSFunctionRef representing the function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the function can be considered for inlining, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"FeedbackCellRef\",\n                \"CanConsiderForInlining(JSHeapBroker*, FeedbackCellRef)\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool CanConsiderForInlining(JSHeapBroker* broker, JSFunctionRef function) {\n  FeedbackCellRef feedback_cell = function.raw_feedback_cell(broker);\n  bool const result = CanConsiderForInlining(broker, feedback_cell);\n  if (result) {\n    CHECK(function.shared(broker).equals(\n        feedback_cell.shared_function_info(broker).value()));\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JSInliningHeuristic\",\n            \"about\": \"Class that encapsulates the logic for inlining JavaScript functions based on heuristics.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"JSHeapBroker\",\n                \"BytecodeArrayRef\",\n                \"FeedbackCellRef\",\n                \"SharedFunctionInfoRef\",\n                \"Reduction\",\n                \"Candidate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass JSInliningHeuristic {\n public:\n  enum Mode { kJSOnly, kWasmWrappersOnly, kWasmFullInlining };\n\n  struct Candidate {\n    Node* node = nullptr;\n    Frequency frequency;\n    JSFunctionRef functions[kMaxCallPolymorphism];\n    OptionalSharedFunctionInfoRef shared_info;\n    OptionalBytecodeArrayRef bytecode[kMaxCallPolymorphism];\n    bool can_inline_function[kMaxCallPolymorphism] = {false};\n    int num_functions = 0;\n    int total_size = 0;\n  };\n\n  explicit JSInliningHeuristic(JSGraph* jsgraph, JSHeapBroker* broker,\n                               CompilerSourcePositionTable* source_positions,\n                               JSInliner* inliner, int max_inlined_bytecode_size,\n                               int max_inlined_bytecode_size_absolute,\n                               Mode mode)\n      : jsgraph_(jsgraph),\n        broker_(broker),\n        source_positions_(source_positions),\n        inliner_(inliner),\n        max_inlined_bytecode_size_cumulative_(max_inlined_bytecode_size),\n        max_inlined_bytecode_size_absolute_(max_inlined_bytecode_size_absolute),\n        mode_(mode) {}\n\n  Candidate CollectFunctions(Node* node, int functions_size);\n  Reduction Reduce(Node* node);\n  void Finalize();\n\n  Node* DuplicateStateValuesAndRename(Node* state_values, Node* from, Node* to,\n                                     StateCloneMode mode);\n  FrameState DuplicateFrameStateAndRename(FrameState frame_state, Node* from,\n                                          Node* to, StateCloneMode mode);\n  // Try to reuse existing control flow for the callee computation.\n  bool TryReuseDispatch(Node* node, Node* callee, Node** if_successes,\n                        Node** calls, Node** inputs, int input_count,\n                        int* num_calls);\n  void CreateOrReuseDispatch(Node* node, Node* callee,\n                              Candidate const& candidate, Node** if_successes,\n                              Node** calls, Node** inputs, int input_count,\n                              int* num_calls);\n  Reduction InlineCandidate(Candidate const& candidate, bool small_function);\n\n  TFGraph* graph() const;\n  CompilationDependencies* dependencies() const;\n  CommonOperatorBuilder* common() const;\n  SimplifiedOperatorBuilder* simplified() const;\n  JSGraph* jsgraph() const { return jsgraph_; }\n  JSHeapBroker* broker() const { return broker_; }\n  Mode mode() const { return mode_; }\n\n  bool CanInline(Node* call, BytecodeArrayRef bytecode) {\n    return total_inlined_bytecode_size_ + bytecode->length() <=\n           max_inlined_bytecode_size_cumulative_;\n  }\n\n  void IncreaseInlinedBytecodeSize(int size) {\n    total_inlined_bytecode_size_ += size;\n  }\n\n private:\n  enum StateCloneMode { kCloneState, kChangeInPlace };\n\n  class CandidateCompare {\n   public:\n    bool operator()(const Candidate& left, const Candidate& right) const;\n  };\n\n  JSGraph* const jsgraph_;\n  JSHeapBroker* const broker_;\n  CompilerSourcePositionTable* const source_positions_;\n  JSInliner* const inliner_;\n  const int max_inlined_bytecode_size_cumulative_;\n  const int max_inlined_bytecode_size_absolute_;\n  const Mode mode_;\n  std::set<Candidate, CandidateCompare> candidates_;\n  std::set<NodeId> seen_;\n  int total_inlined_bytecode_size_ = 0;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CollectFunctions\",\n            \"parent\": \"JSInliningHeuristic\",\n            \"about\": \"Collects the target functions for a given call node and determines if they can be inlined.\",\n            \"logic\": \"Identifies the callee node. If it's a JSFunction, it checks if it's inlineable. If it's a Phi node, it iterates through its inputs, checking each one for inlineable JSFunctions. Handles JSCreateClosure and JSCheckClosure.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The call node to analyze.\"\n                },\n                {\n                    \"name\": \"functions_size\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The maximum number of functions to collect (used for polymorphic calls).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"JSInliningHeuristic::Candidate\",\n                \"description\": \"A Candidate struct containing the collected functions and related information.\"\n            },\n            \"dependencies\": [\n                \"HeapObjectMatcher\",\n                \"JSFunctionRef\",\n                \"CanConsiderForInlining(JSHeapBroker*, JSFunctionRef)\",\n                \"BytecodeArrayRef\",\n                \"FeedbackCellRef\",\n                \"MakeRef\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nJSInliningHeuristic::Candidate JSInliningHeuristic::CollectFunctions(\n    Node* node, int functions_size) {\n  DCHECK_NE(0, functions_size);\n  Node* callee = node->InputAt(0);\n  Candidate out;\n  out.node = node;\n\n  HeapObjectMatcher m(callee);\n  if (m.HasResolvedValue() && m.Ref(broker()).IsJSFunction()) {\n    JSFunctionRef function = m.Ref(broker()).AsJSFunction();\n    out.functions[0] = function;\n    if (CanConsiderForInlining(broker(), function)) {\n      out.bytecode[0] = function.shared(broker()).GetBytecodeArray(broker());\n      out.num_functions = 1;\n      return out;\n    }\n  }\n  if (m.IsPhi()) {\n    int const value_input_count = m.node()->op()->ValueInputCount();\n    if (value_input_count > functions_size) {\n      out.num_functions = 0;\n      return out;\n    }\n    for (int n = 0; n < value_input_count; ++n) {\n      HeapObjectMatcher m2(callee->InputAt(n));\n      if (!m2.HasResolvedValue() || !m2.Ref(broker()).IsJSFunction()) {\n        out.num_functions = 0;\n        return out;\n      }\n\n      out.functions[n] = m2.Ref(broker()).AsJSFunction();\n      JSFunctionRef function = out.functions[n].value();\n      if (CanConsiderForInlining(broker(), function)) {\n        out.bytecode[n] = function.shared(broker()).GetBytecodeArray(broker());\n      }\n    }\n    out.num_functions = value_input_count;\n    return out;\n  }\n  if (m.IsCheckClosure()) {\n    DCHECK(!out.functions[0].has_value());\n    FeedbackCellRef feedback_cell = MakeRef(broker(), FeedbackCellOf(m.op()));\n    if (CanConsiderForInlining(broker(), feedback_cell)) {\n      out.shared_info = feedback_cell.shared_function_info(broker()).value();\n      out.bytecode[0] = out.shared_info->GetBytecodeArray(broker());\n    }\n    out.num_functions = 1;\n    return out;\n  }\n  if (m.IsJSCreateClosure()) {\n    DCHECK(!out.functions[0].has_value());\n    JSCreateClosureNode n(callee);\n    FeedbackCellRef feedback_cell = n.GetFeedbackCellRefChecked(broker());\n    if (CanConsiderForInlining(broker(), feedback_cell)) {\n      out.shared_info = feedback_cell.shared_function_info(broker()).value();\n      out.bytecode[0] = out.shared_info->GetBytecodeArray(broker());\n      CHECK(out.shared_info->equals(n.Parameters().shared_info()));\n    }\n    out.num_functions = 1;\n    return out;\n  }\n  out.num_functions = 0;\n  return out;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"JSInliningHeuristic\",\n            \"about\": \"Determines whether to inline a function call and either performs the inlining directly or adds the call to a list of candidates for later inlining.\",\n            \"logic\": \"Checks various conditions, including whether the maximum inlining budget has been exceeded, whether the node has already been seen, and whether the target function(s) can be inlined.  It also handles polymorphic inlining.  It prioritizes inlining small functions. Gathers feedback on call site frequency.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The call node to potentially inline.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made to the graph.\"\n            },\n            \"dependencies\": [\n                \"IrOpcode::IsInlineeOpcode\",\n                \"CollectFunctions\",\n                \"v8_flags.polymorphic_inlining\",\n                \"FrameState\",\n                \"NodeProperties::GetFrameStateInput\",\n                \"IsSmall\",\n                \"CallParametersOf\",\n                \"ConstructParametersOf\",\n                \"v8_flags.min_inlining_frequency\",\n                \"InlineCandidate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction JSInliningHeuristic::Reduce(Node* node) {\n#if V8_ENABLE_WEBASSEMBLY\n  if (mode() == kWasmWrappersOnly || mode() == kWasmFullInlining) {\n    if (node->opcode() == IrOpcode::kJSWasmCall) {\n      return inliner_.ReduceJSWasmCall(node);\n    }\n    return NoChange();\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n  DCHECK_EQ(mode(), kJSOnly);\n  if (!IrOpcode::IsInlineeOpcode(node->opcode())) return NoChange();\n\n  if (total_inlined_bytecode_size_ >= max_inlined_bytecode_size_absolute_) {\n    return NoChange();\n  }\n\n  // Check if we already saw that {node} before, and if so, just skip it.\n  if (seen_.find(node->id()) != seen_.end()) return NoChange();\n\n  // Check if the {node} is an appropriate candidate for inlining.\n  Candidate candidate = CollectFunctions(node, kMaxCallPolymorphism);\n  if (candidate.num_functions == 0) {\n    return NoChange();\n  } else if (candidate.num_functions > 1 && !v8_flags.polymorphic_inlining) {\n    TRACE(\"Not considering call site #\"\n          << node->id() << \":\" << node->op()->mnemonic()\n          << \", because polymorphic inlining is disabled\");\n    return NoChange();\n  }\n\n  bool can_inline_candidate = false, candidate_is_small = true;\n  candidate.total_size = 0;\n  FrameState frame_state{NodeProperties::GetFrameStateInput(node)};\n  FrameStateInfo const& frame_info = frame_state.frame_state_info();\n  Handle<SharedFunctionInfo> frame_shared_info;\n  for (int i = 0; i < candidate.num_functions; ++i) {\n    if (!candidate.bytecode[i].has_value()) {\n      candidate.can_inline_function[i] = false;\n      continue;\n    }\n\n    SharedFunctionInfoRef shared =\n        candidate.functions[i].has_value()\n            ? candidate.functions[i].value().shared(broker())\n            : candidate.shared_info.value();\n    candidate.can_inline_function[i] = candidate.bytecode[i].has_value();\n    // Because of concurrent optimization, optimization of the inlining\n    // candidate could have been disabled meanwhile.\n    // JSInliner will check this again and not actually inline the function in\n    // this case.\n    CHECK_IMPLIES(candidate.can_inline_function[i],\n                  shared.IsInlineable(broker()) ||\n                      shared.GetInlineability(broker()) ==\n                          SharedFunctionInfo::kHasOptimizationDisabled);\n    // Do not allow direct recursion i.e. f() -> f(). We still allow indirect\n    // recursion like f() -> g() -> f(). The indirect recursion is helpful in\n    // cases where f() is a small dispatch function that calls the appropriate\n    // function. In the case of direct recursion, we only have some static\n    // information for the first level of inlining and it may not be that useful\n    // to just inline one level in recursive calls. In some cases like tail\n    // recursion we may benefit from recursive inlining, if we have additional\n    // analysis that converts them to iterative implementations. Though it is\n    // not obvious if such an analysis is needed.\n    if (frame_info.shared_info().ToHandle(&frame_shared_info) &&\n        frame_shared_info.equals(shared.object())) {\n      TRACE(\"Not considering call site #\" << node->id() << \":\"\n                                          << node->op()->mnemonic()\n                                          << \", because of recursive inlining\");\n      candidate.can_inline_function[i] = false;\n    }\n    if (candidate.can_inline_function[i]) {\n      can_inline_candidate = true;\n      BytecodeArrayRef bytecode = candidate.bytecode[i].value();\n      candidate.total_size += bytecode.length();\n      unsigned inlined_bytecode_size = 0;\n      if (OptionalJSFunctionRef function = candidate.functions[i]) {\n        if (OptionalCodeRef code = function->code(broker())) {\n          inlined_bytecode_size = code->GetInlinedBytecodeSize();\n          candidate.total_size += inlined_bytecode_size;\n        }\n      }\n      candidate_is_small = candidate_is_small &&\n                           IsSmall(bytecode.length() + inlined_bytecode_size);\n    }\n  }\n  if (!can_inline_candidate) return NoChange();\n\n  // Gather feedback on how often this call site has been hit before.\n  if (node->opcode() == IrOpcode::kJSCall) {\n    CallParameters const p = CallParametersOf(node->op());\n    candidate.frequency = p.frequency();\n  } else {\n    ConstructParameters const p = ConstructParametersOf(node->op());\n    candidate.frequency = p.frequency();\n  }\n\n  // Don't consider a {candidate} whose frequency is below the\n  // threshold, i.e. a call site that is only hit once every N\n  // invocations of the caller.\n  if (candidate.frequency.IsKnown() &&\n      candidate.frequency.value() < v8_flags.min_inlining_frequency) {\n    return NoChange();\n  }\n\n  // Found a candidate. Insert it into the set of seen nodes s.t. we don't\n  // revisit in the future. Note this insertion happens here and not earlier in\n  // order to make inlining decisions order-independent. A node may not be a\n  // candidate when first seen, but later reductions may turn it into a valid\n  // candidate. In that case, the node should be revisited by\n  // JSInliningHeuristic.\n  seen_.insert(node->id());\n\n  // Forcibly inline small functions here. In the case of polymorphic inlining\n  // candidate_is_small is set only when all functions are small.\n  if (candidate_is_small) {\n    TRACE(\"Inlining small function(s) at call site #\"\n          << node->id() << \":\" << node->op()->mnemonic());\n    return InlineCandidate(candidate, true);\n  }\n\n  // In the general case we remember the candidate for later.\n  candidates_.insert(candidate);\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Finalize\",\n            \"parent\": \"JSInliningHeuristic\",\n            \"about\": \"Performs the actual inlining of the selected candidates after the main reduction phase.\",\n            \"logic\": \"Iterates through the collected inlining candidates and attempts to inline them, respecting the maximum inlining budget.  It prioritizes candidates based on their potential benefit.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InlineCandidate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid JSInliningHeuristic::Finalize() {\n  if (candidates_.empty()) return;  // Nothing to do without candidates.\n  if (v8_flags.trace_turbo_inlining) PrintCandidates();\n\n  // We inline at most one candidate in every iteration of the fixpoint.\n  // This is to ensure that we don't consume the full inlining budget\n  // on things that aren't called very often.\n  // TODO(bmeurer): Use std::priority_queue instead of std::set here.\n  while (!candidates_.empty()) {\n    auto i = candidates_.begin();\n    Candidate candidate = *i;\n    candidates_.erase(i);\n\n    // Ignore this candidate if it's no longer valid.\n    if (!IrOpcode::IsInlineeOpcode(candidate.node->opcode())) continue;\n    if (candidate.node->IsDead()) continue;\n\n    // Make sure we have some extra budget left, so that any small functions\n    // exposed by this function would be given a chance to inline.\n    double size_of_candidate =\n        candidate.total_size * v8_flags.reserve_inline_budget_scale_factor;\n    int total_size =\n        total_inlined_bytecode_size_ + static_cast<int>(size_of_candidate);\n    if (total_size > max_inlined_bytecode_size_cumulative_) {\n      info_->set_could_not_inline_all_candidates();\n      // Try if any smaller functions are available to inline.\n      continue;\n    }\n\n    Reduction const reduction = InlineCandidate(candidate, false);\n    if (reduction.Changed()) return;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CollectStateValuesOwnedUses\",\n            \"about\": \"Recursively collects uses of a node within a StateValues node, ensuring the StateValues node is not shared.\",\n            \"logic\": \"Traverses the inputs of a StateValues node. If an input is another StateValues node, it recursively calls itself. If an input is the target node, it records the use. Returns false if the number of uses exceeds max_uses or if a shared StateValues node is encountered.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to find uses of.\"\n                },\n                {\n                    \"name\": \"state_values\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The StateValues node to search within.\"\n                },\n                {\n                    \"name\": \"uses_buffer\",\n                    \"type\": \"NodeAndIndex*\",\n                    \"purpose\": \"Buffer to store the found uses.\"\n                },\n                {\n                    \"name\": \"use_count\",\n                    \"type\": \"size_t*\",\n                    \"purpose\": \"Pointer to the current number of uses found.\"\n                },\n                {\n                    \"name\": \"max_uses\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"Maximum number of uses to collect.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all uses were collected successfully, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool CollectStateValuesOwnedUses(Node* node, Node* state_values,\n                                 NodeAndIndex* uses_buffer, size_t* use_count,\n                                 size_t max_uses) {\n  // Only accumulate states that are not shared with other users.\n  if (state_values->UseCount() > 1) return true;\n  for (int i = 0; i < state_values->InputCount(); i++) {\n    Node* input = state_values->InputAt(i);\n    if (input->opcode() == IrOpcode::kStateValues) {\n      if (!CollectStateValuesOwnedUses(node, input, uses_buffer, use_count,\n                                       max_uses)) {\n        return false;\n      }\n    } else if (input == node) {\n      if (*use_count >= max_uses) return false;\n      uses_buffer[*use_count] = {state_values, i};\n      (*use_count)++;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DuplicateStateValuesAndRename\",\n            \"parent\": \"JSInliningHeuristic\",\n            \"about\": \"Duplicates a StateValues node and renames a specific input node within it, if the StateValues node is not shared.\",\n            \"logic\": \"If the StateValues node is shared, it returns the original node. Otherwise, it clones the node (if necessary) and recursively calls itself on any nested StateValues nodes, replacing the 'from' node with the 'to' node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"state_values\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The StateValues node to duplicate and rename within.\"\n                },\n                {\n                    \"name\": \"from\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace 'from' with.\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"StateCloneMode\",\n                    \"purpose\": \"Indicates whether to clone the node or modify it in place if possible.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The duplicated and renamed StateValues node, or the original node if it was shared.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nNode* JSInliningHeuristic::DuplicateStateValuesAndRename(Node* state_values,\n                                                         Node* from, Node* to,\n                                                         StateCloneMode mode) {\n  // Only rename in states that are not shared with other users. This needs to\n  // be in sync with the condition in {CollectStateValuesOwnedUses}.\n  if (state_values->UseCount() > 1) return state_values;\n  Node* copy = mode == kChangeInPlace ? state_values : nullptr;\n  for (int i = 0; i < state_values->InputCount(); i++) {\n    Node* input = state_values->InputAt(i);\n    Node* processed;\n    if (input->opcode() == IrOpcode::kStateValues) {\n      processed = DuplicateStateValuesAndRename(input, from, to, mode);\n    } else if (input == from) {\n      processed = to;\n    } else {\n      processed = input;\n    }\n    if (processed != input) {\n      if (!copy) {\n        copy = graph()->CloneNode(state_values);\n      }\n      copy->ReplaceInput(i, processed);\n    }\n  }\n  return copy ? copy : state_values;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CollectFrameStateUniqueUses\",\n            \"about\": \"Collects unique uses of a node within a FrameState, including uses within nested StateValues nodes.\",\n            \"logic\": \"Checks if the FrameState itself is uniquely used. Then checks if the stack and locals are uniquely used by calling CollectStateValuesOwnedUses on the locals.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to find unique uses of.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"FrameState\",\n                    \"purpose\": \"The FrameState to search within.\"\n                },\n                {\n                    \"name\": \"uses_buffer\",\n                    \"type\": \"NodeAndIndex*\",\n                    \"purpose\": \"Buffer to store the found uses.\"\n                },\n                {\n                    \"name\": \"use_count\",\n                    \"type\": \"size_t*\",\n                    \"purpose\": \"Pointer to the current number of uses found.\"\n                },\n                {\n                    \"name\": \"max_uses\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"Maximum number of uses to collect.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all uses were collected successfully, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"CollectStateValuesOwnedUses\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool CollectFrameStateUniqueUses(Node* node, FrameState frame_state,\n                                 NodeAndIndex* uses_buffer, size_t* use_count,\n                                 size_t max_uses) {\n  // Only accumulate states that are not shared with other users.\n  if (frame_state->UseCount() > 1) return true;\n  if (frame_state.stack() == node) {\n    if (*use_count >= max_uses) return false;\n    uses_buffer[*use_count] = {frame_state, FrameState::kFrameStateStackInput};\n    (*use_count)++;\n  }\n  if (!CollectStateValuesOwnedUses(node, frame_state.locals(), uses_buffer,\n                                   use_count, max_uses)) {\n    return false;\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DuplicateFrameStateAndRename\",\n            \"parent\": \"JSInliningHeuristic\",\n            \"about\": \"Duplicates a FrameState and renames a specific input node within it, including within nested StateValues nodes, if the FrameState is not shared.\",\n            \"logic\": \"If the FrameState is shared, it returns the original FrameState. Otherwise, it clones the FrameState (if necessary) and calls DuplicateStateValuesAndRename on the locals, replacing the 'from' node with the 'to' node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"FrameState\",\n                    \"purpose\": \"The FrameState to duplicate and rename within.\"\n                },\n"
}