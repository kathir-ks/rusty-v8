{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/deoptimizer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/deoptimizer.cc\",\n        \"file_name\": \"deoptimizer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the deoptimization process in V8, handling the transition from optimized code back to unoptimized code.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard library headers and V8-specific headers used for deoptimization.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/deoptimizer/deoptimizer.h\"\n\n#include <optional>\n\n#include \"src/base/memory.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/codegen/register-configuration.h\"\n#include \"src/codegen/reloc-info.h\"\n#include \"src/debug/debug.h\"\n#include \"src/deoptimizer/deoptimized-frame-info.h\"\n#include \"src/deoptimizer/materialized-object-store.h\"\n#include \"src/deoptimizer/translated-state.h\"\n#include \"src/execution/frames-inl.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/execution/pointer-authentication.h\"\n#include \"src/execution/v8threads.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/heap/heap-inl.h\"\n#include \"src/logging/counters.h\"\n#include \"src/logging/log.h\"\n#include \"src/logging/runtime-call-stats-scope.h\"\n#include \"src/objects/deoptimization-data.h\"\n#include \"src/objects/js-function-inl.h\"\n#include \"src/objects/oddball.h\"\n#include \"src/snapshot/embedded/embedded-data.h\"\n#include \"src/utils/utils.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/baseline/liftoff-compiler.h\"\n#include \"src/wasm/baseline/liftoff-varstate.h\"\n#include \"src/wasm/compilation-environment-inl.h\"\n#include \"src/wasm/function-compiler.h\"\n#include \"src/wasm/signature-hashing.h\"\n#include \"src/wasm/wasm-deopt-data.h\"\n#include \"src/wasm/wasm-engine.h\"\n#include \"src/wasm/wasm-linkage.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DeoptimizableCodeIterator\",\n            \"about\": \"Iterates through all Code objects that can be deoptimized in the heap.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The isolate for which to iterate.\"\n                },\n                {\n                    \"name\": \"safepoint_scope_\",\n                    \"type\": \"std::unique_ptr<SafepointScope>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Ensures GC safety during iteration.\"\n                },\n                {\n                    \"name\": \"object_iterator_\",\n                    \"type\": \"std::unique_ptr<ObjectIterator>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Iterates through objects in code spaces.\"\n                },\n                {\n                    \"name\": \"state_\",\n                    \"type\": \"enum\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks the current iteration state (code space, code LO space, done).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"SafepointScope\",\n                \"ObjectIterator\",\n                \"HeapObject\",\n                \"InstructionStream\",\n                \"Code\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass DeoptimizableCodeIterator {\n public:\n  explicit DeoptimizableCodeIterator(Isolate* isolate);\n  DeoptimizableCodeIterator(const DeoptimizableCodeIterator&) = delete;\n  DeoptimizableCodeIterator& operator=(const DeoptimizableCodeIterator&) =\n      delete;\n  Tagged<Code> Next();\n\n private:\n  Isolate* const isolate_;\n  std::unique_ptr<SafepointScope> safepoint_scope_;\n  std::unique_ptr<ObjectIterator> object_iterator_;\n  enum { kIteratingCodeSpace, kIteratingCodeLOSpace, kDone } state_;\n\n  DISALLOW_GARBAGE_COLLECTION(no_gc)\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeoptimizableCodeIterator::DeoptimizableCodeIterator\",\n            \"parent\": \"DeoptimizableCodeIterator\",\n            \"about\": \"Constructor for the DeoptimizableCodeIterator.\",\n            \"logic\": \"Initializes the iterator to start in the code space. Sets up a safepoint scope to prevent GC during iteration.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate for which to iterate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"SafepointScope\",\n                \"ObjectIterator\",\n                \"Heap\",\n                \"CodeSpace\",\n                \"CodeLOSpace\",\n                \"isolate->is_shared_space_isolate\",\n                \"SafepointKind::kGlobal\",\n                \"SafepointKind::kIsolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDeoptimizableCodeIterator::DeoptimizableCodeIterator(Isolate* isolate)\n    : isolate_(isolate),\n      safepoint_scope_(std::make_unique<SafepointScope>(\n          isolate, isolate->is_shared_space_isolate()\n                       ? SafepointKind::kGlobal\n                       : SafepointKind::kIsolate)),\n      object_iterator_(\n          isolate->heap()->code_space()->GetObjectIterator(isolate->heap())),\n      state_(kIteratingCodeSpace) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeoptimizableCodeIterator::Next\",\n            \"parent\": \"DeoptimizableCodeIterator\",\n            \"about\": \"Returns the next deoptimizable Code object in the heap.\",\n            \"logic\": \"Iterates through code spaces and code large object spaces, skipping non-Code objects and Code objects that cannot be deoptimized.  Uses a safepoint to prevent GC movement of objects during iteration.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Tagged<Code>\",\n                \"description\": \"The next deoptimizable Code object, or a null Tagged<Code> if no more deoptimizable code objects exist.\"\n            },\n            \"dependencies\": [\n                \"HeapObject\",\n                \"InstructionStream\",\n                \"Code\",\n                \"CodeKindCanDeoptimize\",\n                \"kAcquireLoad\",\n                \"ObjectIterator\",\n                \"Heap\",\n                \"CodeSpace\",\n                \"CodeLOSpace\",\n                \"SafepointScope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTagged<Code> DeoptimizableCodeIterator::Next() {\n  while (true) {\n    Tagged<HeapObject> object = object_iterator_->Next();\n    if (object.is_null()) {\n      // No objects left in the current iterator, try to move to the next space\n      // based on the state.\n      switch (state_) {\n        case kIteratingCodeSpace: {\n          object_iterator_ =\n              isolate_->heap()->code_lo_space()->GetObjectIterator(\n                  isolate_->heap());\n          state_ = kIteratingCodeLOSpace;\n          continue;\n        }\n        case kIteratingCodeLOSpace:\n          // No other spaces to iterate, so clean up and we're done. Keep the\n          // object iterator so that it keeps returning null on Next(), to avoid\n          // needing to branch on state_ before the while loop, but drop the\n          // safepoint scope since we no longer need to stop the heap from\n          // moving.\n          safepoint_scope_.reset();\n          state_ = kDone;\n          [[fallthrough]];\n        case kDone:\n          return Code();\n      }\n    }\n    Tagged<InstructionStream> istream = Cast<InstructionStream>(object);\n    Tagged<Code> code;\n    if (!istream->TryGetCode(&code, kAcquireLoad)) continue;\n    if (!CodeKindCanDeoptimize(code->kind())) continue;\n    return code;\n  }\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FrameWriter\",\n            \"about\": \"Abstraction for writing FrameDescriptions, managing the offset of the next slot to write to.\",\n            \"attributes\": [\n                {\n                    \"name\": \"deoptimizer_\",\n                    \"type\": \"Deoptimizer*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The deoptimizer using this FrameWriter.\"\n                },\n                {\n                    \"name\": \"frame_\",\n                    \"type\": \"FrameDescription*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The FrameDescription being written to.\"\n                },\n                {\n                    \"name\": \"trace_scope_\",\n                    \"type\": \"CodeTracer::Scope*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"For tracing deoptimization events.\"\n                },\n                {\n                    \"name\": \"top_offset_\",\n                    \"type\": \"unsigned\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The offset of the next slot to write to in the FrameDescription.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Deoptimizer\",\n                \"FrameDescription\",\n                \"CodeTracer\",\n                \"TranslatedFrame\",\n                \"Object\",\n                \"ReadOnlyRoots\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// {FrameWriter} offers a stack writer abstraction for writing\n// FrameDescriptions. The main service the class provides is managing\n// {top_offset_}, i.e. the offset of the next slot to write to.\n//\n// Note: Not in an anonymous namespace due to the friend class declaration\n// in Deoptimizer.\nclass FrameWriter {\n public:\n  static const int NO_INPUT_INDEX = -1;\n  FrameWriter(Deoptimizer* deoptimizer, FrameDescription* frame,\n              CodeTracer::Scope* trace_scope)\n      : deoptimizer_(deoptimizer),\n        frame_(frame),\n        trace_scope_(trace_scope),\n        top_offset_(frame->GetFrameSize()) {}\n\n  void PushRawValue(intptr_t value, const char* debug_hint) {\n    PushValue(value);\n    if (trace_scope_ != nullptr) {\n      DebugPrintOutputValue(value, debug_hint);\n    }\n  }\n\n  void PushRawObject(Tagged<Object> obj, const char* debug_hint) {\n    intptr_t value = obj.ptr();\n    PushValue(value);\n    if (trace_scope_ != nullptr) {\n      DebugPrintOutputObject(obj, top_offset_, debug_hint);\n    }\n  }\n\n  // There is no check against the allowed addresses for bottommost frames, as\n  // the caller's pc could be anything. The caller's pc pushed here should never\n  // be re-signed.\n  void PushBottommostCallerPc(intptr_t pc) {\n    top_offset_ -= kPCOnStackSize;\n    frame_->SetFrameSlot(top_offset_, pc);\n    DebugPrintOutputPc(pc, \"bottommost caller's pc\\n\");\n  }\n\n  void PushApprovedCallerPc(intptr_t pc) {\n    top_offset_ -= kPCOnStackSize;\n    frame_->SetCallerPc(top_offset_, pc);\n    DebugPrintOutputPc(pc, \"caller's pc\\n\");\n  }\n\n  void PushCallerFp(intptr_t fp) {\n    top_offset_ -= kFPOnStackSize;\n    frame_->SetCallerFp(top_offset_, fp);\n    DebugPrintOutputValue(fp, \"caller's fp\\n\");\n  }\n\n  void PushCallerConstantPool(intptr_t cp) {\n    top_offset_ -= kSystemPointerSize;\n    frame_->SetCallerConstantPool(top_offset_, cp);\n    DebugPrintOutputValue(cp, \"caller's constant_pool\\n\");\n  }\n\n  void PushTranslatedValue(const TranslatedFrame::iterator& iterator,\n                           const char* debug_hint = \"\") {\n    Tagged<Object> obj = iterator->GetRawValue();\n    PushRawObject(obj, debug_hint);\n    if (trace_scope_ != nullptr) {\n      PrintF(trace_scope_->file(), \" (input #%d)\\n\", iterator.input_index());\n    }\n    deoptimizer_->QueueValueForMaterialization(output_address(top_offset_), obj,\n                                               iterator);\n  }\n\n  void PushFeedbackVectorForMaterialization(\n      const TranslatedFrame::iterator& iterator) {\n    // Push a marker temporarily.\n    PushRawObject(ReadOnlyRoots(deoptimizer_->isolate()).arguments_marker(),\n                  \"feedback vector\");\n    deoptimizer_->QueueFeedbackVectorForMaterialization(\n        output_address(top_offset_), iterator);\n  }\n\n  void PushStackJSArguments(TranslatedFrame::iterator& iterator,\n                            int parameters_count) {\n    std::vector<TranslatedFrame::iterator> parameters;\n    parameters.reserve(parameters_count);\n    for (int i = 0; i < parameters_count; ++i, ++iterator) {\n      parameters.push_back(iterator);\n    }\n    for (auto& parameter : base::Reversed(parameters)) {\n      PushTranslatedValue(parameter, \"stack parameter\");\n    }\n  }\n\n  unsigned top_offset() const { return top_offset_; }\n\n  FrameDescription* frame() { return frame_; }\n\n private:\n  void PushValue(intptr_t value) {\n    CHECK_GE(top_offset_, 0);\n    top_offset_ -= kSystemPointerSize;\n    frame_->SetFrameSlot(top_offset_, value);\n  }\n\n  Address output_address(unsigned output_offset) {\n    Address output_address =\n        static_cast<Address>(frame_->GetTop()) + output_offset;\n    return output_address;\n  }\n\n  void DebugPrintOutputValue(intptr_t value, const char* debug_hint = \"\") {\n    if (trace_scope_ != nullptr) {\n      PrintF(trace_scope_->file(),\n             \"    \" V8PRIxPTR_FMT \": [top + %3d] <- \" V8PRIxPTR_FMT \" ;  %s\",\n             output_address(top_offset_), top_offset_, value, debug_hint);\n    }\n  }\n\n  void DebugPrintOutputPc(intptr_t value, const char* debug_hint = \"\") {\n#ifdef V8_ENABLE_CONTROL_FLOW_INTEGRITY\n    if (trace_scope_ != nullptr) {\n      PrintF(trace_scope_->file(),\n             \"    \" V8PRIxPTR_FMT \": [top + %3d] <- \" V8PRIxPTR_FMT\n             \" (signed) \" V8PRIxPTR_FMT \" (unsigned) ;  %s\",\n             output_address(top_offset_), top_offset_, value,\n             PointerAuthentication::StripPAC(value), debug_hint);\n    }\n#else\n    DebugPrintOutputValue(value, debug_hint);\n#endif\n  }\n\n  void DebugPrintOutputObject(Tagged<Object> obj, unsigned output_offset,\n                              const char* debug_hint = \"\") {\n    if (trace_scope_ != nullptr) {\n      PrintF(trace_scope_->file(), \"    \" V8PRIxPTR_FMT \": [top + %3d] <- \",\n             output_address(output_offset), output_offset);\n      if (IsSmi(obj)) {\n        PrintF(trace_scope_->file(), V8PRIxPTR_FMT \" <Smi %d>\", obj.ptr(),\n               Cast<Smi>(obj).value());\n      } else {\n        ShortPrint(obj, trace_scope_->file());\n      }\n      PrintF(trace_scope_->file(), \" ;  %s\", debug_hint);\n    }\n  }\n\n  Deoptimizer* deoptimizer_;\n  FrameDescription* frame_;\n  CodeTracer::Scope* const trace_scope_;\n  unsigned top_offset_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Deoptimizer::New\",\n            \"parent\": \"Deoptimizer\",\n            \"about\": \"Creates a new Deoptimizer object.\",\n            \"logic\": \"Allocates a new Deoptimizer object on the heap, sets the current deoptimizer in the isolate, and returns the new object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"raw_function\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The address of the JSFunction being deoptimized.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"DeoptimizeKind\",\n                    \"purpose\": \"The type of deoptimization (eager or lazy).\"\n                },\n                {\n                    \"name\": \"from\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The address in the optimized code where deoptimization is triggered.\"\n                },\n                {\n                    \"name\": \"fp_to_sp_delta\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The difference between the frame pointer and stack pointer at the point of deoptimization.\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate for which to deoptimize.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Deoptimizer*\",\n                \"description\": \"A pointer to the newly created Deoptimizer object.\"\n            },\n            \"dependencies\": [\n                \"JSFunction\",\n                \"Deoptimizer\",\n                \"Isolate\",\n                \"set_current_deoptimizer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// We rely on this function not causing a GC. It is called from generated code\n// without having a real stack frame in place.\nDeoptimizer* Deoptimizer::New(Address raw_function, DeoptimizeKind kind,\n                              Address from, int fp_to_sp_delta,\n                              Isolate* isolate) {\n  // This is zero for wasm.\n  Tagged<JSFunction> function =\n      raw_function != 0 ? Cast<JSFunction>(Tagged<Object>(raw_function))\n                        : Tagged<JSFunction>();\n  Deoptimizer* deoptimizer =\n      new Deoptimizer(isolate, function, kind, from, fp_to_sp_delta);\n  isolate->set_current_deoptimizer(deoptimizer);\n  return deoptimizer;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Deoptimizer::Grab\",\n            \"parent\": \"Deoptimizer\",\n            \"about\": \"Retrieves and clears the current deoptimizer from the isolate.\",\n            \"logic\": \"Gets the currently set deoptimizer from the isolate and clears the isolate's deoptimizer pointer. Deletes the frame descriptions associated with deoptimizer object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate from which to grab the deoptimizer.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Deoptimizer*\",\n                \"description\": \"A pointer to the retrieved Deoptimizer object.\"\n            },\n            \"dependencies\": [\n                \"Deoptimizer\",\n                \"Isolate\",\n                \"GetAndClearCurrentDeoptimizer\",\n                \"DeleteFrameDescriptions\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDeoptimizer* Deoptimizer::Grab(Isolate* isolate) {\n  Deoptimizer* result = isolate->GetAndClearCurrentDeoptimizer();\n  result->DeleteFrameDescriptions();\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Deoptimizer::DeleteForWasm\",\n            \"parent\": \"Deoptimizer\",\n            \"about\": \"Deletes a Deoptimizer object used in WebAssembly deoptimization.\",\n            \"logic\": \"Grabs the current deoptimizer, gets the output count, deletes the deoptimizer, and returns the output count.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate associated with the deoptimizer.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The output count of the deoptimizer.\"\n            },\n            \"dependencies\": [\n                \"Deoptimizer\",\n                \"Isolate\",\n                \"Grab\",\n                \"AllowGarbageCollection\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nsize_t Deoptimizer::DeleteForWasm(Isolate* isolate) {\n  // The deoptimizer disallows garbage collections.\n  DCHECK(!AllowGarbageCollection::IsAllowed());\n  Deoptimizer* deoptimizer = Deoptimizer::Grab(isolate);\n  int output_count = deoptimizer->output_count();\n  delete deoptimizer;\n  // Now garbage collections are allowed again.\n  DCHECK(AllowGarbageCollection::IsAllowed());\n  return output_count;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Deoptimizer::DebuggerInspectableFrame\",\n            \"parent\": \"Deoptimizer\",\n            \"about\": \"Creates a DeoptimizedFrameInfo object for debugger inspection.\",\n            \"logic\": \"Prepares a TranslatedState, finds the relevant unoptimized frame, and creates a DeoptimizedFrameInfo object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"frame\",\n                    \"type\": \"JavaScriptFrame*\",\n                    \"purpose\": \"The JavaScript frame to inspect.\"\n                },\n                {\n                    \"name\": \"jsframe_index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the JS frame.\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate associated with the frame.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DeoptimizedFrameInfo*\",\n                \"description\": \"A pointer to the newly created DeoptimizedFrameInfo object.\"\n            },\n            \"dependencies\": [\n                \"JavaScriptFrame\",\n                \"TranslatedState\",\n                \"DeoptimizedFrameInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDeoptimizedFrameInfo* Deoptimizer::DebuggerInspectableFrame(\n    JavaScriptFrame* frame, int jsframe_index, Isolate* isolate) {\n  CHECK(frame->is_optimized_js());\n\n  TranslatedState translated_values(frame);\n  translated_values.Prepare(frame->fp());\n\n  TranslatedState::iterator frame_it = translated_values.end();\n  int counter = jsframe_index;\n  for (auto it = translated_values.begin(); it != translated_values.end();\n       it++) {\n    if (it->kind() == TranslatedFrame::kUnoptimizedFunction ||\n        it->kind() == TranslatedFrame::kJavaScriptBuiltinContinuation ||\n        it->kind() ==\n            TranslatedFrame::kJavaScriptBuiltinContinuationWithCatch) {\n      if (counter == 0) {\n        frame_it = it;\n        break;\n      }\n      counter--;\n    }\n  }\n  CHECK(frame_it != translated_values.end());\n  // We only include kJavaScriptBuiltinContinuation frames above to get the\n  // counting right.\n  CHECK_EQ(frame_it->kind(), TranslatedFrame::kUnoptimizedFunction);\n\n  DeoptimizedFrameInfo* info =\n      new DeoptimizedFrameInfo(&translated_values, frame_it, isolate);\n\n  return info;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ActivationsFinder\",\n            \"about\": \"Finds activations of codes marked for deoptimization and replaces the current PC on the stack with a trampoline to the deoptimizer call.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ThreadVisitor\",\n                \"Isolate\",\n                \"ThreadLocalTop\",\n                \"StackFrameIterator\",\n                \"GcSafeCode\",\n                \"CodeKindCanDeoptimize\",\n                \"SafepointTable\",\n                \"Address\",\n                \"StackFrame\",\n                \"PointerAuthentication\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\nclass ActivationsFinder : public ThreadVisitor {\n public:\n  ActivationsFinder(Tagged<GcSafeCode> topmost_optimized_code,\n                    bool safe_to_deopt_topmost_optimized_code) {\n#ifdef DEBUG\n    topmost_ = topmost_optimized_code;\n    safe_to_deopt_ = safe_to_deopt_topmost_optimized_code;\n#endif\n  }\n\n  // Find the frames with activations of codes marked for deoptimization, search\n  // for the trampoline to the deoptimizer call respective to each code, and use\n  // it to replace the current pc on the stack.\n  void VisitThread(Isolate* isolate, ThreadLocalTop* top) override {\n    for (StackFrameIterator it(isolate, top, StackFrameIterator::NoHandles{});\n         !it.done(); it.Advance()) {\n      if (it.frame()->is_optimized_js()) {\n        Tagged<GcSafeCode> code = it.frame()->GcSafeLookupCode();\n        if (CodeKindCanDeoptimize(code->kind()) &&\n            code->marked_for_deoptimization()) {\n          // Obtain the trampoline to the deoptimizer call.\n          int trampoline_pc;\n          if (code->is_maglevved()) {\n            MaglevSafepointEntry safepoint = MaglevSafepointTable::FindEntry(\n                isolate, code, it.frame()->pc());\n            trampoline_pc = safepoint.trampoline_pc();\n          } else {\n            SafepointEntry safepoint = SafepointTable::FindEntry(\n                isolate, code, it.frame()->maybe_unauthenticated_pc());\n            trampoline_pc = safepoint.trampoline_pc();\n          }\n          // TODO(saelo): currently we have to use full pointer comparison as\n          // builtin Code is still inside the sandbox while runtime-generated\n          // Code is in trusted space.\n          static_assert(!kAllCodeObjectsLiveInTrustedSpace);\n          DCHECK_IMPLIES(code.SafeEquals(topmost_), safe_to_deopt_);\n          static_assert(SafepointEntry::kNoTrampolinePC == -1);\n          CHECK_GE(trampoline_pc, 0);\n          if (!it.frame()->InFastCCall()) {\n            Address new_pc = code->instruction_start() + trampoline_pc;\n            if (v8_flags.cet_compatible) {\n              Address pc = *it.frame()->pc_address();\n              Deoptimizer::PatchToJump(pc, new_pc);\n            } else {\n              // Replace the current pc on the stack with the trampoline.\n              // TODO(v8:10026): avoid replacing a signed pointer.\n              Address* pc_addr = it.frame()->pc_address();\n              PointerAuthentication::ReplacePC(pc_addr, new_pc,\n                                               kSystemPointerSize);\n            }\n          }\n        }\n      }\n    }\n  }\n\n private:\n#ifdef DEBUG\n  Tagged<GcSafeCode> topmost_;\n  bool safe_to_deopt_;\n#endif\n};\n}  // namespace\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Deoptimizer::DeoptimizeMarkedCode\",\n            \"parent\": \"Deoptimizer\",\n            \"about\": \"Replaces the PC on the stack for codes marked for deoptimization with the deoptimization trampoline.\",\n            \"logic\": \"Iterates through all threads, finds frames with codes marked for deoptimization, retrieves the deoptimization trampoline PC, and replaces the original PC on the stack with the trampoline PC. Uses ActivationsFinder to visit each thread.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to deoptimize code in.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"DisallowGarbageCollection\",\n                \"GcSafeCode\",\n                \"StackFrameIterator\",\n                \"CodeKindCanDeoptimize\",\n                \"SafepointTable\",\n                \"Code\",\n                \"OptimizedJSFrame\",\n                \"JSFunction\",\n                \"ThreadManager\",\n                \"ActivationsFinder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Replace pc on the stack for codes marked for deoptimization.\n// static\nvoid Deoptimizer::DeoptimizeMarkedCode(Isolate* isolate) {\n  DisallowGarbageCollection no_gc;\n\n  Tagged<GcSafeCode> topmost_optimized_code;\n  bool safe_to_deopt_topmost_optimized_code = false;\n#ifdef DEBUG\n  // Make sure all activations of optimized code can deopt at their current PC.\n  // The topmost optimized code has special handling because it cannot be\n  // deoptimized due to weak object dependency.\n  for (StackFrameIterator it(isolate, isolate->thread_local_top(),\n                             StackFrameIterator::NoHandles{});\n       !it.done(); it.Advance()) {\n    if (it.frame()->is_optimized_js()) {\n      Tagged<GcSafeCode> code = it.frame()->GcSafeLookupCode();\n      Tagged<JSFunction> function =\n          static_cast<OptimizedJSFrame*>(it.frame())->function();\n      TraceFoundActivation(isolate, function);\n      bool safe_if_deopt_triggered;\n      if (code->is_maglevved()) {\n        MaglevSafepointEntry safepoint =\n            MaglevSafepointTable::FindEntry(isolate, code, it.frame()->pc());\n        safe_if_deopt_triggered = safepoint.has_deoptimization_index();\n      } else {\n        SafepointEntry safepoint = SafepointTable::FindEntry(\n            isolate, code, it.frame()->maybe_unauthenticated_pc());\n        safe_if_deopt_triggered = safepoint.has_deoptimization_index();\n      }\n\n      // Deopt is checked when we are patching addresses on stack.\n      bool is_builtin_code = code->kind() == CodeKind::BUILTIN;\n      DCHECK(topmost_optimized_code.is_null() || safe_if_deopt_triggered ||\n             is_builtin_code);\n      if (topmost_optimized_code.is_null()) {\n        topmost_optimized_code = code;\n        safe_to_deopt_topmost_optimized_code = safe_if_deopt_triggered;\n      }\n    }\n  }\n#endif\n\n  ActivationsFinder visitor(topmost_optimized_code,\n                            safe_to_deopt_topmost_optimized_code);\n  // Iterate over the stack of this thread.\n  visitor.VisitThread(isolate, isolate->thread_local_top());\n  // In addition to iterate over the stack of this thread, we also\n  // need to consider all the other threads as they may also use\n  // the code currently beings deoptimized.\n  isolate->thread_manager()->IterateArchivedThreads(&visitor);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Deoptimizer::DeoptimizeAll\",\n            \"parent\": \"Deoptimizer\",\n            \"about\": \"Deoptimizes all optimized code in all contexts.\",\n            \"logic\": \"Marks all deoptimizable code for deoptimization, then triggers the deoptimization process.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate in which to deoptimize all code.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"RCS_SCOPE\",\n                \"TimerEventScope\",\n                \"TRACE_EVENT0\",\n                \"DeoptimizableCodeIterator\",\n                \"Code\",\n                \"DeoptimizeMarkedCode\",\n                \"AbortConcurrentOptimization\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Deoptimizer::DeoptimizeAll(Isolate* isolate) {\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kDeoptimizeCode);\n  TimerEventScope<TimerEventDeoptimizeCode> timer(isolate);\n  TRACE_EVENT0(\"v8\", \"V8.DeoptimizeCode\");\n  TraceDeoptAll(isolate);\n  isolate->AbortConcurrentOptimization(BlockingBehavior::kBlock);\n\n  // Mark all code, then deoptimize.\n  {\n    DeoptimizableCodeIterator it(isolate);\n    for (Tagged<Code> code = it.Next(); !code.is_null(); code = it.Next()) {\n      code->SetMarkedForDeoptimization(isolate,\n                                       LazyDeoptimizeReason::kDebugger);\n    }\n  }\n\n  DeoptimizeMarkedCode(isolate);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Deoptimizer::"
}