{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/branch-elimination.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/branch-elimination.cc\",\n        \"file_name\": \"branch-elimination.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements branch elimination optimization in the V8 compiler\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for branch elimination, base utilities, compiler phases, graph manipulation, node matching, and operator definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/branch-elimination.h\"\n\n#include \"src/base/small-vector.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/opcodes.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BranchElimination\",\n            \"extends\": \"AdvancedReducerWithControlPathState\",\n            \"about\": \"Performs branch elimination to simplify control flow by identifying and removing redundant branches based on known conditions.\",\n            \"attributes\": [\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the JSGraph, providing access to the graph representation.\"\n                },\n                {\n                    \"name\": \"dead_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The dead node, used for replacing eliminated code.\"\n                },\n                {\n                    \"name\": \"phase_\",\n                    \"type\": \"Phase\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current compiler phase.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Editor\",\n                \"JSGraph\",\n                \"Zone\",\n                \"AdvancedReducerWithControlPathState\",\n                \"Node\",\n                \"Phase\",\n                \"BranchSemantics\",\n                \"TFGraph\",\n                \"CommonOperatorBuilder\",\n                \"Isolate\",\n                \"ControlPathConditions\",\n                \"BranchCondition\",\n                \"NodeProperties\",\n                \"base::SmallVector\",\n                \"DeoptimizeParameters\",\n                \"Edge\",\n                \"Int32Matcher\",\n                \"DeoptimizeParametersOf\",\n                \"BranchParametersOf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nBranchElimination::BranchElimination(Editor* editor, JSGraph* js_graph,\n                                     Zone* zone, Phase phase)\n    : AdvancedReducerWithControlPathState(editor, zone, js_graph->graph()),\n      jsgraph_(js_graph),\n      dead_(js_graph->Dead()),\n      phase_(phase) {}\n\nBranchElimination::~BranchElimination() = default;\n\nReduction BranchElimination::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kDead:\n      return NoChange();\n    case IrOpcode::kDeoptimizeIf:\n    case IrOpcode::kDeoptimizeUnless:\n      return ReduceDeoptimizeConditional(node);\n    case IrOpcode::kMerge:\n      return ReduceMerge(node);\n    case IrOpcode::kLoop:\n      return ReduceLoop(node);\n    case IrOpcode::kBranch:\n      return ReduceBranch(node);\n    case IrOpcode::kIfFalse:\n      return ReduceIf(node, false);\n    case IrOpcode::kIfTrue:\n      return ReduceIf(node, true);\n    case IrOpcode::kTrapIf:\n    case IrOpcode::kTrapUnless:\n      return ReduceTrapConditional(node);\n    case IrOpcode::kStart:\n      return ReduceStart(node);\n    default:\n      if (node->op()->ControlOutputCount() > 0) {\n        return ReduceOtherControl(node);\n      } else {\n        return NoChange();\n      }\n  }\n}\n\nvoid BranchElimination::SimplifyBranchCondition(Node* branch) {\n  // Try to use a phi as a branch condition if the control flow from the branch\n  // is known from previous branches. For example, in the graph below, the\n  // control flow of the second_branch is predictable because the first_branch\n  // use the same branch condition. In such case, create a new phi with constant\n  // inputs and let the second branch use the phi as its branch condition. From\n  // this transformation, more branch folding opportunities would be exposed to\n  // later passes through branch cloning in effect-control-linearizer.\n  //\n  // condition                             condition\n  //    |   \\                                   |\n  //    |  first_branch                        first_branch\n  //    |   /          \\                       /          \\\n  //    |  /            \\                     /            \\\n  //    |first_true  first_false           first_true  first_false\n  //    |  \\           /                      \\           /\n  //    |   \\         /                        \\         /\n  //    |  first_merge           ==>          first_merge\n  //    |       |                              /    |\n  //   second_branch                    1  0  /     |\n  //    /          \\                     \\ | /      |\n  //   /            \\                     phi       |\n  // second_true  second_false              \\       |\n  //                                      second_branch\n  //                                      /          \\\n  //                                     /            \\\n  //                                   second_true  second_false\n  //\n\n  auto SemanticsOf = [phase = this->phase_](Node* branch) {\n    BranchSemantics semantics = BranchSemantics::kUnspecified;\n    if (branch->opcode() == IrOpcode::kBranch) {\n      semantics = BranchParametersOf(branch->op()).semantics();\n    }\n    if (semantics == BranchSemantics::kUnspecified) {\n      semantics =\n          (phase == kEARLY ? BranchSemantics::kJS : BranchSemantics::kMachine);\n    }\n    return semantics;\n  };\n\n  DCHECK_EQ(IrOpcode::kBranch, branch->opcode());\n  Node* merge = NodeProperties::GetControlInput(branch);\n  if (merge->opcode() != IrOpcode::kMerge) return;\n\n  Node* condition = branch->InputAt(0);\n  BranchSemantics semantics = SemanticsOf(branch);\n  TFGraph* graph = jsgraph()->graph();\n  base::SmallVector<Node*, 2> phi_inputs;\n\n  Node::Inputs inputs = merge->inputs();\n  int input_count = inputs.count();\n  for (int i = 0; i != input_count; ++i) {\n    Node* input = inputs[i];\n    ControlPathConditions from_input = GetState(input);\n\n    BranchCondition branch_condition = from_input.LookupState(condition);\n    if (!branch_condition.IsSet()) return;\n    if (SemanticsOf(branch_condition.branch) != semantics) return;\n    bool condition_value = branch_condition.is_true;\n\n    if (semantics == BranchSemantics::kJS) {\n      phi_inputs.emplace_back(jsgraph()->BooleanConstant(condition_value));\n    } else {\n      DCHECK_EQ(semantics, BranchSemantics::kMachine);\n      phi_inputs.emplace_back(\n          condition_value\n              ? graph->NewNode(jsgraph()->common()->Int32Constant(1))\n              : graph->NewNode(jsgraph()->common()->Int32Constant(0)));\n    }\n  }\n  phi_inputs.emplace_back(merge);\n  Node* new_phi =\n      graph->NewNode(common()->Phi(semantics == BranchSemantics::kJS\n                                       ? MachineRepresentation::kTagged\n                                       : MachineRepresentation::kWord32,\n                                   input_count),\n                     input_count + 1, &phi_inputs.at(0));\n\n  // Replace the branch condition with the new phi.\n  NodeProperties::ReplaceValueInput(branch, new_phi, 0);\n}\n\nbool BranchElimination::TryEliminateBranchWithPhiCondition(Node* branch,\n                                                           Node* phi,\n                                                           Node* merge) {\n  // If the condition of the branch comes from two constant values,\n  // then try to merge the branches successors into its predecessors,\n  // and eliminate the (branch, phi, merge) nodes.\n  //\n  //  pred0   pred1\n  //     \\    /\n  //      merge             0   1\n  //       |  \\___________  |  /\n  //       |              \\ | /              pred0     pred1\n  //       |               phi                 |         |\n  //       |   _____________/        =>        |         |\n  //       |  /                                |         |\n  //      branch                             succ0     succ1\n  //      /    \\\n  //   false   true\n  //     |      |\n  //   succ0  succ1\n  //\n\n  DCHECK_EQ(branch->opcode(), IrOpcode::kBranch);\n  DCHECK_EQ(phi->opcode(), IrOpcode::kPhi);\n  DCHECK_EQ(merge->opcode(), IrOpcode::kMerge);\n  DCHECK_EQ(NodeProperties::GetControlInput(branch, 0), merge);\n  if (!phi->OwnedBy(branch)) return false;\n  if (phi->InputCount() != 3) return false;\n  if (phi->InputAt(2) != merge) return false;\n  if (merge->UseCount() != 2) return false;\n\n  Node::Inputs phi_inputs = phi->inputs();\n  Node* first_value = phi_inputs[0];\n  Node* second_value = phi_inputs[1];\n  if (first_value->opcode() != IrOpcode::kInt32Constant ||\n      second_value->opcode() != IrOpcode::kInt32Constant) {\n    return false;\n  }\n  Node::Inputs merge_inputs = merge->inputs();\n  Node* predecessor0 = merge_inputs[0];\n  Node* predecessor1 = merge_inputs[1];\n  DCHECK_EQ(branch->op()->ControlOutputCount(), 2);\n  Node** projections = zone()->AllocateArray<Node*>(2);\n  NodeProperties::CollectControlProjections(branch, projections, 2);\n  Node* branch_true = projections[0];\n  Node* branch_false = projections[1];\n  DCHECK_EQ(branch_true->opcode(), IrOpcode::kIfTrue);\n  DCHECK_EQ(branch_false->opcode(), IrOpcode::kIfFalse);\n\n  // The input values of phi should be true(1) and false(0).\n  Int32Matcher mfirst_value(first_value);\n  Int32Matcher msecond_value(second_value);\n  Node* predecessor_true = nullptr;\n  Node* predecessor_false = nullptr;\n  if (mfirst_value.Is(1) && msecond_value.Is(0)) {\n    predecessor_true = predecessor0;\n    predecessor_false = predecessor1;\n  } else if (mfirst_value.Is(0) && msecond_value.Is(1)) {\n    predecessor_true = predecessor1;\n    predecessor_false = predecessor0;\n  } else {\n    return false;\n  }\n\n  // Merge the branches successors into its predecessors.\n  for (Edge edge : branch_true->use_edges()) {\n    edge.UpdateTo(predecessor_true);\n  }\n  for (Edge edge : branch_false->use_edges()) {\n    edge.UpdateTo(predecessor_false);\n  }\n\n  branch_true->Kill();\n  branch_false->Kill();\n  branch->Kill();\n  phi->Kill();\n  merge->Kill();\n  return true;\n}\n\nReduction BranchElimination::ReduceBranch(Node* node) {\n  Node* condition = node->InputAt(0);\n  Node* control_input = NodeProperties::GetControlInput(node, 0);\n  if (!IsReduced(control_input)) return NoChange();\n  ControlPathConditions from_input = GetState(control_input);\n  // If we know the condition we can discard the branch.\n  BranchCondition branch_condition = from_input.LookupState(condition);\n  if (branch_condition.IsSet()) {\n    bool condition_value = branch_condition.is_true;\n    for (Node* const use : node->uses()) {\n      switch (use->opcode()) {\n        case IrOpcode::kIfTrue:\n          Replace(use, condition_value ? control_input : dead());\n          break;\n        case IrOpcode::kIfFalse:\n          Replace(use, condition_value ? dead() : control_input);\n          break;\n        default:\n          UNREACHABLE();\n      }\n    }\n    return Replace(dead());\n  }\n  SimplifyBranchCondition(node);\n  // Try to reduce the pattern that branch condition comes from phi node.\n  if (condition->opcode() == IrOpcode::kPhi &&\n      control_input->opcode() == IrOpcode::kMerge) {\n    if (TryEliminateBranchWithPhiCondition(node, condition, control_input)) {\n      return Replace(dead());\n    }\n  }\n  // Trigger revisits of the IfTrue/IfFalse projections, since they depend on\n  // the branch condition.\n  for (Node* const use : node->uses()) {\n    Revisit(use);\n  }\n  return TakeStatesFromFirstControl(node);\n}\n\nReduction BranchElimination::ReduceTrapConditional(Node* node) {\n  DCHECK(node->opcode() == IrOpcode::kTrapIf ||\n         node->opcode() == IrOpcode::kTrapUnless);\n  bool trapping_condition = node->opcode() == IrOpcode::kTrapIf;\n  Node* condition = node->InputAt(0);\n  Node* control_input = NodeProperties::GetControlInput(node, 0);\n  // If we do not know anything about the predecessor, do not propagate just\n  // yet because we will have to recompute anyway once we compute the\n  // predecessor.\n  if (!IsReduced(control_input)) return NoChange();\n\n  ControlPathConditions from_input = GetState(control_input);\n\n  BranchCondition branch_condition = from_input.LookupState(condition);\n  if (branch_condition.IsSet()) {\n    bool condition_value = branch_condition.is_true;\n    if (condition_value == trapping_condition) {\n      // This will always trap. Mark its outputs as dead and connect it to\n      // graph()->end().\n      ReplaceWithValue(node, dead(), dead(), dead());\n      Node* control = graph()->NewNode(common()->Throw(), node, node);\n      MergeControlToEnd(graph(), common(), control);\n      return Changed(node);\n    } else {\n      // This will not trap, remove it by relaxing effect/control.\n      RelaxEffectsAndControls(node);\n      Node* control = NodeProperties::GetControlInput(node);\n      node->Kill();\n      return Replace(control);  // Irrelevant argument\n    }\n  }\n  return UpdateStatesHelper(node, from_input, condition, node,\n                            !trapping_condition, false);\n}\n\nReduction BranchElimination::ReduceDeoptimizeConditional(Node* node) {\n  DCHECK(node->opcode() == IrOpcode::kDeoptimizeIf ||\n         node->opcode() == IrOpcode::kDeoptimizeUnless);\n  bool condition_is_true = node->opcode() == IrOpcode::kDeoptimizeUnless;\n  DeoptimizeParameters p = DeoptimizeParametersOf(node->op());\n  Node* condition = NodeProperties::GetValueInput(node, 0);\n  Node* frame_state = NodeProperties::GetValueInput(node, 1);\n  Node* effect = NodeProperties::GetEffectInput(node);\n  Node* control = NodeProperties::GetControlInput(node);\n  // If we do not know anything about the predecessor, do not propagate just\n  // yet because we will have to recompute anyway once we compute the\n  // predecessor.\n  if (!IsReduced(control)) {\n    return NoChange();\n  }\n\n  ControlPathConditions conditions = GetState(control);\n  BranchCondition branch_condition = conditions.LookupState(condition);\n  if (branch_condition.IsSet()) {\n    // If we know the condition we can discard the branch.\n    bool condition_value = branch_condition.is_true;\n    if (condition_is_true == condition_value) {\n      // We don't update the conditions here, because we're replacing {node}\n      // with the {control} node that already contains the right information.\n      ReplaceWithValue(node, dead(), effect, control);\n    } else {\n      control = graph()->NewNode(common()->Deoptimize(p.reason(), p.feedback()),\n                                 frame_state, effect, control);\n      MergeControlToEnd(graph(), common(), control);\n    }\n    return Replace(dead());\n  }\n  return UpdateStatesHelper(node, conditions, condition, node,\n                            condition_is_true, false);\n}\n\nReduction BranchElimination::ReduceIf(Node* node, bool is_true_branch) {\n  // Add the condition to the list arriving from the input branch.\n  Node* branch = NodeProperties::GetControlInput(node, 0);\n  ControlPathConditions from_branch = GetState(branch);\n  // If we do not know anything about the predecessor, do not propagate just\n  // yet because we will have to recompute anyway once we compute the\n  // predecessor.\n  if (!IsReduced(branch)) {\n    return NoChange();\n  }\n  Node* condition = branch->InputAt(0);\n  return UpdateStatesHelper(node, from_branch, condition, branch,\n                            is_true_branch, true);\n}\n\nReduction BranchElimination::ReduceLoop(Node* node) {\n  // Here we rely on having only reducible loops:\n  // The loop entry edge always dominates the header, so we can just use\n  // the information from the loop entry edge.\n  return TakeStatesFromFirstControl(node);\n}\n\nReduction BranchElimination::ReduceMerge(Node* node) {\n  // Shortcut for the case when we do not know anything about some\n  // input.\n  Node::Inputs inputs = node->inputs();\n  for (Node* input : inputs) {\n    if (!IsReduced(input)) {\n      return NoChange();\n    }\n  }\n\n  auto input_it = inputs.begin();\n\n  DCHECK_GT(inputs.count(), 0);\n\n  ControlPathConditions conditions = GetState(*input_it);\n  ++input_it;\n  // Merge the first input's conditions with the conditions from the other\n  // inputs.\n  auto input_end = inputs.end();\n  for (; input_it != input_end; ++input_it) {\n    // Change the current condition block list to a longest common tail of this\n    // condition list and the other list. (The common tail should correspond to\n    // the list from the common dominator.)\n    conditions.ResetToCommonAncestor(GetState(*input_it));\n  }\n  return UpdateStates(node, conditions);\n}\n\nReduction BranchElimination::ReduceStart(Node* node) {\n  return UpdateStates(node, ControlPathConditions(zone()));\n}\n\nReduction BranchElimination::ReduceOtherControl(Node* node) {\n  DCHECK_EQ(1, node->op()->ControlInputCount());\n  return TakeStatesFromFirstControl(node);\n}\n\nTFGraph* BranchElimination::graph() const { return jsgraph()->graph(); }\n\nIsolate* BranchElimination::isolate() const { return jsgraph()->isolate(); }\n\nCommonOperatorBuilder* BranchElimination::common() const {\n  return jsgraph()->common();\n}\n\n// Workaround a gcc bug causing link errors.\n// Related issue: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105848\ntemplate bool DefaultConstruct<bool>(Zone* zone);\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"BranchElimination\",\n            \"about\": \"Reduces a node based on its opcode, performing branch elimination or other simplifications.\",\n            \"logic\": \"This is the main dispatch function for the branch elimination reducer. It uses a switch statement to handle different opcodes, calling the appropriate reduction method for each.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction, indicating whether the node was changed or replaced.\"\n            },\n            \"dependencies\": [\n                \"NoChange\",\n                \"ReduceDeoptimizeConditional\",\n                \"ReduceMerge\",\n                \"ReduceLoop\",\n                \"ReduceBranch\",\n                \"ReduceIf\",\n                \"ReduceTrapConditional\",\n                \"ReduceStart\",\n                \"ReduceOtherControl\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction BranchElimination::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kDead:\n      return NoChange();\n    case IrOpcode::kDeoptimizeIf:\n    case IrOpcode::kDeoptimizeUnless:\n      return ReduceDeoptimizeConditional(node);\n    case IrOpcode::kMerge:\n      return ReduceMerge(node);\n    case IrOpcode::kLoop:\n      return ReduceLoop(node);\n    case IrOpcode::kBranch:\n      return ReduceBranch(node);\n    case IrOpcode::kIfFalse:\n      return ReduceIf(node, false);\n    case IrOpcode::kIfTrue:\n      return ReduceIf(node, true);\n    case IrOpcode::kTrapIf:\n    case IrOpcode::kTrapUnless:\n      return ReduceTrapConditional(node);\n    case IrOpcode::kStart:\n      return ReduceStart(node);\n    default:\n      if (node->op()->ControlOutputCount() > 0) {\n        return ReduceOtherControl(node);\n      } else {\n        return NoChange();\n      }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SimplifyBranchCondition\",\n            \"parent\": \"BranchElimination\",\n            \"about\": \"Simplifies a branch condition by using a phi node if the control flow from the branch is known from previous branches.\",\n            \"logic\": \"This function attempts to replace a branch condition with a phi node that combines constant inputs based on the control flow history. It checks if the incoming control paths to the branch have known conditions and creates a phi node with corresponding constant values.  This enables more branch folding later.\",\n            \"parameters\": [\n                {\n                    \"name\": \"branch\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The branch node whose condition needs to be simplified.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"BranchSemantics\",\n                \"SemanticsOf\",\n                \"BranchParametersOf\",\n                \"TFGraph\",\n                \"ControlPathConditions\",\n                \"GetState\",\n                \"BranchCondition\",\n                \"jsgraph_\",\n                \"common_\",\n                \"NodeProperties\",\n                \"BooleanConstant\",\n                \"Int32Constant\",\n                \"Phi\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BranchElimination::SimplifyBranchCondition(Node* branch) {\n  // Try to use a phi as a branch condition if the control flow from the branch\n  // is known from previous branches. For example, in the graph below, the\n  // control flow of the second_branch is predictable because the first_branch\n  // use the same branch condition. In such case, create a new phi with constant\n  // inputs and let the second branch use the phi as its branch condition. From\n  // this transformation, more branch folding opportunities would be exposed to\n  // later passes through branch cloning in effect-control-linearizer.\n  //\n  // condition                             condition\n  //    |   \\                                   |\n  //    |  first_branch                        first_branch\n  //    |   /          \\                       /          \\\n  //    |  /            \\                     /            \\\n  //    |first_true  first_false           first_true  first_false\n  //    |  \\           /                      \\           /\n  //    |   \\         /                        \\         /\n  //    |  first_merge           ==>          first_merge\n  //    |       |                              /    |\n  //   second_branch                    1  0  /     |\n  //    /          \\                     \\ | /      |\n  //   /            \\                     phi       |\n  // second_true  second_false              \\       |\n  //                                      second_branch\n  //                                      /          \\\n  //                                     /            \\\n  //                                   second_true  second_false\n  //\n\n  auto SemanticsOf = [phase = this->phase_](Node* branch) {\n    BranchSemantics semantics = BranchSemantics::kUnspecified;\n    if (branch->opcode() == IrOpcode::kBranch) {\n      semantics = BranchParametersOf(branch->op()).semantics();\n    }\n    if (semantics == BranchSemantics::kUnspecified) {\n      semantics =\n          (phase == kEARLY ? BranchSemantics::kJS : BranchSemantics::kMachine);\n    }\n    return semantics;\n  };\n\n  DCHECK_EQ(IrOpcode::kBranch, branch->opcode());\n  Node* merge = NodeProperties::GetControlInput(branch);\n  if (merge->opcode() != IrOpcode::kMerge) return;\n\n  Node* condition = branch->InputAt(0);\n  BranchSemantics semantics = SemanticsOf(branch);\n  TFGraph* graph = jsgraph()->graph();\n  base::SmallVector<Node*, 2> phi_inputs;\n\n  Node::Inputs inputs = merge->inputs();\n  int input_count = inputs.count();\n  for (int i = 0; i != input_count; ++i) {\n    Node* input = inputs[i];\n    ControlPathConditions from_input = GetState(input);\n\n    BranchCondition branch_condition = from_input.LookupState(condition);\n    if (!branch_condition.IsSet()) return;\n    if (SemanticsOf(branch_condition.branch) != semantics) return;\n    bool condition_value = branch_condition.is_true;\n\n    if (semantics == BranchSemantics::kJS) {\n      phi_inputs.emplace_back(jsgraph()->BooleanConstant(condition_value));\n    } else {\n      DCHECK_EQ(semantics, BranchSemantics::kMachine);\n      phi_inputs.emplace_back(\n          condition_value\n              ? graph->NewNode(jsgraph()->common()->Int32Constant(1))\n              : graph->NewNode(jsgraph()->common()->Int32Constant(0)));\n    }\n  }\n  phi_inputs.emplace_back(merge);\n  Node* new_phi =\n      graph->NewNode(common()->Phi(semantics == BranchSemantics::kJS\n                                       ? MachineRepresentation::kTagged\n                                       : MachineRepresentation::kWord32,\n                                   input_count),\n                     input_count + 1, &phi_inputs.at(0));\n\n  // Replace the branch condition with the new phi.\n  NodeProperties::ReplaceValueInput(branch, new_phi, 0);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TryEliminateBranchWithPhiCondition\",\n            \"parent\": \"BranchElimination\",\n            \"about\": \"Attempts to eliminate a branch whose condition is determined by a phi node with constant values.\",\n            \"logic\": \"This function identifies a specific pattern where a branch's condition comes from a phi node, which in turn merges two constant values (0 and 1). If this pattern is found, the function merges the true and false successors of the branch into the predecessors of the merge node, effectively eliminating the branch, phi, and merge nodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"branch\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The branch node to potentially eliminate.\"\n                },\n                {\n                    \"name\": \"phi\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The phi node providing the branch condition.\"\n                },\n                {\n                    \"name\": \"merge\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The merge node feeding into the phi node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the branch was successfully eliminated, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"Int32Matcher\",\n                \"Edge\",\n                \"zone_\",\n                \"AllocateArray\",\n                \"CollectControlProjections\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool BranchElimination::TryEliminateBranchWithPhiCondition(Node* branch,\n                                                           Node* phi,\n                                                           Node* merge) {\n  // If the condition of the branch comes from two constant values,\n  // then try to merge the branches successors into its predecessors,\n  // and eliminate the (branch, phi, merge) nodes.\n  //\n  //  pred0   pred1\n  //     \\    /\n  //      merge             0   1\n  //       |  \\___________  |  /\n  //       |              \\ | /              pred0     pred1\n  //       |               phi                 |         |\n  //       |   _____________/        =>        |         |\n  //       |  /                                |         |\n  //      branch                             succ0     succ1\n  //      /    \\\n  //   false   true\n  //     |      |\n  //   succ0  succ1\n  //\n\n  DCHECK_EQ(branch->opcode(), IrOpcode::kBranch);\n  DCHECK_EQ(phi->opcode(), IrOpcode::kPhi);\n  DCHECK_EQ(merge->opcode(), IrOpcode::kMerge);\n  DCHECK_EQ(NodeProperties::GetControlInput(branch, 0), merge);\n  if (!phi->OwnedBy(branch)) return false;\n  if (phi->InputCount() != 3) return false;\n  if (phi->InputAt(2) != merge) return false;\n  if (merge->UseCount() != 2) return false;\n\n  Node::Inputs phi_inputs = phi->inputs();\n  Node* first_value = phi_inputs[0];\n  Node* second_value = phi_inputs[1];\n  if (first_value->opcode() != IrOpcode::kInt32Constant ||\n      second_value->opcode() != IrOpcode::kInt32Constant) {\n    return false;\n  }\n  Node::Inputs merge_inputs = merge->inputs();\n  Node* predecessor0 = merge_inputs[0];\n  Node* predecessor1 = merge_inputs[1];\n  DCHECK_EQ(branch->op()->ControlOutputCount(), 2);\n  Node** projections = zone()->AllocateArray<Node*>(2);\n  NodeProperties::CollectControlProjections(branch, projections, 2);\n  Node* branch_true = projections[0];\n  Node* branch_false = projections[1];\n  DCHECK_EQ(branch_true->opcode(), IrOpcode::kIfTrue);\n  DCHECK_EQ(branch_false->opcode(), IrOpcode::kIfFalse);\n\n  // The input values of phi should be true(1) and false(0).\n  Int32Matcher mfirst_value(first_value);\n  Int32Matcher msecond_value(second_value);\n  Node* predecessor_true = nullptr;\n  Node* predecessor_false = nullptr;\n  if (mfirst_value.Is(1) && msecond_value.Is(0)) {\n    predecessor_true = predecessor0;\n    predecessor_false = predecessor1;\n  } else if (mfirst_value.Is(0) && msecond_value.Is(1)) {\n    predecessor_true = predecessor1;\n    predecessor_false = predecessor0;\n  } else {\n    return false;\n  }\n\n  // Merge the branches successors into its predecessors.\n  for (Edge edge : branch_true->use_edges()) {\n    edge.UpdateTo(predecessor_true);\n  }\n  for (Edge edge : branch_false->use_edges()) {\n    edge.UpdateTo(predecessor_false);\n  }\n\n  branch_true->Kill();\n  branch_false->Kill();\n  branch->Kill();\n  phi->Kill();\n  merge->Kill();\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceBranch\",\n            \"parent\": \"BranchElimination\",\n            \"about\": \"Reduces a branch node by attempting to eliminate it based on known conditions or by simplifying its condition.\",\n            \"logic\": \"This function first checks if the branch condition is already known from the control path. If so, it replaces the IfTrue/IfFalse projections with the appropriate control path. If the condition is not known, it attempts to simplify the branch condition or eliminate the branch if it's part of a specific pattern involving a phi node and a merge node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The branch node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction, indicating whether the branch was changed or replaced.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"GetState\",\n                \"BranchCondition\",\n                \"LookupState\",\n                \"Replace\",\n                \"dead_\",\n                \"SimplifyBranchCondition\",\n                \"TryEliminateBranchWithPhiCondition\",\n                \"Revisit\",\n                \"TakeStatesFromFirstControl\"\n            ]\n"
}