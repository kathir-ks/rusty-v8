{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler-dispatcher/optimizing-compile-dispatcher.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler-dispatcher/optimizing-compile-dispatcher.cc\",\n        \"file_name\": \"optimizing-compile-dispatcher.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the optimizing compilation dispatcher, which manages the queueing and execution of Turbofan compilation jobs.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for concurrency, logging, compilation, and other V8 functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler-dispatcher/optimizing-compile-dispatcher.h\"\n\n#include \"src/base/atomicops.h\"\n#include \"src/base/fpu.h\"\n#include \"src/base/logging.h\"\n#include \"src/base/platform/mutex.h\"\n#include \"src/base/vector.h\"\n#include \"src/codegen/compiler.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/execution/local-isolate-inl.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/heap/local-heap-inl.h\"\n#include \"src/init/v8.h\"\n#include \"src/logging/counters.h\"\n#include \"src/logging/log.h\"\n#include \"src/logging/runtime-call-stats-scope.h\"\n#include \"src/objects/js-function.h\"\n#include \"src/tasks/cancelable-task.h\"\n#include \"src/tracing/trace-event.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OptimizingCompileTaskExecutor::CompileTask\",\n            \"extends\": \"v8::JobTask\",\n            \"about\": \"Represents a task that executes Turbofan compilation jobs in a background thread.\",\n            \"attributes\": [\n                {\n                    \"name\": \"task_executor_\",\n                    \"type\": \"OptimizingCompileTaskExecutor*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the associated task executor.\"\n                }\n            ],\n            \"dependencies\": [\n                \"OptimizingCompileTaskExecutor\",\n                \"v8::JobTask\",\n                \"TurbofanCompilationJob\",\n                \"OptimizingCompileTaskState\",\n                \"Isolate\",\n                \"LocalIsolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass OptimizingCompileTaskExecutor::CompileTask : public v8::JobTask {\n public:\n  explicit CompileTask(OptimizingCompileTaskExecutor* task_executor)\n      : task_executor_(task_executor) {}\n\n  void Run(JobDelegate* delegate) override {\n    TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.compile\"), \"V8.TurbofanTask\");\n    DCHECK_LT(delegate->GetTaskId(), task_executor_->task_states_.size());\n    OptimizingCompileTaskState& task_state =\n        task_executor_->task_states_[delegate->GetTaskId()];\n    bool should_yield = delegate->ShouldYield();\n\n    while (!should_yield) {\n      // NextInput() sets the isolate for task_state to job->isolate() while\n      // holding the lock.\n      TurbofanCompilationJob* job = task_executor_->NextInput(task_state);\n      if (!job) break;\n\n      Isolate* const isolate = job->isolate();\n\n      {\n        base::FlushDenormalsScope flush_denormals_scope(\n            isolate->flush_denormals());\n\n        // Note that LocalIsolate's lifetime is shorter than the isolate value\n        // in task_state which is only cleared after this LocalIsolate instance\n        // was destroyed.\n        LocalIsolate local_isolate(isolate, ThreadKind::kBackground);\n        DCHECK(local_isolate.heap()->IsParked());\n\n        do {\n          RunCompilationJob(isolate, local_isolate, job);\n\n          should_yield = delegate->ShouldYield();\n          if (should_yield) break;\n\n          // Reuse the LocalIsolate if the next worklist item has the same\n          // isolate.\n          job = task_executor_->NextInputIfIsolateMatches(isolate);\n        } while (job);\n      }\n\n      // Reset the isolate in the task state to nullptr. Only do this after the\n      // LocalIsolate was destroyed. This invariant is used by\n      // WaitUntilTasksStoppedForIsolate() to ensure all tasks are stopped for\n      // an isolate.\n      task_executor_->ClearTaskState(task_state);\n    }\n\n    // Here we are allowed to read the isolate without holding a lock because\n    // only this thread here will ever change this field and the main thread\n    // will only ever read it.\n    DCHECK_NULL(task_state.isolate);\n  }\n\n  void RunCompilationJob(Isolate* isolate, LocalIsolate& local_isolate,\n                         TurbofanCompilationJob* job) {\n    TRACE_EVENT_WITH_FLOW0(\n        TRACE_DISABLED_BY_DEFAULT(\"v8.compile\"), \"V8.OptimizeBackground\",\n        job->trace_id(), TRACE_EVENT_FLAG_FLOW_IN | TRACE_EVENT_FLAG_FLOW_OUT);\n    TimerEventScope<TimerEventRecompileConcurrent> timer(isolate);\n\n    if (task_executor_->recompilation_delay_ != 0) {\n      base::OS::Sleep(base::TimeDelta::FromMilliseconds(\n          task_executor_->recompilation_delay_));\n    }\n\n    RCS_SCOPE(&local_isolate,\n              RuntimeCallCounterId::kOptimizeBackgroundTurbofan);\n\n    task_executor_->CompileNext(isolate, local_isolate, job);\n  }\n\n  size_t GetMaxConcurrency(size_t worker_count) const override {\n    size_t num_tasks = task_executor_->input_queue_.Length() + worker_count;\n    return std::min(num_tasks, task_executor_->task_states_.size());\n  }\n\n private:\n  OptimizingCompileTaskExecutor* task_executor_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OptimizingCompileTaskExecutor\",\n            \"about\": \"Manages the execution of optimizing compilation tasks, including queueing jobs and dispatching them to background threads.\",\n            \"attributes\": [\n                {\n                    \"name\": \"input_queue_\",\n                    \"type\": \"OptimizingCompileInputQueue\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Queue of Turbofan compilation jobs waiting to be executed.\"\n                },\n                {\n                    \"name\": \"recompilation_delay_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Delay (in milliseconds) before starting recompilation.\"\n                },\n                {\n                    \"name\": \"task_states_\",\n                    \"type\": \"base::OwnedVector<OptimizingCompileTaskState>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of task states, one for each background compilation task.\"\n                },\n                {\n                    \"name\": \"job_handle_\",\n                    \"type\": \"std::unique_ptr<JobHandle>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Handle to the background compilation job.\"\n                },\n                {\n                    \"name\": \"is_initialized_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the executor has been initialized.\"\n                }\n            ],\n            \"dependencies\": [\n                \"OptimizingCompileInputQueue\",\n                \"TurbofanCompilationJob\",\n                \"OptimizingCompileTaskState\",\n                \"Isolate\",\n                \"LocalIsolate\",\n                \"V8\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nOptimizingCompileTaskExecutor::OptimizingCompileTaskExecutor()\n    : input_queue_(v8_flags.concurrent_recompilation_queue_length),\n      recompilation_delay_(v8_flags.concurrent_recompilation_delay) {}\n\nOptimizingCompileTaskExecutor::~OptimizingCompileTaskExecutor() {\n  DCHECK_EQ(input_queue_.Length(), 0);\n\n  if (job_handle_) {\n    DCHECK(job_handle_->IsValid());\n\n    // Wait for the job handle to complete, so that we know the queue\n    // pointers are safe.\n    job_handle_->Cancel();\n  }\n}\n\nvoid OptimizingCompileTaskExecutor::EnsureInitialized() {\n  if (is_initialized_) return;\n  is_initialized_ = true;\n\n  if (v8_flags.concurrent_recompilation ||\n      v8_flags.concurrent_builtin_generation) {\n    int max_tasks;\n\n    if (v8_flags.concurrent_turbofan_max_threads == 0) {\n      max_tasks = V8::GetCurrentPlatform()->NumberOfWorkerThreads();\n    } else {\n      max_tasks = v8_flags.concurrent_turbofan_max_threads;\n    }\n\n    task_states_ =\n        base::OwnedVector<OptimizingCompileTaskState>::New(max_tasks);\n    job_handle_ = V8::GetCurrentPlatform()->PostJob(\n        kTaskPriority, std::make_unique<CompileTask>(this));\n  }\n}\n\nTurbofanCompilationJob* OptimizingCompileTaskExecutor::NextInput(\n    OptimizingCompileTaskState& task_state) {\n  return input_queue_.Dequeue(task_state);\n}\n\nTurbofanCompilationJob*\nOptimizingCompileTaskExecutor::NextInputIfIsolateMatches(Isolate* isolate) {\n  return input_queue_.DequeueIfIsolateMatches(isolate);\n}\n\nvoid OptimizingCompileTaskExecutor::CompileNext(Isolate* isolate,\n                                                LocalIsolate& local_isolate,\n                                                TurbofanCompilationJob* job) {\n  DCHECK_NOT_NULL(job);\n\n  // The function may have already been optimized by OSR.  Simply continue.\n  CompilationJob::Status status =\n      job->ExecuteJob(local_isolate.runtime_call_stats(), &local_isolate);\n  USE(status);  // Prevent an unused-variable error.\n\n  isolate->optimizing_compile_dispatcher()->QueueFinishedJob(job);\n}\n\nbool OptimizingCompileTaskExecutor::IsTaskRunningForIsolate(Isolate* isolate) {\n  input_queue_.mutex_.AssertHeld();\n\n  for (auto& task_state : task_states_) {\n    if (task_state.isolate == isolate) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool OptimizingCompileTaskExecutor::HasCompilationJobsForIsolate(\n    Isolate* isolate) {\n  base::MutexGuard guard(input_queue_.mutex_);\n  return input_queue_.HasJobForIsolate(isolate) ||\n         IsTaskRunningForIsolate(isolate);\n}\n\nvoid OptimizingCompileTaskExecutor::ClearTaskState(\n    OptimizingCompileTaskState& task_state) {\n  base::MutexGuard guard(input_queue_.mutex_);\n  DCHECK_NOT_NULL(task_state.isolate);\n  task_state.isolate = nullptr;\n  input_queue_.task_finished_.NotifyAll();\n}\n\nbool OptimizingCompileTaskExecutor::TryQueueForOptimization(\n    std::unique_ptr<TurbofanCompilationJob>& job) {\n  Isolate* isolate = job->isolate();\n  DCHECK_NOT_NULL(isolate);\n\n  if (input_queue_.Enqueue(job)) {\n    if (job_handle_->UpdatePriorityEnabled()) {\n      job_handle_->UpdatePriority(isolate->EfficiencyModeEnabledForTiering()\n                                      ? kEfficiencyTaskPriority\n                                      : kTaskPriority);\n    }\n    job_handle_->NotifyConcurrencyIncrease();\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid OptimizingCompileTaskExecutor::WaitUntilCompilationJobsDoneForIsolate(\n    Isolate* isolate) {\n  // Once we have ensured that no task is working on the given isolate, we also\n  // know that there are no more LocalHeaps for this isolate from CompileTask.\n  // This is because CompileTask::Run() only updates the isolate once the\n  // LocalIsolate/LocalHeap for it was destroyed.\n  base::MutexGuard guard(&input_queue_.mutex_);\n\n  while (input_queue_.HasJobForIsolate(isolate) ||\n         IsTaskRunningForIsolate(isolate)) {\n    input_queue_.task_finished_.Wait(&input_queue_.mutex_);\n  }\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OptimizingCompileDispatcher\",\n            \"about\": \"Dispatches finished Turbofan compilation jobs and manages the output queue.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the isolate.\"\n                },\n                {\n                    \"name\": \"task_executor_\",\n                    \"type\": \"OptimizingCompileTaskExecutor*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the task executor.\"\n                },\n                {\n                    \"name\": \"output_queue_\",\n                    \"type\": \"OptimizingCompileOutputQueue\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Queue of finished Turbofan compilation jobs.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TurbofanCompilationJob\",\n                \"OptimizingCompileTaskExecutor\",\n                \"OptimizingCompileOutputQueue\",\n                \"Isolate\",\n                \"OptimizedCompilationInfo\",\n                \"JSFunction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nOptimizingCompileDispatcher::OptimizingCompileDispatcher(\n    Isolate* isolate, OptimizingCompileTaskExecutor* task_executor)\n    : isolate_(isolate), task_executor_(task_executor) {}\n\nOptimizingCompileDispatcher::~OptimizingCompileDispatcher() {\n  DCHECK_EQ(output_queue_.size(), 0);\n}\n\nvoid OptimizingCompileDispatcher::QueueFinishedJob(\n    TurbofanCompilationJob* job) {\n  DCHECK_EQ(isolate_, job->isolate());\n  output_queue_.Enqueue(job);\n  if (finalize()) isolate_->stack_guard()->RequestInstallCode();\n}\n\nvoid OptimizingCompileDispatcher::FlushOutputQueue() {\n  for (;;) {\n    std::unique_ptr<TurbofanCompilationJob> job = output_queue_.Dequeue();\n    if (!job) break;\n    Compiler::DisposeTurbofanCompilationJob(isolate_, job.get());\n  }\n}\n\nvoid OptimizingCompileDispatcher::FinishTearDown() {\n  task_executor_->WaitUntilCompilationJobsDoneForIsolate(isolate_);\n\n  HandleScope handle_scope(isolate_);\n  FlushOutputQueue();\n}\n\nvoid OptimizingCompileDispatcher::FlushInputQueue() {\n  input_queue().FlushJobsForIsolate(isolate_);\n}\n\nvoid OptimizingCompileDispatcher::WaitUntilCompilationJobsDone() {\n  AllowGarbageCollection allow_before_parking;\n  isolate_->main_thread_local_isolate()->ExecuteMainThreadWhileParked([this]() {\n    task_executor_->WaitUntilCompilationJobsDoneForIsolate(isolate_);\n  });\n}\n\nvoid OptimizingCompileDispatcher::FlushQueues(\n    BlockingBehavior blocking_behavior) {\n  FlushInputQueue();\n  if (blocking_behavior == BlockingBehavior::kBlock) {\n    WaitUntilCompilationJobsDone();\n  }\n  FlushOutputQueue();\n}\n\nvoid OptimizingCompileDispatcher::Flush(BlockingBehavior blocking_behavior) {\n  HandleScope handle_scope(isolate_);\n  FlushQueues(blocking_behavior);\n  if (v8_flags.trace_concurrent_recompilation) {\n    PrintF(\"  ** Flushed concurrent recompilation queues. (mode: %s)\\n\",\n           (blocking_behavior == BlockingBehavior::kBlock) ? \"blocking\"\n                                                           : \"non blocking\");\n  }\n}\n\nvoid OptimizingCompileDispatcher::StartTearDown() {\n  HandleScope handle_scope(isolate_);\n  FlushInputQueue();\n}\n\nvoid OptimizingCompileDispatcher::InstallOptimizedFunctions() {\n  HandleScope handle_scope(isolate_);\n\n  for (;;) {\n    std::unique_ptr<TurbofanCompilationJob> job = output_queue_.Dequeue();\n    if (!job) break;\n\n    OptimizedCompilationInfo* info = job->compilation_info();\n    DirectHandle<JSFunction> function(*info->closure(), isolate_);\n\n    // If another racing task has already finished compiling and installing the\n    // requested code kind on the function, throw out the current job.\n    if (!info->is_osr() &&\n        function->HasAvailableCodeKind(isolate_, info->code_kind())) {\n      if (v8_flags.trace_concurrent_recompilation) {\n        PrintF(\"  ** Aborting compilation for \");\n        ShortPrint(*function);\n        PrintF(\" as it has already been optimized.\\n\");\n      }\n      Compiler::DisposeTurbofanCompilationJob(isolate_, job.get());\n      continue;\n    }\n    // Discard code compiled for a discarded native context without\n    // finalization.\n    if (function->native_context()->global_object()->IsDetached()) {\n      Compiler::DisposeTurbofanCompilationJob(isolate_, job.get());\n      continue;\n    }\n\n    Compiler::FinalizeTurbofanCompilationJob(job.get(), isolate_);\n  }\n}\n\nint OptimizingCompileDispatcher::InstallGeneratedBuiltins(int installed_count) {\n  return output_queue_.InstallGeneratedBuiltins(isolate_, installed_count);\n}\n\nbool OptimizingCompileDispatcher::HasJobs() {\n  DCHECK_EQ(ThreadId::Current(), isolate_->thread_id());\n  if (task_executor_->HasCompilationJobsForIsolate(isolate_)) {\n    return true;\n  }\n\n  return !output_queue_.empty();\n}\n\nbool OptimizingCompileDispatcher::TryQueueForOptimization(\n    std::unique_ptr<TurbofanCompilationJob>& job) {\n  return task_executor_->TryQueueForOptimization(job);\n}\n\nvoid OptimizingCompileDispatcher::Prioritize(\n    Tagged<SharedFunctionInfo> function) {\n  input_queue().Prioritize(isolate_, function);\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OptimizingCompileInputQueue\",\n            \"about\": \"Represents the input queue for Turbofan compilation jobs, managing the order and prioritization of jobs.\",\n            \"attributes\": [\n                {\n                    \"name\": \"queue_\",\n                    \"type\": \"std::deque<TurbofanCompilationJob*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Deque holding the Turbofan compilation jobs.\"\n                },\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mutex to protect access to the queue.\"\n                },\n                {\n                    \"name\": \"task_finished_\",\n                    \"type\": \"base::ConditionVariable\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Condition variable to signal when a task has finished.\"\n                },\n                {\n                    \"name\": \"capacity_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maximum capacity of the queue.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TurbofanCompilationJob\",\n                \"Isolate\",\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid OptimizingCompileInputQueue::Prioritize(\n    Isolate* isolate, Tagged<SharedFunctionInfo> function) {\n  // Ensure that we only run this method on the main thread. This makes sure\n  // that we never dereference handles during a safepoint.\n  DCHECK_EQ(isolate->thread_id(), ThreadId::Current());\n  base::MutexGuard access(&mutex_);\n  auto it =\n      std::find_if(queue_.begin(), queue_.end(),\n                   [isolate, function](TurbofanCompilationJob* job) {\n                     // Early bailout to avoid dereferencing handles from other\n                     // isolates. The other isolate could be in a safepoint/GC\n                     // and dereferencing the handle is therefore invalid.\n                     if (job->isolate() != isolate) return false;\n                     return *job->compilation_info()->shared_info() == function;\n                   });\n\n  if (it != queue_.end()) {\n    auto first_for_isolate = std::find_if(\n        queue_.begin(), queue_.end(), [isolate](TurbofanCompilationJob* job) {\n          return job->isolate() == isolate;\n        });\n    DCHECK_NE(first_for_isolate, queue_.end());\n    std::iter_swap(it, first_for_isolate);\n  }\n}\n\nvoid OptimizingCompileInputQueue::FlushJobsForIsolate(Isolate* isolate) {\n  base::MutexGuard access(&mutex_);\n  std::erase_if(queue_, [isolate](TurbofanCompilationJob* job) {\n    if (job->isolate() != isolate) return false;\n    Compiler::DisposeTurbofanCompilationJob(isolate, job);\n    delete job;\n    return true;\n  });\n}\n\nbool OptimizingCompileInputQueue::HasJobForIsolate(Isolate* isolate) {\n  mutex_.AssertHeld();\n  return std::find_if(queue_.begin(), queue_.end(),\n                      [isolate](TurbofanCompilationJob* job) {\n                        return job->isolate() == isolate;\n                      }) != queue_.end();\n}\n\nTurbofanCompilationJob* OptimizingCompileInputQueue::Dequeue(\n    OptimizingCompileTaskState& task_state) {\n  base::MutexGuard access(&mutex_);\n  DCHECK_NULL(task_state.isolate);\n  if (queue_.empty()) return nullptr;\n  TurbofanCompilationJob* job = queue_.front();\n  queue_.pop_front();\n  DCHECK_NOT_NULL(job);\n  task_state.isolate = job->isolate();\n  return job;\n}\n\nTurbofanCompilationJob* OptimizingCompileInputQueue::DequeueIfIsolateMatches(\n    Isolate* isolate) {\n  base::MutexGuard access(&mutex_);\n  if (queue_.empty()) return nullptr;\n  TurbofanCompilationJob* job = queue_.front();\n  DCHECK_NOT_NULL(job);\n  if (job->isolate() != isolate) return nullptr;\n  queue_.pop_front();\n  return job;\n}\n\nbool OptimizingCompileInputQueue::Enqueue(\n    std::unique_ptr<TurbofanCompilationJob>& job) {\n  base::MutexGuard access(&mutex_);\n  if (queue_.size() < capacity_) {\n    queue_.push_back(job.release());\n    return true;\n  } else {\n    return false;\n  }\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OptimizingCompileOutputQueue\",\n            \"about\": \"Represents the output queue for finished Turbofan compilation jobs, managing the order and finalization of jobs.\",\n            \"attributes\": [\n                {\n                    \"name\": \"queue_\",\n                    \"type\": \"std::deque<TurbofanCompilationJob*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Deque holding the Turbofan compilation jobs.\"\n                },\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mutex to protect access to the queue.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TurbofanCompilationJob\",\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid OptimizingCompileOutputQueue::Enqueue(TurbofanCompilationJob* job) {\n  base::MutexGuard guard(&mutex_);\n  queue_.push_back(job);\n}\n\nstd::unique_ptr<TurbofanCompilationJob>\nOptimizingCompileOutputQueue::Dequeue() {\n  base::MutexGuard guard(&mutex_);\n  if (queue_.empty()) return {};\n  std::unique_ptr<TurbofanCompilationJob> job(queue_.front());\n  queue_.pop_front();\n  return job;\n}\n\nsize_t OptimizingCompileOutputQueue::size() const { return queue_.size(); }\n\nbool OptimizingCompileOutputQueue::empty() const { return queue_.empty(); }\n\nint OptimizingCompileOutputQueue::InstallGeneratedBuiltins(\n    Isolate* isolate, int installed_count) {\n  // Builtin generation needs to be deterministic, meaning heap allocations must\n  // happen in a deterministic order. To ensure determinism with concurrent\n  // compilation, only finalize contiguous builtins in ascending order of their\n  // finalization order, which is set at job creation time.\n\n  CHECK(isolate->IsGeneratingEmbeddedBuiltins());\n\n  base::MutexGuard guard(&mutex_);\n\n  std::sort(queue_.begin(), queue_.end(),\n            [](const TurbofanCompilationJob* job1,\n               const TurbofanCompilationJob* job2) {\n              return job1->FinalizeOrder() < job2->FinalizeOrder();\n            });\n\n  while (!queue_.empty()) {\n    int current = queue_.front()->FinalizeOrder();\n    CHECK_EQ(installed_count, current);\n    std::unique_ptr<TurbofanCompilationJob> job(queue_.front());\n    queue_.pop_front();\n    CHECK_EQ(CompilationJob::SUCCEEDED, job->FinalizeJob(isolate));\n    installed_count = current + 1;\n  }\n  return installed_count;\n}\n        ]]></code>\n    </class>\n    \n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OptimizingCompileTaskState\",\n                \"about\": \"Represents the state of an optimizing compilation task.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The isolate associated with the compilation task.\"\n                    }\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n                struct OptimizingCompileTaskState {\n                    Isolate* isolate = nullptr;\n                };\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TurbofanCompilationJob\",\n                \"about\": \"Represents a compilation job for Turbofan.\",\n                \"attributes\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class TurbofanCompilationJob {\n                public:\n                    Isolate* isolate() {return nullptr;}\n                    int FinalizeOrder() const {return 0;}\n                    CompilationJob::Status FinalizeJob(Isolate* isolate) {return CompilationJob::Status::SUCCEEDED;}\n                    OptimizedCompilationInfo* compilation_info() {return nullptr;}\n                    uint64_t trace_id() {return 0;}\n                    CompilationJob::Status ExecuteJob(RuntimeCallStats* rcs, LocalIsolate* local_isolate) {return CompilationJob::Status::SUCCEEDED;}\n                };\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CompilationJob\",\n                \"about\": \"Base class for compilation jobs.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class CompilationJob {\n                    public:\n                        enum Status {\n                            SUCCEEDED\n                        };\n                };\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {\n                    public:\n                    class StackGuard {\n                        public:\n                        void RequestInstallCode(){}\n                    };\n                    StackGuard* stack_guard(){return nullptr;}\n                    internal::OptimizingCompileDispatcher* optimizing_compile_dispatcher(){return nullptr;}\n                    void RegisterEmbeddedBuiltins(){}\n                    bool IsGeneratingEmbeddedBuiltins() {return false;}\n                    ThreadId thread_id(){ return ThreadId::Invalid();}\n                    LocalIsolate* main_thread_local_isolate(){return nullptr;}\n                    bool EfficiencyModeEnabledForTiering(){return false;}\n                    base::Flags::FlushDenormalsMode flush_denormals() { return base::Flags::FlushDenormalsMode::kNoFlush; }\n                };\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalIsolate\",\n                \"about\": \"Represents a local isolate for background compilation.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class LocalIsolate {\n                public:\n                    explicit LocalIsolate(Isolate* isolate, ThreadKind kind){}\n                    RuntimeCallStats* runtime_call_stats(){return nullptr;}\n                    internal::LocalHeap* heap(){return nullptr;}\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ThreadKind\",\n                \"about\": \"Enum representing the kind of thread.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                enum class ThreadKind { kBackground };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RuntimeCallStats\",\n                \"about\": \"Statistics for runtime calls.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class RuntimeCallStats {};\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OptimizedCompilationInfo\",\n                \"about\": \"Information about optimized compilation.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class OptimizedCompilationInfo {\n                public:\n                    Tagged<SharedFunctionInfo>* shared_info() {return nullptr;}\n                    Tagged<JSFunction>* closure() {return nullptr;}\n                    bool is_osr() {return false;}\n                    int code_kind() { return 0;}\n                };\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SharedFunctionInfo\",\n                \"about\": \"Information about a shared function.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class SharedFunctionInfo {};\n            ]]></code>\n        </class>\n        \n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSFunction\",\n                \"about\": \"Represents a JavaScript Function.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class JSFunction {\n                public:\n                    bool HasAvailableCodeKind(Isolate* isolate, int code_kind) {return false;}\n                    Tagged<NativeContext> native_context(){return NativeContext();}\n                };\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NativeContext\",\n                \"about\": \"Represents a Native Context.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class NativeContext {\n                public:\n                  Tagged<GlobalObject> global_object(){return GlobalObject();}\n                };\n            ]]></code>\n        </class>\n         <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GlobalObject\",\n                \"about\": \"Represents a Global Object.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class GlobalObject {\n                public:\n                  bool IsDetached(){return false;}\n                };\n            ]]></code>\n        </class>\n         <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Tagged\",\n                \"about\": \"Represents a Tagged Object.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template<typename T>\n                class Tagged {\n                 public:\n                    bool operator==(const T& other) const { return false;}\n                };\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"V8\",\n                \"about\": \"The V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class V8 {\n                    public:\n                    static platform::Platform* GetCurrentPlatform(){return nullptr;}\n                };\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"platform::Platform\",\n                \"about\": \"Interface for platform specific functionality.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace platform {\n                    class Platform {\n                        public:\n                        virtual int NumberOfWorkerThreads() {return 1;}\n                        virtual std::unique_ptr<JobHandle> PostJob(TaskPriority priority, std::unique_ptr<v8::JobTask> job) { return nullptr;}\n                    };\n                }\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"v8::JobTask\",\n                \"about\": \"Abstract base class for job tasks.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 {\n                    class JobTask {\n                    public:\n                        virtual ~JobTask() = default;\n                    };\n                }\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"TaskPriority\",\n                \"about\": \"Enum for Task Priorities\"\n            }\n            </metadata>\n            <code><![CDATA[\n                enum class TaskPriority {k"
}