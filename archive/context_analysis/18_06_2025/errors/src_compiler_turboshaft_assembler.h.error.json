{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/assembler.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/assembler.h\",\n        \"file_name\": \"assembler.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Assembler class for the Turboshaft compiler, providing a high-level interface for constructing the intermediate representation (IR) graph.  It includes various utilities for generating code, managing control flow, and performing common operations.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard C++ library headers providing various functionalities like string manipulation, input/output, containers, and utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <cstring>\n            #include <iomanip>\n            #include <iterator>\n            #include <limits>\n            #include <memory>\n            #include <optional>\n            #include <type_traits>\n            #include <utility>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"V8-specific headers for source location, logging, macros, small vectors, string formatting, template utilities, vectors, code generation, heap object lists, relocation info, compiler access builders, code assemblers, common operators, global settings, JS heap broker, simplified operators, turboshaft-specific access builders, builtin/runtime call descriptors, graph representation, index utilities, operation matching, operation definitions, phase management, reducer traits, sidetable management, snapshot table management, uniform reducer adapters, utilities, write barrier kinds, flag definitions, runtime call stats, object definitions, tagged values, turbofan types, and primitive value definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"include/v8-source-location.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/base/macros.h\"\n            #include \"src/base/small-vector.h\"\n            #include \"src/base/string-format.h\"\n            #include \"src/base/template-utils.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/codegen/callable.h\"\n            #include \"src/codegen/code-factory.h\"\n            #include \"src/codegen/heap-object-list.h\"\n            #include \"src/codegen/reloc-info.h\"\n            #include \"src/compiler/access-builder.h\"\n            #include \"src/compiler/code-assembler.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/globals.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/simplified-operator.h\"\n            #include \"src/compiler/turboshaft/access-builder.h\"\n            #include \"src/compiler/turboshaft/builtin-call-descriptors.h\"\n            #include \"src/compiler/turboshaft/graph.h\"\n            #include \"src/compiler/turboshaft/index.h\"\n            #include \"src/compiler/turboshaft/operation-matcher.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/phase.h\"\n            #include \"src/compiler/turboshaft/reducer-traits.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n            #include \"src/compiler/turboshaft/runtime-call-descriptors.h\"\n            #include \"src/compiler/turboshaft/sidetable.h\"\n            #include \"src/compiler/turboshaft/snapshot-table.h\"\n            #include \"src/compiler/turboshaft/uniform-reducer-adapter.h\"\n            #include \"src/compiler/turboshaft/utils.h\"\n            #include \"src/compiler/write-barrier-kind.h\"\n            #include \"src/flags/flags.h\"\n            #include \"src/logging/runtime-call-stats.h\"\n            #include \"src/objects/dictionary.h\"\n            #include \"src/objects/elements-kind.h\"\n            #include \"src/objects/fixed-array.h\"\n            #include \"src/objects/heap-number.h\"\n            #include \"src/objects/oddball.h\"\n            #include \"src/objects/property-cell.h\"\n            #include \"src/objects/scope-info.h\"\n            #include \"src/objects/swiss-name-dictionary.h\"\n            #include \"src/objects/tagged.h\"\n            #include \"src/objects/turbofan-types.h\"\n            #include \"v8-primitive.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"WebAssembly support (conditionally compiled).\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_ENABLE_WEBASSEMBLY\n            #include \"src/wasm/wasm-objects.h\"\n            #endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Range\",\n            \"about\": \"Implements the ForeachIterable concept to iterate over a range of values inside a FOREACH loop.\",\n            \"attributes\": [\n                {\n                    \"name\": \"begin_\",\n                    \"type\": \"ConstOrV<T>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Starting value of the range.\"\n                },\n                {\n                    \"name\": \"end_\",\n                    \"type\": \"ConstOrV<T>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Exclusive end value of the range.\"\n                },\n                {\n                    \"name\": \"stride_\",\n                    \"type\": \"ConstOrV<T>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Increment value for each iteration.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ForeachIterable\",\n                \"ConstOrV\",\n                \"V\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class Range {\n            public:\n            using value_type = V<T>;\n            using iterator_type = value_type;\n\n            Range(ConstOrV<T> begin, ConstOrV<T> end, ConstOrV<T> stride = 1)\n                : begin_(begin), end_(end), stride_(stride) {}\n\n            template <typename A>\n            iterator_type Begin(A& assembler) const {\n                return assembler.resolve(begin_);\n            }\n\n            template <typename A>\n            OptionalV<Word32> IsEnd(A& assembler, iterator_type current_iterator) const {\n                if constexpr (std::is_same_v<T, Word32>) {\n                return assembler.Uint32LessThanOrEqual(assembler.resolve(end_),\n                                                        current_iterator);\n                } else {\n                static_assert(std::is_same_v<T, Word64>);\n                return assembler.Uint64LessThanOrEqual(assembler.resolve(end_),\n                                                        current_iterator);\n                }\n            }\n\n            template <typename A>\n            iterator_type Advance(A& assembler, iterator_type current_iterator) const {\n                if constexpr (std::is_same_v<T, Word32>) {\n                return assembler.Word32Add(current_iterator, assembler.resolve(stride_));\n                } else {\n                static_assert(std::is_same_v<T, Word64>);\n                return assembler.Word64Add(current_iterator, assembler.resolve(stride_));\n                }\n            }\n\n            template <typename A>\n            value_type Dereference(A& assembler, iterator_type current_iterator) const {\n                return current_iterator;\n            }\n\n            private:\n            ConstOrV<T> begin_;\n            ConstOrV<T> end_;\n            ConstOrV<T> stride_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IndexRange\",\n            \"extends\": \"Range<T>\",\n            \"about\": \"A short hand for a Range<T> that iterates the range [0, count) with steps of 1.\",\n            \"dependencies\": [\n                \"Range\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class IndexRange : public Range<T> {\n            public:\n            using base = Range<T>;\n            using value_type = base::value_type;\n            using iterator_type = base::iterator_type;\n\n            explicit IndexRange(ConstOrV<T> count) : Range<T>(0, count, 1) {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Sequence\",\n            \"extends\": \"Range<T>\",\n            \"about\": \"Implements the `ForeachIterable` concept to iterate an unlimited sequence of inside a `FOREACH` loop.\",\n            \"dependencies\": [\n                \"Range\",\n                \"ForeachIterable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class Sequence : private Range<T> {\n            using base = Range<T>;\n\n            public:\n            using value_type = base::value_type;\n            using iterator_type = base::iterator_type;\n\n            explicit Sequence(ConstOrV<T> begin, ConstOrV<T> stride = 1)\n                : base(begin, 0, stride) {}\n\n            using base::Advance;\n            using base::Begin;\n            using base::Dereference;\n\n            template <typename A>\n            OptionalV<Word32> IsEnd(A&, iterator_type) const {\n                // Sequence doesn't have a termination condition.\n                return OptionalV<Word32>::Nullopt();\n            }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Zip\",\n            \"about\": \"Implements the `ForeachIterable` concept to iterate multiple iterators at the same time inside a `FOREACH` loop.\",\n            \"attributes\": [\n                {\n                    \"name\": \"iterables_\",\n                    \"type\": \"std::tuple<Iterables...>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the iterables being zipped.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ForeachIterable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename... Iterables>\n            class Zip {\n            public:\n            using value_type = std::tuple<typename Iterables::value_type...>;\n            using iterator_type = std::tuple<typename Iterables::iterator_type...>;\n\n            explicit Zip(Iterables... iterables) : iterables_(std::move(iterables)...) {}\n\n            template <typename A>\n            iterator_type Begin(A& assembler) {\n                return base::tuple_map(\n                    iterables_, [&assembler](auto& it) { return it.Begin(assembler); });\n            }\n\n            template <typename A>\n            OptionalV<Word32> IsEnd(A& assembler, iterator_type current_iterator) {\n                // TODO(nicohartmann): Currently we don't short-circuit the disjunction here\n                // because that's slightly more difficult to do with the current `IsEnd`\n                // predicate. We can consider making this more powerful if we see use cases.\n                auto results = base::tuple_map2(iterables_, current_iterator,\n                                                [&assembler](auto& it, auto current) {\n                                                return it.IsEnd(assembler, current);\n                                                });\n                return base::tuple_fold(\n                    OptionalV<Word32>::Nullopt(), results,\n                    [&assembler](OptionalV<Word32> acc, OptionalV<Word32> next) {\n                    if (!next.has_value()) return acc;\n                    if (!acc.has_value()) return next;\n                    return OptionalV(\n                        assembler.Word32BitwiseOr(acc.value(), next.value()));\n                    });\n            }\n\n            template <typename A>\n            iterator_type Advance(A& assembler, iterator_type current_iterator) {\n                return base::tuple_map2(iterables_, current_iterator,\n                                        [&assembler](auto& it, auto current) {\n                                            return it.Advance(assembler, current);\n                                        });\n            }\n\n            template <typename A>\n            value_type Dereference(A& assembler, iterator_type current_iterator) {\n                return base::tuple_map2(iterables_, current_iterator,\n                                        [&assembler](auto& it, auto current) {\n                                            return it.Dereference(assembler, current);\n                                        });\n            }\n\n            private:\n            std::tuple<Iterables...> iterables_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ConditionWithHint\",\n            \"about\": \"Represents a condition along with a branch hint for the compiler.\",\n            \"attributes\": [\n                {\n                    \"name\": \"condition_\",\n                    \"type\": \"V<Word32>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The condition to be evaluated.\"\n                },\n                {\n                    \"name\": \"hint_\",\n                    \"type\": \"BranchHint\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Hint to guide branch prediction.\"\n                }\n            ],\n            \"dependencies\": [\n                \"V\",\n                \"BranchHint\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ConditionWithHint final {\n            public:\n            ConditionWithHint(\n                V<Word32> condition,\n                BranchHint hint = BranchHint::kNone)  // NOLINT(runtime/explicit)\n                : condition_(condition), hint_(hint) {}\n\n            template <typename T>\n            ConditionWithHint(\n                T condition,\n                BranchHint hint = BranchHint::kNone)  // NOLINT(runtime/explicit)\n                requires(std::is_same_v<T, OpIndex>)\n                : ConditionWithHint(V<Word32>{condition}, hint) {}\n\n            V<Word32> condition() const { return condition_; }\n            BranchHint hint() const { return hint_; }\n\n            private:\n            V<Word32> condition_;\n            BranchHint hint_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LabelBase\",\n            \"about\": \"Base class for labels used in control flow within the assembler.  Handles block management and value recording for phi nodes.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Block\",\n                \"V\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <bool loop, typename... Ts>\n            class LabelBase {\n            protected:\n            static constexpr size_t size = sizeof...(Ts);\n\n            LabelBase(const LabelBase&) = delete;\n            LabelBase& operator=(const LabelBase&) = delete;\n\n            public:\n            static constexpr bool is_loop = loop;\n            using values_t = std::tuple<V<Ts>...>;\n            using const_or_values_t = std::tuple<maybe_const_or_v_t<Ts>...>;\n            using recorded_values_t = std::tuple<base::SmallVector<V<Ts>, 2>...>;\n\n            Block* block() { return data_.block; }\n\n            bool has_incoming_jump() const { return has_incoming_jump_; }\n\n            template <typename A>\n            void Goto(A& assembler, const values_t& values) {\n                if (assembler.generating_unreachable_operations()) return;\n                has_incoming_jump_ = true;\n                Block* current_block = assembler.current_block();\n                DCHECK_NOT_NULL(current_block);\n                assembler.Goto(data_.block);\n                RecordValues(current_block, data_, values);\n            }\n\n            template <typename A>\n            void GotoIf(A& assembler, OpIndex condition, BranchHint hint,\n                        const values_t& values) {\n                if (assembler.generating_unreachable_operations()) return;\n                has_incoming_jump_ = true;\n                Block* current_block = assembler.current_block();\n                DCHECK_NOT_NULL(current_block);\n                if (assembler.GotoIf(condition, data_.block, hint) &\n                    ConditionalGotoStatus::kGotoDestination) {\n                RecordValues(current_block, data_, values);\n                }\n            }\n\n            template <typename A>\n            void GotoIfNot(A& assembler, OpIndex condition, BranchHint hint,\n                            const values_t& values) {\n                if (assembler.generating_unreachable_operations()) return;\n                has_incoming_jump_ = true;\n                Block* current_block = assembler.current_block();\n                DCHECK_NOT_NULL(current_block);\n                if (assembler.GotoIfNot(condition, data_.block, hint) &\n                    ConditionalGotoStatus::kGotoDestination) {\n                RecordValues(current_block, data_, values);\n                }\n            }\n\n            template <typename A>\n            base::prepend_tuple_type<bool, values_t> Bind(A& assembler) {\n                DCHECK(!data_.block->IsBound());\n                if (!assembler.Bind(data_.block)) {\n                return std::tuple_cat(std::tuple{false}, values_t{});\n                }\n                DCHECK_EQ(data_.block, assembler.current_block());\n                return std::tuple_cat(std::tuple{true}, MaterializePhis(assembler));\n            }\n\n            protected:\n            struct BlockData {\n                Block* block;\n                base::SmallVector<Block*, 4> predecessors;\n                recorded_values_t recorded_values;\n\n                explicit BlockData(Block* block) : block(block) {}\n            };\n\n            explicit LabelBase(Block* block) : data_(block) {\n                DCHECK_NOT_NULL(data_.block);\n            }\n\n            LabelBase(LabelBase&& other) V8_NOEXCEPT\n                : data_(std::move(other.data_)),\n                has_incoming_jump_(other.has_incoming_jump_) {}\n\n            static void RecordValues(Block* source, BlockData& data,\n                                    const values_t& values) {\n                DCHECK_NOT_NULL(source);\n                if (data.block->IsBound()) {\n                // Cannot `Goto` to a bound block. If you are trying to construct a\n                // loop, use a `LoopLabel` instead!\n                UNREACHABLE();\n                }\n                RecordValuesImpl(data, source, values, std::make_index_sequence<size>());\n            }\n\n            template <size_t... indices>\n            static void RecordValuesImpl(BlockData& data, Block* source,\n                                        const values_t& values,\n                                        std::index_sequence<indices...>) {\n            #ifdef DEBUG\n                std::initializer_list<size_t> sizes{\n                    std::get<indices>(data.recorded_values).size()...};\n                // There a -1 on the PredecessorCounts below, because we've emitted the\n                // Goto/Branch before calling RecordValues (which we do because the\n                // condition of the Goto might have been constant-folded, resulting in the\n                // destination not actually being reachable).\n                DCHECK(base::all_equal(\n                    sizes, static_cast<size_t>(data.block->PredecessorCount() - 1)));\n                DCHECK_EQ(data.block->PredecessorCount() - 1, data.predecessors.size());\n            #endif\n                (std::get<indices>(data.recorded_values)\n                    .push_back(std::get<indices>(values)),\n                ...);\n                data.predecessors.push_back(source);\n            }\n\n            template <typename A>\n            values_t MaterializePhis(A& assembler) {\n                return MaterializePhisImpl(assembler, data_,\n                                        std::make_index_sequence<size>());\n            }\n\n            template <typename A, size_t... indices>\n            static values_t MaterializePhisImpl(A& assembler, BlockData& data,\n                                                std::index_sequence<indices...>) {\n                size_t predecessor_count = data.block->PredecessorCount();\n                DCHECK_EQ(data.predecessors.size(), predecessor_count);\n                // If this label has no values, we don't need any Phis.\n                if constexpr (size == 0) return values_t{};\n\n                // If this block does not have any predecessors, we shouldn't call this.\n                DCHECK_LT(0, predecessor_count);\n                // With 1 predecessor, we don't need any Phis.\n                if (predecessor_count == 1) {\n                return values_t{std::get<indices>(data.recorded_values)[0]...};\n                }\n                DCHECK_LT(1, predecessor_count);\n\n                // Construct Phis.\n                return values_t{assembler.Phi(\n                    base::VectorOf(std::get<indices>(data.recorded_values)))...};\n            }\n\n            BlockData data_;\n            bool has_incoming_jump_ = false;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Label\",\n            \"extends\": \"LabelBase<false, Ts...>\",\n            \"about\": \"Represents a non-loop label used for control flow.\",\n            \"dependencies\": [\n                \"LabelBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename... Ts>\n            class Label : public LabelBase<false, Ts...> {\n            using super = LabelBase<false, Ts...>;\n\n            Label(const Label&) = delete;\n            Label& operator=(const Label&) = delete;\n\n            public:\n            template <typename Reducer>\n            explicit Label(Reducer* reducer) : super(reducer->Asm().NewBlock()) {}\n\n            Label(Label&& other) V8_NOEXCEPT : super(std::move(other)) {}\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LoopLabel\",\n            \"extends\": \"LabelBase<true, Ts...>\",\n            \"about\": \"Represents a loop label used for constructing loops in the IR graph. Manages loop header blocks and phi node creation for loop variables.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"LabelBase\",\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename... Ts>\n            class LoopLabel : public LabelBase<true, Ts...> {\n            using super = LabelBase<true, Ts...>;\n            using BlockData = typename super::BlockData;\n\n            LoopLabel(const LoopLabel&) = delete;\n            LoopLabel& operator=(const LoopLabel&) = delete;\n\n            public:\n            using values_t = typename super::values_t;\n            template <typename Reducer>\n            explicit LoopLabel(Reducer* reducer)\n                : super(reducer->Asm().NewBlock()),\n                loop_header_data_{reducer->Asm().NewLoopHeader()} {}\n\n            LoopLabel(LoopLabel&& other) V8_NOEXCEPT\n                : super(std::move(other)),\n                loop_header_data_(std::move(other.loop_header_data_)),\n                pending_loop_phis_(std::move(other.pending_loop_phis_)) {}\n\n            Block* loop_header() const { return loop_header_data_.block; }\n\n            template <typename A>\n            void Goto(A& assembler, const values_t& values) {\n                if (assembler.generating_unreachable_operations()) return;\n                if (!loop_header_data_.block->IsBound()) {\n                // If the loop header is not bound yet, we have the forward edge to the\n                // loop.\n                DCHECK_EQ(0, loop_header_data_.block->PredecessorCount());\n                Block* current_block = assembler.current_block();\n                DCHECK_NOT_NULL(current_block);\n                assembler.Goto(loop_header_data_.block);\n                super::RecordValues(current_block, loop_header_data_, values);\n                } else {\n                // We have a jump back to the loop header and wire it to the single\n                // backedge block.\n                this->super::Goto(assembler, values);\n                }\n            }\n\n            template <typename A>\n            void GotoIf(A& assembler, OpIndex condition, BranchHint hint,\n                        const values_t& values) {\n                if (assembler.generating_unreachable_operations()) return;\n                if (!loop_header_data_.block->IsBound()) {\n                // If the loop header is not bound yet, we have the forward edge to the\n                // loop.\n                DCHECK_EQ(0, loop_header_data_.block->PredecessorCount());\n                Block* current_block = assembler.current_block();\n                DCHECK_NOT_NULL(current_block);\n                if (assembler.GotoIf(condition, loop_header_data_.block, hint) &\n                    ConditionalGotoStatus::kGotoDestination) {\n                    super::RecordValues(current_block, loop_header_data_, values);\n                }\n                } else {\n                // We have a jump back to the loop header and wire it to the single\n                // backedge block.\n                this->super::GotoIf(assembler, condition, hint, values);\n                }\n            }\n\n            template <typename A>\n            void GotoIfNot(A& assembler, OpIndex condition, BranchHint hint,\n                            const values_t& values) {\n                if (assembler.generating_unreachable_operations()) return;\n                if (!loop_header_data_.block->IsBound()) {\n                // If the loop header is not bound yet, we have the forward edge to the\n                // loop.\n                DCHECK_EQ(0, loop_header_data_.block->PredecessorCount());\n                Block* current_block = assembler.current_block();\n                DCHECK_NOT_NULL(current_block);\n                if (assembler.GotoIf(condition, loop_header_data_.block, hint) &\n                    ConditionalGotoStatus::kGotoDestination) {\n                    super::RecordValues(current_block, loop_header_data_, values);\n                }\n                } else {\n                // We have a jump back to the loop header and wire it to the single\n                // backedge block.\n                this->super::GotoIfNot(assembler, condition, hint, values);\n                }\n            }\n\n            template <typename A>\n            base::prepend_tuple_type<bool, values_t> Bind(A& assembler) {\n                // LoopLabels must not be bound  using `Bind`, but with `Loop`.\n                UNREACHABLE();\n            }\n\n            template <typename A>\n            base::prepend_tuple_type<bool, values_t> BindLoop(A& assembler) {\n                DCHECK(!loop_header_data_.block->IsBound());\n                if (!assembler.Bind(loop_header_data_.block)) {\n                return std::tuple_cat(std::tuple{false}, values_t{});\n                }\n                DCHECK_EQ(loop_header_data_.block, assembler.current_block());\n                values_t pending_loop_phis =\n                    MaterializeLoopPhis(assembler, loop_header_data_);\n                pending_loop_phis_ = pending_loop_phis;\n                return std::tuple_cat(std::tuple{true}, pending_loop_phis);\n            }\n\n            template <typename A>\n            void EndLoop(A& assembler) {\n                // First, we need to bind the backedge block.\n                auto bind_result = this->super::Bind(assembler);\n                // `Bind` returns a tuple with a `bool` as first entry that indicates\n                // whether the block was bound. The rest of the tuple contains the phi\n                // values. Check if this block was bound (aka is reachable).\n                if (std::get<0>(bind_result)) {\n                // The block is bound.\n                DCHECK_EQ(assembler.current_block(), this->super::block());\n                // Now we build a jump from this block to the loop header.\n                // Remove the \"bound\"-flag from the beginning of the tuple.\n                auto values = base::tuple_drop<1>(bind_result);\n                assembler.Goto(loop_header_data_.block);\n                // Finalize Phis in the loop header.\n                FixLoopPhis(assembler, values);\n                }\n                assembler.FinalizeLoop(loop_header_data_.block);\n            }\n\n            private:\n            template <typename A>\n            static values_t MaterializeLoopPhis(A& assembler, BlockData& data) {\n                return MaterializeLoopPhisImpl(assembler, data,\n                                            std::make_index_sequence<super::size>());\n            }\n\n            template <typename A, size_t... indices>\n            static values_t MaterializeLoopPhisImpl(A& assembler, BlockData& data,\n                                                    std::index_sequence<indices...>) {\n                size_t predecessor_count = data.block->PredecessorCount();\n                USE(predecessor_count);\n                DCHECK_EQ(data.predecessors.size(), predecessor_count);\n                // If this label has no values, we don't need any Phis.\n                if constexpr (super::size == 0) return typename super::values_t{};\n\n                DCHECK_EQ(predecessor_count, 1);\n                auto phis = typename super::values_t{assembler.PendingLoopPhi(\n                    std::get<indices>(data.recorded_values)[0])...};\n                return phis;\n            }\n\n            template <typename A>\n            void FixLoopPhis(A& assembler, const typename super::values_t& values) {\n                DCHECK(loop_header_data_.block->IsBound());\n                DCHECK(loop_header_data_.block->IsLoop());\n                DCHECK_LE(1, loop_header_data_.predecessors.size());\n                DCHECK_LE(loop_header_data_.predecessors.size(), 2);\n                FixLoopPhi<0>(assembler, values);\n            }\n\n            template <size_t I, typename A>\n            void FixLoopPhi(A& assembler, const typename super::values_t& values) {\n                if constexpr (I < std::tuple_size_v<typename super::values_t>) {\n                OpIndex phi_index = std::get<I>(*pending_loop_phis_);\n                PendingLoopPhiOp& pending_loop_phi =\n                    assembler.output_graph()\n                        .Get(phi_index)\n                        .template Cast<PendingLoopPhiOp>();\n                DCHECK_EQ(pending_loop_phi.first(),\n                            std::get<I>(loop_header_data_.recorded_values)[0]);\n                assembler.output_graph().template Replace<PhiOp>(\n                    phi_index,\n                    base::VectorOf<OpIndex>(\n                        {pending_loop_phi.first(), std::get<I>(values)}),\n                    pending_loop_phi.rep);\n                FixLoopPhi<I + 1>(assembler, values);\n                }\n            }\n\n            BlockData loop_header_data_;\n            std::optional<values_t> pending_loop_phis_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Uninitialized\",\n            \"about\": \"Represents an uninitialized heap object.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"HeapObject\",\n                \"V\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class Uninitialized {\n            static_assert(is_subtype_v<T, HeapObject>);\n\n            public:\n            explicit Uninitialized(V<T> object) : object_(object) {}\n\n            private:\n            template <typename Next>\n            friend class TurboshaftAssemblerOpInterface;\n\n            V<T> object() const {\n                DCHECK(object_.has_value());\n                return *object_;\n            }\n\n            V<T> ReleaseObject() {\n                DCHECK(object_.has_value());\n                auto temp = *object_;\n                object_.reset();\n                return temp;\n            }\n\n            std::optional<V<T>> object_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackBottom\",\n            \"about\": \"Represents the bottom of the reducer stack.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename Reducers>\n            struct StackBottom {\n            using AssemblerType = Assembler<Reducers>;\n            using ReducerList = Reducers;\n            Assembler<ReducerList>& Asm() {\n                return *static_cast<Assembler<ReducerList>*>(this);\n            }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ReducerStack\",\n            \"about\": \"Calculates reducer stack by inserting EmitProjectionReducer and GenericReducerBase.\",\n            \"attributes\": [],\n            \""
}