{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/compilation-dependencies.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/compilation-dependencies.cc\",\n            \"file_name\": \"compilation-dependencies.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Manages dependencies for compilation, ensuring that compiled code remains valid as the heap state changes. This file defines classes and methods to track dependencies on various heap objects and properties, such as Maps, PropertyCells, and AllocationSites.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary header files for compilation dependencies, standard library features, base hashmap, assertions, execution, handles, heap layout, objects, and property cells.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/compilation-dependencies.h\"\n\n#include <optional>\n\n#include \"src/base/hashmap.h\"\n#include \"src/common/assert-scope.h\"\n#include \"src/execution/protectors.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/heap/heap-layout-inl.h\"\n#include \"src/objects/allocation-site-inl.h\"\n#include \"src/objects/internal-index.h\"\n#include \"src/objects/js-array-inl.h\"\n#include \"src/objects/js-function-inl.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/property-cell.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CompilationDependencies\",\n                \"about\": \"Manages the compilation dependencies\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating dependencies.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Broker to access the heap.\"\n                    },\n                    {\n                        \"name\": \"dependencies_\",\n                        \"type\": \"ZoneSet<CompilationDependency*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of tracked compilation dependencies.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"CompilationDependency\",\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass CompilationDependencies {\n public:\n  CompilationDependencies(JSHeapBroker* broker,\n                                                 Zone* zone);\n\n  void RecordDependency(CompilationDependency const* dependency);\n\n  MapRef DependOnInitialMap(JSFunctionRef function);\n\n  HeapObjectRef DependOnPrototypeProperty(\n    JSFunctionRef function);\n\n  void DependOnStableMap(MapRef map);\n\n  void DependOnConstantInDictionaryPrototypeChain(\n    MapRef receiver_map, NameRef property_name, ObjectRef constant,\n    PropertyKind kind);\n\n  AllocationType DependOnPretenureMode(\n    AllocationSiteRef site);\n\n  PropertyConstness DependOnFieldConstness(\n    MapRef map, MapRef owner, InternalIndex descriptor);\n\n  CompilationDependency const*\n    FieldConstnessDependencyOffTheRecord(\n      MapRef map, MapRef owner, InternalIndex descriptor);\n\n  void DependOnGlobalProperty(PropertyCellRef cell);\n\n  bool DependOnScriptContextSlotProperty(\n    ContextRef script_context, size_t index,\n    ContextSidePropertyCell::Property property, JSHeapBroker* broker);\n\n  bool DependOnEmptyContextExtension(\n    ScopeInfoRef scope_info);\n\n  bool DependOnProtector(PropertyCellRef cell);\n\n  bool DependOnMegaDOMProtector();\n\n  bool DependOnNoProfilingProtector();\n\n  bool DependOnNoUndetectableObjectsProtector();\n\n  bool DependOnArrayBufferDetachingProtector();\n\n  bool DependOnArrayIteratorProtector();\n\n  bool DependOnArraySpeciesProtector();\n\n  bool DependOnNoElementsProtector();\n\n  bool DependOnPromiseHookProtector();\n\n  bool DependOnPromiseSpeciesProtector();\n\n  bool DependOnPromiseThenProtector();\n\n  bool DependOnStringWrapperToPrimitiveProtector();\n\n  bool DependOnTypedArrayLengthProtector();\n\n  void DependOnElementsKind(AllocationSiteRef site);\n\n  void DependOnObjectSlotValue(HeapObjectRef object,\n                                                      int offset,\n                                                      ObjectRef value);\n\n  void DependOnOwnConstantElement(JSObjectRef holder,\n                                                         uint32_t index,\n                                                         ObjectRef element);\n\n  void DependOnOwnConstantDataProperty(\n    JSObjectRef holder, MapRef map, FieldIndex index, ObjectRef value);\n\n  void DependOnOwnConstantDoubleProperty(\n    JSObjectRef holder, MapRef map, FieldIndex index, Float64 value);\n\n  void DependOnOwnConstantDictionaryProperty(\n    JSObjectRef holder, InternalIndex index, ObjectRef value);\n\n  bool Commit(Handle<Code> code);\n\n  bool PrepareInstall();\n\n  void DependOnStablePrototypeChains(\n    ZoneVector<MapRef> const& receiver_maps, WhereToStart start,\n    OptionalJSObjectRef last_prototype);\n\n  void DependOnStablePrototypeChain(\n    MapRef receiver_map, WhereToStart start,\n    OptionalJSObjectRef last_prototype);\n\n  void DependOnElementsKinds(AllocationSiteRef site);\n\n  void DependOnConsistentJSFunctionView(\n    JSFunctionRef function);\n\n  void DependOnNoSlackTrackingChange(MapRef map);\n\n  SlackTrackingPrediction\n    DependOnInitialMapInstanceSizePrediction(\n      JSFunctionRef function);\n\n  CompilationDependency const*\n    TransitionDependencyOffTheRecord(\n      MapRef target_map) const;\n\n  CompilationDependency const*\n    FieldRepresentationDependencyOffTheRecord(\n      MapRef map, MapRef owner, InternalIndex descriptor,\n      Representation representation) const;\n\n  CompilationDependency const*\n    FieldTypeDependencyOffTheRecord(\n      MapRef map, MapRef owner, InternalIndex descriptor, ObjectRef type) const;\n\n#ifdef DEBUG\n  // static\n  bool IsFieldRepresentationDependencyOnMap(\n    const CompilationDependency* dep, const Handle<Map>& receiver_map);\n#endif  // DEBUG\n\n private:\n  Zone* zone_;\n  JSHeapBroker* broker_;\n  ZoneSet<CompilationDependency*> dependencies_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CompilationDependencies::CompilationDependencies\",\n                \"about\": \"Constructor for CompilationDependencies. Initializes the object with a JSHeapBroker and a Zone.\",\n                \"logic\": \"Sets the broker and zone, and sets the compilation dependencies for the broker.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker to use.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to use.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nCompilationDependencies::CompilationDependencies(JSHeapBroker* broker,\n                                                 Zone* zone)\n    : zone_(zone), broker_(broker), dependencies_(zone) {\n  broker->set_dependencies(this);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::RecordDependency\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency if it is not null.\",\n                \"logic\": \"Inserts the dependency into the dependencies_ set if the dependency pointer is not null.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"dependency\",\n                        \"type\": \"CompilationDependency const*\",\n                        \"purpose\": \"The dependency to record.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CompilationDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CompilationDependencies::RecordDependency(\n    CompilationDependency const* dependency) {\n  if (dependency != nullptr) dependencies_.insert(dependency);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnInitialMap\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the initial map of a JSFunction.\",\n                \"logic\": \"Gets the initial map from the function, records a dependency on it, and returns the map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"function\",\n                        \"type\": \"JSFunctionRef\",\n                        \"purpose\": \"The JSFunction to depend on.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"MapRef\",\n                    \"description\": \"The initial map of the JSFunction.\"\n                },\n                \"dependencies\": [\n                    \"JSFunctionRef\",\n                    \"MapRef\",\n                    \"InitialMapDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nMapRef CompilationDependencies::DependOnInitialMap(JSFunctionRef function) {\n  MapRef map = function.initial_map(broker_);\n  RecordDependency(zone_->New<InitialMapDependency>(broker_, function, map));\n  return map;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnPrototypeProperty\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the prototype property of a JSFunction.\",\n                \"logic\": \"Gets the instance prototype from the function, records a dependency, and returns the prototype.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"function\",\n                        \"type\": \"JSFunctionRef\",\n                        \"purpose\": \"The JSFunction to depend on.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"HeapObjectRef\",\n                    \"description\": \"The prototype of the JSFunction.\"\n                },\n                \"dependencies\": [\n                    \"JSFunctionRef\",\n                    \"HeapObjectRef\",\n                    \"PrototypePropertyDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nHeapObjectRef CompilationDependencies::DependOnPrototypeProperty(\n    JSFunctionRef function) {\n  HeapObjectRef prototype = function.instance_prototype(broker_);\n  RecordDependency(\n      zone_->New<PrototypePropertyDependency>(broker_, function, prototype));\n  return prototype;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnStableMap\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on a stable map.\",\n                \"logic\": \"If the map can transition, records a dependency.  Stable maps do not change their structure.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"MapRef\",\n                        \"purpose\": \"The Map to depend on.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"MapRef\",\n                    \"StableMapDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CompilationDependencies::DependOnStableMap(MapRef map) {\n  if (map.CanTransition()) {\n    RecordDependency(zone_->New<StableMapDependency>(map));\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnConstantInDictionaryPrototypeChain\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on a constant in the dictionary prototype chain.\",\n                \"logic\": \"Records a dependency on the constant value of a property in the prototype chain. This is used to optimize property accesses.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"receiver_map\",\n                        \"type\": \"MapRef\",\n                        \"purpose\": \"The map of the receiver object.\"\n                    },\n                    {\n                        \"name\": \"property_name\",\n                        \"type\": \"NameRef\",\n                        \"purpose\": \"The name of the property.\"\n                    },\n                    {\n                        \"name\": \"constant\",\n                        \"type\": \"ObjectRef\",\n                        \"purpose\": \"The constant value of the property.\"\n                    },\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"PropertyKind\",\n                        \"purpose\": \"The kind of the property.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"MapRef\",\n                    \"NameRef\",\n                    \"ObjectRef\",\n                    \"ConstantInDictionaryPrototypeChainDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CompilationDependencies::DependOnConstantInDictionaryPrototypeChain(\n    MapRef receiver_map, NameRef property_name, ObjectRef constant,\n    PropertyKind kind) {\n  RecordDependency(zone_->New<ConstantInDictionaryPrototypeChainDependency>(\n      receiver_map, property_name, constant, kind));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnPretenureMode\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the pretenure mode of an AllocationSite.\",\n                \"logic\": \"If allocation site pretenuring is enabled, records a dependency on the allocation type of the site and returns it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"site\",\n                        \"type\": \"AllocationSiteRef\",\n                        \"purpose\": \"The allocation site to depend on.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"AllocationType\",\n                    \"description\": \"The allocation type of the AllocationSite.\"\n                },\n                \"dependencies\": [\n                    \"AllocationSiteRef\",\n                    \"PretenureModeDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nAllocationType CompilationDependencies::DependOnPretenureMode(\n    AllocationSiteRef site) {\n  if (!v8_flags.allocation_site_pretenuring) return AllocationType::kYoung;\n  AllocationType allocation = site.GetAllocationType();\n  RecordDependency(zone_->New<PretenureModeDependency>(site, allocation));\n  return allocation;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnFieldConstness\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the constness of a field.\",\n                \"logic\": \"Records a dependency if the field is constant. If the map can have fast elements transitions, it also depends on the map being stable.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"MapRef\",\n                        \"purpose\": \"The map of the object.\"\n                    },\n                    {\n                        \"name\": \"owner\",\n                        \"type\": \"MapRef\",\n                        \"purpose\": \"The owner map.\"\n                    },\n                    {\n                        \"name\": \"descriptor\",\n                        \"type\": \"InternalIndex\",\n                        \"purpose\": \"The descriptor index.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"PropertyConstness\",\n                    \"description\": \"The constness of the property.\"\n                },\n                \"dependencies\": [\n                    \"MapRef\",\n                    \"InternalIndex\",\n                    \"FieldConstnessDependency\",\n                    \"CompilationDependencies::DependOnStableMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nPropertyConstness CompilationDependencies::DependOnFieldConstness(\n    MapRef map, MapRef owner, InternalIndex descriptor) {\n  PropertyConstness constness =\n      map.GetPropertyDetails(broker_, descriptor).constness();\n  if (constness == PropertyConstness::kMutable) return constness;\n\n  // If the map can have fast elements transitions, then the field can be only\n  // considered constant if the map does not transition.\n  if (Map::CanHaveFastTransitionableElementsKind(map.instance_type())) {\n    // If the map can already transition away, let us report the field as\n    // mutable.\n    if (!map.is_stable()) {\n      return PropertyConstness::kMutable;\n    }\n    DependOnStableMap(map);\n  }\n\n  DCHECK_EQ(constness, PropertyConstness::kConst);\n  RecordDependency(\n      zone_->New<FieldConstnessDependency>(map, owner, descriptor));\n  return PropertyConstness::kConst;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::FieldConstnessDependencyOffTheRecord\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Creates a FieldConstnessDependency but doesn't record it.\",\n                \"logic\": \"Similar to DependOnFieldConstness, but only creates the dependency object without adding it to the tracked dependencies.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"MapRef\",\n                        \"purpose\": \"The map of the object.\"\n                    },\n                    {\n                        \"name\": \"owner\",\n                        \"type\": \"MapRef\",\n                        \"purpose\": \"The owner map.\"\n                    },\n                    {\n                        \"name\": \"descriptor\",\n                        \"type\": \"InternalIndex\",\n                        \"purpose\": \"The descriptor index.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"CompilationDependency const*\",\n                    \"description\": \"The newly created FieldConstnessDependency object or nullptr.\"\n                },\n                \"dependencies\": [\n                    \"MapRef\",\n                    \"InternalIndex\",\n                    \"FieldConstnessDependency\",\n                    \"CompilationDependencies::DependOnStableMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nCompilationDependency const*\nCompilationDependencies::FieldConstnessDependencyOffTheRecord(\n    MapRef map, MapRef owner, InternalIndex descriptor) {\n  DCHECK_EQ(map.GetPropertyDetails(broker_, descriptor).constness(),\n            PropertyConstness::kConst);\n\n  // If the map can have fast elements transitions, then the field can be only\n  // considered constant if the map does not transition.\n  if (Map::CanHaveFastTransitionableElementsKind(map.instance_type())) {\n    // If the map can already transition away, let us report the field as\n    // mutable.\n    if (!map.is_stable()) {\n      return {};\n    }\n    DependOnStableMap(map);\n  }\n\n  return zone_->New<FieldConstnessDependency>(map, owner, descriptor);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnGlobalProperty\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on a global property.\",\n                \"logic\": \"Records a dependency on the type and read-only status of a global property cell.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cell\",\n                        \"type\": \"PropertyCellRef\",\n                        \"purpose\": \"The property cell to depend on.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"PropertyCellRef\",\n                    \"GlobalPropertyDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CompilationDependencies::DependOnGlobalProperty(PropertyCellRef cell) {\n  PropertyCellType type = cell.property_details().cell_type();\n  bool read_only = cell.property_details().IsReadOnly();\n  RecordDependency(zone_->New<GlobalPropertyDependency>(cell, type, read_only));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnScriptContextSlotProperty\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on a slot in a script context.\",\n                \"logic\": \"Records a dependency if const tracking or mutable heap numbers are enabled, and if the script context and property match. This function guards against changes to let/const variables and script context properties.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"script_context\",\n                        \"type\": \"ContextRef\",\n                        \"purpose\": \"The script context to depend on.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the slot in the context.\"\n                    },\n                    {\n                        \"name\": \"property\",\n                        \"type\": \"ContextSidePropertyCell::Property\",\n                        \"purpose\": \"The expected property of the slot.\"\n                    },\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker to use.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"ContextRef\",\n                    \"ScriptContextSlotPropertyDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnScriptContextSlotProperty(\n    ContextRef script_context, size_t index,\n    ContextSidePropertyCell::Property property, JSHeapBroker* broker) {\n  if ((v8_flags.const_tracking_let ||\n       v8_flags.script_context_mutable_heap_number) &&\n      script_context.object()->IsScriptContext() &&\n      script_context.object()->GetScriptContextSideProperty(index) ==\n          property) {\n    RecordDependency(zone_->New<ScriptContextSlotPropertyDependency>(\n        script_context, index, property));\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnEmptyContextExtension\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the absence of a context extension.\",\n                \"logic\": \"Records a dependency if empty context extension is enabled and the scope info does not have a context extension.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"scope_info\",\n                        \"type\": \"ScopeInfoRef\",\n                        \"purpose\": \"The scope info to depend on.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"ScopeInfoRef\",\n                    \"EmptyContextExtensionDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnEmptyContextExtension(\n    ScopeInfoRef scope_info) {\n  if (!v8_flags.empty_context_extension_dep) return false;\n  DCHECK(scope_info.SloppyEvalCanExtendVars());\n  if (HeapLayout::InReadOnlySpace(*scope_info.object()) ||\n      scope_info.object()->SomeContextHasExtension()) {\n    // There are respective contexts with non-empty context extension, so\n    // dynamic checks are required.\n    return false;\n  }\n  RecordDependency(zone_->New<EmptyContextExtensionDependency>(scope_info));\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on a protector cell.\",\n                \"logic\": \"Records a dependency on a property cell used as a protector. This is used for guarding against changes to certain properties or conditions.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cell\",\n                        \"type\": \"PropertyCellRef\",\n                        \"purpose\": \"The protector property cell to depend on.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"PropertyCellRef\",\n                    \"ProtectorDependency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnProtector(PropertyCellRef cell) {\n  cell.CacheAsProtector(broker_);\n  if (cell.value(broker_).AsSmi() != Protectors::kProtectorValid) return false;\n  RecordDependency(zone_->New<ProtectorDependency>(cell));\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnMegaDOMProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the mega DOM protector.\",\n                \"logic\": \"Specific protector for mega DOM properties. Just calls DependOnProtector with the right cell.\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"parameters\": [],\n                \"dependencies\": [\n                    \"CompilationDependencies::DependOnProtector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnMegaDOMProtector() {\n  return DependOnProtector(\n      MakeRef(broker_, broker_->isolate()->factory()->mega_dom_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnNoProfilingProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the no profiling protector.\",\n                \"logic\": \"Guards against enabling profiling after compilation. It returns false if profiling is already enabled.\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"parameters\": [],\n                \"dependencies\": [\n                    \"CompilationDependencies::DependOnProtector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnNoProfilingProtector() {\n  // A shortcut in case profiling was already enabled but the interrupt\n  // request to invalidate NoProfilingProtector wasn't processed yet.\n#ifdef V8_RUNTIME_CALL_STATS\n  if (TracingFlags::is_runtime_stats_enabled()) return false;\n#endif\n  if (broker_->isolate()->is_profiling()) return false;\n  return DependOnProtector(MakeRef(\n      broker_, broker_->isolate()->factory()->no_profiling_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnNoUndetectableObjectsProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the no undetectable objects protector.\",\n                \"logic\": \"Protector against undetectable objects. Just calls DependOnProtector with the right cell.\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"parameters\": [],\n                \"dependencies\": [\n                    \"CompilationDependencies::DependOnProtector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnNoUndetectableObjectsProtector() {\n  return DependOnProtector(MakeRef(\n      broker_,\n      broker_->isolate()->factory()->no_undetectable_objects_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnArrayBufferDetachingProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the array buffer detaching protector.\",\n                \"logic\": \"Protector against detaching array buffers. Just calls DependOnProtector with the right cell.\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"parameters\": [],\n                \"dependencies\": [\n                    \"CompilationDependencies::DependOnProtector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnArrayBufferDetachingProtector() {\n  return DependOnProtector(MakeRef(\n      broker_,\n      broker_->isolate()->factory()->array_buffer_detaching_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnArrayIteratorProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the array iterator protector.\",\n                \"logic\": \"Protector against modifications of array iterators. Just calls DependOnProtector with the right cell.\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"parameters\": [],\n                \"dependencies\": [\n                    \"CompilationDependencies::DependOnProtector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnArrayIteratorProtector() {\n  return DependOnProtector(MakeRef(\n      broker_, broker_->isolate()->factory()->array_iterator_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnArraySpeciesProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the array species protector.\",\n                \"logic\": \"Protector against modifications of the array species. Just calls DependOnProtector with the right cell.\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"parameters\": [],\n                \"dependencies\": [\n                    \"CompilationDependencies::DependOnProtector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnArraySpeciesProtector() {\n  return DependOnProtector(MakeRef(\n      broker_, broker_->isolate()->factory()->array_species_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnNoElementsProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the no elements protector.\",\n                \"logic\": \"Protector against the presence of elements. Just calls DependOnProtector with the right cell.\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"parameters\": [],\n                \"dependencies\": [\n                    \"CompilationDependencies::DependOnProtector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnNoElementsProtector() {\n  return DependOnProtector(\n      MakeRef(broker_, broker_->isolate()->factory()->no_elements_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnPromiseHookProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the promise hook protector.\",\n                \"logic\": \"Specific protector for promise hooks. Just calls DependOnProtector with the right cell.\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"parameters\": [],\n                \"dependencies\": [\n                    \"CompilationDependencies::DependOnProtector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnPromiseHookProtector() {\n  return DependOnProtector(MakeRef(\n      broker_, broker_->isolate()->factory()->promise_hook_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CompilationDependencies::DependOnPromiseSpeciesProtector\",\n                \"parent\": \"CompilationDependencies\",\n                \"about\": \"Records a dependency on the promise species protector.\",\n                \"logic\": \"Specific protector for promise species. Just calls DependOnProtector with the right cell.\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the dependency was recorded, false otherwise.\"\n                },\n                \"parameters\": [],\n                \"dependencies\": [\n                    \"CompilationDependencies::DependOnProtector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool CompilationDependencies::DependOnPromiseSpeciesProtector() {\n  return DependOnProtector(MakeRef(\n      broker_, broker_->isolate()->factory()->promise_species_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n"
}