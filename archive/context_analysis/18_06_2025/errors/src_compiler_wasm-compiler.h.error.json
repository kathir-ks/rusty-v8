{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-compiler.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 92, column 62",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-compiler.h\",\n            \"file_name\": \"wasm-compiler.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the interface and data structures for the WebAssembly compiler within the V8 JavaScript engine.  It provides functionality to compile WASM modules, import call wrappers, host call wrappers, and JS-to-Wasm wrappers. It also includes data structures to facilitate compilation like WasmCompilationData and WasmGraphBuilder\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers for memory management and utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <memory>\n            #include <utility>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes V8 base library headers for small vectors, code generation, compiler definitions, runtime, WASM-related headers, and zone management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/small-vector.h\"\n            #include \"src/codegen/compiler.h\"\n            #include \"src/compiler/wasm-compiler-definitions.h\"\n            #include \"src/runtime/runtime.h\"\n            #include \"src/wasm/function-body-decoder.h\"\n            #include \"src/wasm/function-compiler.h\"\n            #include \"src/wasm/module-instantiate.h\"\n            #include \"src/wasm/wasm-features.h\"\n            #include \"src/wasm/wasm-module.h\"\n            #include \"src/wasm/wasm-opcodes.h\"\n            #include \"src/wasm/wasm-result.h\"\n            #include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmGraphBuilder\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Abstracts the details of building TurboFan graph nodes for WASM to separate the WASM decoder from the internal details of TurboFan.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The zone to allocate nodes.\"\n                    },\n                    {\n                        \"name\": \"mcgraph_\",\n                        \"type\": \"MachineGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The machine graph being constructed.\"\n                    },\n                    {\n                        \"name\": \"env_\",\n                        \"type\": \"wasm::CompilationEnv*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The compilation environment.\"\n                    },\n                    {\n                        \"name\": \"enabled_features_\",\n                        \"type\": \"wasm::WasmEnabledFeatures\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The enabled WASM features.\"\n                    },\n                    {\n                        \"name\": \"parameters_\",\n                        \"type\": \"Node**\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of parameter nodes.\"\n                    },\n                    {\n                        \"name\": \"stack_check_code_node_\",\n                        \"type\": \"SetOncePointer<Node>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Node for stack check code.\"\n                    },\n                    {\n                        \"name\": \"stack_check_call_operator_\",\n                        \"type\": \"SetOncePointer<const Operator>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Operator for stack check call.\"\n                    },\n                    {\n                        \"name\": \"has_simd_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if SIMD is enabled.\"\n                    },\n                    {\n                        \"name\": \"needs_stack_check_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if a stack check is needed.\"\n                    },\n                    {\n                        \"name\": \"function_sig_\",\n                        \"type\": \"const wasm::FunctionSig*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The function signature.\"\n                    },\n                    {\n                        \"name\": \"wrapper_sig_\",\n                        \"type\": \"const wasm::CanonicalSig*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The canonical signature of wrapper function.\"\n                    },\n                    {\n                        \"name\": \"decorator_\",\n                        \"type\": \"compiler::WasmDecorator*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The Wasm decorator (used for debugging).\"\n                    },\n                    {\n                        \"name\": \"source_position_table_\",\n                        \"type\": \"compiler::SourcePositionTable*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Table to store source positions of nodes.\"\n                    },\n                    {\n                        \"name\": \"inlining_id_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"ID of the current inlining.\"\n                    },\n                    {\n                        \"name\": \"parameter_mode_\",\n                        \"type\": \"const ParameterMode\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Specifies how the instance is passed as parameter.\"\n                    },\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The isolate.\"\n                    },\n                    {\n                        \"name\": \"instance_data_node_\",\n                        \"type\": \"SetOncePointer<Node>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The instance data node.\"\n                    },\n                     {\n                        \"name\": \"null_check_strategy_\",\n                        \"type\": \"NullCheckStrategy\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Strategy to use for null checks.\"\n                    },\n                    {\n                        \"name\": \"cached_memory_index_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The cached memory index.\"\n                    },\n                    {\n                        \"name\": \"gasm_\",\n                        \"type\": \"std::unique_ptr<WasmGraphAssembler>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The graph assembler for building Wasm code.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"wasm::CompilationEnv\",\n                    \"Zone\",\n                    \"MachineGraph\",\n                    \"wasm::FunctionSig\",\n                    \"compiler::SourcePositionTable\",\n                    \"Isolate\",\n                    \"wasm::WasmEnabledFeatures\",\n                    \"wasm::CanonicalSig\",\n                    \"compiler::WasmDecorator\",\n                    \"WasmGraphAssembler\",\n                    \"Signature\",\n                    \"MachineRepresentation\",\n                    \"Node\",\n                    \"Operator\",\n                    \"base::Vector\",\n                    \"Runtime::FunctionId\",\n                    \"AbortReason\",\n                    \"StubCallMode\",\n                    \"NullCheckStrategy\",\n                    \"wasm::TrapReason\",\n                    \"wasm::ValueTypeBase\",\n                    \"wasm::WasmCodePosition\",\n                    \"TFGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class WasmGraphBuilder {\n            public:\n              // ParameterMode specifies how the instance is passed.\n              enum ParameterMode {\n                // Normal wasm functions pass the instance as an implicit first parameter.\n                kInstanceParameterMode,\n                // For Wasm-to-JS and C-API wrappers, a {WasmImportData} object is\n                // passed as first parameter.\n                kWasmImportDataMode,\n                // For JS-to-Wasm wrappers (which are JS functions), we load the Wasm\n                // instance from the JS function data. The generated code objects live on\n                // the JS heap, so those compilation pass an isolate.\n                kJSFunctionAbiMode,\n                // The JS-to-JS wrapper does not have an associated instance.\n                // The C-entry stub uses a custom ABI (see {CWasmEntryParameters}).\n                kNoSpecialParameterMode\n              };\n\n              V8_EXPORT_PRIVATE WasmGraphBuilder(\n                  wasm::CompilationEnv* env, Zone* zone, MachineGraph* mcgraph,\n                  const wasm::FunctionSig* sig, compiler::SourcePositionTable* spt,\n                  ParameterMode parameter_mode, Isolate* isolate,\n                  wasm::WasmEnabledFeatures enabled_features,\n                  const wasm::CanonicalSig* wrapper_sig = nullptr);\n\n              V8_EXPORT_PRIVATE ~WasmGraphBuilder();\n\n              bool TryWasmInlining(int fct_index, wasm::NativeModule* native_module,\n                                   int inlining_id);\n\n              //-----------------------------------------------------------------------\n              // Operations independent of {control} or {effect}.\n              //-----------------------------------------------------------------------\n              void Start(unsigned params);\n              Node* Param(int index, const char* debug_name = nullptr);\n              void TerminateThrow(Node* effect, Node* control);\n              Node* Int32Constant(int32_t value);\n\n              //-----------------------------------------------------------------------\n              // Operations that read and/or write {control} and {effect}.\n              //-----------------------------------------------------------------------\n\n              Node* Return(base::Vector<Node*> nodes);\n              template <typename... Nodes>\n              Node* Return(Node* fst, Nodes*... more) {\n                Node* arr[] = {fst, more...};\n                return Return(base::ArrayVector(arr));\n              }\n\n              Node* effect();\n              Node* control();\n              Node* SetEffect(Node* node);\n              Node* SetControl(Node* node);\n              void SetEffectControl(Node* effect, Node* control);\n              Node* SetEffectControl(Node* effect_and_control) {\n                SetEffectControl(effect_and_control, effect_and_control);\n                return effect_and_control;\n              }\n\n              Node* SetType(Node* node, wasm::ValueType type);\n\n              // Overload for when we want to provide a specific signature, rather than\n              // build one using sig_, for example after scalar lowering.\n              V8_EXPORT_PRIVATE void LowerInt64(Signature<MachineRepresentation>* sig);\n              V8_EXPORT_PRIVATE void LowerInt64(wasm::CallOrigin origin);\n\n              void SetSourcePosition(Node* node, wasm::WasmCodePosition position);\n\n              Node* IsNull(Node* object, wasm::ValueType type);\n              Node* TypeGuard(Node* value, wasm::ValueType type);\n\n              bool has_simd() const { return has_simd_; }\n\n              MachineGraph* mcgraph() { return mcgraph_; }\n              TFGraph* graph();\n              Zone* graph_zone();\n\n             protected:\n              Node* NoContextConstant();\n\n              Node* BuildLoadIsolateRoot();\n              Node* UndefinedValue();\n\n              const Operator* GetSafeLoadOperator(int offset, wasm::ValueTypeBase type);\n              Node* BuildSafeStore(int offset, wasm::ValueTypeBase type, Node* arg_buffer,\n                                   Node* value, Node* effect, Node* control);\n\n              Node* BuildCallNode(size_t param_count, base::Vector<Node*> args,\n                                  wasm::WasmCodePosition position, Node* instance_node,\n                                  const Operator* op, Node* frame_state = nullptr);\n              template <typename T>\n              Node* BuildWasmCall(const Signature<T>* sig, base::Vector<Node*> args,\n                                  base::Vector<Node*> rets, wasm::WasmCodePosition position,\n                                  Node* implicit_first_arg, bool indirect,\n                                  Node* frame_state = nullptr);\n\n              //-----------------------------------------------------------------------\n              // Operations involving the CEntry, a dependency we want to remove\n              // to get off the GC heap.\n              //-----------------------------------------------------------------------\n              Node* BuildCallToRuntime(Runtime::FunctionId f, Node** parameters,\n                                       int parameter_count);\n\n              Node* BuildCallToRuntimeWithContext(Runtime::FunctionId f, Node* js_context,\n                                           Node** parameters, int parameter_count);\n\n              TrapId GetTrapIdForTrap(wasm::TrapReason reason);\n\n              void BuildModifyThreadInWasmFlag(bool new_value);\n              void BuildModifyThreadInWasmFlagHelper(Node* thread_in_wasm_flag_address,\n                                                 bool new_value);\n\n              Node* BuildChangeInt64ToBigInt(Node* input, StubCallMode stub_mode);\n\n              void Assert(Node* condition, AbortReason abort_reason);\n\n              std::unique_ptr<WasmGraphAssembler> gasm_;\n              Zone* const zone_;\n              MachineGraph* const mcgraph_;\n              wasm::CompilationEnv* const env_;\n              // For the main WasmGraphBuilder class, this is identical to the features\n              // field in {env_}, but the WasmWrapperGraphBuilder subclass doesn't have\n              // that, so common code should use this field instead.\n              wasm::WasmEnabledFeatures enabled_features_;\n\n              Node** parameters_;\n\n              SetOncePointer<Node> stack_check_code_node_;\n              SetOncePointer<const Operator> stack_check_call_operator_;\n\n              bool has_simd_ = false;\n              bool needs_stack_check_ = false;\n\n              const wasm::FunctionSig* const function_sig_;\n              const wasm::CanonicalSig* const wrapper_sig_{nullptr};\n\n              compiler::WasmDecorator* decorator_ = nullptr;\n\n              compiler::SourcePositionTable* const source_position_table_ = nullptr;\n              int inlining_id_ = -1;\n              const ParameterMode parameter_mode_;\n              Isolate* const isolate_;\n              SetOncePointer<Node> instance_data_node_;\n              NullCheckStrategy null_check_strategy_;\n              static constexpr int kNoCachedMemoryIndex = -1;\n              int cached_memory_index_ = kNoCachedMemoryIndex;\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"WasmLoopInfo\",\n                \"about\": \"Stores information about a Wasm loop for compiler optimizations.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"header\",\n                        \"type\": \"Node*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The header node of the loop.\"\n                    },\n                    {\n                        \"name\": \"nesting_depth\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The nesting depth of the loop.\"\n                    },\n                    {\n                        \"name\": \"can_be_innermost\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates if the loop can be considered the innermost loop.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct WasmLoopInfo {\n              Node* header;\n              uint32_t nesting_depth;\n              // This loop has, to our best knowledge, no other loops nested within it. A\n              // loop can obtain inner loops despite this after inlining.\n              bool can_be_innermost;\n\n              WasmLoopInfo(Node* header, uint32_t nesting_depth, bool can_be_innermost)\n                  : header(header),\n                    nesting_depth(nesting_depth),\n                    can_be_innermost(can_be_innermost) {}\n            };\n        ]]></code>\n    </struct>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"WasmCompilationData\",\n                \"about\": \"Encapsulates data needed for WebAssembly compilation.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"func_body\",\n                        \"type\": \"const wasm::FunctionBody&\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The function body to compile.\"\n                    },\n                    {\n                        \"name\": \"wire_bytes_storage\",\n                        \"type\": \"const wasm::WireBytesStorage*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The storage for wire bytes.\"\n                    },\n                    {\n                        \"name\": \"node_origins\",\n                        \"type\": \"NodeOriginTable*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Table to store node origins.\"\n                    },\n                    {\n                        \"name\": \"loop_infos\",\n                        \"type\": \"std::vector<WasmLoopInfo>*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Vector of loop information.\"\n                    },\n                    {\n                        \"name\": \"assumptions\",\n                        \"type\": \"std::unique_ptr<wasm::AssumptionsJournal>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Journal of assumptions made during compilation.\"\n                    },\n                    {\n                        \"name\": \"source_positions\",\n                        \"type\": \"SourcePositionTable*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Table to store source positions.\"\n                    },\n                    {\n                        \"name\": \"func_index\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Index of the function.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"wasm::FunctionBody\",\n                    \"wasm::WireBytesStorage\",\n                    \"NodeOriginTable\",\n                    \"WasmLoopInfo\",\n                    \"wasm::AssumptionsJournal\",\n                    \"SourcePositionTable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct WasmCompilationData {\n              explicit WasmCompilationData(const wasm::FunctionBody& func_body)\n                  : func_body(func_body) {}\n\n              size_t body_size() { return func_body.end - func_body.start; }\n\n              const wasm::FunctionBody& func_body;\n              const wasm::WireBytesStorage* wire_bytes_storage;\n              NodeOriginTable* node_origins{nullptr};\n              std::vector<WasmLoopInfo>* loop_infos{nullptr};\n              std::unique_ptr<wasm::AssumptionsJournal> assumptions{};\n              SourcePositionTable* source_positions{nullptr};\n              int func_index;\n            };\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CompileWasmImportCallWrapper\",\n                \"about\": \"Compiles an import call wrapper, which allows Wasm to call imports.\",\n                \"logic\": \"Creates a wrapper function that handles the transition from WASM code to imported JavaScript or other host functions. It manages parameter conversion, exception handling, and other necessary operations to ensure compatibility between the WASM environment and the external environment.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"kind\",\n                        \"type\": \"wasm::ImportCallKind\",\n                        \"purpose\": \"The kind of import call.\"\n                    },\n                    {\n                        \"name\": \"sig\",\n                        \"type\": \"const wasm::CanonicalSig*\",\n                        \"purpose\": \"The canonical signature of the import.\"\n                    },\n                    {\n                        \"name\": \"source_positions\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether to include source position information.\"\n                    },\n                    {\n                        \"name\": \"expected_arity\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The expected arity of the import function.\"\n                    },\n                    {\n                        \"name\": \"suspend\",\n                        \"type\": \"wasm::Suspend\",\n                        \"purpose\": \"Indicates suspend option.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"wasm::WasmCompilationResult\",\n                    \"description\": \"The result of the compilation.\"\n                },\n                \"dependencies\": [\n                    \"wasm::ImportCallKind\",\n                    \"wasm::CanonicalSig\",\n                    \"wasm::WasmCompilationResult\",\n                    \"wasm::Suspend\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE wasm::WasmCompilationResult CompileWasmImportCallWrapper(\n                wasm::ImportCallKind kind, const wasm::CanonicalSig* sig, bool source_positions,\n                int expected_arity, wasm::Suspend suspend);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CompileWasmCapiCallWrapper\",\n                \"about\": \"Compiles a host call wrapper, which allows Wasm to call host functions through the C API.\",\n                \"logic\": \"Creates a wrapper function that enables WASM code to call functions exposed through the C API. This wrapper handles the necessary ABI (Application Binary Interface) conversions and ensures that the call conforms to the expected signature.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"sig\",\n                        \"type\": \"const wasm::CanonicalSig*\",\n                        \"purpose\": \"The canonical signature of the host function.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"wasm::WasmCompilationResult\",\n                    \"description\": \"The result of the compilation.\"\n                },\n                \"dependencies\": [\n                    \"wasm::CanonicalSig\",\n                    \"wasm::WasmCompilationResult\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            wasm::WasmCompilationResult CompileWasmCapiCallWrapper(\n                const wasm::CanonicalSig* sig);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsFastCallSupportedSignature\",\n                \"about\": \"Checks if a given function signature is supported for fast calls.\",\n                \"logic\": \"Determines whether the provided CFunctionInfo represents a signature that can be used with the fast call mechanism, which allows for optimized calls between JavaScript and compiled code.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"sig\",\n                        \"type\": \"const v8::CFunctionInfo*\",\n                        \"purpose\": \"The function signature to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the signature is supported for fast calls, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"v8::CFunctionInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool IsFastCallSupportedSignature(const v8::CFunctionInfo*);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CompileWasmJSFastCallWrapper\",\n                \"about\": \"Compiles a wrapper to call a Fast API function from Wasm.\",\n                \"logic\": \"Generates a wrapper function that allows WASM code to efficiently call JavaScript functions marked as Fast API calls. This involves setting up the correct calling context and handling potential type conversions.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"sig\",\n                        \"type\": \"const wasm::CanonicalSig*\",\n                        \"purpose\": \"The canonical signature of the JS function.\"\n                    },\n                    {\n                        \"name\": \"callable\",\n                        \"type\": \"DirectHandle<JSReceiver>\",\n                        \"purpose\": \"A direct handle to the JSReceiver (function) to be called.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"wasm::WasmCompilationResult\",\n                    \"description\": \"The result of the compilation.\"\n                },\n                \"dependencies\": [\n                    \"wasm::CanonicalSig\",\n                    \"wasm::WasmCompilationResult\",\n                    \"DirectHandle\",\n                    \"JSReceiver\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            wasm::WasmCompilationResult CompileWasmJSFastCallWrapper(\n                const wasm::CanonicalSig*, DirectHandle<JSReceiver> callable);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"NewJSToWasmCompilationJob\",\n                \"about\": \"Returns a TurboshaftCompilationJob object for a JS to Wasm wrapper.\",\n                \"logic\": \"Creates a compilation job responsible for compiling a wrapper that facilitates calls from JavaScript code to WebAssembly functions. This wrapper handles parameter marshalling, type conversions, and other necessary operations to ensure seamless interaction between the two environments.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The isolate.\"\n                    },\n                    {\n                        \"name\": \"sig\",\n                        \"type\": \"const wasm::CanonicalSig*\",\n                        \"purpose\": \"The canonical signature of the Wasm function.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::unique_ptr<OptimizedCompilationJob>\",\n                    \"description\": \"A unique pointer to the compilation job.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"wasm::CanonicalSig\",\n                    \"OptimizedCompilationJob\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            std::unique_ptr<OptimizedCompilationJob> NewJSToWasmCompilationJob(\n                Isolate* isolate, const wasm::CanonicalSig* sig);\n        ]]></code>\n    </func>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"CWasmEntryParameters\",\n                \"about\": \"Defines the parameters passed to the C-Wasm entry point.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum CWasmEntryParameters {\n              kCodeEntry,\n              kObjectRef,\n              kArgumentsBuffer,\n              kCEntryFp,\n              // marker:\n              kNumParameters\n            };\n        ]]></code>\n    </enum>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CompileCWasmEntry\",\n                \"about\": \"Compiles a stub with C++ linkage, to be called from Execution::CallWasm, which knows how to feed it its parameters.\",\n                \"logic\": \"Generates a small piece of code (a stub) written in native code that acts as the entry point for calls from the V8 runtime to WebAssembly functions. This stub is responsible for setting up the necessary environment and passing the correct parameters to the WASM function.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The isolate.\"\n                    },\n                    {\n                        \"name\": \"sig\",\n                        \"type\": \"const wasm::CanonicalSig*\",\n                        \"purpose\": \"The canonical signature of the Wasm function.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Handle<Code>\",\n                    \"description\": \"A handle to the compiled code.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"wasm::CanonicalSig\",\n                    \"Handle\",\n                    \"Code\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE Handle<Code> CompileCWasmEntry(Isolate*,\n                                                         const wasm::CanonicalSig*);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BuildInlinedJSToWasmWrapper\",\n                \"about\": \"Builds an inlined JavaScript to WebAssembly wrapper.\",\n                \"logic\": \"Constructs a wrapper function that bridges the gap between JavaScript and WebAssembly, allowing JavaScript code to call WebAssembly functions directly. This wrapper is inlined for performance, meaning the code is inserted directly into the calling JavaScript function, avoiding the overhead of a function call.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone.\"\n                    },\n                    {\n                        \"name\": \"mcgraph\",\n                        \"type\": \"MachineGraph*\",\n                        \"purpose\": \"The machine graph.\"\n                    },\n                    {\n                        \"name\": \"signature\",\n                        \"type\": \"const wasm::CanonicalSig*\",\n                        \"purpose\": \"The canonical signature.\"\n                    },\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The isolate.\"\n                    },\n                    {\n                        \"name\": \"spt\",\n                        \"type\": \"compiler::SourcePositionTable*\",\n                        \"purpose\": \"The source position table.\"\n                    },\n                    {\n                        \"name\": \"frame_state\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The frame state.\"\n                    },\n                    {\n                        \"name\": \"set_in_wasm_flag\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if in WASM flag needs to be set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"MachineGraph\",\n                    \"wasm::CanonicalSig\",\n                    \"Isolate\",\n                    \"compiler::SourcePositionTable\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE void BuildInlinedJSToWasmWrapper(\n                Zone* zone, MachineGraph* mcgraph, const wasm::CanonicalSig* signature,\n                Isolate* isolate, compiler::SourcePositionTable* spt, Node* frame_state,\n                bool set_in_wasm_flag);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"WasmAssemblerOptions\",\n                \"about\": \"Returns assembler options for Wasm compilation.\",\n                \"logic\": \"Provides specific configuration settings for the assembler used during WebAssembly compilation. These options may include flags related to code optimization, debugging information, and other aspects of code generation.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"AssemblerOptions\",\n                    \"description\": \"Assembler options.\"\n                },\n                \"dependencies\": [\n                    \"AssemblerOptions\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            AssemblerOptions WasmAssemblerOptions();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"WasmStubAssemblerOptions\",\n                \"about\": \"Returns assembler options for Wasm stub compilation.\",\n                \"logic\": \"Provides specific configuration settings for the assembler when compiling WebAssembly stubs, which are small pieces of code used to handle specific tasks like function calls or memory access. These options may be different from the options used for compiling the main WebAssembly code.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"AssemblerOptions\",\n                    \"description\": \"Assembler options.\"\n                },\n                \"dependencies\": [\n                    \"AssemblerOptions\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            AssemblerOptions WasmStubAssemblerOptions();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CreateMachineSignature\",\n                \"about\": \"Creates a machine signature from a given signature.\",\n                \"logic\": \"Converts a generic function signature into a machine-specific signature, taking into account the target architecture's calling conventions and data representations. This is necessary for generating efficient machine code for the function.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone.\"\n                    },\n                    {\n                        \"name\": \"sig\",\n                        \"type\": \"const Signature<T>*\",\n                        \"purpose\": \"The signature.\"\n                    },\n                    {\n                        \"name\": \"origin\",\n                        \"type\": \"wasm::CallOrigin\",\n                        \"purpose\": \"The call origin.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Signature<MachineRepresentation>*\",\n                    \"description\": \"A pointer to the created machine signature.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"Signature\",\n                    \"MachineRepresentation\",\n                    \"wasm::CallOrigin\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            Signature<MachineRepresentation>* CreateMachineSignature(\n                Zone* zone, const Signature<T>* sig, wasm::CallOrigin origin);\n        ]]></code>\n    </func>\n</file>\n```"
}