{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-gc-lowering.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-gc-lowering.cc\",\n        \"file_name\": \"wasm-gc-lowering.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"This file implements the WasmGCLowering class, which performs lowering of WebAssembly garbage collection (GC) related operations in the compiler pipeline.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for compiler, base utilities, and WebAssembly specific definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/wasm-gc-lowering.h\"\n\n            #include \"src/base/logging.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/compiler/access-builder.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/compiler-source-position-table.h\"\n            #include \"src/compiler/node-properties.h\"\n            #include \"src/compiler/opcodes.h\"\n            #include \"src/compiler/operator.h\"\n            #include \"src/compiler/wasm-graph-assembler.h\"\n            #include \"src/objects/heap-number.h\"\n            #include \"src/objects/string.h\"\n            #include \"src/wasm/object-access.h\"\n            #include \"src/wasm/wasm-engine.h\"\n            #include \"src/wasm/wasm-linkage.h\"\n            #include \"src/wasm/wasm-objects.h\"\n            #include \"src/wasm/wasm-subtyping.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmGCLowering\",\n            \"extends\": \"AdvancedReducer\",\n            \"about\": \"Reduces WebAssembly GC related nodes to lower-level machine operations.\",\n            \"attributes\": [\n                {\n                    \"name\": \"null_check_strategy_\",\n                    \"type\": \"NullCheckStrategy\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Determines the strategy for null checks (trap handler or explicit).\"\n                },\n                {\n                    \"name\": \"gasm_\",\n                    \"type\": \"WasmGraphAssembler\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Assembler for building machine code graphs.\"\n                },\n                {\n                    \"name\": \"module_\",\n                    \"type\": \"const wasm::WasmModule*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the WebAssembly module.\"\n                },\n                {\n                    \"name\": \"dead_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Represents the dead node in the graph.\"\n                },\n                {\n                    \"name\": \"mcgraph_\",\n                    \"type\": \"MachineGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The machine graph being lowered.\"\n                },\n                {\n                    \"name\": \"source_position_table_\",\n                    \"type\": \"SourcePositionTable*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Table to store source positions for nodes.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AdvancedReducer\",\n                \"WasmGraphAssembler\",\n                \"wasm::WasmModule\",\n                \"MachineGraph\",\n                \"SourcePositionTable\",\n                \"wasm::ValueType\",\n                \"wasm::HeapType\",\n                \"WasmTypeCheckConfig\",\n                \"AssertNotNullParameters\",\n                \"WasmFieldInfo\",\n                \"WasmElementInfo\",\n                \"ObjectAccess\",\n                \"TrapId\",\n                \"Builtin\",\n                \"Operator\",\n                \"AccessBuilder\",\n                \"WasmTrustedInstanceData\",\n                \"AssertNotNullParameters\",\n                \"WasmFieldInfo\",\n                \"WasmElementInfo\",\n                \"ObjectAccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            namespace internal {\n            namespace compiler {\n\n            namespace {\n            int TaggedOffset(FieldAccess access) {\n            DCHECK(access.base_is_tagged);\n            return wasm::ObjectAccess::ToTagged(access.offset);\n            }\n            }  // namespace\n\n            WasmGCLowering::WasmGCLowering(Editor* editor, MachineGraph* mcgraph,\n                                        const wasm::WasmModule* module,\n                                        bool disable_trap_handler,\n                                        SourcePositionTable* source_position_table)\n                : AdvancedReducer(editor),\n                null_check_strategy_(trap_handler::IsTrapHandlerEnabled() &&\n                                        V8_STATIC_ROOTS_BOOL && !disable_trap_handler\n                                    ? NullCheckStrategy::kTrapHandler\n                                    : NullCheckStrategy::kExplicit),\n                gasm_(mcgraph, mcgraph->zone()),\n                module_(module),\n                dead_(mcgraph->Dead()),\n                mcgraph_(mcgraph),\n                source_position_table_(source_position_table) {}\n\n            Reduction WasmGCLowering::Reduce(Node* node) {\n            switch (node->opcode()) {\n                case IrOpcode::kWasmTypeCheck:\n                return ReduceWasmTypeCheck(node);\n                case IrOpcode::kWasmTypeCheckAbstract:\n                return ReduceWasmTypeCheckAbstract(node);\n                case IrOpcode::kWasmTypeCast:\n                return ReduceWasmTypeCast(node);\n                case IrOpcode::kWasmTypeCastAbstract:\n                return ReduceWasmTypeCastAbstract(node);\n                case IrOpcode::kAssertNotNull:\n                return ReduceAssertNotNull(node);\n                case IrOpcode::kNull:\n                return ReduceNull(node);\n                case IrOpcode::kIsNull:\n                return ReduceIsNull(node);\n                case IrOpcode::kIsNotNull:\n                return ReduceIsNotNull(node);\n                case IrOpcode::kRttCanon:\n                return ReduceRttCanon(node);\n                case IrOpcode::kTypeGuard:\n                return ReduceTypeGuard(node);\n                case IrOpcode::kWasmAnyConvertExtern:\n                return ReduceWasmAnyConvertExtern(node);\n                case IrOpcode::kWasmExternConvertAny:\n                return ReduceWasmExternConvertAny(node);\n                case IrOpcode::kWasmStructGet:\n                return ReduceWasmStructGet(node);\n                case IrOpcode::kWasmStructSet:\n                return ReduceWasmStructSet(node);\n                case IrOpcode::kWasmArrayGet:\n                return ReduceWasmArrayGet(node);\n                case IrOpcode::kWasmArraySet:\n                return ReduceWasmArraySet(node);\n                case IrOpcode::kWasmArrayLength:\n                return ReduceWasmArrayLength(node);\n                case IrOpcode::kWasmArrayInitializeLength:\n                return ReduceWasmArrayInitializeLength(node);\n                case IrOpcode::kStringAsWtf16:\n                return ReduceStringAsWtf16(node);\n                case IrOpcode::kStringPrepareForGetCodeunit:\n                return ReduceStringPrepareForGetCodeunit(node);\n                default:\n                return NoChange();\n            }\n            }\n\n            Node* WasmGCLowering::Null(wasm::ValueType type) {\n            RootIndex index =\n                type.use_wasm_null() ? RootIndex::kWasmNull : RootIndex::kNullValue;\n            return gasm_.LoadImmutable(MachineType::Pointer(), gasm_.LoadRootRegister(),\n                                    IsolateData::root_slot_offset(index));\n            }\n\n            Node* WasmGCLowering::IsNull(Node* object, wasm::ValueType type) {\n            #if V8_STATIC_ROOTS_BOOL\n            Node* null_value = gasm_.UintPtrConstant(\n                type.use_wasm_null() ? StaticReadOnlyRoot::kWasmNull\n                                    : StaticReadOnlyRoot::kNullValue);\n            #else\n            Node* null_value = Null(type);\n            #endif\n            return gasm_.TaggedEqual(object, null_value);\n            }\n\n            // TODO(manoskouk): Use the Callbacks infrastructure from wasm-compiler.h to\n            // unify all check/cast implementations.\n            // TODO(manoskouk): Find a way to optimize branches on typechecks.\n            Reduction WasmGCLowering::ReduceWasmTypeCheck(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kWasmTypeCheck);\n\n            Node* object = node->InputAt(0);\n            Node* rtt = node->InputAt(1);\n            Node* effect_input = NodeProperties::GetEffectInput(node);\n            Node* control_input = NodeProperties::GetControlInput(node);\n            auto config = OpParameter<WasmTypeCheckConfig>(node->op());\n            int rtt_depth = wasm::GetSubtypingDepth(module_, config.to.ref_index());\n            bool object_can_be_null = config.from.is_nullable();\n            bool object_can_be_i31 =\n                wasm::IsSubtypeOf(wasm::kWasmI31Ref.AsNonNull(), config.from, module_);\n\n            gasm_.InitializeEffectControl(effect_input, control_input);\n\n            auto end_label = gasm_.MakeLabel(MachineRepresentation::kWord32);\n            bool is_cast_from_any = config.from.is_reference_to(wasm::HeapType::kAny);\n\n            // If we are casting from any and null results in check failure, then the\n            // {IsDataRefMap} check below subsumes the null check. Otherwise, perform\n            // an explicit null check now.\n            if (object_can_be_null && (!is_cast_from_any || config.to.is_nullable())) {\n                const int kResult = config.to.is_nullable() ? 1 : 0;\n                gasm_.GotoIf(IsNull(object, wasm::kWasmAnyRef), &end_label,\n                            BranchHint::kFalse, gasm_.Int32Constant(kResult));\n            }\n\n            if (object_can_be_i31) {\n                gasm_.GotoIf(gasm_.IsSmi(object), &end_label, gasm_.Int32Constant(0));\n            }\n\n            Node* map = gasm_.LoadMap(object);\n\n            if (module_->type(config.to.ref_index()).is_final) {\n                gasm_.Goto(&end_label, gasm_.TaggedEqual(map, rtt));\n            } else {\n                // First, check if types happen to be equal. This has been shown to give\n                // large speedups.\n                gasm_.GotoIf(gasm_.TaggedEqual(map, rtt), &end_label, BranchHint::kTrue,\n                            gasm_.Int32Constant(1));\n\n                // Check if map instance type identifies a wasm object.\n                if (is_cast_from_any) {\n                Node* is_wasm_obj = gasm_.IsDataRefMap(map);\n                gasm_.GotoIfNot(is_wasm_obj, &end_label, BranchHint::kTrue,\n                                gasm_.Int32Constant(0));\n                }\n\n                Node* type_info = gasm_.LoadWasmTypeInfo(map);\n                DCHECK_GE(rtt_depth, 0);\n                // If the depth of the rtt is known to be less that the minimum supertype\n                // array length, we can access the supertype without bounds-checking the\n                // supertype array.\n                if (static_cast<uint32_t>(rtt_depth) >= wasm::kMinimumSupertypeArraySize) {\n                Node* supertypes_length =\n                    gasm_.BuildChangeSmiToIntPtr(gasm_.LoadImmutableFromObject(\n                        MachineType::TaggedSigned(), type_info,\n                        wasm::ObjectAccess::ToTagged(\n                            WasmTypeInfo::kSupertypesLengthOffset)));\n                gasm_.GotoIfNot(gasm_.UintLessThan(gasm_.IntPtrConstant(rtt_depth),\n                                                    supertypes_length),\n                                &end_label, BranchHint::kTrue, gasm_.Int32Constant(0));\n                }\n\n                Node* maybe_match = gasm_.LoadImmutableFromObject(\n                    MachineType::TaggedPointer(), type_info,\n                    wasm::ObjectAccess::ToTagged(WasmTypeInfo::kSupertypesOffset +\n                                                kTaggedSize * rtt_depth));\n\n                gasm_.Goto(&end_label, gasm_.TaggedEqual(maybe_match, rtt));\n            }\n\n            gasm_.Bind(&end_label);\n\n            ReplaceWithValue(node, end_label.PhiAt(0), gasm_.effect(), gasm_.control());\n            node->Kill();\n            return Replace(end_label.PhiAt(0));  // Meaningless argument.\n            }\n\n            Reduction WasmGCLowering::ReduceWasmTypeCheckAbstract(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kWasmTypeCheckAbstract);\n\n            Node* object = node->InputAt(0);\n            Node* effect_input = NodeProperties::GetEffectInput(node);\n            Node* control_input = NodeProperties::GetControlInput(node);\n            WasmTypeCheckConfig config = OpParameter<WasmTypeCheckConfig>(node->op());\n            const bool object_can_be_null = config.from.is_nullable();\n            const bool null_succeeds = config.to.is_nullable();\n            const bool object_can_be_i31 =\n                wasm::IsSubtypeOf(wasm::kWasmI31Ref.AsNonNull(), config.from, module_) ||\n                config.from.heap_representation() == wasm::HeapType::kExtern;\n\n            gasm_.InitializeEffectControl(effect_input, control_input);\n\n            Node* result = nullptr;\n            auto end_label = gasm_.MakeLabel(MachineRepresentation::kWord32);\n\n            wasm::HeapType::Representation to_rep = config.to.heap_representation();\n            do {\n                // The none-types only perform a null check. They need no control flow.\n                if (to_rep == wasm::HeapType::kNone ||\n                    to_rep == wasm::HeapType::kNoExtern ||\n                    to_rep == wasm::HeapType::kNoFunc || to_rep == wasm::HeapType::kNoExn) {\n                result = IsNull(object, config.from);\n                break;\n                }\n                // Null checks performed by any other type check need control flow. We can\n                // skip the null check if null fails, because it's covered by the Smi check\n                // or instance type check we'll do later.\n                if (object_can_be_null && null_succeeds) {\n                const int kResult = null_succeeds ? 1 : 0;\n                gasm_.GotoIf(IsNull(object, wasm::kWasmAnyRef), &end_label,\n                            BranchHint::kFalse, gasm_.Int32Constant(kResult));\n                }\n                // i31 is special in that the Smi check is the last thing to do.\n                if (to_rep == wasm::HeapType::kI31) {\n                // If earlier optimization passes reached the limit of possible graph\n                // transformations, we could DCHECK(object_can_be_i31) here.\n                result = object_can_be_i31 ? gasm_.IsSmi(object) : gasm_.Int32Constant(0);\n                break;\n                }\n                if (to_rep == wasm::HeapType::kEq) {\n                if (object_can_be_i31) {\n                    gasm_.GotoIf(gasm_.IsSmi(object), &end_label, BranchHint::kFalse,\n                                gasm_.Int32Constant(1));\n                }\n                result = gasm_.IsDataRefMap(gasm_.LoadMap(object));\n                break;\n                }\n                // array, struct, string: i31 fails.\n                if (object_can_be_i31) {\n                gasm_.GotoIf(gasm_.IsSmi(object), &end_label, BranchHint::kFalse,\n                                gasm_.Int32Constant(0));\n                }\n                if (to_rep == wasm::HeapType::kArray) {\n                result = gasm_.HasInstanceType(object, WASM_ARRAY_TYPE);\n                break;\n                }\n                if (to_rep == wasm::HeapType::kStruct) {\n                result = gasm_.HasInstanceType(object, WASM_STRUCT_TYPE);\n                break;\n                }\n                if (to_rep == wasm::HeapType::kString ||\n                    to_rep == wasm::HeapType::kExternString) {\n                Node* instance_type = gasm_.LoadInstanceType(gasm_.LoadMap(object));\n                result = gasm_.Uint32LessThan(instance_type,\n                                                gasm_.Uint32Constant(FIRST_NONSTRING_TYPE));\n                break;\n                }\n                UNREACHABLE();\n            } while (false);\n\n            DCHECK_NOT_NULL(result);\n            if (end_label.IsUsed()) {\n                gasm_.Goto(&end_label, result);\n                gasm_.Bind(&end_label);\n                result = end_label.PhiAt(0);\n            }\n\n            ReplaceWithValue(node, result, gasm_.effect(), gasm_.control());\n            node->Kill();\n            return Replace(result);  // Meaningless argument.\n            }\n\n            Reduction WasmGCLowering::ReduceWasmTypeCast(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kWasmTypeCast);\n\n            Node* object = node->InputAt(0);\n            Node* rtt = node->InputAt(1);\n            Node* effect_input = NodeProperties::GetEffectInput(node);\n            Node* control_input = NodeProperties::GetControlInput(node);\n            auto config = OpParameter<WasmTypeCheckConfig>(node->op());\n            int rtt_depth = wasm::GetSubtypingDepth(module_, config.to.ref_index());\n            bool object_can_be_null = config.from.is_nullable();\n            bool object_can_be_i31 =\n                wasm::IsSubtypeOf(wasm::kWasmI31Ref.AsNonNull(), config.from, module_);\n\n            gasm_.InitializeEffectControl(effect_input, control_input);\n\n            auto end_label = gasm_.MakeLabel();\n            bool is_cast_from_any = config.from.is_reference_to(wasm::HeapType::kAny);\n\n            // If we are casting from any and null results in check failure, then the\n            // {IsDataRefMap} check below subsumes the null check. Otherwise, perform\n            // an explicit null check now.\n            if (object_can_be_null && (!is_cast_from_any || config.to.is_nullable())) {\n                Node* is_null = IsNull(object, wasm::kWasmAnyRef);\n                if (config.to.is_nullable()) {\n                gasm_.GotoIf(is_null, &end_label, BranchHint::kFalse);\n                } else if (!v8_flags.experimental_wasm_skip_null_checks) {\n                gasm_.TrapIf(is_null, TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                }\n            }\n\n            if (object_can_be_i31) {\n                gasm_.TrapIf(gasm_.IsSmi(object), TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n            }\n\n            Node* map = gasm_.LoadMap(object);\n\n            if (module_->type(config.to.ref_index()).is_final) {\n                gasm_.TrapUnless(gasm_.TaggedEqual(map, rtt), TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                gasm_.Goto(&end_label);\n            } else {\n                // First, check if types happen to be equal. This has been shown to give\n                // large speedups.\n                gasm_.GotoIf(gasm_.TaggedEqual(map, rtt), &end_label, BranchHint::kTrue);\n\n                // Check if map instance type identifies a wasm object.\n                if (is_cast_from_any) {\n                Node* is_wasm_obj = gasm_.IsDataRefMap(map);\n                gasm_.TrapUnless(is_wasm_obj, TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                }\n\n                Node* type_info = gasm_.LoadWasmTypeInfo(map);\n                DCHECK_GE(rtt_depth, 0);\n                // If the depth of the rtt is known to be less that the minimum supertype\n                // array length, we can access the supertype without bounds-checking the\n                // supertype array.\n                if (static_cast<uint32_t>(rtt_depth) >= wasm::kMinimumSupertypeArraySize) {\n                Node* supertypes_length =\n                    gasm_.BuildChangeSmiToIntPtr(gasm_.LoadImmutableFromObject(\n                        MachineType::TaggedSigned(), type_info,\n                        wasm::ObjectAccess::ToTagged(\n                            WasmTypeInfo::kSupertypesLengthOffset)));\n                gasm_.TrapUnless(gasm_.UintLessThan(gasm_.IntPtrConstant(rtt_depth),\n                                                    supertypes_length),\n                                TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                }\n\n                Node* maybe_match = gasm_.LoadImmutableFromObject(\n                    MachineType::TaggedPointer(), type_info,\n                    wasm::ObjectAccess::ToTagged(WasmTypeInfo::kSupertypesOffset +\n                                                kTaggedSize * rtt_depth));\n\n                gasm_.TrapUnless(gasm_.TaggedEqual(maybe_match, rtt),\n                                TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                gasm_.Goto(&end_label);\n            }\n\n            gasm_.Bind(&end_label);\n\n            ReplaceWithValue(node, object, gasm_.effect(), gasm_.control());\n            node->Kill();\n            return Replace(object);\n            }\n\n            Reduction WasmGCLowering::ReduceWasmTypeCastAbstract(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kWasmTypeCastAbstract);\n\n            Node* object = node->InputAt(0);\n            Node* effect_input = NodeProperties::GetEffectInput(node);\n            Node* control_input = NodeProperties::GetControlInput(node);\n            WasmTypeCheckConfig config = OpParameter<WasmTypeCheckConfig>(node->op());\n            const bool object_can_be_null = config.from.is_nullable();\n            const bool null_succeeds = config.to.is_nullable();\n            const bool object_can_be_i31 =\n                wasm::IsSubtypeOf(wasm::kWasmI31Ref.AsNonNull(), config.from, module_) ||\n                config.from.heap_representation() == wasm::HeapType::kExtern;\n\n            gasm_.InitializeEffectControl(effect_input, control_input);\n\n            auto end_label = gasm_.MakeLabel();\n\n            wasm::HeapType::Representation to_rep = config.to.heap_representation();\n\n            do {\n                // The none-types only perform a null check.\n                if (to_rep == wasm::HeapType::kNone ||\n                    to_rep == wasm::HeapType::kNoExtern ||\n                    to_rep == wasm::HeapType::kNoFunc || to_rep == wasm::HeapType::kNoExn) {\n                gasm_.TrapUnless(IsNull(object, config.from), TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                break;\n                }\n                // Null checks performed by any other type cast can be skipped if null\n                // fails, because it's covered by the Smi check\n                // or instance type check we'll do later.\n                if (object_can_be_null && null_succeeds &&\n                    !v8_flags.experimental_wasm_skip_null_checks) {\n                gasm_.GotoIf(IsNull(object, config.from), &end_label, BranchHint::kFalse);\n                }\n                if (to_rep == wasm::HeapType::kI31) {\n                // If earlier optimization passes reached the limit of possible graph\n                // transformations, we could DCHECK(object_can_be_i31) here.\n                Node* success =\n                    object_can_be_i31 ? gasm_.IsSmi(object) : gasm_.Int32Constant(0);\n                gasm_.TrapUnless(success, TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                break;\n                }\n                if (to_rep == wasm::HeapType::kEq) {\n                if (object_can_be_i31) {\n                    gasm_.GotoIf(gasm_.IsSmi(object), &end_label, BranchHint::kFalse);\n                }\n                gasm_.TrapUnless(gasm_.IsDataRefMap(gasm_.LoadMap(object)),\n                                TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                break;\n                }\n                // array, struct, string: i31 fails.\n                if (object_can_be_i31) {\n                gasm_.TrapIf(gasm_.IsSmi(object), TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                }\n                if (to_rep == wasm::HeapType::kArray) {\n                gasm_.TrapUnless(gasm_.HasInstanceType(object, WASM_ARRAY_TYPE),\n                                TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                break;\n                }\n                if (to_rep == wasm::HeapType::kStruct) {\n                gasm_.TrapUnless(gasm_.HasInstanceType(object, WASM_STRUCT_TYPE),\n                                TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                break;\n                }\n                if (to_rep == wasm::HeapType::kString ||\n                    to_rep == wasm::HeapType::kExternString) {\n                Node* instance_type = gasm_.LoadInstanceType(gasm_.LoadMap(object));\n                gasm_.TrapUnless(\n                    gasm_.Uint32LessThan(instance_type,\n                                        gasm_.Uint32Constant(FIRST_NONSTRING_TYPE)),\n                    TrapId::kTrapIllegalCast);\n                UpdateSourcePosition(gasm_.effect(), node);\n                break;\n                }\n                UNREACHABLE();\n            } while (false);\n\n            if (end_label.IsUsed()) {\n                gasm_.Goto(&end_label);\n                gasm_.Bind(&end_label);\n            }\n\n            ReplaceWithValue(node, object, gasm_.effect(), gasm_.control());\n            node->Kill();\n            return Replace(object);\n            }\n\n            Reduction WasmGCLowering::ReduceAssertNotNull(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kAssertNotNull);\n            Node* effect = NodeProperties::GetEffectInput(node);\n            Node* control = NodeProperties::GetControlInput(node);\n            Node* object = NodeProperties::GetValueInput(node, 0);\n            gasm_.InitializeEffectControl(effect, control);\n            auto op_parameter = OpParameter<AssertNotNullParameters>(node->op());\n            // When able, implement a non-null assertion by loading from the object just\n            // after the map word. This will trap for null and be handled by the trap\n            // handler.\n            if (op_parameter.trap_id == TrapId::kTrapNullDereference) {\n                if (!v8_flags.experimental_wasm_skip_null_checks) {\n                // For supertypes of i31ref, we would need to check for i31ref anyway\n                // before loading from the object, so we might as well just check directly\n                // for null.\n                // For subtypes of externref, we use JS null, so we have to check\n                // explicitly.\n                if (null_check_strategy_ == NullCheckStrategy::kExplicit ||\n                    wasm::IsSubtypeOf(wasm::kWasmI31Ref.AsNonNull(), op_parameter.type,\n                                    module_) ||\n                    !op_parameter.type.use_wasm_null()) {\n                    gasm_.TrapIf(IsNull(object, op_parameter.type), op_parameter.trap_id);\n                    UpdateSourcePosition(gasm_.effect(), node);\n                } else {\n                    static_assert(WasmStruct::kHeaderSize > kTaggedSize);\n                    static_assert(WasmArray::kHeaderSize > kTaggedSize);\n                    static_assert(WasmInternalFunction::kHeaderSize > kTaggedSize);\n                    Node* trap_null = gasm_.LoadTrapOnNull(\n                        MachineType::Int32(), object,\n                        gasm_.IntPtrConstant(wasm::ObjectAccess::ToTagged(kTaggedSize)));\n                    UpdateSourcePosition(trap_null, node);\n                }\n                }\n            } else {\n                gasm_.TrapIf(IsNull(object, op_parameter.type), op_parameter.trap_id);\n                UpdateSourcePosition(gasm_.effect(), node);\n            }\n\n            ReplaceWithValue(node, object, gasm_.effect(), gasm_.control());\n            node->Kill();\n            return Replace(object);\n            }\n\n            Reduction WasmGCLowering::ReduceNull(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kNull);\n            auto type = OpParameter<wasm::ValueType>(node->op());\n            return Replace(Null(type));\n            }\n\n            Reduction WasmGCLowering::ReduceIsNull(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kIsNull);\n            Node* object = NodeProperties::GetValueInput(node, 0);\n            auto type = OpParameter<wasm::ValueType>(node->op());\n            return Replace(IsNull(object, type));\n            }\n\n            Reduction WasmGCLowering::ReduceIsNotNull(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kIsNotNull);\n            Node* object = NodeProperties::GetValueInput(node, 0);\n            auto type = OpParameter<wasm::ValueType>(node->op());\n            return Replace(\n                gasm_.Word32Equal(IsNull(object, type), gasm_.Int32Constant(0)));\n            }\n\n            Reduction WasmGCLowering::ReduceRttCanon(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kRttCanon);\n            int type_index = OpParameter<int>(node->op());\n            Node* instance_node = node->InputAt(0);\n            Node* maps_list = gasm_.LoadImmutable(\n                MachineType::TaggedPointer(), instance_node,\n                WasmTrustedInstanceData::kManagedObjectMapsOffset - kHeapObjectTag);\n            return Replace(gasm_.LoadImmutable(\n                MachineType::TaggedPointer(), maps_list,\n                wasm::ObjectAccess::ElementOffsetInTaggedFixedArray(type_index)));\n            }\n\n            Reduction WasmGCLowering::ReduceTypeGuard(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kTypeGuard);\n            Node* alias = NodeProperties::GetValueInput(node, 0);\n            ReplaceWithValue(node, alias);\n            node->Kill();\n            return Replace(alias);\n            }\n\n            namespace {\n            constexpr int32_t kInt31MaxValue = 0x3fffffff;\n            constexpr int32_t kInt31MinValue = -kInt31MaxValue - 1;\n            }  // namespace\n\n            Reduction WasmGCLowering::ReduceWasmAnyConvertExtern(Node* node) {\n            DCHECK_EQ(node->opcode(), IrOpcode::kWasmAnyConvertExtern);\n            Node* input = NodeProperties::GetValueInput(node, 0);\n            Node* effect = NodeProperties::GetEffectInput(node);\n            Node* control = NodeProperties::GetControlInput(node);\n            gasm_.InitializeEffectControl(effect, control);\n\n            auto end_label = gasm_.MakeLabel(MachineRepresentation::kTagged);\n            auto null_label = gasm_.MakeLabel();\n            auto smi_label = gasm_.MakeLabel();\n            auto int_to_smi_label = gasm_.MakeLabel();\n            auto heap_number_label = gasm_.MakeLabel();\n\n            gasm_.GotoIf(IsNull(input, wasm::kWasmExternRef), &null_label);\n            gasm_.GotoIf(gasm_.IsSmi(input), &smi_label);\n            Node* is_heap_number = gasm_.HasInstanceType(input, HEAP_NUMBER_TYPE);\n            gasm_.GotoIf(is_heap_number, &heap_number_label);\n            // For anything else, just pass through the value.\n            gasm_.Goto(&end_label, input);\n\n            gasm_.Bind(&null_label);\n            gasm_.Goto(&end_label, Null(wasm::kWasmNullRef));\n\n            // Canonicalize SMI.\n            gasm_.Bind(&smi_label);\n            if constexpr (SmiValuesAre31Bits()) {\n                gasm_.Goto(&end_label, input);\n            } else {\n                auto to_heap_number_label = gasm_.MakeLabel();\n                Node* int_value = gasm_.BuildChangeSmiToInt32(input);\n\n                // Convert to heap number if the int32 does not fit into an i31ref.\n                gasm_.GotoIf(\n                    gasm_.Int32LessThan(gasm_.Int32Constant(kInt31MaxValue), int_value),\n                    &to_heap_number_label);\n                gasm_.GotoIf(\n                    gasm_.Int32LessThan(int_value, gasm_.Int32Constant(kInt31MinValue)),\n                    &to_heap_number_label);\n                gasm_.Goto(&end_label, input);\n\n"
}