{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/read-only-deserializer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/read-only-deserializer.cc\",\n        \"file_name\": \"read-only-deserializer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Deserializes the read-only heap from a snapshot into the isolate.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for snapshot deserialization, heap management, object handling, and logging.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/read-only-deserializer.h\"\n\n#include \"src/handles/handles-inl.h\"\n#include \"src/heap/heap-inl.h\"\n#include \"src/heap/read-only-heap.h\"\n#include \"src/logging/counters-scopes.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/slots.h\"\n#include \"src/snapshot/embedded/embedded-data-inl.h\"\n#include \"src/snapshot/read-only-serializer-deserializer.h\"\n#include \"src/snapshot/snapshot-data.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"Deserializes the read-only heap image from a byte source. It handles allocation of pages, copying of segments, and relocation of pointers within the read-only heap.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"SnapshotByteSource\",\n                \"ReadOnlySpace\",\n                \"Bytecode\",\n                \"ReadOnlyPageMetadata\",\n                \"ro::BitSet\",\n                \"ro::EncodedTagged\",\n                \"ReadOnlyRoots\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ReadOnlyHeapImageDeserializer final {\n public:\n  static void Deserialize(Isolate* isolate, SnapshotByteSource* source) {\n    ReadOnlyHeapImageDeserializer{isolate, source}.DeserializeImpl();\n  }\n\n private:\n  using Bytecode = ro::Bytecode;\n\n  ReadOnlyHeapImageDeserializer(Isolate* isolate, SnapshotByteSource* source)\n      : source_(source), isolate_(isolate) {}\n\n  void DeserializeImpl() {\n    while (true) {\n      int bytecode_as_int = source_->Get();\n      DCHECK_LT(bytecode_as_int, ro::kNumberOfBytecodes);\n      switch (static_cast<Bytecode>(bytecode_as_int)) {\n        case Bytecode::kAllocatePage:\n          AllocatePage(false);\n          break;\n        case Bytecode::kAllocatePageAt:\n          AllocatePage(true);\n          break;\n        case Bytecode::kSegment:\n          DeserializeSegment();\n          break;\n        case Bytecode::kRelocateSegment:\n          UNREACHABLE();  // Handled together with kSegment.\n        case Bytecode::kReadOnlyRootsTable:\n          DeserializeReadOnlyRootsTable();\n          break;\n        case Bytecode::kFinalizeReadOnlySpace:\n          ro_space()->FinalizeSpaceForDeserialization();\n          return;\n      }\n    }\n  }\n\n  void AllocatePage(bool fixed_offset) {\n    CHECK_EQ(V8_STATIC_ROOTS_BOOL, fixed_offset);\n    size_t expected_page_index = static_cast<size_t>(source_->GetUint30());\n    size_t actual_page_index = static_cast<size_t>(-1);\n    size_t area_size_in_bytes = static_cast<size_t>(source_->GetUint30());\n    if (fixed_offset) {\n#ifdef V8_COMPRESS_POINTERS\n      uint32_t compressed_page_addr = source_->GetUint32();\n      Address pos = isolate_->cage_base() + compressed_page_addr;\n      actual_page_index = ro_space()->AllocateNextPageAt(pos);\n#else\n      UNREACHABLE();\n#endif  // V8_COMPRESS_POINTERS\n    } else {\n      actual_page_index = ro_space()->AllocateNextPage();\n    }\n    CHECK_EQ(actual_page_index, expected_page_index);\n    ro_space()->InitializePageForDeserialization(PageAt(actual_page_index),\n                                                 area_size_in_bytes);\n  }\n\n  void DeserializeSegment() {\n    uint32_t page_index = source_->GetUint30();\n    ReadOnlyPageMetadata* page = PageAt(page_index);\n\n    // Copy over raw contents.\n    Address start = page->area_start() + source_->GetUint30();\n    int size_in_bytes = source_->GetUint30();\n    CHECK_LE(start + size_in_bytes, page->area_end());\n    source_->CopyRaw(reinterpret_cast<void*>(start), size_in_bytes);\n\n    if (!V8_STATIC_ROOTS_BOOL) {\n      uint8_t relocate_marker_bytecode = source_->Get();\n      CHECK_EQ(relocate_marker_bytecode, Bytecode::kRelocateSegment);\n      int tagged_slots_size_in_bits = size_in_bytes / kTaggedSize;\n      // The const_cast is unfortunate, but we promise not to mutate data.\n      uint8_t* data =\n          const_cast<uint8_t*>(source_->data() + source_->position());\n      ro::BitSet tagged_slots(data, tagged_slots_size_in_bits);\n      DecodeTaggedSlots(start, tagged_slots);\n      source_->Advance(static_cast<int>(tagged_slots.size_in_bytes()));\n    }\n  }\n\n  Address Decode(ro::EncodedTagged encoded) const {\n    ReadOnlyPageMetadata* page = PageAt(encoded.page_index);\n    return page->OffsetToAddress(encoded.offset * kTaggedSize);\n  }\n\n  void DecodeTaggedSlots(Address segment_start,\n                         const ro::BitSet& tagged_slots) {\n    DCHECK(!V8_STATIC_ROOTS_BOOL);\n    for (size_t i = 0; i < tagged_slots.size_in_bits(); i++) {\n      // TODO(jgruber): Depending on sparseness, different iteration methods\n      // could be more efficient.\n      if (!tagged_slots.contains(static_cast<int>(i))) continue;\n      Address slot_addr = segment_start + i * kTaggedSize;\n      Address obj_addr = Decode(ro::EncodedTagged::FromAddress(slot_addr));\n      Address obj_ptr = obj_addr + kHeapObjectTag;\n\n      Tagged_t* dst = reinterpret_cast<Tagged_t*>(slot_addr);\n      *dst = COMPRESS_POINTERS_BOOL\n                 ? V8HeapCompressionScheme::CompressObject(obj_ptr)\n                 : static_cast<Tagged_t>(obj_ptr);\n    }\n  }\n\n  ReadOnlyPageMetadata* PageAt(size_t index) const {\n    DCHECK_LT(index, ro_space()->pages().size());\n    return ro_space()->pages()[index];\n  }\n\n  void DeserializeReadOnlyRootsTable() {\n    ReadOnlyRoots roots(isolate_);\n    if (V8_STATIC_ROOTS_BOOL) {\n      roots.InitFromStaticRootsTable(isolate_->cage_base());\n    } else {\n      for (size_t i = 0; i < ReadOnlyRoots::kEntriesCount; i++) {\n        uint32_t encoded_as_int = source_->GetUint32();\n        Address rudolf = Decode(ro::EncodedTagged::FromUint32(encoded_as_int));\n        roots.read_only_roots_[i] = rudolf + kHeapObjectTag;\n      }\n    }\n  }\n\n  ReadOnlySpace* ro_space() const {\n    return isolate_->read_only_heap()->read_only_space();\n  }\n\n  SnapshotByteSource* const source_;\n  Isolate* const isolate_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Deserialize\",\n            \"parent\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"Static method to deserialize the read-only heap image.\",\n            \"logic\": \"Creates an instance of ReadOnlyHeapImageDeserializer and calls the DeserializeImpl method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to deserialize into.\"\n                },\n                {\n                    \"name\": \"source\",\n                    \"type\": \"SnapshotByteSource*\",\n                    \"purpose\": \"The source of the snapshot data.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReadOnlyHeapImageDeserializer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void Deserialize(Isolate* isolate, SnapshotByteSource* source) {\n    ReadOnlyHeapImageDeserializer{isolate, source}.DeserializeImpl();\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeserializeImpl\",\n            \"parent\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"The main deserialization loop.\",\n            \"logic\": \"Reads bytecodes from the source and performs actions based on the bytecode, such as allocating pages, deserializing segments, and deserializing the read-only roots table.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"AllocatePage\",\n                \"DeserializeSegment\",\n                \"DeserializeReadOnlyRootsTable\",\n                \"ro_space\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void DeserializeImpl() {\n    while (true) {\n      int bytecode_as_int = source_->Get();\n      DCHECK_LT(bytecode_as_int, ro::kNumberOfBytecodes);\n      switch (static_cast<Bytecode>(bytecode_as_int)) {\n        case Bytecode::kAllocatePage:\n          AllocatePage(false);\n          break;\n        case Bytecode::kAllocatePageAt:\n          AllocatePage(true);\n          break;\n        case Bytecode::kSegment:\n          DeserializeSegment();\n          break;\n        case Bytecode::kRelocateSegment:\n          UNREACHABLE();  // Handled together with kSegment.\n        case Bytecode::kReadOnlyRootsTable:\n          DeserializeReadOnlyRootsTable();\n          break;\n        case Bytecode::kFinalizeReadOnlySpace:\n          ro_space()->FinalizeSpaceForDeserialization();\n          return;\n      }\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllocatePage\",\n            \"parent\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"Allocates a page in the read-only heap.\",\n            \"logic\": \"Allocates a page either at a fixed offset or at the next available location.  It initializes the page for deserialization.\",\n            \"parameters\": [\n                {\n                    \"name\": \"fixed_offset\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the page should be allocated at a fixed offset.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ro_space\",\n                \"PageAt\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void AllocatePage(bool fixed_offset) {\n    CHECK_EQ(V8_STATIC_ROOTS_BOOL, fixed_offset);\n    size_t expected_page_index = static_cast<size_t>(source_->GetUint30());\n    size_t actual_page_index = static_cast<size_t>(-1);\n    size_t area_size_in_bytes = static_cast<size_t>(source_->GetUint30());\n    if (fixed_offset) {\n#ifdef V8_COMPRESS_POINTERS\n      uint32_t compressed_page_addr = source_->GetUint32();\n      Address pos = isolate_->cage_base() + compressed_page_addr;\n      actual_page_index = ro_space()->AllocateNextPageAt(pos);\n#else\n      UNREACHABLE();\n#endif  // V8_COMPRESS_POINTERS\n    } else {\n      actual_page_index = ro_space()->AllocateNextPage();\n    }\n    CHECK_EQ(actual_page_index, expected_page_index);\n    ro_space()->InitializePageForDeserialization(PageAt(actual_page_index),\n                                                 area_size_in_bytes);\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeserializeSegment\",\n            \"parent\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"Deserializes a segment of the read-only heap.\",\n            \"logic\": \"Copies raw contents from the source into the specified segment. If V8_STATIC_ROOTS_BOOL is not enabled, it also relocates tagged slots within the segment.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PageAt\",\n                \"DecodeTaggedSlots\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void DeserializeSegment() {\n    uint32_t page_index = source_->GetUint30();\n    ReadOnlyPageMetadata* page = PageAt(page_index);\n\n    // Copy over raw contents.\n    Address start = page->area_start() + source_->GetUint30();\n    int size_in_bytes = source_->GetUint30();\n    CHECK_LE(start + size_in_bytes, page->area_end());\n    source_->CopyRaw(reinterpret_cast<void*>(start), size_in_bytes);\n\n    if (!V8_STATIC_ROOTS_BOOL) {\n      uint8_t relocate_marker_bytecode = source_->Get();\n      CHECK_EQ(relocate_marker_bytecode, Bytecode::kRelocateSegment);\n      int tagged_slots_size_in_bits = size_in_bytes / kTaggedSize;\n      // The const_cast is unfortunate, but we promise not to mutate data.\n      uint8_t* data =\n          const_cast<uint8_t*>(source_->data() + source_->position());\n      ro::BitSet tagged_slots(data, tagged_slots_size_in_bits);\n      DecodeTaggedSlots(start, tagged_slots);\n      source_->Advance(static_cast<int>(tagged_slots.size_in_bytes()));\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Decode\",\n            \"parent\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"Decodes an encoded tagged value to an address.\",\n            \"logic\": \"Retrieves the page metadata from the encoded page index and calculates the address based on the offset.\",\n            \"parameters\": [\n                {\n                    \"name\": \"encoded\",\n                    \"type\": \"ro::EncodedTagged\",\n                    \"purpose\": \"The encoded tagged value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Address\",\n                \"description\": \"The decoded address.\"\n            },\n            \"dependencies\": [\n                \"PageAt\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Address Decode(ro::EncodedTagged encoded) const {\n    ReadOnlyPageMetadata* page = PageAt(encoded.page_index);\n    return page->OffsetToAddress(encoded.offset * kTaggedSize);\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DecodeTaggedSlots\",\n            \"parent\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"Decodes tagged slots within a segment.\",\n            \"logic\": \"Iterates through the tagged slots and decodes the address for each slot.  The decoded address is then written to the slot.\",\n            \"parameters\": [\n                {\n                    \"name\": \"segment_start\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The start address of the segment.\"\n                },\n                {\n                    \"name\": \"tagged_slots\",\n                    \"type\": \"const ro::BitSet&\",\n                    \"purpose\": \"The bitset indicating which slots are tagged.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Decode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void DecodeTaggedSlots(Address segment_start,\n                         const ro::BitSet& tagged_slots) {\n    DCHECK(!V8_STATIC_ROOTS_BOOL);\n    for (size_t i = 0; i < tagged_slots.size_in_bits(); i++) {\n      // TODO(jgruber): Depending on sparseness, different iteration methods\n      // could be more efficient.\n      if (!tagged_slots.contains(static_cast<int>(i))) continue;\n      Address slot_addr = segment_start + i * kTaggedSize;\n      Address obj_addr = Decode(ro::EncodedTagged::FromAddress(slot_addr));\n      Address obj_ptr = obj_addr + kHeapObjectTag;\n\n      Tagged_t* dst = reinterpret_cast<Tagged_t*>(slot_addr);\n      *dst = COMPRESS_POINTERS_BOOL\n                 ? V8HeapCompressionScheme::CompressObject(obj_ptr)\n                 : static_cast<Tagged_t>(obj_ptr);\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PageAt\",\n            \"parent\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"Retrieves the ReadOnlyPageMetadata at the specified index.\",\n            \"logic\": \"Accesses the pages vector of the read-only space to retrieve the metadata.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the page.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ReadOnlyPageMetadata*\",\n                \"description\": \"The ReadOnlyPageMetadata at the specified index.\"\n            },\n            \"dependencies\": [\n                \"ro_space\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  ReadOnlyPageMetadata* PageAt(size_t index) const {\n    DCHECK_LT(index, ro_space()->pages().size());\n    return ro_space()->pages()[index];\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeserializeReadOnlyRootsTable\",\n            \"parent\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"Deserializes the read-only roots table.\",\n            \"logic\": \"Initializes the read-only roots table either from static roots or by decoding encoded tagged values from the source.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReadOnlyRoots\",\n                \"Decode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void DeserializeReadOnlyRootsTable() {\n    ReadOnlyRoots roots(isolate_);\n    if (V8_STATIC_ROOTS_BOOL) {\n      roots.InitFromStaticRootsTable(isolate_->cage_base());\n    } else {\n      for (size_t i = 0; i < ReadOnlyRoots::kEntriesCount; i++) {\n        uint32_t encoded_as_int = source_->GetUint32();\n        Address rudolf = Decode(ro::EncodedTagged::FromUint32(encoded_as_int));\n        roots.read_only_roots_[i] = rudolf + kHeapObjectTag;\n      }\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ro_space\",\n            \"parent\": \"ReadOnlyHeapImageDeserializer\",\n            \"about\": \"Returns a pointer to the read-only space.\",\n            \"logic\": \"Accesses the isolate's read-only heap to get the read-only space.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"ReadOnlySpace*\",\n                \"description\": \"A pointer to the read-only space.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  ReadOnlySpace* ro_space() const {\n    return isolate_->read_only_heap()->read_only_space();\n  }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ReadOnlyDeserializer\",\n            \"about\": \"Deserializes the read-only portion of a V8 snapshot.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Deserializer\",\n                \"SnapshotData\",\n                \"Isolate\",\n                \"ReadOnlyHeapImageDeserializer\",\n                \"ReadOnlyHeap\",\n                \"ReadOnlyRoots\",\n                \"Heap\",\n                \"ObjectPostProcessor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReadOnlyDeserializer::ReadOnlyDeserializer(Isolate* isolate,\n                                           const SnapshotData* data,\n                                           bool can_rehash)\n    : Deserializer(isolate, data->Payload(), data->GetMagicNumber(), false,\n                   can_rehash) {}\n\nvoid ReadOnlyDeserializer::DeserializeIntoIsolate() {\n  base::ElapsedTimer timer;\n  if (V8_UNLIKELY(v8_flags.profile_deserialization)) timer.Start();\n  NestedTimedHistogramScope histogram_timer(\n      isolate()->counters()->snapshot_deserialize_rospace());\n  HandleScope scope(isolate());\n\n  ReadOnlyHeapImageDeserializer::Deserialize(isolate(), source());\n  ReadOnlyHeap* ro_heap = isolate()->read_only_heap();\n  ro_heap->read_only_space()->RepairFreeSpacesAfterDeserialization();\n  PostProcessNewObjects();\n\n  ReadOnlyRoots roots(isolate());\n  roots.VerifyNameForProtectorsPages();\n#ifdef DEBUG\n  roots.VerifyTypes();\n  roots.VerifyNameForProtectors();\n#endif\n\n  if (should_rehash()) {\n    isolate()->heap()->InitializeHashSeed();\n    Rehash();\n  }\n\n  if (V8_UNLIKELY(v8_flags.profile_deserialization)) {\n    // ATTENTION: The Memory.json benchmark greps for this exact output. Do not\n    // change it without also updating Memory.json.\n    const int bytes = source()->length();\n    const double ms = timer.Elapsed().InMillisecondsF();\n    PrintF(\"[Deserializing read-only space (%d bytes) took %0.3f ms]\\n\", bytes,\n           ms);\n  }\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeserializeIntoIsolate\",\n            \"parent\": \"ReadOnlyDeserializer\",\n            \"about\": \"Deserializes the read-only snapshot data into the isolate.\",\n            \"logic\": \"Deserializes the read-only heap image, repairs free spaces, post-processes new objects, verifies read-only roots, and potentially rehashes objects if needed. Measures the deserialization time if profiling is enabled.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReadOnlyHeapImageDeserializer::Deserialize\",\n                \"ReadOnlyHeap\",\n                \"ReadOnlyRoots\",\n                \"Heap\",\n                \"PostProcessNewObjects\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ReadOnlyDeserializer::DeserializeIntoIsolate() {\n  base::ElapsedTimer timer;\n  if (V8_UNLIKELY(v8_flags.profile_deserialization)) timer.Start();\n  NestedTimedHistogramScope histogram_timer(\n      isolate()->counters()->snapshot_deserialize_rospace());\n  HandleScope scope(isolate());\n\n  ReadOnlyHeapImageDeserializer::Deserialize(isolate(), source());\n  ReadOnlyHeap* ro_heap = isolate()->read_only_heap();\n  ro_heap->read_only_space()->RepairFreeSpacesAfterDeserialization();\n  PostProcessNewObjects();\n\n  ReadOnlyRoots roots(isolate());\n  roots.VerifyNameForProtectorsPages();\n#ifdef DEBUG\n  roots.VerifyTypes();\n  roots.VerifyNameForProtectors();\n#endif\n\n  if (should_rehash()) {\n    isolate()->heap()->InitializeHashSeed();\n    Rehash();\n  }\n\n  if (V8_UNLIKELY(v8_flags.profile_deserialization)) {\n    // ATTENTION: The Memory.json benchmark greps for this exact output. Do not\n    // change it without also updating Memory.json.\n    const int bytes = source()->length();\n    const double ms = timer.Elapsed().InMillisecondsF();\n    PrintF(\"[Deserializing read-only space (%d bytes) took %0.3f ms]\\n\", bytes,\n           ms);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"NoExternalReferencesCallback\",\n            \"about\": \"A callback function to be used when no external references are provided during isolate creation.\",\n            \"logic\": \"Triggers a fatal error if a function or object template with references to native functions is deserialized from a snapshot but no external references were provided.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid NoExternalReferencesCallback() {\n  // The following check will trigger if a function or object template with\n  // references to native functions have been deserialized from snapshot, but\n  // no actual external references were provided when the isolate was created.\n  FATAL(\"No external references provided via API\");\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ObjectPostProcessor\",\n            \"about\": \"Post-processes newly deserialized objects in the read-only heap.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"EmbeddedData\",\n                \"AccessorInfo\",\n                \"FunctionTemplateInfo\",\n                \"Code\",\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ObjectPostProcessor final {\n public:\n  explicit ObjectPostProcessor(Isolate* isolate)\n      : isolate_(isolate), embedded_data_(EmbeddedData::FromBlob(isolate_)) {}\n\n  void Finalize() {\n#ifdef V8_ENABLE_SANDBOX\n    std::vector<ReadOnlyArtifacts::ExternalPointerRegistryEntry> registry;\n    registry.reserve(external_pointer_slots_.size());\n    for (auto& slot : external_pointer_slots_) {\n      registry.emplace_back(slot.Relaxed_LoadHandle(), slot.load(isolate_),\n                            slot.exact_tag());\n    }\n\n    isolate_->read_only_artifacts()->set_external_pointer_registry(\n        std::move(registry));\n#endif  // V8_ENABLE_SANDBOX\n  }\n#define POST_PROCESS_TYPE_LIST(V) \\\n  V(AccessorInfo)                 \\\n  V(FunctionTemplateInfo)         \\\n  V(Code)                         \\\n  V(SharedFunctionInfo)\n\n  V8_INLINE void PostProcessIfNeeded(Tagged<HeapObject> o,\n                                     InstanceType instance_type) {\n    DCHECK_EQ(o->map(isolate_)->instance_type(), instance_type);\n#define V(TYPE)                                       \\\n  if (InstanceTypeChecker::Is##TYPE(instance_type)) { \\\n    return PostProcess##TYPE(Cast<TYPE>(o));          \\\n  }\n    POST_PROCESS_TYPE_LIST(V)\n#undef V\n    // If we reach here, no postprocessing is needed for this object.\n  }\n#undef POST_PROCESS_TYPE_LIST\n\n private:\n  Address GetAnyExternalReferenceAt(int index, bool is_api_reference) const {\n    if (is_api_reference) {\n      const intptr_t* refs = isolate_->api_external_references();\n      Address address =\n          refs == nullptr\n              ? reinterpret_cast<Address>(NoExternalReferencesCallback)\n              : static_cast<Address>(refs[index]);\n      DCHECK_NE(address, kNullAddress);\n      return address;\n    }\n    // Note we allow `address` to be kNullAddress since some of our tests\n    // rely on this (e.g. when testing an incompletely initialized ER table).\n    return isolate_->external_reference_table_unsafe()->address(index);\n  }\n\n  void DecodeExternalPointerSlot(Tagged<HeapObject> host,\n                                 ExternalPointerSlot slot) {\n    // Constructing no_gc here is not the intended use pattern (instead we\n    // should pass it along the entire callchain); but there's little point of\n    // doing that here - all of the code in this file relies on GC being\n    // disabled, and that's guarded at entry points.\n    DisallowGarbageCollection no_gc;\n    auto encoded = ro::EncodedExternalReference::FromUint32(\n        slot.GetContentAsIndexAfterDeserialization(no_gc));\n    Address slot_value =\n        GetAnyExternalReferenceAt(encoded.index, encoded.is_api_reference);\n    DCHECK(slot.ExactTagIsKnown());\n    slot.init(isolate_, host, slot_value, slot.exact_tag());\n#ifdef V8_ENABLE_SANDBOX\n    // Register these slots during deserialization s.t. later isolates (which\n    // share the RO space we are currently deserializing) can properly\n    // initialize their external pointer table RO space. Note that slot values\n    // are only fully finalized at the end of deserialization, thus we only\n    // register the slot itself now and read the handle/value in Finalize.\n    external_pointer_slots_.emplace_back(slot);\n#endif  // V8_ENABLE_SANDBOX\n  }\n  void PostProcessAccessorInfo(Tagged<AccessorInfo> o) {\n    DecodeExternalPointerSlot(\n        o, o->RawExternalPointerField(AccessorInfo::kSetterOffset,\n                                      kAccessorInfoSetterTag));\n    DecodeExternalPointerSlot(o, o->RawExternalPointerField(\n                                     AccessorInfo::kMaybeRedirectedGetterOffset,\n                                     kAccessorInfoGetterTag));\n    if (USE_SIMULATOR_BOOL) o->init_getter_redirection(isolate_);\n  }\n  void PostProcessFunctionTemplateInfo(Tagged<FunctionTemplateInfo> o) {\n    DecodeExternalPointerSlot(\n        o, o->RawExternalPointerField(\n               FunctionTemplateInfo::kMaybeRedirectedCallbackOffset,\n               kFunctionTemplateInfoCallbackTag));\n    if (USE_SIMULATOR_BOOL) o->init_callback_redirection(isolate_);\n  }\n  void PostProcessCode(Tagged<Code> o) {\n    o->init_self_indirect_pointer(isolate_);\n    o->wrapper()->set_code(o);\n    // RO space only contains builtin Code objects which don't have an\n    // attached InstructionStream.\n    DCHECK(o->is_builtin());\n    DCHECK(!o->has_instruction_stream());\n    o->SetInstructionStartForOffHeapBuiltin(\n        isolate_,\n        EmbeddedData::FromBlob(isolate_).InstructionStartOf(o->builtin_id()));\n  }\n  void PostProcessSharedFunctionInfo(Tagged<SharedFunctionInfo> o) {\n    // Reset the id to avoid collisions - it must be unique in this isolate.\n    o->set_unique_id(isolate_->GetAndIncNextUniqueSfiId());\n  }\n\n  Isolate* const isolate_;\n  const EmbeddedData embedded_data_;\n\n#ifdef V8_ENABLE_SANDBOX\n  std::vector<ExternalPointerSlot> external_pointer_slots_;\n#endif  // V8_ENABLE_SANDBOX\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PostProcessIfNeeded\",\n            \"parent\": \"ObjectPostProcessor\",\n            \"about\": \"Performs post-processing on a heap object based on its instance type.\",\n            \"logic\": \"Checks the instance type of the heap object and calls the appropriate post-processing function. If no specific post-processing is needed, the function returns without doing anything.\",\n            \"parameters\": [\n                {\n                    \"name\": \"o\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The heap object to post-process.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type of the heap object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PostProcessAccessorInfo\",\n                \"PostProcessFunctionTemplateInfo\",\n                \"PostProcessCode\",\n                \"PostProcessSharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  V8_INLINE void PostProcessIfNeeded(Tagged<HeapObject> o,\n                                     InstanceType instance_type)"
}