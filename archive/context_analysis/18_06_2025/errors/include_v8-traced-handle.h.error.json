{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-traced-handle.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-traced-handle.h\",\n        \"file_name\": \"v8-traced-handle.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines traced handles for garbage collection in V8.  These handles allow C++ code to hold references to JavaScript objects that are tracked by the garbage collector.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers and V8-specific headers required for traced handle implementation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stddef.h>\n            #include <stdint.h>\n            #include <stdio.h>\n\n            #include <atomic>\n            #include <memory>\n            #include <type_traits>\n            #include <utility>\n\n            #include \"v8-internal.h\"            // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"        // NOLINT(build/include_directory)\n            #include \"v8-weak-callback-info.h\"  // NOLINT(build/include_directory)\n            #include \"v8config.h\"               // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TracedReferenceBase\",\n            \"extends\": \"api_internal::IndirectHandleBase\",\n            \"about\": \"Base class for traced references.  Provides basic functionality for managing a pointer to a GlobalHandles node.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"api_internal::IndirectHandleBase\",\n                \"std::atomic\",\n                \"internal::Address\",\n                \"Local\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class TracedReferenceBase : public api_internal::IndirectHandleBase {\n            public:\n            static_assert(sizeof(std::atomic<internal::Address*>) ==\n                            sizeof(internal::Address*));\n\n            /**\n            * If non-empty, destroy the underlying storage cell. |IsEmpty| will return\n            * true after this call.\n            */\n            V8_INLINE void Reset();\n\n            /**\n            * Construct a Local<Data> from this handle.\n            */\n            V8_INLINE Local<Data> Get(Isolate* isolate) const {\n                if (IsEmpty()) return Local<Data>();\n                return Local<Data>::New(isolate, this->value<Data>());\n            }\n\n            /**\n            * Returns true if this TracedReference is empty, i.e., has not been\n            * assigned an object. This version of IsEmpty is thread-safe.\n            */\n            bool IsEmptyThreadSafe() const { return GetSlotThreadSafe() == nullptr; }\n\n            protected:\n            V8_INLINE TracedReferenceBase() = default;\n\n            /**\n            * Update this reference in a thread-safe way.\n            */\n            void SetSlotThreadSafe(internal::Address* new_val) {\n                reinterpret_cast<std::atomic<internal::Address*>*>(&slot())->store(\n                    new_val, std::memory_order_relaxed);\n            }\n\n            /**\n            * Get this reference in a thread-safe way\n            */\n            const internal::Address* GetSlotThreadSafe() const {\n                return reinterpret_cast<const std::atomic<internal::Address*>*>(&slot())\n                    ->load(std::memory_order_relaxed);\n            }\n\n            V8_EXPORT void CheckValue() const;\n\n            friend class internal::BasicTracedReferenceExtractor;\n            template <typename F>\n            friend class Local;\n            template <typename U>\n            friend bool operator==(const TracedReferenceBase&, const Local<U>&);\n            friend bool operator==(const TracedReferenceBase&,\n                                    const TracedReferenceBase&);\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BasicTracedReference\",\n            \"extends\": \"TracedReferenceBase\",\n            \"about\": \"A traced handle with copy and move semantics. Base class for TracedReference.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"TracedReferenceBase\",\n                \"Local\",\n                \"Isolate\",\n                \"internal::TracedReferenceStoreMode\",\n                \"internal::TracedReferenceHandling\",\n                \"internal::GlobalizeTracedReference\",\n                \"Object\",\n                \"ReturnValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class BasicTracedReference : public TracedReferenceBase {\n            public:\n            /**\n            * Construct a Local<T> from this handle.\n            */\n            Local<T> Get(Isolate* isolate) const { return Local<T>::New(isolate, *this); }\n\n            template <class S>\n            V8_INLINE BasicTracedReference<S>& As() const {\n                return reinterpret_cast<BasicTracedReference<S>&>(\n                    const_cast<BasicTracedReference<T>&>(*this));\n            }\n\n            private:\n            /**\n            * An empty BasicTracedReference without storage cell.\n            */\n            BasicTracedReference() = default;\n\n            V8_INLINE static internal::Address* NewFromNonEmptyValue(\n                Isolate* isolate, T* that, internal::Address** slot,\n                internal::TracedReferenceStoreMode store_mode,\n                internal::TracedReferenceHandling reference_handling);\n\n            template <typename F>\n            friend class Local;\n            friend class Object;\n            template <typename F>\n            friend class TracedReference;\n            template <typename F>\n            friend class BasicTracedReference;\n            template <typename F>\n            friend class ReturnValue;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TracedReference\",\n            \"extends\": \"BasicTracedReference\",\n            \"about\": \"A traced handle without destructor that clears the handle. The embedder needs to ensure that the handle is not accessed once the V8 object has been reclaimed. For more details see BasicTracedReference.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"BasicTracedReference\",\n                \"Local\",\n                \"Isolate\",\n                \"std::is_base_of\",\n                \"internal::TracedReferenceStoreMode\",\n                \"internal::TracedReferenceHandling\",\n                \"internal::GlobalizeTracedReference\",\n                \"internal::MoveTracedReference\",\n                \"internal::CopyTracedReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class TracedReference : public BasicTracedReference<T> {\n            public:\n            struct IsDroppable {};\n\n            using BasicTracedReference<T>::Reset;\n\n            /**\n            * An empty TracedReference without storage cell.\n            */\n            V8_INLINE TracedReference() = default;\n\n            /**\n            * Construct a TracedReference from a Local.\n            *\n            * When the Local is non-empty, a new storage cell is created\n            * pointing to the same object.\n            */\n            template <class S>\n            TracedReference(Isolate* isolate, Local<S> that) : BasicTracedReference<T>() {\n                static_assert(std::is_base_of<T, S>::value, \"type check\");\n                if (V8_UNLIKELY(that.IsEmpty())) {\n                return;\n                }\n                this->slot() = this->NewFromNonEmptyValue(\n                    isolate, *that, &this->slot(),\n                    internal::TracedReferenceStoreMode::kInitializingStore,\n                    internal::TracedReferenceHandling::kDefault);\n            }\n\n            /**\n            * Construct a droppable TracedReference from a Local. Droppable means that V8\n            * is free to reclaim the pointee if it is unmodified and otherwise\n            * unreachable\n            *\n            * When the Local is non-empty, a new storage cell is created\n            * pointing to the same object.\n            */\n            template <class S>\n            TracedReference(Isolate* isolate, Local<S> that, IsDroppable)\n                : BasicTracedReference<T>() {\n                static_assert(std::is_base_of<T, S>::value, \"type check\");\n                if (V8_UNLIKELY(that.IsEmpty())) {\n                return;\n                }\n                this->slot() = this->NewFromNonEmptyValue(\n                    isolate, *that, &this->slot(),\n                    internal::TracedReferenceStoreMode::kInitializingStore,\n                    internal::TracedReferenceHandling::kDroppable);\n            }\n\n            /**\n            * Move constructor initializing TracedReference from an\n            * existing one.\n            */\n            V8_INLINE TracedReference(TracedReference&& other) noexcept {\n                // Forward to operator=.\n                *this = std::move(other);\n            }\n\n            /**\n            * Move constructor initializing TracedReference from an\n            * existing one.\n            */\n            template <typename S>\n            V8_INLINE TracedReference(TracedReference<S>&& other) noexcept {\n                // Forward to operator=.\n                *this = std::move(other);\n            }\n\n            /**\n            * Copy constructor initializing TracedReference from an\n            * existing one.\n            */\n            V8_INLINE TracedReference(const TracedReference& other) {\n                // Forward to operator=;\n                *this = other;\n            }\n\n            /**\n            * Copy constructor initializing TracedReference from an\n            * existing one.\n            */\n            template <typename S>\n            V8_INLINE TracedReference(const TracedReference<S>& other) {\n                // Forward to operator=;\n                *this = other;\n            }\n\n            /**\n            * Move assignment operator initializing TracedReference from an existing one.\n            */\n            V8_INLINE TracedReference& operator=(TracedReference&& rhs) noexcept;\n\n            /**\n            * Move assignment operator initializing TracedReference from an existing one.\n            */\n            template <class S>\n            V8_INLINE TracedReference& operator=(TracedReference<S>&& rhs) noexcept;\n\n            /**\n            * Copy assignment operator initializing TracedReference from an existing one.\n            */\n            V8_INLINE TracedReference& operator=(const TracedReference& rhs);\n\n            /**\n            * Copy assignment operator initializing TracedReference from an existing one.\n            */\n            template <class S>\n            V8_INLINE TracedReference& operator=(const TracedReference<S>& rhs);\n\n            /**\n            * Always resets the reference. Creates a new reference from `other` if it is\n            * non-empty.\n            */\n            template <class S>\n            V8_INLINE void Reset(Isolate* isolate, const Local<S>& other);\n\n            /**\n            * Always resets the reference. Creates a new reference from `other` if it is\n            * non-empty. The new reference is droppable, see constructor.\n            */\n            template <class S>\n            V8_INLINE void Reset(Isolate* isolate, const Local<S>& other, IsDroppable);\n\n            template <class S>\n            V8_INLINE TracedReference<S>& As() const {\n                return reinterpret_cast<TracedReference<S>&>(\n                    const_cast<TracedReference<T>&>(*this));\n            }\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NewFromNonEmptyValue\",\n            \"parent\": \"BasicTracedReference\",\n            \"about\": \"Creates a new traced reference from a non-empty value.\",\n            \"logic\": \"Calls GlobalizeTracedReference to create a global handle and associate it with the provided slot.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"that\",\n                    \"type\": \"T*\",\n                    \"purpose\": \"The object to be traced.\"\n                },\n                {\n                    \"name\": \"slot\",\n                    \"type\": \"internal::Address**\",\n                    \"purpose\": \"The slot where the address of the global handle will be stored.\"\n                },\n                {\n                    \"name\": \"store_mode\",\n                    \"type\": \"internal::TracedReferenceStoreMode\",\n                    \"purpose\": \"The store mode.\"\n                },\n                {\n                    \"name\": \"reference_handling\",\n                    \"type\": \"internal::TracedReferenceHandling\",\n                    \"purpose\": \"The reference handling mode.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"internal::Address*\",\n                \"description\": \"The address of the newly created global handle.\"\n            },\n            \"dependencies\": [\n                \"internal::GlobalizeTracedReference\",\n                \"internal::ValueHelper\",\n                \"internal::Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            internal::Address* BasicTracedReference<T>::NewFromNonEmptyValue(\n                Isolate* isolate, T* that, internal::Address** slot,\n                internal::TracedReferenceStoreMode store_mode,\n                internal::TracedReferenceHandling reference_handling) {\n            return internal::GlobalizeTracedReference(\n                reinterpret_cast<internal::Isolate*>(isolate),\n                internal::ValueHelper::ValueAsAddress(that),\n                reinterpret_cast<internal::Address*>(slot), store_mode,\n                reference_handling);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reset\",\n            \"parent\": \"TracedReferenceBase\",\n            \"about\": \"Resets the TracedReferenceBase, disposing of the underlying global handle.\",\n            \"logic\": \"Disposes of the global handle associated with the slot and sets the slot to nullptr.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"internal::DisposeTracedReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void TracedReferenceBase::Reset() {\n            if (V8_UNLIKELY(IsEmpty())) {\n                return;\n            }\n            internal::DisposeTracedReference(slot());\n            SetSlotThreadSafe(nullptr);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Equality operator for two TracedReferenceBase objects\",\n            \"logic\": \"Calls an internal helper to determine equality of the handles\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const TracedReferenceBase&\",\n                    \"purpose\": \"Left hand side of comparison\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const TracedReferenceBase&\",\n                    \"purpose\": \"Right hand side of comparison\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if equal, false otherwise\"\n            },\n            \"dependencies\": [\n                \"internal::HandleHelper\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE bool operator==(const TracedReferenceBase& lhs,\n                                    const TracedReferenceBase& rhs) {\n            return internal::HandleHelper::EqualHandles(lhs, rhs);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Equality operator for a TracedReferenceBase and a Local\",\n            \"logic\": \"Calls an internal helper to determine equality of the handles\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const TracedReferenceBase&\",\n                    \"purpose\": \"Left hand side of comparison\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const v8::Local<U>&\",\n                    \"purpose\": \"Right hand side of comparison\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if equal, false otherwise\"\n            },\n            \"dependencies\": [\n                \"internal::HandleHelper\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename U>\n            V8_INLINE bool operator==(const TracedReferenceBase& lhs,\n                                    const v8::Local<U>& rhs) {\n            return internal::HandleHelper::EqualHandles(lhs, rhs);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Equality operator for a Local and a TracedReferenceBase\",\n            \"logic\": \"Calls the other equality operator to determine equality of the handles\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const v8::Local<U>&\",\n                    \"purpose\": \"Left hand side of comparison\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const TracedReferenceBase&\",\n                    \"purpose\": \"Right hand side of comparison\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if equal, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename U>\n            V8_INLINE bool operator==(const v8::Local<U>& lhs,\n                                    const TracedReferenceBase& rhs) {\n            return rhs == lhs;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Inequality operator for two TracedReferenceBase objects\",\n            \"logic\": \"Negates the equality operator\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const TracedReferenceBase&\",\n                    \"purpose\": \"Left hand side of comparison\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const TracedReferenceBase&\",\n                    \"purpose\": \"Right hand side of comparison\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if not equal, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE bool operator!=(const TracedReferenceBase& lhs,\n                                    const TracedReferenceBase& rhs) {\n            return !(lhs == rhs);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Inequality operator for a TracedReferenceBase and a Local\",\n            \"logic\": \"Negates the equality operator\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const TracedReferenceBase&\",\n                    \"purpose\": \"Left hand side of comparison\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const v8::Local<U>&\",\n                    \"purpose\": \"Right hand side of comparison\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if not equal, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename U>\n            V8_INLINE bool operator!=(const TracedReferenceBase& lhs,\n                                    const v8::Local<U>& rhs) {\n            return !(lhs == rhs);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Inequality operator for a Local and a TracedReferenceBase\",\n            \"logic\": \"Negates the equality operator\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const v8::Local<U>&\",\n                    \"purpose\": \"Left hand side of comparison\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const TracedReferenceBase&\",\n                    \"purpose\": \"Right hand side of comparison\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if not equal, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename U>\n            V8_INLINE bool operator!=(const v8::Local<U>& lhs,\n                                    const TracedReferenceBase& rhs) {\n            return !(rhs == lhs);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reset\",\n            \"parent\": \"TracedReference\",\n            \"about\": \"Resets the TracedReference, creating a new traced reference from the provided Local.\",\n            \"logic\": \"First resets the existing TracedReference, then creates a new one if the Local is non-empty, calling NewFromNonEmptyValue to create the global handle.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const Local<S>&\",\n                    \"purpose\": \"The Local to copy from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"BasicTracedReference::Reset\",\n                \"BasicTracedReference::NewFromNonEmptyValue\",\n                \"internal::TracedReferenceStoreMode\",\n                \"internal::TracedReferenceHandling\",\n                \"std::is_base_of\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            template <class S>\n            void TracedReference<T>::Reset(Isolate* isolate, const Local<S>& other) {\n            static_assert(std::is_base_of<T, S>::value, \"type check\");\n            this->Reset();\n            if (V8_UNLIKELY(other.IsEmpty())) {\n                return;\n            }\n            this->SetSlotThreadSafe(this->NewFromNonEmptyValue(\n                isolate, *other, &this->slot(),\n                internal::TracedReferenceStoreMode::kAssigningStore,\n                internal::TracedReferenceHandling::kDefault));\n            }\n        ]]></code>\n    </func>\n\n        <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reset\",\n            \"parent\": \"TracedReference\",\n            \"about\": \"Resets the TracedReference, creating a new droppable traced reference from the provided Local.\",\n            \"logic\": \"First resets the existing TracedReference, then creates a new droppable one if the Local is non-empty, calling NewFromNonEmptyValue to create the global handle.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const Local<S>&\",\n                    \"purpose\": \"The Local to copy from.\"\n                },\n                {\n                  \"name\": \"IsDroppable\",\n                  \"type\": \"IsDroppable\",\n                  \"purpose\": \"Tag to indicate that the new reference can be dropped by GC.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"BasicTracedReference::Reset\",\n                \"BasicTracedReference::NewFromNonEmptyValue\",\n                \"internal::TracedReferenceStoreMode\",\n                \"internal::TracedReferenceHandling\",\n                \"std::is_base_of\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n          template <class T>\n          template <class S>\n          void TracedReference<T>::Reset(Isolate* isolate, const Local<S>& other,\n                                        IsDroppable) {\n            static_assert(std::is_base_of<T, S>::value, \"type check\");\n            this->Reset();\n            if (V8_UNLIKELY(other.IsEmpty())) {\n              return;\n            }\n            this->SetSlotThreadSafe(this->NewFromNonEmptyValue(\n                isolate, *other, &this->slot(),\n                internal::TracedReferenceStoreMode::kAssigningStore,\n                internal::TracedReferenceHandling::kDroppable));\n          }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator=\",\n            \"parent\": \"TracedReference\",\n            \"about\": \"Move assignment operator for TracedReference.\",\n            \"logic\": \"Move assigns TracedReference from another TracedReference<S>, checking the type using static_assert and calling the As method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"TracedReference<S>&&\",\n                    \"purpose\": \"The source TracedReference.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"TracedReference&\",\n                \"description\": \"A reference to this TracedReference.\"\n            },\n            \"dependencies\": [\n                \"TracedReference::As\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            template <class S>\n            TracedReference<T>& TracedReference<T>::operator=(\n                TracedReference<S>&& rhs) noexcept {\n            static_assert(std::is_base_of<T, S>::value, \"type check\");\n            *this = std::move(rhs.template As<T>());\n            return *this;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator=\",\n            \"parent\": \"TracedReference\",\n            \"about\": \"Copy assignment operator for TracedReference.\",\n            \"logic\": \"Copy assigns TracedReference from another TracedReference<S>, checking the type using static_assert and calling the As method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const TracedReference<S>&\",\n                    \"purpose\": \"The source TracedReference.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"TracedReference&\",\n                \"description\": \"A reference to this TracedReference.\"\n            },\n            \"dependencies\": [\n                \"TracedReference::As\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            template <class S>\n            TracedReference<T>& TracedReference<T>::operator=(\n                const TracedReference<S>& rhs) {\n            static_assert(std::is_base_of<T, S>::value, \"type check\");\n            *this = rhs.template As<T>();\n            return *this;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator=\",\n            \"parent\": \"TracedReference\",\n            \"about\": \"Move assignment operator for TracedReference.\",\n            \"logic\": \"Move assigns TracedReference by moving the internal slot pointer using `internal::MoveTracedReference`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"TracedReference&&\",\n                    \"purpose\": \"The source TracedReference.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"TracedReference&\",\n                \"description\": \"A reference to this TracedReference.\"\n            },\n            \"dependencies\": [\n                \"internal::MoveTracedReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            TracedReference<T>& TracedReference<T>::operator=(\n                TracedReference&& rhs) noexcept {\n            if (this != &rhs) {\n                internal::MoveTracedReference(&rhs.slot(), &this->slot());\n            }\n            return *this;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator=\",\n            \"parent\": \"TracedReference\",\n            \"about\": \"Copy assignment operator for TracedReference.\",\n            \"logic\": \"Copy assigns TracedReference by resetting the current reference and copying the internal slot pointer using `internal::CopyTracedReference`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const TracedReference&\",\n                    \"purpose\": \"The source TracedReference.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"TracedReference&\",\n                \"description\": \"A reference to this TracedReference.\"\n            },\n            \"dependencies\": [\n                \"TracedReference::Reset\",\n                \"internal::CopyTracedReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            TracedReference<T>& TracedReference<T>::operator=(const TracedReference& rhs) {\n            if (this != &rhs) {\n                this->Reset();\n                if (!rhs.IsEmpty()) {\n                internal::CopyTracedReference(&rhs.slot(), &this->slot());\n                }\n            }\n            return *this;\n            }\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Value\",\n                \"about\": \"Base class for all JavaScript values.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Value;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Local\",\n                \"about\": \"A handle to a JavaScript value.  Used to manage the lifetime of JavaScript objects.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class Local {\n                public:\n                    static Local<T> New(Isolate* isolate, T* value);\n                    bool IsEmpty() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"api_internal::IndirectHandleBase\",\n                \"about\": \"Base class for indirect handles.  Provides a slot for storing the address of the handle.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace api_internal {\n                    class IndirectHandleBase {\n                    protected:\n                        internal::Address** slot() { return slot_; }\n                        const internal::Address* const* slot() const { return &slot_; }\n                    private:\n                        internal::Address** slot_ = nullptr;\n                    };\n                }\n            ]]></code>\n        </class>\n        <namespace>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"internal\",\n                \"about\": \"Internal V8 namespace.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace internal {\n                    using Address = uintptr_t;\n                }\n            ]]></code>\n        </namespace>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"internal::GlobalizeTracedReference\",\n                \"about\": \"Creates a global handle for a traced reference.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace internal {\n                    Address* GlobalizeTracedReference(Isolate* isolate, Address value, Address* slot,\n                        TracedReferenceStoreMode store_mode,\n                        TracedReferenceHandling reference_handling);\n                }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"internal::DisposeTracedReference\",\n                \"about\": \"Disposes a global handle.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace internal {\n                    void DisposeTracedReference(Address* global_handle);\n                }\n            ]]></code>\n        </func>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Object\",\n                \"about\": \"Base class"
}