{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/heap-consistency.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 258, column 44",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/heap-consistency.h\",\n            \"file_name\": \"heap-consistency.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides consistency helpers and scopes for managing garbage collection within the cppgc framework.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ header for size_t.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cstddef>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes internal write barrier implementation details.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"cppgc/internal/write-barrier.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes cppgc macros.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"cppgc/macros.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes cppgc member types.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"cppgc/member.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes trace trait definitions.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"cppgc/trace-trait.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes V8 configuration options. Note the NOLINT comment suppresses a build/include_directory warning.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"v8config.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"HeapConsistency\",\n                \"about\": \"Provides consistency helpers for maintaining the internal state of the garbage collector.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"internal::WriteBarrier\",\n                    \"HeapHandle\",\n                    \"TraceCallback\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class HeapConsistency final {\n            public:\n            using WriteBarrierParams = internal::WriteBarrier::Params;\n            using WriteBarrierType = internal::WriteBarrier::Type;\n\n            /**\n             * Gets the required write barrier type for a specific write.\n             *\n             * \\param slot Slot containing the pointer to the object. The slot itself\n             *   must reside in an object that has been allocated using\n             *   `MakeGarbageCollected()`.\n             * \\param value The pointer to the object. May be an interior pointer to an\n             *   interface of the actual object.\n             * \\param params Parameters that may be used for actual write barrier calls.\n             *   Only filled if return value indicates that a write barrier is needed. The\n             *   contents of the `params` are an implementation detail.\n             * \\returns whether a write barrier is needed and which barrier to invoke.\n             */\n            static V8_INLINE WriteBarrierType GetWriteBarrierType(\n                const void* slot, const void* value, WriteBarrierParams& params);\n\n            /**\n             * Gets the required write barrier type for a specific write. This override is\n             * only used for all the BasicMember types.\n             *\n             * \\param slot Slot containing the pointer to the object. The slot itself\n             *   must reside in an object that has been allocated using\n             *   `MakeGarbageCollected()`.\n             * \\param value The pointer to the object held via `BasicMember`.\n             * \\param params Parameters that may be used for actual write barrier calls.\n             *   Only filled if return value indicates that a write barrier is needed. The\n             *   contents of the `params` are an implementation detail.\n             * \\returns whether a write barrier is needed and which barrier to invoke.\n             */\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                        typename CheckingPolicy, typename StorageType>\n            static V8_INLINE WriteBarrierType GetWriteBarrierType(\n                const internal::BasicMember<T, WeaknessTag, WriteBarrierPolicy,\n                                            CheckingPolicy, StorageType>& value,\n                WriteBarrierParams& params);\n\n            /**\n             * Gets the required write barrier type for a specific write.\n             *\n             * \\param slot Slot to some part of an object. The object must not necessarily\n             * have been allocated using `MakeGarbageCollected()` but can also live\n             * off-heap or on stack.\n             * \\param params Parameters that may be used for actual write barrier calls.\n             *   Only filled if return value indicates that a write barrier is needed. The\n             *   contents of the `params` are an implementation detail.\n             * \\param callback Callback returning the corresponding heap handle. The\n             *   callback is only invoked if the heap cannot otherwise be figured out. The\n             *   callback must not allocate.\n             * \\returns whether a write barrier is needed and which barrier to invoke.\n             */\n            template <typename HeapHandleCallback>\n            static V8_INLINE WriteBarrierType\n            GetWriteBarrierType(const void* slot, WriteBarrierParams& params,\n                                HeapHandleCallback callback);\n\n            /**\n             * Gets the required write barrier type for a specific write.\n             * This version is meant to be used in conjunction with with a marking write\n             * barrier barrier which doesn't consider the slot.\n             *\n             * \\param value The pointer to the object. May be an interior pointer to an\n             *   interface of the actual object.\n             * \\param params Parameters that may be used for actual write barrier calls.\n             *   Only filled if return value indicates that a write barrier is needed. The\n             *   contents of the `params` are an implementation detail.\n             * \\returns whether a write barrier is needed and which barrier to invoke.\n             */\n            static V8_INLINE WriteBarrierType\n            GetWriteBarrierType(const void* value, WriteBarrierParams& params);\n\n            /**\n             * Conservative Dijkstra-style write barrier that processes an object if it\n             * has not yet been processed.\n             *\n             * \\param params The parameters retrieved from `GetWriteBarrierType()`.\n             * \\param object The pointer to the object. May be an interior pointer to\n             *   an interface of the actual object.\n             */\n            static V8_INLINE void DijkstraWriteBarrier(const WriteBarrierParams& params,\n                                                        const void* object);\n\n            /**\n             * Conservative Dijkstra-style write barrier that processes a range of\n             * elements if they have not yet been processed.\n             *\n             * \\param params The parameters retrieved from `GetWriteBarrierType()`.\n             * \\param first_element Pointer to the first element that should be processed.\n             *   The slot itself must reside in an object that has been allocated using\n             *   `MakeGarbageCollected()`.\n             * \\param element_size Size of the element in bytes.\n             * \\param number_of_elements Number of elements that should be processed,\n             *   starting with `first_element`.\n             * \\param trace_callback The trace callback that should be invoked for each\n             *   element if necessary.\n             */\n            static V8_INLINE void DijkstraWriteBarrierRange(\n                const WriteBarrierParams& params, const void* first_element,\n                size_t element_size, size_t number_of_elements,\n                TraceCallback trace_callback);\n\n            /**\n             * Steele-style write barrier that re-processes an object if it has already\n             * been processed.\n             *\n             * \\param params The parameters retrieved from `GetWriteBarrierType()`.\n             * \\param object The pointer to the object which must point to an object that\n             *   has been allocated using `MakeGarbageCollected()`. Interior pointers are\n             *   not supported.\n             */\n            static V8_INLINE void SteeleWriteBarrier(const WriteBarrierParams& params,\n                                                        const void* object);\n\n            /**\n             * Generational barrier for maintaining consistency when running with multiple\n             * generations.\n             *\n             * \\param params The parameters retrieved from `GetWriteBarrierType()`.\n             * \\param slot Slot containing the pointer to the object. The slot itself\n             *   must reside in an object that has been allocated using\n             *   `MakeGarbageCollected()`.\n             */\n            static V8_INLINE void GenerationalBarrier(const WriteBarrierParams& params,\n                                                        const void* slot);\n\n            /**\n             * Generational barrier for maintaining consistency when running with multiple\n             * generations. This version is used when slot contains uncompressed pointer.\n             *\n             * \\param params The parameters retrieved from `GetWriteBarrierType()`.\n             * \\param slot Uncompressed slot containing the direct pointer to the object.\n             * The slot itself must reside in an object that has been allocated using\n             *   `MakeGarbageCollected()`.\n             */\n            static V8_INLINE void GenerationalBarrierForUncompressedSlot(\n                const WriteBarrierParams& params, const void* uncompressed_slot);\n\n            /**\n             * Generational barrier for source object that may contain outgoing pointers\n             * to objects in young generation.\n             *\n             * \\param params The parameters retrieved from `GetWriteBarrierType()`.\n             * \\param inner_pointer Pointer to the source object.\n             */\n            static V8_INLINE void GenerationalBarrierForSourceObject(\n                const WriteBarrierParams& params, const void* inner_pointer);\n\n            private:\n            HeapConsistency() = delete;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DisallowGarbageCollectionScope\",\n                \"about\": \"Disallows garbage collection finalizations within its scope.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"heap_handle_\",\n                        \"type\": \"HeapHandle&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to the heap handle.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"HeapHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8_NODISCARD DisallowGarbageCollectionScope final {\n            CPPGC_STACK_ALLOCATED();\n\n            public:\n            /**\n             * \\returns whether garbage collections are currently allowed.\n             */\n            static bool IsGarbageCollectionAllowed(HeapHandle& heap_handle);\n\n            /**\n             * Enters a disallow garbage collection scope. Must be paired with `Leave()`.\n             * Prefer a scope instance of `DisallowGarbageCollectionScope`.\n             *\n             * \\param heap_handle The corresponding heap.\n             */\n            static void Enter(HeapHandle& heap_handle);\n\n            /**\n             * Leaves a disallow garbage collection scope. Must be paired with `Enter()`.\n             * Prefer a scope instance of `DisallowGarbageCollectionScope`.\n             *\n             * \\param heap_handle The corresponding heap.\n             */\n            static void Leave(HeapHandle& heap_handle);\n\n            /**\n             * Constructs a scoped object that automatically enters and leaves a disallow\n             * garbage collection scope based on its lifetime.\n             *\n             * \\param heap_handle The corresponding heap.\n             */\n            explicit DisallowGarbageCollectionScope(HeapHandle& heap_handle);\n            ~DisallowGarbageCollectionScope();\n\n            DisallowGarbageCollectionScope(const DisallowGarbageCollectionScope&) =\n                delete;\n            DisallowGarbageCollectionScope& operator=(\n                const DisallowGarbageCollectionScope&) = delete;\n\n            private:\n            HeapHandle& heap_handle_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NoGarbageCollectionScope\",\n                \"about\": \"Avoids invoking garbage collection finalizations within its scope.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"heap_handle_\",\n                        \"type\": \"HeapHandle&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to the heap handle.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"HeapHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8_NODISCARD NoGarbageCollectionScope final {\n            CPPGC_STACK_ALLOCATED();\n\n            public:\n            /**\n             * Enters a no garbage collection scope. Must be paired with `Leave()`. Prefer\n             * a scope instance of `NoGarbageCollectionScope`.\n             *\n             * \\param heap_handle The corresponding heap.\n             */\n            static void Enter(HeapHandle& heap_handle);\n\n            /**\n             * Leaves a no garbage collection scope. Must be paired with `Enter()`. Prefer\n             * a scope instance of `NoGarbageCollectionScope`.\n             *\n             * \\param heap_handle The corresponding heap.\n             */\n            static void Leave(HeapHandle& heap_handle);\n\n            /**\n             * Constructs a scoped object that automatically enters and leaves a no\n             * garbage collection scope based on its lifetime.\n             *\n             * \\param heap_handle The corresponding heap.\n             */\n            explicit NoGarbageCollectionScope(HeapHandle& heap_handle);\n            ~NoGarbageCollectionScope();\n\n            NoGarbageCollectionScope(const NoGarbageCollectionScope&) = delete;\n            NoGarbageCollectionScope& operator=(const NoGarbageCollectionScope&) = delete;\n\n            private:\n            HeapHandle& heap_handle_;\n            };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"HeapHandle\",\n                    \"about\": \"Handle to the garbage collected heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class HeapHandle {};\n            ]]></code>\n        </class>\n        <interface>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"interface\",\n                    \"name\": \"TraceCallback\",\n                    \"about\": \"Callback function for tracing objects during write barrier.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                using TraceCallback = void (*)(const void*);\n            ]]></code>\n        </interface>\n    </dependencies>\n</file>\n```"
}