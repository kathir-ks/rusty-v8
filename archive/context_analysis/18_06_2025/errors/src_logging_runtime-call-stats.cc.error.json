{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/logging/runtime-call-stats.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/logging/runtime-call-stats.cc\",\n            \"file_name\": \"runtime-call-stats.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements runtime call statistics collection and reporting for the V8 JavaScript engine.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for runtime call stats functionality, standard library features, V8 flags, tracing, and output streams.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/logging/runtime-call-stats.h\"\n\n#include <iomanip>\n\n#include \"src/flags/flags.h\"\n#include \"src/tracing/tracing-category-observer.h\"\n#include \"src/utils/ostreams.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"NowCPUTime\",\n                \"parent\": \"RuntimeCallTimer\",\n                \"about\": \"Gets the current CPU time.\",\n                \"logic\": \"Retrieves the current thread ticks and converts them to base::TimeTicks.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"base::TimeTicks\",\n                    \"description\": \"The current CPU time as TimeTicks.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbase::TimeTicks RuntimeCallTimer::NowCPUTime() {\n  base::ThreadTicks ticks = base::ThreadTicks::Now();\n  return base::TimeTicks::FromInternalValue(ticks.ToInternalValue());\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RuntimeCallStatEntries\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Collects and prints runtime call statistics entries.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"total_call_count_\",\n                        \"type\": \"uint64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Total number of calls across all runtime functions.\"\n                    },\n                    {\n                        \"name\": \"total_time_\",\n                        \"type\": \"base::TimeDelta\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Total time spent in all runtime functions.\"\n                    },\n                    {\n                        \"name\": \"entries_\",\n                        \"type\": \"std::vector<Entry>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of Entry objects, each representing a runtime function's statistics.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Entry\",\n                    \"base::TimeDelta\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass RuntimeCallStatEntries {\n public:\n  void Print(std::ostream& os) {\n    if (total_call_count_ == 0) return;\n    std::sort(entries_.rbegin(), entries_.rend());\n    os << std::setw(50) << \"Runtime Function/C++ Builtin\" << std::setw(12)\n       << \"Time\" << std::setw(18) << \"Count\" << std::endl\n       << std::string(88, '=') << std::endl;\n    for (Entry& entry : entries_) {\n      entry.SetTotal(total_time_, total_call_count_);\n      entry.Print(os);\n    }\n    os << std::string(88, '-') << std::endl;\n    Entry(\"Total\", total_time_, total_call_count_).Print(os);\n  }\n\n  // By default, the compiler will usually inline this, which results in a large\n  // binary size increase: std::vector::push_back expands to a large amount of\n  // instructions, and this function is invoked repeatedly by macros.\n  V8_NOINLINE void Add(RuntimeCallCounter* counter) {\n    if (counter->count() == 0) return;\n    entries_.push_back(\n        Entry(counter->name(), counter->time(), counter->count()));\n    total_time_ += counter->time();\n    total_call_count_ += counter->count();\n  }\n\n private:\n  class Entry {\n   public:\n    Entry(const char* name, base::TimeDelta time, uint64_t count)\n        : name_(name),\n          time_(time.InMicroseconds()),\n          count_(count),\n          time_percent_(100),\n          count_percent_(100) {}\n\n    bool operator<(const Entry& other) const {\n      if (time_ < other.time_) return true;\n      if (time_ > other.time_) return false;\n      return count_ < other.count_;\n    }\n\n    V8_NOINLINE void Print(std::ostream& os) {\n      os.precision(2);\n      os << std::fixed << std::setprecision(2);\n      os << std::setw(50) << name_;\n      os << std::setw(10) << static_cast<double>(time_) / 1000 << \"ms \";\n      os << std::setw(6) << time_percent_ << \"%\";\n      os << std::setw(10) << count_ << \" \";\n      os << std::setw(6) << count_percent_ << \"%\";\n      os << std::endl;\n    }\n\n    V8_NOINLINE void SetTotal(base::TimeDelta total_time,\n                              uint64_t total_count) {\n      if (total_time.InMicroseconds() == 0) {\n        time_percent_ = 0;\n      } else {\n        time_percent_ = 100.0 * time_ / total_time.InMicroseconds();\n      }\n      count_percent_ = 100.0 * count_ / total_count;\n    }\n\n   private:\n    const char* name_;\n    int64_t time_;\n    uint64_t count_;\n    double time_percent_;\n    double count_percent_;\n  };\n\n  uint64_t total_call_count_ = 0;\n  base::TimeDelta total_time_;\n  std::vector<Entry> entries_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RuntimeCallStatEntries::Entry\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents a single entry in the runtime call statistics.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"name_\",\n                        \"type\": \"const char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Name of the runtime function or builtin.\"\n                    },\n                    {\n                        \"name\": \"time_\",\n                        \"type\": \"int64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Time spent in the function (in microseconds).\"\n                    },\n                    {\n                        \"name\": \"count_\",\n                        \"type\": \"uint64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of times the function was called.\"\n                    },\n                    {\n                        \"name\": \"time_percent_\",\n                        \"type\": \"double\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Percentage of total time spent in this function.\"\n                    },\n                    {\n                        \"name\": \"count_percent_\",\n                        \"type\": \"double\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Percentage of total calls to this function.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n class Entry {\n   public:\n    Entry(const char* name, base::TimeDelta time, uint64_t count)\n        : name_(name),\n          time_(time.InMicroseconds()),\n          count_(count),\n          time_percent_(100),\n          count_percent_(100) {}\n\n    bool operator<(const Entry& other) const {\n      if (time_ < other.time_) return true;\n      if (time_ > other.time_) return false;\n      return count_ < other.count_;\n    }\n\n    V8_NOINLINE void Print(std::ostream& os) {\n      os.precision(2);\n      os << std::fixed << std::setprecision(2);\n      os << std::setw(50) << name_;\n      os << std::setw(10) << static_cast<double>(time_) / 1000 << \"ms \";\n      os << std::setw(6) << time_percent_ << \"%\";\n      os << std::setw(10) << count_ << \" \";\n      os << std::setw(6) << count_percent_ << \"%\";\n      os << std::endl;\n    }\n\n    V8_NOINLINE void SetTotal(base::TimeDelta total_time,\n                              uint64_t total_count) {\n      if (total_time.InMicroseconds() == 0) {\n        time_percent_ = 0;\n      } else {\n        time_percent_ = 100.0 * time_ / total_time.InMicroseconds();\n      }\n      count_percent_ = 100.0 * count_ / total_count;\n    }\n\n   private:\n    const char* name_;\n    int64_t time_;\n    uint64_t count_;\n    double time_percent_;\n    double count_percent_;\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reset\",\n                \"parent\": \"RuntimeCallCounter\",\n                \"about\": \"Resets the count and time of the RuntimeCallCounter.\",\n                \"logic\": \"Sets the count_ and time_ attributes to 0.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallCounter::Reset() {\n  count_ = 0;\n  time_ = 0;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Dump\",\n                \"parent\": \"RuntimeCallCounter\",\n                \"about\": \"Dumps the runtime call counter data into a TracedValue object.\",\n                \"logic\": \"Appends the count and time to the provided TracedValue as an array.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"v8::tracing::TracedValue*\",\n                        \"purpose\": \"The TracedValue object to which the data will be appended.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallCounter::Dump(v8::tracing::TracedValue* value) {\n  value->BeginArray(name_);\n  value->AppendDouble(count_);\n  value->AppendDouble(time_);\n  value->EndArray();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Add\",\n                \"parent\": \"RuntimeCallCounter\",\n                \"about\": \"Adds the count and time from another RuntimeCallCounter to this one.\",\n                \"logic\": \"Increments the count_ and time_ attributes by the corresponding values from the other counter.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"other\",\n                        \"type\": \"RuntimeCallCounter*\",\n                        \"purpose\": \"The other RuntimeCallCounter to add to this one.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallCounter::Add(RuntimeCallCounter* other) {\n  count_ += other->count();\n  time_ += other->time().InMicroseconds();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Snapshot\",\n                \"parent\": \"RuntimeCallTimer\",\n                \"about\": \"Takes a snapshot of the timer and commits the elapsed time to the counters.\",\n                \"logic\": \"Pauses the topmost timer, commits the time to the counters, and resumes the timer. It iterates through the timer stack, committing time for each timer.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallTimer::Snapshot() {\n  base::TimeTicks now = Now();\n  // Pause only / topmost timer in the timer stack.\n  Pause(now);\n  // Commit all the timer's elapsed time to the counters.\n  RuntimeCallTimer* timer = this;\n  while (timer != nullptr) {\n    timer->CommitTimeToCounter();\n    timer = timer->parent();\n  }\n  Resume(now);\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RuntimeCallStats\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Manages runtime call statistics for a specific thread.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"in_use_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the stats are currently in use.\"\n                    },\n                    {\n                        \"name\": \"thread_type_\",\n                        \"type\": \"ThreadType\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Specifies the type of thread for which these stats are collected.\"\n                    },\n                    {\n                        \"name\": \"counters_\",\n                        \"type\": \"RuntimeCallCounter[kNumberOfCounters]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of RuntimeCallCounter objects, one for each counter ID.\"\n                    },\n                    {\n                        \"name\": \"current_timer_\",\n                        \"type\": \"base::ThreadLocal<RuntimeCallTimer*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Thread-local storage for the currently active RuntimeCallTimer.\"\n                    },\n                    {\n                        \"name\": \"current_counter_\",\n                        \"type\": \"base::ThreadLocal<RuntimeCallCounter*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Thread-local storage for the currently active RuntimeCallCounter.\"\n                    },\n                    {\n                        \"name\": \"thread_id_\",\n                        \"type\": \"ThreadId\",\n                        \"access\": \"private\",\n                        \"purpose\": \"ID of the thread for which these stats are collected.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"RuntimeCallCounter\",\n                    \"RuntimeCallTimer\",\n                    \"v8_flags\",\n                    \"base::ThreadTicks\",\n                    \"base::ThreadLocal\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nRuntimeCallStats::RuntimeCallStats(ThreadType thread_type)\n    : in_use_(false), thread_type_(thread_type) {\n  static const char* const kNames[] = {\n#define CALL_BUILTIN_COUNTER(name) \"GC_\" #name,\n      FOR_EACH_GC_COUNTER(CALL_BUILTIN_COUNTER)  //\n#undef CALL_BUILTIN_COUNTER\n#define CALL_RUNTIME_COUNTER(name) #name,\n      FOR_EACH_MANUAL_COUNTER(CALL_RUNTIME_COUNTER)  //\n#undef CALL_RUNTIME_COUNTER\n#define CALL_RUNTIME_COUNTER(name, nargs, ressize) #name,\n      FOR_EACH_INTRINSIC(CALL_RUNTIME_COUNTER)  //\n#undef CALL_RUNTIME_COUNTER\n#define CALL_BUILTIN_COUNTER(name, Argc) #name,\n      BUILTIN_LIST_C(CALL_BUILTIN_COUNTER)  //\n#undef CALL_BUILTIN_COUNTER\n#define CALL_BUILTIN_COUNTER(name) \"API_\" #name,\n      FOR_EACH_API_COUNTER(CALL_BUILTIN_COUNTER)  //\n#undef CALL_BUILTIN_COUNTER\n#define CALL_BUILTIN_COUNTER(name) #name,\n      FOR_EACH_HANDLER_COUNTER(CALL_BUILTIN_COUNTER)  //\n#undef CALL_BUILTIN_COUNTER\n#define THREAD_SPECIFIC_COUNTER(name) #name,\n      FOR_EACH_THREAD_SPECIFIC_COUNTER(THREAD_SPECIFIC_COUNTER)  //\n#undef THREAD_SPECIFIC_COUNTER\n  };\n  for (int i = 0; i < kNumberOfCounters; i++) {\n    this->counters_[i] = RuntimeCallCounter(kNames[i]);\n  }\n  if (v8_flags.rcs_cpu_time) {\n    CHECK(base::ThreadTicks::IsSupported());\n    base::ThreadTicks::WaitUntilInitialized();\n    RuntimeCallTimer::Now = &RuntimeCallTimer::NowCPUTime;\n  }\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"FirstCounter\",\n                \"parent\": null,\n                \"about\": \"Helper function to get the first counter ID.\",\n                \"logic\": \"Returns the first counter ID passed as an argument.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"RuntimeCallCounterId\",\n                    \"description\": \"The first counter ID.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconstexpr RuntimeCallCounterId FirstCounter(RuntimeCallCounterId first, ...) {\n  return first;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HasThreadSpecificCounterVariants\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Checks if a given counter ID has thread-specific variants.\",\n                \"logic\": \"Checks if the counter ID falls within the range of thread-specific variant counters.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"type\": \"RuntimeCallCounterId\",\n                        \"purpose\": \"The counter ID to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the counter ID has thread-specific variants, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool RuntimeCallStats::HasThreadSpecificCounterVariants(\n    RuntimeCallCounterId id) {\n  // Check that it's in the range of the thread-specific variant counters and\n  // also that it's one of the background counters.\n  return id >= kFirstThreadVariantCounter && id <= kLastThreadVariantCounter;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsBackgroundThreadSpecificVariant\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Checks if a given counter ID is a background thread-specific variant.\",\n                \"logic\": \"Checks if the counter ID is a thread-specific variant and if it's a background counter (odd index).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"id\",\n                        \"type\": \"RuntimeCallCounterId\",\n                        \"purpose\": \"The counter ID to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the counter ID is a background thread-specific variant, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"HasThreadSpecificCounterVariants\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool RuntimeCallStats::IsBackgroundThreadSpecificVariant(\n    RuntimeCallCounterId id) {\n  return HasThreadSpecificCounterVariants(id) &&\n         (static_cast<int>(id) - static_cast<int>(kFirstThreadVariantCounter)) %\n                 2 ==\n             1;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Enter\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Enters a runtime call, starting a timer.\",\n                \"logic\": \"Gets the counter for the given ID, starts the timer, and sets the current timer and counter.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"timer\",\n                        \"type\": \"RuntimeCallTimer*\",\n                        \"purpose\": \"The timer to start.\"\n                    },\n                    {\n                        \"name\": \"counter_id\",\n                        \"type\": \"RuntimeCallCounterId\",\n                        \"purpose\": \"The ID of the counter to use.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"GetCounter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallStats::Enter(RuntimeCallTimer* timer,\n                             RuntimeCallCounterId counter_id) {\n  DCHECK(IsCalledOnTheSameThread());\n  RuntimeCallCounter* counter = GetCounter(counter_id);\n  DCHECK_NOT_NULL(counter->name());\n  timer->Start(counter, current_timer());\n  current_timer_.SetValue(timer);\n  current_counter_.SetValue(counter);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Leave\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Leaves a runtime call, stopping a timer.\",\n                \"logic\": \"Stops the current timer and updates the current timer and counter.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"timer\",\n                        \"type\": \"RuntimeCallTimer*\",\n                        \"purpose\": \"The timer to stop.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallStats::Leave(RuntimeCallTimer* timer) {\n  DCHECK(IsCalledOnTheSameThread());\n  RuntimeCallTimer* stack_top = current_timer();\n  if (stack_top == nullptr) return;  // Missing timer is a result of Reset().\n  CHECK(stack_top == timer);\n  current_timer_.SetValue(timer->Stop());\n  RuntimeCallTimer* cur_timer = current_timer();\n  current_counter_.SetValue(cur_timer ? cur_timer->counter() : nullptr);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Add\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Adds the statistics from another RuntimeCallStats object to this one.\",\n                \"logic\": \"Iterates through all counters and adds the corresponding counters from the other object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"other\",\n                        \"type\": \"RuntimeCallStats*\",\n                        \"purpose\": \"The other RuntimeCallStats object to add.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"GetCounter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallStats::Add(RuntimeCallStats* other) {\n  for (int i = 0; i < kNumberOfCounters; i++) {\n    GetCounter(i)->Add(other->GetCounter(i));\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CorrectCurrentCounterId\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Corrects the current counter ID based on the thread and counter mode.\",\n                \"logic\": \"Adjusts the counter ID if it's thread-specific and updates the timer and counter.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"counter_id\",\n                        \"type\": \"RuntimeCallCounterId\",\n                        \"purpose\": \"The counter ID to correct.\"\n                    },\n                    {\n                        \"name\": \"mode\",\n                        \"type\": \"CounterMode\",\n                        \"purpose\": \"The counter mode (e.g., thread-specific).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"GetCounter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallStats::CorrectCurrentCounterId(RuntimeCallCounterId counter_id,\n                                               CounterMode mode) {\n  DCHECK(IsCalledOnTheSameThread());\n  if (mode == RuntimeCallStats::CounterMode::kThreadSpecific) {\n    counter_id = CounterIdForThread(counter_id);\n  }\n  DCHECK(IsCounterAppropriateForThread(counter_id));\n\n  RuntimeCallTimer* timer = current_timer();\n  if (timer == nullptr) return;\n  RuntimeCallCounter* counter = GetCounter(counter_id);\n  timer->set_counter(counter);\n  current_counter_.SetValue(counter);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsCalledOnTheSameThread\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Checks if the current function is called on the same thread.\",\n                \"logic\": \"Verifies if the function is executed within the same thread context by comparing current thread ID with recorded thread ID.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"Returns `true` if the function call occurs within the same thread; otherwise, returns `false`.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool RuntimeCallStats::IsCalledOnTheSameThread() {\n  if (thread_id_.IsValid()) return thread_id_ == ThreadId::Current();\n  thread_id_ = ThreadId::Current();\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Print\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Prints the runtime call statistics to standard output.\",\n                \"logic\": \"Creates a RuntimeCallStatEntries object, snapshots the current timer, adds all counters to the entries, and prints the entries.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"RuntimeCallStatEntries\",\n                    \"GetCounter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallStats::Print() {\n  StdoutStream os;\n  Print(os);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Print\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Prints the runtime call statistics to a given output stream.\",\n                \"logic\": \"Creates a RuntimeCallStatEntries object, snapshots the current timer, adds all counters to the entries, and prints the entries to the specified stream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to print to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"RuntimeCallStatEntries\",\n                    \"GetCounter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallStats::Print(std::ostream& os) {\n  RuntimeCallStatEntries entries;\n  if (current_timer_.Value() != nullptr) {\n    current_timer_.Value()->Snapshot();\n  }\n  for (int i = 0; i < kNumberOfCounters; i++) {\n    entries.Add(GetCounter(i));\n  }\n  entries.Print(os);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reset\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Resets all runtime call counters.\",\n                \"logic\": \"Clears the runtime counter stack if tracing is enabled and resets all counters to zero.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"GetCounter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallStats::Reset() {\n  if (V8_LIKELY(!TracingFlags::is_runtime_stats_enabled())) return;\n\n  // In tracing, we only what to trace the time spent on top level trace events,\n  // if runtime counter stack is not empty, we should clear the whole runtime\n  // counter stack, and then reset counters so that we can dump counters into\n  // top level trace events accurately.\n  while (current_timer_.Value()) {\n    current_timer_.SetValue(current_timer_.Value()->Stop());\n  }\n\n  for (int i = 0; i < kNumberOfCounters; i++) {\n    GetCounter(i)->Reset();\n  }\n\n  in_use_ = true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Dump\",\n                \"parent\": \"RuntimeCallStats\",\n                \"about\": \"Dumps the runtime call statistics to a TracedValue object.\",\n                \"logic\": \"Iterates through all counters and dumps the data to the TracedValue if the count is greater than 0. Sets in_use_ to false.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"v8::tracing::TracedValue*\",\n                        \"purpose\": \"The TracedValue object to dump the data to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"GetCounter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RuntimeCallStats::Dump(v8::tracing::TracedValue* value) {\n  for (int i = 0; i < kNumberOfCounters; i++) {\n    if (GetCounter(i)->count() > 0) GetCounter(i)->Dump(value);\n  }\n  in_use_ = false;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WorkerThreadRuntimeCallStats\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Manages runtime call statistics for worker threads.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_thread_id_\",\n                        \"type\": \"ThreadId\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The ID of the isolate's main thread.\"\n                    },\n                    {\n                        \"name\": \"tables_\",\n                        \"type\": \"std::vector<std::unique_ptr<RuntimeCallStats>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of unique pointers to RuntimeCallStats objects, one for each worker thread.\"\n                    },\n                    {\n                        \"name\": \"tls_key_\",\n                        \"type\": \"base::Thread::LocalStorageKey\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Thread local storage key.\"\n                    },\n                    {\n                        \"name\": \"mutex_\",\n                        \"type\": \"base::Mutex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mutex to protect the data structures.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"RuntimeCallStats\",\n                    \"base::Thread\",\n                    \"base::Mutex\",\n                    \"base::MutexGuard\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nWorkerThreadRuntimeCallStats::WorkerThreadRuntimeCallStats()\n    : isolate_thread_id_(ThreadId::Current()) {}\n\nWorkerThreadRuntimeCallStats::~WorkerThreadRuntimeCallStats() {\n  if (tls_key_) base::Thread::DeleteThreadLocalKey(*tls_key_);\n}\n\nbase::Thread::LocalStorageKey WorkerThreadRuntimeCallStats::GetKey() {\n  base::MutexGuard lock(&mutex_);\n  if (!tls_key_) tls_key_ = base::Thread::CreateThreadLocalKey();\n  return *tls_key_;\n}\n\nRuntimeCallStats* WorkerThreadRuntimeCallStats::NewTable() {\n  // Never create a new worker table on the isolate's main thread.\n  DCHECK_NE(ThreadId::Current(), isolate_thread_id_);\n  std::unique_ptr<RuntimeCallStats> new_table =\n      std::make"
}