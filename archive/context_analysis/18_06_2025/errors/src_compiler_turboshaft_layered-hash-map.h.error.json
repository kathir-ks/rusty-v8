{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/layered-hash-map.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 56, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/layered-hash-map.h\",\n        \"file_name\": \"layered-hash-map.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines a LayeredHashMap data structure for efficient insertion and removal of elements in layers.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <cstddef>\n#include <iostream>\n#include <limits>\n#include <optional>\n\n#include \"src/base/bits.h\"\n#include \"src/compiler/turboshaft/fast-hash.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LayeredHashMap\",\n            \"about\": \"A hash map that groups elements into layers, allowing efficient removal of the last inserted layer.\",\n            \"attributes\": [\n                {\n                    \"name\": \"mask_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mask for calculating the index in the hash table.\"\n                },\n                {\n                    \"name\": \"entry_count_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of entries in the hash table.\"\n                },\n                {\n                    \"name\": \"table_\",\n                    \"type\": \"base::Vector<Entry>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The main hash table (a ZoneVector).\"\n                },\n                {\n                    \"name\": \"depths_heads_\",\n                    \"type\": \"ZoneVector<Entry*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Heads of the linked lists for each layer.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory zone for allocating memory.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"ZoneVector\",\n                \"base::Vector\",\n                \"fast_hash\",\n                \"base::bits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nclass LayeredHashMap {\n public:\n  explicit LayeredHashMap(Zone* zone, uint32_t initial_capacity = 64);\n\n  void StartLayer();\n  void DropLastLayer();\n\n  void InsertNewKey(Key key, Value value);\n  bool Contains(Key key);\n  std::optional<Value> Get(Key key);\n\n private:\n  struct Entry {\n    size_t hash = 0;\n    Key key = Key();\n    Value value = Value();\n    Entry* depth_neighboring_entry = nullptr;\n  };\n  void ResizeIfNeeded();\n  size_t NextEntryIndex(size_t index) { return (index + 1) & mask_; }\n  Entry* FindEntryForKey(Key key, size_t hash = 0);\n  Entry* InsertEntry(Entry entry);\n\n  size_t ComputeHash(Key key) {\n    size_t hash = fast_hash<Key>()(key);\n    return V8_UNLIKELY(hash == 0) ? 1 : hash;\n  }\n\n  size_t mask_;\n  size_t entry_count_;\n  base::Vector<Entry> table_;\n  ZoneVector<Entry*> depths_heads_;\n  Zone* zone_;\n\n  static constexpr double kNeedResizePercentage = 0.75;\n  static constexpr int kGrowthFactor = 2;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LayeredHashMap\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Constructor for the LayeredHashMap class.\",\n            \"logic\": \"Initializes the hash map with the given zone and initial capacity. The initial capacity is rounded up to the nearest power of 2.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone to use for allocating memory.\"\n                },\n                {\n                    \"name\": \"initial_capacity\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"The initial capacity of the hash table.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"base::bits::RoundUpToPowerOfTwo32\",\n                \"std::max\",\n                \"base::Vector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nLayeredHashMap<Key, Value>::LayeredHashMap(Zone* zone,\n                                           uint32_t initial_capacity)\n    : entry_count_(0), depths_heads_(zone), zone_(zone) {\n  // Setting the minimal capacity to 16\n  initial_capacity = std::max<uint32_t>(initial_capacity, 16);\n  // {initial_capacity} should be a power of 2, so that we can compute offset\n  // in {table_} with a mask rather than a modulo.\n  initial_capacity = base::bits::RoundUpToPowerOfTwo32(initial_capacity);\n  mask_ = initial_capacity - 1;\n  // Allocating the table_\n  table_ = zone_->NewVector<Entry>(initial_capacity);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"StartLayer\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Starts a new layer in the hash map.\",\n            \"logic\": \"Pushes a nullptr to the depths_heads_ vector to indicate the start of a new layer.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"depths_heads_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nvoid LayeredHashMap<Key, Value>::StartLayer() {\n  depths_heads_.push_back(nullptr);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DropLastLayer\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Removes the last layer from the hash map.\",\n            \"logic\": \"Iterates through the linked list of the last layer, removing each entry from the hash table. Then, it removes the linked list head from depths_heads_.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"depths_heads_\",\n                \"DCHECK_GT\",\n                \"Entry\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nvoid LayeredHashMap<Key, Value>::DropLastLayer() {\n  DCHECK_GT(depths_heads_.size(), 0);\n  for (Entry* entry = depths_heads_.back(); entry != nullptr;) {\n    entry_count_--;\n    Entry* next = entry->depth_neighboring_entry;\n    *entry = Entry();\n    entry = next;\n  }\n  depths_heads_.pop_back();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FindEntryForKey\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Finds an entry in the hash table for the given key.\",\n            \"logic\": \"Iterates through the hash table, starting from the index calculated using the hash of the key. Returns a pointer to the entry if found, or a pointer to an empty entry if not found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"key\",\n                    \"type\": \"Key\",\n                    \"purpose\": \"The key to search for.\"\n                },\n                {\n                    \"name\": \"hash\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The hash of the key (optional).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"typename LayeredHashMap<Key, Value>::Entry*\",\n                \"description\": \"A pointer to the entry if found, or a pointer to an empty entry if not found.\"\n            },\n            \"dependencies\": [\n                \"mask_\",\n                \"table_\",\n                \"NextEntryIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\ntypename LayeredHashMap<Key, Value>::Entry*\nLayeredHashMap<Key, Value>::FindEntryForKey(Key key, size_t hash) {\n  for (size_t i = hash & mask_;; i = NextEntryIndex(i)) {\n    if (table_[i].hash == 0) return &table_[i];\n    if (table_[i].hash == hash && table_[i].key == key) return &table_[i];\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InsertNewKey\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Inserts a new key-value pair into the hash map.\",\n            \"logic\": \"Resizes the hash table if needed. Calculates the hash of the key, finds an empty entry, and inserts the new entry into the hash table and the current layer's linked list.\",\n            \"parameters\": [\n                {\n                    \"name\": \"key\",\n                    \"type\": \"Key\",\n                    \"purpose\": \"The key to insert.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The value to insert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ResizeIfNeeded\",\n                \"ComputeHash\",\n                \"FindEntryForKey\",\n                \"depths_heads_\",\n                \"DCHECK_EQ\",\n                \"entry_count_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nvoid LayeredHashMap<Key, Value>::InsertNewKey(Key key, Value value) {\n  ResizeIfNeeded();\n  size_t hash = ComputeHash(key);\n  Entry* destination = FindEntryForKey(key, hash);\n  DCHECK_EQ(destination->hash, 0);\n  *destination = Entry{hash, key, value, depths_heads_.back()};\n  depths_heads_.back() = destination;\n  entry_count_++;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Get\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Gets the value associated with the given key.\",\n            \"logic\": \"Finds the entry for the key and returns the associated value. Returns std::nullopt if the key is not found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"key\",\n                    \"type\": \"Key\",\n                    \"purpose\": \"The key to search for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<Value>\",\n                \"description\": \"The value associated with the key, or std::nullopt if not found.\"\n            },\n            \"dependencies\": [\n                \"FindEntryForKey\",\n                \"ComputeHash\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nstd::optional<Value> LayeredHashMap<Key, Value>::Get(Key key) {\n  Entry* destination = FindEntryForKey(key, ComputeHash(key));\n  if (destination->hash == 0) return std::nullopt;\n  return destination->value;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Contains\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Checks if the hash map contains the given key.\",\n            \"logic\": \"Calls Get(key) and returns true if it has a value, and false otherwise.\",\n            \"parameters\": [\n                {\n                    \"name\": \"key\",\n                    \"type\": \"Key\",\n                    \"purpose\": \"The key to search for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the key is found, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Get\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nbool LayeredHashMap<Key, Value>::Contains(Key key) {\n  return Get(key).has_value();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ResizeIfNeeded\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Resizes the hash table if it is too full.\",\n            \"logic\": \"Checks if the load factor exceeds kNeedResizePercentage. If so, it resizes the hash table to kGrowthFactor times its current size. It rehashes all entries into the new table, maintaining insertion order within each layer to ensure DropLastLayer works correctly.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"table_\",\n                \"kNeedResizePercentage\",\n                \"entry_count_\",\n                \"kGrowthFactor\",\n                \"std::numeric_limits\",\n                \"mask_\",\n                \"base::bits::CountPopulation\",\n                \"base::bits::CountLeadingZeros\",\n                \"depths_heads_\",\n                \"FindEntryForKey\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nvoid LayeredHashMap<Key, Value>::ResizeIfNeeded() {\n  if (table_.size() * kNeedResizePercentage > entry_count_) return;\n  CHECK_LE(table_.size(), std::numeric_limits<size_t>::max() / kGrowthFactor);\n  table_ = zone_->NewVector<Entry>(table_.size() * kGrowthFactor);\n  mask_ = table_.size() - 1;\n  DCHECK_EQ(base::bits::CountPopulation(mask_),\n            sizeof(mask_) * 8 - base::bits::CountLeadingZeros(mask_));\n  for (size_t depth_idx = 0; depth_idx < depths_heads_.size(); depth_idx++) {\n    // It's important to fill the new hash by inserting data in increasing\n    // depth order, in order to avoid holes when later calling DropLastLayer.\n    // Consider for instance:\n    //\n    //  ---+------+------+------+----\n    //     |  a1  |  a2  |  a3  |\n    //  ---+------+------+------+----\n    //\n    // Where a1, a2 and a3 have the same hash. By construction, we know that\n    // depth(a1) <= depth(a2) <= depth(a3). If, when re-hashing, we were to\n    // insert them in another order, say:\n    //\n    //  ---+------+------+------+----\n    //     |  a3  |  a1  |  a2  |\n    //  ---+------+------+------+----\n    //\n    // Then, when we'll call DropLastLayer to remove entries from a3's depth,\n    // we'll get this:\n    //\n    //  ---+------+------+------+----\n    //     | null |  a1  |  a2  |\n    //  ---+------+------+------+----\n    //\n    // And, when looking if a1 is in the hash, we'd find a \"null\" where we\n    // expect it, and assume that it's not present. If, instead, we always\n    // conserve the increasing depth order, then when removing a3, we'd get:\n    //\n    //  ---+------+------+------+----\n    //     |  a1  |  a2  | null |\n    //  ---+------+------+------+----\n    //\n    // Where we can still find a1 and a2.\n    Entry* entry = depths_heads_[depth_idx];\n    depths_heads_[depth_idx] = nullptr;\n    while (entry != nullptr) {\n      Entry* new_entry_loc = FindEntryForKey(entry->key, entry->hash);\n      *new_entry_loc = *entry;\n      Entry* next_entry = entry->depth_neighboring_entry;\n      new_entry_loc->depth_neighboring_entry = depths_heads_[depth_idx];\n      depths_heads_[depth_idx] = new_entry_loc;\n      entry = next_entry;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NextEntryIndex\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Calculates the index of the next entry in the hash table (for collision resolution).\",\n            \"logic\": \"Increments the index and applies the mask to wrap around the table.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The current index.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The index of the next entry.\"\n            },\n            \"dependencies\": [\n                \"mask_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nsize_t LayeredHashMap<Key, Value>::NextEntryIndex(size_t index) { return (index + 1) & mask_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeHash\",\n            \"parent\": \"LayeredHashMap\",\n            \"about\": \"Computes the hash value for the given key.\",\n            \"logic\": \"Uses the fast_hash function to compute the hash. If the hash is 0, it returns 1 to avoid issues with the hash table implementation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"key\",\n                    \"type\": \"Key\",\n                    \"purpose\": \"The key to hash.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The computed hash value.\"\n            },\n            \"dependencies\": [\n                \"fast_hash\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Key, class Value>\nsize_t LayeredHashMap<Key, Value>::ComputeHash(Key key) {\n    size_t hash = fast_hash<Key>()(key);\n    return V8_UNLIKELY(hash == 0) ? 1 : hash;\n  }\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Zone\",\n                \"about\": \"Memory allocation zone used by V8\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Zone {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ZoneVector\",\n                \"about\": \"A vector-like container that allocates memory from a Zone\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> class ZoneVector {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"base::Vector\",\n                \"about\": \"Dynamically sized array.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base { template <typename T> class Vector {}; }\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"fast_hash\",\n                \"about\": \"Fast hash function for keys.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename K> struct fast_hash { size_t operator()(K key) { return 0; } };\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"base::bits::RoundUpToPowerOfTwo32\",\n                \"about\": \"Rounds up a 32-bit unsigned integer to the nearest power of 2.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base { namespace bits { uint32_t RoundUpToPowerOfTwo32(uint32_t v) { return 0; } } }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"base::bits::CountPopulation\",\n                \"about\": \"Counts the number of set bits (1s) in an integer.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base { namespace bits { int CountPopulation(size_t v) { return 0; } } }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"base::bits::CountLeadingZeros\",\n                \"about\": \"Counts the number of leading zero bits in an integer.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base { namespace bits { int CountLeadingZeros(size_t v) { return 0; } } }\n            ]]></code>\n        </func>\n    </dependencies>\n</file>\n```"
}