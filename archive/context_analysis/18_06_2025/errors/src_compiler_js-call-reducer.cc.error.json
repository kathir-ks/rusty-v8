{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-call-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-call-reducer.cc\",\n        \"file_name\": \"js-call-reducer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Reduces JavaScript call nodes in the compiler graph to more efficient or specialized operations.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for compiler, builtins, codegen, objects, and utils.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/js-call-reducer.h\"\n\n#include <functional>\n#include <optional>\n\n#include \"src/base/container-utils.h\"\n#include \"src/base/small-vector.h\"\n#include \"src/builtins/builtins-promise.h\"\n#include \"src/builtins/builtins-utils.h\"\n#include \"src/codegen/code-factory.h\"\n#include \"src/codegen/tnode.h\"\n#include \"src/compiler/access-builder.h\"\n#include \"src/compiler/access-info.h\"\n#include \"src/compiler/allocation-builder-inl.h\"\n#include \"src/compiler/allocation-builder.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/fast-api-calls.h\"\n#include \"src/compiler/feedback-source.h\"\n#include \"src/compiler/graph-assembler.h\"\n#include \"src/compiler/heap-refs.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/js-operator.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/map-inference.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/state-values-utils.h\"\n#include \"src/compiler/type-cache.h\"\n#include \"src/compiler/use-info.h\"\n#include \"src/flags/flags.h\"\n#include \"src/ic/call-optimization.h\"\n#include \"src/objects/elements-kind.h\"\n#include \"src/objects/instance-type.h\"\n#include \"src/objects/js-function.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/ordered-hash-table.h\"\n#include \"src/utils/utils.h\"\n\n#ifdef V8_INTL_SUPPORT\n#include \"src/objects/intl-objects.h\"\n#endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JSCallReducerAssembler\",\n            \"extends\": \"JSGraphAssembler\",\n            \"about\": \"Helper class to simplify creating nodes for reducing JS calls.\",\n            \"attributes\": [\n                {\n                    \"name\": \"dependencies_\",\n                    \"type\": \"CompilationDependencies*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Compilation dependencies for the reducer.\"\n                },\n                {\n                    \"name\": \"node_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The node being reduced.\"\n                }\n            ],\n            \"dependencies\": [\n                \"JSGraphAssembler\",\n                \"CompilationDependencies\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass JSCallReducerAssembler : public JSGraphAssembler {\n  static constexpr bool kMarkLoopExits = true;\n\n public:\n  JSCallReducerAssembler(JSCallReducer* reducer, Node* node,\n                         Node* effect = nullptr, Node* control = nullptr)\n      : JSGraphAssembler(\n            reducer->broker(), reducer->JSGraphForGraphAssembler(),\n            reducer->ZoneForGraphAssembler(), BranchSemantics::kJS,\n            [reducer](Node* n) { reducer->RevisitForGraphAssembler(n); },\n            kMarkLoopExits),\n        dependencies_(reducer->dependencies()),\n        node_(node) {\n    InitializeEffectControl(\n        effect ? effect : NodeProperties::GetEffectInput(node),\n        control ? control : NodeProperties::GetControlInput(node));\n\n    // Finish initializing the outermost catch scope.\n    bool has_handler =\n        NodeProperties::IsExceptionalCall(node, &outermost_handler_);\n    outermost_catch_scope_.set_has_handler(has_handler);\n  }\n\n  TNode<Object> ReduceJSCallWithArrayLikeOrSpreadOfEmpty(\n      std::unordered_set<Node*>* generated_calls_with_array_like_or_spread);\n  TNode<Object> ReduceMathUnary(const Operator* op);\n  TNode<Object> ReduceMathBinary(const Operator* op);\n  TNode<String> ReduceStringPrototypeSubstring();\n  TNode<Boolean> ReduceStringPrototypeStartsWith();\n  TNode<Boolean> ReduceStringPrototypeStartsWith(\n      StringRef search_element_string);\n  TNode<Boolean> ReduceStringPrototypeEndsWith();\n  TNode<Boolean> ReduceStringPrototypeEndsWith(StringRef search_element_string);\n  TNode<String> ReduceStringPrototypeCharAt();\n  TNode<String> ReduceStringPrototypeCharAt(StringRef s, uint32_t index);\n  TNode<String> ReduceStringPrototypeSlice();\n  TNode<Object> ReduceJSCallMathMinMaxWithArrayLike(Builtin builtin);\n\n  TNode<Object> TargetInput() const { return JSCallNode{node_ptr()}.target(); }\n\n  template <typename T>\n  TNode<T> ReceiverInputAs() const {\n    return TNode<T>::UncheckedCast(JSCallNode{node_ptr()}.receiver());\n  }\n\n  TNode<Object> ReceiverInput() const { return ReceiverInputAs<Object>(); }\n\n  Node* node_ptr() const { return node_; }\n\n  // Simplified operators.\n  TNode<Number> SpeculativeToNumber(\n      TNode<Object> value,\n      NumberOperationHint hint = NumberOperationHint::kNumberOrOddball);\n  TNode<Smi> CheckSmi(TNode<Object> value);\n  TNode<Number> CheckNumber(TNode<Object> value);\n  TNode<String> CheckString(TNode<Object> value);\n  TNode<Number> CheckBounds(TNode<Number> value, TNode<Number> limit,\n                            CheckBoundsFlags flags = {});\n\n  // Common operators.\n  TNode<Smi> TypeGuardUnsignedSmall(TNode<Object> value);\n  TNode<Object> TypeGuardNonInternal(TNode<Object> value);\n  TNode<Number> TypeGuardFixedArrayLength(TNode<Object> value);\n  TNode<Object> Call4(const Callable& callable, TNode<Context> context,\n                      TNode<Object> arg0, TNode<Object> arg1,\n                      TNode<Object> arg2, TNode<Object> arg3);\n\n  // Javascript operators.\n  TNode<Object> JSCall3(TNode<Object> function, TNode<Object> this_arg,\n                        TNode<Object> arg0, TNode<Object> arg1,\n                        TNode<Object> arg2, FrameState frame_state);\n  TNode<Object> JSCall4(TNode<Object> function, TNode<Object> this_arg,\n                        TNode<Object> arg0, TNode<Object> arg1,\n                        TNode<Object> arg2, TNode<Object> arg3,\n                        FrameState frame_state);\n\n  // Emplace a copy of the call node into the graph at current effect/control.\n  TNode<Object> CopyNode();\n\n  // Used in special cases in which we are certain CreateArray does not throw.\n  TNode<JSArray> CreateArrayNoThrow(TNode<Object> ctor, TNode<Number> size,\n                                    FrameState frame_state);\n\n  TNode<JSArray> AllocateEmptyJSArray(ElementsKind kind,\n                                      NativeContextRef native_context);\n\n  TNode<Number> NumberInc(TNode<Number> value) {\n    return NumberAdd(value, OneConstant());\n  }\n\n  TNode<Number> LoadMapElementsKind(TNode<Map> map);\n\n  template <typename T, typename U>\n  TNode<T> EnterMachineGraph(TNode<U> input, UseInfo use_info) {\n    return AddNode<T>(\n        graph()->NewNode(common()->EnterMachineGraph(use_info), input));\n  }\n\n  template <typename T, typename U>\n  TNode<T> ExitMachineGraph(TNode<U> input,\n                            MachineRepresentation output_representation,\n                            Type output_type) {\n    return AddNode<T>(graph()->NewNode(\n        common()->ExitMachineGraph(output_representation, output_type), input));\n  }\n\n  void MaybeInsertMapChecks(MapInference* inference,\n                            bool has_stability_dependency) {\n    // TODO(jgruber): Implement MapInference::InsertMapChecks in graph\n    // assembler.\n    if (!has_stability_dependency) {\n      Effect e = effect();\n      inference->InsertMapChecks(jsgraph(), &e, Control{control()}, feedback());\n      InitializeEffectControl(e, control());\n    }\n  }\n\n  TNode<Object> ConvertHoleToUndefined(TNode<Object> value, ElementsKind kind) {\n    DCHECK(IsHoleyElementsKind(kind));\n    if (kind == HOLEY_DOUBLE_ELEMENTS) {\n      return AddNode<Number>(\n          graph()->NewNode(simplified()->ChangeFloat64HoleToTagged(), value));\n    }\n    return ConvertTaggedHoleToUndefined(value);\n  }\n\n  class TryCatchBuilder0 {\n   public:\n    using TryFunction = VoidGenerator0;\n    using CatchFunction = std::function<void(TNode<Object>)>;\n\n    TryCatchBuilder0(JSCallReducerAssembler* gasm, const TryFunction& try_body)\n        : gasm_(gasm), try_body_(try_body) {}\n\n    void Catch(const CatchFunction& catch_body) {\n      TNode<Object> handler_exception;\n      Effect handler_effect{nullptr};\n      Control handler_control{nullptr};\n\n      auto continuation = gasm_->MakeLabel();\n\n      // Try.\n      {\n        CatchScope catch_scope = CatchScope::Inner(gasm_->temp_zone(), gasm_);\n        try_body_();\n        gasm_->Goto(&continuation);\n\n        catch_scope.MergeExceptionalPaths(&handler_exception, &handler_effect,\n                                          &handler_control);\n      }\n\n      // Catch.\n      {\n        gasm_->InitializeEffectControl(handler_effect, handler_control);\n        catch_body(handler_exception);\n        gasm_->Goto(&continuation);\n      }\n\n      gasm_->Bind(&continuation);\n    }\n\n   private:\n    JSCallReducerAssembler* const gasm_;\n    const VoidGenerator0 try_body_;\n  };\n\n  TryCatchBuilder0 Try(const VoidGenerator0& try_body) {\n    return {this, try_body};\n  }\n\n  using ConditionFunction1 = std::function<TNode<Boolean>(TNode<Number>)>;\n  using StepFunction1 = std::function<TNode<Number>(TNode<Number>)>;\n  class ForBuilder0 {\n    using For0BodyFunction = std::function<void(TNode<Number>)>;\n\n   public:\n    ForBuilder0(JSGraphAssembler* gasm, TNode<Number> initial_value,\n                const ConditionFunction1& cond, const StepFunction1& step)\n        : gasm_(gasm),\n          initial_value_(initial_value),\n          cond_(cond),\n          step_(step) {}\n\n    void Do(const For0BodyFunction& body) {\n      auto loop_exit = gasm_->MakeLabel();\n\n      {\n        GraphAssembler::LoopScope<kPhiRepresentation> loop_scope(gasm_);\n\n        auto loop_header = loop_scope.loop_header_label();\n        auto loop_body = gasm_->MakeLabel();\n\n        gasm_->Goto(loop_header, initial_value_);\n\n        gasm_->Bind(loop_header);\n        TNode<Number> i = loop_header->PhiAt<Number>(0);\n\n        gasm_->BranchWithHint(cond_(i), &loop_body, &loop_exit,\n                              BranchHint::kTrue);\n\n        gasm_->Bind(&loop_body);\n        body(i);\n        gasm_->Goto(loop_header, step_(i));\n      }\n\n      gasm_->Bind(&loop_exit);\n    }\n\n   private:\n    static constexpr MachineRepresentation kPhiRepresentation =\n        MachineRepresentation::kTagged;\n\n    JSGraphAssembler* const gasm_;\n    const TNode<Number> initial_value_;\n    const ConditionFunction1 cond_;\n    const StepFunction1 step_;\n  };\n\n  ForBuilder0 ForZeroUntil(TNode<Number> excluded_limit) {\n    TNode<Number> initial_value = ZeroConstant();\n    auto cond = [=, this](TNode<Number> i) {\n      return NumberLessThan(i, excluded_limit);\n    };\n    auto step = [=, this](TNode<Number> i) {\n      return NumberAdd(i, OneConstant());\n    };\n    return {this, initial_value, cond, step};\n  }\n\n  ForBuilder0 Forever(TNode<Number> initial_value, const StepFunction1& step) {\n    return {this, initial_value,\n            [=, this](TNode<Number>) { return TrueConstant(); }, step};\n  }\n\n  using For1BodyFunction = std::function<void(TNode<Number>, TNode<Object>*)>;\n  class ForBuilder1 {\n   public:\n    ForBuilder1(JSGraphAssembler* gasm, TNode<Number> initial_value,\n                const ConditionFunction1& cond, const StepFunction1& step,\n                TNode<Object> initial_arg0)\n        : gasm_(gasm),\n          initial_value_(initial_value),\n          cond_(cond),\n          step_(step),\n          initial_arg0_(initial_arg0) {}\n\n    V8_WARN_UNUSED_RESULT ForBuilder1& Do(const For1BodyFunction& body) {\n      body_ = body;\n      return *this;\n    }\n\n    V8_WARN_UNUSED_RESULT TNode<Object> Value() {\n      DCHECK(body_);\n      TNode<Object> arg0 = initial_arg0_;\n\n      auto loop_exit = gasm_->MakeDeferredLabel(kPhiRepresentation);\n\n      {\n        GraphAssembler::LoopScope<kPhiRepresentation, kPhiRepresentation>\n            loop_scope(gasm_);\n\n        auto loop_header = loop_scope.loop_header_label();\n        auto loop_body = gasm_->MakeDeferredLabel(kPhiRepresentation);\n\n        gasm_->Goto(loop_header, initial_value_, initial_arg0_);\n\n        gasm_->Bind(loop_header);\n        TNode<Number> i = loop_header->PhiAt<Number>(0);\n        arg0 = loop_header->PhiAt<Object>(1);\n\n        gasm_->BranchWithHint(cond_(i), &loop_body, &loop_exit,\n                              BranchHint::kTrue, arg0);\n\n        gasm_->Bind(&loop_body);\n        body_(i, &arg0);\n        gasm_->Goto(loop_header, step_(i), arg0);\n      }\n\n      gasm_->Bind(&loop_exit);\n      return TNode<Object>::UncheckedCast(loop_exit.PhiAt<Object>(0));\n    }\n\n    void ValueIsUnused() { USE(Value()); }\n\n   private:\n    static constexpr MachineRepresentation kPhiRepresentation =\n        MachineRepresentation::kTagged;\n\n    JSGraphAssembler* const gasm_;\n    const TNode<Number> initial_value_;\n    const ConditionFunction1 cond_;\n    const StepFunction1 step_;\n    For1BodyFunction body_;\n    const TNode<Object> initial_arg0_;\n  };\n\n  ForBuilder1 For1(TNode<Number> initial_value, const ConditionFunction1& cond,\n                   const StepFunction1& step, TNode<Object> initial_arg0) {\n    return {this, initial_value, cond, step, initial_arg0};\n  }\n\n  ForBuilder1 For1ZeroUntil(TNode<Number> excluded_limit,\n                            TNode<Object> initial_arg0) {\n    TNode<Number> initial_value = ZeroConstant();\n    auto cond = [=, this](TNode<Number> i) {\n      return NumberLessThan(i, excluded_limit);\n    };\n    auto step = [=, this](TNode<Number> i) {\n      return NumberAdd(i, OneConstant());\n    };\n    return {this, initial_value, cond, step, initial_arg0};\n  }\n\n  void ThrowIfNotCallable(TNode<Object> maybe_callable,\n                          FrameState frame_state) {\n    IfNot(ObjectIsCallable(maybe_callable))\n        .Then(_ {\n          JSCallRuntime1(Runtime::kThrowCalledNonCallable, maybe_callable,\n                         ContextInput(), frame_state);\n          Unreachable();  // The runtime call throws unconditionally.\n        })\n        .ExpectTrue();\n  }\n\n  const FeedbackSource& feedback() const {\n    CallParameters const& p = CallParametersOf(node_ptr()->op());\n    return p.feedback();\n  }\n\n  int ArgumentCount() const { return JSCallNode{node_ptr()}.ArgumentCount(); }\n\n  TNode<Object> Argument(int index) const {\n    return TNode<Object>::UncheckedCast(JSCallNode{node_ptr()}.Argument(index));\n  }\n\n  template <typename T>\n  TNode<T> ArgumentAs(int index) const {\n    return TNode<T>::UncheckedCast(Argument(index));\n  }\n\n  TNode<Object> ArgumentOrNaN(int index) {\n    return TNode<Object>::UncheckedCast(\n        ArgumentCount() > index ? Argument(index) : NaNConstant());\n  }\n\n  TNode<Object> ArgumentOrUndefined(int index) {\n    return TNode<Object>::UncheckedCast(\n        ArgumentCount() > index ? Argument(index) : UndefinedConstant());\n  }\n\n  TNode<Number> ArgumentOrZero(int index) {\n    return TNode<Number>::UncheckedCast(\n        ArgumentCount() > index ? Argument(index) : ZeroConstant());\n  }\n\n  TNode<Context> ContextInput() const {\n    return TNode<Context>::UncheckedCast(\n        NodeProperties::GetContextInput(node_));\n  }\n\n  FrameState FrameStateInput() const {\n    return FrameState(NodeProperties::GetFrameStateInput(node_));\n  }\n\n  CompilationDependencies* dependencies() const { return dependencies_; }\n\n private:\n  CompilationDependencies* const dependencies_;\n  Node* const node_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IteratingArrayBuiltinReducerAssembler\",\n            \"extends\": \"JSCallReducerAssembler\",\n            \"about\": \"Helper class for reducing iterating array builtins.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"JSCallReducerAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nenum class ArrayReduceDirection { kLeft, kRight };\nenum class ArrayFindVariant { kFind, kFindIndex };\nenum class ArrayEverySomeVariant { kEvery, kSome };\nenum class ArrayIndexOfIncludesVariant { kIncludes, kIndexOf };\n\n// This subclass bundles functionality specific to reducing iterating array\n// builtins.\nclass IteratingArrayBuiltinReducerAssembler : public JSCallReducerAssembler {\n public:\n  IteratingArrayBuiltinReducerAssembler(JSCallReducer* reducer, Node* node)\n      : JSCallReducerAssembler(reducer, node) {\n    DCHECK(v8_flags.turbo_inline_array_builtins);\n  }\n\n  TNode<Object> ReduceArrayPrototypeForEach(MapInference* inference,\n                                            const bool has_stability_dependency,\n                                            ElementsKind kind,\n                                            SharedFunctionInfoRef shared);\n  TNode<Object> ReduceArrayPrototypeReduce(MapInference* inference,\n                                           const bool has_stability_dependency,\n                                           ElementsKind kind,\n                                           ArrayReduceDirection direction,\n                                           SharedFunctionInfoRef shared);\n  TNode<JSArray> ReduceArrayPrototypeMap(MapInference* inference,\n                                         const bool has_stability_dependency,\n                                         ElementsKind kind,\n                                         SharedFunctionInfoRef shared,\n                                         NativeContextRef native_context);\n  TNode<JSArray> ReduceArrayPrototypeFilter(MapInference* inference,\n                                            const bool has_stability_dependency,\n                                            ElementsKind kind,\n                                            SharedFunctionInfoRef shared,\n                                            NativeContextRef native_context);\n  TNode<Object> ReduceArrayPrototypeFind(MapInference* inference,\n                                         const bool has_stability_dependency,\n                                         ElementsKind kind,\n                                         SharedFunctionInfoRef shared,\n                                         NativeContextRef native_context,\n                                         ArrayFindVariant variant);\n  TNode<Boolean> ReduceArrayPrototypeEverySome(\n      MapInference* inference, const bool has_stability_dependency,\n      ElementsKind kind, SharedFunctionInfoRef shared,\n      NativeContextRef native_context, ArrayEverySomeVariant variant);\n  TNode<Object> ReduceArrayPrototypeAt(ZoneVector<MapRef> kinds,\n                                       bool needs_fallback_builtin_call);\n  TNode<Object> ReduceArrayPrototypeIndexOfIncludes(\n      ElementsKind kind, ArrayIndexOfIncludesVariant variant);\n  TNode<Number> ReduceArrayPrototypePush(MapInference* inference);\n\n private:\n  // Returns {index,value}. Assumes that the map has not changed, but possibly\n  // the length and backing store.\n  std::pair<TNode<Number>, TNode<Object>> SafeLoadElement(ElementsKind kind,\n                                                          TNode<JSArray> o,\n                                                          TNode<Number> index) {\n    // Make sure that the access is still in bounds, since the callback could\n    // have changed the array's size.\n    TNode<Number> length = LoadJSArrayLength(o, kind);\n    index = CheckBounds(index, length);\n\n    // Reload the elements pointer before calling the callback, since the\n    // previous callback might have resized the array causing the elements\n    // buffer to be re-allocated.\n    TNode<HeapObject> elements =\n        LoadField<HeapObject>(AccessBuilder::ForJSObjectElements(), o);\n    TNode<Object> value = LoadElement<Object>(\n        AccessBuilder::ForFixedArrayElement(kind), elements, index);\n    return std::make_pair(index, value);\n  }\n\n  template <typename... Vars>\n  TNode<Object> MaybeSkipHole(\n      TNode<Object> o, ElementsKind kind,\n      GraphAssemblerLabel<sizeof...(Vars)>* continue_label,\n      TNode<Vars>... vars) {\n    if (!IsHoleyElementsKind(kind)) return o;\n\n    auto if_not_hole = MakeLabel(MachineRepresentationOf<Vars>::value...);\n    BranchWithHint(HoleCheck(kind, o), continue_label, &if_not_hole,\n                   BranchHint::kFalse, vars...);\n\n    // The contract is that we don't leak \"the hole\" into \"user JavaScript\",\n    // so we must rename the {element} here to explicitly exclude \"the hole\"\n    // from the type of {element}.\n    Bind(&if_not_hole);\n    return TypeGuardNonInternal(o);\n  }\n\n  TNode<Smi> LoadJSArrayLength(TNode<JSArray> array, ElementsKind kind) {\n    return LoadField<Smi>(AccessBuilder::ForJSArrayLength(kind), array);\n  }\n  void StoreJSArrayLength(TNode<JSArray> array, TNode<Number> value,\n                          ElementsKind kind) {\n    StoreField(AccessBuilder::ForJSArrayLength(kind), array, value);\n  }\n  void StoreFixedArrayBaseElement(TNode<FixedArrayBase> o, TNode<Number> index,\n                                  TNode<Object> v, ElementsKind kind) {\n    StoreElement(AccessBuilder::ForFixedArrayElement(kind), o, index, v);\n  }\n\n  TNode<FixedArrayBase> LoadElements(TNode<JSObject> o) {\n    return LoadField<FixedArrayBase>(AccessBuilder::ForJSObjectElements(), o);\n  }\n  TNode<Smi> LoadFixedArrayBaseLength(TNode<FixedArrayBase> o) {\n    return LoadField<Smi>(AccessBuilder::ForFixedArrayLength(), o);\n  }\n\n  TNode<Boolean> HoleCheck(ElementsKind kind, TNode<Object> v) {\n    return IsDoubleElementsKind(kind)\n               ? NumberIsFloat64Hole(TNode<Number>::UncheckedCast(v))\n               : IsTheHole(v);\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PromiseBuiltinReducerAssembler\",\n            \"extends\": \"JSCallReducerAssembler\",\n            \"about\": \"Helper class for reducing Promise constructor calls.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"JSCallReducerAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass PromiseBuiltinReducerAssembler : public JSCallReducerAssembler {\n public:\n  PromiseBuiltinReducerAssembler(JSCallReducer* reducer, Node* node)\n      : JSCallReducerAssembler(reducer, node) {\n    DCHECK_EQ(IrOpcode::kJSConstruct, node->opcode());\n  }\n\n  TNode<Object> ReducePromiseConstructor(NativeContextRef native_context);\n\n  int ConstructArity() const {\n    return JSConstructNode{node_ptr()}.ArgumentCount();\n  }\n\n  TNode<Object> TargetInput() const {\n    return JSConstructNode{node_ptr()}.target();\n  }\n\n  TNode<Object> NewTargetInput() const {\n    return JSConstructNode{node_ptr()}.new_target();\n  }\n\n private:\n  TNode<JSPromise> CreatePromise(TNode<Context> context) {\n    return AddNode<JSPromise>(\n        graph()->NewNode(javascript()->CreatePromise(), context, effect()));\n  }\n\n  TNode<Context> CreateFunctionContext(NativeContextRef native_context,\n                                       TNode<Context> outer_context,\n                                       int slot_count) {\n    return AddNode<Context>(graph()->NewNode(\n        javascript()->CreateFunctionContext(\n            native_context.scope_info(broker()),\n            slot_count - Context::MIN_CONTEXT_SLOTS, FUNCTION_SCOPE),\n        outer_context, effect(), control()));\n  }\n\n  void StoreContextSlot(TNode<Context> context, size_t slot_index,\n                        TNode<Object> value) {\n    StoreField(AccessBuilder::ForContextSlot(slot_index), context, value);\n  }\n\n  TNode<JSFunction> CreateClosureFromBuiltinSharedFunctionInfo(\n      SharedFunctionInfoRef shared, TNode<Context> context) {\n    DCHECK(shared.HasBuiltinId());\n    Handle<FeedbackCell> feedback_cell =\n        isolate()->factory()->many_closures_cell();\n    Callable const callable =\n        Builtins::CallableFor(isolate(), shared.builtin_id());\n    CodeRef code = MakeRef(broker(), *callable.code());\n    return AddNode<JSFunction>(graph()->NewNode(\n        javascript()->CreateClosure(shared, code), HeapConstant(feedback_cell),\n        context, effect(), control()));\n  }\n\n  void CallPromiseExecutor(TNode<Object> executor, TNode<JSFunction> resolve,\n                           TNode<JSFunction> reject, FrameState frame_state) {\n    JSConstructNode n(node_ptr());\n    const ConstructParameters& p = n.Parameters();\n    FeedbackSource no_feedback_source{};\n    Node* no_feedback = UndefinedConstant();\n    MayThrow(_ {\n      return AddNode<Object>(graph()->NewNode(\n          javascript()->Call(JSCallNode::ArityForArgc(2), p.frequency(),\n                             no_feedback_source,\n                             ConvertReceiverMode::kNullOrUndefined),\n          executor, UndefinedConstant(), resolve, reject, no_feedback,\n          n.context(), frame_state, effect(), control()));\n    });\n  }\n\n  void CallPromiseReject(TNode<JSFunction> reject, TNode<Object> exception,\n                         FrameState frame_state) {\n    JSConstructNode n(node_ptr());\n    const ConstructParameters& p = n.Parameters();\n    FeedbackSource no_feedback_source{};\n    Node* no_feedback = UndefinedConstant();\n    MayThrow(_ {\n      return AddNode<Object>(graph()->NewNode(\n          javascript()->Call(JSCallNode::ArityForArgc(1), p.frequency(),\n                             no_feedback_source,\n                             ConvertReceiverMode::kNullOrUndefined),\n          reject, UndefinedConstant(), exception, no_feedback, n.context(),\n          frame_state, effect(), control()));\n    });\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FastApiCallReducerAssembler\",\n            \"extends\": \"JSCallReducerAssembler\",\n            \"about\": \"Helper class for reducing fast API calls.\",\n            \"attributes\": [\n                {\n                    \"name\": \"c_function_\",\n                    \"type\": \"FastApiCallFunction\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The C function to be called.\"\n                },\n                {\n                    \"name\": \"function_template_info_\",\n                    \"type\": \"FunctionTemplateInfoRef\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Information about the function template.\"\n                },\n                {\n                    \"name\": \"receiver_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The receiver of the call.\"\n                },\n                {\n                    \"name\": \"shared_\",\n                    \"type\": \"SharedFunctionInfoRef\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Shared function info of the function being called.\"\n                },\n                {\n                    \"name\": \"target_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The target of the call.\"\n                },\n                {\n                    \"name\": \"arity_\",\n                    \"type\": \"const int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The arity of the function.\"\n                }\n            ],\n            \"dependencies\": [\n                \"JSCallReducerAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass FastApiCallReducerAssembler : public JSCallReducerAssembler {\n public:\n  FastApiCallReducerAssembler(\n      JSCallReducer* reducer, Node* node,\n      const FunctionTemplateInfoRef function_template_info,\n      FastApiCallFunction c_function, Node* receiver,\n      const SharedFunctionInfoRef shared, Node* target, const int arity,\n      Node* effect)\n      : JSCallReducerAssembler(reducer, node),\n        c_function_(c_function),\n        function_template_info_(function_template_info),\n        receiver_(receiver),\n        shared_(shared),\n        target_(target),\n        arity_(arity) {\n    DCHECK_EQ(IrOpcode::kJSCall, node->opcode());\n    InitializeEffectControl(effect, NodeProperties::GetControlInput(node));\n  }\n\n  TNode<Object> ReduceFastApiCall() {\n    JSCallNode n(node_ptr());\n\n    // C arguments include the receiver at index 0. Thus C index 1 corresponds\n    // to the JS argument 0, etc.\n    // All functions in c_candidate_functions_ have the same number of\n    // arguments, so extract c_argument_count from the first function.\n    const int c_argument_count =\n        static_cast<int>(c_function_.signature->ArgumentCount());\n    CHECK_GE(c_argument_count, kReceiver);\n\n    const int slow_arg_count =\n        // Arguments for CallApiCallbackOptimizedXXX builtin including\n        // context, see CallApiCallbackOptimizedDescriptor.\n        kSlowBuiltinParams +\n        // JS arguments.\n        kReceiver + arity_;\n\n    const int value_input_count =\n        FastApiCallNode::ArityForArgc(c_argument_count, slow_arg_count);\n\n    base::SmallVector<Node*, kInlineSize> inputs(value_input_count +\n                                                 kEffectAndControl);\n    int cursor = 0;\n    inputs[cursor++] = n.receiver();\n\n    // TODO(turbofan): Consider refactoring CFunctionInfo to distinguish\n    // between receiver and arguments, simplifying this (and related) spots.\n    int js_args_count = c_argument_count - kReceiver;\n    for (int i = 0; i < js_args_count; ++i) {\n      if (i < n.ArgumentCount()) {\n        inputs[cursor++] = n.Argument(i);\n      } else {\n        inputs[cursor++] = UndefinedConstant();\n      }\n    }\n\n    // Here we add the arguments for the slow call, which will be\n    // reconstructed at a later phase. Those are effectively the same\n    // arguments as for the fast call, but we want to have them as\n    // separate inputs, so that SimplifiedLowering can provide the best\n    // possible UseInfos for each of them. The inputs to FastApiCall\n    // look like:\n    // [receiver, ... C arguments, callback data,\n    //  slow call code, external constant for function, argc,\n    //  FunctionTemplateInfo, holder, receiver, ... JS arguments,\n    //  context, new frame state].\n    bool no_profiling =\n        broker()->dependencies()->DependOnNoProfilingProtector();\n    Callable call_api_callback = Builtins::CallableFor(\n        isolate(), no_profiling ? Builtin::kCallApiCallbackOptimizedNoProfiling\n                                : Builtin::kCallApiCallbackOptimized);\n    "
}