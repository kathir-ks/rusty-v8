{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/ast.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/ast.h\",\n            \"file_name\": \"ast.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the Abstract Syntax Tree (AST) nodes for the Torque language used in V8.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers for various functionalities like containers, memory management, and strings.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <algorithm>\n            #include <iostream>\n            #include <map>\n            #include <memory>\n            #include <optional>\n            #include <set>\n            #include <string>\n            #include <vector>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes V8-specific headers for integer literals, constants, source positions, and utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/numbers/integer-literal.h\"\n            #include \"src/torque/constants.h\"\n            #include \"src/torque/source-positions.h\"\n            #include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::internal::torque\",\n                \"purpose\": \"Encapsulates all Torque-related code within the V8 namespace.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8::internal::torque {\n        ]]></code>\n\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"AST_EXPRESSION_NODE_KIND_LIST\",\n                    \"purpose\": \"Defines a list of macro calls for different kinds of expression nodes in the AST.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                #define AST_EXPRESSION_NODE_KIND_LIST(V) \\\n                  V(CallExpression)                      \\\n                  V(CallMethodExpression)                \\\n                  V(IntrinsicCallExpression)             \\\n                  V(StructExpression)                    \\\n                  V(LogicalOrExpression)                 \\\n                  V(LogicalAndExpression)                \\\n                  V(SpreadExpression)                    \\\n                  V(ConditionalExpression)               \\\n                  V(IdentifierExpression)                \\\n                  V(StringLiteralExpression)             \\\n                  V(IntegerLiteralExpression)            \\\n                  V(FloatingPointLiteralExpression)      \\\n                  V(FieldAccessExpression)               \\\n                  V(ElementAccessExpression)             \\\n                  V(DereferenceExpression)               \\\n                  V(AssignmentExpression)                \\\n                  V(IncrementDecrementExpression)        \\\n                  V(NewExpression)                       \\\n                  V(AssumeTypeImpossibleExpression)      \\\n                  V(StatementExpression)                 \\\n                  V(TryLabelExpression)\n            ]]></code>\n        </macro>\n\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"AST_TYPE_EXPRESSION_NODE_KIND_LIST\",\n                    \"purpose\": \"Defines a list of macro calls for different kinds of type expression nodes in the AST.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                #define AST_TYPE_EXPRESSION_NODE_KIND_LIST(V) \\\n                  V(BasicTypeExpression)                      \\\n                  V(FunctionTypeExpression)                   \\\n                  V(PrecomputedTypeExpression)                \\\n                  V(UnionTypeExpression)\n            ]]></code>\n        </macro>\n\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"AST_STATEMENT_NODE_KIND_LIST\",\n                    \"purpose\": \"Defines a list of macro calls for different kinds of statement nodes in the AST.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                #define AST_STATEMENT_NODE_KIND_LIST(V) \\\n                  V(BlockStatement)                     \\\n                  V(ExpressionStatement)                \\\n                  V(IfStatement)                        \\\n                  V(WhileStatement)                     \\\n                  V(ForLoopStatement)                   \\\n                  V(BreakStatement)                     \\\n                  V(ContinueStatement)                  \\\n                  V(ReturnStatement)                    \\\n                  V(DebugStatement)                     \\\n                  V(AssertStatement)                    \\\n                  V(TailCallStatement)                  \\\n                  V(VarDeclarationStatement)            \\\n                  V(GotoStatement)\n            ]]></code>\n        </macro>\n\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"AST_TYPE_DECLARATION_NODE_KIND_LIST\",\n                    \"purpose\": \"Defines a list of macro calls for different kinds of type declaration nodes in the AST.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                #define AST_TYPE_DECLARATION_NODE_KIND_LIST(V) \\\n                  V(AbstractTypeDeclaration)                   \\\n                  V(TypeAliasDeclaration)                      \\\n                  V(BitFieldStructDeclaration)                 \\\n                  V(ClassDeclaration)                          \\\n                  V(StructDeclaration)\n            ]]></code>\n        </macro>\n\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"AST_DECLARATION_NODE_KIND_LIST\",\n                    \"purpose\": \"Defines a list of macro calls for different kinds of declaration nodes in the AST.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                #define AST_DECLARATION_NODE_KIND_LIST(V) \\\n                  AST_TYPE_DECLARATION_NODE_KIND_LIST(V)  \\\n                  V(GenericCallableDeclaration)           \\\n                  V(GenericTypeDeclaration)               \\\n                  V(SpecializationDeclaration)            \\\n                  V(ExternConstDeclaration)               \\\n                  V(NamespaceDeclaration)                 \\\n                  V(ConstDeclaration)                     \\\n                  V(CppIncludeDeclaration)                \\\n                  V(TorqueMacroDeclaration)               \\\n                  V(TorqueBuiltinDeclaration)               \\\n                  V(ExternalMacroDeclaration)             \\\n                  V(ExternalBuiltinDeclaration)           \\\n                  V(ExternalRuntimeDeclaration)           \\\n                  V(IntrinsicDeclaration)\n            ]]></code>\n        </macro>\n\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"AST_NODE_KIND_LIST\",\n                    \"purpose\": \"Aggregates all the node kind lists into a single list.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                #define AST_NODE_KIND_LIST(V)           \\\n                  AST_EXPRESSION_NODE_KIND_LIST(V)      \\\n                  AST_TYPE_EXPRESSION_NODE_KIND_LIST(V) \\\n                  AST_STATEMENT_NODE_KIND_LIST(V)       \\\n                  AST_DECLARATION_NODE_KIND_LIST(V)     \\\n                  V(Identifier)                         \\\n                  V(TryHandler)                         \\\n                  V(ClassBody)\n            ]]></code>\n        </macro>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"AstNode\",\n                    \"about\": \"Base class for all AST nodes.  Contains the node kind and source position.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"kind\",\n                            \"type\": \"Kind\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The type of AST node.\"\n                        },\n                        {\n                            \"name\": \"pos\",\n                            \"type\": \"SourcePosition\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The position of this node in the source code.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct AstNode {\n                 public:\n                  enum class Kind {\n                #define ENUM_ITEM(name) k##name,\n                    AST_NODE_KIND_LIST(ENUM_ITEM)\n                #undef ENUM_ITEM\n                  };\n\n                  AstNode(Kind kind, SourcePosition pos) : kind(kind), pos(pos) {}\n                  virtual ~AstNode() = default;\n\n                  const Kind kind;\n                  SourcePosition pos;\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"AstNodeClassCheck\",\n                    \"about\": \"Helper struct for checking the type of an AstNode at runtime.  Used for downcasting.\",\n                    \"methods\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                struct AstNodeClassCheck {\n                  template <class T>\n                  static bool IsInstanceOf(AstNode* node);\n                };\n            ]]></code>\n        </struct>\n\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"DEFINE_AST_NODE_LEAF_BOILERPLATE\",\n                    \"purpose\": \"Boilerplate macro for defining static cast methods and kind for leaf AST nodes.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"T\",\n                            \"type\": \"typename\",\n                            \"purpose\": \"The name of the class.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                #define DEFINE_AST_NODE_LEAF_BOILERPLATE(T)  \\\n                  static const Kind kKind = Kind::k##T;      \\\n                  static T* cast(AstNode* node) {            \\\n                    DCHECK_EQ(node->kind, kKind);            \\\n                    return static_cast<T*>(node);            \\\n                  }                                          \\\n                  static T* DynamicCast(AstNode* node) {     \\\n                    if (!node) return nullptr;               \\\n                    if (node->kind != kKind) return nullptr; \\\n                    return static_cast<T*>(node);            \\\n                  }\n            ]]></code>\n        </macro>\n\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"DEFINE_AST_NODE_INNER_BOILERPLATE\",\n                    \"purpose\": \"Boilerplate macro for defining static cast methods for inner AST nodes (nodes with subclasses).\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"T\",\n                            \"type\": \"typename\",\n                            \"purpose\": \"The name of the class.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                #define DEFINE_AST_NODE_INNER_BOILERPLATE(T)                       \\\n                  static T* cast(AstNode* node) {                                  \\\n                    DCHECK(AstNodeClassCheck::IsInstanceOf<T>(node));              \\\n                    return static_cast<T*>(node);                                  \\\n                  }                                                                \\\n                  static T* DynamicCast(AstNode* node) {                           \\\n                    if (!node) return nullptr;                                     \\\n                    if (!AstNodeClassCheck::IsInstanceOf<T>(node)) return nullptr; \\\n                    return static_cast<T*>(node);                                  \\\n                  }\n            ]]></code>\n        </macro>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"Expression\",\n                    \"extends\": \"AstNode\",\n                    \"about\": \"Base class for all expression AST nodes.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                struct Expression : AstNode {\n                  Expression(Kind kind, SourcePosition pos) : AstNode(kind, pos) {}\n                  DEFINE_AST_NODE_INNER_BOILERPLATE(Expression)\n\n                  using VisitCallback = std::function<void(Expression*)>;\n                  virtual void VisitAllSubExpressions(VisitCallback callback) {\n                    // TODO(szuend): Hoist this up to AstNode and make it a\n                    //               general Ast visitor.\n                  }\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"LocationExpression\",\n                    \"extends\": \"Expression\",\n                    \"about\": \"Base class for expressions that can appear on the left-hand side of an assignment.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                struct LocationExpression : Expression {\n                  LocationExpression(Kind kind, SourcePosition pos) : Expression(kind, pos) {}\n                  DEFINE_AST_NODE_INNER_BOILERPLATE(LocationExpression)\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"TypeExpression\",\n                    \"extends\": \"AstNode\",\n                    \"about\": \"Base class for AST nodes that represent type expressions.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                struct TypeExpression : AstNode {\n                  TypeExpression(Kind kind, SourcePosition pos) : AstNode(kind, pos) {}\n                  DEFINE_AST_NODE_INNER_BOILERPLATE(TypeExpression)\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"Declaration\",\n                    \"extends\": \"AstNode\",\n                    \"about\": \"Base class for all declaration AST nodes.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                struct Declaration : AstNode {\n                  Declaration(Kind kind, SourcePosition pos) : AstNode(kind, pos) {}\n                  DEFINE_AST_NODE_INNER_BOILERPLATE(Declaration)\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"Statement\",\n                    \"extends\": \"AstNode\",\n                    \"about\": \"Base class for all statement AST nodes.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                struct Statement : AstNode {\n                  Statement(Kind kind, SourcePosition pos) : AstNode(kind, pos) {}\n                  DEFINE_AST_NODE_INNER_BOILERPLATE(Statement)\n                };\n            ]]></code>\n        </struct>\n\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Namespace\",\n                    \"about\": \"Forward declaration of the Namespace class.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Namespace;\n            ]]></code>\n        </class>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"NamespaceDeclaration\",\n                    \"extends\": \"Declaration\",\n                    \"about\": \"Represents a namespace declaration in the AST.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"declarations\",\n                            \"type\": \"std::vector<Declaration*>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"A list of declarations inside this namespace.\"\n                        },\n                        {\n                            \"name\": \"name\",\n                            \"type\": \"std::string\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The name of the namespace.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct NamespaceDeclaration : Declaration {\n                  DEFINE_AST_NODE_LEAF_BOILERPLATE(NamespaceDeclaration)\n                  NamespaceDeclaration(SourcePosition pos, std::string name,\n                                       std::vector<Declaration*> declarations)\n                      : Declaration(kKind, pos),\n                        declarations(std::move(declarations)),\n                        name(name) {}\n                  std::vector<Declaration*> declarations;\n                  std::string name;\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"EnumDescription\",\n                    \"about\": \"Describes an enum declaration, including its name, entries, and constexpr generation settings.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"pos\",\n                            \"type\": \"SourcePosition\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Source position of the enum declaration.\"\n                        },\n                        {\n                            \"name\": \"name\",\n                            \"type\": \"std::string\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Name of the enum.\"\n                        },\n                        {\n                            \"name\": \"constexpr_generates\",\n                            \"type\": \"std::string\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Name of the constexpr function that generates the enum.\"\n                        },\n                        {\n                            \"name\": \"is_open\",\n                            \"type\": \"bool\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Whether the enum is open (can have more entries added later).\"\n                        },\n                        {\n                            \"name\": \"entries\",\n                            \"type\": \"std::vector<Entry>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"List of enum entries.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct EnumDescription {\n                  struct Entry {\n                    std::string name;\n                    std::string alias_entry;\n                    Entry(std::string name, std::string alias_entry)\n                        : name(std::move(name)), alias_entry(std::move(alias_entry)) {}\n                  };\n                  SourcePosition pos;\n                  std::string name;\n                  std::string constexpr_generates;\n                  bool is_open;\n                  std::vector<Entry> entries;\n\n                  EnumDescription(SourcePosition pos, std::string name,\n                                  std::string constexpr_generates, bool is_open,\n                                  std::vector<Entry> entries = {})\n                      : pos(std::move(pos)),\n                        name(std::move(name)),\n                        constexpr_generates(std::move(constexpr_generates)),\n                        is_open(is_open),\n                        entries(std::move(entries)) {}\n                };\n            ]]></code>\n        </struct>\n\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Ast\",\n                    \"about\": \"Represents the entire Abstract Syntax Tree.  Manages the list of declarations and AST nodes.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"declarations_\",\n                            \"type\": \"std::vector<Declaration*>\",\n                            \"access\": \"private\",\n                            \"purpose\": \"A list of top-level declarations.\"\n                        },\n                        {\n                            \"name\": \"nodes_\",\n                            \"type\": \"std::vector<std::unique_ptr<AstNode>>\",\n                            \"access\": \"private\",\n                            \"purpose\": \"A list of all AST nodes.\"\n                        },\n                                                {\n                            \"name\": \"declared_imports_\",\n                            \"type\": \"std::map<SourceId, std::set<SourceId>>\",\n                            \"access\": \"private\",\n                            \"purpose\": \"Tracks which files have declared imports for which other files.\"\n                        },\n                                                {\n                            \"name\": \"enum_descriptions_\",\n                            \"type\": \"std::vector<EnumDescription>\",\n                            \"access\": \"private\",\n                            \"purpose\": \"Stores descriptions of enum declarations.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                class Ast {\n                 public:\n                  Ast() = default;\n\n                  std::vector<Declaration*>& declarations() { return declarations_; }\n                  const std::vector<Declaration*>& declarations() const {\n                    return declarations_;\n                  }\n                  template <class T>\n                  T* AddNode(std::unique_ptr<T> node) {\n                    T* result = node.get();\n                    nodes_.push_back(std::move(node));\n                    return result;\n                  }\n\n                  void DeclareImportForCurrentFile(SourceId import_id) {\n                    declared_imports_[CurrentSourcePosition::Get().source].insert(import_id);\n                  }\n\n                  void AddEnumDescription(EnumDescription description) {\n                    std::string name = description.name;\n                    DCHECK(!name.empty());\n                    auto f = [&](const auto& d) { return d.name == name; };\n                    USE(f);  // Suppress unused in release.\n                    DCHECK_EQ(\n                        std::find_if(enum_descriptions_.begin(), enum_descriptions_.end(), f),\n                        enum_descriptions_.end());\n                    enum_descriptions_.push_back(std::move(description));\n                  }\n\n                  std::vector<EnumDescription>& EnumDescriptions() {\n                    return enum_descriptions_;\n                  }\n\n                 private:\n                  std::vector<Declaration*> declarations_;\n                  std::vector<std::unique_ptr<AstNode>> nodes_;\n                  std::map<SourceId, std::set<SourceId>> declared_imports_;\n                  std::vector<EnumDescription> enum_descriptions_;\n                };\n            ]]></code>\n        </class>\n\n        <const>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"kThisParameterName\",\n                    \"type\": \"const char*\",\n                    \"about\": \"Constant string representing the name of the 'this' parameter.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                static const char* const kThisParameterName = \"this\";\n            ]]></code>\n        </const>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"Identifier\",\n                    \"extends\": \"AstNode\",\n                    \"about\": \"Represents an identifier (a name) in the source code.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"value\",\n                            \"type\": \"std::string\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The string value of the identifier.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct Identifier : AstNode {\n                  DEFINE_AST_NODE_LEAF_BOILERPLATE(Identifier)\n                  Identifier(SourcePosition pos, std::string identifier)\n                      : AstNode(kKind, pos), value(std::move(identifier)) {}\n                  std::string value;\n                };\n            ]]></code>\n        </struct>\n\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"operator<<\",\n                    \"about\": \"Overloads the output stream operator for Identifier pointers.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"os\",\n                            \"type\": \"std::ostream&\",\n                            \"purpose\": \"The output stream.\"\n                        },\n                        {\n                            \"name\": \"id\",\n                            \"type\": \"Identifier*\",\n                            \"purpose\": \"The Identifier pointer to print.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"std::ostream&\",\n                        \"description\": \"The output stream.\"\n                    }\n                }\n            </metadata>\n            <code><![CDATA[\n                inline std::ostream& operator<<(std::ostream& os, Identifier* id) {\n                  return os << id->value;\n                }\n            ]]></code>\n        </func>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"IdentifierPtrValueEq\",\n                    \"about\": \"Functor for comparing identifiers based on their string values.\",\n                    \"attributes\": [],\n                    \"methods\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                struct IdentifierPtrValueEq {\n                  bool operator()(const Identifier* a, const Identifier* b) {\n                    return a->value < b->value;\n                  }\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"IdentifierExpression\",\n                    \"extends\": \"LocationExpression\",\n                    \"about\": \"Represents an identifier used as an expression (e.g., a variable lookup).\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"namespace_qualification\",\n                            \"type\": \"std::vector<std::string>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"A list of namespace qualifiers.\"\n                        },\n                        {\n                            \"name\": \"name\",\n                            \"type\": \"Identifier*\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The identifier itself.\"\n                        },\n                        {\n                            \"name\": \"generic_arguments\",\n                            \"type\": \"std::vector<TypeExpression*>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Generic type arguments to the identifier, if any.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct IdentifierExpression : LocationExpression {\n                  DEFINE_AST_NODE_LEAF_BOILERPLATE(IdentifierExpression)\n                  IdentifierExpression(SourcePosition pos,\n                                       std::vector<std::string> namespace_qualification,\n                                       Identifier* name, std::vector<TypeExpression*> args = {})\n                      : LocationExpression(kKind, pos),\n                        namespace_qualification(std::move(namespace_qualification)),\n                        name(name),\n                        generic_arguments(std::move(args)) {}\n                  IdentifierExpression(SourcePosition pos, Identifier* name,\n                                       std::vector<TypeExpression*> args = {})\n                      : IdentifierExpression(pos, {}, name, std::move(args)) {}\n                  bool IsThis() const { return name->value == kThisParameterName; }\n\n                  void VisitAllSubExpressions(VisitCallback callback) override {\n                    callback(this);\n                  }\n\n                  std::vector<std::string> namespace_qualification;\n                  Identifier* name;\n                  std::vector<TypeExpression*> generic_arguments;\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"IntrinsicCallExpression\",\n                    \"extends\": \"Expression\",\n                    \"about\": \"Represents a call to an intrinsic function.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"name\",\n                            \"type\": \"Identifier*\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The name of the intrinsic function.\"\n                        },\n                        {\n                            \"name\": \"generic_arguments\",\n                            \"type\": \"std::vector<TypeExpression*>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Generic type arguments to the intrinsic, if any.\"\n                        },\n                        {\n                            \"name\": \"arguments\",\n                            \"type\": \"std::vector<Expression*>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The arguments to the intrinsic call.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct IntrinsicCallExpression : Expression {\n                  DEFINE_AST_NODE_LEAF_BOILERPLATE(IntrinsicCallExpression)\n                  IntrinsicCallExpression(SourcePosition pos, Identifier* name,\n                                            std::vector<TypeExpression*> generic_arguments,\n                                            std::vector<Expression*> arguments)\n                      : Expression(kKind, pos),\n                        name(name),\n                        generic_arguments(std::move(generic_arguments)),\n                        arguments(std::move(arguments)) {}\n\n                  void VisitAllSubExpressions(VisitCallback callback) override {\n                    for (auto argument : arguments) {\n                      argument->VisitAllSubExpressions(callback);\n                    }\n                    callback(this);\n                  }\n\n                  Identifier* name;\n                  std::vector<TypeExpression*> generic_arguments;\n                  std::vector<Expression*> arguments;\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"CallMethodExpression\",\n                    \"extends\": \"Expression\",\n                    \"about\": \"Represents a call to a method on an object.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"target\",\n                            \"type\": \"Expression*\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The object on which the method is being called.\"\n                        },\n                        {\n                            \"name\": \"method\",\n                            \"type\": \"IdentifierExpression*\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The name of the method.\"\n                        },\n                        {\n                            \"name\": \"arguments\",\n                            \"type\": \"std::vector<Expression*>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The arguments to the method call.\"\n                        },\n                        {\n                            \"name\": \"labels\",\n                            \"type\": \"std::vector<Identifier*>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Labels used for control flow within the method call.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct CallMethodExpression : Expression {\n                  DEFINE_AST_NODE_LEAF_BOILERPLATE(CallMethodExpression)\n                  CallMethodExpression(SourcePosition pos, Expression* target,\n                                       IdentifierExpression* method,\n                                       std::vector<Expression*> arguments,\n                                       std::vector<Identifier*> labels)\n                      : Expression(kKind, pos),\n                        target(target),\n                        method(method),\n                        arguments(std::move(arguments)),\n                        labels(std::move(labels)) {}\n\n                  void VisitAllSubExpressions(VisitCallback callback) override {\n                    target->VisitAllSubExpressions(callback);\n                    method->VisitAllSubExpressions(callback);\n                    for (auto argument : arguments) {\n                      argument->VisitAllSubExpressions(callback);\n                    }\n                    callback(this);\n                  }\n\n                  Expression* target;\n                  IdentifierExpression* method;\n                  std::vector<Expression*> arguments;\n                  std::vector<Identifier*> labels;\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"CallExpression\",\n                    \"extends\": \"Expression\",\n                    \"about\": \"Represents a function call.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"callee\",\n                            \"type\": \"IdentifierExpression*\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The function being called.\"\n                        },\n                        {\n                            \"name\": \"arguments\",\n                            \"type\": \"std::vector<Expression*>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The arguments to the function call.\"\n                        },\n                        {\n                            \"name\": \"labels\",\n                            \"type\": \"std::vector<Identifier*>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Labels used for control flow within the function call.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct CallExpression : Expression {\n                  DEFINE_AST_NODE_LEAF_BOILERPLATE(CallExpression)\n                  CallExpression(SourcePosition pos, IdentifierExpression* callee,\n                                 std::vector<Expression*> arguments,\n                                 std::vector<Identifier*> labels)\n                      : Expression(kKind, pos),\n                        callee(callee),\n                        arguments(std::move(arguments)),\n                        labels(std::move(labels)) {}\n\n                  void VisitAllSubExpressions(VisitCallback callback) override {\n                    callee->VisitAllSubExpressions(callback);\n                    for (auto argument : arguments) {\n                      argument->VisitAllSubExpressions(callback);\n                    }\n                    callback(this);\n                  }\n\n                  IdentifierExpression* callee;\n                  std::vector<Expression*> arguments;\n                  std::vector<Identifier*> labels;\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"NameAndExpression\",\n                    \"about\": \"Represents a name and an expression pair, often used in initializers.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"name\",\n                            \"type\": \"Identifier*\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The name.\"\n                        },\n                        {\n                            \"name\": \"expression\",\n                            \"type\": \"Expression*\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The expression.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct NameAndExpression {\n                  Identifier* name;\n                  Expression* expression;\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"StructExpression\",\n                    \"extends\": \"Expression\",\n                    \"about\": \"Represents the creation of a struct.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"type\",\n                            \"type\": \"TypeExpression*\",\n                            \"access\": \"public\",\n                            \"purpose\": \"The type of the struct being created.\"\n                        },\n                        {\n                            \"name\": \"initializers\",\n                            \"type\": \"std::vector<NameAndExpression>\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Initializers for the struct's fields.\"\n                        }\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                struct StructExpression : Expression {\n                  DEFINE_AST_NODE_LEAF_BOILERPLATE(StructExpression)\n                  StructExpression(SourcePosition pos, TypeExpression* type,\n                                   std::vector<NameAndExpression> initializers)\n                      : Expression(kKind, pos),\n                        type(type),\n                        initializers(std::move(initializers)) {}\n\n                  void VisitAllSubExpressions(VisitCallback callback) override {\n                    for (auto& initializer : initializers) {\n                      initializer.expression->VisitAllSubExpressions(callback);\n                    }\n                    callback(this);\n                  }\n\n                  TypeExpression* type;\n                  std::vector<NameAndExpression> initializers;\n                };\n            ]]></code>\n        </struct>\n\n        <struct>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"LogicalOrExpression\",\n                    \"extends\": \"Expression\",\n                    \"about\": \"Represents a logical OR expression.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"left\",\n                            \"type\": \"Expression*\",\n                            \"access\": \"public\",\n"
}