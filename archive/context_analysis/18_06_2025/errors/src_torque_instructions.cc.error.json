{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/instructions.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/instructions.cc\",\n        \"file_name\": \"instructions.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the instruction set for the Torque language, including type checking and definition location computation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for instruction definitions, standard library features, and Torque specific components.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/torque/instructions.h\"\n\n            #include <optional>\n\n            #include \"src/torque/cfg.h\"\n            #include \"src/torque/type-oracle.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ExpectType\",\n            \"about\": \"Checks if the actual type matches the expected type.  Reports an error if they don't match.\",\n            \"logic\": \"Compares two Type pointers. If they are not equal, it reports an error message using ReportError.\",\n            \"parameters\": [\n                {\n                    \"name\": \"expected\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The expected type\"\n                },\n                {\n                    \"name\": \"actual\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The actual type\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n            void ExpectType(const Type* expected, const Type* actual) {\n            if (expected != actual) {\n                ReportError(\"expected type \", *expected, \" but found \", *actual);\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ExpectSubtype\",\n            \"about\": \"Checks if a type is a subtype of another type. Reports an error if it is not.\",\n            \"logic\": \"Uses the IsSubtypeOf method of the Type class to determine if subtype is a subtype of supertype. If not, it calls ReportError.\",\n            \"parameters\": [\n                {\n                    \"name\": \"subtype\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The subtype to check\"\n                },\n                {\n                    \"name\": \"supertype\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The supertype to check against\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ExpectSubtype(const Type* subtype, const Type* supertype) {\n            if (!subtype->IsSubtypeOf(supertype)) {\n                ReportError(\"type \", *subtype, \" is not a subtype of \", *supertype);\n            }\n            }\n            }  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TypeInstruction\",\n            \"parent\": \"PeekInstruction\",\n            \"about\": \"Performs type checking for the PeekInstruction.  Pushes the type found at the specified slot onto the stack.  Optionally widens the type with ExpectSubtype check.\",\n            \"logic\": \"Pushes the type at the given slot onto the stack. If widened_type is provided, it checks that the type at the slot is a subtype of widened_type before pushing the widened_type onto the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<const Type*>*\",\n                    \"purpose\": \"The stack to operate on\"\n                },\n                {\n                    \"name\": \"cfg\",\n                    \"type\": \"ControlFlowGraph*\",\n                    \"purpose\": \"The control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"ExpectSubtype\",\n                \"TopType\",\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PeekInstruction::TypeInstruction(Stack<const Type*>* stack,\n                                                ControlFlowGraph* cfg) const {\n            const Type* type = stack->Peek(slot);\n            if (widened_type) {\n                if (type->IsTopType()) {\n                const TopType* top_type = TopType::cast(type);\n                ReportError(\"use of \" + top_type->reason());\n                }\n                ExpectSubtype(type, *widened_type);\n                type = *widened_type;\n            }\n            stack->Push(type);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RecomputeDefinitionLocations\",\n            \"parent\": \"PeekInstruction\",\n            \"about\": \"Recomputes definition locations for the PeekInstruction.\",\n            \"logic\": \"Pushes the definition location found at the given slot onto the locations stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"locations\",\n                    \"type\": \"Stack<DefinitionLocation>*\",\n                    \"purpose\": \"The stack of definition locations\"\n                },\n                {\n                    \"name\": \"worklist\",\n                    \"type\": \"Worklist<Block*>*\",\n                    \"purpose\": \"The worklist for the control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"DefinitionLocation\",\n                \"Worklist\",\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PeekInstruction::RecomputeDefinitionLocations(\n                Stack<DefinitionLocation>* locations, Worklist<Block*>* worklist) const {\n            locations->Push(locations->Peek(slot));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TypeInstruction\",\n            \"parent\": \"PokeInstruction\",\n            \"about\": \"Performs type checking for the PokeInstruction. Replaces a type in the stack at a given position.\",\n            \"logic\": \"Pops the top type from the stack and checks, if widened_type is specified, whether the type is subtype of widened type and then substitutes it with widened type. Finally, it pokes the resulting type into the specified stack slot.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<const Type*>*\",\n                    \"purpose\": \"The stack to operate on\"\n                },\n                {\n                    \"name\": \"cfg\",\n                    \"type\": \"ControlFlowGraph*\",\n                    \"purpose\": \"The control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"ExpectSubtype\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PokeInstruction::TypeInstruction(Stack<const Type*>* stack,\n                                                ControlFlowGraph* cfg) const {\n            const Type* type = stack->Top();\n            if (widened_type) {\n                ExpectSubtype(type, *widened_type);\n                type = *widened_type;\n            }\n            stack->Poke(slot, type);\n            stack->Pop();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RecomputeDefinitionLocations\",\n            \"parent\": \"PokeInstruction\",\n            \"about\": \"Recomputes definition locations for the PokeInstruction.\",\n            \"logic\": \"Pokes a definition location into the stack at a given slot, replacing the existing value. The new value comes from the top of the stack which is then popped.\",\n            \"parameters\": [\n                {\n                    \"name\": \"locations\",\n                    \"type\": \"Stack<DefinitionLocation>*\",\n                    \"purpose\": \"The stack of definition locations\"\n                },\n                {\n                    \"name\": \"worklist\",\n                    \"type\": \"Worklist<Block*>*\",\n                    \"purpose\": \"The worklist for the control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"DefinitionLocation\",\n                \"Worklist\",\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PokeInstruction::RecomputeDefinitionLocations(\n                Stack<DefinitionLocation>* locations, Worklist<Block*>* worklist) const {\n            locations->Poke(slot, locations->Pop());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TypeInstruction\",\n            \"parent\": \"DeleteRangeInstruction\",\n            \"about\": \"Performs type checking for the DeleteRangeInstruction. Deletes a range of types from the stack.\",\n            \"logic\": \"Deletes types in given range from the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<const Type*>*\",\n                    \"purpose\": \"The stack to operate on\"\n                },\n                {\n                    \"name\": \"cfg\",\n                    \"type\": \"ControlFlowGraph*\",\n                    \"purpose\": \"The control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void DeleteRangeInstruction::TypeInstruction(Stack<const Type*>* stack,\n                                                        ControlFlowGraph* cfg) const {\n            stack->DeleteRange(range);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RecomputeDefinitionLocations\",\n            \"parent\": \"DeleteRangeInstruction\",\n            \"about\": \"Recomputes definition locations for the DeleteRangeInstruction.\",\n            \"logic\": \"Deletes a range of definition locations from the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"locations\",\n                    \"type\": \"Stack<DefinitionLocation>*\",\n                    \"purpose\": \"The stack of definition locations\"\n                },\n                {\n                    \"name\": \"worklist\",\n                    \"type\": \"Worklist<Block*>*\",\n                    \"purpose\": \"The worklist for the control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"DefinitionLocation\",\n                \"Worklist\",\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void DeleteRangeInstruction::RecomputeDefinitionLocations(\n                Stack<DefinitionLocation>* locations, Worklist<Block*>* worklist) const {\n            locations->DeleteRange(range);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TypeInstruction\",\n            \"parent\": \"PushUninitializedInstruction\",\n            \"about\": \"Performs type checking for the PushUninitializedInstruction. Pushes an uninitialized type onto the stack.\",\n            \"logic\": \"Pushes the pre-defined type onto the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<const Type*>*\",\n                    \"purpose\": \"The stack to operate on\"\n                },\n                {\n                    \"name\": \"cfg\",\n                    \"type\": \"ControlFlowGraph*\",\n                    \"purpose\": \"The control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PushUninitializedInstruction::TypeInstruction(\n                Stack<const Type*>* stack, ControlFlowGraph* cfg) const {\n            stack->Push(type);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RecomputeDefinitionLocations\",\n            \"parent\": \"PushUninitializedInstruction\",\n            \"about\": \"Recomputes definition locations for the PushUninitializedInstruction.\",\n            \"logic\": \"Pushes a value definition (obtained from GetValueDefinition()) onto the locations stack, representing the definition location for the uninitialized value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"locations\",\n                    \"type\": \"Stack<DefinitionLocation>*\",\n                    \"purpose\": \"The stack of definition locations\"\n                },\n                {\n                    \"name\": \"worklist\",\n                    \"type\": \"Worklist<Block*>*\",\n                    \"purpose\": \"The worklist for the control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"DefinitionLocation\",\n                \"Worklist\",\n                \"Block\",\n                \"GetValueDefinition\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PushUninitializedInstruction::RecomputeDefinitionLocations(\n                Stack<DefinitionLocation>* locations, Worklist<Block*>* worklist) const {\n            locations->Push(GetValueDefinition());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetValueDefinition\",\n            \"parent\": \"PushUninitializedInstruction\",\n            \"about\": \"Gets the definition location for the pushed value.\",\n            \"logic\": \"Creates a definition location associated with this instruction and the index 0.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"DefinitionLocation\",\n                \"description\": \"The definition location of the pushed value\"\n            },\n            \"dependencies\": [\n                \"DefinitionLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            DefinitionLocation PushUninitializedInstruction::GetValueDefinition() const {\n            return DefinitionLocation::Instruction(this, 0);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TypeInstruction\",\n            \"parent\": \"PushBuiltinPointerInstruction\",\n            \"about\": \"Performs type checking for the PushBuiltinPointerInstruction. Pushes a builtin pointer type onto the stack.\",\n            \"logic\": \"Pushes the pre-defined type onto the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<const Type*>*\",\n                    \"purpose\": \"The stack to operate on\"\n                },\n                {\n                    \"name\": \"cfg\",\n                    \"type\": \"ControlFlowGraph*\",\n                    \"purpose\": \"The control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PushBuiltinPointerInstruction::TypeInstruction(\n                Stack<const Type*>* stack, ControlFlowGraph* cfg) const {\n            stack->Push(type);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RecomputeDefinitionLocations\",\n            \"parent\": \"PushBuiltinPointerInstruction\",\n            \"about\": \"Recomputes definition locations for the PushBuiltinPointerInstruction.\",\n            \"logic\": \"Pushes a value definition (obtained from GetValueDefinition()) onto the locations stack, representing the definition location for the builtin pointer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"locations\",\n                    \"type\": \"Stack<DefinitionLocation>*\",\n                    \"purpose\": \"The stack of definition locations\"\n                },\n                {\n                    \"name\": \"worklist\",\n                    \"type\": \"Worklist<Block*>*\",\n                    \"purpose\": \"The worklist for the control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"DefinitionLocation\",\n                \"Worklist\",\n                \"Block\",\n                \"GetValueDefinition\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void PushBuiltinPointerInstruction::RecomputeDefinitionLocations(\n                Stack<DefinitionLocation>* locations, Worklist<Block*>* worklist) const {\n            locations->Push(GetValueDefinition());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetValueDefinition\",\n            \"parent\": \"PushBuiltinPointerInstruction\",\n            \"about\": \"Gets the definition location for the pushed builtin pointer.\",\n            \"logic\": \"Creates a definition location associated with this instruction and the index 0.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"DefinitionLocation\",\n                \"description\": \"The definition location of the pushed value\"\n            },\n            \"dependencies\": [\n                \"DefinitionLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            DefinitionLocation PushBuiltinPointerInstruction::GetValueDefinition() const {\n            return DefinitionLocation::Instruction(this, 0);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TypeInstruction\",\n            \"parent\": \"NamespaceConstantInstruction\",\n            \"about\": \"Performs type checking for the NamespaceConstantInstruction. Pushes the lowered type(s) of a namespace constant onto the stack.\",\n            \"logic\": \"Lowers the type of the namespace constant using LowerType and pushes the resulting types onto the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<const Type*>*\",\n                    \"purpose\": \"The stack to operate on\"\n                },\n                {\n                    \"name\": \"cfg\",\n                    \"type\": \"ControlFlowGraph*\",\n                    \"purpose\": \"The control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"LowerType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void NamespaceConstantInstruction::TypeInstruction(\n                Stack<const Type*>* stack, ControlFlowGraph* cfg) const {\n            stack->PushMany(LowerType(constant->type()));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RecomputeDefinitionLocations\",\n            \"parent\": \"NamespaceConstantInstruction\",\n            \"about\": \"Recomputes definition locations for the NamespaceConstantInstruction.\",\n            \"logic\": \"Iterates through the number of value definitions and pushes each definition location onto the locations stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"locations\",\n                    \"type\": \"Stack<DefinitionLocation>*\",\n                    \"purpose\": \"The stack of definition locations\"\n                },\n                {\n                    \"name\": \"worklist\",\n                    \"type\": \"Worklist<Block*>*\",\n                    \"purpose\": \"The worklist for the control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"DefinitionLocation\",\n                \"Worklist\",\n                \"Block\",\n                \"GetValueDefinitionCount\",\n                \"GetValueDefinition\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void NamespaceConstantInstruction::RecomputeDefinitionLocations(\n                Stack<DefinitionLocation>* locations, Worklist<Block*>* worklist) const {\n            for (std::size_t i = 0; i < GetValueDefinitionCount(); ++i) {\n                locations->Push(GetValueDefinition(i));\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetValueDefinitionCount\",\n            \"parent\": \"NamespaceConstantInstruction\",\n            \"about\": \"Gets the number of value definitions for this instruction.\",\n            \"logic\": \"Returns the size of the lowered type of the constant. The lowering process can split a type into multiple stack values, so the count is the number of those lowered types.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::size_t\",\n                \"description\": \"The number of value definitions\"\n            },\n            \"dependencies\": [\n                \"LowerType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::size_t NamespaceConstantInstruction::GetValueDefinitionCount() const {\n            return LowerType(constant->type()).size();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetValueDefinition\",\n            \"parent\": \"NamespaceConstantInstruction\",\n            \"about\": \"Gets the definition location for a specific value produced by this instruction.\",\n            \"logic\": \"Returns a DefinitionLocation::Instruction for this instruction and the given index.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"std::size_t\",\n                    \"purpose\": \"The index of the value definition to retrieve\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DefinitionLocation\",\n                \"description\": \"The definition location of the specified value\"\n            },\n            \"dependencies\": [\n                \"DefinitionLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            DefinitionLocation NamespaceConstantInstruction::GetValueDefinition(\n                std::size_t index) const {\n            DCHECK_LT(index, GetValueDefinitionCount());\n            return DefinitionLocation::Instruction(this, index);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for NamespaceConstantInstruction to provide a readable string representation.\",\n            \"logic\": \"Outputs a string containing the instruction name and the external name of the constant.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream\"\n                },\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const NamespaceConstantInstruction&\",\n                    \"purpose\": \"The instruction to print\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os,\n                                    const NamespaceConstantInstruction& instruction) {\n            return os << \"NamespaceConstant \" << instruction.constant->external_name();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InvalidateTransientTypes\",\n            \"parent\": \"InstructionBase\",\n            \"about\": \"Invalidates transient types on the stack due to a transitioning callable invocation.\",\n            \"logic\": \"Iterates through the stack, checking if any types are transient. If a transient type is found, it's replaced with a TopType, indicating that it's now invalid due to the potential for type changes caused by the transition.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<const Type*>*\",\n                    \"purpose\": \"The stack of types\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"TypeOracle\",\n                \"PositionAsString\",\n                \"Type\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void InstructionBase::InvalidateTransientTypes(\n                Stack<const Type*>* stack) const {\n            auto current = stack->begin();\n            while (current != stack->end()) {\n                if ((*current)->IsTransient()) {\n                std::stringstream stream;\n                stream << \"type \" << **current\n                       << \" is made invalid by transitioning callable invocation at \"\n                       << PositionAsString(pos);\n                *current = TypeOracle::GetTopType(stream.str(), *current);\n                }\n                ++current;\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TypeInstruction\",\n            \"parent\": \"CallIntrinsicInstruction\",\n            \"about\": \"Performs type checking for the CallIntrinsicInstruction. Pops argument types from the stack, compares them to parameter types, and pushes the return type(s) onto the stack. Invalidates Transient Types on transitioning intrinsics.\",\n            \"logic\": \"Pops arguments from the stack and checks if their types match the expected parameter types of the intrinsic. If there is a mismatch, it reports an error. If the intrinsic is transitioning, it invalidates transient types on the stack using InvalidateTransientTypes. Finally, it pushes the lowered return types of the intrinsic onto the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<const Type*>*\",\n                    \"purpose\": \"The stack to operate on\"\n                },\n                {\n                    \"name\": \"cfg\",\n                    \"type\": \"ControlFlowGraph*\",\n                    \"purpose\": \"The control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"LowerParameterTypes\",\n                \"ReportError\",\n                \"InvalidateTransientTypes\",\n                \"LowerType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallIntrinsicInstruction::TypeInstruction(Stack<const Type*>* stack,\n                                                        ControlFlowGraph* cfg) const {\n            std::vector<const Type*> parameter_types =\n                LowerParameterTypes(intrinsic->signature().parameter_types);\n            for (intptr_t i = parameter_types.size() - 1; i >= 0; --i) {\n                const Type* arg_type = stack->Pop();\n                const Type* parameter_type = parameter_types.back();\n                parameter_types.pop_back();\n                if (arg_type != parameter_type) {\n                ReportError(\"parameter \", i, \": expected type \", *parameter_type,\n                            \" but found type \", *arg_type);\n                }\n            }\n            if (intrinsic->IsTransitioning()) {\n                InvalidateTransientTypes(stack);\n            }\n            stack->PushMany(LowerType(intrinsic->signature().return_type));\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RecomputeDefinitionLocations\",\n            \"parent\": \"CallIntrinsicInstruction\",\n            \"about\": \"Recomputes definition locations for the CallIntrinsicInstruction.\",\n            \"logic\": \"Pops locations for the parameters from the stack, and then pushes locations for the return values onto the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"locations\",\n                    \"type\": \"Stack<DefinitionLocation>*\",\n                    \"purpose\": \"The stack of definition locations\"\n                },\n                {\n                    \"name\": \"worklist\",\n                    \"type\": \"Worklist<Block*>*\",\n                    \"purpose\": \"The worklist for the control flow graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Stack\",\n                \"DefinitionLocation\",\n                \"Worklist\",\n                \"Block\",\n                \"LowerParameterTypes\",\n                \"GetValueDefinitionCount\",\n                \"GetValueDefinition\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallIntrinsicInstruction::RecomputeDefinitionLocations(\n                Stack<DefinitionLocation>* locations, Worklist<Block*>* worklist) const {\n            auto parameter_types =\n                LowerParameterTypes(intrinsic->signature().parameter_types);\n            locations->PopMany(parameter_types.size());\n            for (std::size_t i = 0; i < GetValueDefinitionCount(); ++i) {\n                locations->Push(DefinitionLocation::Instruction(this, i));\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetValueDefinitionCount\",\n            \"parent\": \"CallIntrinsicInstruction\",\n            \"about\": \"Gets the number of value definitions for this instruction.\",\n            \"logic\": \"Returns the size of the lowered return type.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::size_t\",\n                \"description\": \"The number of value definitions\"\n            },\n            \"dependencies\": [\n                \"LowerType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::size_t CallIntrinsicInstruction::GetValueDefinitionCount() const {\n            return LowerType(intrinsic->signature().return_type).size();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetValueDefinition\",\n            \"parent\": \"CallIntrinsicInstruction\",\n            \"about\": \"Gets the definition location for a specific return value produced by this instruction.\",\n            \"logic\": \"Returns a DefinitionLocation::Instruction for this instruction and the given index.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"std::size_t\",\n                    \"purpose\": \"The index of the return value definition to retrieve\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DefinitionLocation\",\n                \"description\": \"The definition location of the specified return value\"\n            },\n            \"dependencies\": [\n                \"DefinitionLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            DefinitionLocation CallIntrinsicInstruction::GetValueDefinition(\n                std::size_t index) const {\n            DCHECK_LT(index, GetValueDefinitionCount());\n            return DefinitionLocation::Instruction(this, index);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for CallIntrinsicInstruction to provide a readable string representation.\",\n            \"logic\": \"Outputs a string containing the instruction name, the name of the intrinsic, and any specialization types or constexpr arguments.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream\"\n                },\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const CallIntrinsicInstruction&\",\n                    \"purpose\": \"The instruction to print\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream\"\n            },\n            \"dependencies\": [\n                \"PrintCommaSeparatedList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os,\n                                    const CallIntrinsicInstruction& instruction) {\n            os << \"CallIntrinsic \" << instruction.intrinsic->ReadableName();\n            if (!instruction.specialization_types.empty()) {\n                os << \"<\";\n                PrintCommaSeparatedList(\n                    os, instruction.specialization_types,\n                    [](const Type* type) -> const Type& { return *type; });\n                os << \">\";\n            }\n            os << \"(\";\n            PrintCommaSeparatedList(os, instruction.constexpr_arguments);\n            os << \")\";\n            return os;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TypeInstruction\",\n            \"parent\": \"CallCsaMacroInstruction\",\n            \"about\": \"Performs type checking for the CallCsaMacroInstruction.  Pops arguments, validates their types against the macro's signature, and pushes the return type. Invalidates transient types if transitioning.  Handles catch blocks.\",\n            \"logic\": \"Pops arguments from the stack and checks if their types match the expected parameter types of the macro. If there is a mismatch, it reports an error. If the macro is transitioning, it invalidates transient types on the stack using Invalidate"
}