{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/microtask-queue.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/microtask-queue.cc\",\n        \"file_name\": \"microtask-queue.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the MicrotaskQueue, which manages and executes microtasks in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for standard library features, V8 internal APIs, and tracing.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/microtask-queue.h\"\n\n#include <algorithm>\n#include <cstddef>\n#include <optional>\n\n#include \"src/api/api-inl.h\"\n#include \"src/base/logging.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/objects/microtask-inl.h\"\n#include \"src/objects/visitors.h\"\n#include \"src/roots/roots-inl.h\"\n#include \"src/tracing/trace-event.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MicrotaskQueue\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Manages a queue of microtasks for execution.\",\n            \"attributes\": [\n                {\n                    \"name\": \"ring_buffer_\",\n                    \"type\": \"Address*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Circular buffer storing the microtasks.\"\n                },\n                {\n                    \"name\": \"capacity_\",\n                    \"type\": \"intptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maximum number of microtasks the buffer can hold.\"\n                },\n                {\n                    \"name\": \"size_\",\n                    \"type\": \"intptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Current number of microtasks in the queue.\"\n                },\n                {\n                    \"name\": \"start_\",\n                    \"type\": \"intptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Index of the first element in the circular buffer.\"\n                },\n                {\n                    \"name\": \"finished_microtask_count_\",\n                    \"type\": \"intptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of microtasks finished.\"\n                },\n                {\n                    \"name\": \"next_\",\n                    \"type\": \"MicrotaskQueue*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the next MicrotaskQueue in a linked list.\"\n                },\n                {\n                    \"name\": \"prev_\",\n                    \"type\": \"MicrotaskQueue*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the previous MicrotaskQueue in a linked list.\"\n                },\n                {\n                    \"name\": \"microtasks_completed_callbacks_\",\n                    \"type\": \"std::vector<CallbackWithData>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"List of callbacks to be executed when microtasks are completed.\"\n                },\n                {\n                    \"name\": \"microtasks_completed_callbacks_cow_\",\n                    \"type\": \"std::optional<std::vector<CallbackWithData>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Copy-on-write vector for callbacks when they are being iterated.\"\n                },\n                {\n                    \"name\": \"is_running_completed_callbacks_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating if the completion callbacks are currently running.\"\n                },\n                {\n                    \"name\": \"microtasks_policy_\",\n                    \"type\": \"v8::MicrotasksPolicy\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Policy that defines when microtasks should be run.\"\n                },\n                {\n                    \"name\": \"is_running_microtasks_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to indicate if microtasks are currently running in the queue.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Microtask\",\n                \"CallableTask\",\n                \"CallbackTask\",\n                \"HandleScope\",\n                \"Factory\",\n                \"Utils\",\n                \"Object\",\n                \"RootVisitor\",\n                \"v8::Isolate\",\n                \"v8::Local<Function>\",\n                \"v8::MicrotaskCallback\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nconst size_t MicrotaskQueue::kRingBufferOffset =\n    OFFSET_OF(MicrotaskQueue, ring_buffer_);\nconst size_t MicrotaskQueue::kCapacityOffset =\n    OFFSET_OF(MicrotaskQueue, capacity_);\nconst size_t MicrotaskQueue::kSizeOffset = OFFSET_OF(MicrotaskQueue, size_);\nconst size_t MicrotaskQueue::kStartOffset = OFFSET_OF(MicrotaskQueue, start_);\nconst size_t MicrotaskQueue::kFinishedMicrotaskCountOffset =\n    OFFSET_OF(MicrotaskQueue, finished_microtask_count_);\n\nconst intptr_t MicrotaskQueue::kMinimumCapacity = 8;\n\n// static\nvoid MicrotaskQueue::SetUpDefaultMicrotaskQueue(Isolate* isolate) {\n  DCHECK_NULL(isolate->default_microtask_queue());\n\n  MicrotaskQueue* microtask_queue = new MicrotaskQueue;\n  microtask_queue->next_ = microtask_queue;\n  microtask_queue->prev_ = microtask_queue;\n  isolate->set_default_microtask_queue(microtask_queue);\n}\n\n// static\nstd::unique_ptr<MicrotaskQueue> MicrotaskQueue::New(Isolate* isolate) {\n  DCHECK_NOT_NULL(isolate->default_microtask_queue());\n\n  std::unique_ptr<MicrotaskQueue> microtask_queue(new MicrotaskQueue);\n\n  // Insert the new instance to the next of last MicrotaskQueue instance.\n  MicrotaskQueue* last = isolate->default_microtask_queue()->prev_;\n  microtask_queue->next_ = last->next_;\n  microtask_queue->prev_ = last;\n  last->next_->prev_ = microtask_queue.get();\n  last->next_ = microtask_queue.get();\n\n  return microtask_queue;\n}\n\nMicrotaskQueue::MicrotaskQueue() = default;\n\nMicrotaskQueue::~MicrotaskQueue() {\n  if (next_ != this) {\n    DCHECK_NE(prev_, this);\n    next_->prev_ = prev_;\n    prev_->next_ = next_;\n  }\n  delete[] ring_buffer_;\n}\n\n// static\nAddress MicrotaskQueue::CallEnqueueMicrotask(Isolate* isolate,\n                                             intptr_t microtask_queue_pointer,\n                                             Address raw_microtask) {\n  Tagged<Microtask> microtask = Cast<Microtask>(Tagged<Object>(raw_microtask));\n  reinterpret_cast<MicrotaskQueue*>(microtask_queue_pointer)\n      ->EnqueueMicrotask(microtask);\n  return Smi::zero().ptr();\n}\n\nvoid MicrotaskQueue::EnqueueMicrotask(v8::Isolate* v8_isolate,\n                                      v8::Local<Function> function) {\n  Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);\n  HandleScope scope(isolate);\n  DirectHandle<CallableTask> microtask = isolate->factory()->NewCallableTask(\n      Utils::OpenDirectHandle(*function), isolate->native_context());\n  EnqueueMicrotask(*microtask);\n}\n\nvoid MicrotaskQueue::EnqueueMicrotask(v8::Isolate* v8_isolate,\n                                      v8::MicrotaskCallback callback,\n                                      void* data) {\n  Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);\n  HandleScope scope(isolate);\n  DirectHandle<CallbackTask> microtask = isolate->factory()->NewCallbackTask(\n      isolate->factory()->NewForeign<kMicrotaskCallbackTag>(\n          reinterpret_cast<Address>(callback)),\n      isolate->factory()->NewForeign<kMicrotaskCallbackDataTag>(\n          reinterpret_cast<Address>(data)));\n  EnqueueMicrotask(*microtask);\n}\n\nvoid MicrotaskQueue::EnqueueMicrotask(Tagged<Microtask> microtask) {\n  if (size_ == capacity_) {\n    // Keep the capacity of |ring_buffer_| power of 2, so that the JIT\n    // implementation can calculate the modulo easily.\n    intptr_t new_capacity = std::max(kMinimumCapacity, capacity_ << 1);\n    ResizeBuffer(new_capacity);\n  }\n\n  DCHECK_LT(size_, capacity_);\n  ring_buffer_[(start_ + size_) % capacity_] = microtask.ptr();\n  ++size_;\n}\n\nvoid MicrotaskQueue::PerformCheckpointInternal(v8::Isolate* v8_isolate) {\n  DCHECK(ShouldPerfomCheckpoint());\n  std::optional<MicrotasksScope> microtasks_scope;\n  if (microtasks_policy_ == v8::MicrotasksPolicy::kScoped) {\n    // If we're using microtask scopes to schedule microtask execution, V8\n    // API calls will check that there's always a microtask scope on the\n    // stack. As the microtasks we're about to execute could invoke embedder\n    // callbacks which then calls back into V8, we create an artificial\n    // microtask scope here to avoid running into the CallDepthScope check.\n    microtasks_scope.emplace(v8_isolate, this,\n                             v8::MicrotasksScope::kDoNotRunMicrotasks);\n  }\n  Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);\n  RunMicrotasks(isolate);\n  isolate->ClearKeptObjects();\n}\n\nnamespace {\n\nclass SetIsRunningMicrotasks {\n public:\n  explicit SetIsRunningMicrotasks(bool* flag) : flag_(flag) {\n    DCHECK(!*flag_);\n    *flag_ = true;\n  }\n\n  ~SetIsRunningMicrotasks() {\n    DCHECK(*flag_);\n    *flag_ = false;\n  }\n\n private:\n  bool* flag_;\n};\n\n}  // namespace\n\nint MicrotaskQueue::RunMicrotasks(Isolate* isolate) {\n  SetIsRunningMicrotasks scope(&is_running_microtasks_);\n  v8::Isolate::SuppressMicrotaskExecutionScope suppress(\n      reinterpret_cast<v8::Isolate*>(isolate), this);\n\n  if (!size()) {\n    OnCompleted(isolate);\n    return 0;\n  }\n\n  // We should not enter V8 if it's marked for termination.\n  DCHECK_IMPLIES(v8_flags.strict_termination_checks,\n                 !isolate->is_execution_terminating());\n\n  intptr_t base_count = finished_microtask_count_;\n  HandleScope handle_scope(isolate);\n  MaybeDirectHandle<Object> maybe_result;\n\n#ifdef V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\n  DirectHandle<Object> continuation_preserved_embedder_data(\n      isolate->isolate_data()->continuation_preserved_embedder_data(), isolate);\n  isolate->isolate_data()->set_continuation_preserved_embedder_data(\n      ReadOnlyRoots(isolate).undefined_value());\n#endif  // V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\n\n  int processed_microtask_count;\n  {\n    HandleScopeImplementer::EnteredContextRewindScope rewind_scope(\n        isolate->handle_scope_implementer());\n    TRACE_EVENT_BEGIN0(\"v8.execute\", \"RunMicrotasks\");\n    {\n      TRACE_EVENT_CALL_STATS_SCOPED(isolate, \"v8\", \"V8.RunMicrotasks\");\n      maybe_result = Execution::TryRunMicrotasks(isolate, this);\n      processed_microtask_count =\n          static_cast<int>(finished_microtask_count_ - base_count);\n    }\n    TRACE_EVENT_END1(\"v8.execute\", \"RunMicrotasks\", \"microtask_count\",\n                     processed_microtask_count);\n  }\n\n#ifdef V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\n  isolate->isolate_data()->set_continuation_preserved_embedder_data(\n      *continuation_preserved_embedder_data);\n#endif  // V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\n\n  if (isolate->is_execution_terminating()) {\n    DCHECK(isolate->has_exception());\n    DCHECK(maybe_result.is_null());\n    delete[] ring_buffer_;\n    ring_buffer_ = nullptr;\n    capacity_ = 0;\n    size_ = 0;\n    start_ = 0;\n    isolate->OnTerminationDuringRunMicrotasks();\n    OnCompleted(isolate);\n    return -1;\n  }\n\n  DCHECK_EQ(0, size());\n  OnCompleted(isolate);\n\n  return processed_microtask_count;\n}\n\nvoid MicrotaskQueue::IterateMicrotasks(RootVisitor* visitor) {\n  if (size_) {\n    // Iterate pending Microtasks as root objects to avoid the write barrier for\n    // all single Microtask. If this hurts the GC performance, use a FixedArray.\n    visitor->VisitRootPointers(\n        Root::kMicroTasks, nullptr, FullObjectSlot(ring_buffer_ + start_),\n        FullObjectSlot(ring_buffer_ + std::min(start_ + size_, capacity_)));\n    visitor->VisitRootPointers(\n        Root::kMicroTasks, nullptr, FullObjectSlot(ring_buffer_),\n        FullObjectSlot(ring_buffer_ + std::max(start_ + size_ - capacity_,\n                                               static_cast<intptr_t>(0))));\n  }\n\n  if (capacity_ <= kMinimumCapacity) {\n    return;\n  }\n\n  intptr_t new_capacity = capacity_;\n  while (new_capacity > 2 * size_) {\n    new_capacity >>= 1;\n  }\n  new_capacity = std::max(new_capacity, kMinimumCapacity);\n  if (new_capacity < capacity_) {\n    ResizeBuffer(new_capacity);\n  }\n}\n\nvoid MicrotaskQueue::AddMicrotasksCompletedCallback(\n    MicrotasksCompletedCallbackWithData callback, void* data) {\n  std::vector<CallbackWithData>* microtasks_completed_callbacks =\n      &microtasks_completed_callbacks_;\n  if (is_running_completed_callbacks_) {\n    if (!microtasks_completed_callbacks_cow_.has_value()) {\n      microtasks_completed_callbacks_cow_.emplace(\n          microtasks_completed_callbacks_);\n    }\n    // Use the COW vector if we are iterating the callbacks right now.\n    microtasks_completed_callbacks =\n        &microtasks_completed_callbacks_cow_.value();\n  }\n\n  CallbackWithData callback_with_data(callback, data);\n  const auto pos =\n      std::find(microtasks_completed_callbacks->begin(),\n                microtasks_completed_callbacks->end(), callback_with_data);\n  if (pos != microtasks_completed_callbacks->end()) {\n    return;\n  }\n  microtasks_completed_callbacks->push_back(callback_with_data);\n}\n\nvoid MicrotaskQueue::RemoveMicrotasksCompletedCallback(\n    MicrotasksCompletedCallbackWithData callback, void* data) {\n  std::vector<CallbackWithData>* microtasks_completed_callbacks =\n      &microtasks_completed_callbacks_;\n  if (is_running_completed_callbacks_) {\n    if (!microtasks_completed_callbacks_cow_.has_value()) {\n      microtasks_completed_callbacks_cow_.emplace(\n          microtasks_completed_callbacks_);\n    }\n    // Use the COW vector if we are iterating the callbacks right now.\n    microtasks_completed_callbacks =\n        &microtasks_completed_callbacks_cow_.value();\n  }\n\n  CallbackWithData callback_with_data(callback, data);\n  const auto pos =\n      std::find(microtasks_completed_callbacks->begin(),\n                microtasks_completed_callbacks->end(), callback_with_data);\n  if (pos == microtasks_completed_callbacks->end()) {\n    return;\n  }\n  microtasks_completed_callbacks->erase(pos);\n}\n\nvoid MicrotaskQueue::OnCompleted(Isolate* isolate) {\n  is_running_completed_callbacks_ = true;\n  for (auto& callback : microtasks_completed_callbacks_) {\n    callback.first(reinterpret_cast<v8::Isolate*>(isolate), callback.second);\n  }\n  is_running_completed_callbacks_ = false;\n  if (V8_UNLIKELY(microtasks_completed_callbacks_cow_.has_value())) {\n    microtasks_completed_callbacks_ =\n        std::move(microtasks_completed_callbacks_cow_.value());\n    microtasks_completed_callbacks_cow_.reset();\n  }\n}\n\nTagged<Microtask> MicrotaskQueue::get(intptr_t index) const {\n  DCHECK_LT(index, size_);\n  Tagged<Object> microtask(ring_buffer_[(index + start_) % capacity_]);\n  return Cast<Microtask>(microtask);\n}\n\nvoid MicrotaskQueue::ResizeBuffer(intptr_t new_capacity) {\n  DCHECK_LE(size_, new_capacity);\n  Address* new_ring_buffer = new Address[new_capacity];\n  for (intptr_t i = 0; i < size_; ++i) {\n    new_ring_buffer[i] = ring_buffer_[(start_ + i) % capacity_];\n  }\n\n  delete[] ring_buffer_;\n  ring_buffer_ = new_ring_buffer;\n  capacity_ = new_capacity;\n  start_ = 0;\n}\n\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetUpDefaultMicrotaskQueue\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Sets up the default MicrotaskQueue for the isolate.\",\n            \"logic\": \"Creates a new MicrotaskQueue, makes it circular (next and prev pointers point to itself), and sets it as the default for the given isolate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to set the default MicrotaskQueue for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"MicrotaskQueue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid MicrotaskQueue::SetUpDefaultMicrotaskQueue(Isolate* isolate) {\n  DCHECK_NULL(isolate->default_microtask_queue());\n\n  MicrotaskQueue* microtask_queue = new MicrotaskQueue;\n  microtask_queue->next_ = microtask_queue;\n  microtask_queue->prev_ = microtask_queue;\n  isolate->set_default_microtask_queue(microtask_queue);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"New\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Creates a new MicrotaskQueue and inserts it into the linked list of queues associated with the isolate.\",\n            \"logic\": \"Creates a new MicrotaskQueue and inserts it into the linked list maintained by the isolate's default queue. This allows for multiple queues.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to create the MicrotaskQueue for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<MicrotaskQueue>\",\n                \"description\": \"A unique pointer to the newly created MicrotaskQueue.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"MicrotaskQueue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nstd::unique_ptr<MicrotaskQueue> MicrotaskQueue::New(Isolate* isolate) {\n  DCHECK_NOT_NULL(isolate->default_microtask_queue());\n\n  std::unique_ptr<MicrotaskQueue> microtask_queue(new MicrotaskQueue);\n\n  // Insert the new instance to the next of last MicrotaskQueue instance.\n  MicrotaskQueue* last = isolate->default_microtask_queue()->prev_;\n  microtask_queue->next_ = last->next_;\n  microtask_queue->prev_ = last;\n  last->next_->prev_ = microtask_queue.get();\n  last->next_ = microtask_queue.get();\n\n  return microtask_queue;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MicrotaskQueue\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Default constructor for MicrotaskQueue.\",\n            \"logic\": \"The default constructor is used. Initializes member variables to default values.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nMicrotaskQueue::MicrotaskQueue() = default;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"~MicrotaskQueue\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Destructor for MicrotaskQueue.\",\n            \"logic\": \"Removes the queue from the linked list if it's not the default queue and deletes the ring buffer used for storing tasks.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nMicrotaskQueue::~MicrotaskQueue() {\n  if (next_ != this) {\n    DCHECK_NE(prev_, this);\n    next_->prev_ = prev_;\n    prev_->next_ = next_;\n  }\n  delete[] ring_buffer_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CallEnqueueMicrotask\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Static method to enqueue a microtask given a raw microtask pointer.\",\n            \"logic\": \"Converts the raw pointer to a Tagged<Microtask> and then calls the EnqueueMicrotask method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate associated with the microtask queue.\"\n                },\n                {\n                    \"name\": \"microtask_queue_pointer\",\n                    \"type\": \"intptr_t\",\n                    \"purpose\": \"Pointer to the MicrotaskQueue.\"\n                },\n                {\n                    \"name\": \"raw_microtask\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"Raw pointer to the Microtask object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Address\",\n                \"description\": \"Returns Smi::zero().ptr().\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"Microtask\",\n                \"EnqueueMicrotask\",\n                \"Object\",\n                \"Smi\",\n                \"Cast\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nAddress MicrotaskQueue::CallEnqueueMicrotask(Isolate* isolate,\n                                             intptr_t microtask_queue_pointer,\n                                             Address raw_microtask) {\n  Tagged<Microtask> microtask = Cast<Microtask>(Tagged<Object>(raw_microtask));\n  reinterpret_cast<MicrotaskQueue*>(microtask_queue_pointer)\n      ->EnqueueMicrotask(microtask);\n  return Smi::zero().ptr();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EnqueueMicrotask\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Enqueues a microtask (represented by a v8::Local<Function>) into the queue.\",\n            \"logic\": \"Converts the v8::Local<Function> to a CallableTask and then enqueues it.\",\n            \"parameters\": [\n                {\n                    \"name\": \"v8_isolate\",\n                    \"type\": \"v8::Isolate*\",\n                    \"purpose\": \"The v8 isolate.\"\n                },\n                {\n                    \"name\": \"function\",\n                    \"type\": \"v8::Local<Function>\",\n                    \"purpose\": \"The function to be enqueued as a microtask.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"HandleScope\",\n                \"CallableTask\",\n                \"Factory\",\n                \"Utils\",\n                \"EnqueueMicrotask\",\n                \"v8::Isolate\",\n                \"v8::Local<Function>\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MicrotaskQueue::EnqueueMicrotask(v8::Isolate* v8_isolate,\n                                      v8::Local<Function> function) {\n  Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);\n  HandleScope scope(isolate);\n  DirectHandle<CallableTask> microtask = isolate->factory()->NewCallableTask(\n      Utils::OpenDirectHandle(*function), isolate->native_context());\n  EnqueueMicrotask(*microtask);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EnqueueMicrotask\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Enqueues a microtask (represented by a v8::MicrotaskCallback) into the queue.\",\n            \"logic\": \"Converts the v8::MicrotaskCallback to a CallbackTask and then enqueues it.\",\n            \"parameters\": [\n                {\n                    \"name\": \"v8_isolate\",\n                    \"type\": \"v8::Isolate*\",\n                    \"purpose\": \"The v8 isolate.\"\n                },\n                {\n                    \"name\": \"callback\",\n                    \"type\": \"v8::MicrotaskCallback\",\n                    \"purpose\": \"The callback function to be enqueued as a microtask.\"\n                },\n                {\n                    \"name\": \"data\",\n                    \"type\": \"void*\",\n                    \"purpose\": \"Data to be passed to the callback function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"HandleScope\",\n                \"CallbackTask\",\n                \"Factory\",\n                \"EnqueueMicrotask\",\n                \"v8::Isolate\",\n                \"v8::MicrotaskCallback\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MicrotaskQueue::EnqueueMicrotask(v8::Isolate* v8_isolate,\n                                      v8::MicrotaskCallback callback,\n                                      void* data) {\n  Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);\n  HandleScope scope(isolate);\n  DirectHandle<CallbackTask> microtask = isolate->factory()->NewCallbackTask(\n      isolate->factory()->NewForeign<kMicrotaskCallbackTag>(\n          reinterpret_cast<Address>(callback)),\n      isolate->factory()->NewForeign<kMicrotaskCallbackDataTag>(\n          reinterpret_cast<Address>(data)));\n  EnqueueMicrotask(*microtask);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EnqueueMicrotask\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Enqueues a microtask (represented by a Tagged<Microtask>) into the queue.\",\n            \"logic\": \"Adds the microtask to the circular buffer. Resizes the buffer if necessary.\",\n            \"parameters\": [\n                {\n                    \"name\": \"microtask\",\n                    \"type\": \"Tagged<Microtask>\",\n                    \"purpose\": \"The microtask to be enqueued.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Microtask\",\n                \"ResizeBuffer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MicrotaskQueue::EnqueueMicrotask(Tagged<Microtask> microtask) {\n  if (size_ == capacity_) {\n    // Keep the capacity of |ring_buffer_| power of 2, so that the JIT\n    // implementation can calculate the modulo easily.\n    intptr_t new_capacity = std::max(kMinimumCapacity, capacity_ << 1);\n    ResizeBuffer(new_capacity);\n  }\n\n  DCHECK_LT(size_, capacity_);\n  ring_buffer_[(start_ + size_) % capacity_] = microtask.ptr();\n  ++size_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PerformCheckpointInternal\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Performs a checkpoint to run microtasks when using scoped microtasks policy.\",\n            \"logic\": \"If the microtasks policy is scoped, it creates a MicrotasksScope to ensure a microtask scope is present during execution.  Then, it executes the microtasks and clears kept objects.\",\n            \"parameters\": [\n                {\n                    \"name\": \"v8_isolate\",\n                    \"type\": \"v8::Isolate*\",\n                    \"purpose\": \"The v8 isolate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"RunMicrotasks\",\n                \"MicrotasksScope\",\n                \"ClearKeptObjects\",\n                \"v8::Isolate\",\n                \"v8::MicrotasksPolicy\",\n                \"ShouldPerfomCheckpoint\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MicrotaskQueue::PerformCheckpointInternal(v8::Isolate* v8_isolate) {\n  DCHECK(ShouldPerfomCheckpoint());\n  std::optional<MicrotasksScope> microtasks_scope;\n  if (microtasks_policy_ == v8::MicrotasksPolicy::kScoped) {\n    // If we're using microtask scopes to schedule microtask execution, V8\n    // API calls will check that there's always a microtask scope on the\n    // stack. As the microtasks we're about to execute could invoke embedder\n    // callbacks which then calls back into V8, we create an artificial\n    // microtask scope here to avoid running into the CallDepthScope check.\n    microtasks_scope.emplace(v8_isolate, this,\n                             v8::MicrotasksScope::kDoNotRunMicrotasks);\n  }\n  Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);\n  RunMicrotasks(isolate);\n  isolate->ClearKeptObjects();\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SetIsRunningMicrotasks\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"RAII class to set and unset the is_running_microtasks_ flag.\",\n            \"attributes\": [\n                {\n                    \"name\": \"flag_\",\n                    \"type\": \"bool*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the is_running_microtasks_ flag.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nclass SetIsRunningMicrotasks {\n public:\n  explicit SetIsRunningMicrotasks(bool* flag) : flag_(flag) {\n    DCHECK(!*flag_);\n    *flag_ = true;\n  }\n\n  ~SetIsRunningMicrotasks() {\n    DCHECK(*flag_);\n    *flag_ = false;\n  }\n\n private:\n  bool* flag_;\n};\n\n}  // namespace\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RunMicrotasks\",\n            \"parent\": \"MicrotaskQueue\",\n            \"about\": \"Runs the microtasks in the queue.\",\n            \"logic\": \"Sets a flag to indicate microtasks are running, suppresses microtask execution, and then executes the microtasks using Execution::TryRunMicrotasks. Handles exceptions and termination during microtask execution. Calls OnCompleted when finished.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to run the microtasks for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The number of processed microtasks, or -1 if termination occurred.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"HandleScope\",\n                \"Execution::TryRunMicrotasks\",\n                \"OnCompleted\",\n                \"SetIsRunningMicrotasks\",\n                \"v8::Isolate\",\n                \"ReadOnlyRoots\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint MicrotaskQueue::RunMicrotasks(Isolate* isolate) {\n  SetIsRunningMicrotasks scope(&is_running_microtasks_);\n  v8::Isolate::SuppressMicrotaskExecutionScope suppress(\n      reinterpret_cast<v8::Isolate*>(isolate"
}