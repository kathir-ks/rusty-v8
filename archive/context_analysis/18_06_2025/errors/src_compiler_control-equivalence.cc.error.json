{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/control-equivalence.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 413, column 43",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/control-equivalence.cc\",\n        \"file_name\": \"control-equivalence.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements control equivalence analysis for the Turbofan compiler, used to identify nodes with equivalent control flow.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for control equivalence analysis and node properties.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/control-equivalence.h\"\n#include \"src/compiler/node-properties.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Run\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Runs the control equivalence analysis starting from the given exit node.\",\n            \"logic\": \"If the exit node doesn't participate or has an invalid class, it determines participation and runs an undirected DFS to compute control equivalence classes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"exit\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The exit node of the control flow graph to analyze.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Participates\",\n                \"GetClass\",\n                \"DetermineParticipation\",\n                \"RunUndirectedDFS\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::Run(Node* exit) {\n  if (!Participates(exit) || GetClass(exit) == kInvalidClass) {\n    DetermineParticipation(exit);\n    RunUndirectedDFS(exit);\n  }\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ControlEquivalence\",\n            \"about\": \"Performs control equivalence analysis on a control flow graph.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass ControlEquivalence {\n public:\n  void Run(Node* exit);\n\n private:\n  // ... (private members and methods) ...\n};\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitPre\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Called before visiting a node in the DFS traversal.\",\n            \"logic\": \"Traces the pre-visit of a node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node being visited.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::VisitPre(Node* node) {\n  TRACE(\"CEQ: Pre-visit of #%d:%s\\n\", node->id(), node->op()->mnemonic());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitMid\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Called during the DFS traversal after visiting inputs/uses of a node.\",\n            \"logic\": \"Removes brackets pointing to the current node, introduces artificial dependencies from start to end if necessary, starts a new equivalence class, and assigns the equivalence class to the node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node being visited.\"\n                },\n                {\n                    \"name\": \"direction\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction of the DFS traversal.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"GetBracketList\",\n                \"BracketListDelete\",\n                \"VisitBackedge\",\n                \"NewClassNumber\",\n                \"SetClass\",\n                \"BracketListTRACE\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::VisitMid(Node* node, DFSDirection direction) {\n  TRACE(\"CEQ: Mid-visit of #%d:%s\\n\", node->id(), node->op()->mnemonic());\n  BracketList& blist = GetBracketList(node);\n\n  // Remove brackets pointing to this node [line:19].\n  BracketListDelete(blist, node, direction);\n\n  // Potentially introduce artificial dependency from start to end.\n  if (blist.empty()) {\n    DCHECK_EQ(kInputDirection, direction);\n    VisitBackedge(node, graph_->end(), kInputDirection);\n  }\n\n  // Potentially start a new equivalence class [line:37].\n  BracketListTRACE(blist);\n  Bracket* recent = &blist.back();\n  if (recent->recent_size != blist.size()) {\n    recent->recent_size = blist.size();\n    recent->recent_class = NewClassNumber();\n  }\n\n  // Assign equivalence class to node.\n  SetClass(node, recent->recent_class);\n  TRACE(\"  Assigned class number is %zu\\n\", GetClass(node));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitPost\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Called after visiting all inputs and uses of a node in the DFS traversal.\",\n            \"logic\": \"Removes brackets pointing to the current node and propagates the bracket list up the DFS tree.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node being visited.\"\n                },\n                {\n                    \"name\": \"parent_node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The parent node in the DFS tree.\"\n                },\n                {\n                    \"name\": \"direction\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction of the DFS traversal.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"GetBracketList\",\n                \"BracketListDelete\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::VisitPost(Node* node, Node* parent_node,\n                                   DFSDirection direction) {\n  TRACE(\"CEQ: Post-visit of #%d:%s\\n\", node->id(), node->op()->mnemonic());\n  BracketList& blist = GetBracketList(node);\n\n  // Remove brackets pointing to this node [line:19].\n  BracketListDelete(blist, node, direction);\n\n  // Propagate bracket list up the DFS tree [line:13].\n  if (parent_node != nullptr) {\n    BracketList& parent_blist = GetBracketList(parent_node);\n    parent_blist.splice(parent_blist.end(), blist);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitBackedge\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Called when a backedge is found during the DFS traversal.\",\n            \"logic\": \"Pushes the backedge onto the bracket list.\",\n            \"parameters\": [\n                {\n                    \"name\": \"from\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The source node of the backedge.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The target node of the backedge.\"\n                },\n                {\n                    \"name\": \"direction\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction of the backedge.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"GetBracketList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::VisitBackedge(Node* from, Node* to,\n                                       DFSDirection direction) {\n  TRACE(\"CEQ: Backedge from #%d:%s to #%d:%s\\n\", from->id(),\n        from->op()->mnemonic(), to->id(), to->op()->mnemonic());\n\n  // Push backedge onto the bracket list [line:25].\n  Bracket bracket = {direction, kInvalidClass, 0, from, to};\n  GetBracketList(from).push_back(bracket);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RunUndirectedDFS\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Runs an undirected depth-first search to compute control equivalence classes.\",\n            \"logic\": \"Uses a stack to perform the DFS traversal.  It iterates through input and use edges, handling backedges and pushing/popping nodes from the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"exit\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The exit node of the control flow graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ZoneStack\",\n                \"DFSPush\",\n                \"VisitPre\",\n                \"Participates\",\n                \"GetData\",\n                \"NodeProperties::IsControlEdge\",\n                \"VisitBackedge\",\n                \"DFSPop\",\n                \"VisitMid\",\n                \"VisitPost\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::RunUndirectedDFS(Node* exit) {\n  ZoneStack<DFSStackEntry> stack(zone_);\n  DFSPush(stack, exit, nullptr, kInputDirection);\n  VisitPre(exit);\n\n  while (!stack.empty()) {  // Undirected depth-first backwards traversal.\n    DFSStackEntry& entry = stack.top();\n    Node* node = entry.node;\n\n    if (entry.direction == kInputDirection) {\n      if (entry.input != node->input_edges().end()) {\n        Edge edge = *entry.input;\n        Node* input = edge.to();\n        ++(entry.input);\n        if (NodeProperties::IsControlEdge(edge)) {\n          // Visit next control input.\n          if (!Participates(input)) continue;\n          if (GetData(input)->visited) continue;\n          if (GetData(input)->on_stack) {\n            // Found backedge if input is on stack.\n            if (input != entry.parent_node) {\n              VisitBackedge(node, input, kInputDirection);\n            }\n          } else {\n            // Push input onto stack.\n            DFSPush(stack, input, node, kInputDirection);\n            VisitPre(input);\n          }\n        }\n        continue;\n      }\n      if (entry.use != node->use_edges().end()) {\n        // Switch direction to uses.\n        entry.direction = kUseDirection;\n        VisitMid(node, kInputDirection);\n        continue;\n      }\n    }\n\n    if (entry.direction == kUseDirection) {\n      if (entry.use != node->use_edges().end()) {\n        Edge edge = *entry.use;\n        Node* use = edge.from();\n        ++(entry.use);\n        if (NodeProperties::IsControlEdge(edge)) {\n          // Visit next control use.\n          if (!Participates(use)) continue;\n          if (GetData(use)->visited) continue;\n          if (GetData(use)->on_stack) {\n            // Found backedge if use is on stack.\n            if (use != entry.parent_node) {\n              VisitBackedge(node, use, kUseDirection);\n            }\n          } else {\n            // Push use onto stack.\n            DFSPush(stack, use, node, kUseDirection);\n            VisitPre(use);\n          }\n        }\n        continue;\n      }\n      if (entry.input != node->input_edges().end()) {\n        // Switch direction to inputs.\n        entry.direction = kInputDirection;\n        VisitMid(node, kUseDirection);\n        continue;\n      }\n    }\n\n    // Pop node from stack when done with all inputs and uses.\n    DCHECK(entry.input == node->input_edges().end());\n    DCHECK(entry.use == node->use_edges().end());\n    VisitPost(node, entry.parent_node, entry.direction);\n    DFSPop(stack, node);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DetermineParticipationEnqueue\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Enqueues a node for participation determination if it doesn't already participate.\",\n            \"logic\": \"If the node does not participate, it allocates data for it and adds it to the queue.\",\n            \"parameters\": [\n                {\n                    \"name\": \"queue\",\n                    \"type\": \"ZoneQueue<Node*>&\",\n                    \"purpose\": \"The queue to enqueue the node into.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to enqueue.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Participates\",\n                \"AllocateData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::DetermineParticipationEnqueue(ZoneQueue<Node*>& queue,\n                                                       Node* node) {\n  if (!Participates(node)) {\n    AllocateData(node);\n    queue.push(node);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DetermineParticipation\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Determines the participation of nodes in the control equivalence analysis.\",\n            \"logic\": \"Performs a breadth-first backwards traversal to identify nodes that participate in control flow.\",\n            \"parameters\": [\n                {\n                    \"name\": \"exit\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The exit node of the control flow graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ZoneQueue\",\n                \"DetermineParticipationEnqueue\",\n                \"NodeProperties::PastControlIndex\",\n                \"NodeProperties::FirstControlIndex\",\n                \"Node::InputAt\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::DetermineParticipation(Node* exit) {\n  ZoneQueue<Node*> queue(zone_);\n  DetermineParticipationEnqueue(queue, exit);\n  while (!queue.empty()) {  // Breadth-first backwards traversal.\n    Node* node = queue.front();\n    queue.pop();\n    int max = NodeProperties::PastControlIndex(node);\n    for (int i = NodeProperties::FirstControlIndex(node); i < max; i++) {\n      DetermineParticipationEnqueue(queue, node->InputAt(i));\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DFSPush\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Pushes a node onto the DFS stack.\",\n            \"logic\": \"Sets the node's on_stack flag and pushes it onto the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"DFSStack&\",\n                    \"purpose\": \"The DFS stack.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to push onto the stack.\"\n                },\n                {\n                    \"name\": \"from\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The parent node.\"\n                },\n                {\n                    \"name\": \"dir\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction of the DFS traversal.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Participates\",\n                \"GetData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::DFSPush(DFSStack& stack, Node* node, Node* from,\n                                 DFSDirection dir) {\n  DCHECK(Participates(node));\n  DCHECK(!GetData(node)->visited);\n  GetData(node)->on_stack = true;\n  Node::InputEdges::iterator input = node->input_edges().begin();\n  Node::UseEdges::iterator use = node->use_edges().begin();\n  stack.push({dir, input, use, from, node});\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DFSPop\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Pops a node from the DFS stack.\",\n            \"logic\": \"Sets the node's on_stack and visited flags and pops it from the stack.\",\n            \"parameters\": [\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"DFSStack&\",\n                    \"purpose\": \"The DFS stack.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to pop from the stack.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"GetData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::DFSPop(DFSStack& stack, Node* node) {\n  DCHECK_EQ(stack.top().node, node);\n  GetData(node)->on_stack = false;\n  GetData(node)->visited = true;\n  stack.pop();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BracketListDelete\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Deletes brackets from a bracket list.\",\n            \"logic\": \"Iterates through the bracket list and removes brackets that point to the given node and have the opposite direction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"blist\",\n                    \"type\": \"BracketList&\",\n                    \"purpose\": \"The bracket list.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The target node.\"\n                },\n                {\n                    \"name\": \"direction\",\n                    \"type\": \"DFSDirection\",\n                    \"purpose\": \"The direction of the bracket.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::BracketListDelete(BracketList& blist, Node* to,\n                                           DFSDirection direction) {\n  // TODO(turbofan): Optimize this to avoid linear search.\n  for (BracketList::iterator i = blist.begin(); i != blist.end(); /*nop*/) {\n    if (i->to == to && i->direction != direction) {\n      TRACE(\"  BList erased: {%d->%d}\\n\", i->from->id(), i->to->id());\n      i = blist.erase(i);\n    } else {\n      ++i;\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BracketListTRACE\",\n            \"parent\": \"ControlEquivalence\",\n            \"about\": \"Traces the contents of a bracket list.\",\n            \"logic\": \"If tracing is enabled, it prints the contents of the bracket list.\",\n            \"parameters\": [\n                {\n                    \"name\": \"blist\",\n                    \"type\": \"BracketList&\",\n                    \"purpose\": \"The bracket list.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ControlEquivalence::BracketListTRACE(BracketList& blist) {\n  if (v8_flags.trace_turbo_ceq) {\n    TRACE(\"  BList: \");\n    for (Bracket bracket : blist) {\n      TRACE(\"{%d->%d} \", bracket.from->id(), bracket.to->id());\n    }\n    TRACE(\"\\n\");\n  }\n}\n        ]]></code>\n    </func>\n</file>\n```"
}