{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/sandbox/sandbox.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/sandbox/sandbox.cc\",\n        \"file_name\": \"sandbox.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the sandbox functionality for V8, providing a secure execution environment by isolating memory regions.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for sandbox implementation, V8 internals, base utilities, and flags.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/sandbox/sandbox.h\"\n\n#include \"include/v8-internal.h\"\n#include \"src/base/bits.h\"\n#include \"src/base/bounded-page-allocator.h\"\n#include \"src/base/cpu.h\"\n#include \"src/base/emulated-virtual-address-subspace.h\"\n#include \"src/base/lazy-instance.h\"\n#include \"src/base/sys-info.h\"\n#include \"src/base/utils/random-number-generator.h\"\n#include \"src/base/virtual-address-space-page-allocator.h\"\n#include \"src/base/virtual-address-space.h\"\n#include \"src/flags/flags.h\"\n#include \"src/sandbox/hardware-support.h\"\n#include \"src/sandbox/sandboxed-pointer.h\"\n#include \"src/utils/allocation.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Sandbox\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents the V8 sandbox, responsible for managing a restricted memory region.\",\n            \"attributes\": [\n                {\n                    \"name\": \"first_four_gb_of_address_space_are_reserved_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the first 4GB of address space are reserved as a mitigation.\"\n                },\n                {\n                    \"name\": \"current_\",\n                    \"type\": \"Sandbox*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Thread-local storage for the current sandbox (used when multiple cages are enabled).\"\n                },\n                {\n                    \"name\": \"default_sandbox_\",\n                    \"type\": \"Sandbox*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Static pointer to the default sandbox instance.\"\n                },\n                {\n                    \"name\": \"address_space_\",\n                    \"type\": \"std::unique_ptr<base::VirtualAddressSubspace>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Manages the virtual address subspace of the sandbox.\"\n                },\n                {\n                    \"name\": \"sandbox_page_allocator_\",\n                    \"type\": \"std::unique_ptr<base::VirtualAddressSpacePageAllocator>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Allocator used for managing pages within the sandbox.\"\n                },\n                {\n                    \"name\": \"base_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Base address of the sandbox.\"\n                },\n                {\n                    \"name\": \"end_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"End address of the sandbox.\"\n                },\n                {\n                    \"name\": \"size_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Size of the sandbox.\"\n                },\n                {\n                    \"name\": \"reservation_base_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Base address of the reserved memory region for the sandbox.\"\n                },\n                {\n                    \"name\": \"reservation_size_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Size of the reserved memory region for the sandbox.\"\n                },\n                {\n                    \"name\": \"initialized_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether the sandbox has been initialized.\"\n                },\n                {\n                    \"name\": \"constants_\",\n                    \"type\": \"internal::SandboxConstants\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores constants specific to the sandbox.\"\n                },\n                {\n                    \"name\": \"trap_handler_initialized_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the trap handler has been initialized for this sandbox.\"\n                }\n            ],\n            \"dependencies\": [\n                \"v8::VirtualAddressSpace\",\n                \"base::VirtualAddressSubspace\",\n                \"base::VirtualAddressSpacePageAllocator\",\n                \"base::RandomNumberGenerator\",\n                \"base::EmulatedVirtualAddressSubspace\",\n                \"SandboxHardwareSupport\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\n#ifdef V8_ENABLE_SANDBOX\n\nbool Sandbox::first_four_gb_of_address_space_are_reserved_ = false;\n\n#ifdef V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\nthread_local Sandbox* Sandbox::current_ = nullptr;\n// static\nSandbox* Sandbox::current_non_inlined() { return current_; }\n// static\nvoid Sandbox::set_current_non_inlined(Sandbox* sandbox) { current_ = sandbox; }\n#endif  // V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n\nSandbox* Sandbox::default_sandbox_ = nullptr;\n\n// Best-effort function to determine the approximate size of the virtual\n// address space that can be addressed by this process. Used to determine\n// appropriate sandbox size and placement.\n// The value returned by this function will always be a power of two.\nstatic Address DetermineAddressSpaceLimit() {\n#ifndef V8_TARGET_ARCH_64_BIT\n#error Unsupported target architecture.\n#endif\n\n  // Assume 48 bits by default, which seems to be the most common configuration.\n  constexpr unsigned kDefaultVirtualAddressBits = 48;\n  // 36 bits should realistically be the lowest value we could ever see.\n  constexpr unsigned kMinVirtualAddressBits = 36;\n  constexpr unsigned kMaxVirtualAddressBits = 64;\n\n  unsigned hardware_virtual_address_bits = kDefaultVirtualAddressBits;\n#if defined(V8_TARGET_ARCH_X64)\n  base::CPU cpu;\n  if (cpu.exposes_num_virtual_address_bits()) {\n    hardware_virtual_address_bits = cpu.num_virtual_address_bits();\n  }\n#endif  // V8_TARGET_ARCH_X64\n\n#if defined(V8_TARGET_ARCH_ARM64) && defined(V8_TARGET_OS_ANDROID)\n  // On Arm64 Android assume a 40-bit virtual address space (39 bits for\n  // userspace and kernel each) as that appears to be the most common\n  // configuration and there seems to be no easy way to retrieve the actual\n  // number of virtual address bits from the CPU in userspace.\n  hardware_virtual_address_bits = 40;\n#endif\n\n  // Assume virtual address space is split 50/50 between userspace and kernel.\n  hardware_virtual_address_bits -= 1;\n\n  // Check if there is a software-imposed limits on the size of the address\n  // space. For example, older Windows versions limit the address space to 8TB:\n  // https://learn.microsoft.com/en-us/windows/win32/memory/memory-limits-for-windows-releases).\n  Address software_limit = base::SysInfo::AddressSpaceEnd();\n  // Compute the next power of two that is larger or equal to the limit.\n  unsigned software_virtual_address_bits =\n      64 - base::bits::CountLeadingZeros(software_limit - 1);\n\n  // The available address space is the smaller of the two limits.\n  unsigned virtual_address_bits =\n      std::min(hardware_virtual_address_bits, software_virtual_address_bits);\n\n  // Guard against nonsensical values.\n  if (virtual_address_bits < kMinVirtualAddressBits ||\n      virtual_address_bits > kMaxVirtualAddressBits) {\n    virtual_address_bits = kDefaultVirtualAddressBits;\n  }\n\n  return 1ULL << virtual_address_bits;\n}\n\nvoid Sandbox::Initialize(v8::VirtualAddressSpace* vas) {\n  // Take the size of the virtual address space into account when determining\n  // the size of the address space reservation backing the sandbox. For\n  // example, if we only have a 40-bit address space, split evenly between\n  // userspace and kernel, then userspace can only address 512GB and so we use\n  // a quarter of that, 128GB, as maximum reservation size.\n  Address address_space_limit = DetermineAddressSpaceLimit();\n  // Note: this is technically the maximum reservation size excluding the guard\n  // regions (which are not created for partially-reserved sandboxes).\n  size_t max_reservation_size = address_space_limit / 4;\n\n  // In any case, the sandbox should be smaller than our address space since we\n  // otherwise wouldn't always be able to allocate objects inside of it.\n  CHECK_LT(kSandboxSize, address_space_limit);\n\n  if (!vas->CanAllocateSubspaces()) {\n    // If we cannot create virtual memory subspaces, we fall back to creating a\n    // partially reserved sandbox. This will happen for example on older\n    // Windows versions (before Windows 10) where the necessary memory\n    // management APIs, in particular, VirtualAlloc2, are not available.\n    // Since reserving virtual memory is an expensive operation on Windows\n    // before version 8.1 (reserving 1TB of address space will increase private\n    // memory usage by around 2GB), we only reserve the minimal amount of\n    // address space here. This way, we don't incur the cost of reserving\n    // virtual memory, but also don't get the desired security properties as\n    // unrelated mappings may end up inside the sandbox.\n    max_reservation_size = kSandboxMinimumReservationSize;\n  }\n\n  // If the maximum reservation size is less than the size of the sandbox, we\n  // can only create a partially-reserved sandbox.\n  bool success;\n  size_t reservation_size = std::min(kSandboxSize, max_reservation_size);\n  DCHECK(base::bits::IsPowerOfTwo(reservation_size));\n  if (reservation_size < kSandboxSize) {\n    DCHECK_GE(max_reservation_size, kSandboxMinimumReservationSize);\n    success = InitializeAsPartiallyReservedSandbox(vas, kSandboxSize,\n                                                   reservation_size);\n  } else {\n    DCHECK_EQ(kSandboxSize, reservation_size);\n    constexpr bool use_guard_regions = true;\n    success = Initialize(vas, kSandboxSize, use_guard_regions);\n  }\n\n  // Fall back to creating a (smaller) partially reserved sandbox.\n  while (!success && reservation_size > kSandboxMinimumReservationSize) {\n    static_assert(kFallbackToPartiallyReservedSandboxAllowed);\n    reservation_size /= 2;\n    DCHECK_GE(reservation_size, kSandboxMinimumReservationSize);\n    success = InitializeAsPartiallyReservedSandbox(vas, kSandboxSize,\n                                                   reservation_size);\n  }\n\n  if (!success) {\n    V8::FatalProcessOutOfMemory(\n        nullptr,\n        \"Failed to reserve the virtual address space for the V8 sandbox\");\n  }\n\n#if V8_ENABLE_WEBASSEMBLY && V8_TRAP_HANDLER_SUPPORTED\n  if (trap_handler::RegisterV8Sandbox(base(), size())) {\n    trap_handler_initialized_ = true;\n  } else {\n    V8::FatalProcessOutOfMemory(\n        nullptr, \"Failed to allocate sandbox record for trap handling.\");\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY && V8_TRAP_HANDLER_SUPPORTED\n\n  SandboxHardwareSupport::TryEnable(base(), size());\n\n  DCHECK(initialized_);\n}\n\nbool Sandbox::Initialize(v8::VirtualAddressSpace* vas, size_t size,\n                         bool use_guard_regions) {\n  CHECK(!initialized_);\n  CHECK(base::bits::IsPowerOfTwo(size));\n  CHECK(vas->CanAllocateSubspaces());\n\n  size_t reservation_size = size;\n  // As a temporary workaround for crbug.com/40070746 we use larger guard\n  // regions at the end of the sandbox.\n  // TODO(40070746): remove this workaround again once we have a proper fix.\n  size_t true_reservation_size = size;\n#if defined(V8_TARGET_OS_ANDROID)\n  // On Android, we often won't have sufficient virtual address space available.\n  const size_t kAdditionalTrailingGuardRegionSize = 0;\n#else\n  // Worst-case, we currently need 8 (max element size) * 32GB (max ArrayBuffer\n  // size) + 4GB (additional offset for TypedArray access).\n  const size_t kTotalTrailingGuardRegionSize = 260ULL * GB;\n  const size_t kAdditionalTrailingGuardRegionSize =\n      kTotalTrailingGuardRegionSize - kSandboxGuardRegionSize;\n#endif\n  if (use_guard_regions) {\n    reservation_size += 2 * kSandboxGuardRegionSize;\n    true_reservation_size =\n        reservation_size + kAdditionalTrailingGuardRegionSize;\n  }\n\n  Address hint = RoundDown(vas->RandomPageAddress(), kSandboxAlignment);\n\n  // There should be no executable pages mapped inside the sandbox since\n  // those could be corrupted by an attacker and therefore pose a security\n  // risk. Furthermore, allowing executable mappings in the sandbox requires\n  // MAP_JIT on macOS, which causes fork() to become excessively slow\n  // (multiple seconds or even minutes for a 1TB sandbox on macOS 12.X), in\n  // turn causing tests to time out. As such, the maximum page permission\n  // inside the sandbox should be read + write.\n  address_space_ =\n      vas->AllocateSubspace(hint, true_reservation_size, kSandboxAlignment,\n                            PagePermissions::kReadWrite);\n\n  if (!address_space_) return false;\n\n  reservation_base_ = address_space_->base();\n  base_ = reservation_base_ + (use_guard_regions ? kSandboxGuardRegionSize : 0);\n  size_ = size;\n  end_ = base_ + size_;\n  reservation_size_ = reservation_size;\n  sandbox_page_allocator_ =\n      std::make_unique<base::VirtualAddressSpacePageAllocator>(\n          address_space_.get());\n\n  if (use_guard_regions) {\n    Address front = reservation_base_;\n    Address back = end_;\n    // These must succeed since nothing was allocated in the subspace yet.\n    CHECK(address_space_->AllocateGuardRegion(front, kSandboxGuardRegionSize));\n    CHECK(address_space_->AllocateGuardRegion(\n        back, kSandboxGuardRegionSize + kAdditionalTrailingGuardRegionSize));\n  }\n\n  // Also try to reserve the first 4GB of the process' address space. This\n  // mitigates Smi<->HeapObject confusion bugs in which we end up treating a\n  // Smi value as a pointer.\n  if (!first_four_gb_of_address_space_are_reserved_) {\n    Address end = 4UL * GB;\n    size_t step = address_space_->allocation_granularity();\n    for (Address start = 0; start <= 1 * MB; start += step) {\n      if (vas->AllocateGuardRegion(start, end - start)) {\n        first_four_gb_of_address_space_are_reserved_ = true;\n        break;\n      }\n    }\n  }\n\n  initialized_ = true;\n\n  FinishInitialization();\n\n  DCHECK(!is_partially_reserved());\n  return true;\n}\n\nbool Sandbox::InitializeAsPartiallyReservedSandbox(v8::VirtualAddressSpace* vas,\n                                                   size_t size,\n                                                   size_t size_to_reserve) {\n  CHECK(!initialized_);\n  CHECK(base::bits::IsPowerOfTwo(size));\n  CHECK(base::bits::IsPowerOfTwo(size_to_reserve));\n  CHECK_LT(size_to_reserve, size);\n\n  // Use a custom random number generator here to ensure that we get uniformly\n  // distributed random numbers. We figure out the available address space\n  // ourselves, and so are potentially better positioned to determine a good\n  // base address for the sandbox than the embedder.\n  base::RandomNumberGenerator rng;\n  if (v8_flags.random_seed != 0) {\n    rng.SetSeed(v8_flags.random_seed);\n  }\n\n  // We try to ensure that base + size is still (mostly) within the process'\n  // address space, even though we only reserve a fraction of the memory. For\n  // that, we attempt to map the sandbox into the first half of the usable\n  // address space. This keeps the implementation simple and should, In any\n  // realistic scenario, leave plenty of space after the actual reservation.\n  Address address_space_end = DetermineAddressSpaceLimit();\n  Address highest_allowed_address = address_space_end / 2;\n  DCHECK(base::bits::IsPowerOfTwo(highest_allowed_address));\n  constexpr int kMaxAttempts = 10;\n  for (int i = 1; i <= kMaxAttempts; i++) {\n    Address hint = rng.NextInt64() % highest_allowed_address;\n    hint = RoundDown(hint, kSandboxAlignment);\n\n    reservation_base_ = vas->AllocatePages(\n        hint, size_to_reserve, kSandboxAlignment, PagePermissions::kNoAccess);\n\n    if (!reservation_base_) return false;\n\n    // Take this base if it meets the requirements or if this is the last\n    // attempt.\n    if (reservation_base_ <= highest_allowed_address || i == kMaxAttempts)\n      break;\n\n    // Can't use this base, so free the reservation and try again\n    vas->FreePages(reservation_base_, size_to_reserve);\n    reservation_base_ = kNullAddress;\n  }\n  DCHECK(reservation_base_);\n\n  base_ = reservation_base_;\n  size_ = size;\n  end_ = base_ + size_;\n  reservation_size_ = size_to_reserve;\n  initialized_ = true;\n  address_space_ = std::make_unique<base::EmulatedVirtualAddressSubspace>(\n      vas, reservation_base_, reservation_size_, size_);\n  sandbox_page_allocator_ =\n      std::make_unique<base::VirtualAddressSpacePageAllocator>(\n          address_space_.get());\n\n  FinishInitialization();\n\n  DCHECK(is_partially_reserved());\n  return true;\n}\n\nvoid Sandbox::FinishInitialization() {\n  // Reserve the last page in the sandbox. This way, we can place inaccessible\n  // \"objects\" (e.g. the empty backing store buffer) there that are guaranteed\n  // to cause a fault on any accidental access.\n  // Further, this also prevents the accidental construction of invalid\n  // SandboxedPointers: if an ArrayBuffer is placed right at the end of the\n  // sandbox, an ArrayBufferView could be constructed with byteLength=0 and\n  // offset=buffer.byteLength, which would lead to a pointer that points just\n  // outside of the sandbox.\n  size_t allocation_granularity = address_space_->allocation_granularity();\n  bool success = address_space_->AllocateGuardRegion(\n      end_ - allocation_granularity, allocation_granularity);\n  // If the sandbox is partially-reserved, this operation may fail, for example\n  // if the last page is outside of the mappable address space of the process.\n  CHECK(success || is_partially_reserved());\n\n  InitializeConstants();\n}\n\nvoid Sandbox::InitializeConstants() {\n  // Place the empty backing store buffer at the end of the sandbox, so that any\n  // accidental access to it will most likely hit a guard page.\n  constants_.set_empty_backing_store_buffer(end_ - 1);\n}\n\nvoid Sandbox::TearDown() {\n  if (initialized_) {\n#if V8_ENABLE_WEBASSEMBLY && V8_TRAP_HANDLER_SUPPORTED\n    if (trap_handler_initialized_) {\n      trap_handler::UnregisterV8Sandbox(base(), size());\n      trap_handler_initialized_ = false;\n    }\n#endif  // V8_ENABLE_WEBASSEMBLY && V8_TRAP_HANDLER_SUPPORTED\n\n    // This destroys the sub space and frees the underlying reservation.\n    address_space_.reset();\n    sandbox_page_allocator_.reset();\n    base_ = kNullAddress;\n    end_ = kNullAddress;\n    size_ = 0;\n    reservation_base_ = kNullAddress;\n    reservation_size_ = 0;\n    initialized_ = false;\n    constants_.Reset();\n  }\n}\n\n// static\nvoid Sandbox::InitializeDefaultOncePerProcess(v8::VirtualAddressSpace* vas) {\n  static base::LeakyObject<Sandbox> default_sandbox;\n  default_sandbox_ = default_sandbox.get();\n\n#ifdef V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n  set_current(default_sandbox_);\n#endif\n  default_sandbox_->Initialize(vas);\n}\n\n// static\nvoid Sandbox::TearDownDefault() {\n  GetDefault()->TearDown();\n\n#ifdef V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n  set_current(nullptr);\n#endif\n}\n\n// static\nSandbox* Sandbox::New(v8::VirtualAddressSpace* vas) {\n  if (!COMPRESS_POINTERS_IN_MULTIPLE_CAGES_BOOL) {\n    FATAL(\n        \"Creation of new sandboxes requires enabling \"\n        \"multiple pointer compression cages at build-time\");\n  }\n  Sandbox* sandbox = new Sandbox;\n  sandbox->Initialize(vas);\n  CHECK(!v8_flags.sandbox_testing && !v8_flags.sandbox_fuzzing);\n  return sandbox;\n}\n\n#endif  // V8_ENABLE_SANDBOX\n\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DetermineAddressSpaceLimit\",\n            \"parent\": null,\n            \"about\": \"Determines the approximate size of the virtual address space that can be addressed by this process.\",\n            \"logic\": \"Determines the address space limit by considering hardware and software limitations.  It uses CPU information when available, falls back to defaults, and considers OS-specific limitations.  It returns a power of two representing the address space limit.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Address\",\n                \"description\": \"The address space limit.\"\n            },\n            \"dependencies\": [\n                \"base::CPU\",\n                \"base::SysInfo\",\n                \"base::bits::CountLeadingZeros\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic Address DetermineAddressSpaceLimit() {\n#ifndef V8_TARGET_ARCH_64_BIT\n#error Unsupported target architecture.\n#endif\n\n  // Assume 48 bits by default, which seems to be the most common configuration.\n  constexpr unsigned kDefaultVirtualAddressBits = 48;\n  // 36 bits should realistically be the lowest value we could ever see.\n  constexpr unsigned kMinVirtualAddressBits = 36;\n  constexpr unsigned kMaxVirtualAddressBits = 64;\n\n  unsigned hardware_virtual_address_bits = kDefaultVirtualAddressBits;\n#if defined(V8_TARGET_ARCH_X64)\n  base::CPU cpu;\n  if (cpu.exposes_num_virtual_address_bits()) {\n    hardware_virtual_address_bits = cpu.num_virtual_address_bits();\n  }\n#endif  // V8_TARGET_ARCH_X64\n\n#if defined(V8_TARGET_ARCH_ARM64) && defined(V8_TARGET_OS_ANDROID)\n  // On Arm64 Android assume a 40-bit virtual address space (39 bits for\n  // userspace and kernel each) as that appears to be the most common\n  // configuration and there seems to be no easy way to retrieve the actual\n  // number of virtual address bits from the CPU in userspace.\n  hardware_virtual_address_bits = 40;\n#endif\n\n  // Assume virtual address space is split 50/50 between userspace and kernel.\n  hardware_virtual_address_bits -= 1;\n\n  // Check if there is a software-imposed limits on the size of the address\n  // space. For example, older Windows versions limit the address space to 8TB:\n  // https://learn.microsoft.com/en-us/windows/win32/memory/memory-limits-for-windows-releases).\n  Address software_limit = base::SysInfo::AddressSpaceEnd();\n  // Compute the next power of two that is larger or equal to the limit.\n  unsigned software_virtual_address_bits =\n      64 - base::bits::CountLeadingZeros(software_limit - 1);\n\n  // The available address space is the smaller of the two limits.\n  unsigned virtual_address_bits =\n      std::min(hardware_virtual_address_bits, software_virtual_address_bits);\n\n  // Guard against nonsensical values.\n  if (virtual_address_bits < kMinVirtualAddressBits ||\n      virtual_address_bits > kMaxVirtualAddressBits) {\n    virtual_address_bits = kDefaultVirtualAddressBits;\n  }\n\n  return 1ULL << virtual_address_bits;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Initialize\",\n            \"parent\": \"Sandbox\",\n            \"about\": \"Initializes the sandbox, reserving and configuring its memory region.\",\n            \"logic\": \"The function determines the available address space, decides between a fully or partially reserved sandbox, and attempts to allocate memory with guard regions for security. It handles fallback to smaller sandbox sizes if allocation fails. The function also attempts to reserve the first 4GB of address space.\",\n            \"parameters\": [\n                {\n                    \"name\": \"vas\",\n                    \"type\": \"v8::VirtualAddressSpace*\",\n                    \"purpose\": \"The virtual address space to allocate the sandbox within.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"DetermineAddressSpaceLimit\",\n                \"base::bits::IsPowerOfTwo\",\n                \"InitializeAsPartiallyReservedSandbox\",\n                \"Initialize\",\n                \"V8::FatalProcessOutOfMemory\",\n                \"trap_handler::RegisterV8Sandbox\",\n                \"SandboxHardwareSupport::TryEnable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Sandbox::Initialize(v8::VirtualAddressSpace* vas) {\n  // Take the size of the virtual address space into account when determining\n  // the size of the address space reservation backing the sandbox. For\n  // example, if we only have a 40-bit address space, split evenly between\n  // userspace and kernel, then userspace can only address 512GB and so we use\n  // a quarter of that, 128GB, as maximum reservation size.\n  Address address_space_limit = DetermineAddressSpaceLimit();\n  // Note: this is technically the maximum reservation size excluding the guard\n  // regions (which are not created for partially-reserved sandboxes).\n  size_t max_reservation_size = address_space_limit / 4;\n\n  // In any case, the sandbox should be smaller than our address space since we\n  // otherwise wouldn't always be able to allocate objects inside of it.\n  CHECK_LT(kSandboxSize, address_space_limit);\n\n  if (!vas->CanAllocateSubspaces()) {\n    // If we cannot create virtual memory subspaces, we fall back to creating a\n    // partially reserved sandbox. This will happen for example on older\n    // Windows versions (before Windows 10) where the necessary memory\n    // management APIs, in particular, VirtualAlloc2, are not available.\n    // Since reserving virtual memory is an expensive operation on Windows\n    // before version 8.1 (reserving 1TB of address space will increase private\n    // memory usage by around 2GB), we only reserve the minimal amount of\n    // address space here. This way, we don't incur the cost of reserving\n    // virtual memory, but also don't get the desired security properties as\n    // unrelated mappings may end up inside the sandbox.\n    max_reservation_size = kSandboxMinimumReservationSize;\n  }\n\n  // If the maximum reservation size is less than the size of the sandbox, we\n  // can only create a partially-reserved sandbox.\n  bool success;\n  size_t reservation_size = std::min(kSandboxSize, max_reservation_size);\n  DCHECK(base::bits::IsPowerOfTwo(reservation_size));\n  if (reservation_size < kSandboxSize) {\n    DCHECK_GE(max_reservation_size, kSandboxMinimumReservationSize);\n    success = InitializeAsPartiallyReservedSandbox(vas, kSandboxSize,\n                                                   reservation_size);\n  } else {\n    DCHECK_EQ(kSandboxSize, reservation_size);\n    constexpr bool use_guard_regions = true;\n    success = Initialize(vas, kSandboxSize, use_guard_regions);\n  }\n\n  // Fall back to creating a (smaller) partially reserved sandbox.\n  while (!success && reservation_size > kSandboxMinimumReservationSize) {\n    static_assert(kFallbackToPartiallyReservedSandboxAllowed);\n    reservation_size /= 2;\n    DCHECK_GE(reservation_size, kSandboxMinimumReservationSize);\n    success = InitializeAsPartiallyReservedSandbox(vas, kSandboxSize,\n                                                   reservation_size);\n  }\n\n  if (!success) {\n    V8::FatalProcessOutOfMemory(\n        nullptr,\n        \"Failed to reserve the virtual address space for the V8 sandbox\");\n  }\n\n#if V8_ENABLE_WEBASSEMBLY && V8_TRAP_HANDLER_SUPPORTED\n  if (trap_handler::RegisterV8Sandbox(base(), size())) {\n    trap_handler_initialized_ = true;\n  } else {\n    V8::FatalProcessOutOfMemory(\n        nullptr, \"Failed to allocate sandbox record for trap handling.\");\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY && V8_TRAP_HANDLER_SUPPORTED\n\n  SandboxHardwareSupport::TryEnable(base(), size());\n\n  DCHECK(initialized_);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Initialize\",\n            \"parent\": \"Sandbox\",\n            \"about\": \"Initializes the sandbox with a specific size and option to use guard regions.\",\n            \"logic\": \"This function allocates a virtual address subspace with specified permissions, reserves guard regions at the beginning and end of the sandbox to detect out-of-bounds access, and attempts to reserve the first 4GB of address space for security.\",\n            \"parameters\": [\n                {\n                    \"name\": \"vas\",\n                    \"type\": \"v8::VirtualAddressSpace*\",\n                    \"purpose\": \"The virtual address space to allocate the sandbox within.\"\n                },\n                {\n                    \"name\": \"size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The size of the sandbox.\"\n                },\n                {\n                    \"name\": \"use_guard_regions\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether to use guard regions around the sandbox.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if initialization was successful, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"base::bits::IsPowerOfTwo\",\n                \"vas->AllocateSubspace\",\n                \"RoundDown\",\n                \"vas->AllocateGuardRegion\",\n                \"FinishInitialization\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Sandbox::Initialize(v8::VirtualAddressSpace* vas, size_t size,\n                         bool use_guard_regions) {\n  CHECK(!initialized_);\n  CHECK(base::bits::IsPowerOfTwo(size));\n  CHECK(vas->CanAllocateSubspaces());\n\n  size_t reservation_size = size;\n  // As a temporary workaround for crbug.com/40070746 we use larger guard\n  // regions at the end of the sandbox.\n  // TODO(40070746): remove this workaround again once we have a proper fix.\n  size_t true_reservation_size = size;\n#if defined(V8_TARGET_OS_ANDROID)\n  // On Android, we often won't have sufficient virtual address space available.\n  const size_t kAdditionalTrailingGuardRegionSize = 0;\n#else\n  // Worst-case, we currently need 8 (max element size) * 32GB (max ArrayBuffer\n  // size) + 4GB (additional offset for TypedArray access).\n  const size_t kTotalTrailingGuardRegionSize = 260ULL * GB;\n  const size_t kAdditionalTrailingGuardRegionSize =\n      kTotalTrailingGuardRegionSize - kSandboxGuardRegionSize;\n#endif\n  if (use_guard_regions) {\n    reservation_size += 2 * kSandboxGuardRegionSize;\n    true_reservation_size =\n        reservation_size + kAdditionalTrailingGuardRegionSize;\n  }\n\n  Address hint = RoundDown(vas->RandomPageAddress(), kSandboxAlignment);\n\n  // There should be no executable pages mapped inside the sandbox since\n  // those could be corrupted by an attacker and therefore pose a security\n  // risk. Furthermore, allowing executable mappings in the sandbox requires\n  // MAP_JIT on macOS, which causes fork() to become excessively slow\n  // (multiple seconds or even minutes for a 1TB sandbox on macOS 12.X), in\n  // turn causing tests to time out. As such, the maximum page permission\n  // inside the sandbox should be read + write.\n  address_space_ =\n      vas->AllocateSubspace(hint, true_reservation_size, kSandboxAlignment,\n                            PagePermissions::kReadWrite"
}