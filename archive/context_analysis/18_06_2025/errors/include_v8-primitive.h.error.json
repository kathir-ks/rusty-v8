{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-primitive.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-primitive.h\",\n        \"file_name\": \"v8-primitive.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the v8::Primitive class hierarchy and related classes for representing JavaScript primitive values (Boolean, String, Number, Symbol, BigInt) in the V8 engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary V8 headers for data structures, internal APIs, local handles, value representation, and configuration.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"v8-data.h\"          // NOLINT(build/include_directory)\n            #include \"v8-internal.h\"      // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n            #include \"v8-value.h\"         // NOLINT(build/include_directory)\n            #include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Primitive\",\n            \"extends\": \"Value\",\n            \"about\": \"The superclass of primitive values in JavaScript (ECMA-262 4.3.2).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Primitive : public Value {};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Boolean\",\n            \"extends\": \"Primitive\",\n            \"about\": \"Represents a primitive boolean value (ECMA-262, 4.3.14). Either true or false.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Primitive\",\n                \"Isolate\",\n                \"Data\",\n                \"Local\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Boolean : public Primitive {\n            public:\n                bool Value() const;\n                V8_INLINE static Boolean* Cast(v8::Data* data) {\n            #ifdef V8_ENABLE_CHECKS\n                CheckCast(data);\n            #endif\n                return static_cast<Boolean*>(data);\n                }\n\n                V8_INLINE static Local<Boolean> New(Isolate* isolate, bool value);\n\n            private:\n                static void CheckCast(v8::Data* that);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PrimitiveArray\",\n            \"extends\": \"Data\",\n            \"about\": \"An array to hold Primitive values. Used by the embedder to pass host defined options to the ScriptOptions during compilation and in HostImportModuleDynamicallyCallback.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Data\",\n                \"Isolate\",\n                \"Local\",\n                \"Primitive\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT PrimitiveArray : public Data {\n            public:\n                static Local<PrimitiveArray> New(Isolate* isolate, int length);\n                int Length() const;\n                void Set(Isolate* isolate, int index, Local<Primitive> item);\n                Local<Primitive> Get(Isolate* isolate, int index);\n\n                V8_INLINE static PrimitiveArray* Cast(Data* data) {\n            #ifdef V8_ENABLE_CHECKS\n                CheckCast(data);\n            #endif\n                return reinterpret_cast<PrimitiveArray*>(data);\n                }\n\n            private:\n                static void CheckCast(Data* obj);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Name\",\n            \"extends\": \"Primitive\",\n            \"about\": \"A superclass for symbols and strings.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Primitive\",\n                \"Data\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Name : public Primitive {\n            public:\n                /**\n                * Returns the identity hash for this object. The current implementation\n                * uses an inline property on the object to store the identity hash.\n                *\n                * The return value will never be 0. Also, it is not guaranteed to be\n                * unique.\n                */\n                int GetIdentityHash();\n\n                V8_INLINE static Name* Cast(Data* data) {\n            #ifdef V8_ENABLE_CHECKS\n                CheckCast(data);\n            #endif\n                return static_cast<Name*>(data);\n                }\n\n            private:\n                static void CheckCast(Data* that);\n            };\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"NewStringType\",\n            \"about\": \"A flag describing different modes of string creation.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class NewStringType {\n            /**\n             * Create a new string, always allocating new storage memory.\n             */\n            kNormal,\n\n            /**\n             * Acts as a hint that the string should be created in the\n             * old generation heap space and be deduplicated if an identical string\n             * already exists.\n             */\n            kInternalized\n            };\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"String\",\n            \"extends\": \"Name\",\n            \"about\": \"Represents a JavaScript string value (ECMA-262, 4.3.17).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Name\",\n                \"Isolate\",\n                \"Local\",\n                \"ExternalStringResource\",\n                \"ExternalOneByteStringResource\",\n                \"Value\",\n                \"internal::kApiSystemPointerSize\",\n                \"NewStringType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT String : public Name {\n            public:\n                static constexpr int kMaxLength =\n                internal::kApiSystemPointerSize == 4 ? (1 << 28) - 16 : (1 << 29) - 24;\n\n                enum Encoding {\n                UNKNOWN_ENCODING = 0x1,\n                TWO_BYTE_ENCODING = 0x0,\n                ONE_BYTE_ENCODING = 0x8\n                };\n                /**\n                * Returns the number of characters (UTF-16 code units) in this string.\n                */\n                int Length() const;\n\n                /**\n                * Returns the number of bytes in the UTF-8 encoded\n                * representation of this string.\n                */\n                V8_DEPRECATED(\"Use Utf8LengthV2 instead.\")\n                int Utf8Length(Isolate* isolate) const;\n\n                /**\n                * Returns the number of bytes needed for the Utf8 encoding of this string.\n                */\n                size_t Utf8LengthV2(Isolate* isolate) const;\n\n                /**\n                * Returns whether this string is known to contain only one byte data,\n                * i.e. ISO-8859-1 code points.\n                * Does not read the string.\n                * False negatives are possible.\n                */\n                bool IsOneByte() const;\n\n                /**\n                * Returns whether this string contain only one byte data,\n                * i.e. ISO-8859-1 code points.\n                * Will read the entire string in some cases.\n                */\n                bool ContainsOnlyOneByte() const;\n\n                /**\n                * Write the contents of the string to an external buffer.\n                * If no arguments are given, expects the buffer to be large\n                * enough to hold the entire string and NULL terminator. Copies\n                * the contents of the string and the NULL terminator into the\n                * buffer.\n                *\n                * WriteUtf8 will not write partial UTF-8 sequences, preferring to stop\n                * before the end of the buffer.\n                *\n                * Copies up to length characters into the output buffer.\n                * Only null-terminates if there is enough space in the buffer.\n                *\n                * \\param buffer The buffer into which the string will be copied.\n                * \\param start The starting position within the string at which\n                * copying begins.\n                * \\param length The number of characters to copy from the string.  For\n                *    WriteUtf8 the number of bytes in the buffer.\n                * \\param nchars_ref The number of characters written, can be NULL.\n                * \\param options Various options that might affect performance of this or\n                *    subsequent operations.\n                * \\return The number of characters copied to the buffer excluding the null\n                *    terminator.  For WriteUtf8: The number of bytes copied to the buffer\n                *    including the null terminator (if written).\n                */\n                enum WriteOptions {\n                NO_OPTIONS = 0,\n                HINT_MANY_WRITES_EXPECTED = 1,\n                NO_NULL_TERMINATION = 2,\n                PRESERVE_ONE_BYTE_NULL = 4,\n                // Used by WriteUtf8 to replace orphan surrogate code units with the\n                // unicode replacement character. Needs to be set to guarantee valid UTF-8\n                // output.\n                REPLACE_INVALID_UTF8 = 8\n                };\n\n                // 16-bit character codes.\n                V8_DEPRECATED(\"Use WriteV2 instead.\")\n                int Write(Isolate* isolate, uint16_t* buffer, int start = 0, int length = -1,\n                            int options = NO_OPTIONS) const;\n                // One byte characters.\n                V8_DEPRECATED(\"Use WriteOneByteV2 instead.\")\n                int WriteOneByte(Isolate* isolate, uint8_t* buffer, int start = 0,\n                                int length = -1, int options = NO_OPTIONS) const;\n                // UTF-8 encoded characters.\n                V8_DEPRECATED(\"Use WriteUtf8V2 instead.\")\n                int WriteUtf8(Isolate* isolate, char* buffer, int length = -1,\n                            int* nchars_ref = nullptr, int options = NO_OPTIONS) const;\n\n                struct WriteFlags {\n                    enum {\n                    kNone = 0,\n                    // Indicates that the output string should be null-terminated. In that\n                    // case, the output buffer must include sufficient space for the\n                    // additional null character.\n                    kNullTerminate = 1,\n                    // Used by WriteUtf8 to replace orphan surrogate code units with the\n                    // unicode replacement character. Needs to be set to guarantee valid UTF-8\n                    // output.\n                    kReplaceInvalidUtf8 = 2\n                    };\n                };\n\n                /**\n                * Write the contents of the string to an external buffer.\n                *\n                * Copies length characters into the output buffer starting at offset. The\n                * output buffer must have sufficient space for all characters and the null\n                * terminator if null termination is requested through the flags.\n                *\n                * \\param offset The position within the string at which copying begins.\n                * \\param length The number of characters to copy from the string.\n                * \\param buffer The buffer into which the string will be copied.\n                * \\param flags Various flags that influence the behavior of this operation.\n                */\n                void WriteV2(Isolate* isolate, uint32_t offset, uint32_t length,\n                            uint16_t* buffer, int flags = WriteFlags::kNone) const;\n                void WriteOneByteV2(Isolate* isolate, uint32_t offset, uint32_t length,\n                                    uint8_t* buffer, int flags = WriteFlags::kNone) const;\n\n                /**\n                * Encode the contents of the string as Utf8 into an external buffer.\n                *\n                * Encodes the characters of this string as Utf8 and writes them into the\n                * output buffer until either all characters were encoded or the buffer is\n                * full. Will not write partial UTF-8 sequences, preferring to stop before\n                * the end of the buffer. If null termination is requested, the output buffer\n                * will always be null terminated even if not all characters fit. In that\n                * case, the capacity must be at least one. The required size of the output\n                * buffer can be determined using Utf8Length().\n                *\n                * \\param buffer The buffer into which the string will be written.\n                * \\param capacity The number of bytes available in the output buffer.\n                * \\param flags Various flags that influence the behavior of this operation.\n                * \\param processed_characters_return The number of processed characters from\n                * the buffer.\n                * \\return The number of bytes copied to the buffer including the null\n                * terminator (if written).\n                */\n                size_t WriteUtf8V2(Isolate* isolate, char* buffer, size_t capacity,\n                                    int flags = WriteFlags::kNone,\n                                    size_t* processed_characters_return = nullptr) const;\n\n                /**\n                * A zero length string.\n                */\n                V8_INLINE static Local<String> Empty(Isolate* isolate);\n\n                /**\n                * Returns true if the string is external.\n                */\n                bool IsExternal() const;\n\n                /**\n                * Returns true if the string is both external and two-byte.\n                */\n                bool IsExternalTwoByte() const;\n\n                /**\n                * Returns true if the string is both external and one-byte.\n                */\n                bool IsExternalOneByte() const;\n\n                /**\n                * Returns the internalized string. See `NewStringType::kInternalized` for\n                * details on internalized strings.\n                */\n                Local<String> InternalizeString(Isolate* isolate);\n\n                class V8_EXPORT ExternalStringResourceBase {\n                public:\n                    virtual ~ExternalStringResourceBase() = default;\n\n                    /**\n                     * If a string is cacheable, the value returned by\n                     * ExternalStringResource::data() may be cached, otherwise it is not\n                     * expected to be stable beyond the current top-level task.\n                     */\n                    virtual bool IsCacheable() const { return true; }\n\n                    /**\n                     * Internally V8 will call this Unaccount method when the external string\n                     * resource should be unaccounted for. This method can be overridden in\n                     * subclasses to control how allocated external bytes are accounted.\n                     */\n                    virtual void Unaccount(Isolate* isolate) {}\n\n                    /**\n                     * Returns an estimate of the memory occupied by this external string, to be\n                     * used by V8 when producing a heap snapshot. If this function returns\n                     * kDefaultMemoryEstimate, then V8 will estimate the external size based on\n                     * the string length. This function should return only memory that is\n                     * uniquely owned by this resource. If the resource has shared ownership of\n                     * a secondary allocation, it can report that memory by implementing\n                     * EstimateSharedMemoryUsage.\n                     */\n                    virtual size_t EstimateMemoryUsage() const {\n                    return kDefaultMemoryEstimate;\n                    }\n                    static constexpr size_t kDefaultMemoryEstimate = static_cast<size_t>(-1);\n\n                    class V8_EXPORT SharedMemoryUsageRecorder {\n                    public:\n                        /**\n                         * Record that a shared allocation at the given location has the given\n                         * size.\n                         */\n                        virtual void RecordSharedMemoryUsage(const void* location,\n                                                            size_t size) = 0;\n                    };\n\n                    /**\n                     * Estimates memory that this string resource may share with other string\n                     * resources, to be used by V8 when producing a heap snapshot.\n                     */\n                    virtual void EstimateSharedMemoryUsage(\n                        SharedMemoryUsageRecorder* recorder) const {}\n\n                    // Disallow copying and assigning.\n                    ExternalStringResourceBase(const ExternalStringResourceBase&) = delete;\n                    void operator=(const ExternalStringResourceBase&) = delete;\n\n                protected:\n                    ExternalStringResourceBase() = default;\n\n                    /**\n                     * Internally V8 will call this Dispose method when the external string\n                     * resource is no longer needed. The default implementation will use the\n                     * delete operator. This method can be overridden in subclasses to\n                     * control how allocated external string resources are disposed.\n                     */\n                    virtual void Dispose() { delete this; }\n\n                    /**\n                     * For a non-cacheable string, the value returned by\n                     * |ExternalStringResource::data()| has to be stable between |Lock()| and\n                     * |Unlock()|, that is the string must behave as is |IsCacheable()| returned\n                     * true.\n                     *\n                     * These two functions must be thread-safe, and can be called from anywhere.\n                     * They also must handle lock depth, in the sense that each can be called\n                     * several times, from different threads, and unlocking should only happen\n                     * when the balance of Lock() and Unlock() calls is 0.\n                     */\n                    virtual void Lock() const {}\n\n                    /**\n                     * Unlocks the string.\n                     */\n                    virtual void Unlock() const {}\n\n                private:\n                    friend class internal::ExternalString;\n                    friend class v8::String;\n                    friend class internal::StringForwardingTable;\n                    friend class internal::ScopedExternalStringLock;\n                };\n\n                /**\n                * An ExternalStringResource is a wrapper around a two-byte string\n                * buffer that resides outside V8's heap. Implement an\n                * ExternalStringResource to manage the life cycle of the underlying\n                * buffer.  Note that the string data must be immutable.\n                */\n                class V8_EXPORT ExternalStringResource : public ExternalStringResourceBase {\n                public:\n                    /**\n                     * Override the destructor to manage the life cycle of the underlying\n                     * buffer.\n                     */\n                    ~ExternalStringResource() override = default;\n\n                    /**\n                     * The string data from the underlying buffer. If the resource is cacheable\n                     * then data() must return the same value for all invocations.\n                     */\n                    virtual const uint16_t* data() const = 0;\n\n                    /**\n                     * The length of the string. That is, the number of two-byte characters.\n                     */\n                    virtual size_t length() const = 0;\n\n                    /**\n                     * Returns the cached data from the underlying buffer. This method can be\n                     * called only for cacheable resources (i.e. IsCacheable() == true) and only\n                     * after UpdateDataCache() was called.\n                     */\n                    const uint16_t* cached_data() const {\n                    CheckCachedDataInvariants();\n                    return cached_data_;\n                    }\n\n                    /**\n                     * Update {cached_data_} with the data from the underlying buffer. This can\n                     * be called only for cacheable resources.\n                     */\n                    void UpdateDataCache();\n\n                protected:\n                    ExternalStringResource() = default;\n\n                private:\n                    void CheckCachedDataInvariants() const;\n\n                    const uint16_t* cached_data_ = nullptr;\n                };\n\n                /**\n                * An ExternalOneByteStringResource is a wrapper around an one-byte\n                * string buffer that resides outside V8's heap. Implement an\n                * ExternalOneByteStringResource to manage the life cycle of the\n                * underlying buffer.  Note that the string data must be immutable\n                * and that the data must be Latin-1 and not UTF-8, which would require\n                * special treatment internally in the engine and do not allow efficient\n                * indexing.  Use String::New or convert to 16 bit data for non-Latin1.\n                */\n\n                class V8_EXPORT ExternalOneByteStringResource\n                    : public ExternalStringResourceBase {\n                public:\n                    /**\n                     * Override the destructor to manage the life cycle of the underlying\n                     * buffer.\n                     */\n                    ~ExternalOneByteStringResource() override = default;\n\n                    /**\n                     * The string data from the underlying buffer. If the resource is cacheable\n                     * then data() must return the same value for all invocations.\n                     */\n                    virtual const char* data() const = 0;\n\n                    /** The number of Latin-1 characters in the string.*/\n                    virtual size_t length() const = 0;\n\n                    /**\n                     * Returns the cached data from the underlying buffer. If the resource is\n                     * uncacheable or if UpdateDataCache() was not called before, it has\n                     * undefined behaviour.\n                     */\n                    const char* cached_data() const {\n                    CheckCachedDataInvariants();\n                    return cached_data_;\n                    }\n\n                    /**\n                     * Update {cached_data_} with the data from the underlying buffer. This can\n                     * be called only for cacheable resources.\n                     */\n                    void UpdateDataCache();\n\n                protected:\n                    ExternalOneByteStringResource() = default;\n\n                private:\n                    void CheckCachedDataInvariants() const;\n\n                    const char* cached_data_ = nullptr;\n                };\n\n                /**\n                * If the string is an external string, return the ExternalStringResourceBase\n                * regardless of the encoding, otherwise return NULL.  The encoding of the\n                * string is returned in encoding_out.\n                */\n                V8_INLINE ExternalStringResourceBase* GetExternalStringResourceBase(\n                    v8::Isolate* isolate, Encoding* encoding_out) const;\n                V8_INLINE ExternalStringResourceBase* GetExternalStringResourceBase(\n                    Encoding* encoding_out) const;\n\n                /**\n                * Get the ExternalStringResource for an external string.  Returns\n                * NULL if IsExternal() doesn't return true.\n                */\n                V8_INLINE ExternalStringResource* GetExternalStringResource() const;\n\n                /**\n                * Get the ExternalOneByteStringResource for an external one-byte string.\n                * Returns NULL if IsExternalOneByte() doesn't return true.\n                */\n                const ExternalOneByteStringResource* GetExternalOneByteStringResource() const;\n\n                V8_INLINE static String* Cast(v8::Data* data) {\n            #ifdef V8_ENABLE_CHECKS\n                CheckCast(data);\n            #endif\n                return static_cast<String*>(data);\n                }\n\n                /**\n                * Allocates a new string from a UTF-8 literal. This is equivalent to calling\n                * String::NewFromUtf(isolate, \"...\").ToLocalChecked(), but without the check\n                * overhead.\n                *\n                * When called on a string literal containing '\\0', the inferred length is the\n                * length of the input array minus 1 (for the final '\\0') and not the value\n                * returned by strlen.\n                **/\n                template <int N>\n                static V8_WARN_UNUSED_RESULT Local<String> NewFromUtf8Literal(\n                    Isolate* isolate, const char (&literal)[N],\n                    NewStringType type = NewStringType::kNormal) {\n                    static_assert(N <= kMaxLength, \"String is too long\");\n                    return NewFromUtf8Literal(isolate, literal, type, N - 1);\n                }\n\n                /** Allocates a new string from UTF-8 data. Only returns an empty value when\n                 * length > kMaxLength. **/\n                static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromUtf8(\n                    Isolate* isolate, const char* data,\n                    NewStringType type = NewStringType::kNormal, int length = -1);\n\n                /** Allocates a new string from Latin-1 data.  Only returns an empty value\n                 * when length > kMaxLength. **/\n                static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromOneByte(\n                    Isolate* isolate, const uint8_t* data,\n                    NewStringType type = NewStringType::kNormal, int length = -1);\n\n                /** Allocates a new string from UTF-16 data. Only returns an empty value when\n                 * length > kMaxLength. **/\n                static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromTwoByte(\n                    Isolate* isolate, const uint16_t* data,\n                    NewStringType type = NewStringType::kNormal, int length = -1);\n\n                /**\n                * Creates a new string by concatenating the left and the right strings\n                * passed in as parameters.\n                */\n                static Local<String> Concat(Isolate* isolate, Local<String> left,\n                                            Local<String> right);\n\n                /**\n                * Creates a new external string using the data defined in the given\n                * resource. When the external string is no longer live on V8's heap the\n                * resource will be disposed by calling its Dispose method. The caller of\n                * this function should not otherwise delete or modify the resource. Neither\n                * should the underlying buffer be deallocated or modified except through the\n                * destructor of the external string resource.\n                */\n                static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewExternalTwoByte(\n                    Isolate* isolate, ExternalStringResource* resource);\n\n                /**\n                * Associate an external string resource with this string by transforming it\n                * in place so that existing references to this string in the JavaScript heap\n                * will use the external string resource. The external string resource's\n                * character contents need to be equivalent to this string.\n                * Returns true if the string has been changed to be an external string.\n                * The string is not modified if the operation fails. See NewExternal for\n                * information on the lifetime of the resource.\n                */\n                V8_DEPRECATE_SOON(\"Use the version with the isolate argument instead.\")\n                bool MakeExternal(ExternalStringResource* resource);\n\n                /**\n                * Associate an external string resource with this string by transforming it\n                * in place so that existing references to this string in the JavaScript heap\n                * will use the external string resource. The external string resource's\n                * character contents need to be equivalent to this string.\n                * Returns true if the string has been changed to be an external string.\n                * The string is not modified if the operation fails. See NewExternal for\n                * information on the lifetime of the resource.\n                */\n                bool MakeExternal(Isolate* isolate, ExternalStringResource* resource);\n\n                /**\n                * Creates a new external string using the one-byte data defined in the given\n                * resource. When the external string is no longer live on V8's heap the\n                * resource will be disposed by calling its Dispose method. The caller of\n                * this function should not otherwise delete or modify the resource. Neither\n                * should the underlying buffer be deallocated or modified except through the\n                * destructor of the external string resource.\n                */\n                static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewExternalOneByte(\n                    Isolate* isolate, ExternalOneByteStringResource* resource);\n\n                /**\n                * Associate an external string resource with this string by transforming it\n                * in place so that existing references to this string in the JavaScript heap\n                * will use the external string resource. The external string resource's\n                * character contents need to be equivalent to this string.\n                * Returns true if the string has been changed to be an external string.\n                * The string is not modified if the operation fails. See NewExternal for\n                * information on the lifetime of the resource.\n                */\n                V8_DEPRECATE_SOON(\"Use the version with the isolate argument instead.\")\n                bool MakeExternal(ExternalOneByteStringResource* resource);\n\n                /**\n                * Associate an external string resource with this string by transforming it\n                * in place so that existing references to this string in the JavaScript heap\n                * will use the external string resource. The external string resource's\n                * character contents need to be equivalent to this string.\n                * Returns true if the string has been changed to be an external string.\n                * The string is not modified if the operation fails. See NewExternal for\n                * information on the lifetime of the resource.\n                */\n                bool MakeExternal(Isolate* isolate, ExternalOneByteStringResource* resource);\n\n                /**\n                * Returns true if this string can be made external, given the encoding for\n                * the external string resource.\n                */\n                bool CanMakeExternal(Encoding encoding) const;\n\n                /**\n                * Returns true if the strings values are equal. Same as JS ==/===.\n                */\n                bool StringEquals(Local<String> str) const;\n\n                /**\n                * Converts an object to a UTF-8-encoded character array.  Useful if\n                * you want to print the object.  If conversion to a string fails\n                * (e.g. due to an exception in the toString() method of the object)\n                * then the length() method returns 0 and the * operator returns\n                * NULL.\n                *\n                * WARNING: This will unconditionally copy the contents of the JavaScript\n                * string, and should be avoided in situations where performance is a concern.\n                * Consider using WriteUtf8() instead.\n                */\n                class V8_EXPORT Utf8Value {\n                public:\n                    Utf8Value(Isolate* isolate, Local<v8::Value> obj,\n                                WriteOptions options = REPLACE_INVALID_UTF8);\n                    ~Utf8Value();\n                    char* operator*() { return str_; }\n                    const char* operator*() const { return str_; }\n                    size_t length() const { return length_; }\n\n                    // Disallow copying and assigning.\n                    Utf8Value(const Utf8Value&) = delete;\n                    void operator=(const Utf8Value&) = delete;\n\n                private:\n                    char* str_;\n                    size_t length_;\n                };\n\n                /**\n                * Converts an object to a two-byte (UTF-16-encoded) string.\n                *\n                * If conversion to a string fails (eg. due to an exception in the toString()\n                * method of the object) then the length() method returns 0 and the * operator\n                * returns NULL.\n                *\n                * WARNING: This will unconditionally copy the contents of the JavaScript\n                * string, and should be avoided in situations where performance is a concern.\n                */\n                class V8_EXPORT Value {\n                public:\n                    V8_DEPRECATE_SOON(\n                        \"Prefer using String::ValueView if you can, or string->Write to a \"\n                        \"buffer if you cannot.\")\n                    Value(Isolate* isolate, Local<v8::Value> obj);\n                    ~Value();\n                    uint16_t* operator*() { return str_; }\n                    const uint16_t* operator*() const { return str_; }\n                    uint32_t length() const { return length_; }\n\n                    // Disallow copying and assigning.\n                    Value(const Value&) = delete;\n                    void operator=(const Value&) = delete;\n\n                private:\n                    uint16_t* str_;\n                    uint32_t length_;\n                };\n\n                /**\n                * Returns a view onto a string's contents.\n                *\n                * WARNING: This does not copy the string's contents, and will therefore be\n                * invalidated if the GC can move the string while the ValueView is alive. It\n                * is therefore required that no GC or allocation can happen while there is an\n                * active ValueView. This requirement may be relaxed in the future.\n                *\n                * V8 strings are either encoded as one-byte or two-bytes per character.\n                */\n                class V8_EXPORT ValueView {\n                public:\n                    ValueView(Isolate* isolate, Local<v8::String> str);\n                    ~ValueView();\n                    const uint8_t* data8() const {\n            #if V8_ENABLE_CHECKS\n                    CheckOneByte(true);\n            #endif\n                    return data8_;\n                    }\n                    const uint16_t* data16() const {\n            #if V8_ENABLE_CHECKS\n                    CheckOneByte(false);\n            #endif\n                    return data16_;\n                    }\n                    uint32_t length() const { return length_; }\n                    bool is_one_byte() const { return is_one_byte_; }\n\n                    // Disallow copying and assigning.\n                    ValueView(const ValueView&) = delete;\n                    void operator=(const ValueView&) = delete;\n\n                private:\n                    void CheckOneByte(bool is_one_byte) const;\n\n                    Local<v8::String> flat_str_;\n                    union {\n                    const uint8_t* data8_;\n                    const uint16_t* data16_;\n                    };\n                    uint32_t length_;\n                    bool is_one_byte_;\n                    // Avoid exposing the internal DisallowGarbageCollection scope.\n                    alignas(internal::Internals::\n                                kDisallowGarbageCollectionAlign) char no_gc_debug_scope_\n                        [internal::Internals::kDisallowGarbageCollectionSize];\n                };\n\n            private:\n                void VerifyExternalStringResourceBase(ExternalStringResourceBase* v,\n                                                        Encoding encoding) const;\n                void VerifyExternalStringResource(ExternalStringResource* val) const;\n                ExternalStringResource* GetExternalStringResourceSlow() const;\n                ExternalStringResourceBase* GetExternalStringResourceBaseSlow(\n                    String::Encoding* encoding_out) const;\n\n                static Local<v8::String> NewFromUtf8Literal(Isolate* isolate,\n                                                        const char* literal,\n                                                        NewStringType type, int length);\n\n                static void CheckCast(v8::Data* that);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ExternalStringResourceBase\",\n            \"about\": \"Base class for managing external string resources (strings stored outside V8's heap).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"internal::ExternalString\",\n                \"internal::StringForwardingTable\",\n                \"internal::ScopedExternalStringLock\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT String::ExternalStringResourceBase {\n            public:\n                virtual ~ExternalStringResourceBase() = default;\n\n                /**\n                 * If a string is cacheable, the value returned by\n                 * ExternalStringResource::data() may be cached, otherwise it is not\n                 * expected to be stable beyond the current top-level task.\n                 */\n                virtual bool IsCacheable() const { return true; }\n\n                /**\n                 * Internally V8 will call this Unaccount method when the external string\n                 * resource should be unaccounted for. This method can be overridden in\n                 * subclasses to control how allocated external bytes are accounted.\n                 */\n                virtual void Unaccount(Isolate* isolate) {}\n\n                /**\n                 * Returns an estimate of the memory occupied by this external string, to be\n                 * used by V8 when producing a heap snapshot. If this function returns\n                 * kDefaultMemoryEstimate"
}