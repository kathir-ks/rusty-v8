{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/control-path-state.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 508, column 59",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/control-path-state.h\",\n            \"file_name\": \"control-path-state.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines classes for tracking control path state during compilation, used for advanced compiler optimizations.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary header files for functional lists, graph reduction, node auxiliary data, node properties, graph nodes, persistent maps, turbofan graphs, and memory zones.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/functional-list.h\"\n#include \"src/compiler/graph-reducer.h\"\n#include \"src/compiler/node-aux-data.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/persistent-map.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"NodeUniqueness\",\n                \"about\": \"Defines whether node instances are unique or multiple instances can exist.\",\n                \"values\": [\n                    \"kUniqueInstance\",\n                    \"kMultipleInstances\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nenum NodeUniqueness { kUniqueInstance, kMultipleInstances };\n        ]]></code>\n    </enum>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ControlPathState\",\n                \"about\": \"Tracks information about the control path state, represented as a linked list of NodeState blocks.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"NodeState\",\n                    \"FunctionalList\",\n                    \"PersistentMap\",\n                    \"Node\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nclass ControlPathState {\n public:\n  static_assert(\n      std::is_member_function_pointer<decltype(&NodeState::IsSet)>::value,\n      \"{NodeState} needs an {IsSet} method\");\n  static_assert(\n      std::is_member_object_pointer<decltype(&NodeState::node)>::value,\n      \"{NodeState} needs to hold a pointer to the {Node*} owner of the state\");\n\n  explicit ControlPathState(Zone* zone) : states_(zone) {}\n\n  // Returns the {NodeState} assigned to node, or the default value\n  // {NodeState()} if it is not assigned.\n  NodeState LookupState(Node* node) const;\n\n  // Adds a state in the current code block, or a new block if the block list is\n  // empty.\n  void AddState(Zone* zone, Node* node, NodeState state, ControlPathState hint);\n\n  // Adds a state in a new block.\n  void AddStateInNewBlock(Zone* zone, Node* node, NodeState state);\n\n  // Reset this {ControlPathState} to its longest prefix that is common with\n  // {other}.\n  void ResetToCommonAncestor(ControlPathState other);\n\n  bool IsEmpty() { return blocks_.Size() == 0; }\n\n  bool operator==(const ControlPathState& other) const {\n    return blocks_ == other.blocks_;\n  }\n  bool operator!=(const ControlPathState& other) const {\n    return blocks_ != other.blocks_;\n  }\n\n private:\n  using NodeWithPathDepth = std::pair<Node*, size_t>;\n\n  size_t depth(size_t depth_if_multiple_instances) {\n    return node_uniqueness == kMultipleInstances ? depth_if_multiple_instances\n                                                 : 0;\n  }\n\n#if DEBUG\n  bool BlocksAndStatesInvariant();\n#endif\n\n  FunctionalList<FunctionalList<NodeState>> blocks_;\n  // This is an auxilliary data structure that provides fast lookups in the\n  // set of states. It should hold at any point that the contents of {blocks_}\n  // and {states_} is the same, which is implemented in\n  // {BlocksAndStatesInvariant}.\n  PersistentMap<NodeWithPathDepth, NodeState> states_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AdvancedReducerWithControlPathState\",\n                \"extends\": \"AdvancedReducer\",\n                \"about\": \"An advanced reducer that utilizes ControlPathState to perform reductions based on control flow information.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"Editor\",\n                    \"Zone\",\n                    \"TFGraph\",\n                    \"NodeAuxData\",\n                    \"ControlPathState\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nclass AdvancedReducerWithControlPathState : public AdvancedReducer {\n protected:\n  AdvancedReducerWithControlPathState(Editor* editor, Zone* zone,\n                                      TFGraph* graph)\n      : AdvancedReducer(editor),\n        zone_(zone),\n        node_states_(graph->NodeCount(), zone),\n        reduced_(graph->NodeCount(), zone) {}\n  Reduction TakeStatesFromFirstControl(Node* node);\n  // Update the state of {state_owner} to {new_state}.\n  Reduction UpdateStates(\n      Node* state_owner,\n      ControlPathState<NodeState, node_uniqueness> new_state);\n  // Update the state of {state_owner} to {prev_states}, plus {additional_state}\n  // assigned to {additional_node}. Force the new state in a new block if\n  // {in_new_block}.\n  Reduction UpdateStates(\n      Node* state_owner,\n      ControlPathState<NodeState, node_uniqueness> prev_states,\n      Node* additional_node, NodeState additional_state, bool in_new_block);\n  Zone* zone() { return zone_; }\n  ControlPathState<NodeState, node_uniqueness> GetState(Node* node) {\n    return node_states_.Get(node);\n  }\n  bool IsReduced(Node* node) { return reduced_.Get(node); }\n\n private:\n  Zone* zone_;\n  // Maps each control node to the node's current state.\n  // If the information is nullptr, then we have not calculated the information\n  // yet.\n  NodeAuxData<ControlPathState<NodeState, node_uniqueness>,\n              ZoneConstruct<ControlPathState<NodeState, node_uniqueness>>>\n      node_states_;\n  NodeAuxData<bool> reduced_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LookupState\",\n                \"parent\": \"ControlPathState\",\n                \"about\": \"Looks up the NodeState associated with a given node.\",\n                \"logic\": \"Iterates through the blocks to find the most recent NodeState for the given node.  If node_uniqueness is kUniqueInstance, it only checks the first block.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to look up the state for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"NodeState\",\n                    \"description\": \"The NodeState associated with the node, or a default NodeState if not found.\"\n                },\n                \"dependencies\": [\n                    \"NodeState\",\n                    \"Node\",\n                    \"PersistentMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nNodeState ControlPathState<NodeState, node_uniqueness>::LookupState(\n    Node* node) const {\n  if (node_uniqueness == kUniqueInstance) return states_.Get({node, 0});\n  for (size_t depth = blocks_.Size(); depth > 0; depth--) {\n    NodeState state = states_.Get({node, depth});\n    if (state.IsSet()) return state;\n  }\n  return {};\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddState\",\n                \"parent\": \"ControlPathState\",\n                \"about\": \"Adds a NodeState to the current code block.\",\n                \"logic\": \"Adds the given NodeState to the front of the current code block.  If node_uniqueness is kUniqueInstance and a state already exists for the node, it does nothing. It uses the provided hint to construct the new block list by pushing the new state to the front of the hint's front block.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to allocate from.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to associate the state with.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"NodeState\",\n                        \"purpose\": \"The NodeState to add.\"\n                    },\n                    {\n                        \"name\": \"hint\",\n                        \"type\": \"ControlPathState\",\n                        \"purpose\": \"Hint used to build the new block list.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NodeState\",\n                    \"Node\",\n                    \"FunctionalList\",\n                    \"PersistentMap\",\n                    \"ControlPathState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nvoid ControlPathState<NodeState, node_uniqueness>::AddState(\n    Zone* zone, Node* node, NodeState state,\n    ControlPathState<NodeState, node_uniqueness> hint) {\n  NodeState previous_state = LookupState(node);\n  if (node_uniqueness == kUniqueInstance ? previous_state.IsSet()\n                                         : previous_state == state) {\n    return;\n  }\n\n  FunctionalList<NodeState> prev_front = blocks_.Front();\n  if (hint.blocks_.Size() > 0) {\n    prev_front.PushFront(state, zone, hint.blocks_.Front());\n  } else {\n    prev_front.PushFront(state, zone);\n  }\n  blocks_.DropFront();\n  blocks_.PushFront(prev_front, zone);\n  states_.Set({node, depth(blocks_.Size())}, state);\n  SLOW_DCHECK(BlocksAndStatesInvariant());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddStateInNewBlock\",\n                \"parent\": \"ControlPathState\",\n                \"about\": \"Adds a NodeState to a new code block.\",\n                \"logic\": \"Creates a new code block and adds the given NodeState to it. If node_uniqueness is kUniqueInstance and a state already exists for the node, it does nothing.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to allocate from.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to associate the state with.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"NodeState\",\n                        \"purpose\": \"The NodeState to add.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NodeState\",\n                    \"Node\",\n                    \"FunctionalList\",\n                    \"PersistentMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nvoid ControlPathState<NodeState, node_uniqueness>::AddStateInNewBlock(\n    Zone* zone, Node* node, NodeState state) {\n  FunctionalList<NodeState> new_block;\n  NodeState previous_state = LookupState(node);\n  if (node_uniqueness == kUniqueInstance ? !previous_state.IsSet()\n                                         : previous_state != state) {\n    new_block.PushFront(state, zone);\n    states_.Set({node, depth(blocks_.Size() + 1)}, state);\n  }\n  blocks_.PushFront(new_block, zone);\n  SLOW_DCHECK(BlocksAndStatesInvariant());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ResetToCommonAncestor\",\n                \"parent\": \"ControlPathState\",\n                \"about\": \"Resets the ControlPathState to its longest common prefix with another ControlPathState.\",\n                \"logic\": \"Drops blocks from the front of both ControlPathStates until they have the same size. Then, drops blocks from the front until the remaining prefixes are equal.  Removes all states from the dropped blocks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"other\",\n                        \"type\": \"ControlPathState\",\n                        \"purpose\": \"The other ControlPathState to find the common ancestor with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NodeState\",\n                    \"Node\",\n                    \"FunctionalList\",\n                    \"PersistentMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nvoid ControlPathState<NodeState, node_uniqueness>::ResetToCommonAncestor(\n    ControlPathState<NodeState, node_uniqueness> other) {\n  while (other.blocks_.Size() > blocks_.Size()) other.blocks_.DropFront();\n  while (blocks_.Size() > other.blocks_.Size()) {\n    for (NodeState state : blocks_.Front()) {\n      states_.Set({state.node, depth(blocks_.Size())}, {});\n    }\n    blocks_.DropFront();\n  }\n  while (blocks_ != other.blocks_) {\n    for (NodeState state : blocks_.Front()) {\n      states_.Set({state.node, depth(blocks_.Size())}, {});\n    }\n    blocks_.DropFront();\n    other.blocks_.DropFront();\n  }\n  SLOW_DCHECK(BlocksAndStatesInvariant());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BlocksAndStatesInvariant\",\n                \"parent\": \"ControlPathState\",\n                \"about\": \"Debug method to check the consistency between blocks_ and states_.\",\n                \"logic\": \"Checks if every state in blocks_ is also present in states_ and vice versa. Used for debugging.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the invariant holds, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"NodeState\",\n                    \"Node\",\n                    \"FunctionalList\",\n                    \"PersistentMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if DEBUG\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nbool ControlPathState<NodeState, node_uniqueness>::BlocksAndStatesInvariant() {\n  PersistentMap<NodeWithPathDepth, NodeState> states_copy(states_);\n  size_t current_depth = blocks_.Size();\n  for (auto block : blocks_) {\n    std::unordered_set<Node*> seen_this_block;\n    for (NodeState state : block) {\n      // Every element of blocks_ has to be in states_.\n      if (seen_this_block.count(state.node) == 0) {\n        if (states_copy.Get({state.node, depth(current_depth)}) != state) {\n          return false;\n        }\n        states_copy.Set({state.node, depth(current_depth)}, {});\n        seen_this_block.emplace(state.node);\n      }\n    }\n    current_depth--;\n  }\n  // Every element of {states_} has to be in {blocks_}. We removed all\n  // elements of blocks_ from states_copy, so if it is not empty, the\n  // invariant fails.\n  return states_copy.begin() == states_copy.end();\n}\n#endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TakeStatesFromFirstControl\",\n                \"parent\": \"AdvancedReducerWithControlPathState\",\n                \"about\": \"Propagates control path state from the first control input of a node.\",\n                \"logic\": \"Retrieves the control path state from the first control input of the given node and updates the node's state with it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to propagate the state to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A reduction indicating whether the state was changed.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"NodeProperties\",\n                    \"ControlPathState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nReduction AdvancedReducerWithControlPathState<\n    NodeState, node_uniqueness>::TakeStatesFromFirstControl(Node* node) {\n  // We just propagate the information from the control input (ideally,\n  // we would only revisit control uses if there is change).\n  Node* input = NodeProperties::GetControlInput(node, 0);\n  if (!reduced_.Get(input)) return NoChange();\n  return UpdateStates(node, node_states_.Get(input));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"UpdateStates\",\n                \"parent\": \"AdvancedReducerWithControlPathState\",\n                \"about\": \"Updates the control path state of a node.\",\n                \"logic\": \"Sets the control path state of the given node and signals a change if the state has actually changed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"state_owner\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node whose state is being updated.\"\n                    },\n                    {\n                        \"name\": \"new_state\",\n                        \"type\": \"ControlPathState<NodeState, node_uniqueness>\",\n                        \"purpose\": \"The new control path state.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A reduction indicating whether the state was changed.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"ControlPathState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nReduction\nAdvancedReducerWithControlPathState<NodeState, node_uniqueness>::UpdateStates(\n    Node* state_owner, ControlPathState<NodeState, node_uniqueness> new_state) {\n  // Only signal that the node has {Changed} if its state has changed.\n  bool reduced_changed = reduced_.Set(state_owner, true);\n  bool node_states_changed = node_states_.Set(state_owner, new_state);\n  if (reduced_changed || node_states_changed) {\n    return Changed(state_owner);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"UpdateStates\",\n                \"parent\": \"AdvancedReducerWithControlPathState\",\n                \"about\": \"Updates the control path state of a node, adding an additional state.\",\n                \"logic\": \"Updates the control path state of the given node, adding an additional state.  Can create a new block depending on in_new_block parameter.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"state_owner\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node whose state is being updated.\"\n                    },\n                    {\n                        \"name\": \"prev_states\",\n                        \"type\": \"ControlPathState<NodeState, node_uniqueness>\",\n                        \"purpose\": \"The previous control path state.\"\n                    },\n                    {\n                        \"name\": \"additional_node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node for the additional state.\"\n                    },\n                    {\n                        \"name\": \"additional_state\",\n                        \"type\": \"NodeState\",\n                        \"purpose\": \"The additional state.\"\n                    },\n                    {\n                        \"name\": \"in_new_block\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Whether to add the state in a new block.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A reduction indicating whether the state was changed.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"ControlPathState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodeState, NodeUniqueness node_uniqueness>\nReduction\nAdvancedReducerWithControlPathState<NodeState, node_uniqueness>::UpdateStates(\n    Node* state_owner, ControlPathState<NodeState, node_uniqueness> prev_states,\n    Node* additional_node, NodeState additional_state, bool in_new_block) {\n  if (in_new_block || prev_states.IsEmpty()) {\n    prev_states.AddStateInNewBlock(zone_, additional_node, additional_state);\n  } else {\n    ControlPathState<NodeState, node_uniqueness> original =\n        node_states_.Get(state_owner);\n    prev_states.AddState(zone_, additional_node, additional_state, original);\n  }\n  return UpdateStates(state_owner, prev_states);\n}\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"AdvancedReducer\",\n                    \"about\": \"Base class for advanced reducers in the Turbofan compiler.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class AdvancedReducer {\n                public:\n                    AdvancedReducer(Editor* editor) : editor_(editor) {}\n                protected:\n                    Editor* editor() { return editor_; }\n                    Reduction Changed(Node* node) { return Reduction::Changed(node); }\n                    Reduction NoChange() { return Reduction::NoChange(); }\n                private:\n                    Editor* editor_;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Editor\",\n                    \"about\": \"Provides editing capabilities for the graph during reduction.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Editor {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Reduction\",\n                    \"about\": \"Represents the result of a reduction step.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Reduction {\n                public:\n                    static Reduction Changed(Node* node) { return Reduction(); }\n                    static Reduction NoChange() { return Reduction(); }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Zone\",\n                    \"about\": \"Memory allocation zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Zone {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Node\",\n                    \"about\": \"Represents a node in the Turbofan graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Node {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TFGraph\",\n                    \"about\": \"Represents the Turbofan graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class TFGraph {\n                public:\n                    size_t NodeCount() { return 0; }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NodeAuxData\",\n                    \"about\": \"Auxiliary data associated with a node.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename T, typename Allocator>\n                class NodeAuxData {\n                public:\n                    NodeAuxData(size_t node_count, Zone* zone) {}\n                    T Get(Node* node) { return T(); }\n                    bool Set(Node* node, T value) { return false; }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ZoneConstruct\",\n                    \"about\": \"Used for constructing objects in a Zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class ZoneConstruct {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"FunctionalList\",\n                    \"about\": \"A persistent functional list.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class FunctionalList {\n                public:\n                    FunctionalList() {}\n                    FunctionalList(const FunctionalList& other) {}\n                    FunctionalList& operator=(const FunctionalList& other) { return *this; }\n                    void PushFront(T value, Zone* zone) {}\n                    void PushFront(T value, Zone* zone, const FunctionalList& hint) {}\n                    void DropFront() {}\n                    T Front() { return T(); }\n                    size_t Size() const { return 0; }\n                    bool operator==(const FunctionalList& other) const { return true; }\n                    bool operator!=(const FunctionalList& other) const { return false; }\n                    class iterator {\n                    public:\n                        T operator*() { return T(); }\n                        iterator& operator++() { return *this; }\n                        bool operator!=(const iterator& other) { return false; }\n                    };\n                    iterator begin() const { return iterator(); }\n                    iterator end() const { return iterator(); }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"PersistentMap\",\n                    \"about\": \"A persistent map.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename K, typename V>\n                class PersistentMap {\n                public:\n                    PersistentMap(Zone* zone) {}\n                    PersistentMap(const PersistentMap& other) {}\n                    V Get(K key) const { return V(); }\n                    void Set(K key, V value) {}\n                    class iterator {\n                    public:\n                        bool operator==(const iterator& other) { return true; }\n                        bool operator!=(const iterator& other) { return false; }\n                    };\n                    iterator begin() const { return iterator(); }\n                    iterator end() const { return iterator(); }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NodeProperties\",\n                    \"about\": \"Provides properties of a node.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class NodeProperties {\n                public:\n                    static Node* GetControlInput(Node* node, int index) { return nullptr; }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"NodeState\",\n                    \"about\": \"Represents the state of a node.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class NodeState {\n                public:\n                    bool IsSet() const { return false; }\n                    Node* node;\n                    bool operator==(const NodeState& other) const { return true; }\n                    bool operator!=(const NodeState& other) const { return false; }\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}