{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-chunk-list.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-chunk-list.h\",\n            \"file_name\": \"zone-chunk-list.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the ZoneChunkList class, a zone-backed hybrid of a vector and a linked list.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for standard library functionalities, base utilities, common globals, memory operations, and zone management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <algorithm>\n\n            #include \"src/base/iterator.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/utils/memcopy.h\"\n            #include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ZoneChunkList\",\n                \"extends\": \"ZoneObject\",\n                \"about\": \"A zone-backed hybrid of a vector and a linked list for efficient memory management and iteration within a Zone.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Zone this list belongs to.\"\n                    },\n                    {\n                        \"name\": \"size_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The number of elements in the list.\"\n                    },\n                    {\n                        \"name\": \"front_\",\n                        \"type\": \"Chunk*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the first chunk in the list.\"\n                    },\n                    {\n                        \"name\": \"last_nonempty_\",\n                        \"type\": \"Chunk*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the last chunk that contains at least one element.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneObject\",\n                    \"Zone\",\n                    \"ZoneChunkListIterator\",\n                    \"std::swap\",\n                    \"std::conditional\",\n                    \"std::add_const\",\n                    \"base::iterator\",\n                    \"std::bidirectional_iterator_tag\",\n                    \"base::bits::UnsignedAddOverflow32\",\n                    \"base::bits::RoundUpToPowerOfTwo32\",\n                    \"MemCopy\",\n                    \"MOVE_ONLY_NO_DEFAULT_CONSTRUCTOR\",\n                    \"DCHECK\",\n                    \"DCHECK_NULL\",\n                    \"DCHECK_EQ\",\n                    \"DCHECK_NOT_NULL\",\n                    \"DCHECK_LE\",\n                    \"DCHECK_LT\",\n                    \"CHECK\",\n                    \"V8_ASSUME\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class ZoneChunkList : public ZoneObject {\n            public:\n            using iterator = ZoneChunkListIterator<T, false, true>;\n            using const_iterator = ZoneChunkListIterator<T, false, false>;\n            using reverse_iterator = ZoneChunkListIterator<T, true, true>;\n            using const_reverse_iterator = ZoneChunkListIterator<T, true, false>;\n\n            static constexpr uint32_t kInitialChunkCapacity = 8;\n            static constexpr uint32_t kMaxChunkCapacity = 256;\n\n            explicit ZoneChunkList(Zone* zone) : zone_(zone) {}\n\n            MOVE_ONLY_NO_DEFAULT_CONSTRUCTOR(ZoneChunkList);\n\n            size_t size() const { return size_; }\n            bool empty() const { return size() == 0; }\n\n            T& front();\n            const T& front() const;\n            T& back();\n            const T& back() const;\n\n            void push_back(const T& item);\n\n            // If the first chunk has space, inserts into it at the front. Otherwise\n            // allocate a new chunk with the same growth strategy as `push_back`.\n            // This limits the amount of copying to O(`kMaxChunkCapacity`).\n            void push_front(const T& item);\n\n            // Cuts the last list elements so at most 'limit' many remain. Does not\n            // free the actual memory, since it is zone allocated.\n            void Rewind(const size_t limit = 0);\n\n            // Quickly scans the list to retrieve the element at the given index. Will\n            // *not* check bounds.\n            iterator Find(const size_t index);\n            const_iterator Find(const size_t index) const;\n            // TODO(heimbuef): Add 'rFind', seeking from the end and returning a\n            // reverse iterator.\n\n            // Splits off a new list that contains the elements from `split_begin` to\n            // `end()`. The current list is truncated to end just before `split_begin`.\n            // This naturally invalidates all iterators, including `split_begin`.\n            ZoneChunkList<T> SplitAt(iterator split_begin);\n            void Append(ZoneChunkList<T>& other);\n\n            void CopyTo(T* ptr);\n\n            iterator begin() { return iterator::Begin(this); }\n            iterator end() { return iterator::End(this); }\n            reverse_iterator rbegin() { return reverse_iterator::Begin(this); }\n            reverse_iterator rend() { return reverse_iterator::End(this); }\n            const_iterator begin() const { return const_iterator::Begin(this); }\n            const_iterator end() const { return const_iterator::End(this); }\n            const_reverse_iterator rbegin() const {\n                return const_reverse_iterator::Begin(this);\n            }\n            const_reverse_iterator rend() const {\n                return const_reverse_iterator::End(this);\n            }\n\n            void swap(ZoneChunkList<T>& other) {\n                DCHECK_EQ(zone_, other.zone_);\n                std::swap(size_, other.size_);\n                std::swap(front_, other.front_);\n                std::swap(last_nonempty_, other.last_nonempty_);\n            }\n\n            private:\n            template <typename S, bool backwards, bool modifiable>\n            friend class ZoneChunkListIterator;\n\n            struct Chunk {\n                uint32_t capacity_ = 0;\n                uint32_t position_ = 0;\n                Chunk* next_ = nullptr;\n                Chunk* previous_ = nullptr;\n                T* items() { return reinterpret_cast<T*>(this + 1); }\n                const T* items() const { return reinterpret_cast<const T*>(this + 1); }\n                uint32_t size() const {\n                    DCHECK_LE(position_, capacity_);\n                    return position_;\n                }\n                bool empty() const { return size() == 0; }\n                bool full() const { return size() == capacity_; }\n            };\n\n            Chunk* NewChunk(const uint32_t capacity) {\n                void* memory = zone_->Allocate<Chunk>(sizeof(Chunk) + capacity * sizeof(T));\n                Chunk* chunk = new (memory) Chunk();\n                chunk->capacity_ = capacity;\n                return chunk;\n            }\n\n            static uint32_t NextChunkCapacity(uint32_t previous_capacity) {\n                return std::min(previous_capacity * 2, kMaxChunkCapacity);\n            }\n\n            struct SeekResult {\n                Chunk* chunk_;\n                uint32_t chunk_index_;\n            };\n\n            // Returns the chunk and relative index of the element at the given global\n            // index. Will skip entire chunks and is therefore faster than iterating.\n            SeekResult SeekIndex(size_t index) const;\n\n            #ifdef DEBUG\n            // Check the invariants.\n            void Verify() const {\n                if (front_ == nullptr) {\n                // Initial empty state.\n                DCHECK_NULL(last_nonempty_);\n                DCHECK_EQ(0, size());\n                } else if (empty()) {\n                // Special case: Fully rewound list, with only empty chunks.\n                DCHECK_EQ(front_, last_nonempty_);\n                DCHECK_EQ(0, size());\n                for (Chunk* chunk = front_; chunk != nullptr; chunk = chunk->next_) {\n                    DCHECK(chunk->empty());\n                }\n                } else {\n                // Normal state: Somewhat filled and (partially) rewound.\n                DCHECK_NOT_NULL(last_nonempty_);\n\n                size_t size_check = 0;\n                bool in_empty_tail = false;\n                for (Chunk* chunk = front_; chunk != nullptr; chunk = chunk->next_) {\n                    // Chunks from `front_` to `last_nonempty_` (inclusive) are non-empty.\n                    DCHECK_EQ(in_empty_tail, chunk->empty());\n                    size_check += chunk->size();\n\n                    if (chunk == last_nonempty_) {\n                    in_empty_tail = true;\n                    }\n                }\n                DCHECK_EQ(size_check, size());\n                }\n            }\n            #endif\n\n            Zone* zone_;\n\n            size_t size_ = 0;\n            Chunk* front_ = nullptr;\n            Chunk* last_nonempty_ = nullptr;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ZoneChunkListIterator\",\n                \"about\": \"Iterator for the ZoneChunkList, providing bidirectional traversal and access to elements within the list's chunks.\",\n                \"dependencies\": [\n                    \"base::iterator\",\n                    \"std::bidirectional_iterator_tag\",\n                    \"ZoneChunkList\",\n                    \"std::conditional\",\n                    \"std::add_const\",\n                    \"base::bits::UnsignedAddOverflow32\",\n                    \"DCHECK\",\n                    \"CHECK\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, bool backwards, bool modifiable>\n            class ZoneChunkListIterator\n                : public base::iterator<std::bidirectional_iterator_tag, T> {\n            private:\n            template <typename S>\n            using maybe_const =\n                typename std::conditional<modifiable, S,\n                                        typename std::add_const<S>::type>::type;\n            using Chunk = maybe_const<typename ZoneChunkList<T>::Chunk>;\n            using ChunkList = maybe_const<ZoneChunkList<T>>;\n\n            public:\n            maybe_const<T>& operator*() const { return current_->items()[position_]; }\n            maybe_const<T>* operator->() const { return &current_->items()[position_]; }\n            bool operator==(const ZoneChunkListIterator& other) const {\n                return other.current_ == current_ && other.position_ == position_;\n            }\n            bool operator!=(const ZoneChunkListIterator& other) const {\n                return !operator==(other);\n            }\n\n            ZoneChunkListIterator& operator++() {\n                Move<backwards>();\n                return *this;\n            }\n\n            ZoneChunkListIterator operator++(int) {\n                ZoneChunkListIterator clone(*this);\n                Move<backwards>();\n                return clone;\n            }\n\n            ZoneChunkListIterator& operator--() {\n                Move<!backwards>();\n                return *this;\n            }\n\n            ZoneChunkListIterator operator--(int) {\n                ZoneChunkListIterator clone(*this);\n                Move<!backwards>();\n                return clone;\n            }\n\n            void Advance(uint32_t amount) {\n                static_assert(!backwards, \"Advance only works on forward iterators\");\n\n            #ifdef DEBUG\n                ZoneChunkListIterator clone(*this);\n                for (uint32_t i = 0; i < amount; ++i) {\n                ++clone;\n                }\n            #endif\n\n                CHECK(!base::bits::UnsignedAddOverflow32(position_, amount, &position_));\n                while (position_ > 0 && position_ >= current_->position_) {\n                auto overshoot = position_ - current_->position_;\n                current_ = current_->next_;\n                position_ = overshoot;\n\n                DCHECK(position_ == 0 || current_);\n                }\n\n            #ifdef DEBUG\n                DCHECK_EQ(clone, *this);\n            #endif\n            }\n\n            private:\n            friend class ZoneChunkList<T>;\n\n            static ZoneChunkListIterator Begin(ChunkList* list) {\n                // Forward iterator:\n                if (!backwards) return ZoneChunkListIterator(list->front_, 0);\n\n                // Backward iterator:\n                if (list->empty()) return End(list);\n\n                DCHECK(!list->last_nonempty_->empty());\n                return ZoneChunkListIterator(list->last_nonempty_,\n                                            list->last_nonempty_->position_ - 1);\n            }\n\n            static ZoneChunkListIterator End(ChunkList* list) {\n                // Backward iterator:\n                if (backwards) return ZoneChunkListIterator(nullptr, 0);\n\n                // Forward iterator:\n                if (list->empty()) return Begin(list);\n\n                // NOTE: Decrementing `end()` is not supported if `last_nonempty_->next_`\n                // is nullptr (in that case `Move` will crash on dereference).\n                return ZoneChunkListIterator(list->last_nonempty_->next_, 0);\n            }\n\n            ZoneChunkListIterator(Chunk* current, uint32_t position)\n                : current_(current), position_(position) {\n                DCHECK(current == nullptr || position < current->capacity_);\n            }\n\n            template <bool move_backward>\n            void Move() {\n                if (move_backward) {\n                // Move backwards.\n                if (position_ == 0) {\n                    current_ = current_->previous_;\n                    position_ = current_ ? current_->position_ - 1 : 0;\n                } else {\n                    --position_;\n                }\n                } else {\n                // Move forwards.\n                ++position_;\n                if (position_ >= current_->position_) {\n                    current_ = current_->next_;\n                    position_ = 0;\n                }\n                }\n            }\n\n            Chunk* current_;\n            uint32_t position_;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"front\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Returns a reference to the first element in the ZoneChunkList.\",\n                \"logic\": \"Asserts that the list is not empty and then returns the first element using the begin() iterator.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"T&\",\n                    \"description\": \"A reference to the first element.\"\n                },\n                \"dependencies\": [\n                    \"begin\",\n                    \"empty\",\n                    \"DCHECK\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            T& ZoneChunkList<T>::front() {\n            DCHECK(!empty());\n            return *begin();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"front\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Returns a const reference to the first element in the ZoneChunkList.\",\n                \"logic\": \"Asserts that the list is not empty and then returns the first element using the begin() const iterator.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"const T&\",\n                    \"description\": \"A const reference to the first element.\"\n                },\n                \"dependencies\": [\n                    \"begin\",\n                    \"empty\",\n                    \"DCHECK\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            const T& ZoneChunkList<T>::front() const {\n            DCHECK(!empty());\n            return *begin();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"back\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Returns a reference to the last element in the ZoneChunkList.\",\n                \"logic\": \"Asserts that the list is not empty and then returns the last element using the rbegin() iterator. V8_ASSUME is used for optimization.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"T&\",\n                    \"description\": \"A reference to the last element.\"\n                },\n                \"dependencies\": [\n                    \"rbegin\",\n                    \"empty\",\n                    \"DCHECK\",\n                    \"V8_ASSUME\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            T& ZoneChunkList<T>::back() {\n            DCHECK(!empty());\n            // Avoid the branch in `ZoneChunkListIterator::Begin()`.\n            V8_ASSUME(size_ != 0);\n            return *rbegin();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"back\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Returns a const reference to the last element in the ZoneChunkList.\",\n                \"logic\": \"Asserts that the list is not empty and then returns the last element using the rbegin() const iterator. V8_ASSUME is used for optimization.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"const T&\",\n                    \"description\": \"A const reference to the last element.\"\n                },\n                \"dependencies\": [\n                    \"rbegin\",\n                    \"empty\",\n                    \"DCHECK\",\n                    \"V8_ASSUME\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            const T& ZoneChunkList<T>::back() const {\n            DCHECK(!empty());\n            // Avoid the branch in `ZoneChunkListIterator::Begin()`.\n            V8_ASSUME(size_ != 0);\n            return *rbegin();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"push_back\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Appends an item to the back of the ZoneChunkList.\",\n                \"logic\": \"Adds a new item to the last non-empty chunk. If no chunk exists or the last chunk is full, a new chunk is allocated.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"item\",\n                        \"type\": \"const T&\",\n                        \"purpose\": \"The item to be appended.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NewChunk\",\n                    \"NextChunkCapacity\",\n                    \"DCHECK_LE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneChunkList<T>::push_back(const T& item) {\n            if (last_nonempty_ == nullptr) {\n                // Initially empty chunk list.\n                front_ = NewChunk(kInitialChunkCapacity);\n                last_nonempty_ = front_;\n            } else if (last_nonempty_->full()) {\n                // If there is an empty chunk following, reuse that, otherwise allocate.\n                if (last_nonempty_->next_ == nullptr) {\n                Chunk* chunk = NewChunk(NextChunkCapacity(last_nonempty_->capacity_));\n                last_nonempty_->next_ = chunk;\n                chunk->previous_ = last_nonempty_;\n                }\n                last_nonempty_ = last_nonempty_->next_;\n                DCHECK(!last_nonempty_->full());\n            }\n\n            last_nonempty_->items()[last_nonempty_->position_] = item;\n            ++last_nonempty_->position_;\n            ++size_;\n            DCHECK_LE(last_nonempty_->position_, last_nonempty_->capacity_);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"push_front\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Inserts an item at the front of the ZoneChunkList.\",\n                \"logic\": \"Adds a new item to the beginning of the first chunk. If the first chunk is full, a new chunk is allocated and prepended.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"item\",\n                        \"type\": \"const T&\",\n                        \"purpose\": \"The item to be inserted.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NewChunk\",\n                    \"NextChunkCapacity\",\n                    \"std::move_backward\",\n                    \"DCHECK_NULL\",\n                    \"DCHECK_LE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneChunkList<T>::push_front(const T& item) {\n            if (front_ == nullptr) {\n                // Initially empty chunk list.\n                front_ = NewChunk(kInitialChunkCapacity);\n                last_nonempty_ = front_;\n            } else if (front_->full()) {\n                // First chunk at capacity, so prepend a new chunk.\n                DCHECK_NULL(front_->previous_);\n                Chunk* chunk = NewChunk(NextChunkCapacity(front_->capacity_));\n                front_->previous_ = chunk;\n                chunk->next_ = front_;\n                front_ = chunk;\n            }\n            DCHECK(!front_->full());\n\n            T* end = front_->items() + front_->position_;\n            std::move_backward(front_->items(), end, end + 1);\n            front_->items()[0] = item;\n            ++front_->position_;\n            ++size_;\n            DCHECK_LE(front_->position_, front_->capacity_);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SeekIndex\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Finds the chunk and index for a given element index in the ZoneChunkList.\",\n                \"logic\": \"Iterates through the chunks to find the chunk containing the specified index.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the element to find.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"SeekResult\",\n                    \"description\": \"A struct containing the chunk and index.\"\n                },\n                \"dependencies\": [\n                    \"DCHECK_LT\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            typename ZoneChunkList<T>::SeekResult ZoneChunkList<T>::SeekIndex(\n                size_t index) const {\n            DCHECK_LT(index, size());\n            Chunk* current = front_;\n            while (index >= current->capacity_) {\n                index -= current->capacity_;\n                current = current->next_;\n            }\n            DCHECK_LT(index, current->capacity_);\n            return {current, static_cast<uint32_t>(index)};\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Rewind\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Rewinds the ZoneChunkList to a specified limit, effectively truncating the list.\",\n                \"logic\": \"Finds the chunk corresponding to the limit index, truncates it, and resets the position of subsequent chunks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"limit\",\n                        \"type\": \"const size_t\",\n                        \"purpose\": \"The new size of the list after rewinding.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"SeekIndex\",\n                    \"DCHECK_NOT_NULL\",\n                    \"Verify\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneChunkList<T>::Rewind(const size_t limit) {\n            if (limit >= size()) return;\n\n            SeekResult seek_result = SeekIndex(limit);\n            DCHECK_NOT_NULL(seek_result.chunk_);\n\n            // Do a partial rewind of the chunk containing the index.\n            seek_result.chunk_->position_ = seek_result.chunk_index_;\n\n            // Set last_nonempty_ so iterators will work correctly.\n            last_nonempty_ = seek_result.chunk_;\n\n            // Do full rewind of all subsequent chunks.\n            for (Chunk* current = seek_result.chunk_->next_; current != nullptr;\n                current = current->next_) {\n                current->position_ = 0;\n            }\n\n            size_ = limit;\n\n            #ifdef DEBUG\n            Verify();\n            #endif\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Find\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Finds an iterator pointing to the element at the given index.\",\n                \"logic\": \"Uses SeekIndex to find the chunk and chunk index, then constructs an iterator pointing to that location.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"const size_t\",\n                        \"purpose\": \"The index of the element to find.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"iterator\",\n                    \"description\": \"An iterator pointing to the element at the given index.\"\n                },\n                \"dependencies\": [\n                    \"SeekIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            typename ZoneChunkList<T>::iterator ZoneChunkList<T>::Find(const size_t index) {\n            SeekResult seek_result = SeekIndex(index);\n            return typename ZoneChunkList<T>::iterator(seek_result.chunk_,\n                                                        seek_result.chunk_index_);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Find\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Finds a const_iterator pointing to the element at the given index.\",\n                \"logic\": \"Uses SeekIndex to find the chunk and chunk index, then constructs a const_iterator pointing to that location.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"const size_t\",\n                        \"purpose\": \"The index of the element to find.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const_iterator\",\n                    \"description\": \"A const_iterator pointing to the element at the given index.\"\n                },\n                \"dependencies\": [\n                    \"SeekIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            typename ZoneChunkList<T>::const_iterator ZoneChunkList<T>::Find(\n                const size_t index) const {\n            SeekResult seek_result = SeekIndex(index);\n            return typename ZoneChunkList<T>::const_iterator(seek_result.chunk_,\n                                                            seek_result.chunk_index_);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SplitAt\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Splits the list into two, with the new list starting at the given iterator.\",\n                \"logic\": \"Creates a new ZoneChunkList and moves elements from the split_begin iterator to the end of the original list into the new list. It handles cases where the split happens at the beginning or the end of the list. The split is implemented by splitting the chunk where the split_begin iterator points to, creating a new chunk, copying memory, and adjusting pointers. Then the linked list is split, and the sizes of the lists are adjusted. The original list is truncated to end just before split_begin. All iterators are invalidated.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"split_begin\",\n                        \"type\": \"iterator\",\n                        \"purpose\": \"Iterator indicating the position where the list should be split.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ZoneChunkList<T>\",\n                    \"description\": \"The new ZoneChunkList containing the elements from split_begin to the end of the original list.\"\n                },\n                \"dependencies\": [\n                    \"ZoneChunkList\",\n                    \"begin\",\n                    \"end\",\n                    \"swap\",\n                    \"DCHECK_LE\",\n                    \"NewChunk\",\n                    \"kInitialChunkCapacity\",\n                    \"base::bits::RoundUpToPowerOfTwo32\",\n                    \"CHECK_LE\",\n                    \"std::copy\",\n                    \"DCHECK_LT\",\n                    \"Verify\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            ZoneChunkList<T> ZoneChunkList<T>::SplitAt(iterator split_begin) {\n            ZoneChunkList<T> result(zone_);\n\n            // `result` is an empty freshly-constructed list.\n            if (split_begin == end()) return result;\n\n            // `this` is empty after the split and `result` contains everything.\n            if (split_begin == begin()) {\n                this->swap(result);\n                return result;\n            }\n\n            // There is at least one element in both `this` and `result`.\n\n            // Split the chunk.\n            Chunk* split_chunk = split_begin.current_;\n            DCHECK_LE(split_begin.position_, split_chunk->position_);\n            T* chunk_split_begin = split_chunk->items() + split_begin.position_;\n            T* chunk_split_end = split_chunk->items() + split_chunk->position_;\n            uint32_t new_chunk_size =\n                static_cast<uint32_t>(chunk_split_end - chunk_split_begin);\n            uint32_t new_chunk_capacity = std::max(\n                kInitialChunkCapacity, base::bits::RoundUpToPowerOfTwo32(new_chunk_size));\n            CHECK_LE(new_chunk_size, new_chunk_capacity);\n            Chunk* new_chunk = NewChunk(new_chunk_capacity);\n            std::copy(chunk_split_begin, chunk_split_end, new_chunk->items());\n            new_chunk->position_ = new_chunk_size;\n            split_chunk->position_ = split_begin.position_;\n\n            // Split the linked list.\n            result.front_ = new_chunk;\n            result.last_nonempty_ =\n                (last_nonempty_ == split_chunk) ? new_chunk : last_nonempty_;\n            new_chunk->next_ = split_chunk->next_;\n            if (new_chunk->next_) {\n                new_chunk->next_->previous_ = new_chunk;\n            }\n\n            last_nonempty_ = split_chunk;\n            split_chunk->next_ = nullptr;\n\n            // Compute the new size.\n            size_t new_size = 0;\n            for (Chunk* chunk = front_; chunk != split_chunk; chunk = chunk->next_) {\n                DCHECK(!chunk->empty());\n                new_size += chunk->size();\n            }\n            new_size += split_chunk->size();\n            DCHECK_LT(new_size, size());\n            result.size_ = size() - new_size;\n            size_ = new_size;\n\n            #ifdef DEBUG\n            Verify();\n            result.Verify();\n            #endif\n\n            return result;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Append\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Appends another ZoneChunkList to the end of this ZoneChunkList.\",\n                \"logic\": \"Appends the chunks from the `other` list to the end of the current list. The `other` list is left in a valid but empty state after the operation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"other\",\n                        \"type\": \"ZoneChunkList<T>&\",\n                        \"purpose\": \"The ZoneChunkList to append.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"DCHECK_EQ\",\n                    \"Verify\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneChunkList<T>::Append(ZoneChunkList<T>& other) {\n            DCHECK_EQ(zone_, other.zone_);\n\n            if (other.front_ == nullptr) return;\n\n            last_nonempty_->next_ = other.front_;\n            other.front_->previous_ = last_nonempty_;\n\n            last_nonempty_ = other.last_nonempty_;\n\n            size_ += other.size_;\n            #ifdef DEBUG\n            Verify();\n            #endif\n\n            // Leave `other` in empty, but valid state.\n            other.front_ = nullptr;\n            other.last_nonempty_ = nullptr;\n            other.size_ = 0;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CopyTo\",\n                \"parent\": \"ZoneChunkList\",\n                \"about\": \"Copies the contents of the ZoneChunkList to a contiguous memory location.\",\n                \"logic\": \"Iterates through the chunks and copies their contents to the provided pointer using MemCopy.\",\n                \"parameters\": [\n                    {\n                        \"name"
}