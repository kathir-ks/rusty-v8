{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/jump-threading.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/jump-threading.cc\",\n            \"file_name\": \"jump-threading.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements jump threading optimization pass for the V8 compiler backend.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for jump threading and code generation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/backend/jump-threading.h\"\n#include \"src/compiler/backend/code-generator-impl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"JumpThreadingState\",\n                \"about\": \"Represents the state of the jump threading algorithm during the computation of forwarding targets.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"forwarded\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether any blocks have been forwarded.\"\n                    },\n                    {\n                        \"name\": \"result\",\n                        \"type\": \"ZoneVector<RpoNumber>&\",\n                        \"access\": \"public\",\n                        \"purpose\": \"A vector storing the forwarding target for each RPO number.  `result[i]` contains the RPO number to which block `i` should be forwarded.\"\n                    },\n                    {\n                        \"name\": \"stack\",\n                        \"type\": \"ZoneStack<RpoNumber>&\",\n                        \"access\": \"public\",\n                        \"purpose\": \"A stack used for depth-first search of empty blocks.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"RpoNumber\",\n                    \"ZoneVector\",\n                    \"ZoneStack\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct JumpThreadingState {\n  bool forwarded;\n  ZoneVector<RpoNumber>& result;\n  ZoneStack<RpoNumber>& stack;\n\n  void Clear(size_t count) { result.assign(count, unvisited()); }\n  void PushIfUnvisited(RpoNumber num) {\n    if (result[num.ToInt()] == unvisited()) {\n      stack.push(num);\n      result[num.ToInt()] = onstack();\n    }\n  }\n  void Forward(RpoNumber to) {\n    RpoNumber from = stack.top();\n    RpoNumber to_to = result[to.ToInt()];\n    bool pop = true;\n    if (to == from) {\n      TRACE(\"  xx %d\\n\", from.ToInt());\n      result[from.ToInt()] = from;\n    } else if (to_to == unvisited()) {\n      TRACE(\"  fw %d -> %d (recurse)\\n\", from.ToInt(), to.ToInt());\n      stack.push(to);\n      result[to.ToInt()] = onstack();\n      pop = false;  // recurse.\n    } else if (to_to == onstack()) {\n      TRACE(\"  fw %d -> %d (cycle)\\n\", from.ToInt(), to.ToInt());\n      result[from.ToInt()] = to;  // break the cycle.\n      forwarded = true;\n    } else {\n      TRACE(\"  fw %d -> %d (forward)\\n\", from.ToInt(), to.ToInt());\n      result[from.ToInt()] = to_to;  // forward the block.\n      forwarded = true;\n    }\n    if (pop) stack.pop();\n  }\n  RpoNumber unvisited() { return RpoNumber::FromInt(-1); }\n  RpoNumber onstack() { return RpoNumber::FromInt(-2); }\n};\n        ]]></code>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"Clear\",\n                    \"parent\": \"JumpThreadingState\",\n                    \"about\": \"Initializes the 'result' vector with 'unvisited' markers.\",\n                    \"logic\": \"Assigns the `unvisited()` RpoNumber to each element of the `result` vector.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"count\",\n                            \"type\": \"size_t\",\n                            \"purpose\": \"The number of elements to initialize in the 'result' vector.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"void\",\n                        \"description\": \"No return value.\"\n                    },\n                    \"dependencies\": [\n                        \"unvisited\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n  void Clear(size_t count) { result.assign(count, unvisited()); }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"PushIfUnvisited\",\n                    \"parent\": \"JumpThreadingState\",\n                    \"about\": \"Pushes an RPO number onto the stack if it hasn't been visited yet.\",\n                    \"logic\": \"Checks if `result[num.ToInt()]` is equal to `unvisited()`. If it is, pushes `num` onto the stack and marks `result[num.ToInt()]` as `onstack()`.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"num\",\n                            \"type\": \"RpoNumber\",\n                            \"purpose\": \"The RPO number to push onto the stack.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"void\",\n                        \"description\": \"No return value.\"\n                    },\n                    \"dependencies\": [\n                        \"unvisited\",\n                        \"onstack\",\n                        \"RpoNumber\",\n                        \"ZoneStack\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n  void PushIfUnvisited(RpoNumber num) {\n    if (result[num.ToInt()] == unvisited()) {\n      stack.push(num);\n      result[num.ToInt()] = onstack();\n    }\n  }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"Forward\",\n                    \"parent\": \"JumpThreadingState\",\n                    \"about\": \"Forwards a block to a target RPO number, handling recursion, cycles, and forwarding.\",\n                    \"logic\": \"This method implements the core logic of the jump threading algorithm. It checks several cases:\\n1. If `to` is the same as `from`, it marks `from` as its own forward target.\\n2. If `to` is unvisited, it pushes `to` onto the stack and marks it as being on the stack (recurses).\\n3. If `to` is already on the stack, it indicates a cycle, so `from` is forwarded to `to` to break the cycle.\\n4. Otherwise, `from` is forwarded to the target of `to`.\\nIf any forwarding occurs, the `forwarded` flag is set.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"to\",\n                            \"type\": \"RpoNumber\",\n                            \"purpose\": \"The target RPO number to forward to.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"void\",\n                        \"description\": \"No return value.\"\n                    },\n                    \"dependencies\": [\n                        \"unvisited\",\n                        \"onstack\",\n                        \"RpoNumber\",\n                        \"ZoneStack\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n  void Forward(RpoNumber to) {\n    RpoNumber from = stack.top();\n    RpoNumber to_to = result[to.ToInt()];\n    bool pop = true;\n    if (to == from) {\n      TRACE(\"  xx %d\\n\", from.ToInt());\n      result[from.ToInt()] = from;\n    } else if (to_to == unvisited()) {\n      TRACE(\"  fw %d -> %d (recurse)\\n\", from.ToInt(), to.ToInt());\n      stack.push(to);\n      result[to.ToInt()] = onstack();\n      pop = false;  // recurse.\n    } else if (to_to == onstack()) {\n      TRACE(\"  fw %d -> %d (cycle)\\n\", from.ToInt(), to.ToInt());\n      result[from.ToInt()] = to;  // break the cycle.\n      forwarded = true;\n    } else {\n      TRACE(\"  fw %d -> %d (forward)\\n\", from.ToInt(), to.ToInt());\n      result[from.ToInt()] = to_to;  // forward the block.\n      forwarded = true;\n    }\n    if (pop) stack.pop();\n  }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"unvisited\",\n                    \"parent\": \"JumpThreadingState\",\n                    \"about\": \"Returns a special RpoNumber indicating an unvisited block.\",\n                    \"logic\": \"Returns an RpoNumber constructed from -1.\",\n                    \"parameters\": [],\n                    \"return\": {\n                        \"type\": \"RpoNumber\",\n                        \"description\": \"The RpoNumber representing an unvisited block.\"\n                    },\n                    \"dependencies\": [\n                        \"RpoNumber\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n  RpoNumber unvisited() { return RpoNumber::FromInt(-1); }\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"onstack\",\n                    \"parent\": \"JumpThreadingState\",\n                    \"about\": \"Returns a special RpoNumber indicating that a block is currently on the stack.\",\n                    \"logic\": \"Returns an RpoNumber constructed from -2.\",\n                    \"parameters\": [],\n                    \"return\": {\n                        \"type\": \"RpoNumber\",\n                        \"description\": \"The RpoNumber representing a block on the stack.\"\n                    },\n                    \"dependencies\": [\n                        \"RpoNumber\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n  RpoNumber onstack() { return RpoNumber::FromInt(-2); }\n            ]]></code>\n        </func>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"GapJumpRecord\",\n                \"about\": \"Data structure to record gap jump instructions for jump threading.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The zone allocator.\"\n                    },\n                    {\n                        \"name\": \"gap_jump_records_\",\n                        \"type\": \"ZoneUnorderedMap<RpoNumber, ZoneVector<Record>, RpoNumberHash>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Hash map to store gap jump records.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Zone\",\n                    \"RpoNumber\",\n                    \"ZoneUnorderedMap\",\n                    \"ZoneVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct GapJumpRecord {\n  explicit GapJumpRecord(Zone* zone) : zone_(zone), gap_jump_records_(zone) {}\n\n  struct Record {\n    RpoNumber block;\n    Instruction* instr;\n  };\n\n  struct RpoNumberHash {\n    std::size_t operator()(const RpoNumber& key) const {\n      return std::hash<int>()(key.ToInt());\n    }\n  };\n\n  bool CanForwardGapJump(Instruction* instr, RpoNumber instr_block,\n                         RpoNumber target_block, RpoNumber* forward_to) {\n    DCHECK_EQ(instr->arch_opcode(), kArchJmp);\n    bool can_forward = false;\n    auto search = gap_jump_records_.find(target_block);\n    if (search != gap_jump_records_.end()) {\n      for (Record& record : search->second) {\n        Instruction* record_instr = record.instr;\n        DCHECK_EQ(record_instr->arch_opcode(), kArchJmp);\n        bool is_same_instr = true;\n        for (int i = Instruction::FIRST_GAP_POSITION;\n             i <= Instruction::LAST_GAP_POSITION; i++) {\n          Instruction::GapPosition pos =\n              static_cast<Instruction::GapPosition>(i);\n          ParallelMove* record_move = record_instr->GetParallelMove(pos);\n          ParallelMove* instr_move = instr->GetParallelMove(pos);\n          if (record_move == nullptr && instr_move == nullptr) continue;\n          if (((record_move == nullptr) != (instr_move == nullptr)) ||\n              !record_move->Equals(*instr_move)) {\n            is_same_instr = false;\n            break;\n          }\n        }\n        if (is_same_instr) {\n          // Found an instruction same as the recorded one.\n          *forward_to = record.block;\n          can_forward = true;\n          break;\n        }\n      }\n      if (!can_forward) {\n        // No recorded instruction has been found for this target block,\n        // so create a new record with the given instruction.\n        search->second.push_back({instr_block, instr});\n      }\n    } else {\n      // This is the first explored gap jump to target block.\n      auto ins =\n          gap_jump_records_.insert({target_block, ZoneVector<Record>(zone_)});\n      if (ins.second) {\n        ins.first->second.reserve(4);\n        ins.first->second.push_back({instr_block, instr});\n      }\n    }\n    return can_forward;\n  }\n\n  Zone* zone_;\n  ZoneUnorderedMap<RpoNumber, ZoneVector<Record>, RpoNumberHash>\n      gap_jump_records_;\n};\n        ]]></code>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"Record\",\n                    \"parent\": \"GapJumpRecord\",\n                    \"about\": \"A record that saves an instruction with RPO number.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"block\",\n                            \"type\": \"RpoNumber\",\n                            \"access\": \"public\",\n                            \"purpose\": \"RPO number of the block\"\n                        },\n                        {\n                            \"name\": \"instr\",\n                            \"type\": \"Instruction*\",\n                            \"access\": \"public\",\n                            \"purpose\": \"Instruction of gap jump\"\n                        }\n                    ],\n                    \"dependencies\": [\n                        \"Instruction\",\n                        \"RpoNumber\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n  struct Record {\n    RpoNumber block;\n    Instruction* instr;\n  };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"struct\",\n                    \"name\": \"RpoNumberHash\",\n                    \"parent\": \"GapJumpRecord\",\n                    \"about\": \"Functor to hash RpoNumber for unordered map.\",\n                    \"dependencies\": [\n                        \"RpoNumber\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n  struct RpoNumberHash {\n    std::size_t operator()(const RpoNumber& key) const {\n      return std::hash<int>()(key.ToInt());\n    }\n  };\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"CanForwardGapJump\",\n                    \"parent\": \"GapJumpRecord\",\n                    \"about\": \"Determines whether the gap jump can be forwarded to another block.\",\n                    \"logic\": \"This function checks if a gap jump instruction can be forwarded to a previously recorded gap jump to the same target block.  It iterates through previously recorded instructions for the target block. If it finds an instruction with the same parallel moves (gap moves), it means it can be forwarded. If no identical instructions are found, it adds a new record for the current instruction and target block.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"instr\",\n                            \"type\": \"Instruction*\",\n                            \"purpose\": \"The gap jump instruction to check.\"\n                        },\n                        {\n                            \"name\": \"instr_block\",\n                            \"type\": \"RpoNumber\",\n                            \"purpose\": \"The RPO number of the block containing the instruction.\"\n                        },\n                        {\n                            \"name\": \"target_block\",\n                            \"type\": \"RpoNumber\",\n                            \"purpose\": \"The RPO number of the target block.\"\n                        },\n                        {\n                            \"name\": \"forward_to\",\n                            \"type\": \"RpoNumber*\",\n                            \"purpose\": \"Output parameter to store the RPO number of the block to forward to, if possible.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"bool\",\n                        \"description\": \"True if the gap jump can be forwarded, false otherwise.\"\n                    },\n                    \"dependencies\": [\n                        \"Instruction\",\n                        \"RpoNumber\",\n                        \"ParallelMove\",\n                        \"ZoneUnorderedMap\",\n                        \"ZoneVector\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n  bool CanForwardGapJump(Instruction* instr, RpoNumber instr_block,\n                         RpoNumber target_block, RpoNumber* forward_to) {\n    DCHECK_EQ(instr->arch_opcode(), kArchJmp);\n    bool can_forward = false;\n    auto search = gap_jump_records_.find(target_block);\n    if (search != gap_jump_records_.end()) {\n      for (Record& record : search->second) {\n        Instruction* record_instr = record.instr;\n        DCHECK_EQ(record_instr->arch_opcode(), kArchJmp);\n        bool is_same_instr = true;\n        for (int i = Instruction::FIRST_GAP_POSITION;\n             i <= Instruction::LAST_GAP_POSITION; i++) {\n          Instruction::GapPosition pos =\n              static_cast<Instruction::GapPosition>(i);\n          ParallelMove* record_move = record_instr->GetParallelMove(pos);\n          ParallelMove* instr_move = instr->GetParallelMove(pos);\n          if (record_move == nullptr && instr_move == nullptr) continue;\n          if (((record_move == nullptr) != (instr_move == nullptr)) ||\n              !record_move->Equals(*instr_move)) {\n            is_same_instr = false;\n            break;\n          }\n        }\n        if (is_same_instr) {\n          // Found an instruction same as the recorded one.\n          *forward_to = record.block;\n          can_forward = true;\n          break;\n        }\n      }\n      if (!can_forward) {\n        // No recorded instruction has been found for this target block,\n        // so create a new record with the given instruction.\n        search->second.push_back({instr_block, instr});\n      }\n    } else {\n      // This is the first explored gap jump to target block.\n      auto ins =\n          gap_jump_records_.insert({target_block, ZoneVector<Record>(zone_)});\n      if (ins.second) {\n        ins.first->second.reserve(4);\n        ins.first->second.push_back({instr_block, instr});\n      }\n    }\n    return can_forward;\n  }\n            ]]></code>\n        </func>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ComputeForwarding\",\n                \"about\": \"Computes the forwarding targets for each instruction block, based on jump threading rules.\",\n                \"logic\": \"This function performs a depth-first search (DFS) through the instruction blocks, attempting to forward empty blocks to their targets.  It uses the JumpThreadingState struct to maintain the state of the DFS. Key steps:\\n1.  Initialize the JumpThreadingState.\\n2. Iterate through the blocks in RPO (Reverse Postorder).\\n3. For each block, push it onto the stack if it's unvisited.\\n4. Process the stack:  For each block on the stack, examine its instructions:\\n    * Skip instructions with non-redundant moves or flag continuations.\\n    * Nop instructions are skipped.\\n    * Jump instructions may be forwarded if the block doesn't construct/deconstruct a frame (unless frame-at-start is enabled). Gap jumps can be forwarded when they have identical parallel moves as recorded instructions.\\n    * Return instructions may be forwarded if they have immediate operands and share the same must_deconstruct_frame attribute.\\n5. Call state.Forward(fw) to update the forwarding target of the current block.\\nThe GapJumpRecord data structure records instructions with parallel moves, so gap jumps can be forwarded when possible.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"local_zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone allocator for local data structures.\"\n                    },\n                    {\n                        \"name\": \"result\",\n                        \"type\": \"ZoneVector<RpoNumber>*\",\n                        \"purpose\": \"Output parameter: A vector that will store the forwarding target for each instruction block.\"\n                    },\n                    {\n                        \"name\": \"code\",\n                        \"type\": \"InstructionSequence*\",\n                        \"purpose\": \"The instruction sequence to optimize.\"\n                    },\n                    {\n                        \"name\": \"frame_at_start\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether the stack frame is built at the start of the function.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if any blocks were forwarded, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"ZoneVector\",\n                    \"ZoneStack\",\n                    \"JumpThreadingState\",\n                    \"InstructionSequence\",\n                    \"RpoNumber\",\n                    \"InstructionBlock\",\n                    \"Instruction\",\n                    \"GapJumpRecord\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool JumpThreading::ComputeForwarding(Zone* local_zone,\n                                      ZoneVector<RpoNumber>* result,\n                                      InstructionSequence* code,\n                                      bool frame_at_start) {\n  ZoneStack<RpoNumber> stack(local_zone);\n  JumpThreadingState state = {false, *result, stack};\n  state.Clear(code->InstructionBlockCount());\n  RpoNumber empty_deconstruct_frame_return_block = RpoNumber::Invalid();\n  int32_t empty_deconstruct_frame_return_size;\n  RpoNumber empty_no_deconstruct_frame_return_block = RpoNumber::Invalid();\n  int32_t empty_no_deconstruct_frame_return_size;\n  GapJumpRecord record(local_zone);\n\n  // Iterate over the blocks forward, pushing the blocks onto the stack.\n  for (auto const instruction_block : code->instruction_blocks()) {\n    RpoNumber current = instruction_block->rpo_number();\n    state.PushIfUnvisited(current);\n\n    // Process the stack, which implements DFS through empty blocks.\n    while (!state.stack.empty()) {\n      InstructionBlock* block = code->InstructionBlockAt(state.stack.top());\n      // Process the instructions in a block up to a non-empty instruction.\n      TRACE(\"jt [%d] B%d\\n\", static_cast<int>(stack.size()),\n            block->rpo_number().ToInt());\n      RpoNumber fw = block->rpo_number();\n      for (int i = block->code_start(); i < block->code_end(); ++i) {\n        Instruction* instr = code->InstructionAt(i);\n        if (!instr->AreMovesRedundant()) {\n          TRACE(\"  parallel move\");\n          // can't skip instructions with non redundant moves, except when we\n          // can forward to a block with identical gap-moves.\n          if (instr->arch_opcode() == kArchJmp) {\n            TRACE(\" jmp\");\n            RpoNumber forward_to;\n            if ((frame_at_start || !(block->must_deconstruct_frame() ||\n                                     block->must_construct_frame())) &&\n                record.CanForwardGapJump(instr, block->rpo_number(),\n                                         code->InputRpo(instr, 0),\n                                         &forward_to)) {\n              DCHECK(forward_to.IsValid());\n              fw = forward_to;\n              TRACE(\"\\n  merge B%d into B%d\", block->rpo_number().ToInt(),\n                    forward_to.ToInt());\n            }\n          }\n          TRACE(\"\\n\");\n        } else if (FlagsModeField::decode(instr->opcode()) != kFlags_none) {\n          // can't skip instructions with flags continuations.\n          TRACE(\"  flags\\n\");\n        } else if (instr->IsNop()) {\n          // skip nops.\n          TRACE(\"  nop\\n\");\n          continue;\n        } else if (instr->arch_opcode() == kArchJmp) {\n          // try to forward the jump instruction.\n          TRACE(\"  jmp\\n\");\n          // if this block deconstructs the frame, we can't forward it.\n          // TODO(mtrofin): we can still forward if we end up building\n          // the frame at start. So we should move the decision of whether\n          // to build a frame or not in the register allocator, and trickle it\n          // here and to the code generator.\n          if (frame_at_start || !(block->must_deconstruct_frame() ||\n                                  block->must_construct_frame())) {\n            fw = code->InputRpo(instr, 0);\n          }\n        } else if (instr->IsRet()) {\n          TRACE(\"  ret\\n\");\n          CHECK_IMPLIES(block->must_construct_frame(),\n                        block->must_deconstruct_frame());\n          // Only handle returns with immediate/constant operands, since\n          // they must always be the same for all returns in a function.\n          // Dynamic return values might use different registers at\n          // different return sites and therefore cannot be shared.\n          if (instr->InputAt(0)->IsImmediate()) {\n            int32_t return_size =\n                ImmediateOperand::cast(instr->InputAt(0))->inline_int32_value();\n            // Instructions can be shared only for blocks that share\n            // the same |must_deconstruct_frame| attribute.\n            if (block->must_deconstruct_frame()) {\n              if (empty_deconstruct_frame_return_block ==\n                  RpoNumber::Invalid()) {\n                empty_deconstruct_frame_return_block = block->rpo_number();\n                empty_deconstruct_frame_return_size = return_size;\n              } else if (empty_deconstruct_frame_return_size == return_size) {\n                fw = empty_deconstruct_frame_return_block;\n                block->clear_must_deconstruct_frame();\n              }\n            } else {\n              if (empty_no_deconstruct_frame_return_block ==\n                  RpoNumber::Invalid()) {\n                empty_no_deconstruct_frame_return_block = block->rpo_number();\n                empty_no_deconstruct_frame_return_size = return_size;\n              } else if (empty_no_deconstruct_frame_return_size ==\n                         return_size) {\n                fw = empty_no_deconstruct_frame_return_block;\n              }\n            }\n          }\n        } else {\n          // can't skip other instructions.\n          TRACE(\"  other\\n\");\n        }\n        break;\n      }\n      state.Forward(fw);\n    }\n  }\n\n#ifdef DEBUG\n  for (RpoNumber num : *result) {\n    DCHECK(num.IsValid());\n  }\n#endif\n\n  if (v8_flags.trace_turbo_jt) {\n    for (int i = 0; i < static_cast<int>(result->size()); i++) {\n      TRACE(\"B%d \", i);\n      int to = (*result)[i].ToInt();\n      if (i != to) {\n        TRACE(\"-> B%d\\n\", to);\n      } else {\n        TRACE(\"\\n\");\n      }\n    }\n  }\n\n  return state.forwarded;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ApplyForwarding\",\n                \"about\": \"Applies the computed forwarding targets to the instruction sequence, removing redundant jumps.\",\n                \"logic\": \"This function iterates through the instruction blocks and replaces redundant jumps with nops based on the computed forwarding targets in the 'result' vector. It updates the AO (Assembly Order) numbers of the blocks to maintain a contiguous order, even after skipping blocks. RPO immediates are also updated to point to the new target.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"local_zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone allocator for local data structures.\"\n                    },\n                    {\n                        \"name\": \"result\",\n                        \"type\": \"ZoneVector<RpoNumber> const&\",\n                        \"purpose\": \"A vector containing the forwarding target for each instruction block.\"\n                    },\n                    {\n                        \"name\": \"code\",\n                        \"type\": \"InstructionSequence*\",\n                        \"purpose\": \"The instruction sequence to modify.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"ZoneVector\",\n                    \"InstructionSequence\",\n                    \"RpoNumber\",\n                    \"InstructionBlock\",\n                    \"Instruction\",\n                    \"ParallelMove\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid JumpThreading::ApplyForwarding(Zone* local_zone,\n                                    ZoneVector<RpoNumber> const& result,\n                                    InstructionSequence* code) {\n  if (!v8_flags.turbo_jt) return;\n\n  // Skip empty blocks except for the first block.\n  int ao = 0;\n  for (auto const block : code->ao_blocks()) {\n    RpoNumber block_rpo = block->rpo_number();\n    int block_num = block_rpo.ToInt();\n    RpoNumber result_rpo = result[block_num];\n    bool skip = block_rpo != RpoNumber::FromInt(0) && result_rpo != block_rpo;\n\n    if (result_rpo != block_rpo) {\n      // We need the handler and switch target information to be propagated, so\n      // that branch targets are annotated as necessary for control flow\n      // integrity checks (when enabled).\n      if (code->InstructionBlockAt(block_rpo)->IsHandler()) {\n        code->InstructionBlockAt(result_rpo)->MarkHandler();\n      }\n      if (code->InstructionBlockAt(block_rpo)->IsSwitchTarget()) {\n        code->InstructionBlockAt(result_rpo)->set_switch_target(true);\n      }\n    }\n\n    if (skip) {\n      for (int instr_idx = block->code_start(); instr_idx < block->code_end();\n           ++instr_idx) {\n        Instruction* instr = code->InstructionAt(instr_idx);\n        DCHECK_NE(FlagsModeField::decode(instr->opcode()), kFlags_branch);\n        if (instr->arch_opcode() == kArchJmp ||\n            instr->arch_opcode() == kArchRet) {\n          // Overwrite a redundant jump with a nop.\n          TRACE(\"jt-fw nop @%d\\n\", instr_idx);\n          instr->OverwriteWithNop();\n          // Eliminate all the ParallelMoves.\n          for (int i = Instruction::FIRST_GAP_POSITION;\n               i <= Instruction::LAST_GAP_POSITION; i++) {\n            Instruction::GapPosition pos =\n                static_cast<Instruction::GapPosition>(i);\n            ParallelMove* instr_move = instr->GetParallelMove(pos);\n            if (instr_move != nullptr) {\n              instr_move->Eliminate();\n            }\n          }\n          // If this block was marked as a handler, it can be unmarked now.\n          code->InstructionBlockAt(block_rpo)->UnmarkHandler();\n          code->InstructionBlockAt(block_rpo)->set_omitted_by_jump_threading();\n        }\n      }\n    }\n\n    // Renumber the blocks so that IsNextInAssemblyOrder() will return true,\n    // even if there are skipped blocks in-between.\n    block->set_ao_number(RpoNumber::FromInt(ao));\n    if (!skip) ao++;\n  }\n\n  // Patch RPO immediates.\n  InstructionSequence::RpoImmediates& rpo_immediates = code->rpo_immediates();\n  for (size_t i = 0; i < rpo_immediates.size(); i++) {\n    RpoNumber rpo = rpo_immediates[i];\n    if (rpo.IsValid()) {\n      RpoNumber fw = result[rpo.ToInt()];\n      if (fw != rpo) rpo_immediates[i] = fw;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"InstructionSequence\",\n                    \"about\": \"Represents a sequence of instructions.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass InstructionSequence {\n public:\n  class RpoImmediates : public ZoneVector<RpoNumber> {\n   public:\n    explicit RpoImmediates(Zone* zone) : ZoneVector(zone) {}\n  };\n\n  InstructionBlock* InstructionBlockAt(RpoNumber rpo) const;\n  Instruction* InstructionAt(int index) const;\n  RpoNumber InputRpo(Instruction* instr, int index) const;\n  const ZoneVector<InstructionBlock*>& instruction_blocks() const;\n  const ZoneVector<InstructionBlock*>& ao_blocks() const;\n  RpoImmediates& rpo_immediates();\n};\n            ]]></code>\n        </class>\n        <class>"
}