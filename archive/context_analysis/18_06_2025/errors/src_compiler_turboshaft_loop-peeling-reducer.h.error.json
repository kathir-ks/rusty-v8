{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/loop-peeling-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 148, column 46",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/loop-peeling-reducer.h\",\n            \"file_name\": \"loop-peeling-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the LoopPeelingReducer class, which implements loop peeling optimization in the Turboshaft compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for logging, assembler, copying phase, index, loop finding, machine optimization, operations, and phase management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/logging.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/copying-phase.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/loop-finder.h\"\n#include \"src/compiler/turboshaft/machine-optimization-reducer.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoopPeelingReducer\",\n                \"extends\": \"Next\",\n                \"about\": \"A reducer that peels the first iteration of innermost loops to hoist checks out of the loop.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"peeling_\",\n                        \"type\": \"PeelingStatus\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of the current peeling status.\"\n                    },\n                    {\n                        \"name\": \"current_loop_header_\",\n                        \"type\": \"const Block*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the header block of the loop being peeled.\"\n                    },\n                    {\n                        \"name\": \"loop_finder_\",\n                        \"type\": \"LoopFinder\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Used to find loops and their properties.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Used to access heap objects and properties.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Next\",\n                    \"Block\",\n                    \"GotoOp\",\n                    \"LoopFinder\",\n                    \"JSHeapBroker\",\n                    \"CallOp\",\n                    \"JSStackCheckOp\",\n                    \"WasmStackCheckOp\",\n                    \"PhiOp\",\n                    \"V\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass LoopPeelingReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(LoopPeeling)\n\n#if defined(__clang__)\n  // LoopUnrolling and LoopPeeling shouldn't be performed in the same phase, see\n  // the comment in pipeline.cc where LoopUnrolling is triggered.\n  static_assert(\n      !reducer_list_contains<ReducerList, LoopUnrollingReducer>::value);\n#endif\n\n  V<None> REDUCE_INPUT_GRAPH(Goto)(V<None> ig_idx, const GotoOp& gto);\n\n  // TODO(dmercadier): remove once StackCheckOp are kept in the pipeline until\n  // the very end (which should happen when we have a SimplifiedLowering in\n  // Turboshaft).\n  V<AnyOrNone> REDUCE_INPUT_GRAPH(Call)(V<AnyOrNone> ig_idx,\n                                        const CallOp& call);\n\n  V<None> REDUCE_INPUT_GRAPH(JSStackCheck)(V<None> ig_idx,\n                                           const JSStackCheckOp& stack_check);\n\n#if V8_ENABLE_WEBASSEMBLY\n  V<None> REDUCE_INPUT_GRAPH(WasmStackCheck)(\n      V<None> ig_idx, const WasmStackCheckOp& stack_check);\n#endif\n\n  OpIndex REDUCE_INPUT_GRAPH(Phi)(OpIndex ig_idx, const PhiOp& phi);\n\n private:\n  static constexpr int kMaxSizeForPeeling = 1000;\n  enum class PeelingStatus {\n    kNotPeeling,\n    kEmittingPeeledLoop,\n    kEmittingUnpeeledBody\n  };\n\n  void PeelFirstIteration(const Block* header);\n\n  bool CanPeelLoop(const Block* header);\n\n  bool IsPeeling() const;\n  bool IsEmittingPeeledIteration() const;\n  bool IsEmittingUnpeeledBody() const;\n\n  PeelingStatus peeling_ = PeelingStatus::kNotPeeling;\n  const Block* current_loop_header_ = nullptr;\n\n  LoopFinder loop_finder_{__ phase_zone(), &__ modifiable_input_graph()};\n  JSHeapBroker* broker_ = __ data() -> broker();\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE_INPUT_GRAPH(Goto)\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Reduces a Goto operation in the input graph, handling loop peeling logic.\",\n                \"logic\": \"If the Goto leads to a loop header and loop peeling is possible, the function triggers loop peeling.  It also handles skipping backedges during peeling.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_idx\",\n                        \"type\": \"V<None>\",\n                        \"purpose\": \"Index of the Goto operation in the input graph.\"\n                    },\n                    {\n                        \"name\": \"gto\",\n                        \"type\": \"const GotoOp&\",\n                        \"purpose\": \"The Goto operation to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<None>\",\n                    \"description\": \"A potentially new V<None> representing the reduced Goto operation.  Empty V<None> if the backedge is skipped, otherwise result from the base class.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"Block\",\n                    \"GotoOp\",\n                    \"CanPeelLoop\",\n                    \"PeelFirstIteration\",\n                    \"IsEmittingPeeledIteration\",\n                    \"ShouldSkipOptimizationStep\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<None> REDUCE_INPUT_GRAPH(Goto)(V<None> ig_idx, const GotoOp& gto) {\n    // Note that the \"ShouldSkipOptimizationStep\" is placed in the part of\n    // this Reduce method triggering the peeling rather than at the begining.\n    // This is because the backedge skipping is not an optimization but a\n    // mandatory lowering when peeling is being performed.\n    LABEL_BLOCK(no_change) { return Next::ReduceInputGraphGoto(ig_idx, gto); }\n\n    const Block* dst = gto.destination;\n    if (dst->IsLoop() && !gto.is_backedge && CanPeelLoop(dst)) {\n      if (ShouldSkipOptimizationStep()) goto no_change;\n      PeelFirstIteration(dst);\n      return {};\n    } else if (IsEmittingPeeledIteration() && dst == current_loop_header_) {\n      // We skip the backedge of the loop: PeelFirstIeration will instead emit a\n      // forward edge to the non-peeled header.\n      return {};\n    }\n\n    goto no_change;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE_INPUT_GRAPH(Call)\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Reduces a Call operation in the input graph, removing stack checks from the peeled iteration.\",\n                \"logic\": \"If the call is a stack check within the peeled iteration, it is removed. Otherwise, the base class reduction is performed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_idx\",\n                        \"type\": \"V<AnyOrNone>\",\n                        \"purpose\": \"Index of the Call operation in the input graph.\"\n                    },\n                    {\n                        \"name\": \"call\",\n                        \"type\": \"const CallOp&\",\n                        \"purpose\": \"The Call operation to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<AnyOrNone>\",\n                    \"description\": \"A potentially new V<AnyOrNone> representing the reduced Call operation. Empty V<AnyOrNone> if the stack check is removed, otherwise result from the base class.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"CallOp\",\n                    \"IsEmittingPeeledIteration\",\n                    \"ShouldSkipOptimizationStep\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  // TODO(dmercadier): remove once StackCheckOp are kept in the pipeline until\n  // the very end (which should happen when we have a SimplifiedLowering in\n  // Turboshaft).\n  V<AnyOrNone> REDUCE_INPUT_GRAPH(Call)(V<AnyOrNone> ig_idx,\n                                        const CallOp& call) {\n    LABEL_BLOCK(no_change) { return Next::ReduceInputGraphCall(ig_idx, call); }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    if (IsEmittingPeeledIteration() &&\n        call.IsStackCheck(__ input_graph(), broker_,\n                          StackCheckKind::kJSIterationBody)) {\n      // We remove the stack check of the peeled iteration.\n      return {};\n    }\n\n    goto no_change;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE_INPUT_GRAPH(JSStackCheck)\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Reduces a JSStackCheck operation in the input graph, removing it from the peeled iteration.\",\n                \"logic\": \"If peeling and emitting the peeled iteration, removes the stack check, otherwise performs the base class reduction.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_idx\",\n                        \"type\": \"V<None>\",\n                        \"purpose\": \"Index of the JSStackCheck operation in the input graph.\"\n                    },\n                    {\n                        \"name\": \"stack_check\",\n                        \"type\": \"const JSStackCheckOp&\",\n                        \"purpose\": \"The JSStackCheck operation to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<None>\",\n                    \"description\": \"A potentially new V<None> representing the reduced JSStackCheck operation. Invalid V<None> if the stack check is removed, otherwise result from the base class.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"JSStackCheckOp\",\n                    \"IsEmittingPeeledIteration\",\n                    \"ShouldSkipOptimizationStep\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  V<None> REDUCE_INPUT_GRAPH(JSStackCheck)(V<None> ig_idx,\n                                           const JSStackCheckOp& stack_check) {\n    if (ShouldSkipOptimizationStep() || !IsEmittingPeeledIteration()) {\n      return Next::ReduceInputGraphJSStackCheck(ig_idx, stack_check);\n    }\n\n    // We remove the stack check of the peeled iteration.\n    return V<None>::Invalid();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE_INPUT_GRAPH(WasmStackCheck)\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Reduces a WasmStackCheck operation in the input graph, removing it from the peeled iteration.\",\n                \"logic\": \"If peeling and emitting the peeled iteration, removes the stack check, otherwise performs the base class reduction.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_idx\",\n                        \"type\": \"V<None>\",\n                        \"purpose\": \"Index of the WasmStackCheck operation in the input graph.\"\n                    },\n                    {\n                        \"name\": \"stack_check\",\n                        \"type\": \"const WasmStackCheckOp&\",\n                        \"purpose\": \"The WasmStackCheck operation to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<None>\",\n                    \"description\": \"A potentially new V<None> representing the reduced WasmStackCheck operation. Invalid V<None> if the stack check is removed, otherwise result from the base class.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"WasmStackCheckOp\",\n                    \"IsEmittingPeeledIteration\",\n                    \"ShouldSkipOptimizationStep\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\n  V<None> REDUCE_INPUT_GRAPH(WasmStackCheck)(\n      V<None> ig_idx, const WasmStackCheckOp& stack_check) {\n    if (ShouldSkipOptimizationStep() || !IsEmittingPeeledIteration()) {\n      return Next::ReduceInputGraphWasmStackCheck(ig_idx, stack_check);\n    }\n\n    // We remove the stack check of the peeled iteration.\n    return V<None>::Invalid();\n  }\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"REDUCE_INPUT_GRAPH(Phi)\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Reduces a Phi operation in the input graph when emitting the unpeeled loop body, adjusting the input from the backedge of the peeled loop.\",\n                \"logic\": \"When emitting the unpeeled loop body, the first input of the loop's Phi nodes is rewired to take the value from the second input (backedge) of the *original* loop's Phi nodes. This is because the original first input now feeds into the peeled first iteration.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_idx\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"Index of the Phi operation in the input graph.\"\n                    },\n                    {\n                        \"name\": \"phi\",\n                        \"type\": \"const PhiOp&\",\n                        \"purpose\": \"The Phi operation to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"A potentially new OpIndex representing the reduced Phi operation, representing the pending loop phi.\"\n                },\n                \"dependencies\": [\n                    \"Next\",\n                    \"PhiOp\",\n                    \"IsEmittingUnpeeledBody\",\n                    \"V\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  OpIndex REDUCE_INPUT_GRAPH(Phi)(OpIndex ig_idx, const PhiOp& phi) {\n    if (!IsEmittingUnpeeledBody() ||\n        __ current_input_block() != current_loop_header_) {\n      return Next::ReduceInputGraphPhi(ig_idx, phi);\n    }\n\n    // The 1st input of the loop phis of the unpeeled loop header should be the\n    // 2nd input of the original loop phis, since with the peeling, they\n    // actually come from the backedge of the peeled iteration.\n    return __ PendingLoopPhi(\n        __ MapToNewGraph(phi.input(PhiOp::kLoopPhiBackEdgeIndex)), phi.rep);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PeelFirstIteration\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Peels the first iteration of a loop.\",\n                \"logic\": \"Clones the loop body twice: once for the peeled iteration and once for the remaining unpeeled loop. Skips the backedge of the peeled iteration and emits a forward edge to the unpeeled header.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"header\",\n                        \"type\": \"const Block*\",\n                        \"purpose\": \"The header block of the loop to peel.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Block\",\n                    \"LoopFinder\",\n                    \"CloneSubGraph\",\n                    \"IsPeeling\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void PeelFirstIteration(const Block* header) {\n    TRACE(\"LoopPeeling: peeling loop at \" << header->index());\n    DCHECK_EQ(peeling_, PeelingStatus::kNotPeeling);\n    ScopedModification<PeelingStatus> scope(&peeling_,\n                                            PeelingStatus::kEmittingPeeledLoop);\n    current_loop_header_ = header;\n\n    // Emitting the peeled iteration.\n    auto loop_body = loop_finder_.GetLoopBody(header);\n    // Note that this call to CloneSubGraph will not emit the backedge because\n    // we'll skip it in ReduceInputGraphGoto (above). The next CloneSubGraph\n    // call will start with a forward Goto to the header (like all\n    // CloneSubGraphs do), and will end by emitting the backedge, because this\n    // time {peeling_} won't be EmittingPeeledLoop, and the backedge Goto will\n    // thus be emitted.\n    TRACE(\"> Emitting peeled iteration\");\n    __ CloneSubGraph(loop_body, /* keep_loop_kinds */ false);\n\n    if (__ generating_unreachable_operations()) {\n      // While peeling, we realized that the 2nd iteration of the loop is not\n      // reachable.\n      TRACE(\"> Second iteration is not reachable, stopping now\");\n      return;\n    }\n\n    // We now emit the regular unpeeled loop.\n    peeling_ = PeelingStatus::kEmittingUnpeeledBody;\n    TRACE(\"> Emitting unpeeled loop body\");\n    __ CloneSubGraph(loop_body, /* keep_loop_kinds */ true,\n                     /* is_loop_after_peeling */ true);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CanPeelLoop\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Determines whether a loop can be peeled.\",\n                \"logic\": \"Checks if the loop is already being peeled, has inner loops, or exceeds the maximum size for peeling.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"header\",\n                        \"type\": \"const Block*\",\n                        \"purpose\": \"The header block of the loop to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the loop can be peeled, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Block\",\n                    \"LoopFinder\",\n                    \"IsPeeling\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  bool CanPeelLoop(const Block* header) {\n    TRACE(\"LoopPeeling: considering \" << header->index());\n    if (IsPeeling()) {\n      TRACE(\"> Cannot peel because we're already peeling a loop\");\n      return false;\n    }\n    auto info = loop_finder_.GetLoopInfo(header);\n    if (info.has_inner_loops) {\n      TRACE(\"> Cannot peel because it has inner loops\");\n      return false;\n    }\n    if (info.op_count > kMaxSizeForPeeling) {\n      TRACE(\"> Cannot peel because it contains too many operations\");\n      return false;\n    }\n    return true;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsPeeling\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Checks if the reducer is currently in the process of peeling a loop.\",\n                \"logic\": \"Returns true if the peeling status is either kEmittingPeeledLoop or kEmittingUnpeeledBody.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the reducer is peeling, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"IsEmittingPeeledIteration\",\n                    \"IsEmittingUnpeeledBody\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  bool IsPeeling() const {\n    return IsEmittingPeeledIteration() || IsEmittingUnpeeledBody();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsEmittingPeeledIteration\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Checks if the reducer is currently emitting the peeled iteration of a loop.\",\n                \"logic\": \"Returns true if the peeling status is kEmittingPeeledLoop.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the reducer is emitting the peeled iteration, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  bool IsEmittingPeeledIteration() const {\n    return peeling_ == PeelingStatus::kEmittingPeeledLoop;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsEmittingUnpeeledBody\",\n                \"parent\": \"LoopPeelingReducer\",\n                \"about\": \"Checks if the reducer is currently emitting the unpeeled body of a loop.\",\n                \"logic\": \"Returns true if the peeling status is kEmittingUnpeeledBody.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the reducer is emitting the unpeeled body, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  bool IsEmittingUnpeeledBody() const {\n    return peeling_ == PeelingStatus::kEmittingUnpeeledBody;\n  }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"PeelingStatus\",\n                \"about\": \"Represents the current status of the loop peeling process.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  enum class PeelingStatus {\n    kNotPeeling,\n    kEmittingPeeledLoop,\n    kEmittingUnpeeledBody\n  };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Next\",\n                    \"about\": \"Template parameter representing the next reducer in the chain.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class Next {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Block\",\n                    \"about\": \"Represents a basic block in the control flow graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class Block {\n                public:\n                    bool IsLoop() const { return false; }\n                    int index() const { return 0; }\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"GotoOp\",\n                    \"about\": \"Represents a goto operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class GotoOp {\n                public:\n                    const Block* destination;\n                    bool is_backedge;\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"LoopFinder\",\n                    \"about\": \"Finds loops in the control flow graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class LoopFinder {\n                public:\n                    struct LoopInfo {\n                        bool has_inner_loops;\n                        int op_count;\n                    };\n                    LoopInfo GetLoopInfo(const Block* header) {\n                        return LoopInfo{false, 0};\n                    }\n                    const Block* GetLoopBody(const Block* header) {\n                        return header;\n                    }\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSHeapBroker\",\n                    \"about\": \"Interface for accessing the JavaScript heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class JSHeapBroker {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"CallOp\",\n                    \"about\": \"Represents a call operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class CallOp {\n                public:\n                    bool IsStackCheck(...) const { return false; }\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"JSStackCheckOp\",\n                    \"about\": \"Represents a JavaScript stack check operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class JSStackCheckOp {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"WasmStackCheckOp\",\n                    \"about\": \"Represents a WebAssembly stack check operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class WasmStackCheckOp {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"PhiOp\",\n                    \"about\": \"Represents a Phi operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            class PhiOp {\n                public:\n                    enum class Inputs {\n                        kLoopPhiBackEdgeIndex\n                    };\n                    int rep;\n                    int input(Inputs i) const { return 0; }\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"V\",\n                    \"about\": \"A template class for representing values in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n            template <typename T>\n            class V {\n                public:\n                static V Invalid() { return V(); }\n            };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"StackCheckKind\",\n                    \"about\": \"Enum for stack check kinds\"\n                }\n            </metadata>\n            <code><![CDATA[\n            enum class StackCheckKind {\n                kJSIterationBody\n            };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}