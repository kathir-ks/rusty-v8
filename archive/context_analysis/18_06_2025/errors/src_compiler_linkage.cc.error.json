{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/linkage.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/linkage.cc\",\n        \"file_name\": \"linkage.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Linkage class and related functions for managing calling conventions and data locations during compilation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for compiler linkage functionality.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/linkage.h\"\n\n#include \"src/builtins/builtins-descriptors.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/frame.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/osr.h\"\n#include \"src/compiler/pipeline.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/compiler/wasm-compiler-definitions.h\"\n#endif\n        ]]></code>\n    </imports>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8::internal::compiler\",\n            \"purpose\": \"Encloses all compiler-related code within the V8 namespace.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n        ]]></code>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"(anonymous)\",\n            \"purpose\": \"Contains helper functions with file scope.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\n// Offsets from callee to caller frame, in slots.\nconstexpr int kFirstCallerSlotOffset = 1;\nconstexpr int kNoCallerSlotOffset = 0;\n\ninline LinkageLocation regloc(Register reg, MachineType type) {\n  return LinkageLocation::ForRegister(reg.code(), type);\n}\n\ninline LinkageLocation regloc(DoubleRegister reg, MachineType type) {\n  return LinkageLocation::ForRegister(reg.code(), type);\n}\n\n}  // namespace\n        ]]></code>\n    </namespace>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for CallDescriptor::Kind enum to provide string representation.\",\n            \"logic\": \"Uses a switch statement to output different strings based on the CallDescriptor::Kind enum value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream to write to.\"\n                },\n                {\n                    \"name\": \"k\",\n                    \"type\": \"const CallDescriptor::Kind&\",\n                    \"purpose\": \"The CallDescriptor::Kind enum value to output.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"Returns the modified output stream.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const CallDescriptor::Kind& k) {\n  switch (k) {\n    case CallDescriptor::kCallCodeObject:\n      os << \"Code\";\n      break;\n    case CallDescriptor::kCallJSFunction:\n      os << \"JS\";\n      break;\n    case CallDescriptor::kCallAddress:\n      os << \"Addr\";\n      break;\n#if V8_ENABLE_WEBASSEMBLY\n    case CallDescriptor::kCallWasmCapiFunction:\n      os << \"WasmExit\";\n      break;\n    case CallDescriptor::kCallWasmFunction:\n      os << \"WasmFunction\";\n      break;\n    case CallDescriptor::kCallWasmFunctionIndirect:\n      os << \"WasmFunctionIndirect\";\n      break;\n    case CallDescriptor::kCallWasmImportWrapper:\n      os << \"WasmImportWrapper\";\n      break;\n#endif  // V8_ENABLE_WEBASSEMBLY\n    case CallDescriptor::kCallBuiltinPointer:\n      os << \"BuiltinPointer\";\n      break;\n  }\n  return os;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for CallDescriptor class to provide a concise string representation.\",\n            \"logic\": \"Outputs the CallDescriptor kind, debug name, return count, parameter slot count, input count, and frame state count to the stream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream to write to.\"\n                },\n                {\n                    \"name\": \"d\",\n                    \"type\": \"const CallDescriptor&\",\n                    \"purpose\": \"The CallDescriptor object to output.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"Returns the modified output stream.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const CallDescriptor& d) {\n  // TODO(svenpanne) Output properties etc. and be less cryptic.\n  return os << d.kind() << \":\" << d.debug_name() << \":r\" << d.ReturnCount()\n            << \"s\" << d.ParameterSlotCount() << \"i\" << d.InputCount() << \"f\"\n            << d.FrameStateCount();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetMachineSignature\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Creates and returns a MachineSignature object based on the CallDescriptor's return and parameter types.\",\n            \"logic\": \"Allocates an array to store return and parameter MachineTypes. Populates the array and creates a new MachineSignature object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"Memory allocation zone.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MachineSignature*\",\n                \"description\": \"Pointer to a newly created MachineSignature object.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nMachineSignature* CallDescriptor::GetMachineSignature(Zone* zone) const {\n  size_t param_count = ParameterCount();\n  size_t return_count = ReturnCount();\n  MachineType* types =\n      zone->AllocateArray<MachineType>(param_count + return_count);\n  int current = 0;\n  for (size_t i = 0; i < return_count; ++i) {\n    types[current++] = GetReturnType(i);\n  }\n  for (size_t i = 0; i < param_count; ++i) {\n    types[current++] = GetParameterType(i);\n  }\n  return zone->New<MachineSignature>(return_count, param_count, types);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetStackParameterDelta\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Computes the difference in stack parameter offsets between two CallDescriptors, used for tail call optimization.\",\n            \"logic\": \"Calculates the difference in offset to returns between two call descriptors, taking into account argument padding. Returns 0 for TailCallForTierUp.\",\n            \"parameters\": [\n                {\n                    \"name\": \"tail_caller\",\n                    \"type\": \"CallDescriptor const*\",\n                    \"purpose\": \"The calling CallDescriptor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The stack parameter delta.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nint CallDescriptor::GetStackParameterDelta(\n    CallDescriptor const* tail_caller) const {\n  // In the IsTailCallForTierUp case, the callee has\n  // identical linkage and runtime arguments to the caller, thus the stack\n  // parameter delta is 0. We don't explicitly pass the runtime arguments as\n  // inputs to the TailCall node, since they already exist on the stack.\n  if (IsTailCallForTierUp()) return 0;\n\n  // Add padding if necessary before computing the stack parameter delta.\n  int callee_slots_above_sp = AddArgumentPaddingSlots(GetOffsetToReturns());\n  int tail_caller_slots_above_sp =\n      AddArgumentPaddingSlots(tail_caller->GetOffsetToReturns());\n  int stack_param_delta = callee_slots_above_sp - tail_caller_slots_above_sp;\n  DCHECK(!ShouldPadArguments(stack_param_delta));\n  return stack_param_delta;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetOffsetToFirstUnusedStackSlot\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Determines the offset to the first unused stack slot relative to the callee's frame.\",\n            \"logic\": \"Iterates through the input locations of the CallDescriptor, finding the maximum offset needed to store the input parameters on the stack.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The offset to the first unused stack slot.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nint CallDescriptor::GetOffsetToFirstUnusedStackSlot() const {\n  int offset = kFirstCallerSlotOffset;\n  for (size_t i = 0; i < InputCount(); ++i) {\n    LinkageLocation operand = GetInputLocation(i);\n    if (!operand.IsRegister()) {\n      DCHECK(operand.IsCallerFrameSlot());\n      int slot_offset = -operand.GetLocation();\n      offset = std::max(offset, slot_offset + operand.GetSizeInPointers());\n    }\n  }\n  return offset;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetOffsetToReturns\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Calculates the offset to the return slots relative to the callee's frame.\",\n            \"logic\": \"First attempts to find explicit return slots. If no explicit return slots are found, it calculates the offset based on parameter area size and padding.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The offset to the return slots.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nint CallDescriptor::GetOffsetToReturns() const {\n  // Find the return slot with the least offset relative to the callee.\n  int offset = kNoCallerSlotOffset;\n  for (size_t i = 0; i < ReturnCount(); ++i) {\n    LinkageLocation operand = GetReturnLocation(i);\n    if (!operand.IsRegister()) {\n      DCHECK(operand.IsCallerFrameSlot());\n      int slot_offset = -operand.GetLocation();\n      offset = std::min(offset, slot_offset);\n    }\n  }\n  // If there was a return slot, return the offset minus 1 slot.\n  if (offset != kNoCallerSlotOffset) {\n    return offset - 1;\n  }\n\n  // Otherwise, return the first slot after the parameters area, including\n  // optional padding slots.\n  int last_argument_slot = GetOffsetToFirstUnusedStackSlot() - 1;\n  offset = AddArgumentPaddingSlots(last_argument_slot);\n\n  DCHECK_IMPLIES(offset == 0, ParameterSlotCount() == 0);\n  return offset;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetTaggedParameterSlots\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Calculates the number of tagged parameter slots and the offset to the first one.\",\n            \"logic\": \"Iterates over input locations to find tagged parameters and calculates their offset. Packs the offset and count into a single uint32_t value.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"uint32_t\",\n                \"description\": \"A uint32_t where the upper 16 bits are the offset, and lower 16 bits are the number of tagged parameters.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nuint32_t CallDescriptor::GetTaggedParameterSlots() const {\n  uint32_t count = 0;\n  uint32_t untagged_count = 0;\n  uint32_t first_offset = kMaxInt;\n  for (size_t i = 0; i < InputCount(); ++i) {\n    LinkageLocation operand = GetInputLocation(i);\n    if (!operand.IsRegister()) {\n      if (operand.GetType().IsTagged()) {\n        ++count;\n        // Caller frame slots have negative indices and start at -1. Flip it\n        // back to a positive offset (to be added to the frame's SP to find the\n        // slot).\n        int slot_offset = -operand.GetLocation() - 1;\n        DCHECK_GE(slot_offset, 0);\n        first_offset =\n            std::min(first_offset, static_cast<uint32_t>(slot_offset));\n      } else {\n        untagged_count += operand.GetSizeInPointers();\n      }\n    }\n  }\n  if (count == 0) {\n    // If we don't have any tagged parameter slots, still initialize the offset\n    // to point past the untagged parameter slots, so that\n    // offset + count == stack slot count.\n    first_offset = untagged_count;\n  }\n  DCHECK(first_offset != kMaxInt);\n  return (first_offset << 16) | (count & 0xFFFFu);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CanTailCall\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Determines whether a tail call can be performed from the current CallDescriptor to the given callee CallDescriptor.\",\n            \"logic\": \"Checks return count and return location compatibility to determine if tail call is possible.\",\n            \"parameters\": [\n                {\n                    \"name\": \"callee\",\n                    \"type\": \"const CallDescriptor*\",\n                    \"purpose\": \"The callee CallDescriptor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a tail call can be performed, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"LinkageLocation::IsSameLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool CallDescriptor::CanTailCall(const CallDescriptor* callee) const {\n  if (ReturnCount() != callee->ReturnCount()) return false;\n  const int stack_returns_delta =\n      GetOffsetToReturns() - callee->GetOffsetToReturns();\n  for (size_t i = 0; i < ReturnCount(); ++i) {\n    if (GetReturnLocation(i).IsCallerFrameSlot() &&\n        callee->GetReturnLocation(i).IsCallerFrameSlot()) {\n      if (GetReturnLocation(i).AsCallerFrameSlot() + stack_returns_delta !=\n          callee->GetReturnLocation(i).AsCallerFrameSlot()) {\n        return false;\n      }\n    } else if (!LinkageLocation::IsSameLocation(GetReturnLocation(i),\n                                                callee->GetReturnLocation(i))) {\n      return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CalculateFixedFrameSize\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Calculates the fixed frame size based on the CallDescriptor's kind and CodeKind.\",\n            \"logic\": \"Uses a switch statement based on the kind_ member to determine the frame size.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code_kind\",\n                    \"type\": \"CodeKind\",\n                    \"purpose\": \"The code kind of the function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The fixed frame size in slots.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nint CallDescriptor::CalculateFixedFrameSize(CodeKind code_kind) const {\n  switch (kind_) {\n    case kCallJSFunction:\n      return StandardFrameConstants::kFixedSlotCount;\n    case kCallAddress:\n#if V8_ENABLE_WEBASSEMBLY\n      if (code_kind == CodeKind::C_WASM_ENTRY) {\n        return CWasmEntryFrameConstants::kFixedSlotCount;\n      }\n#endif  // V8_ENABLE_WEBASSEMBLY\n      return CommonFrameConstants::kFixedSlotCountAboveFp +\n             CommonFrameConstants::kCPSlotCount;\n    case kCallCodeObject:\n    case kCallBuiltinPointer:\n      return TypedFrameConstants::kFixedSlotCount;\n#if V8_ENABLE_WEBASSEMBLY\n    case kCallWasmFunction:\n    case kCallWasmFunctionIndirect:\n    case kCallWasmImportWrapper:\n      return WasmFrameConstants::kFixedSlotCount;\n    case kCallWasmCapiFunction:\n      return WasmExitFrameConstants::kFixedSlotCount;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"signature_hash\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Returns the signature hash, used for indirect wasm function calls.\",\n            \"logic\": \"Simply returns the value of the signature_hash_ member.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"uint64_t\",\n                \"description\": \"The signature hash.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nuint64_t CallDescriptor::signature_hash() const {\n#if V8_ENABLE_WEBASSEMBLY\n  DCHECK_EQ(kind_, kCallWasmFunctionIndirect);\n#endif\n  return signature_hash_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ToEncodedCSignature\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Encodes the signature of a C function call into a compact representation.\",\n            \"logic\": \"Iterates through the parameters and return values, setting flags based on whether they are floating-point types. Stores result in EncodedCSignature.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"EncodedCSignature\",\n                \"description\": \"The encoded C signature.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nEncodedCSignature CallDescriptor::ToEncodedCSignature() const {\n  int parameter_count = static_cast<int>(ParameterCount());\n  EncodedCSignature sig(parameter_count);\n  CHECK_LT(parameter_count, EncodedCSignature::kInvalidParamCount);\n\n  for (int i = 0; i < parameter_count; ++i) {\n    if (IsFloatingPoint(GetParameterType(i).representation())) {\n      sig.SetFloat(i);\n    }\n  }\n  if (ReturnCount() > 0) {\n    DCHECK_EQ(1, ReturnCount());\n    if (IsFloatingPoint(GetReturnType(0).representation())) {\n      if (GetReturnType(0).representation() ==\n          MachineRepresentation::kFloat64) {\n        sig.SetReturnFloat64();\n      } else {\n        sig.SetReturnFloat32();\n      }\n    }\n  }\n  return sig;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeParamCounts\",\n            \"parent\": \"CallDescriptor\",\n            \"about\": \"Counts the number of general-purpose and floating-point parameters in the CallDescriptor.\",\n            \"logic\": \"Iterates through the parameters, incrementing the appropriate counter based on the MachineRepresentation.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CallDescriptor::ComputeParamCounts() const {\n  gp_param_count_ = 0;\n  fp_param_count_ = 0;\n  for (size_t i = 0; i < ParameterCount(); ++i) {\n    if (IsFloatingPoint(GetParameterType(i).representation())) {\n      ++fp_param_count_.value();\n    } else {\n      ++gp_param_count_.value();\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"(anonymous)\",\n            \"purpose\": \"Contains helper functions specific for WebAssembly related CallDescriptor manipulations.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\nnamespace {\nCallDescriptor* ReplaceTypeInCallDescriptorWith(\n    Zone* zone, const CallDescriptor* call_descriptor, size_t num_replacements,\n    MachineType from, MachineType to) {\n  // The last parameter may be the special callable parameter. In that case we\n  // have to preserve it as the last parameter, i.e. we allocate it in the new\n  // location signature again in the same register.\n  bool extra_callable_param =\n      (call_descriptor->GetInputLocation(call_descriptor->InputCount() - 1) ==\n       LinkageLocation::ForRegister(kJSFunctionRegister.code(),\n                                    MachineType::TaggedPointer()));\n\n  size_t return_count = call_descriptor->ReturnCount();\n  // To recover the function parameter count, disregard the instance parameter,\n  // and the extra callable parameter if present.\n  size_t parameter_count =\n      call_descriptor->ParameterCount() - (extra_callable_param ? 2 : 1);\n\n  // Precompute if the descriptor contains {from}.\n  bool needs_change = false;\n  for (size_t i = 0; !needs_change && i < return_count; i++) {\n    needs_change = call_descriptor->GetReturnType(i) == from;\n  }\n  for (size_t i = 1; !needs_change && i < parameter_count + 1; i++) {\n    needs_change = call_descriptor->GetParameterType(i) == from;\n  }\n  if (!needs_change) return const_cast<CallDescriptor*>(call_descriptor);\n\n  std::vector<MachineType> reps;\n\n  for (size_t i = 0, limit = return_count; i < limit; i++) {\n    MachineType initial_type = call_descriptor->GetReturnType(i);\n    if (initial_type == from) {\n      for (size_t j = 0; j < num_replacements; j++) reps.push_back(to);\n      return_count += num_replacements - 1;\n    } else {\n      reps.push_back(initial_type);\n    }\n  }\n\n  // Disregard the instance (first) parameter.\n  for (size_t i = 1, limit = parameter_count + 1; i < limit; i++) {\n    MachineType initial_type = call_descriptor->GetParameterType(i);\n    if (initial_type == from) {\n      for (size_t j = 0; j < num_replacements; j++) reps.push_back(to);\n      parameter_count += num_replacements - 1;\n    } else {\n      reps.push_back(initial_type);\n    }\n  }\n\n  MachineSignature sig(return_count, parameter_count, reps.data());\n\n  int parameter_slots;\n  int return_slots;\n  LocationSignature* location_sig = BuildLocations(\n      zone, &sig, extra_callable_param, &parameter_slots, &return_slots);\n\n  return zone->New<CallDescriptor>(               // --\n      call_descriptor->kind(),                    // kind\n      call_descriptor->tag(),                     // tag\n      call_descriptor->GetInputType(0),           // target MachineType\n      call_descriptor->GetInputLocation(0),       // target location\n      location_sig,                               // location_sig\n      parameter_slots,                            // parameter slot count\n      call_descriptor->properties(),              // properties\n      call_descriptor->CalleeSavedRegisters(),    // callee-saved registers\n      call_descriptor->CalleeSavedFPRegisters(),  // callee-saved fp regs\n      call_descriptor->flags(),                   // flags\n      call_descriptor->debug_name(),              // debug name\n      call_descriptor->GetStackArgumentOrder(),   // stack order\n      call_descriptor->AllocatableRegisters(),    // allocatable registers\n      return_slots,                               // return slot count\n      call_descriptor->IsIndirectWasmFunctionCall()\n          ? call_descriptor->signature_hash()\n          : kInvalidWasmSignatureHash);  // signature hash\n}\n}  // namespace\n        ]]></code>\n    </namespace>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetI32WasmCallDescriptor\",\n            \"about\": \"Replaces MachineType::Int64() with MachineType::Int32() in a call descriptor for WebAssembly calls.\",\n            \"logic\": \"Calls ReplaceTypeInCallDescriptorWith to perform the replacement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"Memory allocation zone.\"\n                },\n                {\n                    \"name\": \"call_descriptor\",\n                    \"type\": \"const CallDescriptor*\",\n                    \"purpose\": \"The original call descriptor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CallDescriptor*\",\n                \"description\": \"A new CallDescriptor with the replaced types.\"\n            },\n            \"dependencies\": [\n                \"ReplaceTypeInCallDescriptorWith\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCallDescriptor* GetI32WasmCallDescriptor(\n    Zone* zone, const CallDescriptor* call_descriptor) {\n  return ReplaceTypeInCallDescriptorWith(\n      zone, call_descriptor, 2, MachineType::Int64(), MachineType::Int32());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ComputeIncoming\",\n            \"parent\": \"Linkage\",\n            \"about\": \"Computes the incoming CallDescriptor for a compiled function.\",\n            \"logic\": \"Determines if the compilation is for a JS function or other type, and returns the appropriate CallDescriptor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"Memory allocation zone.\"\n                },\n                {\n                    \"name\": \"info\",\n                    \"type\": \"OptimizedCompilationInfo*\",\n                    \"purpose\": \"Compilation information.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CallDescriptor*\",\n                \"description\": \"The incoming CallDescriptor.\"\n            },\n            \"dependencies\": [\n                \"GetJSCallDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCallDescriptor* Linkage::ComputeIncoming(Zone* zone,\n                                         OptimizedCompilationInfo* info) {\n#if V8_ENABLE_WEBASSEMBLY\n  DCHECK(info->IsOptimizing() || info->IsWasm());\n#else\n  DCHECK(info->IsOptimizing());\n#endif  // V8_ENABLE_WEBASSEMBLY\n  if (!info->closure().is_null()) {\n    // If we are compiling a JS function, use a JS call descriptor,\n    // plus the receiver.\n    DCHECK(info->has_bytecode_array());\n    DCHECK_EQ(info->closure()\n                  ->shared()\n                  ->internal_formal_parameter_count_with_receiver(),\n              info->bytecode_array()->parameter_count());\n    return GetJSCallDescriptor(zone, info->is_osr(),\n                               info->bytecode_array()->parameter_count(),\n                               CallDescriptor::kCanUseRoots);\n  }\n  return nullptr;  // TODO(titzer): ?\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"NeedsFrameStateInput\",\n            \"parent\": \"Linkage\",\n            \"about\": \"Determines if a Runtime function needs a FrameState input based on the Runtime::FunctionId.\",\n            \"logic\": \"Uses a switch statement to allowlist Runtime functions that are safe to call without a FrameState.\",\n            \"parameters\": [\n                {\n                    \"name\": \"function\",\n                    \"type\": \"Runtime::FunctionId\",\n                    \"purpose\": \"The ID of the Runtime function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a FrameState input is needed, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nbool Linkage::NeedsFrameStateInput(Runtime::FunctionId function) {\n  switch (function) {\n    // Most runtime functions need a FrameState. A few chosen ones that we know\n    // not to call into arbitrary JavaScript, not to throw, and not to lazily\n    // deoptimize are allowlisted here and can be called without a FrameState.\n    case Runtime::kAbort:\n    case Runtime::kAllocateInOldGeneration:\n    case Runtime::kCreateIterResultObject:\n    case Runtime::kGrowableSharedArrayBufferByteLength:\n    case Runtime::kIncBlockCounter:\n    case Runtime::kNewClosure:\n    case Runtime::kNewClosure_Tenured:\n    case Runtime::kNewFunctionContext:\n    case Runtime::kPushBlockContext:\n    case Runtime::kPushCatchContext:\n    case Runtime::kStringEqual:\n    case Runtime::kStringLessThan:\n    case Runtime::kStringLessThanOrEqual:\n    case Runtime::kStringGreaterThan:\n    case Runtime::kStringGreaterThanOrEqual:\n    case Runtime::kToFastProperties:  // TODO(conradw): Is it safe?\n    case Runtime::kTraceEnter:\n    case Runtime::kTraceExit:\n      return false;\n\n    // Some inline intrinsics are also safe to call without a FrameState.\n    case Runtime::kInlineCreateIterResultObject:\n    case Runtime::kInlineIncBlockCounter:\n    case Runtime::kInlineGeneratorClose:\n    case Runtime::kInlineGeneratorGetResumeMode:\n    case Runtime::kInlineCreateJSGeneratorObject:\n      return false;\n\n    default:\n      break;\n  }\n\n  // For safety, default to needing a FrameState unless allowlisted.\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetRuntimeCallDescriptor\",\n            \"parent\": \"Linkage\",\n            \"about\": \"Creates a CallDescriptor for a call to a Runtime function.\",\n            \"logic\": \"Determines if a FrameState input is needed, then calls GetCEntryStubCallDescriptor to create the CallDescriptor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"Memory allocation zone.\"\n                },\n                {\n                    \"name\": \"function_id\",\n                    \"type\": \"Runtime::FunctionId\",\n                    \"purpose\": \"The ID of the Runtime function.\"\n                },\n                {\n                    \"name\": \"js_parameter_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of JS parameters.\"\n                },\n                {\n                    \"name\": \"properties\",\n                    \"type\": \"Operator::Properties\",\n                    \"purpose\": \"Operator properties.\"\n                },\n                {\n                    \"name\": \"flags\",\n                    \"type\": \"CallDescriptor::Flags\",\n                    \"purpose\": \"Call descriptor flags.\"\n                },\n                {\n                    \"name\": \"lazy_deopt_on_throw\",\n                    \"type\": \"LazyDeoptOnThrow\",\n                    \"purpose\": \"Indicates whether to lazily deoptimize on throw.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CallDescriptor*\",\n                \"description\": \"The CallDescriptor for the Runtime function call.\"\n            },\n            \"dependencies\": [\n                \"NeedsFrameStateInput\",\n                \"GetCEntryStubCallDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCallDescriptor* Linkage::GetRuntimeCallDescriptor(\n    Zone* zone, Runtime::FunctionId function_id, int js_parameter_count,\n    Operator::Properties properties, CallDescriptor::Flags"
}