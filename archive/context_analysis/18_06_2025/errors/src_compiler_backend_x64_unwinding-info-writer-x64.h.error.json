{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/x64/unwinding-info-writer-x64.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 59, column 63",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/x64/unwinding-info-writer-x64.h\",\n        \"file_name\": \"unwinding-info-writer-x64.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the UnwindingInfoWriter class for generating eh_frame unwinding information on x64 architecture.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for eh-frame writing and feature flags.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/diagnostics/eh-frame.h\"\n#include \"src/flags/flags.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"UnwindingInfoWriter\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Writes unwinding information for generated code to assist debuggers and exception handling.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory zone for allocations.\"\n                },\n                {\n                    \"name\": \"eh_frame_writer_\",\n                    \"type\": \"EhFrameWriter\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Writer for the eh_frame data.\"\n                },\n                {\n                    \"name\": \"tracking_fp_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the frame pointer is being tracked.\"\n                },\n                {\n                    \"name\": \"block_will_exit_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the current instruction block will exit.\"\n                },\n                {\n                    \"name\": \"block_initial_states_\",\n                    \"type\": \"ZoneVector<const BlockInitialState*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the initial state of each instruction block.\"\n                }\n            ],\n            \"dependencies\": [\n                \"EhFrameWriter\",\n                \"Zone\",\n                \"InstructionBlock\",\n                \"ZoneVector\",\n                \"BlockInitialState\",\n                \"v8_flags\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass UnwindingInfoWriter {\n public:\n  explicit UnwindingInfoWriter(Zone* zone)\n      : zone_(zone),\n        eh_frame_writer_(zone),\n        tracking_fp_(false),\n        block_will_exit_(false),\n        block_initial_states_(zone) {\n    if (enabled()) eh_frame_writer_.Initialize();\n  }\n\n  void MaybeIncreaseBaseOffsetAt(int pc_offset, int base_delta) {\n    if (enabled() && !tracking_fp_) {\n      eh_frame_writer_.AdvanceLocation(pc_offset);\n      eh_frame_writer_.IncreaseBaseAddressOffset(base_delta);\n    }\n  }\n\n  void SetNumberOfInstructionBlocks(int number) {\n    if (enabled()) block_initial_states_.resize(number);\n  }\n\n  void BeginInstructionBlock(int pc_offset, const InstructionBlock* block);\n  void EndInstructionBlock(const InstructionBlock* block);\n\n  void MarkFrameConstructed(int pc_base);\n  void MarkFrameDeconstructed(int pc_base);\n\n  void MarkBlockWillExit() { block_will_exit_ = true; }\n\n  void Finish(int code_size) {\n    if (enabled()) eh_frame_writer_.Finish(code_size);\n  }\n\n  EhFrameWriter* eh_frame_writer() {\n    return enabled() ? &eh_frame_writer_ : nullptr;\n  }\n\n private:\n  bool enabled() const { return v8_flags.perf_prof_unwinding_info; }\n\n  class BlockInitialState : public ZoneObject {\n   public:\n    BlockInitialState(Register reg, int offset, bool tracking_fp)\n        : register_(reg), offset_(offset), tracking_fp_(tracking_fp) {}\n\n    Register register_;\n    int offset_;\n    bool tracking_fp_;\n  };\n\n  Zone* zone_;\n  EhFrameWriter eh_frame_writer_;\n  bool tracking_fp_;\n  bool block_will_exit_;\n\n  ZoneVector<const BlockInitialState*> block_initial_states_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UnwindingInfoWriter\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Constructor for the UnwindingInfoWriter.\",\n            \"logic\": \"Initializes the writer with a memory zone, eh_frame writer, and sets initial states.  Conditionally initializes the eh_frame writer if unwinding info generation is enabled via a flag.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone to use for allocations.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"EhFrameWriter\",\n                \"enabled\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  explicit UnwindingInfoWriter(Zone* zone)\n      : zone_(zone),\n        eh_frame_writer_(zone),\n        tracking_fp_(false),\n        block_will_exit_(false),\n        block_initial_states_(zone) {\n    if (enabled()) eh_frame_writer_.Initialize();\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MaybeIncreaseBaseOffsetAt\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Increases the base offset in the eh_frame writer if unwinding info is enabled and not currently tracking the frame pointer.\",\n            \"logic\": \"Conditionally advances the eh_frame location and increases the base address offset in the eh_frame writer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pc_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Program counter offset.\"\n                },\n                {\n                    \"name\": \"base_delta\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Delta to increase the base address offset by.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"enabled\",\n                \"tracking_fp_\",\n                \"eh_frame_writer_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void MaybeIncreaseBaseOffsetAt(int pc_offset, int base_delta) {\n    if (enabled() && !tracking_fp_) {\n      eh_frame_writer_.AdvanceLocation(pc_offset);\n      eh_frame_writer_.IncreaseBaseAddressOffset(base_delta);\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetNumberOfInstructionBlocks\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Sets the number of instruction blocks to reserve space for initial states.\",\n            \"logic\": \"Resizes the block_initial_states_ vector if unwinding info generation is enabled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"number\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of instruction blocks.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"enabled\",\n                \"block_initial_states_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void SetNumberOfInstructionBlocks(int number) {\n    if (enabled()) block_initial_states_.resize(number);\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BeginInstructionBlock\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Marks the beginning of an instruction block.\",\n            \"logic\": \"Implementation is not provided in the header file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pc_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Program counter offset.\"\n                },\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const InstructionBlock*\",\n                    \"purpose\": \"The instruction block being started.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionBlock\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void BeginInstructionBlock(int pc_offset, const InstructionBlock* block);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EndInstructionBlock\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Marks the end of an instruction block.\",\n            \"logic\": \"Implementation is not provided in the header file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const InstructionBlock*\",\n                    \"purpose\": \"The instruction block being ended.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstructionBlock\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void EndInstructionBlock(const InstructionBlock* block);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkFrameConstructed\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Marks when a stack frame is constructed.\",\n            \"logic\": \"Implementation is not provided in the header file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pc_base\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Program counter base.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void MarkFrameConstructed(int pc_base);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkFrameDeconstructed\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Marks when a stack frame is deconstructed.\",\n            \"logic\": \"Implementation is not provided in the header file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pc_base\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Program counter base.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void MarkFrameDeconstructed(int pc_base);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MarkBlockWillExit\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Marks that the current block will exit.\",\n            \"logic\": \"Sets the block_will_exit_ flag to true.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void MarkBlockWillExit() { block_will_exit_ = true; }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Finish\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Finalizes the eh_frame writing process.\",\n            \"logic\": \"Conditionally finishes the eh_frame writing process if unwinding info generation is enabled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code_size\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The size of the generated code.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"enabled\",\n                \"eh_frame_writer_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void Finish(int code_size) {\n    if (enabled()) eh_frame_writer_.Finish(code_size);\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"eh_frame_writer\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Returns a pointer to the eh_frame writer.\",\n            \"logic\": \"Conditionally returns a pointer to the eh_frame writer if unwinding info generation is enabled, otherwise returns nullptr.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"EhFrameWriter*\",\n                \"description\": \"Pointer to the eh_frame writer, or nullptr if unwinding info is disabled.\"\n            },\n            \"dependencies\": [\n                \"enabled\",\n                \"eh_frame_writer_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  EhFrameWriter* eh_frame_writer() {\n    return enabled() ? &eh_frame_writer_ : nullptr;\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"enabled\",\n            \"parent\": \"UnwindingInfoWriter\",\n            \"about\": \"Determines whether unwinding info generation is enabled.\",\n            \"logic\": \"Checks the v8_flags.perf_prof_unwinding_info flag.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if unwinding info generation is enabled, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"v8_flags\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  bool enabled() const { return v8_flags.perf_prof_unwinding_info; }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BlockInitialState\",\n            \"extends\": \"ZoneObject\",\n            \"implements\": [],\n            \"about\": \"Represents the initial state of an instruction block.\",\n            \"attributes\": [\n                {\n                    \"name\": \"register_\",\n                    \"type\": \"Register\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The register.\"\n                },\n                {\n                    \"name\": \"offset_\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The offset.\"\n                },\n                {\n                    \"name\": \"tracking_fp_\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates whether the frame pointer is being tracked.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"Register\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class BlockInitialState : public ZoneObject {\n   public:\n    BlockInitialState(Register reg, int offset, bool tracking_fp)\n        : register_(reg), offset_(offset), tracking_fp_(tracking_fp) {}\n\n    Register register_;\n    int offset_;\n    bool tracking_fp_;\n  };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BlockInitialState\",\n            \"parent\": \"BlockInitialState\",\n            \"about\": \"Constructor for BlockInitialState.\",\n            \"logic\": \"Initializes a BlockInitialState with the given register, offset, and tracking_fp status.\",\n            \"parameters\": [\n                {\n                    \"name\": \"reg\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The initial register value.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The initial offset value.\"\n                },\n                {\n                    \"name\": \"tracking_fp\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"The initial tracking_fp value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Register\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n    BlockInitialState(Register reg, int offset, bool tracking_fp)\n        : register_(reg), offset_(offset), tracking_fp_(tracking_fp) {}\n        ]]></code>\n    </func>\n</file>\n```"
}