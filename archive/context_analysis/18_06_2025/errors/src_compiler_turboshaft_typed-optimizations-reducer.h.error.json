{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/typed-optimizations-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 92, column 44",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/typed-optimizations-reducer.h\",\n        \"file_name\": \"typed-optimizations-reducer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the TypedOptimizationsReducer, which performs optimizations based on type information in the Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for assembler, index, operations, typer, and uniform reducer adapter.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/typer.h\"\n#include \"src/compiler/turboshaft/uniform-reducer-adapter.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypedOptimizationsReducer\",\n            \"extends\": \"UniformReducerAdapter\",\n            \"about\": \"A reducer that performs optimizations based on type information.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"UniformReducerAdapter\",\n                \"TypeInferenceReducer\",\n                \"Type\",\n                \"OpIndex\",\n                \"BranchOp\",\n                \"Typer\",\n                \"Block\",\n                \"Assembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Next>\nclass TypedOptimizationsReducer\n    : public UniformReducerAdapter<TypedOptimizationsReducer, Next> {\n#if defined(__clang__)\n  // Typed optimizations require a typed graph.\n  static_assert(next_contains_reducer<Next, TypeInferenceReducer>::value);\n#endif\n\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(TypedOptimizations)\n\n  using Adapter = UniformReducerAdapter<TypedOptimizationsReducer, Next>;\n\n  OpIndex ReduceInputGraphBranch(OpIndex ig_index, const BranchOp& operation);\n\n  template <typename Op, typename Continuation>\n  OpIndex ReduceInputGraphOperation(OpIndex ig_index, const Op& operation);\n\n private:\n  // If {type} is a single value that can be respresented by a constant, this\n  // function returns the index for a corresponding ConstantOp. It returns\n  // OpIndex::Invalid otherwise.\n  OpIndex TryAssembleConstantForType(const Type& type);\n\n  Type GetType(const OpIndex index);\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceInputGraphBranch\",\n            \"parent\": \"TypedOptimizationsReducer\",\n            \"about\": \"Reduces a branch operation based on its condition's type.\",\n            \"logic\": \"Checks if the condition's type is known. If it's None, the branch is unreachable. If it's a constant, the branch is replaced by a goto to the appropriate target block.\",\n            \"parameters\": [\n                {\n                    \"name\": \"ig_index\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the branch operation in the input graph.\"\n                },\n                {\n                    \"name\": \"operation\",\n                    \"type\": \"const BranchOp&\",\n                    \"purpose\": \"The branch operation to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"OpIndex\",\n                \"description\": \"The index of the reduced operation (OpIndex::Invalid if the operation was removed or replaced, otherwise the original index).\"\n            },\n            \"dependencies\": [\n                \"Type\",\n                \"GetType\",\n                \"IsInvalid\",\n                \"IsNone\",\n                \"Asm\",\n                \"Unreachable\",\n                \"TruncateWord32Input\",\n                \"graph_zone\",\n                \"IsWord32\",\n                \"try_get_constant\",\n                \"Goto\",\n                \"MapToNewGraph\",\n                \"Adapter::ReduceInputGraphBranch\",\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  OpIndex ReduceInputGraphBranch(OpIndex ig_index, const BranchOp& operation) {\n    if (!ShouldSkipOptimizationStep()) {\n      Type condition_type = GetType(operation.condition());\n      if (!condition_type.IsInvalid()) {\n        if (condition_type.IsNone()) {\n          Asm().Unreachable();\n          return OpIndex::Invalid();\n        }\n        condition_type = Typer::TruncateWord32Input(condition_type, true,\n                                                    Asm().graph_zone());\n        DCHECK(condition_type.IsWord32());\n        if (auto c = condition_type.AsWord32().try_get_constant()) {\n          Block* goto_target = *c == 0 ? operation.if_false : operation.if_true;\n          Asm().Goto(Asm().MapToNewGraph(goto_target));\n          return OpIndex::Invalid();\n        }\n      }\n    }\n    return Adapter::ReduceInputGraphBranch(ig_index, operation);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceInputGraphOperation\",\n            \"parent\": \"TypedOptimizationsReducer\",\n            \"about\": \"Reduces a generic operation based on its type.\",\n            \"logic\": \"Checks if the operation's type is known. If it's None, the operation is unreachable. If it can be represented as a constant, the operation is replaced by the constant. Otherwise reduction continues.\",\n            \"parameters\": [\n                {\n                    \"name\": \"ig_index\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the operation in the input graph.\"\n                },\n                {\n                    \"name\": \"operation\",\n                    \"type\": \"const Op&\",\n                    \"purpose\": \"The operation to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"OpIndex\",\n                \"description\": \"The index of the reduced operation (OpIndex::Invalid if the operation was removed or replaced, otherwise the original index).\"\n            },\n            \"dependencies\": [\n                \"Type\",\n                \"GetType\",\n                \"IsNone\",\n                \"Asm\",\n                \"Unreachable\",\n                \"CanBeTyped\",\n                \"TryAssembleConstantForType\",\n                \"OpIndex\",\n                \"ReduceInputGraph\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  template <typename Op, typename Continuation>\n  OpIndex ReduceInputGraphOperation(OpIndex ig_index, const Op& operation) {\n    if (!ShouldSkipOptimizationStep()) {\n      Type type = GetType(ig_index);\n      if (type.IsNone()) {\n        // This operation is dead. Remove it.\n        DCHECK(CanBeTyped(operation));\n        Asm().Unreachable();\n        return OpIndex::Invalid();\n      } else if (!type.IsInvalid()) {\n        // See if we can replace the operation by a constant.\n        if (OpIndex constant = TryAssembleConstantForType(type);\n            constant.valid()) {\n          return constant;\n        }\n      }\n    }\n\n    // Otherwise just continue with reduction.\n    return Continuation{this}.ReduceInputGraph(ig_index, operation);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TryAssembleConstantForType\",\n            \"parent\": \"TypedOptimizationsReducer\",\n            \"about\": \"Tries to assemble a constant operation for a given type.\",\n            \"logic\": \"Checks the type kind and attempts to create a constant operation (Word32Constant, Word64Constant, Float32Constant, Float64Constant) if the type has a constant value. Returns OpIndex::Invalid if a constant cannot be assembled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"const Type&\",\n                    \"purpose\": \"The type for which to assemble a constant.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"OpIndex\",\n                \"description\": \"The index of the constant operation, or OpIndex::Invalid if a constant cannot be assembled.\"\n            },\n            \"dependencies\": [\n                \"Type\",\n                \"AsWord32\",\n                \"try_get_constant\",\n                \"Asm\",\n                \"Word32Constant\",\n                \"Word64Constant\",\n                \"AsWord64\",\n                \"AsFloat32\",\n                \"Float32Constant\",\n                \"nan_v\",\n                \"is_only_nan\",\n                \"is_only_minus_zero\",\n                \"AsFloat64\",\n                \"Float64Constant\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  OpIndex TryAssembleConstantForType(const Type& type) {\n    switch (type.kind()) {\n      case Type::Kind::kWord32: {\n        auto w32 = type.AsWord32();\n        if (auto c = w32.try_get_constant()) {\n          return Asm().Word32Constant(*c);\n        }\n        break;\n      }\n      case Type::Kind::kWord64: {\n        auto w64 = type.AsWord64();\n        if (auto c = w64.try_get_constant()) {\n          return Asm().Word64Constant(*c);\n        }\n        break;\n      }\n      case Type::Kind::kFloat32: {\n        auto f32 = type.AsFloat32();\n        if (f32.is_only_nan()) {\n          return Asm().Float32Constant(nan_v<32>);\n        } else if (f32.is_only_minus_zero()) {\n          return Asm().Float32Constant(-0.0f);\n        } else if (auto c = f32.try_get_constant()) {\n          return Asm().Float32Constant(*c);\n        }\n        break;\n      }\n      case Type::Kind::kFloat64: {\n        auto f64 = type.AsFloat64();\n        if (f64.is_only_nan()) {\n          return Asm().Float64Constant(nan_v<64>);\n        } else if (f64.is_only_minus_zero()) {\n          return Asm().Float64Constant(-0.0);\n        } else if (auto c = f64.try_get_constant()) {\n          return Asm().Float64Constant(*c);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    return OpIndex::Invalid();\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetType\",\n            \"parent\": \"TypedOptimizationsReducer\",\n            \"about\": \"Gets the type of an operation from the input graph.\",\n            \"logic\": \"Retrieves the type associated with the given operation index from the input graph's type information.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"const OpIndex\",\n                    \"purpose\": \"The index of the operation to get the type for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Type\",\n                \"description\": \"The type of the operation.\"\n            },\n            \"dependencies\": [\n                \"Asm\",\n                \"GetInputGraphType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  Type GetType(const OpIndex index) {\n    // Typed optimizations use the types of the input graph.\n    return Asm().GetInputGraphType(index);\n  }\n        ]]></code>\n    </func>\n</file>\n```"
}