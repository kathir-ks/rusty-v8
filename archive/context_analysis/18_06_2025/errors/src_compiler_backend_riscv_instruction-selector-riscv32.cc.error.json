{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/riscv/instruction-selector-riscv32.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/riscv/instruction-selector-riscv32.cc\",\n        \"file_name\": \"instruction-selector-riscv32.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"RISC-V 32-bit Instruction Selector implementation for the V8 compiler backend.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for bit manipulation, code generation, machine types, instruction selection, node matching, node properties, turboshaft operations, and opmasks.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/bits.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/compiler/backend/instruction-selector-impl.h\"\n#include \"src/compiler/backend/riscv/instruction-selector-riscv.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CanBeImmediate\",\n            \"parent\": \"RiscvOperandGeneratorT\",\n            \"about\": \"Determines if a given value can be used as an immediate operand for a specific RISC-V instruction.\",\n            \"logic\": \"Checks the opcode and determines the immediate value range based on the instruction type. Uses helper functions like is_uint5, is_int12, and is_int32.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The value to check.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the value can be used as an immediate, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool RiscvOperandGeneratorT::CanBeImmediate(int64_t value,\n                                            InstructionCode opcode) {\n  switch (ArchOpcodeField::decode(opcode)) {\n    case kRiscvShl32:\n    case kRiscvSar32:\n    case kRiscvShr32:\n      return is_uint5(value);\n    case kRiscvAdd32:\n    case kRiscvAnd32:\n    case kRiscvAnd:\n    case kRiscvOr32:\n    case kRiscvOr:\n    case kRiscvTst32:\n    case kRiscvXor:\n      return is_int12(value);\n    case kRiscvLb:\n    case kRiscvLbu:\n    case kRiscvSb:\n    case kRiscvLh:\n    case kRiscvLhu:\n    case kRiscvSh:\n    case kRiscvLw:\n    case kRiscvSw:\n    case kRiscvLoadFloat:\n    case kRiscvStoreFloat:\n    case kRiscvLoadDouble:\n    case kRiscvStoreDouble:\n      return is_int32(value);\n    default:\n      return is_int12(value);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"EmitLoad\",\n            \"about\": \"Emits the appropriate RISC-V load instruction based on the provided parameters.\",\n            \"logic\": \"Handles different addressing modes including immediate offsets, root register addressing, and register+register addressing.  It checks for external constant bases and root register loads for optimization. Uses InstructionSelectorT::Emit to generate the instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the load operation.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the load instruction.\"\n                },\n                {\n                    \"name\": \"output\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"Optional output node for merging conversions.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid EmitLoad(InstructionSelectorT* selector, OpIndex node,\n              InstructionCode opcode, OpIndex output = OpIndex()) {\n  RiscvOperandGeneratorT g(selector);\n  const Operation& op = selector->Get(node);\n  const LoadOp& load = op.Cast<LoadOp>();\n  // The LoadStoreSimplificationReducer transforms all loads into\n  // *(base + index).\n  OpIndex base = load.base();\n  OptionalOpIndex index = load.index();\n  DCHECK_EQ(load.offset, 0);\n  DCHECK_EQ(load.element_size_log2, 0);\n\n  InstructionOperand inputs[3];\n  size_t input_count = 0;\n  InstructionOperand output_op;\n\n  // If output is valid, use that as the output register. This is used when we\n  // merge a conversion into the load.\n  output_op = g.DefineAsRegister(output.valid() ? output : node);\n\n  const Operation& base_op = selector->Get(base);\n  if (base_op.Is<Opmask::kExternalConstant>() && g.IsIntegerConstant(index)) {\n    const ConstantOp& constant_base = base_op.Cast<ConstantOp>();\n    if (selector->CanAddressRelativeToRootsRegister(\n            constant_base.external_reference())) {\n      ptrdiff_t const delta =\n          *g.GetOptionalIntegerConstant(index.value()) +\n          MacroAssemblerBase::RootRegisterOffsetForExternalReference(\n              selector->isolate(), constant_base.external_reference());\n      input_count = 1;\n      // Check that the delta is a 32-bit integer due to the limitations of\n      // immediate operands.\n      if (is_int32(delta)) {\n        inputs[0] = g.UseImmediate(static_cast<int32_t>(delta));\n        opcode |= AddressingModeField::encode(kMode_Root);\n        selector->Emit(opcode, 1, &output_op, input_count, inputs);\n        return;\n      }\n    }\n  }\n\n  if (base_op.Is<LoadRootRegisterOp>()) {\n    DCHECK(g.IsIntegerConstant(index));\n    input_count = 1;\n    inputs[0] = g.UseImmediate64(*g.GetOptionalIntegerConstant(index.value()));\n    opcode |= AddressingModeField::encode(kMode_Root);\n    selector->Emit(opcode, 1, &output_op, input_count, inputs);\n    return;\n  }\n\n  if (load.index().has_value() && g.CanBeImmediate(index.value(), opcode)) {\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                   g.DefineAsRegister(output.valid() ? output : node),\n                   g.UseRegister(base), g.UseImmediate(index.value()));\n  } else {\n    if (index.has_value()) {\n      InstructionOperand addr_reg = g.TempRegister();\n      selector->Emit(kRiscvAdd32 | AddressingModeField::encode(kMode_None),\n                     addr_reg, g.UseRegister(index.value()),\n                     g.UseRegister(base));\n      // Emit desired load opcode, using temp addr_reg.\n      selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                     g.DefineAsRegister(output.valid() ? output : node),\n                     addr_reg, g.TempImmediate(0));\n    } else {\n      selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                     g.DefineAsRegister(output.valid() ? output : node),\n                     g.UseRegister(base), g.TempImmediate(0));\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"EmitS128Load\",\n            \"about\": \"Emits the appropriate RISC-V S128 (vector) load instruction based on the provided parameters.\",\n            \"logic\": \"Similar to EmitLoad, but specialized for S128 (Simd128) vector loads.  It handles immediate offsets and register+register addressing. Uses InstructionSelectorT::Emit to generate the instruction with sew and lmul configurations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the load operation.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the load instruction.\"\n                },\n                {\n                    \"name\": \"sew\",\n                    \"type\": \"VSew\",\n                    \"purpose\": \"Vector length configuration.\"\n                },\n                {\n                    \"name\": \"lmul\",\n                    \"type\": \"Vlmul\",\n                    \"purpose\": \"Vector multiply configuration.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid EmitS128Load(InstructionSelectorT* selector, OpIndex node,\n                  InstructionCode opcode, VSew sew, Vlmul lmul) {\n  RiscvOperandGeneratorT g(selector);\n  OpIndex base = selector->input_at(node, 0);\n  OpIndex index = selector->input_at(node, 1);\n\n  if (g.CanBeImmediate(index, opcode)) {\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                   g.DefineAsRegister(node), g.UseRegister(base),\n                   g.UseImmediate(index), g.UseImmediate(sew),\n                   g.UseImmediate(lmul));\n  } else {\n    InstructionOperand addr_reg = g.TempRegister();\n    selector->Emit(kRiscvAdd32 | AddressingModeField::encode(kMode_None),\n                   addr_reg, g.UseRegister(index), g.UseRegister(base));\n    // Emit desired load opcode, using temp addr_reg.\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                   g.DefineAsRegister(node), addr_reg, g.TempImmediate(0),\n                   g.UseImmediate(sew), g.UseImmediate(lmul));\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitStoreLane\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for storing a SIMD128 lane to memory.\",\n            \"logic\": \"Calculates the address using base and index registers, then emits a RISC-V vector store lane instruction with the lane size encoded in the opcode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the store lane operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitStoreLane(OpIndex node) {\n  const Simd128LaneMemoryOp& store = Get(node).Cast<Simd128LaneMemoryOp>();\n  InstructionCode opcode = kRiscvS128StoreLane;\n  opcode |= LaneSizeField::encode(store.lane_size() * kBitsPerByte);\n  if (store.kind.with_trap_handler) {\n    opcode |= AccessModeField::encode(kMemoryAccessProtectedMemOutOfBounds);\n  }\n\n  RiscvOperandGeneratorT g(this);\n  OpIndex base = this->input_at(node, 0);\n  OpIndex index = this->input_at(node, 1);\n  InstructionOperand addr_reg = g.TempRegister();\n  Emit(kRiscvAdd32, addr_reg, g.UseRegister(base), g.UseRegister(index));\n  InstructionOperand inputs[4] = {\n      g.UseRegister(input_at(node, 2)),\n      g.UseImmediate(store.lane),\n      addr_reg,\n      g.TempImmediate(0),\n  };\n  opcode |= AddressingModeField::encode(kMode_MRI);\n  Emit(opcode, 0, nullptr, 4, inputs);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitLoadLane\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for loading a SIMD128 lane from memory.\",\n            \"logic\": \"Calculates the address using base and index registers, then emits a RISC-V vector load lane instruction with the lane size encoded in the opcode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the load lane operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitLoadLane(OpIndex node) {\n  const Simd128LaneMemoryOp& load = this->Get(node).Cast<Simd128LaneMemoryOp>();\n  InstructionCode opcode = kRiscvS128LoadLane;\n  opcode |= LaneSizeField::encode(load.lane_size() * kBitsPerByte);\n  if (load.kind.with_trap_handler) {\n    opcode |= AccessModeField::encode(kMemoryAccessProtectedMemOutOfBounds);\n  }\n\n  RiscvOperandGeneratorT g(this);\n  OpIndex base = this->input_at(node, 0);\n  OpIndex index = this->input_at(node, 1);\n  InstructionOperand addr_reg = g.TempRegister();\n  Emit(kRiscvAdd32, addr_reg, g.UseRegister(base), g.UseRegister(index));\n  opcode |= AddressingModeField::encode(kMode_MRI);\n  Emit(opcode, g.DefineSameAsFirst(node),\n       g.UseRegister(this->input_at(node, 2)), g.UseImmediate(load.lane),\n       addr_reg, g.TempImmediate(0));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitLoad\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a memory load operation based on the data type being loaded.\",\n            \"logic\": \"Determines the appropriate RISC-V load opcode based on the LoadRepresentation, then calls EmitLoad to generate the instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the load operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"EmitLoad\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitLoad(OpIndex node) {\n  auto load = this->load_view(node);\n  LoadRepresentation load_rep = load.loaded_rep();\n  InstructionCode opcode = kArchNop;\n  switch (load_rep.representation()) {\n    case MachineRepresentation::kFloat32:\n      opcode = kRiscvLoadFloat;\n      break;\n    case MachineRepresentation::kFloat64:\n      opcode = kRiscvLoadDouble;\n      break;\n    case MachineRepresentation::kBit:  // Fall through.\n    case MachineRepresentation::kWord8:\n      opcode = load_rep.IsUnsigned() ? kRiscvLbu : kRiscvLb;\n      break;\n    case MachineRepresentation::kWord16:\n      opcode = load_rep.IsUnsigned() ? kRiscvLhu : kRiscvLh;\n      break;\n    case MachineRepresentation::kTaggedSigned:   // Fall through.\n    case MachineRepresentation::kTaggedPointer:  // Fall through.\n    case MachineRepresentation::kTagged:         // Fall through.\n    case MachineRepresentation::kWord32:\n      opcode = kRiscvLw;\n      break;\n    case MachineRepresentation::kSimd128:\n      opcode = kRiscvRvvLd;\n      break;\n    case MachineRepresentation::kCompressedPointer:\n    case MachineRepresentation::kCompressed:\n    case MachineRepresentation::kSandboxedPointer:\n    case MachineRepresentation::kMapWord:  // Fall through.\n    case MachineRepresentation::kWord64:\n    case MachineRepresentation::kNone:\n    case MachineRepresentation::kSimd256:  // Fall through.\n    case MachineRepresentation::kProtectedPointer:  // Fall through.\n    case MachineRepresentation::kIndirectPointer:\n    case MachineRepresentation::kFloat16:\n    case MachineRepresentation::kFloat16RawBits:\n      UNREACHABLE();\n    }\n\n    EmitLoad(this, node, opcode);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitStorePair\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a memory store pair operation.\",\n            \"logic\": \"Marks the function as unreachable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the store pair operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitStorePair(OpIndex node) { UNREACHABLE(); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitStore\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a memory store operation based on the data type being stored.\",\n            \"logic\": \"Determines the appropriate RISC-V store opcode based on the StoreRepresentation and handles write barriers if necessary. It also handles root register based stores and immediate offsets. Uses InstructionSelectorT::Emit to generate the instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the store operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitStore(OpIndex node) {\n  RiscvOperandGeneratorT g(this);\n  StoreView store_view = this->store_view(node);\n  OpIndex base = store_view.base();\n  OptionalOpIndex index = store_view.index();\n  OpIndex value = store_view.value();\n\n  WriteBarrierKind write_barrier_kind =\n      store_view.stored_rep().write_barrier_kind();\n  MachineRepresentation rep = store_view.stored_rep().representation();\n\n  // TODO(riscv): I guess this could be done in a better way.\n  if (write_barrier_kind != kNoWriteBarrier && index.has_value() &&\n      V8_LIKELY(!v8_flags.disable_write_barriers)) {\n    DCHECK(CanBeTaggedPointer(rep));\n    InstructionOperand inputs[4];\n    size_t input_count = 0;\n    inputs[input_count++] = g.UseUniqueRegister(base);\n    inputs[input_count++] = g.UseUniqueRegister(this->value(index));\n    inputs[input_count++] = g.UseUniqueRegister(value);\n    RecordWriteMode record_write_mode =\n        WriteBarrierKindToRecordWriteMode(write_barrier_kind);\n    InstructionOperand temps[] = {g.TempRegister(), g.TempRegister()};\n    size_t const temp_count = arraysize(temps);\n    InstructionCode code;\n    if (rep == MachineRepresentation::kIndirectPointer) {\n      DCHECK_EQ(write_barrier_kind, kIndirectPointerWriteBarrier);\n      // In this case we need to add the IndirectPointerTag as additional input.\n      code = kArchStoreIndirectWithWriteBarrier;\n      IndirectPointerTag tag = store_view.indirect_pointer_tag();\n      inputs[input_count++] = g.UseImmediate64(static_cast<int64_t>(tag));\n    } else {\n      code = kArchStoreWithWriteBarrier;\n    }\n    code |= RecordWriteModeField::encode(record_write_mode);\n    if (store_view.is_store_trap_on_null()) {\n      code |= AccessModeField::encode(kMemoryAccessProtectedNullDereference);\n    }\n    Emit(code, 0, nullptr, input_count, inputs, temp_count, temps);\n  } else {\n    InstructionCode code;\n    switch (rep) {\n      case MachineRepresentation::kFloat32:\n        code = kRiscvStoreFloat;\n        break;\n      case MachineRepresentation::kFloat64:\n        code = kRiscvStoreDouble;\n        break;\n      case MachineRepresentation::kBit:  // Fall through.\n      case MachineRepresentation::kWord8:\n        code = kRiscvSb;\n        break;\n      case MachineRepresentation::kWord16:\n        code = kRiscvSh;\n        break;\n      case MachineRepresentation::kTaggedSigned:   // Fall through.\n      case MachineRepresentation::kTaggedPointer:  // Fall through.\n      case MachineRepresentation::kTagged:\n      case MachineRepresentation::kWord32:\n        code = kRiscvSw;\n        break;\n      case MachineRepresentation::kSimd128:\n        code = kRiscvRvvSt;\n        break;\n      case MachineRepresentation::kCompressedPointer:  // Fall through.\n      case MachineRepresentation::kCompressed:\n      case MachineRepresentation::kSandboxedPointer:\n      case MachineRepresentation::kMapWord:  // Fall through.\n      case MachineRepresentation::kNone:\n      case MachineRepresentation::kWord64:\n      case MachineRepresentation::kSimd256:  // Fall through.\n      case MachineRepresentation::kProtectedPointer:  // Fall through.\n      case MachineRepresentation::kIndirectPointer:\n      case MachineRepresentation::kFloat16:\n      case MachineRepresentation::kFloat16RawBits:\n        UNREACHABLE();\n    }\n\n    if (this->is_load_root_register(base)) {\n      Emit(code | AddressingModeField::encode(kMode_Root), g.NoOutput(),\n           g.UseRegisterOrImmediateZero(value),\n           index.has_value() ? g.UseImmediate(this->value(index))\n                             : g.UseImmediate(0));\n      return;\n    }\n\n    if (index.has_value() && g.CanBeImmediate(this->value(index), code)) {\n      Emit(code | AddressingModeField::encode(kMode_MRI), g.NoOutput(),\n           g.UseRegisterOrImmediateZero(value), g.UseRegister(base),\n           index.has_value() ? g.UseImmediate(this->value(index))\n                             : g.UseImmediate(0));\n    } else {\n      if (index.has_value()) {\n        InstructionOperand addr_reg = g.TempRegister();\n        Emit(kRiscvAdd32 | AddressingModeField::encode(kMode_None), addr_reg,\n             g.UseRegister(this->value(index)), g.UseRegister(base));\n        // Emit desired store opcode, using temp addr_reg.\n        Emit(code | AddressingModeField::encode(kMode_MRI), g.NoOutput(),\n             g.UseRegisterOrImmediateZero(value), addr_reg, g.TempImmediate(0));\n      } else {\n        Emit(code | AddressingModeField::encode(kMode_MRI), g.NoOutput(),\n             g.UseRegisterOrImmediateZero(value), g.UseRegister(base),\n             g.UseImmediate(0));\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitProtectedLoad\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a protected memory load operation.\",\n            \"logic\": \"Marks the function as unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the protected load operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitProtectedLoad(OpIndex node) {\n  // TODO(eholk)\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitProtectedStore\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a protected memory store operation.\",\n            \"logic\": \"Marks the function as unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the protected store operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitProtectedStore(OpIndex node) {\n  // TODO(eholk)\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitWord32And\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a bitwise AND operation.\",\n            \"logic\": \"Uses VisitBinop to generate the AND instruction. Allows immediate operands.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the AND operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitBinop\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitWord32And(OpIndex node) {\n  VisitBinop<Int32BinopMatcher>(this, node, kRiscvAnd, true, kRiscvAnd);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitWord32Or\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a bitwise OR operation.\",\n            \"logic\": \"Uses VisitBinop to generate the OR instruction. Allows immediate operands.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the OR operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitBinop\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitWord32Or(OpIndex node) {\n  VisitBinop<Int32BinopMatcher>(this, node, kRiscvOr, true, kRiscvOr);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitWord32Xor\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a bitwise XOR operation.\",\n            \"logic\": \"Uses VisitBinop to generate the XOR instruction. Allows immediate operands.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the XOR operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitBinop\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitWord32Xor(OpIndex node) {\n  VisitBinop<Int32BinopMatcher>(this, node, kRiscvXor, true, kRiscvXor);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitWord32Rol\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a bitwise rotate left operation.\",\n            \"logic\": \"Marks the function as unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the rotate left operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitWord32Rol(OpIndex node) { UNIMPLEMENTED(); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitWord32Ror\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a bitwise rotate right operation.\",\n            \"logic\": \"Uses VisitRRO to generate the rotate right instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the rotate right operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VisitRRO\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitWord32Ror(OpIndex node) {\n  VisitRRO(this, kRiscvRor32, node);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitWord32ReverseBits\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a bitwise reverse bits operation.\",\n            \"logic\": \"Marks the function as unreachable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the bitwise reverse bits operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitWord32ReverseBits(OpIndex node) {\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n        <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitWord64ReverseBytes\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for a bitwise reverse bytes operation on 64 bit.\",\n            \"logic\": \"Marks the function as unreachable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the bitwise reverse bytes operation on 64 bit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\","
}