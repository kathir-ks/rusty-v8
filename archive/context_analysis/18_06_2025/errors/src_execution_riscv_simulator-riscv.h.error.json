{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/riscv/simulator-riscv.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/riscv/simulator-riscv.h\",\n        \"file_name\": \"simulator-riscv.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the Simulator class for RISC-V instructions, used when not generating native RISC-V binaries.  Allows running and debugging RISC-V code generation on desktop machines.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes definitions required when simulator is enabled\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Compare\",\n            \"about\": \"Compares two values of the same type.\",\n            \"logic\": \"Returns 0 if a == b, -1 if a < b, and 1 if a > b.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The first value to compare.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The second value to compare.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"0 if a == b, -1 if a < b, and 1 if a > b.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            int Compare(const T& a, const T& b) {\n            if (a == b)\n                return 0;\n            else if (a < b)\n                return -1;\n            else\n                return 1;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Nabs\",\n            \"about\": \"Returns the negative absolute value of its argument.\",\n            \"logic\": \"If a < 0, returns a; otherwise, returns -a.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The value to get the negative absolute value of.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T\",\n                \"description\": \"The negative absolute value of a.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T,\n                    typename = typename std::enable_if<std::is_signed<T>::value>::type>\n            T Nabs(T a) {\n            return a < 0 ? a : -a;\n            }\n        ]]></code>\n    </func>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes definitions for simulator related classes and definitions when USE_SIMULATOR is defined.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #if defined(USE_SIMULATOR)\n            typedef signed __int128_t __attribute__((__mode__(__TI__)));\n            typedef unsigned __uint128_t __attribute__((__mode__(__TI__)));\n            // Running with a simulator.\n\n            #include \"src/base/hashmap.h\"\n            #include \"src/codegen/assembler.h\"\n            #include \"src/codegen/constants-arch.h\"\n            #include \"src/execution/simulator-base.h\"\n            #include \"src/utils/allocation.h\"\n            #include \"src/utils/boxed-float.h\"\n\n            namespace heap::base {\n            class StackVisitor;\n            }\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CachePage\",\n            \"about\": \"Caches pages of memory for the simulator to improve performance.\",\n            \"attributes\": [\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"char[kPageSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The cached data.\"\n                },\n                {\n                    \"name\": \"validity_map_\",\n                    \"type\": \"char[kValidityMapSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks the validity of each cache line within the page.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class CachePage {\n            public:\n            static const int LINE_VALID = 0;\n            static const int LINE_INVALID = 1;\n\n            static const int kPageShift = 12;\n            static const int kPageSize = 1 << kPageShift;\n            static const int kPageMask = kPageSize - 1;\n            static const int kLineShift = 2;  // The cache line is only 4 bytes right now.\n            static const int kLineLength = 1 << kLineShift;\n            static const int kLineMask = kLineLength - 1;\n\n            CachePage() { memset(&validity_map_, LINE_INVALID, sizeof(validity_map_)); }\n\n            char* ValidityByte(int offset) {\n                return &validity_map_[offset >> kLineShift];\n            }\n\n            char* CachedData(int offset) { return &data_[offset]; }\n\n            private:\n            char data_[kPageSize];  // The cached data.\n            static const int kValidityMapSize = kPageSize >> kLineShift;\n            char validity_map_[kValidityMapSize];  // One byte per line.\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimInstructionBase\",\n            \"extends\": \"InstructionBase\",\n            \"about\": \"Base class for simulated instructions, providing common functionality for accessing instruction details.\",\n            \"attributes\": [\n                {\n                    \"name\": \"operand_\",\n                    \"type\": \"int32_t\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The operand of the instruction.\"\n                },\n                {\n                    \"name\": \"instr_\",\n                    \"type\": \"Instruction*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Pointer to the actual instruction.\"\n                },\n                {\n                    \"name\": \"type_\",\n                    \"type\": \"Type\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The type of the instruction.\"\n                }\n            ],\n            \"dependencies\": [\n                \"InstructionBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SimInstructionBase : public InstructionBase {\n            public:\n            Type InstructionType() const { return type_; }\n            inline Instruction* instr() const { return instr_; }\n            inline int32_t operand() const { return operand_; }\n\n            protected:\n            SimInstructionBase() : operand_(-1), instr_(nullptr), type_(kUnsupported) {}\n            explicit SimInstructionBase(Instruction* instr) {}\n\n            int32_t operand_;\n            Instruction* instr_;\n            Type type_;\n\n            private:\n            DISALLOW_ASSIGN(SimInstructionBase);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimInstruction\",\n            \"extends\": \"InstructionGetters<SimInstructionBase>\",\n            \"about\": \"Represents a simulated instruction, inheriting from InstructionGetters and SimInstructionBase.\",\n            \"dependencies\": [\n                \"InstructionGetters\",\n                \"SimInstructionBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SimInstruction : public InstructionGetters<SimInstructionBase> {\n            public:\n            SimInstruction() {}\n\n            explicit SimInstruction(Instruction* instr) { *this = instr; }\n\n            SimInstruction& operator=(Instruction* instr) {\n                operand_ = *reinterpret_cast<const int32_t*>(instr);\n                instr_ = instr;\n                type_ = InstructionBase::InstructionType();\n                DCHECK(reinterpret_cast<void*>(&operand_) == this);\n                return *this;\n            }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Simulator\",\n            \"extends\": \"SimulatorBase\",\n            \"about\": \"The main simulator class for RISC-V architecture, responsible for executing instructions and managing the simulated environment.\",\n            \"attributes\": [\n                {\n                    \"name\": \"registers_\",\n                    \"type\": \"sreg_t[kNumSimuRegisters]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array holding the integer register values.\"\n                },\n                {\n                    \"name\": \"FPUregisters_\",\n                    \"type\": \"sfreg_t[kNumFPURegisters]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array holding the floating-point register values.\"\n                },\n                {\n                    \"name\": \"FCSR_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Floating-point control and status register.\"\n                },\n                {\n                    \"name\": \"stack_\",\n                    \"type\": \"uintptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the simulated stack.\"\n                },\n                {\n                    \"name\": \"stack_limit_\",\n                    \"type\": \"uintptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The limit of the simulated stack.\"\n                },\n                {\n                    \"name\": \"pc_modified_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating if the PC has been modified.\"\n                },\n                {\n                    \"name\": \"icount_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Instruction counter.\"\n                },\n                {\n                    \"name\": \"trace_buf_\",\n                    \"type\": \"base::EmbeddedVector<char, 256>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Buffer for storing trace information.\"\n                },\n                {\n                    \"name\": \"last_debugger_input_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the last debugger input.\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"v8::internal::Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the V8 isolate.\"\n                },\n                {\n                    \"name\": \"builtins_\",\n                    \"type\": \"v8::internal::Builtins\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Reference to the V8 builtins.\"\n                },\n                {\n                    \"name\": \"watched_stops_\",\n                    \"type\": \"StopCountAndDesc[kMaxStopCode + 1]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of stop counts and descriptions.\"\n                },\n                {\n                    \"name\": \"local_monitor_\",\n                    \"type\": \"LocalMonitor\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The local monitor for exclusive access.\"\n                },\n                {\n                    \"name\": \"global_monitor_thread_\",\n                    \"type\": \"GlobalMonitor::LinkedAddress\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The global monitor thread for exclusive access.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SimulatorBase\",\n                \"Isolate\",\n                \"Builtins\",\n                \"StopCountAndDesc\",\n                \"LocalMonitor\",\n                \"GlobalMonitor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Simulator : public SimulatorBase {\n            public:\n            friend class RiscvDebugger;\n\n            // Registers are declared in order. See SMRL chapter 2.\n            enum Register {\n                no_reg = -1,\n                zero_reg = 0,\n                ra,\n                sp,\n                gp,\n                tp,\n                t0,\n                t1,\n                t2,\n                s0,\n                s1,\n                a0,\n                a1,\n                a2,\n                a3,\n                a4,\n                a5,\n                a6,\n                a7,\n                s2,\n                s3,\n                s4,\n                s5,\n                s6,\n                s7,\n                s8,\n                s9,\n                s10,\n                s11,\n                t3,\n                t4,\n                t5,\n                t6,\n                pc,  // pc must be the last register.\n                kNumSimuRegisters,\n                // aliases\n                fp = s0\n            };\n\n            // Coprocessor registers.\n            // Generated code will always use doubles. So we will only use even registers.\n            enum FPURegister {\n                ft0,\n                ft1,\n                ft2,\n                ft3,\n                ft4,\n                ft5,\n                ft6,\n                ft7,\n                fs0,\n                fs1,\n                fa0,\n                fa1,\n                fa2,\n                fa3,\n                fa4,\n                fa5,\n                fa6,\n                fa7,\n                fs2,\n                fs3,\n                fs4,\n                fs5,\n                fs6,\n                fs7,\n                fs8,\n                fs9,\n                fs10,\n                fs11,\n                ft8,\n                ft9,\n                ft10,\n                ft11,\n                kNumFPURegisters\n            };\n\n            enum VRegister {\n                v0,\n                v1,\n                v2,\n                v3,\n                v4,\n                v5,\n                v6,\n                v7,\n                v8,\n                v9,\n                v10,\n                v11,\n                v12,\n                v13,\n                v14,\n                v15,\n                v16,\n                v17,\n                v18,\n                v19,\n                v20,\n                v21,\n                v22,\n                v23,\n                v24,\n                v25,\n                v26,\n                v27,\n                v28,\n                v29,\n                v30,\n                v31,\n                kNumVRegisters\n            };\n\n            explicit Simulator(Isolate* isolate);\n            ~Simulator();\n\n            // The currently executing Simulator instance. Potentially there can be one\n            // for each native thread.\n            V8_EXPORT_PRIVATE static Simulator* current(v8::internal::Isolate* isolate);\n\n            // Accessors for register state. Reading the pc value adheres to the RISC-V\n            // architecture specification and is off by a 8 from the currently executing\n            // instruction.\n            void set_register(int reg, sreg_t value);\n            void set_register_word(int reg, int32_t value);\n            V8_EXPORT_PRIVATE sreg_t get_register(int reg) const;\n            double get_double_from_register_pair(int reg);\n\n            // Same for FPURegisters.\n            void set_fpu_register(int fpureg, int64_t value);\n            void set_fpu_register_word(int fpureg, int32_t value);\n            void set_fpu_register_hi_word(int fpureg, int32_t value);\n            void set_fpu_register_float(int fpureg, float value);\n            void set_fpu_register_float(int fpureg, Float32 value);\n            void set_fpu_register_double(int fpureg, double value);\n            void set_fpu_register_double(int fpureg, Float64 value);\n\n            int64_t get_fpu_register(int fpureg) const;\n            int32_t get_fpu_register_word(int fpureg) const;\n            int32_t get_fpu_register_signed_word(int fpureg) const;\n            int32_t get_fpu_register_hi_word(int fpureg) const;\n            float get_fpu_register_float(int fpureg) const;\n            Float32 get_fpu_register_Float32(int fpureg, bool check_nanbox = true) const;\n            double get_fpu_register_double(int fpureg) const;\n            Float64 get_fpu_register_Float64(int fpureg) const;\n\n            // RV CSR manipulation\n            uint32_t read_csr_value(uint32_t csr);\n            void write_csr_value(uint32_t csr, reg_t value);\n            void set_csr_bits(uint32_t csr, reg_t flags);\n            void clear_csr_bits(uint32_t csr, reg_t flags);\n\n            void set_fflags(uint32_t flags) { set_csr_bits(csr_fflags, flags); }\n            void clear_fflags(int32_t flags) { clear_csr_bits(csr_fflags, flags); }\n\n            #ifdef CAN_USE_RVV_INSTRUCTIONS\n            // RVV CSR\n            __int128_t get_vregister(int vreg) const;\n            inline uint64_t rvv_vlen() const { return kRvvVLEN; }\n            inline uint64_t rvv_vtype() const { return vtype_; }\n            inline uint64_t rvv_vl() const { return vl_; }\n            inline uint64_t rvv_vstart() const { return vstart_; }\n            inline uint64_t rvv_vxsat() const { return vxsat_; }\n            inline uint64_t rvv_vxrm() const { return vxrm_; }\n            inline uint64_t rvv_vcsr() const { return vcsr_; }\n            inline uint64_t rvv_vlenb() const { return vlenb_; }\n            inline uint32_t rvv_zimm() const { return instr_.Rvvzimm(); }\n            inline uint32_t rvv_vlmul() const { return (rvv_vtype() & 0x7); }\n            inline float rvv_vflmul() const {\n                if ((rvv_vtype() & 0b100) == 0) {\n                return static_cast<float>(0x1 << (rvv_vtype() & 0x7));\n                } else {\n                return 1.0 / static_cast<float>(0x1 << (4 - rvv_vtype() & 0x3));\n                }\n            }\n            inline uint32_t rvv_vsew() const { return ((rvv_vtype() >> 3) & 0x7); }\n\n            inline const char* rvv_sew_s() const {\n                uint32_t vsew = rvv_vsew();\n                switch (vsew) {\n            #define CAST_VSEW(name) \\\n            case name:            \\\n                return #name;\n                RVV_SEW(CAST_VSEW)\n                default:\n                return \"unknown\";\n            #undef CAST_VSEW\n                }\n            }\n\n            inline const char* rvv_lmul_s() const {\n                uint32_t vlmul = rvv_vlmul();\n                switch (vlmul) {\n            #define CAST_VLMUL(name) \\\n            case name:             \\\n                return #name;\n                RVV_LMUL(CAST_VLMUL)\n                default:\n                return \"unknown\";\n            #undef CAST_VLMUL\n                }\n            }\n\n            // return size of lane.8 16 32 64\n            inline uint32_t rvv_sew() const {\n                DCHECK_EQ(rvv_vsew() & (~0x7), 0x0);\n                return (0x1 << rvv_vsew()) * 8;\n            }\n            inline uint64_t rvv_vlmax() const {\n                if ((rvv_vlmul() & 0b100) != 0) {\n                return (rvv_vlen() / rvv_sew()) >> (4 - (rvv_vlmul() & 0b11));\n                } else {\n                return ((rvv_vlen() << rvv_vlmul()) / rvv_sew());\n                }\n            }\n            #endif\n\n            inline uint32_t get_dynamic_rounding_mode();\n            inline bool test_fflags_bits(uint32_t mask);\n\n            float RoundF2FHelper(float input_val, int rmode);\n            double RoundF2FHelper(double input_val, int rmode);\n            template <typename I_TYPE, typename F_TYPE>\n            I_TYPE RoundF2IHelper(F_TYPE original, int rmode);\n\n            template <typename T>\n            T FMaxMinHelper(T a, T b, MaxMinKind kind);\n\n            template <typename T>\n            bool CompareFHelper(T input1, T input2, FPUCondition cc);\n\n            // Special case of set_register and get_register to access the raw PC value.\n            void set_pc(sreg_t value);\n            V8_EXPORT_PRIVATE sreg_t get_pc() const;\n\n            Address get_sp() const { return static_cast<Address>(get_register(sp)); }\n\n            // Accessor to the internal simulator stack area. Adds a safety\n            // margin to prevent overflows (kAdditionalStackMargin).\n            uintptr_t StackLimit(uintptr_t c_limit) const;\n            uintptr_t StackBase() const;\n            // Return central stack view, without additional safety margins.\n            // Users, for example wasm::StackMemory, can add their own.\n            base::Vector<uint8_t> GetCentralStackView() const;\n\n            void IterateRegistersAndStack(::heap::base::StackVisitor* visitor);\n\n            // Pseudo instruction for switching stack limit\n            void DoSwitchStackLimit(Instruction* instr);\n\n            // Executes RISC-V instructions until the PC reaches end_sim_pc.\n            void Execute();\n\n            // Only arguments up to 64 bits in size are supported.\n            class CallArgument {\n            public:\n                template <typename T>\n                explicit CallArgument(T argument) {\n                bits_ = 0;\n                DCHECK(sizeof(argument) <= sizeof(bits_));\n                bits_ = ConvertArg(argument);\n                type_ = GP_ARG;\n                }\n                explicit CallArgument(double argument) {\n                DCHECK(sizeof(argument) == sizeof(bits_));\n                memcpy(&bits_, &argument, sizeof(argument));\n                type_ = FP_ARG;\n                }\n                explicit CallArgument(float argument) {\n                // TODO(all): CallArgument(float) is untested.\n                UNIMPLEMENTED();\n                }\n                // This indicates the end of the arguments list, so that CallArgument\n                // objects can be passed into varargs functions.\n                static CallArgument End() { return CallArgument(); }\n                int64_t bits() const { return bits_; }\n                bool IsEnd() const { return type_ == NO_ARG; }\n                bool IsGP() const { return type_ == GP_ARG; }\n                bool IsFP() const { return type_ == FP_ARG; }\n\n            private:\n                enum CallArgumentType { GP_ARG, FP_ARG, NO_ARG };\n                // All arguments are aligned to at least 64 bits and we don't support\n                // passing bigger arguments, so the payload size can be fixed at 64 bits.\n                int64_t bits_;\n                CallArgumentType type_;\n                CallArgument() { type_ = NO_ARG; }\n            };\n\n            template <typename Return, typename... Args>\n            Return Call(Address entry, Args... args) {\n            #ifdef V8_TARGET_ARCH_RISCV64\n                // Convert all arguments to CallArgument.\n                CallArgument call_args[] = {CallArgument(args)..., CallArgument::End()};\n                CallImpl(entry, call_args);\n                return ReadReturn<Return>();\n            #else\n                return VariadicCall<Return>(this, &Simulator::CallImpl, entry, args...);\n            #endif\n            }\n            // Alternative: call a 2-argument double function.\n            double CallFP(Address entry, double d0, double d1);\n\n            // Push an address onto the JS stack.\n            V8_EXPORT_PRIVATE uintptr_t PushAddress(uintptr_t address);\n\n            // Pop an address from the JS stack.\n            V8_EXPORT_PRIVATE uintptr_t PopAddress();\n\n            // Debugger input.\n            void set_last_debugger_input(char* input);\n            char* last_debugger_input() { return last_debugger_input_; }\n\n            // Redirection support.\n            static void SetRedirectInstruction(Instruction* instruction);\n\n            // ICache checking.\n            static bool ICacheMatch(void* one, void* two);\n            static void FlushICache(base::CustomMatcherHashMap* i_cache, void* start,\n                                    size_t size);\n\n            // Returns true if pc register contains one of the 'special_values' defined\n            // below (bad_ra, end_sim_pc).\n            bool has_bad_pc() const;\n\n            private:\n            enum special_values {\n                // Known bad pc value to ensure that the simulator does not execute\n                // without being properly setup.\n                bad_ra = -1,\n                // A pc value used to signal the simulator to stop execution.  Generally\n                // the ra is set to this value on transition from native C code to\n                // simulated execution, so that the simulator can \"return\" to the native\n                // C code.\n                end_sim_pc = -2,\n                // Unpredictable value.\n                Unpredictable = 0xbadbeaf\n            };\n\n            #ifdef V8_TARGET_ARCH_RISCV64\n            V8_EXPORT_PRIVATE void CallImpl(Address entry, CallArgument* args);\n            void CallAnyCTypeFunction(Address target_address,\n                                        const EncodedCSignature& signature);\n            // Read floating point return values.\n            template <typename T>\n            typename std::enable_if<std::is_floating_point<T>::value, T>::type\n            ReadReturn() {\n                return static_cast<T>(get_fpu_register_double(fa0));\n            }\n            // Read non-float return values.\n            template <typename T>\n            typename std::enable_if<!std::is_floating_point<T>::value, T>::type\n            ReadReturn() {\n                return ConvertReturn<T>(get_register(a0));\n            }\n            #else\n            V8_EXPORT_PRIVATE intptr_t CallImpl(Address entry, int argument_count,\n                                                const intptr_t* arguments);\n            #endif\n            // Unsupported instructions use Format to print an error and stop execution.\n            void Format(Instruction* instr, const char* format);\n\n            // Helpers for data value tracing.\n            enum TraceType {\n                BYTE,\n                HALF,\n                WORD,\n            #if V8_TARGET_ARCH_RISCV64\n                DWORD,\n            #endif\n                FLOAT,\n                DOUBLE,\n                // FLOAT_DOUBLE,\n                // WORD_DWORD\n            };\n\n            // \"Probe\" if an address range can be read. This is currently implemented\n            // by doing a 1-byte read of the last accessed byte, since the assumption is\n            // that if the last byte is accessible, also all lower bytes are accessible\n            // (which holds true for Wasm).\n            // Returns true if the access was successful, false if the access raised a\n            // signal which was then handled by the trap handler (also see\n            // {trap_handler::ProbeMemory}). If the access raises a signal which is not\n            // handled by the trap handler (e.g. because the current PC is not registered\n            // as a protected instruction), the signal will propagate and make the process\n            // crash. If no trap handler is available, this always returns true.\n            bool ProbeMemory(uintptr_t address, uintptr_t access_size);\n\n            // RISCV Memory read/write methods\n            template <typename T>\n            T ReadMem(sreg_t addr, Instruction* instr);\n            template <typename T>\n            void WriteMem(sreg_t addr, T value, Instruction* instr);\n            template <typename T, typename OP>\n            T amo(sreg_t addr, OP f, Instruction* instr, TraceType t) {\n                auto lhs = ReadMem<T>(addr, instr);\n                // TODO(RISCV): trace memory read for AMO\n                WriteMem<T>(addr, (T)f(lhs), instr);\n                return lhs;\n            }\n\n            // Helper for debugging memory access.\n            inline void DieOrDebug();\n\n            #if V8_TARGET_ARCH_RISCV32\n            template <typename T>\n            void TraceRegWr(T value, TraceType t = WORD);\n            #elif V8_TARGET_ARCH_RISCV64\n            void TraceRegWr(sreg_t value, TraceType t = DWORD);\n            #endif\n            void TraceMemWr(sreg_t addr, sreg_t value, TraceType t);\n            template <typename T>\n            void TraceMemRd(sreg_t addr, T value, sreg_t reg_value);\n            void TraceMemRdDouble(sreg_t addr, double value, int64_t reg_value);\n            void TraceMemRdDouble(sreg_t addr, Float64 value, int64_t reg_value);\n            void TraceMemRdFloat(sreg_t addr, Float32 value, int64_t reg_value);\n\n            template <typename T>\n            void TraceMemWr(sreg_t addr, T value);\n            void TraceMemWrDouble(sreg_t addr, double value);\n\n            SimInstruction instr_;\n\n            // RISCV utlity API to access register value\n            inline int32_t rs1_reg() const { return instr_.Rs1Value(); }\n            inline sreg_t rs1() const { return get_register(rs1_reg()); }\n            inline float frs1() const { return get_fpu_register_float(rs1_reg()); }\n            inline double drs1() const { return get_fpu_register_double(rs1_reg()); }\n            inline Float32 frs1_boxed() const {\n                return get_fpu_register_Float32(rs1_reg());\n            }\n            inline Float64 drs1_boxed() const {\n                return get_fpu_register_Float64(rs1_reg());\n            }\n            inline int32_t rs2_reg() const { return instr_.Rs2Value(); }\n            inline sreg_t rs2() const { return get_register(rs2_reg()); }\n            inline float frs2() const { return get_fpu_register_float(rs2_reg()); }\n            inline double drs2() const { return get_fpu_register_double(rs2_reg()); }\n            inline Float32 frs2_boxed() const {\n                return get_fpu_register_Float32(rs2_reg());\n            }\n            inline Float64 drs2_boxed() const {\n                return get_fpu_register_Float64(rs2_reg());\n            }\n            inline int32_t rs3_reg() const { return instr_.Rs3Value(); }\n            inline sreg_t rs3() const { return get_register(rs3_reg()); }\n            inline float frs3() const { return get_fpu_register_float(rs3_reg()); }\n            inline double drs3() const { return get_fpu_register_double(rs3_reg()); }\n            inline Float32 frs3_boxed() const {\n                return get_fpu_register_Float32(rs3_reg());\n            }\n            inline Float64 drs3_boxed() const {\n                return get_fpu_register_Float64(rs3_reg());\n            }\n            inline int32_t rd_reg() const { return instr_.RdValue(); }\n            inline int32_t frd_reg() const { return instr_.RdValue(); }\n            inline int32_t rvc_rs1_reg() const { return instr_.RvcRs1Value(); }\n            inline sreg_t rvc_rs1() const { return get_register(rvc_rs1_reg()); }\n            inline int32_t rvc_rs2_reg() const { return instr_.RvcRs2Value(); }\n            inline sreg_t rvc_rs2() const { return get_register(rvc_rs2_reg()); }\n            inline double rvc_drs2() const {\n                return get_fpu_register_double(rvc_rs2_reg());\n            }\n            inline int32_t rvc_rs1s_reg() const { return instr_.RvcRs1sValue(); }\n            inline sreg_t rvc_rs1s() const { return get_register(rvc_rs1s_reg()); }\n            inline int32_t rvc_rs2s_reg() const { return instr_.RvcRs2sValue(); }\n            inline sreg_t rvc_rs2s() const { return get_register(rvc_rs2s_reg()); }\n            inline double rvc_drs2s() const {\n                return get_fpu_register_double(rvc_rs2s_reg());\n            }\n            inline int32_t rvc_rd_reg() const { return instr_.RvcRdValue(); }\n            inline int32_t rvc_"
}