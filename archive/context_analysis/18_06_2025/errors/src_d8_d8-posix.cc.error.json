{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8-posix.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8-posix.cc\",\n        \"file_name\": \"d8-posix.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements POSIX-specific functionalities for the d8 shell, including system calls, directory manipulation, and environment variable management.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C and C++ libraries for various functionalities such as input/output, string manipulation, system calls, and networking. Also includes V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <errno.h>\n            #include <fcntl.h>\n\n            #include \"src/d8/d8.h\"\n\n            #ifndef V8_OS_ZOS\n            #include <netinet/ip.h>\n            #endif\n            #include <signal.h>\n            #include <stdlib.h>\n            #include <string.h>\n            #include <sys/select.h>\n            #include <sys/socket.h>\n            #include <sys/stat.h>\n            #include <sys/time.h>\n            #include <sys/types.h>\n            #include <sys/wait.h>\n            #include <unistd.h>\n\n            #include \"include/v8-container.h\"\n            #include \"include/v8-template.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"LengthWithoutIncompleteUtf8\",\n            \"parent\": null,\n            \"about\": \"Calculates the length of a string, excluding any incomplete UTF-8 sequences at the end.\",\n            \"logic\": \"Iterates through the buffer from the end, checking for valid UTF-8 sequences. Returns the length up to the last complete sequence.\",\n            \"parameters\": [\n                {\n                    \"name\": \"buffer\",\n                    \"type\": \"char*\",\n                    \"purpose\": \"The buffer containing the string.\"\n                },\n                {\n                    \"name\": \"len\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The length of the buffer.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The length of the string without incomplete UTF-8 sequences.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static int LengthWithoutIncompleteUtf8(char* buffer, int len) {\n              int answer = len;\n              // 1-byte encoding.\n              static const int kUtf8SingleByteMask = 0x80;\n              static const int kUtf8SingleByteValue = 0x00;\n              // 2-byte encoding.\n              static const int kUtf8TwoByteMask = 0xE0;\n              static const int kUtf8TwoByteValue = 0xC0;\n              // 3-byte encoding.\n              static const int kUtf8ThreeByteMask = 0xF0;\n              static const int kUtf8ThreeByteValue = 0xE0;\n              // 4-byte encoding.\n              static const int kUtf8FourByteMask = 0xF8;\n              static const int kUtf8FourByteValue = 0xF0;\n              // Subsequent bytes of a multi-byte encoding.\n              static const int kMultiByteMask = 0xC0;\n              static const int kMultiByteValue = 0x80;\n              int multi_byte_bytes_seen = 0;\n              while (answer > 0) {\n                int c = buffer[answer - 1];\n                // Ends in valid single-byte sequence?\n                if ((c & kUtf8SingleByteMask) == kUtf8SingleByteValue) return answer;\n                // Ends in one or more subsequent bytes of a multi-byte value?\n                if ((c & kMultiByteMask) == kMultiByteValue) {\n                  multi_byte_bytes_seen++;\n                  answer--;\n                } else {\n                  if ((c & kUtf8TwoByteMask) == kUtf8TwoByteValue) {\n                    if (multi_byte_bytes_seen >= 1) {\n                      return answer + 2;\n                    }\n                    return answer - 1;\n                  } else if ((c & kUtf8ThreeByteMask) == kUtf8ThreeByteValue) {\n                    if (multi_byte_bytes_seen >= 2) {\n                      return answer + 3;\n                    }\n                    return answer - 1;\n                  } else if ((c & kUtf8FourByteMask) == kUtf8FourByteValue) {\n                    if (multi_byte_bytes_seen >= 3) {\n                      return answer + 4;\n                    }\n                    return answer - 1;\n                  } else {\n                    return answer;  // Malformed UTF-8.\n                  }\n                }\n              }\n              return 0;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"WaitOnFD\",\n            \"parent\": null,\n            \"about\": \"Suspends the thread until data is available from a file descriptor, with optional timeouts.\",\n            \"logic\": \"Uses `select` to monitor a file descriptor for readability. Handles read and total timeouts. Returns `false` if the timeout expires, `true` if data is ready.\",\n            \"parameters\": [\n                {\n                    \"name\": \"fd\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The file descriptor to wait on.\"\n                },\n                {\n                    \"name\": \"read_timeout\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The timeout for a single read operation, in milliseconds.\"\n                },\n                {\n                    \"name\": \"total_timeout\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The total timeout for the operation, in milliseconds. -1 means no timeout.\"\n                },\n                {\n                    \"name\": \"start_time\",\n                    \"type\": \"const struct timeval&\",\n                    \"purpose\": \"The timeval struct representing the start time of the operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns `true` if data is ready, `false` if a timeout occurred.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool WaitOnFD(int fd, int read_timeout, int total_timeout,\n                                 const struct timeval& start_time) {\n              fd_set readfds, writefds, exceptfds;\n              struct timeval timeout;\n              int gone = 0;\n              if (total_timeout != -1) {\n                struct timeval time_now;\n                gettimeofday(&time_now, nullptr);\n                time_t seconds = time_now.tv_sec - start_time.tv_sec;\n                gone = static_cast<int>(seconds * 1000 +\n                                        (time_now.tv_usec - start_time.tv_usec) / 1000);\n                if (gone >= total_timeout) return false;\n              }\n              FD_ZERO(&readfds);\n              FD_ZERO(&writefds);\n              FD_ZERO(&exceptfds);\n              FD_SET(fd, &readfds);\n              FD_SET(fd, &exceptfds);\n              if (read_timeout == -1 ||\n                  (total_timeout != -1 && total_timeout - gone < read_timeout)) {\n                read_timeout = total_timeout - gone;\n              }\n              timeout.tv_usec = (read_timeout % 1000) * 1000;\n              timeout.tv_sec = read_timeout / 1000;\n              int number_of_fds_ready = select(fd + 1, &readfds, &writefds, &exceptfds,\n                                               read_timeout != -1 ? &timeout : nullptr);\n              return number_of_fds_ready == 1;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TimeIsOut\",\n            \"parent\": null,\n            \"about\": \"Checks if a specified total time has elapsed since a start time.\",\n            \"logic\": \"Compares the current time with the start time. Returns true if the difference is greater than or equal to the total time.\",\n            \"parameters\": [\n                {\n                    \"name\": \"start_time\",\n                    \"type\": \"const struct timeval&\",\n                    \"purpose\": \"The timeval struct representing the start time.\"\n                },\n                {\n                    \"name\": \"total_time\",\n                    \"type\": \"const int&\",\n                    \"purpose\": \"The total allowed time, in milliseconds.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns `true` if the total time has elapsed, `false` otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool TimeIsOut(const struct timeval& start_time, const int& total_time) {\n              if (total_time == -1) return false;\n              struct timeval time_now;\n              gettimeofday(&time_now, nullptr);\n              // Careful about overflow.\n              int seconds = static_cast<int>(time_now.tv_sec - start_time.tv_sec);\n              if (seconds > 100) {\n                if (seconds * 1000 > total_time) return true;\n                return false;\n              }\n              int useconds = static_cast<int>(time_now.tv_usec - start_time.tv_usec);\n              if (seconds * 1000000 + useconds > total_time * 1000) {\n                return true;\n              }\n              return false;\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZombieProtector\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Ensures that child processes are properly waited for to prevent zombie processes.\",\n            \"attributes\": [\n                {\n                    \"name\": \"pid_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the process ID of the child process.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class ZombieProtector {\n             public:\n              explicit ZombieProtector(int pid) : pid_(pid) {}\n              ~ZombieProtector() {\n                if (pid_ != 0) waitpid(pid_, nullptr, 0);\n              }\n              void ChildIsDeadNow() { pid_ = 0; }\n\n             private:\n              int pid_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OpenFDCloser\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Closes a file descriptor when the object goes out of scope.\",\n            \"attributes\": [\n                {\n                    \"name\": \"fd_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the file descriptor to be closed.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class OpenFDCloser {\n             public:\n              explicit OpenFDCloser(int fd) : fd_(fd) {}\n              ~OpenFDCloser() { close(fd_); }\n\n             private:\n              int fd_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ExecArgs\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Manages the arguments passed to the `exec` system call.\",\n            \"attributes\": [\n                {\n                    \"name\": \"exec_args_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores an array of C-style strings representing the arguments.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class ExecArgs {\n             public:\n              ExecArgs() { exec_args_[0] = nullptr; }\n              bool Init(Isolate* isolate, Local<Value> arg0, Local<Array> command_args) {\n                String::Utf8Value prog(isolate, arg0);\n                if (*prog == nullptr) {\n                  isolate->ThrowError(\n                      \"os.system(): String conversion of program name failed\");\n                  return false;\n                }\n                {\n                  size_t len = prog.length() + 3;\n                  char* c_arg = new char[len];\n                  snprintf(c_arg, len, \"%s\", *prog);\n                  exec_args_[0] = c_arg;\n                }\n                int i = 1;\n                for (unsigned j = 0; j < command_args->Length(); i++, j++) {\n                  Local<Value> arg(\n                      command_args\n                          ->Get(isolate->GetCurrentContext(), Integer::New(isolate, j))\n                          .ToLocalChecked());\n                  String::Utf8Value utf8_arg(isolate, arg);\n                  if (*utf8_arg == nullptr) {\n                    exec_args_[i] = nullptr;  // Consistent state for destructor.\n                    isolate->ThrowError(\n                        \"os.system(): String conversion of argument failed.\");\n                    return false;\n                  }\n                  size_t len = utf8_arg.length() + 1;\n                  char* c_arg = new char[len];\n                  snprintf(c_arg, len, \"%s\", *utf8_arg);\n                  exec_args_[i] = c_arg;\n                }\n                exec_args_[i] = nullptr;\n                return true;\n              }\n              ~ExecArgs() {\n                for (unsigned i = 0; i < kMaxArgs; i++) {\n                  if (exec_args_[i] == nullptr) {\n                    return;\n                  }\n                  delete[] exec_args_[i];\n                  exec_args_[i] = nullptr;\n                }\n              }\n              static const unsigned kMaxArgs = 1000;\n              char* const* arg_array() const { return exec_args_; }\n              const char* arg0() const { return exec_args_[0]; }\n\n             private:\n              char* exec_args_[kMaxArgs + 1];\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetTimeouts\",\n            \"parent\": null,\n            \"about\": \"Retrieves optional timeout values from the arguments to the `system()` call.\",\n            \"logic\": \"Parses the 3rd and 4th arguments of the `info` object, which are expected to be numbers representing read and total timeouts, respectively.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"const v8::FunctionCallbackInfo<v8::Value>&\",\n                    \"purpose\": \"The V8 function callback information object.\"\n                },\n                {\n                    \"name\": \"read_timeout\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"A pointer to store the read timeout value.\"\n                },\n                {\n                    \"name\": \"total_timeout\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"A pointer to store the total timeout value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns `true` if the timeouts were successfully retrieved, `false` otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool GetTimeouts(const v8::FunctionCallbackInfo<v8::Value>& info,\n                                    int* read_timeout, int* total_timeout) {\n              if (info.Length() > 3) {\n                if (info[3]->IsNumber()) {\n                  *total_timeout = info[3]\n                                       ->Int32Value(info.GetIsolate()->GetCurrentContext())\n                                       .FromJust();\n                } else {\n                  info.GetIsolate()->ThrowError(\"system: Argument 4 must be a number\");\n                  return false;\n                }\n              }\n              if (info.Length() > 2) {\n                if (info[2]->IsNumber()) {\n                  *read_timeout = info[2]\n                                      ->Int32Value(info.GetIsolate()->GetCurrentContext())\n                                      .FromJust();\n                } else {\n                  info.GetIsolate()->ThrowError(\"system: Argument 3 must be a number\");\n                  return false;\n                }\n              }\n              return true;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"v8_strerror\",\n            \"parent\": null,\n            \"about\": \"Returns a V8 string representation of a system error message.\",\n            \"logic\": \"Uses `strerror` to get the system error message for a given error number and then converts it into a V8 string.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"v8::Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"err\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The error number.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"v8::Local<v8::String>\",\n                \"description\": \"A V8 string representing the error message.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n            v8::Local<v8::String> v8_strerror(v8::Isolate* isolate, int err) {\n              return v8::String::NewFromUtf8(isolate, strerror(err)).ToLocalChecked();\n            }\n            }  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ExecSubprocess\",\n            \"parent\": null,\n            \"about\": \"Executes the subprocess in the child process after fork().\",\n            \"logic\": \"Closes unused file descriptors, duplicates the stdout file descriptor to the pipe, and executes the subprocess using `execvp`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"exec_error_fds\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"File descriptors for the pipe used to communicate errors from the child to the parent.\"\n                },\n                {\n                    \"name\": \"stdout_fds\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"File descriptors for the pipe used to capture the standard output of the child process.\"\n                },\n                {\n                    \"name\": \"exec_args\",\n                    \"type\": \"const ExecArgs&\",\n                    \"purpose\": \"The arguments to be passed to the executable.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"This function does not return normally. If `execvp` fails, it writes the error number to the `exec_error_fds` pipe.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static void ExecSubprocess(int* exec_error_fds, int* stdout_fds,\n                                     const ExecArgs& exec_args) {\n              close(exec_error_fds[kReadFD]);  // Don't need this in the child.\n              close(stdout_fds[kReadFD]);      // Don't need this in the child.\n              close(1);                        // Close stdout.\n              dup2(stdout_fds[kWriteFD], 1);   // Dup pipe fd to stdout.\n              close(stdout_fds[kWriteFD]);     // Don't need the original fd now.\n              fcntl(exec_error_fds[kWriteFD], F_SETFD, FD_CLOEXEC);\n              execvp(exec_args.arg0(), exec_args.arg_array());\n              // Only get here if the exec failed.  Write errno to the parent to tell\n              // them it went wrong.  If it went well the pipe is closed.\n              int err = errno;\n              ssize_t bytes_written;\n              do {\n                bytes_written = write(exec_error_fds[kWriteFD], &err, sizeof(err));\n              } while (bytes_written == -1 && errno == EINTR);\n              // Return (and exit child process).\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ChildLaunchedOK\",\n            \"parent\": null,\n            \"about\": \"Checks if the child process was launched successfully by reading from the error pipe.\",\n            \"logic\": \"Reads from the `exec_error_fds` pipe. If data is received, it indicates an error during the child process's execution. If the pipe is closed without any data, the launch was successful.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"exec_error_fds\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"File descriptors for the pipe used to communicate errors from the child to the parent.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns `true` if the child process was launched successfully, `false` otherwise.\"\n            },\n            \"dependencies\": [\n                \"v8_strerror\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool ChildLaunchedOK(Isolate* isolate, int* exec_error_fds) {\n              ssize_t bytes_read;\n              int err;\n              do {\n                bytes_read = read(exec_error_fds[kReadFD], &err, sizeof(err));\n              } while (bytes_read == -1 && errno == EINTR);\n              if (bytes_read != 0) {\n                isolate->ThrowError(v8_strerror(isolate, err));\n                return false;\n              }\n              return true;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetStdout\",\n            \"parent\": null,\n            \"about\": \"Accumulates the standard output from the child process into a V8 string.\",\n            \"logic\": \"Reads data from the child's stdout file descriptor in a non-blocking manner, handling timeouts and UTF-8 sequence completion. Concatenates the received data into a V8 string accumulator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"child_fd\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The file descriptor for the child's standard output.\"\n                },\n                {\n                    \"name\": \"start_time\",\n                    \"type\": \"const struct timeval&\",\n                    \"purpose\": \"The timeval struct representing the start time of the operation.\"\n                },\n                {\n                    \"name\": \"read_timeout\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The timeout for a single read operation, in milliseconds.\"\n                },\n                {\n                    \"name\": \"total_timeout\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The total timeout for the operation, in milliseconds. -1 means no timeout.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Local<Value>\",\n                \"description\": \"A V8 string containing the accumulated standard output from the child process. Returns an error if an exception was thrown.\"\n            },\n            \"dependencies\": [\n                \"LengthWithoutIncompleteUtf8\",\n                \"WaitOnFD\",\n                \"TimeIsOut\",\n                \"v8_strerror\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static Local<Value> GetStdout(Isolate* isolate, int child_fd,\n                                          const struct timeval& start_time,\n                                          int read_timeout, int total_timeout) {\n              Local<String> accumulator = String::Empty(isolate);\n\n              int fullness = 0;\n              static const int kStdoutReadBufferSize = 4096;\n              char buffer[kStdoutReadBufferSize];\n\n              if (fcntl(child_fd, F_SETFL, O_NONBLOCK) != 0) {\n                return isolate->ThrowError(v8_strerror(isolate, errno));\n              }\n\n              int bytes_read;\n              do {\n                bytes_read = static_cast<int>(\n                    read(child_fd, buffer + fullness, kStdoutReadBufferSize - fullness));\n                if (bytes_read == -1) {\n                  if (errno == EAGAIN) {\n                    if (!WaitOnFD(child_fd, read_timeout, total_timeout, start_time) ||\n                        (TimeIsOut(start_time, total_timeout))) {\n                      return isolate->ThrowError(\"Timed out waiting for output\");\n                    }\n                    continue;\n                  } else if (errno == EINTR) {\n                    continue;\n                  } else {\n                    break;\n                  }\n                }\n                if (bytes_read + fullness > 0) {\n                  int length = bytes_read == 0 ? bytes_read + fullness\n                                               : LengthWithoutIncompleteUtf8(\n                                                     buffer, bytes_read + fullness);\n                  Local<String> addition =\n                      String::NewFromUtf8(isolate, buffer, NewStringType::kNormal, length)\n                          .ToLocalChecked();\n                  accumulator = String::Concat(isolate, accumulator, addition);\n                  fullness = bytes_read + fullness - length;\n                  memcpy(buffer, buffer + length, fullness);\n                }\n              } while (bytes_read != 0);\n              return accumulator;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"WaitForChild\",\n            \"parent\": null,\n            \"about\": \"Waits for the child process to exit, with timeout and signal handling.\",\n            \"logic\": \"Uses `waitid` (if available) or `waitpid` to wait for the child process to exit. Handles timeouts, signals, and exit statuses. Throws V8 errors for non-zero exit statuses or signals.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"pid\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The process ID of the child process.\"\n                },\n                {\n                    \"name\": \"child_waiter\",\n                    \"type\": \"ZombieProtector&\",\n                    \"purpose\": \"A `ZombieProtector` object to ensure the child process is waited on.\"\n                },\n                {\n                    \"name\": \"start_time\",\n                    \"type\": \"const struct timeval&\",\n                    \"purpose\": \"The timeval struct representing the start time of the operation.\"\n                },\n                {\n                    \"name\": \"read_timeout\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The timeout for a single read operation, in milliseconds.\"\n                },\n                {\n                    \"name\": \"total_timeout\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The total timeout for the operation, in milliseconds. -1 means no timeout.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns `true` if the child process exited successfully, `false` otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool WaitForChild(Isolate* isolate, int pid,\n                                     ZombieProtector& child_waiter,\n                                     const struct timeval& start_time, int read_timeout,\n                                     int total_timeout) {\n            #ifdef HAS_WAITID\n\n              siginfo_t child_info;\n              child_info.si_pid = 0;\n              int useconds = 1;\n              // Wait for child to exit.\n              while (child_info.si_pid == 0) {\n                waitid(P_PID, pid, &child_info, WEXITED | WNOHANG | WNOWAIT);\n                usleep(useconds);\n                if (useconds < 1000000) useconds <<= 1;\n                if ((read_timeout != -1 && useconds / 1000 > read_timeout) ||\n                    (TimeIsOut(start_time, total_timeout))) {\n                  isolate->ThrowError(\"Timed out waiting for process to terminate\");\n                  kill(pid, SIGINT);\n                  return false;\n                }\n              }\n              if (child_info.si_code == CLD_KILLED) {\n                char message[999];\n                snprintf(message, sizeof(message), \"Child killed by signal %d\",\n                         child_info.si_status);\n                isolate->ThrowError(message);\n                return false;\n              }\n              if (child_info.si_code == CLD_EXITED && child_info.si_status != 0) {\n                char message[999];\n                snprintf(message, sizeof(message), \"Child exited with status %d\",\n                         child_info.si_status);\n                isolate->ThrowError(message);\n                return false;\n              }\n\n            #else  // No waitid call.\n\n              int child_status;\n              waitpid(pid, &child_status, 0);  // We hang here if the child doesn't exit.\n              child_waiter.ChildIsDeadNow();\n              if (WIFSIGNALED(child_status)) {\n                char message[999];\n                snprintf(message, sizeof(message), \"Child killed by signal %d\",\n                         WTERMSIG(child_status));\n                isolate->ThrowError(message);\n                return false;\n              }\n              if (WEXITSTATUS(child_status) != 0) {\n                char message[999];\n                int exit_status = WEXITSTATUS(child_status);\n                snprintf(message, sizeof(message), \"Child exited with status %d\",\n                         exit_status);\n                isolate->ThrowError(message);\n                return false;\n              }\n\n            #endif  // No waitid call.\n\n              return true;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"System\",\n            \"parent\": \"Shell\",\n            \"about\": \"Implements the `system()` function, which executes a shell command and returns its output.\",\n            \"logic\": \"Forks a child process to execute the command, captures the standard output using pipes, and waits for the child process to exit. Handles timeouts, signals, and exit statuses. Throws V8 errors for failures.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"const v8::FunctionCallbackInfo<v8::Value>&\",\n                    \"purpose\": \"The V8 function callback information object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"Sets the return value of the V8 function to the standard output of the executed command.\"\n            },\n            \"dependencies\": [\n                \"GetTimeouts\",\n                \"ExecArgs\",\n                \"ExecSubprocess\",\n                \"ChildLaunchedOK\",\n                \"GetStdout\",\n                \"WaitForChild\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Shell::System(const v8::FunctionCallbackInfo<v8::Value>& info) {\n              DCHECK(i::ValidateCallbackInfo(info));\n              HandleScope scope(info.GetIsolate());\n              int read_timeout = -1;\n              int total_timeout = -1;\n              if (!GetTimeouts(info, &read_timeout, &total_timeout)) return;\n              Local<Array> command_args;\n              if (info.Length() > 1) {\n                if (!info[1]->IsArray()) {\n                  info.GetIsolate()->ThrowError(\"system: Argument 2 must be an array\");\n                  return;\n                }\n                command_args = info[1].As<Array>();\n              } else {\n                command_args = Array::New(info.GetIsolate(), 0);\n              }\n              if (command_args->Length() > ExecArgs::kMaxArgs) {\n                info.GetIsolate()->ThrowError(\"Too many arguments to system()\");\n                return;\n              }\n              if (info.Length() < 1) {\n                info.GetIsolate()->ThrowError(\"Too few arguments to system()\");\n                return;\n              }\n\n              struct timeval start_time;\n              gettimeofday(&start_time, nullptr);\n\n              ExecArgs exec_args;\n              if (!exec_args.Init(info.GetIsolate(), info[0], command_args)) {\n                return;\n              }\n              int exec_error_fds[2];\n              int stdout_fds[2];\n\n              if (pipe(exec_error_fds) != 0) {\n                info.GetIsolate()->ThrowError(\"pipe syscall failed.\");\n                return;\n              }\n              if (pipe(stdout_fds) != 0) {\n                info.GetIsolate()->ThrowError(\"pipe"
}