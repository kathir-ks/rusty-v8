{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/scheduler.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/scheduler.cc\",\n            \"file_name\": \"scheduler.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the Scheduler class for instruction scheduling in the Turbofan compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard library includes for various functionalities (input/output, data structures, etc.)\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/scheduler.h\"\n\n            #include <iomanip>\n            #include <optional>\n\n            #include \"src/base/iterator.h\"\n            #include \"src/builtins/profile-data-reader.h\"\n            #include \"src/codegen/tick-counter.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/control-equivalence.h\"\n            #include \"src/compiler/node-marker.h\"\n            #include \"src/compiler/node-properties.h\"\n            #include \"src/compiler/node.h\"\n            #include \"src/compiler/turbofan-graph.h\"\n            #include \"src/utils/bit-vector.h\"\n            #include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TRACE\",\n                \"about\": \"A macro for conditional tracing output to stdout, enabled by a flag.\",\n                \"logic\": \"Uses the v8_flags.trace_turbo_scheduler flag to determine whether to print debugging information.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #define TRACE(...)                                           \\\n              do {                                                       \\\n                if (v8_flags.trace_turbo_scheduler) PrintF(__VA_ARGS__); \\\n              } while (false)\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Scheduler\",\n                \"about\": \"The main class for scheduling nodes in the Turbofan compiler.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory allocation zone.\"\n                    },\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The Turbofan graph to be scheduled.\"\n                    },\n                    {\n                        \"name\": \"schedule_\",\n                        \"type\": \"Schedule*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The schedule being constructed.\"\n                    },\n                    {\n                        \"name\": \"flags_\",\n                        \"type\": \"Flags\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Scheduling flags.\"\n                    },\n                    {\n                        \"name\": \"scheduled_nodes_\",\n                        \"type\": \"ZoneVector<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of scheduled nodes.\"\n                    },\n                    {\n                        \"name\": \"schedule_root_nodes_\",\n                        \"type\": \"ZoneVector<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of root nodes for scheduling.\"\n                    },\n                    {\n                        \"name\": \"schedule_queue_\",\n                        \"type\": \"ZoneQueue<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The queue for scheduling nodes.\"\n                    },\n                    {\n                        \"name\": \"node_data_\",\n                        \"type\": \"ZoneVector<SchedulerData>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Data associated with each node for scheduling.\"\n                    },\n                    {\n                        \"name\": \"tick_counter_\",\n                        \"type\": \"TickCounter*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A tick counter for triggering safepoints during scheduling.\"\n                    },\n                    {\n                        \"name\": \"profile_data_\",\n                        \"type\": \"const ProfileDataFromFile*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Profile data for branch prediction hints.\"\n                    },\n                    {\n                        \"name\": \"common_dominator_cache_\",\n                        \"type\": \"ZoneMap<int, ZoneMap<int, BasicBlock*>*>*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Cache for common dominator computation.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Zone\",\n                    \"TFGraph\",\n                    \"Schedule\",\n                    \"Flags\",\n                    \"TickCounter\",\n                    \"ProfileDataFromFile\",\n                    \"Node\",\n                    \"BasicBlock\",\n                    \"SchedulerData\",\n                    \"ControlEquivalence\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            namespace internal {\n            namespace compiler {\n\n            class Scheduler {\n             public:\n              enum Flags {\n                kNoFlags = 0,\n                kTempSchedule = 1 << 0,\n                kSplitNodes = 1 << 1\n              };\n\n              struct SchedulerData {\n                BasicBlock* minimum_block_;\n                int unscheduled_count_;\n                Placement placement_;\n              };\n\n              enum Placement { kUnknown, kFixed, kCoupled, kSchedulable, kScheduled };\n\n              Scheduler(Zone* zone, TFGraph* graph, Schedule* schedule, Flags flags,\n                          size_t node_count_hint, TickCounter* tick_counter,\n                          const ProfileDataFromFile* profile_data);\n\n              Schedule* ComputeSchedule(Zone* zone, TFGraph* graph, Flags flags,\n                                          TickCounter* tick_counter,\n                                          const ProfileDataFromFile* profile_data);\n\n              SchedulerData DefaultSchedulerData();\n\n              SchedulerData* GetData(Node* node);\n\n              Placement InitializePlacement(Node* node);\n              Placement GetPlacement(Node* node);\n              bool IsLive(Node* node);\n              void UpdatePlacement(Node* node, Placement placement);\n              std::optional<int> GetCoupledControlEdge(Node* node);\n\n              void IncrementUnscheduledUseCount(Node* node, Node* from);\n              void DecrementUnscheduledUseCount(Node* node, Node* from);\n\n              void BuildCFG();\n              BasicBlockVector* ComputeSpecialRPO(Zone* zone, Schedule* schedule);\n              void ComputeSpecialRPONumbering();\n              BasicBlock* GetCommonDominatorIfCached(BasicBlock* b1, BasicBlock* b2);\n              BasicBlock* GetCommonDominator(BasicBlock* b1, BasicBlock* b2);\n              void PropagateImmediateDominators(BasicBlock* block);\n              void GenerateDominatorTree(Schedule* schedule);\n              void GenerateDominatorTree();\n\n              void PrepareUses();\n\n              void ScheduleEarly();\n\n              void ScheduleLate();\n\n              void SealFinalSchedule();\n              void FuseFloatingControl(BasicBlock* block, Node* node);\n              void MovePlannedNodes(BasicBlock* from, BasicBlock* to);\n\n              private:\n              Zone* zone_;\n              TFGraph* graph_;\n              Schedule* schedule_;\n              Flags flags_;\n              ZoneVector<Node*> scheduled_nodes_;\n              ZoneVector<Node*> schedule_root_nodes_;\n              ZoneQueue<Node*> schedule_queue_;\n              ZoneVector<SchedulerData> node_data_;\n              TickCounter* tick_counter_;\n              const ProfileDataFromFile* profile_data_;\n              ZoneMap<int, ZoneMap<int, BasicBlock*>*>* common_dominator_cache_;\n              ControlEquivalence* equivalence_; // Used for minimal SESE detection.\n              class CFGBuilder* control_flow_builder_; // Helper class for building CFGs.\n              class SpecialRPONumberer* special_rpo_; // Helper class for RPO numbering.\n            };\n\n            }  // namespace compiler\n            }  // namespace internal\n            }  // namespace v8\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Scheduler\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Constructor for the Scheduler class.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to allocate from.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The Turbofan graph to schedule.\"\n                    },\n                    {\n                        \"name\": \"schedule\",\n                        \"type\": \"Schedule*\",\n                        \"purpose\": \"The schedule object to populate.\"\n                    },\n                    {\n                        \"name\": \"flags\",\n                        \"type\": \"Flags\",\n                        \"purpose\": \"Scheduling flags.\"\n                    },\n                    {\n                        \"name\": \"node_count_hint\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"Hint for the number of nodes in the graph.\"\n                    },\n                    {\n                        \"name\": \"tick_counter\",\n                        \"type\": \"TickCounter*\",\n                        \"purpose\": \"A tick counter to check for safepoints.\"\n                    },\n                    {\n                        \"name\": \"profile_data\",\n                        \"type\": \"const ProfileDataFromFile*\",\n                        \"purpose\": \"Profile data for branch prediction.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            Scheduler::Scheduler(Zone* zone, TFGraph* graph, Schedule* schedule,\n                                 Flags flags, size_t node_count_hint,\n                                 TickCounter* tick_counter,\n                                 const ProfileDataFromFile* profile_data)\n                : zone_(zone),\n                  graph_(graph),\n                  schedule_(schedule),\n                  flags_(flags),\n                  scheduled_nodes_(zone),\n                  schedule_root_nodes_(zone),\n                  schedule_queue_(zone),\n                  node_data_(zone),\n                  tick_counter_(tick_counter),\n                  profile_data_(profile_data),\n                  common_dominator_cache_(zone) {\n              node_data_.reserve(node_count_hint);\n              node_data_.resize(graph->NodeCount(), DefaultSchedulerData());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ComputeSchedule\",\n                \"about\": \"Static method to compute the schedule for a given graph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to allocate from.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The Turbofan graph to schedule.\"\n                    },\n                    {\n                        \"name\": \"flags\",\n                        \"type\": \"Flags\",\n                        \"purpose\": \"Scheduling flags.\"\n                    },\n                    {\n                        \"name\": \"tick_counter\",\n                        \"type\": \"TickCounter*\",\n                        \"purpose\": \"A tick counter to check for safepoints.\"\n                    },\n                    {\n                        \"name\": \"profile_data\",\n                        \"type\": \"const ProfileDataFromFile*\",\n                        \"purpose\": \"Profile data for branch prediction.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Schedule*\",\n                    \"description\": \"The computed schedule.\"\n                },\n                \"dependencies\": [\n                    \"Scheduler\",\n                    \"Schedule\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Schedule* Scheduler::ComputeSchedule(Zone* zone, TFGraph* graph, Flags flags,\n                                                 TickCounter* tick_counter,\n                                                 const ProfileDataFromFile* profile_data) {\n              Zone* schedule_zone =\n                  (flags & Scheduler::kTempSchedule) ? zone : graph->zone();\n\n              // Reserve 10% more space for nodes if node splitting is enabled to try to\n              // avoid resizing the vector since that would triple its zone memory usage.\n              float node_hint_multiplier = (flags & Scheduler::kSplitNodes) ? 1.1 : 1;\n              size_t node_count_hint = node_hint_multiplier * graph->NodeCount();\n\n              Schedule* schedule =\n                  schedule_zone->New<Schedule>(schedule_zone, node_count_hint);\n              Scheduler scheduler(zone, graph, schedule, flags, node_count_hint,\n                                  tick_counter, profile_data);\n\n              scheduler.BuildCFG();\n              scheduler.ComputeSpecialRPONumbering();\n              scheduler.GenerateDominatorTree();\n\n              scheduler.PrepareUses();\n              scheduler.ScheduleEarly();\n              scheduler.ScheduleLate();\n\n              scheduler.SealFinalSchedule();\n\n              return schedule;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DefaultSchedulerData\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Returns the default scheduler data.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Scheduler::SchedulerData\",\n                    \"description\": \"Default scheduler data with the start block and other initial values.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            Scheduler::SchedulerData Scheduler::DefaultSchedulerData() {\n              SchedulerData def = {schedule_->start(), 0, kUnknown};\n              return def;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetData\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Returns a pointer to the scheduler data for a given node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to get data for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Scheduler::SchedulerData*\",\n                    \"description\": \"Pointer to the scheduler data.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            Scheduler::SchedulerData* Scheduler::GetData(Node* node) {\n              return &node_data_[node->id()];\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InitializePlacement\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Initializes the placement of a node based on its opcode.\",\n                \"logic\": \"Nodes are initially marked as kUnknown. Based on opcode, sets to kFixed, kCoupled, or kSchedulable. Parameters and OSR values are fixed to the start block. Phis are coupled to their control input if it's fixed, otherwise, coupled to floating control node.  Control nodes not reachable from end may float.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to initialize placement for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Scheduler::Placement\",\n                    \"description\": \"The initial placement of the node.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            Scheduler::Placement Scheduler::InitializePlacement(Node* node) {\n              SchedulerData* data = GetData(node);\n              if (data->placement_ == kFixed) {\n                // Nothing to do for control nodes that have been already fixed in\n                // the schedule.\n                return data->placement_;\n              }\n              DCHECK_EQ(kUnknown, data->placement_);\n              switch (node->opcode()) {\n                case IrOpcode::kParameter:\n                case IrOpcode::kOsrValue:\n                  // Parameters and OSR values are always fixed to the start block.\n                  data->placement_ = kFixed;\n                  break;\n                case IrOpcode::kPhi:\n                case IrOpcode::kEffectPhi: {\n                  // Phis and effect phis are fixed if their control inputs are, whereas\n                  // otherwise they are coupled to a floating control node.\n                  Placement p = GetPlacement(NodeProperties::GetControlInput(node));\n                  data->placement_ = (p == kFixed ? kFixed : kCoupled);\n                  break;\n                }\n                default:\n                  // Control nodes that were not control-reachable from end may float.\n                  data->placement_ = kSchedulable;\n                  break;\n              }\n              return data->placement_;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetPlacement\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Returns the placement of a node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to get the placement for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Scheduler::Placement\",\n                    \"description\": \"The placement of the node.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            Scheduler::Placement Scheduler::GetPlacement(Node* node) {\n              return GetData(node)->placement_;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsLive\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Checks if a node is live (has a placement).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check liveness for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the node is live, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            bool Scheduler::IsLive(Node* node) { return GetPlacement(node) != kUnknown; }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"UpdatePlacement\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Updates the placement of a node and propagates the change to its uses.\",\n                \"logic\": \"Control nodes force coupled uses to be placed. Updates unscheduled use counts of node inputs. Sets placement to kScheduled when complete.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to update the placement for.\"\n                    },\n                    {\n                        \"name\": \"placement\",\n                        \"type\": \"Scheduler::Placement\",\n                        \"purpose\": \"The new placement of the node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            void Scheduler::UpdatePlacement(Node* node, Placement placement) {\n              SchedulerData* data = GetData(node);\n              if (data->placement_ == kUnknown) {\n                // We only update control nodes from {kUnknown} to {kFixed}.  Ideally, we\n                // should check that {node} is a control node (including exceptional calls),\n                // but that is expensive.\n                DCHECK_EQ(Scheduler::kFixed, placement);\n                data->placement_ = placement;\n                return;\n              }\n\n              switch (node->opcode()) {\n                case IrOpcode::kParameter:\n                  // Parameters are fixed once and for all.\n                  UNREACHABLE();\n                case IrOpcode::kPhi:\n                case IrOpcode::kEffectPhi: {\n                  // Phis and effect phis are coupled to their respective blocks.\n                  DCHECK_EQ(Scheduler::kCoupled, data->placement_);\n                  DCHECK_EQ(Scheduler::kFixed, placement);\n                  Node* control = NodeProperties::GetControlInput(node);\n                  BasicBlock* block = schedule_->block(control);\n                  schedule_->AddNode(block, node);\n                  break;\n                }\n            #define DEFINE_CONTROL_CASE(V) case IrOpcode::k##V:\n                  CONTROL_OP_LIST(DEFINE_CONTROL_CASE)\n            #undef DEFINE_CONTROL_CASE\n                  {\n                    // Control nodes force coupled uses to be placed.\n                    for (auto use : node->uses()) {\n                      if (GetPlacement(use) == Scheduler::kCoupled) {\n                        DCHECK_EQ(node, NodeProperties::GetControlInput(use));\n                        UpdatePlacement(use, placement);\n                      }\n                  }\n                  break;\n                }\n                default:\n                  DCHECK_EQ(Scheduler::kSchedulable, data->placement_);\n                  DCHECK_EQ(Scheduler::kScheduled, placement);\n                  break;\n              }\n              // Reduce the use count of the node's inputs to potentially make them\n              // schedulable. If all the uses of a node have been scheduled, then the node\n              // itself can be scheduled.\n              std::optional<int> coupled_control_edge = GetCoupledControlEdge(node);\n              for (Edge const edge : node->input_edges()) {\n                DCHECK_EQ(node, edge.from());\n                if (edge.index() != coupled_control_edge) {\n                  DecrementUnscheduledUseCount(edge.to(), node);\n                }\n              }\n              data->placement_ = placement;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetCoupledControlEdge\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Returns the control edge index for a coupled node, if it exists.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check for a coupled control edge.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<int>\",\n                    \"description\": \"The control edge index, or empty optional if not coupled.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            std::optional<int> Scheduler::GetCoupledControlEdge(Node* node) {\n              if (GetPlacement(node) == kCoupled) {\n                return NodeProperties::FirstControlIndex(node);\n              }\n              return {};\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IncrementUnscheduledUseCount\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Increments the unscheduled use count of a node.\",\n                \"logic\": \"Increments the unscheduled_count_ for the given node. If node is coupled, increments on its control input instead. Fixed nodes and coupled nodes being counted on their control input are skipped.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to increment the use count for.\"\n                    },\n                    {\n                        \"name\": \"from\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node using the node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            void Scheduler::IncrementUnscheduledUseCount(Node* node, Node* from) {\n              // Tracking use counts for fixed nodes is useless.\n              if (GetPlacement(node) == kFixed) return;\n\n              // Use count for coupled nodes is summed up on their control.\n              if (GetPlacement(node) == kCoupled) {\n                node = NodeProperties::GetControlInput(node);\n                DCHECK_NE(GetPlacement(node), Placement::kFixed);\n                DCHECK_NE(GetPlacement(node), Placement::kCoupled);\n              }\n\n              ++(GetData(node)->unscheduled_count_);\n              if (v8_flags.trace_turbo_scheduler) {\n                TRACE(\"  Use count of #%d:%s (used by #%d:%s)++ = %d\\n\", node->id(),\n                      node->op()->mnemonic(), from->id(), from->op()->mnemonic(),\n                      GetData(node)->unscheduled_count_);\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DecrementUnscheduledUseCount\",\n                \"parent\": \"Scheduler\",\n                \"about\": \"Decrements the unscheduled use count of a node, potentially making it schedulable.\",\n                \"logic\": \"Decrements the unscheduled_count_ for the given node. If node is coupled, decrements on its control input instead. If the count reaches 0, pushes the node onto the schedule queue.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to decrement the use count for.\"\n                    },\n                    {\n                        \"name\": \"from\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node that used the node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            void Scheduler::DecrementUnscheduledUseCount(Node* node, Node* from) {\n              // Tracking use counts for fixed nodes is useless.\n              if (GetPlacement(node) == kFixed) return;\n\n              // Use count for coupled nodes is summed up on their control.\n              if (GetPlacement(node) == kCoupled) {\n                node = NodeProperties::GetControlInput(node);\n                DCHECK_NE(GetPlacement(node), Placement::kFixed);\n                DCHECK_NE(GetPlacement(node), Placement::kCoupled);\n              }\n\n              DCHECK_LT(0, GetData(node)->unscheduled_count_);\n              --(GetData(node)->unscheduled_count_);\n              if (v8_flags.trace_turbo_scheduler) {\n                TRACE(\"  Use count of #%d:%s (used by #%d:%s)-- = %d\\n\", node->id(),\n                      node->op()->mnemonic(), from->id(), from->op()->mnemonic(),\n                      GetData(node)->unscheduled_count_);\n              }\n              if (GetData(node)->unscheduled_count_ == 0) {\n                TRACE(\"    newly eligible #%d:%s\\n\", node->id(), node->op()->mnemonic());\n                schedule_queue_.push(node);\n              }\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CFGBuilder\",\n                \"about\": \"Builds the Control Flow Graph (CFG) for the scheduler.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory allocation zone.\"\n                    },\n                    {\n                        \"name\": \"scheduler_\",\n                        \"type\": \"Scheduler*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the scheduler.\"\n                    },\n                    {\n                        \"name\": \"schedule_\",\n                        \"type\": \"Schedule*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the schedule.\"\n                    },\n                    {\n                        \"name\": \"queued_\",\n                        \"type\": \"NodeMarker<bool>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Marks whether a node has been queued.\"\n                    },\n                    {\n                        \"name\": \"queue_\",\n                        \"type\": \"ZoneQueue<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Queue for breadth-first traversal.\"\n                    },\n                    {\n                        \"name\": \"control_\",\n                        \"type\": \"NodeVector\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of encountered control nodes.\"\n                    },\n                    {\n                        \"name\": \"component_entry_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Component single-entry node.\"\n                    },\n                    {\n                        \"name\": \"component_start_\",\n                        \"type\": \"BasicBlock*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Component single-entry block.\"\n                    },\n                    {\n                        \"name\": \"component_end_\",\n                        \"type\": \"BasicBlock*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Component single-exit block.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Zone\",\n                    \"Scheduler\",\n                    \"Schedule\",\n                    \"Node\",\n                    \"BasicBlock\",\n                    \"NodeMarker\",\n                    \"ControlEquivalence\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // Internal class to build a control flow graph (i.e the basic blocks and edges\n            // between them within a Schedule) from the node graph. Visits control edges of\n            // the graph backwards from an end node in order to find the connected control\n            // subgraph, needed for scheduling.\n            class CFGBuilder : public ZoneObject {\n             public:\n              CFGBuilder(Zone* zone, Scheduler* scheduler)\n                  : zone_(zone),\n                    scheduler_(scheduler),\n                    schedule_(scheduler->schedule_),\n                    queued_(scheduler->graph_, 2),\n                    queue_(zone),\n                    control_(zone),\n                    component_entry_(nullptr),\n                    component_start_(nullptr),\n                    component_end_(nullptr) {}\n\n              // Run the control flow graph construction algorithm by walking the graph\n              // backwards from end through control edges, building and connecting the\n              // basic blocks for control nodes.\n              void Run() {\n                ResetDataStructures();\n                Queue(scheduler_->graph_->end());\n\n                while (!queue_.empty()) {  // Breadth-first backwards traversal.\n                  scheduler_->tick_counter_->TickAndMaybeEnterSafepoint();\n                  Node* node = queue_.front();\n                  queue_.pop();\n                  int max = NodeProperties::PastControlIndex(node);\n                  for (int i = NodeProperties::FirstControlIndex(node); i < max; i++) {\n                    Queue(node->InputAt(i));\n                  }\n                }\n\n                for (NodeVector::iterator i = control_.begin(); i != control_.end(); ++i) {\n                  ConnectBlocks(*i);  // Connect block to its predecessor/successors.\n                }\n              }\n\n              // Run the control flow graph construction for a minimal control-connected\n              // component ending in {exit} and merge that component into an existing\n              // control flow graph at the bottom of {block}.\n              void Run(BasicBlock* block, Node* exit) {\n                ResetDataStructures();\n                Queue(exit);\n\n                component_entry_ = nullptr;\n                component_start_ = block;\n                component_end_ = schedule_->block(exit);\n                scheduler_->equivalence_->Run(exit);\n                while (!queue_.empty()) {  // Breadth-first backwards traversal.\n                  scheduler_->tick_counter_->TickAndMaybeEnterSafepoint();\n                  Node* node = queue_.front();\n                  queue_.pop();\n\n                  // Use control dependence equivalence to find a canonical single-entry\n                  // single-exit region that makes up a minimal component to be scheduled.\n                  if (IsSingleEntrySingleExitRegion(node, exit)) {\n                    TRACE(\"Found SESE at #%d:%s\\n\", node->id(), node->op()->mnemonic());\n                    DCHECK(!component_entry_);\n                    component_entry_ = node;\n                    continue;\n                  }\n\n                  int max = NodeProperties::PastControlIndex(node);\n                  for (int i = NodeProperties::FirstControlIndex(node); i < max; i++) {\n                    Queue(node->InputAt(i));\n                  }\n                }\n                DCHECK(component_entry_);\n\n                for (NodeVector::iterator i = control_.begin(); i != control_.end(); ++i) {\n                  ConnectBlocks(*i);  // Connect block to its predecessor/successors.\n                }\n              }\n\n             private:\n              friend class ScheduleLateNodeVisitor;\n              friend class Scheduler;\n\n              void FixNode(BasicBlock* block, Node* node) {\n                schedule_->AddNode(block, node);\n                scheduler_->UpdatePlacement(node, Scheduler::kFixed);\n              }\n\n              void Queue(Node* node) {\n                // Mark the connected control nodes as they are queued.\n                if (!queued_.Get(node)) {\n                  BuildBlocks(node);\n                  queue_.push(node);\n                  queued_.Set(node, true);\n                  control_.push_back(node);\n                }\n              }\n\n              void BuildBlocks(Node* node) {\n                switch (node->opcode()) {\n                  case IrOpcode::kEnd:\n                    FixNode(schedule_->end(), node);\n                    break;\n                  case IrOpcode::kStart:\n                    FixNode(schedule_->start(), node);\n                    break;\n                  case IrOpcode::kLoop:\n                  case IrOpcode::kMerge:\n                    BuildBlockForNode(node);\n                    break;\n                  case IrOpcode::kTerminate: {\n                    // Put Terminate in the loop to which it refers.\n                    Node* loop = NodeProperties::GetControlInput(node);\n                    BasicBlock* block = BuildBlockForNode(loop);\n                    FixNode(block, node);\n                    break;\n                  }\n                  case IrOpcode::kBranch:\n                  case IrOpcode::kSwitch:\n                    BuildBlocksForSuccessors(node);\n                    break;\n            #define BUILD_BLOCK_JS_CASE(Name, ...) case IrOpcode::k##Name:\n                    JS_OP_LIST(BUILD_BLOCK_JS_CASE)\n            // JS opcodes are just like calls => fall through.\n            #undef BUILD_BLOCK_JS_CASE\n                  case IrOpcode::kCall:\n                  case IrOpcode::kFastApiCall:\n                    "
}