{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/logging/counters.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/logging/counters.h\",\n            \"file_name\": \"counters.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines classes for managing and tracking performance counters and histograms within the V8 JavaScript engine.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for memory management, atomic operations, platform abstractions, data structures, and logging.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <memory>\n\n#include \"include/v8-callbacks.h\"\n#include \"src/base/atomic-utils.h\"\n#include \"src/base/platform/elapsed-timer.h\"\n#include \"src/base/platform/time.h\"\n#include \"src/common/globals.h\"\n#include \"src/logging/counters-definitions.h\"\n#include \"src/logging/runtime-call-stats.h\"\n#include \"src/objects/code-kind.h\"\n#include \"src/objects/objects.h\"\n#include \"src/utils/allocation.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StatsTable\",\n                \"about\": \"Provides an interface for external counters and histograms.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"lookup_function_\",\n                        \"type\": \"CounterLookupCallback\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Function pointer for looking up counter locations.\"\n                    },\n                    {\n                        \"name\": \"create_histogram_function_\",\n                        \"type\": \"CreateHistogramCallback\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Function pointer for creating histograms.\"\n                    },\n                    {\n                        \"name\": \"add_histogram_sample_function_\",\n                        \"type\": \"AddHistogramSampleCallback\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Function pointer for adding samples to histograms.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"CounterLookupCallback\",\n                    \"CreateHistogramCallback\",\n                    \"AddHistogramSampleCallback\",\n                    \"Counters\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass StatsTable {\n public:\n  StatsTable(const StatsTable&) = delete;\n  StatsTable& operator=(const StatsTable&) = delete;\n\n  // Register an application-defined function for recording\n  // subsequent counter statistics.\n  void SetCounterFunction(CounterLookupCallback f);\n\n  // Register an application-defined function to create histograms for\n  // recording subsequent histogram samples.\n  void SetCreateHistogramFunction(CreateHistogramCallback f) {\n    create_histogram_function_ = f;\n  }\n\n  // Register an application-defined function to add a sample\n  // to a histogram created with CreateHistogram function.\n  void SetAddHistogramSampleFunction(AddHistogramSampleCallback f) {\n    add_histogram_sample_function_ = f;\n  }\n\n  bool HasCounterFunction() const { return lookup_function_ != nullptr; }\n\n  // Lookup the location of a counter by name.  If the lookup\n  // is successful, returns a non-nullptr pointer for writing the\n  // value of the counter.  Each thread calling this function\n  // may receive a different location to store it's counter.\n  // The return value must not be cached and reused across\n  // threads, although a single thread is free to cache it.\n  int* FindLocation(const char* name) {\n    if (!lookup_function_) return nullptr;\n    return lookup_function_(name);\n  }\n\n  // Create a histogram by name. If the create is successful,\n  // returns a non-nullptr pointer for use with AddHistogramSample\n  // function. min and max define the expected minimum and maximum\n  // sample values. buckets is the maximum number of buckets\n  // that the samples will be grouped into.\n  void* CreateHistogram(const char* name, int min, int max, size_t buckets) {\n    if (!create_histogram_function_) return nullptr;\n    return create_histogram_function_(name, min, max, buckets);\n  }\n\n  // Add a sample to a histogram created with the CreateHistogram\n  // function.\n  void AddHistogramSample(void* histogram, int sample) {\n    if (!add_histogram_sample_function_) return;\n    return add_histogram_sample_function_(histogram, sample);\n  }\n\n private:\n  friend class Counters;\n\n  explicit StatsTable(Counters* counters);\n\n  CounterLookupCallback lookup_function_;\n  CreateHistogramCallback create_histogram_function_;\n  AddHistogramSampleCallback add_histogram_sample_function_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StatsCounter\",\n                \"about\": \"Represents a dynamically created value tracked in the StatsTable, designed to be lightweight and easy to use. This class is thread-safe.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"counters_\",\n                        \"type\": \"Counters*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Counters object.\"\n                    },\n                    {\n                        \"name\": \"name_\",\n                        \"type\": \"const char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Name of the counter.\"\n                    },\n                    {\n                        \"name\": \"ptr_\",\n                        \"type\": \"std::atomic<std::atomic<int>*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Atomic pointer to the counter's memory location.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Counters\",\n                    \"CountersInitializer\",\n                    \"StatsCounterResetter\",\n                    \"V8_EXPORT_PRIVATE\",\n                    \"V8_NOINLINE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass StatsCounter {\n public:\n  void Set(int value) { GetPtr()->store(value, std::memory_order_relaxed); }\n  int Get() { return GetPtr()->load(); }\n\n  void Increment(int value = 1) {\n    GetPtr()->fetch_add(value, std::memory_order_relaxed);\n  }\n\n  void Decrement(int value = 1) {\n    GetPtr()->fetch_sub(value, std::memory_order_relaxed);\n  }\n\n  // Returns true if this counter is enabled (a lookup function was provided and\n  // it returned a non-null pointer).\n  V8_EXPORT_PRIVATE bool Enabled();\n\n  // Get the internal pointer to the counter. This is used\n  // by the code generator to emit code that manipulates a\n  // given counter without calling the runtime system.\n  std::atomic<int>* GetInternalPointer() { return GetPtr(); }\n\n private:\n  friend class Counters;\n  friend class CountersInitializer;\n  friend class StatsCounterResetter;\n\n  void Initialize(const char* name, Counters* counters) {\n    DCHECK_NULL(counters_);\n    DCHECK_NOT_NULL(counters);\n    // Counter names always start with \"c:V8.\".\n    DCHECK_EQ(0, memcmp(name, \"c:V8.\", 5));\n    counters_ = counters;\n    name_ = name;\n  }\n\n  V8_NOINLINE V8_EXPORT_PRIVATE std::atomic<int>* SetupPtrFromStatsTable();\n\n  // Reset the cached internal pointer.\n  void Reset() { ptr_.store(nullptr, std::memory_order_relaxed); }\n\n  // Returns the cached address of this counter location.\n  std::atomic<int>* GetPtr() {\n    auto* ptr = ptr_.load(std::memory_order_acquire);\n    if (V8_LIKELY(ptr)) return ptr;\n    return SetupPtrFromStatsTable();\n  }\n\n  Counters* counters_ = nullptr;\n  const char* name_ = nullptr;\n  // A pointer to an atomic, set atomically in {GetPtr}.\n  std::atomic<std::atomic<int>*> ptr_{nullptr};\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Histogram\",\n                \"about\": \"Represents a dynamically created histogram in the StatsTable. This class is thread-safe.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"name_\",\n                        \"type\": \"const char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Name of the histogram.\"\n                    },\n                    {\n                        \"name\": \"min_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Minimum value for the histogram.\"\n                    },\n                    {\n                        \"name\": \"max_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maximum value for the histogram.\"\n                    },\n                    {\n                        \"name\": \"num_buckets_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of buckets in the histogram.\"\n                    },\n                    {\n                        \"name\": \"histogram_\",\n                        \"type\": \"std::atomic<void*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Atomic pointer to the histogram's data structure.\"\n                    },\n                    {\n                        \"name\": \"counters_\",\n                        \"type\": \"Counters*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Counters object.\"\n                    },\n                    {\n                        \"name\": \"mutex_\",\n                        \"type\": \"base::Mutex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mutex to protect histogram creation.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Counters\",\n                    \"CountersInitializer\",\n                    \"HistogramResetter\",\n                    \"base::Mutex\",\n                    \"base::MutexGuard\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass Histogram {\n public:\n  // Add a single sample to this histogram.\n  V8_EXPORT_PRIVATE void AddSample(int sample);\n\n  // Returns true if this histogram is enabled.\n  bool Enabled() { return histogram_ != nullptr; }\n\n  const char* name() const { return name_; }\n\n  int min() const { return min_; }\n  int max() const { return max_; }\n  int num_buckets() const { return num_buckets_; }\n\n  // Asserts that |expected_counters| are the same as the Counters this\n  // Histogram reports to.\n  void AssertReportsToCounters(Counters* expected_counters) {\n    DCHECK_EQ(counters_, expected_counters);\n  }\n\n protected:\n  Histogram() = default;\n  Histogram(const Histogram&) = delete;\n  Histogram& operator=(const Histogram&) = delete;\n\n  void Initialize(const char* name, int min, int max, int num_buckets,\n                  Counters* counters) {\n    name_ = name;\n    min_ = min;\n    max_ = max;\n    num_buckets_ = num_buckets;\n    histogram_ = nullptr;\n    counters_ = counters;\n    DCHECK_NOT_NULL(counters_);\n  }\n\n  Counters* counters() const { return counters_; }\n\n  // Reset the cached internal pointer to nullptr; the histogram will be\n  // created lazily, the first time it is needed.\n  void Reset() { histogram_ = nullptr; }\n\n  // Lazily create the histogram, if it has not been created yet.\n  void EnsureCreated(bool create_new = true) {\n    if (create_new && histogram_.load(std::memory_order_acquire) == nullptr) {\n      base::MutexGuard Guard(&mutex_);\n      if (histogram_.load(std::memory_order_relaxed) == nullptr)\n        histogram_.store(CreateHistogram(), std::memory_order_release);\n    }\n  }\n\n private:\n  friend class Counters;\n  friend class CountersInitializer;\n  friend class HistogramResetter;\n\n  V8_EXPORT_PRIVATE void* CreateHistogram() const;\n\n  const char* name_;\n  int min_;\n  int max_;\n  int num_buckets_;\n  std::atomic<void*> histogram_;\n  Counters* counters_;\n  base::Mutex mutex_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PercentageHistogram\",\n                \"extends\": \"Histogram\",\n                \"about\": \"A dummy class for better visiting of Percentage Histograms.\"\n            }\n        </metadata>\n        <code><![CDATA[\nclass PercentageHistogram : public Histogram {};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LegacyMemoryHistogram\",\n                \"extends\": \"Histogram\",\n                \"about\": \"A dummy class for better visiting of Legacy Memory Histograms.\"\n            }\n        </metadata>\n        <code><![CDATA[\nclass LegacyMemoryHistogram : public Histogram {};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TimedHistogram\",\n                \"extends\": \"Histogram\",\n                \"about\": \"A thread-safe histogram timer.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"resolution_\",\n                        \"type\": \"TimedHistogramResolution\",\n                        \"access\": \"protected\",\n                        \"purpose\": \"The resolution of the timed histogram (MILLISECOND or MICROSECOND).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Histogram\",\n                    \"Isolate\",\n                    \"Counters\",\n                    \"CountersInitializer\",\n                    \"base::ElapsedTimer\",\n                    \"base::TimeDelta\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nenum class TimedHistogramResolution { MILLISECOND, MICROSECOND };\n\n// A thread safe histogram timer.\nclass TimedHistogram : public Histogram {\n public:\n  // Records a TimeDelta::Max() result. Useful to record percentage of tasks\n  // that never got to run in a given scenario. Log if isolate non-null.\n  void RecordAbandon(base::ElapsedTimer* timer, Isolate* isolate);\n\n  // Add a single sample to this histogram.\n  V8_EXPORT_PRIVATE void AddTimedSample(base::TimeDelta sample);\n\n#ifdef DEBUG\n  // Ensures that we don't have nested timers for TimedHistogram per thread, use\n  // NestedTimedHistogram which correctly pause and resume timers.\n  // This method assumes that each timer is alternating between stopped and\n  // started on a single thread. Multiple timers can be active on different\n  // threads.\n  bool ToggleRunningState(bool expected_is_running) const;\n#endif  // DEBUG\n\n protected:\n  void Stop(base::ElapsedTimer* timer);\n  void LogStart(Isolate* isolate);\n  void LogEnd(Isolate* isolate);\n\n  friend class Counters;\n  friend class CountersInitializer;\n\n  TimedHistogramResolution resolution_;\n\n  TimedHistogram() = default;\n  TimedHistogram(const TimedHistogram&) = delete;\n  TimedHistogram& operator=(const TimedHistogram&) = delete;\n\n  void Initialize(const char* name, int min, int max,\n                  TimedHistogramResolution resolution, int num_buckets,\n                  Counters* counters) {\n    Histogram::Initialize(name, min, max, num_buckets, counters);\n    resolution_ = resolution;\n  }\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NestedTimedHistogram\",\n                \"extends\": \"TimedHistogram\",\n                \"about\": \"A timed histogram that supports nested scopes, correctly accounting for time even with recursive calls.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"current_\",\n                        \"type\": \"NestedTimedHistogramScope*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the currently active NestedTimedHistogramScope.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TimedHistogram\",\n                    \"Counters\",\n                    \"NestedTimedHistogramScope\",\n                    \"PauseNestedTimedHistogramScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass NestedTimedHistogramScope;\nclass PauseNestedTimedHistogramScope;\n\n// For use with the NestedTimedHistogramScope. 'Nested' here means that scopes\n// may have nested lifetimes while still correctly accounting for time, e.g.:\n//\n// void f() {\n//   NestedTimedHistogramScope timer(...);\n//   ...\n//   f();  // Recursive call.\n// }\nclass NestedTimedHistogram : public TimedHistogram {\n public:\n  // Note: public for testing purposes only.\n  NestedTimedHistogram(const char* name, int min, int max,\n                       TimedHistogramResolution resolution, int num_buckets,\n                       Counters* counters)\n      : NestedTimedHistogram() {\n    Initialize(name, min, max, resolution, num_buckets, counters);\n  }\n\n private:\n  friend class Counters;\n  friend class NestedTimedHistogramScope;\n  friend class PauseNestedTimedHistogramScope;\n\n  inline NestedTimedHistogramScope* Enter(NestedTimedHistogramScope* next) {\n    NestedTimedHistogramScope* previous = current_;\n    current_ = next;\n    return previous;\n  }\n\n  inline void Leave(NestedTimedHistogramScope* previous) {\n    current_ = previous;\n  }\n\n  NestedTimedHistogramScope* current_ = nullptr;\n\n  NestedTimedHistogram() = default;\n  NestedTimedHistogram(const NestedTimedHistogram&) = delete;\n  NestedTimedHistogram& operator=(const NestedTimedHistogram&) = delete;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AggregatableHistogramTimer\",\n                \"extends\": \"Histogram\",\n                \"about\": \"A histogram timer that can aggregate events within a larger scope.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"time_\",\n                        \"type\": \"base::TimeDelta\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Accumulated time for the aggregated scope.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Histogram\",\n                    \"Counters\",\n                    \"base::TimeDelta\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// A histogram timer that can aggregate events within a larger scope.\n//\n// Intended use of this timer is to have an outer (aggregating) and an inner\n// (to be aggregated) scope, where the inner scope measure the time of events,\n// and all those inner scope measurements will be summed up by the outer scope.\n// An example use might be to aggregate the time spent in lazy compilation\n// while running a script.\n//\n// Helpers:\n// - AggregatingHistogramTimerScope, the \"outer\" scope within which\n//     times will be summed up.\n// - AggregatedHistogramTimerScope, the \"inner\" scope which defines the\n//     events to be timed.\nclass AggregatableHistogramTimer : public Histogram {\n public:\n  // Start/stop the \"outer\" scope.\n  void Start() { time_ = base::TimeDelta(); }\n  void Stop() {\n    if (time_ != base::TimeDelta()) {\n      // Only add non-zero samples, since zero samples represent situations\n      // where there were no aggregated samples added.\n      AddSample(static_cast<int>(time_.InMicroseconds()));\n    }\n  }\n\n  // Add a time value (\"inner\" scope).\n  void Add(base::TimeDelta other) { time_ += other; }\n\n private:\n  friend class Counters;\n\n  AggregatableHistogramTimer() = default;\n  AggregatableHistogramTimer(const AggregatableHistogramTimer&) = delete;\n  AggregatableHistogramTimer& operator=(const AggregatableHistogramTimer&) =\n      delete;\n\n  base::TimeDelta time_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AggregatingHistogramTimerScope\",\n                \"about\": \"A helper class for use with AggregatableHistogramTimer. This is the outer-most timer scope used with an AggregatableHistogramTimer. It will aggregate the information from the inner AggregatedHistogramTimerScope.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"histogram_\",\n                        \"type\": \"AggregatableHistogramTimer*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the AggregatableHistogramTimer.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AggregatableHistogramTimer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// A helper class for use with AggregatableHistogramTimer. This is the\n// // outer-most timer scope used with an AggregatableHistogramTimer. It will\n// // aggregate the information from the inner AggregatedHistogramTimerScope.\nclass V8_NODISCARD AggregatingHistogramTimerScope {\n public:\n  explicit AggregatingHistogramTimerScope(AggregatableHistogramTimer* histogram)\n      : histogram_(histogram) {\n    histogram_->Start();\n  }\n  ~AggregatingHistogramTimerScope() { histogram_->Stop(); }\n\n private:\n  AggregatableHistogramTimer* histogram_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AggregatedHistogramTimerScope\",\n                \"about\": \"A helper class for use with AggregatableHistogramTimer, the inner scope which defines the events to be timed.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"timer_\",\n                        \"type\": \"base::ElapsedTimer\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Timer to measure the duration of the event.\"\n                    },\n                    {\n                        \"name\": \"histogram_\",\n                        \"type\": \"AggregatableHistogramTimer*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the AggregatableHistogramTimer.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AggregatableHistogramTimer\",\n                    \"base::ElapsedTimer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// A helper class for use with AggregatableHistogramTimer, the \"inner\" scope\n// // which defines the events to be timed.\nclass V8_NODISCARD AggregatedHistogramTimerScope {\n public:\n  explicit AggregatedHistogramTimerScope(AggregatableHistogramTimer* histogram)\n      : histogram_(histogram) {\n    timer_.Start();\n  }\n  ~AggregatedHistogramTimerScope() { histogram_->Add(timer_.Elapsed()); }\n\n private:\n  base::ElapsedTimer timer_;\n  AggregatableHistogramTimer* histogram_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AggregatedMemoryHistogram\",\n                \"about\": \"Collects (time, value) sample pairs and turns them into time-uniform samples for the backing histogram.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"is_initialized_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the histogram has been initialized.\"\n                    },\n                    {\n                        \"name\": \"start_ms_\",\n                        \"type\": \"double\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Start time in milliseconds.\"\n                    },\n                    {\n                        \"name\": \"last_ms_\",\n                        \"type\": \"double\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Last sample time in milliseconds.\"\n                    },\n                    {\n                        \"name\": \"aggregate_value_\",\n                        \"type\": \"double\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Aggregated value of samples.\"\n                    },\n                    {\n                        \"name\": \"last_value_\",\n                        \"type\": \"double\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Last sample value.\"\n                    },\n                    {\n                        \"name\": \"backing_histogram_\",\n                        \"type\": \"Histogram*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the backing histogram.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Histogram\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Histogram>\nclass AggregatedMemoryHistogram {\n public:\n  // Note: public for testing purposes only.\n  explicit AggregatedMemoryHistogram(Histogram* backing_histogram)\n      : AggregatedMemoryHistogram() {\n    backing_histogram_ = backing_histogram;\n  }\n\n  // Invariants that hold before and after AddSample if\n  // is_initialized_ is true:\n  //\n  // 1) For we processed samples that came in before start_ms_ and sent the\n  // corresponding aggregated samples to backing histogram.\n  // 2) (last_ms_, last_value_) is the last received sample.\n  // 3) last_ms_ < start_ms_ + v8_flags.histogram_interval.\n  // 4) aggregate_value_ is the average of the function that is constructed by\n  // linearly interpolating samples received between start_ms_ and last_ms_.\n  void AddSample(double current_ms, double current_value);\n\n private:\n  friend class Counters;\n\n  AggregatedMemoryHistogram()\n      : is_initialized_(false),\n        start_ms_(0.0),\n        last_ms_(0.0),\n        aggregate_value_(0.0),\n        last_value_(0.0),\n        backing_histogram_(nullptr) {}\n  double Aggregate(double current_ms, double current_value);\n\n  bool is_initialized_;\n  double start_ms_;\n  double last_ms_;\n  double aggregate_value_;\n  double last_value_;\n  Histogram* backing_histogram_;\n};\n\ntemplate <typename Histogram>\nvoid AggregatedMemoryHistogram<Histogram>::AddSample(double current_ms,\n                                                     double current_value) {\n  if (!is_initialized_) {\n    aggregate_value_ = current_value;\n    start_ms_ = current_ms;\n    last_value_ = current_value;\n    last_ms_ = current_ms;\n    is_initialized_ = true;\n  } else {\n    const double kEpsilon = 1e-6;\n    const int kMaxSamples = 1000;\n    if (current_ms < last_ms_ + kEpsilon) {\n      // Two samples have the same time, remember the last one.\n      last_value_ = current_value;\n    } else {\n      double sample_interval_ms = v8_flags.histogram_interval;\n      double end_ms = start_ms_ + sample_interval_ms;\n      if (end_ms <= current_ms + kEpsilon) {\n        // Linearly interpolate between the last_ms_ and the current_ms.\n        double slope = (current_value - last_value_) / (current_ms - last_ms_);\n        int i;\n        // Send aggregated samples to the backing histogram from the start_ms\n        // to the current_ms.\n        for (i = 0; i < kMaxSamples && end_ms <= current_ms + kEpsilon; i++) {\n          double end_value = last_value_ + (end_ms - last_ms_) * slope;\n          double sample_value;\n          if (i == 0) {\n            // Take aggregate_value_ into account.\n            sample_value = Aggregate(end_ms, end_value);\n          } else {\n            // There is no aggregate_value_ for i > 0.\n            sample_value = (last_value_ + end_value) / 2;\n          }\n          backing_histogram_->AddSample(static_cast<int>(sample_value + 0.5));\n          last_value_ = end_value;\n          last_ms_ = end_ms;\n          end_ms += sample_interval_ms;\n        }\n        if (i == kMaxSamples) {\n          // We hit the sample limit, ignore the remaining samples.\n          aggregate_value_ = current_value;\n          start_ms_ = current_ms;\n        } else {\n          aggregate_value_ = last_value_;\n          start_ms_ = last_ms_;\n        }\n      }\n      aggregate_value_ = current_ms > start_ms_ + kEpsilon\n                             ? Aggregate(current_ms, current_value)\n                             : aggregate_value_;\n      last_value_ = current_value;\n      last_ms_ = current_ms;\n    }\n  }\n}\n\ntemplate <typename Histogram>\ndouble AggregatedMemoryHistogram<Histogram>::Aggregate(double current_ms,\n                                                       double current_value) {\n  double interval_ms = current_ms - start_ms_;\n  double value = (current_value + last_value_) / 2;\n  // The aggregate_value_ is the average for [start_ms_; last_ms_].\n  // The value is the average for [last_ms_; current_ms].\n  // Return the weighted average of the aggregate_value_ and the value.\n  return aggregate_value_ * ((last_ms_ - start_ms_) / interval_ms) +\n         value * ((current_ms - last_ms_) / interval_ms);\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Counters\",\n                \"extends\": \"std::enable_shared_from_this<Counters>\",\n                \"about\": \"Manages all V8 counters and histograms. This class holds instances of StatsCounter and Histogram objects, providing access to them.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Isolate object.\"\n                    },\n                    {\n                        \"name\": \"stats_table_\",\n                        \"type\": \"StatsTable\",\n                        \"access\": \"private\",\n                        \"purpose\": \"StatsTable instance for managing counters.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"StatsTable\",\n                    \"Histogram\",\n                    \"NestedTimedHistogram\",\n                    \"TimedHistogram\",\n                    \"AggregatableHistogramTimer\",\n                    \"PercentageHistogram\",\n                    \"LegacyMemoryHistogram\",\n                    \"StatsCounter\",\n                    \"RuntimeCallStats\",\n                    \"WorkerThreadRuntimeCallStats\",\n                    \"HISTOGRAM_RANGE_LIST\",\n                    \"HISTOGRAM_RANGE_LIST_SLOW\",\n                    \"NESTED_TIMED_HISTOGRAM_LIST\",\n                    \"NESTED_TIMED_HISTOGRAM_LIST_SLOW\",\n                    \"TIMED_HISTOGRAM_LIST\",\n                    \"AGGREGATABLE_HISTOGRAM_TIMER_LIST\",\n                    \"HISTOGRAM_PERCENTAGE_LIST\",\n                    \"HISTOGRAM_LEGACY_MEMORY_LIST\",\n                    \"STATS_COUNTER_LIST\",\n                    \"STATS_COUNTER_NATIVE_CODE_LIST\",\n                    \"INSTANCE_TYPE_LIST\",\n                    \"CODE_KIND_LIST\",\n                    \"RuntimeCallStats\",\n                    \"WorkerThreadRuntimeCallStats\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// This file contains all the v8 counters that are in use.\nclass Counters : public std::enable_shared_from_this<Counters> {\n public:\n  explicit Counters(Isolate* isolate);\n\n  // Register an application-defined function for recording\n  // subsequent counter statistics. Note: Must be called on the main\n  // thread.\n  void ResetCounterFunction(CounterLookupCallback f);\n\n  // Register an application-defined function to create histograms for\n  // recording subsequent histogram samples. Note: Must be called on\n  // the main thread.\n  void ResetCreateHistogramFunction(CreateHistogramCallback f);\n\n  // Register an application-defined function to add a sample\n  // to a histogram. Will be used in all subsequent sample additions.\n  // Note: Must be called on the main thread.\n  void SetAddHistogramSampleFunction(AddHistogramSampleCallback f) {\n    stats_table_.SetAddHistogramSampleFunction(f);\n  }\n\n#define HR(name, caption, min, max, num_buckets) \\\n  Histogram* name() {                            \\\n    name##_.EnsureCreated();                     \\\n    return &name##_;                             \\\n  }\n  HISTOGRAM_RANGE_LIST(HR)\n#undef HR\n\n#if V8_ENABLE_DRUMBRAKE\n#define HR(name, caption, min, max, num_buckets)     \\\n  Histogram* name() {                                \\\n    name##_.EnsureCreated(v8_flags.slow_histograms); \\\n    return &name##_;                                 \\\n  }\n  HISTOGRAM_RANGE_LIST_SLOW(HR)\n#undef HR\n#endif  // V8_ENABLE_DRUMBRAKE\n\n#define HT(name, caption, max, res) \\\n  NestedTimedHistogram* name() {    \\\n    name##_.EnsureCreated();        \\\n    return &name##_;                \\\n  }\n  NESTED_TIMED_HISTOGRAM_LIST(HT)\n#undef HT\n\n#define HT(name, caption, max, res)                  \\\n  NestedTimedHistogram* name() {                     \\\n    name##_.EnsureCreated(v8_flags.slow_histograms); \\\n    return &name##_;                                 \\\n  }\n  NESTED_TIMED_HISTOGRAM_LIST_SLOW(HT)\n#undef HT\n\n#define HT(name, caption, max, res) \\\n  TimedHistogram* name() {          \\\n    name##_.EnsureCreated();        \\\n    return &name##_;                \\\n  }\n  TIMED_HISTOGRAM_LIST(HT)\n#undef HT\n\n#define AHT(name, caption)             \\\n  AggregatableHistogramTimer* name() { \\\n    name##_.EnsureCreated();           \\\n    return &name##_;                   \\\n  }\n  AGGREGATABLE_HISTOGRAM_TIMER_LIST(AHT)\n#undef AHT\n\n#define HP(name, caption)       \\\n  PercentageHistogram* name() { \\\n    name##_.EnsureCreated();    \\\n    return &name##_;            \\\n  }\n  HISTOGRAM_PERCENTAGE_LIST(HP)\n#undef HP\n\n#define HM(name, caption)         \\\n  LegacyMemoryHistogram* name() { \\\n    name##_.EnsureCreated();      \\\n    return &name##_;              \\\n  }\n  HISTOGRAM_LEGACY_MEMORY_LIST(HM)\n#undef HM\n\n#define SC(name, caption) \\\n  StatsCounter* name() {"
}