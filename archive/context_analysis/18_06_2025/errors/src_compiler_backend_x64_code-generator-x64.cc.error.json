{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/x64/code-generator-x64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/x64/code-generator-x64.cc\",\n            \"file_name\": \"code-generator-x64.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the X64-specific code generator for the V8 compiler backend.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for standard library, V8 base, code generation, compiler backend, execution, heap, and objects.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <limits>\n#include <optional>\n\n#include \"src/base/logging.h\"\n#include \"src/base/overflowing-math.h\"\n#include \"src/builtins/builtins.h\"\n#include \"src/codegen/assembler.h\"\n#include \"src/codegen/cpu-features.h\"\n#include \"src/codegen/external-reference.h\"\n#include \"src/codegen/interface-descriptors-inl.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/codegen/x64/assembler-x64.h\"\n#include \"src/codegen/x64/register-x64.h\"\n#include \"src/common/globals.h\"\n#include \"src/common/ptr-compr-inl.h\"\n#include \"src/compiler/backend/code-generator-impl.h\"\n#include \"src/compiler/backend/code-generator.h\"\n#include \"src/compiler/backend/gap-resolver.h\"\n#include \"src/compiler/backend/instruction-codes.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/osr.h\"\n#include \"src/execution/frame-constants.h\"\n#include \"src/heap/mutable-page-metadata.h\"\n#include \"src/objects/code-kind.h\"\n#include \"src/objects/smi.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-linkage.h\"\n#include \"src/wasm/wasm-objects.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"FirstMacroFusionInstKind\",\n                \"about\": \"Enumerates the possible kinds of the first instruction in a macro-fused instruction pair.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class FirstMacroFusionInstKind {\n  // TEST\n  kTest,\n  // CMP\n  kCmp,\n  // AND\n  kAnd,\n  // ADD, SUB\n  kAddSub,\n  // INC, DEC\n  kIncDec,\n  // Not valid as a first macro fusion instruction.\n  kInvalid\n};\n        ]]></code>\n    </enum>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"SecondMacroFusionInstKind\",\n                \"about\": \"Enumerates the possible kinds of the second instruction in a macro-fused instruction pair, specifically jump instructions.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class SecondMacroFusionInstKind {\n  // JA, JB and variants.\n  kAB,\n  // JE, JL, JG and variants.\n  kELG,\n  // Not a fusible jump.\n  kInvalid,\n};\n        ]]></code>\n    </enum>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsMacroFused\",\n                \"about\": \"Determines whether two instruction kinds (first and second) can be macro-fused.\",\n                \"logic\": \"Uses a switch statement to check compatibility based on the first instruction kind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"first_kind\",\n                        \"type\": \"FirstMacroFusionInstKind\",\n                        \"purpose\": \"The kind of the first instruction.\"\n                    },\n                    {\n                        \"name\": \"second_kind\",\n                        \"type\": \"SecondMacroFusionInstKind\",\n                        \"purpose\": \"The kind of the second instruction (jump).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instructions can be macro-fused, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool IsMacroFused(FirstMacroFusionInstKind first_kind,\n                  SecondMacroFusionInstKind second_kind) {\n  switch (first_kind) {\n    case FirstMacroFusionInstKind::kTest:\n    case FirstMacroFusionInstKind::kAnd:\n      return true;\n    case FirstMacroFusionInstKind::kCmp:\n    case FirstMacroFusionInstKind::kAddSub:\n      return second_kind == SecondMacroFusionInstKind::kAB ||\n             second_kind == SecondMacroFusionInstKind::kELG;\n    case FirstMacroFusionInstKind::kIncDec:\n      return second_kind == SecondMacroFusionInstKind::kELG;\n    case FirstMacroFusionInstKind::kInvalid:\n      return false;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetSecondMacroFusionInstKind\",\n                \"about\": \"Determines the SecondMacroFusionInstKind based on a FlagsCondition.\",\n                \"logic\": \"Maps FlagsCondition values (representing different jump conditions) to their corresponding SecondMacroFusionInstKind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"condition\",\n                        \"type\": \"FlagsCondition\",\n                        \"purpose\": \"The condition code for the jump instruction.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"SecondMacroFusionInstKind\",\n                    \"description\": \"The corresponding SecondMacroFusionInstKind, or kInvalid if no match is found.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nSecondMacroFusionInstKind GetSecondMacroFusionInstKind(\n    FlagsCondition condition) {\n  switch (condition) {\n    // JE,JZ\n    case kEqual:\n      // JNE,JNZ\n    case kNotEqual:\n    // JL,JNGE\n    case kSignedLessThan:\n    // JLE,JNG\n    case kSignedLessThanOrEqual:\n    // JG,JNLE\n    case kSignedGreaterThan:\n    // JGE,JNL\n    case kSignedGreaterThanOrEqual:\n      return SecondMacroFusionInstKind::kELG;\n    // JB,JC\n    case kUnsignedLessThan:\n    // JNA,JBE\n    case kUnsignedLessThanOrEqual:\n    // JA,JNBE\n    case kUnsignedGreaterThan:\n    // JAE,JNC,JNB\n    case kUnsignedGreaterThanOrEqual:\n      return SecondMacroFusionInstKind::kAB;\n    default:\n      return SecondMacroFusionInstKind::kInvalid;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ShouldAlignForJCCErratum\",\n                \"about\": \"Determines if the code should be aligned to mitigate the Intel JCC erratum.\",\n                \"logic\": \"Checks if the erratum mitigation is enabled, and if the instruction is a macro-fused branch. Uses CpuFeatures and IsMacroFused functions.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    },\n                    {\n                        \"name\": \"first_kind\",\n                        \"type\": \"FirstMacroFusionInstKind\",\n                        \"purpose\": \"The kind of the first instruction in the potential macro-fusion.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if alignment is needed, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"CpuFeatures\",\n                    \"IsMacroFused\",\n                    \"GetSecondMacroFusionInstKind\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool ShouldAlignForJCCErratum(Instruction* instr,\n                              FirstMacroFusionInstKind first_kind) {\n  if (!CpuFeatures::IsSupported(INTEL_JCC_ERRATUM_MITIGATION)) return false;\n  FlagsMode mode = FlagsModeField::decode(instr->opcode());\n  if (mode == kFlags_branch || mode == kFlags_deoptimize) {\n    FlagsCondition condition = FlagsConditionField::decode(instr->opcode());\n    if (IsMacroFused(first_kind, GetSecondMacroFusionInstKind(condition))) {\n      return true;\n    }\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"X64OperandConverter\",\n                \"extends\": \"InstructionOperandConverter\",\n                \"about\": \"A helper class to convert InstructionOperands to X64-specific Operands.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"CodeGenerator\",\n                    \"InstructionOperandConverter\",\n                    \"InstructionOperand\",\n                    \"Immediate\",\n                    \"Operand\",\n                    \"Constant\",\n                    \"AllocatedOperand\",\n                    \"FrameOffset\",\n                    \"ScaleFactor\",\n                    \"AddressingMode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// Adds X64 specific methods for decoding operands.\nclass X64OperandConverter : public InstructionOperandConverter {\n public:\n  X64OperandConverter(CodeGenerator* gen, Instruction* instr)\n      : InstructionOperandConverter(gen, instr) {}\n\n  Immediate InputImmediate(size_t index) {\n    return ToImmediate(instr_->InputAt(index));\n  }\n\n  Operand InputOperand(size_t index, int extra = 0) {\n    return ToOperand(instr_->InputAt(index), extra);\n  }\n\n  Operand OutputOperand() { return ToOperand(instr_->Output()); }\n\n  Immediate ToImmediate(InstructionOperand* operand) {\n    Constant constant = ToConstant(operand);\n    if (constant.type() == Constant::kCompressedHeapObject) {\n      CHECK(COMPRESS_POINTERS_BOOL);\n      CHECK(V8_STATIC_ROOTS_BOOL || !gen_->isolate()->bootstrapper());\n      RootIndex root_index;\n      CHECK(gen_->isolate()->roots_table().IsRootHandle(constant.ToHeapObject(),\n                                                        &root_index));\n      return Immediate(\n          MacroAssemblerBase::ReadOnlyRootPtr(root_index, gen_->isolate()));\n    }\n    if (constant.type() == Constant::kFloat64) {\n      DCHECK_EQ(0, constant.ToFloat64().AsUint64());\n      return Immediate(0);\n    }\n    return Immediate(constant.ToInt32(), constant.rmode());\n  }\n\n  Operand ToOperand(InstructionOperand* op, int extra = 0) {\n    DCHECK(op->IsStackSlot() || op->IsFPStackSlot());\n    return SlotToOperand(AllocatedOperand::cast(op)->index(), extra);\n  }\n\n  Operand SlotToOperand(int slot_index, int extra = 0) {\n    FrameOffset offset = frame_access_state()->GetFrameOffset(slot_index);\n    return Operand(offset.from_stack_pointer() ? rsp : rbp,\n                   offset.offset() + extra);\n  }\n\n  static size_t NextOffset(size_t* offset) {\n    size_t i = *offset;\n    (*offset)++;\n    return i;\n  }\n\n  static ScaleFactor ScaleFor(AddressingMode one, AddressingMode mode) {\n    static_assert(0 == static_cast<int>(times_1));\n    static_assert(1 == static_cast<int>(times_2));\n    static_assert(2 == static_cast<int>(times_4));\n    static_assert(3 == static_cast<int>(times_8));\n    int scale = static_cast<int>(mode - one);\n    DCHECK(scale >= 0 && scale < 4);\n    return static_cast<ScaleFactor>(scale);\n  }\n\n  Operand MemoryOperand(size_t* offset) {\n    AddressingMode mode = AddressingModeField::decode(instr_->opcode());\n    switch (mode) {\n      case kMode_MR: {\n        Register base = InputRegister(NextOffset(offset));\n        int32_t disp = 0;\n        return Operand(base, disp);\n      }\n      case kMode_MRI: {\n        Register base = InputRegister(NextOffset(offset));\n        int32_t disp = InputInt32(NextOffset(offset));\n        return Operand(base, disp);\n      }\n      case kMode_MR1:\n      case kMode_MR2:\n      case kMode_MR4:\n      case kMode_MR8: {\n        Register base = InputRegister(NextOffset(offset));\n        Register index = InputRegister(NextOffset(offset));\n        ScaleFactor scale = ScaleFor(kMode_MR1, mode);\n        int32_t disp = 0;\n        return Operand(base, index, scale, disp);\n      }\n      case kMode_MR1I:\n      case kMode_MR2I:\n      case kMode_MR4I:\n      case kMode_MR8I: {\n        Register base = InputRegister(NextOffset(offset));\n        Register index = InputRegister(NextOffset(offset));\n        ScaleFactor scale = ScaleFor(kMode_MR1I, mode);\n        int32_t disp = InputInt32(NextOffset(offset));\n        return Operand(base, index, scale, disp);\n      }\n      case kMode_M1: {\n        Register base = InputRegister(NextOffset(offset));\n        int32_t disp = 0;\n        return Operand(base, disp);\n      }\n      case kMode_M2:\n        UNREACHABLE();  // Should use kModeMR with more compact encoding instead\n      case kMode_M4:\n      case kMode_M8: {\n        Register index = InputRegister(NextOffset(offset));\n        ScaleFactor scale = ScaleFor(kMode_M1, mode);\n        int32_t disp = 0;\n        return Operand(index, scale, disp);\n      }\n      case kMode_M1I:\n      case kMode_M2I:\n      case kMode_M4I:\n      case kMode_M8I: {\n        Register index = InputRegister(NextOffset(offset));\n        ScaleFactor scale = ScaleFor(kMode_M1I, mode);\n        int32_t disp = InputInt32(NextOffset(offset));\n        return Operand(index, scale, disp);\n      }\n      case kMode_Root: {\n        Register base = kRootRegister;\n        int32_t disp = InputInt32(NextOffset(offset));\n        return Operand(base, disp);\n      }\n      case kMode_MCR: {\n        Register base = kPtrComprCageBaseRegister;\n        Register index = InputRegister(NextOffset(offset));\n        ScaleFactor scale = static_cast<ScaleFactor>(0);\n        int32_t disp = 0;\n        return Operand(base, index, scale, disp);\n      }\n      case kMode_MCRI: {\n        Register base = kPtrComprCageBaseRegister;\n        Register index = InputRegister(NextOffset(offset));\n        ScaleFactor scale = static_cast<ScaleFactor>(0);\n        int32_t disp = InputInt32(NextOffset(offset));\n        return Operand(base, index, scale, disp);\n      }\n      case kMode_None:\n        UNREACHABLE();\n    }\n    UNREACHABLE();\n  }\n\n  Operand MemoryOperand(size_t first_input = 0) {\n    return MemoryOperand(&first_input);\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasAddressingMode\",\n                \"about\": \"Checks if an instruction has an addressing mode.\",\n                \"logic\": \"Checks if the addressing mode of the instruction is not kMode_None.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instruction has an addressing mode, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nbool HasAddressingMode(Instruction* instr) {\n  return instr->addressing_mode() != kMode_None;\n}\n\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasImmediateInput\",\n                \"about\": \"Checks if an instruction has an immediate input at a given index.\",\n                \"logic\": \"Checks if the input at the given index is an immediate.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the input to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instruction has an immediate input at the given index, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool HasImmediateInput(Instruction* instr, size_t index) {\n  return instr->InputAt(index)->IsImmediate();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasRegisterInput\",\n                \"about\": \"Checks if an instruction has a register input at a given index.\",\n                \"logic\": \"Checks if the input at the given index is a register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the input to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instruction has a register input at the given index, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool HasRegisterInput(Instruction* instr, size_t index) {\n  return instr->InputAt(index)->IsRegister();\n}\n\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OutOfLineLoadFloat32NaN\",\n                \"extends\": \"OutOfLineCode\",\n                \"about\": \"Generates out-of-line code to load a Float32 NaN value into a register.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OutOfLineCode\",\n                    \"CodeGenerator\",\n                    \"XMMRegister\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass OutOfLineLoadFloat32NaN final : public OutOfLineCode {\n public:\n  OutOfLineLoadFloat32NaN(CodeGenerator* gen, XMMRegister result)\n      : OutOfLineCode(gen), result_(result) {}\n\n  void Generate() final {\n    __ Xorps(result_, result_);\n    __ Divss(result_, result_);\n  }\n\n private:\n  XMMRegister const result_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OutOfLineLoadFloat64NaN\",\n                \"extends\": \"OutOfLineCode\",\n                \"about\": \"Generates out-of-line code to load a Float64 NaN value into a register.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OutOfLineCode\",\n                    \"CodeGenerator\",\n                    \"XMMRegister\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass OutOfLineLoadFloat64NaN final : public OutOfLineCode {\n public:\n  OutOfLineLoadFloat64NaN(CodeGenerator* gen, XMMRegister result)\n      : OutOfLineCode(gen), result_(result) {}\n\n  void Generate() final {\n    __ Xorpd(result_, result_);\n    __ Divsd(result_, result_);\n  }\n\n private:\n  XMMRegister const result_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OutOfLineTruncateDoubleToI\",\n                \"extends\": \"OutOfLineCode\",\n                \"about\": \"Generates out-of-line code to truncate a double to an integer.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OutOfLineCode\",\n                    \"CodeGenerator\",\n                    \"Register\",\n                    \"XMMRegister\",\n                    \"StubCallMode\",\n                    \"UnwindingInfoWriter\",\n                    \"Isolate\",\n                    \"Zone\",\n                    \"MemOperand\",\n                    \"Builtin\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass OutOfLineTruncateDoubleToI final : public OutOfLineCode {\n public:\n  OutOfLineTruncateDoubleToI(CodeGenerator* gen, Register result,\n                             XMMRegister input, StubCallMode stub_mode,\n                             UnwindingInfoWriter* unwinding_info_writer)\n      : OutOfLineCode(gen),\n        result_(result),\n        input_(input),\n#if V8_ENABLE_WEBASSEMBLY\n        stub_mode_(stub_mode),\n#endif  // V8_ENABLE_WEBASSEMBLY\n        unwinding_info_writer_(unwinding_info_writer),\n        isolate_(gen->isolate()),\n        zone_(gen->zone()) {\n  }\n\n  void Generate() final {\n    __ AllocateStackSpace(kDoubleSize);\n    unwinding_info_writer_->MaybeIncreaseBaseOffsetAt(__ pc_offset(),\n                                                      kDoubleSize);\n    __ Movsd(MemOperand(rsp, 0), input_);\n#if V8_ENABLE_WEBASSEMBLY\n    if (stub_mode_ == StubCallMode::kCallWasmRuntimeStub) {\n      // A direct call to a builtin. Just encode the builtin index. This will be\n      // patched when the code is added to the native module and copied into\n      // wasm code space.\n      __ near_call(static_cast<intptr_t>(Builtin::kDoubleToI),\n                   RelocInfo::WASM_STUB_CALL);\n#else\n    // For balance.\n    if (false) {\n#endif  // V8_ENABLE_WEBASSEMBLY\n    } else {\n      // With embedded builtins we do not need the isolate here. This allows\n      // the call to be generated asynchronously.\n      __ CallBuiltin(Builtin::kDoubleToI);\n    }\n    __ movl(result_, MemOperand(rsp, 0));\n    __ addq(rsp, Immediate(kDoubleSize));\n    unwinding_info_writer_->MaybeIncreaseBaseOffsetAt(__ pc_offset(),\n                                                      -kDoubleSize);\n  }\n\n private:\n  Register const result_;\n  XMMRegister const input_;\n#if V8_ENABLE_WEBASSEMBLY\n  StubCallMode stub_mode_;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  UnwindingInfoWriter* const unwinding_info_writer_;\n  Isolate* isolate_;\n  Zone* zone_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OutOfLineRecordWrite\",\n                \"extends\": \"OutOfLineCode\",\n                \"about\": \"Generates out-of-line code for record write barriers.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"OutOfLineCode\",\n                    \"CodeGenerator\",\n                    \"Register\",\n                    \"Operand\",\n                    \"RecordWriteMode\",\n                    \"StubCallMode\",\n                    \"IndirectPointerTag\",\n                    \"Zone\",\n                    \"MemoryChunk\",\n                    \"SaveFPRegsMode\",\n                    \"FrameAccessState\",\n                    \"ExposedTrustedObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass OutOfLineRecordWrite final : public OutOfLineCode {\n public:\n  OutOfLineRecordWrite(\n      CodeGenerator* gen, Register object, Operand operand, Register value,\n      Register scratch0, Register scratch1, RecordWriteMode mode,\n      StubCallMode stub_mode,\n      IndirectPointerTag indirect_pointer_tag = kIndirectPointerNullTag)\n      : OutOfLineCode(gen),\n        object_(object),\n        operand_(operand),\n        value_(value),\n        scratch0_(scratch0),\n        scratch1_(scratch1),\n        mode_(mode),\n#if V8_ENABLE_WEBASSEMBLY\n        stub_mode_(stub_mode),\n#endif  // V8_ENABLE_WEBASSEMBLY\n        zone_(gen->zone()),\n        indirect_pointer_tag_(indirect_pointer_tag) {\n    DCHECK(!AreAliased(object, scratch0, scratch1));\n    DCHECK(!AreAliased(value, scratch0, scratch1));\n  }\n\n#if V8_ENABLE_STICKY_MARK_BITS_BOOL\n  Label* stub_call() { return &stub_call_; }\n#endif  // V8_ENABLE_STICKY_MARK_BITS_BOOL\n\n  void Generate() final {\n    // When storing an indirect pointer, the value will always be a\n    // full/decompressed pointer.\n    if (COMPRESS_POINTERS_BOOL &&\n        mode_ != RecordWriteMode::kValueIsIndirectPointer) {\n      __ DecompressTagged(value_, value_);\n    }\n\n    // No need to check value page flags with the indirect pointer write barrier\n    // because the value is always an ExposedTrustedObject.\n    if (mode_ != RecordWriteMode::kValueIsIndirectPointer) {\n#if V8_ENABLE_STICKY_MARK_BITS_BOOL\n      // TODO(333906585): Optimize this path.\n      Label stub_call_with_decompressed_value;\n      __ CheckPageFlag(value_, scratch0_, MemoryChunk::kIsInReadOnlyHeapMask,\n                       not_zero, exit());\n      __ CheckMarkBit(value_, scratch0_, scratch1_, carry, exit());\n      __ jmp(&stub_call_with_decompressed_value);\n\n      __ bind(&stub_call_);\n      if (COMPRESS_POINTERS_BOOL &&\n          mode_ != RecordWriteMode::kValueIsIndirectPointer) {\n        __ DecompressTagged(value_, value_);\n      }\n\n      __ bind(&stub_call_with_decompressed_value);\n#else   // !V8_ENABLE_STICKY_MARK_BITS_BOOL\n      __ CheckPageFlag(value_, scratch0_,\n                       MemoryChunk::kPointersToHereAreInterestingMask, zero,\n                       exit());\n#endif  // !V8_ENABLE_STICKY_MARK_BITS_BOOL\n    }\n\n    __ leaq(scratch1_, operand_);\n\n    SaveFPRegsMode const save_fp_mode = frame()->DidAllocateDoubleRegisters()\n                                            ? SaveFPRegsMode::kSave\n                                            : SaveFPRegsMode::kIgnore;\n\n    if (mode_ == RecordWriteMode::kValueIsEphemeronKey) {\n      __ CallEphemeronKeyBarrier(object_, scratch1_, save_fp_mode);\n    } else if (mode_ == RecordWriteMode::kValueIsIndirectPointer) {\n      // We must have a valid indirect pointer tag here. Otherwise, we risk not\n      // invoking the correct write barrier, which may lead to subtle issues.\n      CHECK(IsValidIndirectPointerTag(indirect_pointer_tag_));\n      __ CallIndirectPointerBarrier(object_, scratch1_, save_fp_mode,\n                                    indirect_pointer_tag_);\n#if V8_ENABLE_WEBASSEMBLY\n    } else if (stub_mode_ == StubCallMode::kCallWasmRuntimeStub) {\n      // A direct call to a wasm runtime stub defined in this module.\n      // Just encode the stub index. This will be patched when the code\n      // is added to the native module and copied into wasm code space.\n      __ CallRecordWriteStubSaveRegisters(object_, scratch1_, save_fp_mode,\n                                          StubCallMode::kCallWasmRuntimeStub);\n#endif  // V8_ENABLE_WEBASSEMBLY\n    } else {\n      __ CallRecordWriteStubSaveRegisters(object_, scratch1_, save_fp_mode);\n    }\n  }\n\n private:\n  Register const object_;\n  Operand const operand_;\n  Register const value_;\n  Register const scratch0_;\n  Register const scratch1_;\n  RecordWriteMode const mode_;\n#if V8_ENABLE_WEBASSEMBLY\n  StubCallMode const stub_mode_;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  Zone* zone_;\n  IndirectPointerTag indirect_pointer_tag_;\n#if V8_ENABLE_STICKY_MARK_BITS_BOOL\n  Label stub_call_;\n#endif  // V8_ENABLE_STICKY_MARK_BITS_BOOL\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"EmitStore\",\n                \"about\": \"Emits a store instruction with optional memory order.\",\n                \"logic\": \"Emits different store instructions based on the given MachineRepresentation and memory order.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"masm\",\n                        \"type\": \"MacroAssembler*\",\n                        \"purpose\": \"The MacroAssembler to use.\"\n                    },\n                    {\n                        \"name\": \"operand\",\n                        \"type\": \"Operand\",\n                        \"purpose\": \"The memory location to store to.\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the value to store.\"\n                    },\n                    {\n                        \"name\": \"rep\",\n                        \"type\": \"MachineRepresentation\",\n                        \"purpose\": \"The representation of the data to store.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The pc offset of the store instruction.\"\n                },\n                \"dependencies\": [\n                    \"MacroAssembler\",\n                    \"Operand\",\n                    \"Register\",\n                    \"MachineRepresentation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <std::memory_order order>\nint EmitStore(MacroAssembler* masm, Operand operand, Register value,\n              MachineRepresentation rep) {\n  int store_instr_offset;\n  if (order == std::memory_order_relaxed) {\n    store_instr_offset = masm->pc_offset();\n    switch (rep) {\n      case MachineRepresentation::kWord8:\n        masm->movb(operand, value);\n        break;\n      case MachineRepresentation::kWord16:\n        masm->movw(operand, value);\n        break;\n      case MachineRepresentation::kWord32:\n        masm->movl(operand, value);\n        break;\n      case MachineRepresentation::kWord64:\n        masm->movq(operand, value);\n        break;\n      case MachineRepresentation::kTagged:\n        masm->StoreTaggedField(operand, value);\n        break;\n      case MachineRepresentation::kSandboxedPointer:\n        masm->StoreSandboxedPointerField(operand, value);\n        break;\n      case MachineRepresentation::kIndirectPointer:\n        masm->StoreIndirectPointerField(operand, value);\n        break;\n      default:\n        UNREACHABLE();\n    }\n    return store_instr_offset;\n  }\n\n  DCHECK_EQ(order, std::memory_order_seq_cst);\n  switch (rep) {\n    case MachineRepresentation::kWord8:\n      masm->movq(kScratchRegister, value);\n      store_instr_offset = masm->pc_offset();\n      masm->xchgb(kScratchRegister, operand);\n      break;\n    case MachineRepresentation::kWord16:\n      masm->movq(kScratchRegister, value);\n      store_instr_offset = masm->pc_offset();\n      masm->xchgw(kScratchRegister, operand);\n      break;\n    case MachineRepresentation::kWord32:\n      masm->movq(kScratchRegister, value);\n      store_instr_offset = masm->pc_offset();\n      masm->xchgl(kScratchRegister, operand);\n      break;\n    case MachineRepresentation::kWord64:\n      masm->movq(kScratchRegister, value);\n      store_instr_offset = masm->pc_offset();\n      masm->xchgq(kScratchRegister, operand);\n      break;\n    case MachineRepresentation::kTagged:\n      store_instr_offset = masm->pc_offset();\n      masm->AtomicStoreTaggedField(operand, value);\n      break;\n    default:\n      UNREACHABLE();\n  }\n  return store_instr_offset;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata"
}