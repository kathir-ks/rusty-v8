{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/serializer-deserializer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/serializer-deserializer.h\",\n        \"file_name\": \"serializer-deserializer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the SerializerDeserializer class, a common base for Serializer and Deserializer, used for snapshotting V8's heap.  It also defines related structs and enums used in the serialization/deserialization process.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for object visiting and snapshot references.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/objects/visitors.h\"\n#include \"src/snapshot/references.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SerializerDeserializer\",\n            \"extends\": \"RootVisitor\",\n            \"about\": \"Common superclass for Serializer and Deserializer, providing shared constants and methods.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Tagged<HeapObject>\",\n                \"AccessorInfo\",\n                \"FunctionTemplateInfo\",\n                \"RootVisitor\",\n                \"SnapshotSpace\",\n                \"RootIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass SerializerDeserializer : public RootVisitor {\n public:\n  static void IterateStartupObjectCache(Isolate* isolate, RootVisitor* visitor);\n\n  static void IterateSharedHeapObjectCache(Isolate* isolate,\n                                           RootVisitor* visitor);\n\n protected:\n  enum class SlotType {\n    kAnySlot,\n    kMapSlot,\n  };\n  static bool CanBeDeferred(Tagged<HeapObject> o, SlotType slot_type);\n\n  void RestoreExternalReferenceRedirector(Isolate* isolate,\n                                          Tagged<AccessorInfo> accessor_info);\n  void RestoreExternalReferenceRedirector(\n      Isolate* isolate, Tagged<FunctionTemplateInfo> function_template_info);\n\n  // clang-format off\n#define UNUSED_SERIALIZER_BYTE_CODES(V)                           \\\n  /* Free range 0x22..0x2f */                                     \\\n                  V(0x22) V(0x23) V(0x24) V(0x25) V(0x26) V(0x27) \\\n  V(0x28) V(0x29) V(0x2a) V(0x2b) V(0x2c) V(0x2d) V(0x2e) V(0x2f) \\\n  /* Free range 0x30..0x3f */                                     \\\n  V(0x30) V(0x31) V(0x32) V(0x33) V(0x34) V(0x35) V(0x36) V(0x37) \\\n  V(0x38) V(0x39) V(0x3a) V(0x3b) V(0x3c) V(0x3d) V(0x3e) V(0x3f) \\\n  /* Free range 0x97..0x9f */                                     \\\n  V(0x98) V(0x99) V(0x9a) V(0x9b) V(0x9c) V(0x9d) V(0x9e) V(0x9f) \\\n  /* Free range 0xa0..0xaf */                                     \\\n  V(0xa0) V(0xa1) V(0xa2) V(0xa3) V(0xa4) V(0xa5) V(0xa6) V(0xa7) \\\n  V(0xa8) V(0xa9) V(0xaa) V(0xab) V(0xac) V(0xad) V(0xae) V(0xaf) \\\n  /* Free range 0xb0..0xbf */                                     \\\n  V(0xb0) V(0xb1) V(0xb2) V(0xb3) V(0xb4) V(0xb5) V(0xb6) V(0xb7) \\\n  V(0xb8) V(0xb9) V(0xba) V(0xbb) V(0xbc) V(0xbd) V(0xbe) V(0xbf) \\\n  /* Free range 0xc0..0xcf */                                     \\\n  V(0xc0) V(0xc1) V(0xc2) V(0xc3) V(0xc4) V(0xc5) V(0xc6) V(0xc7) \\\n  V(0xc8) V(0xc9) V(0xca) V(0xcb) V(0xcc) V(0xcd) V(0xce) V(0xcf) \\\n  /* Free range 0xd0..0xdf */                                     \\\n  V(0xd0) V(0xd1) V(0xd2) V(0xd3) V(0xd4) V(0xd5) V(0xd6) V(0xd7) \\\n  V(0xd8) V(0xd9) V(0xda) V(0xdb) V(0xdc) V(0xdd) V(0xde) V(0xdf) \\\n  /* Free range 0xe0..0xef */                                     \\\n  V(0xe0) V(0xe1) V(0xe2) V(0xe3) V(0xe4) V(0xe5) V(0xe6) V(0xe7) \\\n  V(0xe8) V(0xe9) V(0xea) V(0xeb) V(0xec) V(0xed) V(0xee) V(0xef) \\\n  /* Free range 0xf0..0xff */                                     \\\n  V(0xf0) V(0xf1) V(0xf2) V(0xf3) V(0xf4) V(0xf5) V(0xf6) V(0xf7) \\\n  V(0xf8) V(0xf9) V(0xfa) V(0xfb) V(0xfc) V(0xfd) V(0xfe) V(0xff)\n  // clang-format on\n\n  // The static assert below will trigger when the number of preallocated spaces\n  // changed. If that happens, update the kNewObject and kBackref bytecode\n  // ranges in the comments below.\n  static_assert(4 == kNumberOfSnapshotSpaces);\n\n  // First 32 root array items.\n  static const int kRootArrayConstantsCount = 0x20;\n\n  // 32 common raw data lengths.\n  static const int kFixedRawDataCount = 0x20;\n  // 16 repeats lengths.\n  static const int kFixedRepeatRootCount = 0x10;\n\n  // 8 hot (recently seen or back-referenced) objects with optional skip.\n  static const int kHotObjectCount = 8;\n\n  enum Bytecode : uint8_t {\n    //\n    // ---------- byte code range 0x00..0x1f ----------\n    //\n\n    // 0x00..0x03  Allocate new object, in specified space.\n    kNewObject = 0x00,\n    // Reference to previously allocated object.\n    kBackref = 0x04,\n    // Reference to an object in the read only heap.\n    kReadOnlyHeapRef,\n    // Object in the startup object cache.\n    kStartupObjectCache,\n    // Root array item.\n    kRootArray,\n    // Object provided in the attached list.\n    kAttachedReference,\n    // Object in the shared heap object cache.\n    kSharedHeapObjectCache,\n    // Do nothing, used for padding.\n    kNop,\n    // A tag emitted at strategic points in the snapshot to delineate sections.\n    // If the deserializer does not find these at the expected moments then it\n    // is an indication that the snapshot and the VM do not fit together.\n    // Examine the build process for architecture, version or configuration\n    // mismatches.\n    kSynchronize,\n    // Repeats of variable length of a root.\n    kVariableRepeatRoot,\n    // Used for embedder-allocated backing stores for TypedArrays.\n    kOffHeapBackingStore,\n    kOffHeapResizableBackingStore,\n    // Used for embedder-provided serialization data for embedder fields.\n    kEmbedderFieldsData,\n    // Used for embedder-provided serialziation data for API wrappers.\n    kApiWrapperFieldsData,\n    // Raw data of variable length.\n    kVariableRawData,\n    // Used to encode external references provided through the API.\n    kApiReference,\n    // External reference referenced by id.\n    kExternalReference,\n    // Same as three bytecodes above but for serializing sandboxed external\n    // pointer values.\n    // TODO(v8:10391): Remove them once all ExternalPointer usages are\n    // sandbox-ready.\n    kSandboxedApiReference,\n    kSandboxedExternalReference,\n    kSandboxedRawExternalReference,\n    // In-place weak references.\n    kClearedWeakReference,\n    kWeakPrefix,\n    // Registers the current slot as a \"pending\" forward reference, to be later\n    // filled by a corresponding resolution bytecode.\n    kRegisterPendingForwardRef,\n    // Resolves an existing \"pending\" forward reference to point to the current\n    // object.\n    kResolvePendingForwardRef,\n    // Special construction bytecodes for the metamaps. In theory we could\n    // reuse forward-references for this, but then the forward reference would\n    // be registered during object map deserialization, before the object is\n    // allocated, so there wouldn't be a allocated object whose map field we can\n    // register as the pending field. We could either hack around this, or\n    // simply introduce this new bytecode.\n    kNewContextlessMetaMap,\n    kNewContextfulMetaMap,\n    // When the sandbox is enabled, a prefix indicating that the following\n    // object is referenced through an indirect pointer, i.e. through an entry\n    // in a pointer table.\n    kIndirectPointerPrefix,\n    // When the sandbox is enabled, this bytecode instructs the deserializer to\n    // initialize the \"self\" indirect pointer of trusted objects, which\n    // references the object's pointer table entry. As the \"self\" indirect\n    // pointer is always the first field after the map word, it is guaranteed\n    // that it will be deserialized before any inner objects, which may require\n    // the pointer table entry for back reference to the trusted object.\n    kInitializeSelfIndirectPointer,\n    // This bytecode instructs the deserializer to allocate an entry in the\n    // JSDispatchTable for the host object and store the corresponding dispatch\n    // handle into the current slot.\n    kAllocateJSDispatchEntry,\n    // A back-reference to the already allocated n-th dispatch entry.\n    kJSDispatchEntry,\n    // A prefix indicating that the following object is referenced through a\n    // protected pointer, i.e. a pointer from one trusted object to another.\n    kProtectedPointerPrefix,\n\n    //\n    // ---------- byte code range 0x40..0x7f ----------\n    //\n\n    // 0x40..0x5f\n    kRootArrayConstants = 0x40,\n\n    // 0x60..0x7f\n    kFixedRawData = 0x60,\n\n    //\n    // ---------- byte code range 0x80..0x9f ----------\n    //\n\n    // 0x80..0x8f\n    kFixedRepeatRoot = 0x80,\n\n    // 0x90..0x97\n    kHotObject = 0x90,\n  };\n\n  // Helper class for encoding and decoding a value into and from a bytecode.\n  //\n  // The value is encoded by allocating an entire bytecode range, and encoding\n  // the value as an index in that range, starting at kMinValue; thus the range\n  // of values\n  //   [kMinValue, kMinValue + 1, ... , kMaxValue]\n  // is encoded as\n  //   [kBytecode, kBytecode + 1, ... , kBytecode + (N - 1)]\n  // where N is the number of values, i.e. kMaxValue - kMinValue + 1.\n  template <Bytecode kBytecode, int kMinValue, int kMaxValue,\n            typename TValue = int>\n  struct BytecodeValueEncoder {\n    static_assert((kBytecode + kMaxValue - kMinValue) <= kMaxUInt8);\n\n    static constexpr bool IsEncodable(TValue value) {\n      return base::IsInRange(static_cast<int>(value), kMinValue, kMaxValue);\n    }\n\n    static constexpr uint8_t Encode(TValue value) {\n      DCHECK(IsEncodable(value));\n      return static_cast<uint8_t>(kBytecode + static_cast<int>(value) -\n                                  kMinValue);\n    }\n\n    static constexpr TValue Decode(uint8_t bytecode) {\n      DCHECK(base::IsInRange(bytecode, Encode(static_cast<TValue>(kMinValue)),\n                             Encode(static_cast<TValue>(kMaxValue))));\n      return static_cast<TValue>(bytecode - kBytecode + kMinValue);\n    }\n  };\n\n  template <Bytecode bytecode>\n  using SpaceEncoder =\n      BytecodeValueEncoder<bytecode, 0, kNumberOfSnapshotSpaces - 1,\n                           SnapshotSpace>;\n\n  using NewObject = SpaceEncoder<kNewObject>;\n\n  //\n  // Some other constants.\n  //\n\n  // Sentinel after a new object to indicate that double alignment is needed.\n  static const int kDoubleAlignmentSentinel = 0;\n\n  // Raw data size encoding helpers.\n  static const int kFirstEncodableFixedRawDataSize = 1;\n  static const int kLastEncodableFixedRawDataSize =\n      kFirstEncodableFixedRawDataSize + kFixedRawDataCount - 1;\n\n  using FixedRawDataWithSize =\n      BytecodeValueEncoder<kFixedRawData, kFirstEncodableFixedRawDataSize,\n                           kLastEncodableFixedRawDataSize>;\n\n  // Repeat count encoding helpers.\n  static const int kFirstEncodableRepeatRootCount = 2;\n  static const int kLastEncodableFixedRepeatRootCount =\n      kFirstEncodableRepeatRootCount + kFixedRepeatRootCount - 1;\n  static const int kFirstEncodableVariableRepeatRootCount =\n      kLastEncodableFixedRepeatRootCount + 1;\n\n  using FixedRepeatRootWithCount =\n      BytecodeValueEncoder<kFixedRepeatRoot, kFirstEncodableRepeatRootCount,\n                           kLastEncodableFixedRepeatRootCount>;\n\n  // Encodes/decodes repeat count into a serialized variable repeat count\n  // value.\n  struct VariableRepeatRootCount {\n    static constexpr bool IsEncodable(int repeat_count) {\n      return repeat_count >= kFirstEncodableVariableRepeatRootCount;\n    }\n\n    static constexpr int Encode(int repeat_count) {\n      DCHECK(IsEncodable(repeat_count));\n      return repeat_count - kFirstEncodableVariableRepeatRootCount;\n    }\n\n    static constexpr int Decode(int value) {\n      return value + kFirstEncodableVariableRepeatRootCount;\n    }\n  };\n\n  using RootArrayConstant =\n      BytecodeValueEncoder<kRootArrayConstants, 0, kRootArrayConstantsCount - 1,\n                           RootIndex>;\n  using HotObject = BytecodeValueEncoder<kHotObject, 0, kHotObjectCount - 1>;\n\n  // This backing store reference value represents empty backing stores during\n  // serialization/deserialization.\n  static const uint32_t kEmptyBackingStoreRefSentinel = 0;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IterateStartupObjectCache\",\n            \"parent\": \"SerializerDeserializer\",\n            \"about\": \"Iterates over the startup object cache.\",\n            \"logic\": \"This function likely iterates through the startup object cache of the Isolate, applying the visitor pattern.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The Isolate whose startup object cache should be iterated.\"\n                },\n                {\n                    \"name\": \"visitor\",\n                    \"type\": \"RootVisitor*\",\n                    \"purpose\": \"The RootVisitor to apply to each object in the cache.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"RootVisitor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void IterateStartupObjectCache(Isolate* isolate, RootVisitor* visitor);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IterateSharedHeapObjectCache\",\n            \"parent\": \"SerializerDeserializer\",\n            \"about\": \"Iterates over the shared heap object cache.\",\n            \"logic\": \"This function likely iterates through the shared heap object cache of the Isolate, applying the visitor pattern.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The Isolate whose shared heap object cache should be iterated.\"\n                },\n                {\n                    \"name\": \"visitor\",\n                    \"type\": \"RootVisitor*\",\n                    \"purpose\": \"The RootVisitor to apply to each object in the cache.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"RootVisitor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void IterateSharedHeapObjectCache(Isolate* isolate,\n                                           RootVisitor* visitor);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CanBeDeferred\",\n            \"parent\": \"SerializerDeserializer\",\n            \"about\": \"Determines if a HeapObject can be deferred during serialization.\",\n            \"logic\": \"The function likely checks properties of the HeapObject to determine if its serialization can be delayed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"o\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The HeapObject to check.\"\n                },\n                {\n                    \"name\": \"slot_type\",\n                    \"type\": \"SlotType\",\n                    \"purpose\": \"The type of slot the HeapObject is in.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the HeapObject can be deferred, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Tagged<HeapObject>\",\n                \"SlotType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static bool CanBeDeferred(Tagged<HeapObject> o, SlotType slot_type);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RestoreExternalReferenceRedirector\",\n            \"parent\": \"SerializerDeserializer\",\n            \"about\": \"Restores the external reference redirector for an AccessorInfo object.\",\n            \"logic\": \"This function likely handles setting up the redirector for external references, potentially involving platform-specific APIs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to restore the redirector for.\"\n                },\n                {\n                    \"name\": \"accessor_info\",\n                    \"type\": \"Tagged<AccessorInfo>\",\n                    \"purpose\": \"The AccessorInfo object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"Tagged<AccessorInfo>\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void RestoreExternalReferenceRedirector(Isolate* isolate,\n                                          Tagged<AccessorInfo> accessor_info);\n        ]]></code>\n    </func>\n\n        <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RestoreExternalReferenceRedirector\",\n            \"parent\": \"SerializerDeserializer\",\n            \"about\": \"Restores the external reference redirector for a FunctionTemplateInfo object.\",\n            \"logic\": \"This function likely handles setting up the redirector for external references, potentially involving platform-specific APIs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to restore the redirector for.\"\n                },\n                {\n                    \"name\": \"function_template_info\",\n                    \"type\": \"Tagged<FunctionTemplateInfo>\",\n                    \"purpose\": \"The FunctionTemplateInfo object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"Tagged<FunctionTemplateInfo>\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void RestoreExternalReferenceRedirector(\n      Isolate* isolate, Tagged<FunctionTemplateInfo> function_template_info);\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SerializeEmbedderFieldsCallback\",\n            \"about\": \"Structure to hold callback functions for serializing embedder fields.\",\n            \"attributes\": [\n                {\n                    \"name\": \"js_object_callback\",\n                    \"type\": \"v8::SerializeInternalFieldsCallback\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Callback for serializing internal fields of JS objects.\"\n                },\n                {\n                    \"name\": \"context_callback\",\n                    \"type\": \"v8::SerializeContextDataCallback\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Callback for serializing context data.\"\n                },\n                {\n                    \"name\": \"api_wrapper_callback\",\n                    \"type\": \"v8::SerializeAPIWrapperCallback\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Callback for serializing API wrappers.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstruct SerializeEmbedderFieldsCallback {\n  explicit SerializeEmbedderFieldsCallback(\n      v8::SerializeInternalFieldsCallback js_cb =\n          v8::SerializeInternalFieldsCallback(),\n      v8::SerializeContextDataCallback context_cb =\n          v8::SerializeContextDataCallback(),\n      v8::SerializeAPIWrapperCallback api_wrapper_cb =\n          v8::SerializeAPIWrapperCallback())\n      : js_object_callback(js_cb),\n        context_callback(context_cb),\n        api_wrapper_callback(api_wrapper_cb) {}\n  v8::SerializeInternalFieldsCallback js_object_callback;\n  v8::SerializeContextDataCallback context_callback;\n  v8::SerializeAPIWrapperCallback api_wrapper_callback;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"DeserializeEmbedderFieldsCallback\",\n            \"about\": \"Structure to hold callback functions for deserializing embedder fields.\",\n            \"attributes\": [\n                {\n                    \"name\": \"js_object_callback\",\n                    \"type\": \"v8::DeserializeInternalFieldsCallback\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Callback for deserializing internal fields of JS objects.\"\n                },\n                {\n                    \"name\": \"context_callback\",\n                    \"type\": \"v8::DeserializeContextDataCallback\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Callback for deserializing context data.\"\n                },\n                {\n                    \"name\": \"api_wrapper_callback\",\n                    \"type\": \"v8::DeserializeAPIWrapperCallback\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Callback for deserializing API wrappers.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstruct DeserializeEmbedderFieldsCallback {\n  explicit DeserializeEmbedderFieldsCallback(\n      v8::DeserializeInternalFieldsCallback js_cb =\n          v8::DeserializeInternalFieldsCallback(),\n      v8::DeserializeContextDataCallback context_cb =\n          v8::DeserializeContextDataCallback(),\n      v8::DeserializeAPIWrapperCallback api_wrapper_cb =\n          v8::DeserializeAPIWrapperCallback())\n      : js_object_callback(js_cb),\n        context_callback(context_cb),\n        api_wrapper_callback(api_wrapper_cb) {}\n  v8::DeserializeInternalFieldsCallback js_object_callback;\n  v8::DeserializeContextDataCallback context_callback;\n  v8::DeserializeAPIWrapperCallback api_wrapper_callback;\n};\n        ]]></code>\n    </class>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"SlotType\",\n            \"parent\": \"SerializerDeserializer\",\n            \"about\": \"Enum defining the types of slots.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  enum class SlotType {\n    kAnySlot,\n    kMapSlot,\n  };\n        ]]></code>\n    </enum>\n\n     <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"Bytecode\",\n            \"parent\": \"SerializerDeserializer\",\n            \"about\": \"Enum defining the bytecodes used for serialization/deserialization.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  enum Bytecode : uint8_t {\n    //\n    // ---------- byte code range 0x00..0x1f ----------\n    //\n\n    // 0x00..0x03  Allocate new object, in specified space.\n    kNewObject = 0x00,\n    // Reference to previously allocated object.\n    kBackref = 0x04,\n    // Reference to an object in the read only heap.\n    kReadOnlyHeapRef,\n    // Object in the startup object cache.\n    kStartupObjectCache,\n    // Root array item.\n    kRootArray,\n    // Object provided in the attached list.\n    kAttachedReference,\n    // Object in the shared heap object cache.\n    kSharedHeapObjectCache,\n    // Do nothing, used for padding.\n    kNop,\n    // A tag emitted at strategic points in the snapshot to delineate sections.\n    // If the deserializer does not find these at the expected moments then it\n    // is an indication that the snapshot and the VM do not fit together.\n    // Examine the build process for architecture, version or configuration\n    // mismatches.\n    kSynchronize,\n    // Repeats of variable length of a root.\n    kVariableRepeatRoot,\n    // Used for embedder-allocated backing stores for TypedArrays.\n    kOffHeapBackingStore,\n    kOffHeapResizableBackingStore,\n    // Used for embedder-provided serialization data for embedder fields.\n    kEmbedderFieldsData,\n    // Used for embedder-provided serialziation data for API wrappers.\n    kApiWrapperFieldsData,\n    // Raw data of variable length.\n    kVariableRawData,\n    // Used to encode external references provided through the API.\n    kApiReference,\n    // External reference referenced by id.\n    kExternalReference,\n    // Same as three bytecodes above but for serializing sandboxed external\n    // pointer values.\n    // TODO(v8:10391): Remove them once all ExternalPointer usages are\n    // sandbox-ready.\n    kSandboxedApiReference,\n    kSandboxedExternalReference,\n    kSandboxedRawExternalReference,\n    // In-place weak references.\n    kClearedWeakReference,\n    kWeakPrefix,\n    // Registers the current slot as a \"pending\" forward reference, to be later\n    // filled by a corresponding resolution bytecode.\n    kRegisterPendingForwardRef,\n    // Resolves an existing \"pending\" forward reference to point to the current\n    // object.\n    kResolvePendingForwardRef,\n    // Special construction bytecodes for the metamaps. In theory we could\n    // reuse forward-references for this, but then the forward reference would\n    // be registered during object map deserialization, before the object is\n    // allocated, so there wouldn't be a allocated object whose map field we can\n    // register as the pending field. We could either hack around this, or\n    // simply introduce this new bytecode.\n    kNewContextlessMetaMap,\n    kNewContextfulMetaMap,\n    // When the sandbox is enabled, a prefix indicating that the following\n    // object is referenced through an indirect pointer, i.e. through an entry\n    // in a pointer table.\n    kIndirectPointerPrefix,\n    // When the sandbox is enabled, this bytecode instructs the deserializer to\n    // initialize the \"self\" indirect pointer of trusted objects, which\n    // references the object's pointer table entry. As the \"self\" indirect\n    // pointer is always the first field after the map word, it is guaranteed\n    // that it will be deserialized before any inner objects, which may require\n    // the pointer table entry for back reference to the trusted object.\n    kInitializeSelfIndirectPointer,\n    // This bytecode instructs the deserializer to allocate an entry in the\n    // JSDispatchTable for the host object and store the corresponding dispatch\n    // handle into the current slot.\n    kAllocateJSDispatchEntry,\n    // A back-reference to the already allocated n-th dispatch entry.\n    kJSDispatchEntry,\n    // A prefix indicating that the following object is referenced through a\n    // protected pointer, i.e. a pointer from one trusted object to another.\n    kProtectedPointerPrefix,\n\n    //\n    // ---------- byte code range 0x40..0x7f ----------\n    //\n\n    // 0x40..0x5f\n    kRootArrayConstants = 0x40,\n\n    // 0x60..0x7f\n    kFixedRawData = 0x60,\n\n    //\n    // ---------- byte code range 0x80..0x9f ----------\n    //\n\n    // 0x80..0x8f\n    kFixedRepeatRoot = 0x80,\n\n    // 0x90..0x97\n    kHotObject = 0x90,\n  };\n        ]]></code>\n    </enum>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"BytecodeValueEncoder\",\n            \"about\": \"Helper class for encoding and decoding a value into and from a bytecode.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  template <Bytecode kBytecode, int kMinValue, int kMaxValue,\n            typename TValue = int>\n  struct BytecodeValueEncoder {\n    static_assert((kBytecode + kMaxValue - kMinValue) <= kMaxUInt8);\n\n    static constexpr bool IsEncodable(TValue value) {\n      return base::IsInRange(static_cast<int>(value), kMinValue, kMaxValue);\n    }\n\n    static constexpr uint8_t Encode(TValue value) {\n      DCHECK(IsEncodable(value));\n      return static_cast<uint8_t>(kBytecode + static_cast<int>(value) -\n                                  kMinValue);\n    }\n\n    static constexpr TValue Decode(uint8_t bytecode) {\n      DCHECK(base::IsInRange(bytecode, Encode(static_cast<TValue>(kMinValue)),\n                             Encode(static_cast<TValue>(kMaxValue))));\n      return static_cast<TValue>(bytecode - kBytecode + kMinValue);\n    }\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"VariableRepeatRootCount\",\n            \"about\": \"Encodes/decodes repeat count into a serialized variable repeat count value.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  // Encodes/decodes repeat count into a serialized variable repeat count\n  // value.\n  struct VariableRepeatRootCount {\n    static constexpr bool IsEncodable(int repeat_count) {\n      return repeat_count >= kFirstEncodableVariableRepeatRootCount;\n    }\n\n    static constexpr int Encode(int repeat_count) {\n      DCHECK(IsEncodable(repeat_count));\n      return repeat_count - kFirstEncodableVariableRepeatRootCount;\n    }\n\n    static constexpr int Decode(int value) {\n      return value + kFirstEncodableVariableRepeatRootCount;\n    }\n  };\n        ]]></code>\n    </class>\n\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"SpaceEncoder\",\n            \"parent\": \"SerializerDeserializer\",\n            \"about\": \"Type alias for SpaceEncoder.\",\n            \"dependencies\": [\n                \"BytecodeValueEncoder\",\n                \"SnapshotSpace\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  template <Bytecode bytecode>\n  using SpaceEncoder =\n      BytecodeValueEncoder<bytecode, 0, kNumberOfSnapshotSpaces - 1,\n                           SnapshotSpace>;\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"NewObject\",\n            \""
}