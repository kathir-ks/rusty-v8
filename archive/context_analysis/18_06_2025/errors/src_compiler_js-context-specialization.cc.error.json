{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-context-specialization.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-context-specialization.cc\",\n            \"file_name\": \"js-context-specialization.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Performs context specialization optimizations in the V8 compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary header files for compilation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/js-context-specialization.h\"\n\n#include \"src/base/logging.h\"\n#include \"src/compiler/access-builder.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/feedback-source.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/js-operator.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/property-access-builder.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/deoptimizer/deoptimize-reason.h\"\n#include \"src/objects/contexts-inl.h\"\n#include \"src/objects/property-cell.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSContextSpecialization\",\n                \"about\": \"Performs context-sensitive optimizations on the JS graph.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass JSContextSpecialization {\n public:\n  Reduction Reduce(Node* node);\n\n  Isolate* isolate() const;\n\n private:\n  Reduction ReduceParameter(Node* node);\n  Reduction ReduceJSLoadContext(Node* node);\n  Reduction ReduceJSLoadScriptContext(Node* node);\n  Reduction ReduceJSStoreContext(Node* node);\n  Reduction ReduceJSStoreScriptContext(Node* node);\n  Reduction ReduceJSGetImportMeta(Node* node);\n\n  Reduction SimplifyJSLoadContext(Node* node, Node* new_context,\n                                   size_t new_depth);\n  Reduction SimplifyJSLoadScriptContext(Node* node, Node* new_context,\n                                        size_t new_depth);\n  Reduction SimplifyJSStoreContext(Node* node, Node* new_context,\n                                    size_t new_depth);\n  Reduction SimplifyJSStoreScriptContext(Node* node, Node* new_context,\n                                         size_t new_depth);\n\n  JSGraph* jsgraph() const { return jsgraph_; }\n  JSHeapBroker* broker() const { return broker_; }\n  Maybe<OuterContext> outer() const { return outer_context_; }\n  Handle<JSFunction> closure() const { return closure_; }\n\n  JSContextSpecialization(JSGraph* jsgraph, JSHeapBroker* broker,\n                           Handle<JSFunction> closure,\n                           Maybe<OuterContext> outer_context)\n      : jsgraph_(jsgraph),\n        broker_(broker),\n        closure_(closure),\n        outer_context_(outer_context) {}\n\n  JSGraph* const jsgraph_;\n  JSHeapBroker* const broker_;\n  Handle<JSFunction> closure_;\n  Maybe<OuterContext> outer_context_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reduce\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Reduces a given node based on its opcode.\",\n                \"logic\": \"Switches on the opcode of the given node and calls the corresponding reduction function.  If no specific reduction is applicable, it returns NoChange().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to be reduced.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"ReduceParameter\",\n                    \"ReduceJSLoadContext\",\n                    \"ReduceJSLoadScriptContext\",\n                    \"ReduceJSStoreContext\",\n                    \"ReduceJSStoreScriptContext\",\n                    \"ReduceJSGetImportMeta\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kParameter:\n      return ReduceParameter(node);\n    case IrOpcode::kJSLoadContext:\n      return ReduceJSLoadContext(node);\n    case IrOpcode::kJSLoadScriptContext:\n      return ReduceJSLoadScriptContext(node);\n    case IrOpcode::kJSStoreContext:\n      return ReduceJSStoreContext(node);\n    case IrOpcode::kJSStoreScriptContext:\n      return ReduceJSStoreScriptContext(node);\n    case IrOpcode::kJSGetImportMeta:\n      return ReduceJSGetImportMeta(node);\n    default:\n      break;\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceParameter\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Constant-folds the function parameter if it is the closure.\",\n                \"logic\": \"Checks if the parameter is the closure. If so, and the closure is a constant, replaces the parameter with the constant value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The parameter node to be reduced.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::ReduceParameter(Node* node) {\n  DCHECK_EQ(IrOpcode::kParameter, node->opcode());\n  int const index = ParameterIndexOf(node->op());\n  if (index == Linkage::kJSCallClosureParamIndex) {\n    // Constant-fold the function parameter {node}.\n    Handle<JSFunction> function;\n    if (closure().ToHandle(&function)) {\n      Node* value =\n          jsgraph()->ConstantNoHole(MakeRef(broker_, function), broker());\n      return Replace(value);\n    }\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SimplifyJSLoadContext\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Simplifies a JSLoadContext node by folding in a known context.\",\n                \"logic\": \"Replaces the context input of the JSLoadContext node with a new context node and adjusts the depth of the context access. If the new depth and context are the same as the existing ones, it returns NoChange().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSLoadContext node to be simplified.\"\n                    },\n                    {\n                        \"name\": \"new_context\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The new context node.\"\n                    },\n                    {\n                        \"name\": \"new_depth\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The new context depth.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the simplification.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::SimplifyJSLoadContext(Node* node,\n                                                         Node* new_context,\n                                                         size_t new_depth) {\n  DCHECK_EQ(IrOpcode::kJSLoadContext, node->opcode());\n  const ContextAccess& access = ContextAccessOf(node->op());\n  DCHECK_LE(new_depth, access.depth());\n\n  if (new_depth == access.depth() &&\n      new_context == NodeProperties::GetContextInput(node)) {\n    return NoChange();\n  }\n\n  const Operator* op = jsgraph_->javascript()->LoadContext(\n      new_depth, access.index(), access.immutable());\n  NodeProperties::ReplaceContextInput(node, new_context);\n  NodeProperties::ChangeOp(node, op);\n  return Changed(node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SimplifyJSLoadScriptContext\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Simplifies a JSLoadScriptContext node by folding in a known context.\",\n                \"logic\": \"Replaces the context input of the JSLoadScriptContext node with a new context node and adjusts the depth of the context access. If the new depth and context are the same as the existing ones, it returns NoChange().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSLoadScriptContext node to be simplified.\"\n                    },\n                    {\n                        \"name\": \"new_context\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The new context node.\"\n                    },\n                    {\n                        \"name\": \"new_depth\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The new context depth.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the simplification.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::SimplifyJSLoadScriptContext(\n    Node* node, Node* new_context, size_t new_depth) {\n  DCHECK_EQ(IrOpcode::kJSLoadScriptContext, node->opcode());\n  const ContextAccess& access = ContextAccessOf(node->op());\n  DCHECK_LE(new_depth, access.depth());\n\n  if (new_depth == access.depth() &&\n      new_context == NodeProperties::GetContextInput(node)) {\n    return NoChange();\n  }\n\n  const Operator* op =\n      jsgraph_->javascript()->LoadScriptContext(new_depth, access.index());\n  NodeProperties::ReplaceContextInput(node, new_context);\n  NodeProperties::ChangeOp(node, op);\n  return Changed(node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SimplifyJSStoreContext\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Simplifies a JSStoreContext node by folding in a known context.\",\n                \"logic\": \"Replaces the context input of the JSStoreContext node with a new context node and adjusts the depth of the context access. If the new depth and context are the same as the existing ones, it returns NoChange().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSStoreContext node to be simplified.\"\n                    },\n                    {\n                        \"name\": \"new_context\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The new context node.\"\n                    },\n                    {\n                        \"name\": \"new_depth\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The new context depth.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the simplification.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::SimplifyJSStoreContext(Node* node,\n                                                          Node* new_context,\n                                                          size_t new_depth) {\n  DCHECK_EQ(IrOpcode::kJSStoreContext, node->opcode());\n  const ContextAccess& access = ContextAccessOf(node->op());\n  DCHECK_LE(new_depth, access.depth());\n\n  if (new_depth == access.depth() &&\n      new_context == NodeProperties::GetContextInput(node)) {\n    return NoChange();\n  }\n\n  const Operator* op =\n      jsgraph_->javascript()->StoreContext(new_depth, access.index());\n  NodeProperties::ReplaceContextInput(node, new_context);\n  NodeProperties::ChangeOp(node, op);\n  return Changed(node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SimplifyJSStoreScriptContext\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Simplifies a JSStoreScriptContext node by folding in a known context.\",\n                \"logic\": \"Replaces the context input of the JSStoreScriptContext node with a new context node and adjusts the depth of the context access. If the new depth and context are the same as the existing ones, it returns NoChange().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSStoreScriptContext node to be simplified.\"\n                    },\n                    {\n                        \"name\": \"new_context\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The new context node.\"\n                    },\n                    {\n                        \"name\": \"new_depth\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The new context depth.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the simplification.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::SimplifyJSStoreScriptContext(\n    Node* node, Node* new_context, size_t new_depth) {\n  DCHECK_EQ(IrOpcode::kJSStoreScriptContext, node->opcode());\n  const ContextAccess& access = ContextAccessOf(node->op());\n  DCHECK_LE(new_depth, access.depth());\n\n  if (new_depth == access.depth() &&\n      new_context == NodeProperties::GetContextInput(node)) {\n    return NoChange();\n  }\n\n  const Operator* op =\n      jsgraph_->javascript()->StoreScriptContext(new_depth, access.index());\n  NodeProperties::ReplaceContextInput(node, new_context);\n  NodeProperties::ChangeOp(node, op);\n  return Changed(node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSLoadContext\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Reduces a JSLoadContext node by attempting to resolve the context and slot value to a constant.\",\n                \"logic\": \"Walks up the context chain, attempting to concretize the context. If a concrete context is found, it attempts to read the slot value. If the slot value is immutable and not the hole or undefined, it replaces the JSLoadContext node with a constant node representing the slot value.  If mutable, or the value cannot be determined, the load is partially reduced.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSLoadContext node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"SimplifyJSLoadContext\",\n                    \"GetSpecializationContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::ReduceJSLoadContext(Node* node) {\n  DCHECK_EQ(IrOpcode::kJSLoadContext, node->opcode());\n\n  const ContextAccess& access = ContextAccessOf(node->op());\n  size_t depth = access.depth();\n\n  // First walk up the context chain in the graph as far as possible.\n  Node* context = NodeProperties::GetOuterContext(node, &depth);\n\n  OptionalContextRef maybe_concrete =\n      GetSpecializationContext(broker(), context, &depth, outer());\n  if (!maybe_concrete.has_value()) {\n    // We do not have a concrete context object, so we can only partially reduce\n    // the load by folding-in the outer context node.\n    return SimplifyJSLoadContext(node, context, depth);\n  }\n\n  // Now walk up the concrete context chain for the remaining depth.\n  ContextRef concrete = maybe_concrete.value();\n  concrete = concrete.previous(broker(), &depth);\n  if (depth > 0) {\n    TRACE_BROKER_MISSING(broker(), \"previous value for context \" << concrete);\n    return SimplifyJSLoadContext(\n        node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n  }\n\n  if (!access.immutable() &&\n      !broker()->dependencies()->DependOnScriptContextSlotProperty(\n          concrete, access.index(), ContextSidePropertyCell::kConst,\n          broker())) {\n    // We found the requested context object but since the context slot is\n    // mutable we can only partially reduce the load.\n    return SimplifyJSLoadContext(\n        node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n  }\n\n  // This will hold the final value, if we can figure it out.\n  OptionalObjectRef maybe_value;\n  maybe_value = concrete.get(broker(), static_cast<int>(access.index()));\n\n  if (!maybe_value.has_value()) {\n    TRACE_BROKER_MISSING(broker(), \"slot value \" << access.index()\n                                                 << \" for context \"\n                                                 << concrete);\n    return SimplifyJSLoadContext(\n        node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n  }\n\n  // Even though the context slot is immutable, the context might have escaped\n  // before the function to which it belongs has initialized the slot.\n  // We must be conservative and check if the value in the slot is currently\n  // the hole or undefined. Only if it is neither of these, can we be sure\n  // that it won't change anymore.\n  if (maybe_value->IsUndefined() || maybe_value->IsTheHole()) {\n    return SimplifyJSLoadContext(\n        node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n  }\n\n  // Success. The context load can be replaced with the constant.\n  Node* constant = jsgraph_->ConstantNoHole(*maybe_value, broker());\n  ReplaceWithValue(node, constant);\n  return Replace(constant);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSLoadScriptContext\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Reduces a JSLoadScriptContext node by attempting to resolve the context and slot value to a constant or specialized load.\",\n                \"logic\": \"Walks up the context chain, attempting to concretize the context. If a concrete context is found, it attempts to read the slot value. Depending on the context side property (kConst, kSmi, kMutableInt32, kMutableHeapNumber, kOther), it replaces the JSLoadScriptContext node with a constant node, a specialized load, or a standard load. If the value cannot be determined, the load is partially reduced.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSLoadScriptContext node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"SimplifyJSLoadScriptContext\",\n                    \"GetSpecializationContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::ReduceJSLoadScriptContext(Node* node) {\n  DCHECK_EQ(IrOpcode::kJSLoadScriptContext, node->opcode());\n\n  const ContextAccess& access = ContextAccessOf(node->op());\n  DCHECK(!access.immutable());\n  size_t depth = access.depth();\n\n  // First walk up the context chain in the graph as far as possible.\n  Node* effect = NodeProperties::GetEffectInput(node);\n  Node* control = NodeProperties::GetControlInput(node);\n  Node* context = NodeProperties::GetOuterContext(node, &depth);\n\n  OptionalContextRef maybe_concrete =\n      GetSpecializationContext(broker(), context, &depth, outer());\n  if (!maybe_concrete.has_value()) {\n    // We do not have a concrete context object, so we can only partially reduce\n    // the load by folding-in the outer context node.\n    return SimplifyJSLoadScriptContext(node, context, depth);\n  }\n\n  // Now walk up the concrete context chain for the remaining depth.\n  ContextRef concrete = maybe_concrete.value();\n  concrete = concrete.previous(broker(), &depth);\n  if (depth > 0) {\n    TRACE_BROKER_MISSING(broker(), \"previous value for context \" << concrete);\n    return SimplifyJSLoadScriptContext(\n        node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n  }\n\n  DCHECK(concrete.object()->IsScriptContext());\n  auto maybe_property =\n      concrete.object()->GetScriptContextSideProperty(access.index());\n  if (!maybe_property) {\n    return SimplifyJSLoadScriptContext(\n        node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n  }\n  auto property = maybe_property.value();\n  switch (property) {\n    case ContextSidePropertyCell::kConst: {\n      OptionalObjectRef maybe_value =\n          concrete.get(broker(), static_cast<int>(access.index()));\n      if (!maybe_value.has_value()) {\n        TRACE_BROKER_MISSING(broker(), \"slot value \" << access.index()\n                                                     << \" for context \"\n                                                     << concrete);\n        return SimplifyJSLoadScriptContext(\n            node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n      }\n      broker()->dependencies()->DependOnScriptContextSlotProperty(\n          concrete, access.index(), property, broker());\n      Node* constant = jsgraph_->ConstantNoHole(*maybe_value, broker());\n      ReplaceWithValue(node, constant, effect, control);\n      return Changed(node);\n    }\n    case ContextSidePropertyCell::kSmi: {\n      broker()->dependencies()->DependOnScriptContextSlotProperty(\n          concrete, access.index(), property, broker());\n      Node* load = effect = jsgraph_->graph()->NewNode(\n          jsgraph_->simplified()->LoadField(\n              AccessBuilder::ForContextSlotSmi(access.index())),\n          jsgraph_->ConstantNoHole(concrete, broker()), effect, control);\n      ReplaceWithValue(node, load, effect, control);\n      return Changed(node);\n    }\n    case ContextSidePropertyCell::kMutableInt32: {\n      Node* mutable_heap_number;\n      if (auto concrete_heap_number =\n              concrete.get(broker(), static_cast<int>(access.index()))) {\n        if (!concrete_heap_number->IsHeapNumber()) {\n          // TODO(victorgomes): In case the tag is out of date by now we could\n          // retry this reduction.\n          return NoChange();\n        }\n        mutable_heap_number = jsgraph_->ConstantMutableHeapNumber(\n            concrete_heap_number->AsHeapNumber(), broker());\n      } else {\n        mutable_heap_number = effect = jsgraph_->graph()->NewNode(\n            jsgraph_->simplified()->LoadField(\n                AccessBuilder::ForContextSlot(access.index())),\n            jsgraph_->ConstantNoHole(concrete, broker()), effect, control);\n      }\n      broker()->dependencies()->DependOnScriptContextSlotProperty(\n          concrete, access.index(), property, broker());\n      Node* int32_load = effect = jsgraph_->graph()->NewNode(\n          jsgraph_->simplified()->LoadField(AccessBuilder::ForHeapInt32Value()),\n          mutable_heap_number, effect, control);\n      ReplaceWithValue(node, int32_load, effect, control);\n      return Changed(node);\n    }\n    case ContextSidePropertyCell::kMutableHeapNumber: {\n      Node* mutable_heap_number;\n      if (auto concrete_heap_number =\n              concrete.get(broker(), static_cast<int>(access.index()))) {\n        if (!concrete_heap_number->IsHeapNumber()) {\n          // TODO(victorgomes): In case the tag is out of date by now we could\n          // retry this reduction.\n          return NoChange();\n        }\n        mutable_heap_number = jsgraph_->ConstantMutableHeapNumber(\n            concrete_heap_number->AsHeapNumber(), broker());\n      } else {\n        mutable_heap_number = effect = jsgraph_->graph()->NewNode(\n            jsgraph_->simplified()->LoadField(\n                AccessBuilder::ForContextSlot(access.index())),\n            jsgraph_->ConstantNoHole(concrete, broker()), effect, control);\n      }\n      broker()->dependencies()->DependOnScriptContextSlotProperty(\n          concrete, access.index(), property, broker());\n      Node* double_load = effect =\n          jsgraph_->graph()->NewNode(jsgraph_->simplified()->LoadField(\n                                         AccessBuilder::ForHeapNumberValue()),\n                                     mutable_heap_number, effect, control);\n      ReplaceWithValue(node, double_load, effect, control);\n      return Changed(node);\n    }\n    case ContextSidePropertyCell::kOther: {\n      // Do a normal context load.\n      Node* load = effect = jsgraph_->graph()->NewNode(\n          jsgraph_->simplified()->LoadField(\n              AccessBuilder::ForContextSlot(access.index())),\n          jsgraph_->ConstantNoHole(concrete, broker()), effect, control);\n      ReplaceWithValue(node, load, effect, control);\n      return Changed(node);\n    }\n    default:\n      UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSStoreContext\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Reduces a JSStoreContext node by attempting to resolve the context.\",\n                \"logic\": \"Walks up the context chain, attempting to concretize the context.  If a concrete context is found, the store is partially reduced.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSStoreContext node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"SimplifyJSStoreContext\",\n                    \"GetSpecializationContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::ReduceJSStoreContext(Node* node) {\n  DCHECK_EQ(IrOpcode::kJSStoreContext, node->opcode());\n\n  const ContextAccess& access = ContextAccessOf(node->op());\n  size_t depth = access.depth();\n\n  // First walk up the context chain in the graph until we reduce the depth to 0\n  // or hit a node that does not have a CreateXYZContext operator.\n  Node* context = NodeProperties::GetOuterContext(node, &depth);\n\n  OptionalContextRef maybe_concrete =\n      GetSpecializationContext(broker(), context, &depth, outer());\n  if (!maybe_concrete.has_value()) {\n    // We do not have a concrete context object, so we can only partially reduce\n    // the load by folding-in the outer context node.\n    return SimplifyJSStoreContext(node, context, depth);\n  }\n\n  // Now walk up the concrete context chain for the remaining depth.\n  ContextRef concrete = maybe_concrete.value();\n  concrete = concrete.previous(broker(), &depth);\n  if (depth > 0) {\n    TRACE_BROKER_MISSING(broker(), \"previous value for context \" << concrete);\n    return SimplifyJSStoreContext(\n        node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n  }\n\n  return SimplifyJSStoreContext(\n      node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceJSStoreScriptContext\",\n                \"parent\": \"JSContextSpecialization\",\n                \"about\": \"Reduces a JSStoreScriptContext node by attempting to resolve the context and perform specialized stores based on context side properties.\",\n                \"logic\": \"Walks up the context chain, attempting to concretize the context. If a concrete context is found, it attempts to perform specialized stores based on the context side property (kConst, kSmi, kMutableInt32, kMutableHeapNumber, kOther). It also includes checks and type conversions before storing the value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The JSStoreScriptContext node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"SimplifyJSStoreScriptContext\",\n                    \"GetSpecializationContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction JSContextSpecialization::ReduceJSStoreScriptContext(Node* node) {\n  DCHECK(v8_flags.script_context_mutable_heap_number ||\n         v8_flags.const_tracking_let);\n  DCHECK_EQ(IrOpcode::kJSStoreScriptContext, node->opcode());\n\n  const ContextAccess& access = ContextAccessOf(node->op());\n  size_t depth = access.depth();\n\n  // First walk up the context chain in the graph until we reduce the depth to 0\n  // or hit a node that does not have a CreateXYZContext operator.\n  Node* context = NodeProperties::GetOuterContext(node, &depth);\n  Node* value = NodeProperties::GetValueInput(node, 0);\n  Effect effect{NodeProperties::GetEffectInput(node)};\n  Control control{NodeProperties::GetControlInput(node)};\n\n  OptionalContextRef maybe_concrete =\n      GetSpecializationContext(broker(), context, &depth, outer());\n  if (!maybe_concrete.has_value()) {\n    // We do not have a concrete context object, so we can only partially reduce\n    // the load by folding-in the outer context node.\n    return SimplifyJSStoreScriptContext(node, context, depth);\n  }\n\n  // Now walk up the concrete context chain for the remaining depth.\n  ContextRef concrete = maybe_concrete.value();\n  concrete = concrete.previous(broker(), &depth);\n  if (depth > 0) {\n    TRACE_BROKER_MISSING(broker(), \"previous value for context \" << concrete);\n    return SimplifyJSStoreScriptContext(\n        node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n  }\n  DCHECK(concrete.object()->IsScriptContext());\n  auto maybe_property =\n      concrete.object()->GetScriptContextSideProperty(access.index());\n  if (!maybe_property) {\n    return SimplifyJSStoreScriptContext(\n        node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n  }\n  auto property = maybe_property.value();\n  PropertyAccessBuilder access_builder(jsgraph(), broker());\n  if (property == ContextSidePropertyCell::kConst) {\n    compiler::OptionalObjectRef constant =\n        concrete.get(broker(), static_cast<int>(access.index()));\n    if (!constant.has_value() ||\n        (constant->IsString() && !constant->IsInternalizedString())) {\n      return SimplifyJSStoreScriptContext(\n          node, jsgraph()->ConstantNoHole(concrete, broker()), depth);\n    }\n    broker()->dependencies()->DependOnScriptContextSlotProperty(\n        concrete, access.index(), property, broker());\n    access_builder.BuildCheckValue(value, &effect, control, *constant);\n    ReplaceWithValue(node, effect, effect, control);\n    return Changed(node);\n  }\n\n  if (!v8_flags.script_context_mutable_heap_number) {\n    // Do a normal context store.\n    Node* store = jsgraph()->graph()->NewNode(\n        jsgraph()->simplified()->StoreField(\n            AccessBuilder::ForContextSlot(access.index())),\n        jsgraph()->ConstantNoHole(concrete, broker()), value, effect, control);\n    ReplaceWithValue(node, store, store, control);\n    return Changed(node);\n  }\n\n  switch (property) {\n    case ContextSidePropertyCell::kConst:\n      UNREACHABLE();\n    case ContextSidePropertyCell::kSmi: {\n      broker()->dependencies()->DependOnScriptContextSlotProperty(\n          concrete, access.index(), property, broker());\n      Node* smi_value = access_builder.BuildCheckSmi(value, &effect, control);\n      Node* smi_store = jsgraph()->graph()->NewNode(\n          jsgraph()->simplified()->StoreField(\n              AccessBuilder::ForContextSlotSmi(access.index())),\n          jsgraph()->ConstantNoHole(concrete, broker()), smi_value, effect,\n          control);\n      ReplaceWithValue(node, smi_store, smi_store, control);\n      return Changed(node);\n    }\n    case ContextSidePropertyCell::kMutableInt32: {\n      Node* mutable_heap_number;\n      "
}