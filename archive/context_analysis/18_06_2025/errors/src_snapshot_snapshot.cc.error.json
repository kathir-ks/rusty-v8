{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/snapshot.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/snapshot.cc\",\n        \"file_name\": \"snapshot.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements snapshot creation and deserialization functionality for V8 JavaScript engine\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for snapshot functionality, API, baseline compiler, assertions, execution, handles, heap management, initialization, logging, object representation, serialization, utilities, and versioning.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/snapshot.h\"\n\n#include \"src/api/api-inl.h\"  // For OpenHandle.\n#include \"src/baseline/baseline-batch-compiler.h\"\n#include \"src/common/assert-scope.h\"\n#include \"src/execution/local-isolate-inl.h\"\n#include \"src/handles/global-handles-inl.h\"\n#include \"src/heap/local-heap-inl.h\"\n#include \"src/heap/read-only-promotion.h\"\n#include \"src/heap/safepoint.h\"\n#include \"src/init/bootstrapper.h\"\n#include \"src/logging/counters-scopes.h\"\n#include \"src/logging/runtime-call-stats-scope.h\"\n#include \"src/objects/js-regexp-inl.h\"\n#include \"src/snapshot/context-deserializer.h\"\n#include \"src/snapshot/context-serializer.h\"\n#include \"src/snapshot/read-only-serializer.h\"\n#include \"src/snapshot/shared-heap-serializer.h\"\n#include \"src/snapshot/snapshot-utils.h\"\n#include \"src/snapshot/startup-serializer.h\"\n#include \"src/utils/memcopy.h\"\n#include \"src/utils/version.h\"\n\n#ifdef V8_SNAPSHOT_COMPRESSION\n#include \"src/snapshot/snapshot-compression.h\"\n#endif\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8::internal\",\n            \"purpose\": \"Encloses V8 internal implementation details.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \" (anonymous)\",\n            \"purpose\": \"Contains internal, file-specific helper classes and functions for snapshot implementation.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n        ]]></code>\n    </namespace>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SnapshotImpl\",\n            \"extends\": \"AllStatic\",\n            \"about\": \"Provides static methods for creating, extracting data from, and manipulating snapshot blobs.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"SnapshotData\",\n                \"std::vector\",\n                \"v8::StartupData\",\n                \"base::Vector\",\n                \"ContextDeserializer\",\n                \"ContextSerializer\",\n                \"ReadOnlySerializer\",\n                \"SharedHeapSerializer\",\n                \"StartupSerializer\",\n                \"SnapshotCompression\",\n                \"Version\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass SnapshotImpl : public AllStatic {\n public:\n  static v8::StartupData CreateSnapshotBlob(\n      const SnapshotData* startup_snapshot_in,\n      const SnapshotData* read_only_snapshot_in,\n      const SnapshotData* shared_heap_snapshot_in,\n      const std::vector<SnapshotData*>& context_snapshots_in,\n      bool can_be_rehashed);\n\n  static uint32_t ExtractNumContexts(const v8::StartupData* data);\n  static uint32_t ExtractContextOffset(const v8::StartupData* data,\n                                       uint32_t index);\n  static base::Vector<const uint8_t> ExtractStartupData(\n      const v8::StartupData* data);\n  static base::Vector<const uint8_t> ExtractReadOnlyData(\n      const v8::StartupData* data);\n  static base::Vector<const uint8_t> ExtractSharedHeapData(\n      const v8::StartupData* data);\n  static base::Vector<const uint8_t> ExtractContextData(\n      const v8::StartupData* data, uint32_t index);\n\n  static uint32_t GetHeaderValue(const v8::StartupData* data, uint32_t offset) {\n    DCHECK_NOT_NULL(data);\n    DCHECK_LT(offset, static_cast<uint32_t>(data->raw_size));\n    return base::ReadLittleEndianValue<uint32_t>(\n        reinterpret_cast<Address>(data->data) + offset);\n  }\n  static void SetHeaderValue(char* data, uint32_t offset, uint32_t value) {\n    base::WriteLittleEndianValue(reinterpret_cast<Address>(data) + offset,\n                                 value);\n  }\n\n  static void CheckVersion(const v8::StartupData* data);\n\n  // Snapshot blob layout:\n  // [0] number of contexts N\n  // [1] rehashability\n  // [2] checksum\n  // [3] read-only snapshot checksum\n  // [4] (64 bytes) version string\n  // [5] offset to readonly\n  // [6] offset to shared heap\n  // [7] offset to context 0\n  // [8] offset to context 1\n  // ...\n  // ... offset to context N - 1\n  // ... startup snapshot data\n  // ... read-only snapshot data\n  // ... shared heap snapshot data\n  // ... context 0 snapshot data\n  // ... context 1 snapshot data\n\n  static const uint32_t kNumberOfContextsOffset = 0;\n  // TODO(yangguo): generalize rehashing, and remove this flag.\n  static const uint32_t kRehashabilityOffset =\n      kNumberOfContextsOffset + kUInt32Size;\n  static const uint32_t kChecksumOffset = kRehashabilityOffset + kUInt32Size;\n  static const uint32_t kReadOnlySnapshotChecksumOffset =\n      kChecksumOffset + kUInt32Size;\n  static const uint32_t kVersionStringOffset =\n      kReadOnlySnapshotChecksumOffset + kUInt32Size;\n  static const uint32_t kVersionStringLength = 64;\n  static const uint32_t kReadOnlyOffsetOffset =\n      kVersionStringOffset + kVersionStringLength;\n  static const uint32_t kSharedHeapOffsetOffset =\n      kReadOnlyOffsetOffset + kUInt32Size;\n  static const uint32_t kFirstContextOffsetOffset =\n      kSharedHeapOffsetOffset + kUInt32Size;\n\n  static base::Vector<const uint8_t> ChecksummedContent(\n      const v8::StartupData* data) {\n    // The hashed region is everything but the header slots up-to-and-including\n    // the checksum slot itself.\n    // TODO(jgruber): We currently exclude #contexts and rehashability. This\n    // seems arbitrary and I think we could shuffle header slot order around to\n    // include them, just for consistency.\n    static_assert(kReadOnlySnapshotChecksumOffset ==\n                  kChecksumOffset + kUInt32Size);\n    const uint32_t kChecksumStart = kReadOnlySnapshotChecksumOffset;\n    return base::Vector<const uint8_t>(\n        reinterpret_cast<const uint8_t*>(data->data + kChecksumStart),\n        data->raw_size - kChecksumStart);\n  }\n\n  static uint32_t StartupSnapshotOffset(int num_contexts) {\n    return POINTER_SIZE_ALIGN(kFirstContextOffsetOffset +\n                              num_contexts * kInt32Size);\n  }\n\n  static uint32_t ContextSnapshotOffsetOffset(int index) {\n    return kFirstContextOffsetOffset + index * kInt32Size;\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MaybeDecompress\",\n            \"about\": \"Conditionally decompresses snapshot data if snapshot compression is enabled.\",\n            \"logic\": \"Uses SnapshotCompression::Decompress if V8_SNAPSHOT_COMPRESSION is defined, otherwise returns the input data.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate the snapshot belongs to.\"\n                },\n                {\n                    \"name\": \"snapshot_data\",\n                    \"type\": \"base::Vector<const uint8_t>\",\n                    \"purpose\": \"The compressed snapshot data.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"SnapshotData\",\n                \"description\": \"The decompressed or original snapshot data.\"\n            },\n            \"dependencies\": [\n                \"SnapshotCompression\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nSnapshotData MaybeDecompress(Isolate* isolate,\n                             base::Vector<const uint8_t> snapshot_data) {\n#ifdef V8_SNAPSHOT_COMPRESSION\n  TRACE_EVENT0(\"v8\", \"V8.SnapshotDecompress\");\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kSnapshotDecompress);\n  NestedTimedHistogramScope histogram_timer(\n      isolate->counters()->snapshot_decompress());\n  return SnapshotCompression::Decompress(snapshot_data);\n#else\n  return SnapshotData(snapshot_data);\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Snapshot::SnapshotIsValid\",\n            \"about\": \"Checks if a snapshot blob is valid (has at least one context).\",\n            \"logic\": \"Extracts the number of contexts from the snapshot blob and checks if it's greater than 0.\",\n            \"parameters\": [\n                {\n                    \"name\": \"snapshot_blob\",\n                    \"type\": \"const v8::StartupData*\",\n                    \"purpose\": \"The snapshot data to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the snapshot is valid, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"SnapshotImpl::ExtractNumContexts\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nbool Snapshot::SnapshotIsValid(const v8::StartupData* snapshot_blob) {\n  return SnapshotImpl::ExtractNumContexts(snapshot_blob) > 0;\n}\n#endif  // DEBUG\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Snapshot::HasContextSnapshot\",\n            \"about\": \"Checks if a context snapshot exists at a given index.\",\n            \"logic\": \"Retrieves the snapshot blob from the isolate and checks if the provided index is within the bounds of the number of contexts in the snapshot.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the context snapshot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the context snapshot exists, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"SnapshotImpl::ExtractNumContexts\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Snapshot::HasContextSnapshot(Isolate* isolate, size_t index) {\n  // Do not use snapshots if the isolate is used to create snapshots.\n  const v8::StartupData* blob = isolate->snapshot_blob();\n  if (blob == nullptr) return false;\n  if (blob->data == nullptr) return false;\n  size_t num_contexts =\n      static_cast<size_t>(SnapshotImpl::ExtractNumContexts(blob));\n  return index < num_contexts;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Snapshot::VersionIsValid\",\n            \"about\": \"Checks if the version string in the snapshot matches the current V8 version.\",\n            \"logic\": \"Compares the version string stored in the snapshot with the current V8 version string.\",\n            \"parameters\": [\n                {\n                    \"name\": \"data\",\n                    \"type\": \"const v8::StartupData*\",\n                    \"purpose\": \"The snapshot data to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the versions match, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"SnapshotImpl::kVersionStringOffset\",\n                \"SnapshotImpl::kVersionStringLength\",\n                \"Version::GetString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Snapshot::VersionIsValid(const v8::StartupData* data) {\n  char version[SnapshotImpl::kVersionStringLength];\n  memset(version, 0, SnapshotImpl::kVersionStringLength);\n  CHECK_LT(\n      SnapshotImpl::kVersionStringOffset + SnapshotImpl::kVersionStringLength,\n      static_cast<uint32_t>(data->raw_size));\n  Version::GetString(\n      base::Vector<char>(version, SnapshotImpl::kVersionStringLength));\n  return strncmp(version, data->data + SnapshotImpl::kVersionStringOffset,\n                 SnapshotImpl::kVersionStringLength) == 0;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Snapshot::Initialize\",\n            \"about\": \"Initializes the isolate with snapshot data.\",\n            \"logic\": \"Extracts startup, read-only, and shared heap data from the snapshot blob, decompresses them, and calls InitWithSnapshot on the isolate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to initialize.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if initialization succeeds, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"SnapshotImpl::CheckVersion\",\n                \"Snapshot::ShouldVerifyChecksum\",\n                \"Snapshot::VerifyChecksum\",\n                \"SnapshotImpl::ExtractStartupData\",\n                \"SnapshotImpl::ExtractReadOnlyData\",\n                \"SnapshotImpl::ExtractSharedHeapData\",\n                \"MaybeDecompress\",\n                \"isolate->InitWithSnapshot\",\n                \"ExtractRehashability\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Snapshot::Initialize(Isolate* isolate) {\n  if (!isolate->snapshot_available()) return false;\n\n  const v8::StartupData* blob = isolate->snapshot_blob();\n  SnapshotImpl::CheckVersion(blob);\n  if (Snapshot::ShouldVerifyChecksum(blob)) {\n    CHECK(VerifyChecksum(blob));\n  }\n\n  base::Vector<const uint8_t> startup_data =\n      SnapshotImpl::ExtractStartupData(blob);\n  base::Vector<const uint8_t> read_only_data =\n      SnapshotImpl::ExtractReadOnlyData(blob);\n  base::Vector<const uint8_t> shared_heap_data =\n      SnapshotImpl::ExtractSharedHeapData(blob);\n\n  SnapshotData startup_snapshot_data(MaybeDecompress(isolate, startup_data));\n  SnapshotData read_only_snapshot_data(\n      MaybeDecompress(isolate, read_only_data));\n  SnapshotData shared_heap_snapshot_data(\n      MaybeDecompress(isolate, shared_heap_data));\n\n  return isolate->InitWithSnapshot(\n      &startup_snapshot_data, &read_only_snapshot_data,\n      &shared_heap_snapshot_data, ExtractRehashability(blob));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Snapshot::NewContextFromSnapshot\",\n            \"about\": \"Creates a new context from a context snapshot.\",\n            \"logic\": \"Extracts context data from the snapshot blob, decompresses it, and calls ContextDeserializer::DeserializeContext.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to create the context in.\"\n                },\n                {\n                    \"name\": \"global_proxy\",\n                    \"type\": \"DirectHandle<JSGlobalProxy>\",\n                    \"purpose\": \"The global proxy for the context.\"\n                },\n                {\n                    \"name\": \"context_index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the context snapshot.\"\n                },\n                {\n                    \"name\": \"embedder_fields_deserializer\",\n                    \"type\": \"DeserializeEmbedderFieldsCallback\",\n                    \"purpose\": \"Callback to deserialize embedder fields.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MaybeDirectHandle<Context>\",\n                \"description\": \"The newly created context, or an empty handle on failure.\"\n            },\n            \"dependencies\": [\n                \"SnapshotImpl::ExtractContextData\",\n                \"MaybeDecompress\",\n                \"ContextDeserializer::DeserializeContext\",\n                \"ExtractRehashability\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMaybeDirectHandle<Context> Snapshot::NewContextFromSnapshot(\n    Isolate* isolate, DirectHandle<JSGlobalProxy> global_proxy,\n    size_t context_index,\n    DeserializeEmbedderFieldsCallback embedder_fields_deserializer) {\n  if (!isolate->snapshot_available()) return DirectHandle<Context>();\n\n  const v8::StartupData* blob = isolate->snapshot_blob();\n  bool can_rehash = ExtractRehashability(blob);\n  base::Vector<const uint8_t> context_data = SnapshotImpl::ExtractContextData(\n      blob, static_cast<uint32_t>(context_index));\n  SnapshotData snapshot_data(MaybeDecompress(isolate, context_data));\n\n  return ContextDeserializer::DeserializeContext(\n      isolate, &snapshot_data, context_index, can_rehash, global_proxy,\n      embedder_fields_deserializer);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Snapshot::ClearReconstructableDataForSerialization\",\n            \"about\": \"Clears SharedFunctionInfos and JSRegExps to prepare for serialization.\",\n            \"logic\": \"Iterates through the heap, clears compiled code from SFIs if possible and clears regexp data of JSRegExps. Also clears js-to-wasm wrappers if webassembly is enabled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to clear data from.\"\n                },\n                {\n                    \"name\": \"clear_recompilable_data\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether recompilable data should be cleared.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"SharedFunctionInfo::DiscardCompiled\",\n                \"JSRegExp::data\",\n                \"RegExpData::HasCompiledCode\",\n                \"IrRegExpData::DiscardCompiledCodeForSerialization\",\n                \"BUILTIN_CODE\",\n                \"JSFunction::UpdateCode\",\n                \"ReadOnlyRoots\",\n                \"JSFunction::raw_feedback_cell\",\n                \"WeakFixedArray\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid Snapshot::ClearReconstructableDataForSerialization(\n    Isolate* isolate, bool clear_recompilable_data) {\n  // Clear SFIs and JSRegExps.\n  PtrComprCageBase cage_base(isolate);\n\n  {\n    HandleScope scope(isolate);\n    std::vector<i::Handle<i::SharedFunctionInfo>> sfis_to_clear;\n    {\n      i::HeapObjectIterator it(isolate->heap());\n      for (i::Tagged<i::HeapObject> o = it.Next(); !o.is_null();\n           o = it.Next()) {\n        if (clear_recompilable_data && IsSharedFunctionInfo(o, cage_base)) {\n          i::Tagged<i::SharedFunctionInfo> shared =\n              i::Cast<i::SharedFunctionInfo>(o);\n          if (IsScript(shared->script(cage_base), cage_base) &&\n              Cast<Script>(shared->script(cage_base))->type() ==\n                  Script::Type::kExtension) {\n            continue;  // Don't clear extensions, they cannot be recompiled.\n          }\n          if (shared->CanDiscardCompiled()) {\n            sfis_to_clear.emplace_back(shared, isolate);\n          }\n        } else if (IsJSRegExp(o, cage_base)) {\n          i::Tagged<i::JSRegExp> regexp = i::Cast<i::JSRegExp>(o);\n          if (regexp->has_data()) {\n            i::Tagged<i::RegExpData> data = regexp->data(isolate);\n            if (data->HasCompiledCode()) {\n              DCHECK(Is<IrRegExpData>(regexp->data(isolate)));\n              Cast<IrRegExpData>(data)->DiscardCompiledCodeForSerialization();\n            }\n          }\n        }\n      }\n    }\n\n#if V8_ENABLE_WEBASSEMBLY\n    // Clear the cached js-to-wasm wrappers.\n    DirectHandle<WeakFixedArray> wrappers(\n        isolate->heap()->js_to_wasm_wrappers(), isolate);\n    MemsetTagged(wrappers->RawFieldOfFirstElement(), ClearedValue(isolate),\n                 wrappers->length());\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n    // Must happen after heap iteration since SFI::DiscardCompiled may allocate.\n    for (i::DirectHandle<i::SharedFunctionInfo> shared : sfis_to_clear) {\n      if (shared->CanDiscardCompiled()) {\n        i::SharedFunctionInfo::DiscardCompiled(isolate, shared);\n      }\n    }\n  }\n\n  // Clear JSFunctions.\n  {\n    i::HeapObjectIterator it(isolate->heap());\n    for (i::Tagged<i::HeapObject> o = it.Next(); !o.is_null(); o = it.Next()) {\n      if (!IsJSFunction(o, cage_base)) continue;\n\n      i::Tagged<i::JSFunction> fun = i::Cast<i::JSFunction>(o);\n      fun->CompleteInobjectSlackTrackingIfActive();\n\n      i::Tagged<i::SharedFunctionInfo> shared = fun->shared();\n      if (IsScript(shared->script(cage_base), cage_base) &&\n          Cast<Script>(shared->script(cage_base))->type() ==\n              Script::Type::kExtension) {\n        continue;  // Don't clear extensions, they cannot be recompiled.\n      }\n\n      // Also, clear out feedback vectors and recompilable code.\n      if (fun->CanDiscardCompiled(isolate)) {\n        fun->UpdateCode(*BUILTIN_CODE(isolate, CompileLazy));\n      }\n      if (!IsUndefined(fun->raw_feedback_cell(cage_base)->value(cage_base))) {\n        fun->raw_feedback_cell(cage_base)->set_value(\n            i::ReadOnlyRoots(isolate).undefined_value());\n      }\n#ifdef DEBUG\n      if (clear_recompilable_data) {\n#if V8_ENABLE_WEBASSEMBLY\n        DCHECK(fun->shared()->HasWasmExportedFunctionData() ||\n               fun->shared()->HasBuiltinId() ||\n               fun->shared()->IsApiFunction() ||\n               fun->shared()->HasUncompiledDataWithoutPreparseData());\n#else\n        DCHECK(fun->shared()->HasBuiltinId() ||\n               fun->shared()->IsApiFunction() ||\n               fun->shared()->HasUncompiledDataWithoutPreparseData());\n#endif  // V8_ENABLE_WEBASSEMBLY\n      }\n#endif  // DEBUG\n    }\n  }\n\n  // PendingOptimizeTable also contains BytecodeArray, we need to clear the\n  // recompilable code same as above.\n  ReadOnlyRoots roots(isolate);\n  isolate->heap()->SetFunctionsMarkedForManualOptimization(\n      roots.undefined_value());\n\n#if V8_ENABLE_WEBASSEMBLY\n  {\n    // Check if there are any asm.js / wasm functions on the heap.\n    // These cannot be serialized due to restrictions with the js-to-wasm\n    // wrapper. A tiered-up wrapper would have to be replaced with a generic\n    // wrapper which isn't supported. For asm.js there also isn't any support\n    // for the generic wrapper at all.\n    i::HeapObjectIterator it(isolate->heap(),\n                             HeapObjectIterator::kFilterUnreachable);\n    for (i::Tagged<i::HeapObject> o = it.Next(); !o.is_null(); o = it.Next()) {\n      if (IsJSFunction(o)) {\n        i::Tagged<i::JSFunction> fun = i::Cast<i::JSFunction>(o);\n        if (fun->shared()->HasAsmWasmData()) {\n          FATAL(\"asm.js functions are not supported in snapshots\");\n        }\n        if (fun->shared()->HasWasmExportedFunctionData()) {\n          FATAL(\n              \"Exported WebAssembly functions are not supported in snapshots\");\n        }\n      }\n    }\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Snapshot::SerializeDeserializeAndVerifyForTesting\",\n            \"about\": \"Creates a snapshot, deserializes it, and verifies the deserialized state, used for testing.\",\n            \"logic\": \"Serializes the given context, creates a new isolate and deserializes the snapshot in it. Then, it creates another context in the new isolate and verifies the heap.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to use for serialization.\"\n                },\n                {\n                    \"name\": \"default_context\",\n                    \"type\": \"DirectHandle<Context>\",\n                    \"purpose\": \"The context to serialize.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Snapshot::Create\",\n                \"Snapshot::Initialize\",\n                \"Isolate::New\",\n                \"Isolate::Delete\",\n                \"HeapVerifier::VerifyHeap\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid Snapshot::SerializeDeserializeAndVerifyForTesting(\n    Isolate* isolate, DirectHandle<Context> default_context) {\n  StartupData serialized_data;\n  std::unique_ptr<const char[]> auto_delete_serialized_data;\n\n  isolate->heap()->CollectAllAvailableGarbage(\n      i::GarbageCollectionReason::kSnapshotCreator);\n\n  // Test serialization.\n  {\n    SafepointKind safepoint_kind = isolate->has_shared_space()\n                                       ? SafepointKind::kGlobal\n                                       : SafepointKind::kIsolate;\n    SafepointScope safepoint_scope(isolate, safepoint_kind);\n    DisallowGarbageCollection no_gc;\n\n    Snapshot::SerializerFlags flags(\n        Snapshot::kAllowUnknownExternalReferencesForTesting |\n        Snapshot::kAllowActiveIsolateForTesting |\n        Snapshot::kReconstructReadOnlyAndSharedObjectCachesForTesting);\n    std::vector<Tagged<Context>> contexts{*default_context};\n    std::vector<SerializeEmbedderFieldsCallback> callbacks{\n        SerializeEmbedderFieldsCallback()};\n    serialized_data = Snapshot::Create(isolate, &contexts, callbacks,\n                                       safepoint_scope, no_gc, flags);\n    auto_delete_serialized_data.reset(serialized_data.data);\n  }\n\n  // The shared heap is verified on Heap teardown, which performs a global\n  // safepoint. Both isolate and new_isolate are running in the same thread, so\n  // park isolate before running new_isolate to avoid deadlock.\n  isolate->main_thread_local_isolate()->ExecuteMainThreadWhileParked(\n      [&serialized_data]() {\n        // Test deserialization.\n        Isolate* new_isolate = Isolate::New();\n        std::unique_ptr<v8::ArrayBuffer::Allocator> array_buffer_allocator(\n            v8::ArrayBuffer::Allocator::NewDefaultAllocator());\n        {\n          // Set serializer_enabled() to not install extensions and experimental\n          // natives on the new isolate.\n          // TODO(v8:10416): This should be a separate setting on the isolate.\n          new_isolate->enable_serializer();\n          new_isolate->Enter();\n          new_isolate->set_snapshot_blob(&serialized_data);\n          new_isolate->set_array_buffer_allocator(array_buffer_allocator.get());\n          CHECK(Snapshot::Initialize(new_isolate));\n\n          HandleScope scope(new_isolate);\n          DirectHandle<Context> new_native_context =\n              new_isolate->bootstrapper()->CreateEnvironmentForTesting();\n          CHECK(IsNativeContext(*new_native_context));\n\n#ifdef VERIFY_HEAP\n          if (v8_flags.verify_heap)\n            HeapVerifier::VerifyHeap(new_isolate->heap());\n#endif  // VERIFY_HEAP\n        }\n        new_isolate->Exit();\n        Isolate::Delete(new_isolate);\n      });\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Snapshot::Create\",\n            \"about\": \"Creates a snapshot blob from the current isolate state.\",\n            \"logic\": \"Serializes the read-only heap, the startup isolate data, and the given contexts. Combines the serialized data into a single snapshot blob.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to create a snapshot from.\"\n                },\n                {\n                    \"name\": \"contexts\",\n                    \"type\": \"std::vector<Tagged<Context>>*\",\n                    \"purpose\": \"The contexts to serialize.\"\n                },\n                {\n                    \"name\": \"embedder_fields_serializers\",\n                    \"type\": \"const std::vector<SerializeEmbedderFieldsCallback>&\",\n                    \"purpose\": \"Callbacks to serialize embedder fields of the contexts.\"\n                },\n                {\n                    \"name\": \"safepoint_scope\",\n                    \"type\": \"const SafepointScope&\",\n                    \"purpose\": \"The safepoint scope to use.\"\n                },\n                {\n                    \"name\": \"no_gc\",\n                    \"type\": \"const DisallowGarbageCollection&\",\n                    \"purpose\": \"Object to disallow garbage collection.\"\n                },\n                {\n                    \"name\": \"flags\",\n                    \"type\": \"SerializerFlags\",\n                    \"purpose\": \"Serialization flags.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"v8::StartupData\",\n                \"description\": \"The created snapshot data blob.\"\n            },\n            \"dependencies\": [\n                \"ReadOnlySerializer\",\n                \"SharedHeapSerializer\",\n                \"StartupSerializer\",\n                \"ContextSerializer\",\n                \"SnapshotImpl::CreateSnapshotBlob\",\n                \"Snapshot::VerifyChecksum\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nv8::StartupData Snapshot::Create(\n    Isolate* isolate, std::vector<Tagged<Context>>* contexts,\n    const std::vector<SerializeEmbedderFieldsCallback>&\n        embedder_fields_serializers,\n    const SafepointScope& safepoint_scope,\n    const DisallowGarbageCollection& no_gc, SerializerFlags flags) {\n  TRACE_EVENT0(\"v8\", \"V8.SnapshotCreate\");\n  DCHECK_EQ(contexts->size(), embedder_fields_serializers.size());\n  DCHECK_GT(contexts->size(), 0);\n  HandleScope scope(isolate);\n\n  ReadOnlySerializer read_only_serializer(isolate, flags);\n  read_only_serializer.Serialize();\n\n  // TODO(v8:6593): generalize rehashing, and remove this flag.\n  bool can_be_rehashed = read_only_serializer.can_be_rehashed();\n\n  SharedHeapSerializer shared_heap_serializer(isolate, flags);\n  StartupSerializer startup_serializer(isolate, flags, &shared_heap_serializer);\n  startup_serializer.SerializeStrongReferences(no_gc);\n\n  // Serialize each context with a new serializer.\n  const int num_contexts = static_cast<int>(contexts->size());\n  std::vector<SnapshotData*> context_snapshots;\n  context_snapshots.reserve(num_contexts);\n\n  std::vector<int> context_allocation_sizes;\n  for (int i = 0; i < num_contexts; i++) {\n    ContextSerializer context_serializer(isolate, flags, &startup_serializer,\n                                         embedder_fields_serializers[i]);\n    context_serializer.Serialize(&contexts->at(i), no_gc);\n    can_be_rehashed = can_be_rehashed && context_serializer.can_be_rehashed();\n    context_snapshots.push_back(new SnapshotData(&context_serializer));\n    if (v8_flags.serialization_statistics) {\n      context_allocation_sizes.push_back(\n          context_serializer.TotalAllocationSize());\n    }\n  }\n\n  startup_serializer.SerializeWeakReferencesAndDeferred();\n  can_be_rehashed = can_be_rehashed"
}