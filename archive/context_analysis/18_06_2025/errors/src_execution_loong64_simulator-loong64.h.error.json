{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/loong64/simulator-loong64.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/loong64/simulator-loong64.h\",\n        \"file_name\": \"simulator-loong64.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the LOONG64 instruction simulator for running and debugging LOONG64 code on non-LOONG64 platforms.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Compare\",\n            \"about\": \"Compares two values of the same type and returns -1, 0, or 1 based on their relative order.\",\n            \"logic\": \"Uses standard comparison operators to determine the order.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The first value to compare.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The second value to compare.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"-1 if a < b, 0 if a == b, 1 if a > b\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            int Compare(const T& a, const T& b) {\n              if (a == b)\n                return 0;\n              else if (a < b)\n                return -1;\n              else\n                return 1;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Nabs\",\n            \"about\": \"Returns the negative absolute value of its argument.\",\n            \"logic\": \"If the argument is negative, it returns the argument; otherwise, it returns the negation of the argument.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The value for which to calculate the negative absolute value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T\",\n                \"description\": \"The negative absolute value of the input.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T,\n                      typename = typename std::enable_if<std::is_signed<T>::value>::type>\n            T Nabs(T a) {\n              return a < 0 ? a : -a;\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CachePage\",\n            \"about\": \"Represents a page in the instruction cache for the simulator.\",\n            \"attributes\": [\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"char[kPageSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The cached data for the page.\"\n                },\n                {\n                    \"name\": \"validity_map_\",\n                    \"type\": \"char[kValidityMapSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A map indicating the validity of each cache line in the page.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class CachePage {\n             public:\n              static const int LINE_VALID = 0;\n              static const int LINE_INVALID = 1;\n\n              static const int kPageShift = 12;\n              static const int kPageSize = 1 << kPageShift;\n              static const int kPageMask = kPageSize - 1;\n              static const int kLineShift = 2;  // The cache line is only 4 bytes right now.\n              static const int kLineLength = 1 << kLineShift;\n              static const int kLineMask = kLineLength - 1;\n\n              CachePage() { memset(&validity_map_, LINE_INVALID, sizeof(validity_map_)); }\n\n              char* ValidityByte(int offset) {\n                return &validity_map_[offset >> kLineShift];\n              }\n\n              char* CachedData(int offset) { return &data_[offset]; }\n\n             private:\n              char data_[kPageSize];  // The cached data.\n              static const int kValidityMapSize = kPageSize >> kLineShift;\n              char validity_map_[kValidityMapSize];  // One byte per line.\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimInstructionBase\",\n            \"extends\": \"InstructionBase\",\n            \"about\": \"Base class for simulated LOONG64 instructions.\",\n            \"attributes\": [\n                {\n                    \"name\": \"operand_\",\n                    \"type\": \"int32_t\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Stores the operand of the instruction.\"\n                },\n                {\n                    \"name\": \"instr_\",\n                    \"type\": \"Instruction*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Pointer to the actual instruction.\"\n                },\n                {\n                    \"name\": \"type_\",\n                    \"type\": \"Type\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The type of the instruction.\"\n                }\n            ],\n            \"dependencies\": [\n                \"InstructionBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SimInstructionBase : public InstructionBase {\n             public:\n              Type InstructionType() const { return type_; }\n              inline Instruction* instr() const { return instr_; }\n              inline int32_t operand() const { return operand_; }\n\n             protected:\n              SimInstructionBase() : operand_(-1), instr_(nullptr), type_(kUnsupported) {}\n              explicit SimInstructionBase(Instruction* instr) {}\n\n              int32_t operand_;\n              Instruction* instr_;\n              Type type_;\n\n             private:\n              DISALLOW_ASSIGN(SimInstructionBase);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimInstruction\",\n            \"extends\": \"InstructionGetters<SimInstructionBase>\",\n            \"about\": \"Represents a simulated LOONG64 instruction, inheriting from InstructionGetters and SimInstructionBase.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"InstructionGetters\",\n                \"SimInstructionBase\",\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SimInstruction : public InstructionGetters<SimInstructionBase> {\n             public:\n              SimInstruction() {}\n\n              explicit SimInstruction(Instruction* instr) { *this = instr; }\n\n              SimInstruction& operator=(Instruction* instr) {\n                operand_ = *reinterpret_cast<const int32_t*>(instr);\n                instr_ = instr;\n                type_ = InstructionBase::InstructionType();\n                DCHECK(reinterpret_cast<void*>(&operand_) == this);\n                return *this;\n              }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Simulator\",\n            \"extends\": \"SimulatorBase\",\n            \"about\": \"The LOONG64 instruction simulator.\",\n            \"attributes\": [\n                {\n                    \"name\": \"registers_\",\n                    \"type\": \"int64_t[kNumSimuRegisters]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of general-purpose registers.\"\n                },\n                {\n                    \"name\": \"FPUregisters_\",\n                    \"type\": \"int64_t[kNumFPURegisters]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of floating-point registers.\"\n                },\n                {\n                    \"name\": \"CFregisters_\",\n                    \"type\": \"bool[kNumCFRegisters]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of condition flag registers.\"\n                },\n                {\n                    \"name\": \"FCSR_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"FPU control and status register.\"\n                },\n                {\n                    \"name\": \"stack_\",\n                    \"type\": \"uintptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The base address of the simulator stack.\"\n                },\n                {\n                    \"name\": \"stack_limit_\",\n                    \"type\": \"uintptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The limit of the simulator stack.\"\n                },\n                {\n                    \"name\": \"pc_modified_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether the program counter has been modified.\"\n                },\n                {\n                    \"name\": \"icount_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Instruction count.\"\n                },\n                {\n                    \"name\": \"break_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Breakpoint count.\"\n                },\n                {\n                    \"name\": \"trace_buf_\",\n                    \"type\": \"base::EmbeddedVector<char, 128>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Trace buffer for debugging.\"\n                },\n                {\n                    \"name\": \"last_debugger_input_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The last debugger input.\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"v8::internal::Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"break_pc_\",\n                    \"type\": \"Instruction*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The program counter at the breakpoint.\"\n                },\n                {\n                    \"name\": \"break_instr_\",\n                    \"type\": \"Instr\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The instruction at the breakpoint.\"\n                },\n                {\n                    \"name\": \"watched_stops_\",\n                    \"type\": \"StopCountAndDesc[kMaxStopCode + 1]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Watched stop information.\"\n                },\n                {\n                    \"name\": \"local_monitor_\",\n                    \"type\": \"LocalMonitor\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Local monitor for exclusive loads/stores.\"\n                },\n                {\n                    \"name\": \"global_monitor_thread_\",\n                    \"type\": \"GlobalMonitor::LinkedAddress\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Global monitor thread for exclusive loads/stores.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SimulatorBase\",\n                \"Isolate\",\n                \"CallArgument\",\n                \"LocalMonitor\",\n                \"GlobalMonitor\",\n                \"Instruction\",\n                \"FPURoundingMode\",\n                \"EncodedCSignature\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Simulator : public SimulatorBase {\n             public:\n              friend class Loong64Debugger;\n\n              // Registers are declared in order.\n              enum Register {\n                no_reg = -1,\n                zero_reg = 0,\n                ra,\n                gp,\n                sp,\n                a0,\n                a1,\n                a2,\n                a3,\n                a4,\n                a5,\n                a6,\n                a7,\n                t0,\n                t1,\n                t2,\n                t3,\n                t4,\n                t5,\n                t6,\n                t7,\n                t8,\n                tp,\n                fp,\n                s0,\n                s1,\n                s2,\n                s3,\n                s4,\n                s5,\n                s6,\n                s7,\n                s8,\n                pc,  // pc must be the last register.\n                kNumSimuRegisters,\n                // aliases\n                v0 = a0,\n                v1 = a1\n              };\n\n              // Condition flag registers.\n              enum CFRegister {\n                fcc0,\n                fcc1,\n                fcc2,\n                fcc3,\n                fcc4,\n                fcc5,\n                fcc6,\n                fcc7,\n                kNumCFRegisters\n              };\n\n              // Floating point registers.\n              enum FPURegister {\n                f0,\n                f1,\n                f2,\n                f3,\n                f4,\n                f5,\n                f6,\n                f7,\n                f8,\n                f9,\n                f10,\n                f11,\n                f12,\n                f13,\n                f14,\n                f15,\n                f16,\n                f17,\n                f18,\n                f19,\n                f20,\n                f21,\n                f22,\n                f23,\n                f24,\n                f25,\n                f26,\n                f27,\n                f28,\n                f29,\n                f30,\n                f31,\n                kNumFPURegisters\n              };\n\n              explicit Simulator(Isolate* isolate);\n              ~Simulator();\n\n              // The currently executing Simulator instance. Potentially there can be one\n              // for each native thread.\n              V8_EXPORT_PRIVATE static Simulator* current(v8::internal::Isolate* isolate);\n\n              float ceil(float value);\n              float floor(float value);\n              float trunc(float value);\n              double ceil(double value);\n              double floor(double value);\n              double trunc(double value);\n\n              // Accessors for register state. Reading the pc value adheres to the LOONG64\n              // architecture specification and is off by a 8 from the currently executing\n              // instruction.\n              void set_register(int reg, int64_t value);\n              void set_register_word(int reg, int32_t value);\n              void set_dw_register(int dreg, const int* dbl);\n              V8_EXPORT_PRIVATE int64_t get_register(int reg) const;\n              double get_double_from_register_pair(int reg);\n              // Same for FPURegisters.\n              void set_fpu_register(int fpureg, int64_t value);\n              void set_fpu_register_word(int fpureg, int32_t value);\n              void set_fpu_register_hi_word(int fpureg, int32_t value);\n              void set_fpu_register_float(int fpureg, float value);\n              void set_fpu_register_double(int fpureg, double value);\n              void set_fpu_register_invalid_result64(float original, float rounded);\n              void set_fpu_register_invalid_result(float original, float rounded);\n              void set_fpu_register_word_invalid_result(float original, float rounded);\n              void set_fpu_register_invalid_result64(double original, double rounded);\n              void set_fpu_register_invalid_result(double original, double rounded);\n              void set_fpu_register_word_invalid_result(double original, double rounded);\n              int64_t get_fpu_register(int fpureg) const;\n              int32_t get_fpu_register_word(int fpureg) const;\n              int32_t get_fpu_register_signed_word(int fpureg) const;\n              int32_t get_fpu_register_hi_word(int fpureg) const;\n              float get_fpu_register_float(int fpureg) const;\n              double get_fpu_register_double(int fpureg) const;\n              void set_cf_register(int cfreg, bool value);\n              bool get_cf_register(int cfreg) const;\n              void set_fcsr_rounding_mode(FPURoundingMode mode);\n              unsigned int get_fcsr_rounding_mode();\n              void set_fcsr_bit(uint32_t cc, bool value);\n              bool test_fcsr_bit(uint32_t cc);\n              bool set_fcsr_round_error(double original, double rounded);\n              bool set_fcsr_round64_error(double original, double rounded);\n              bool set_fcsr_round_error(float original, float rounded);\n              bool set_fcsr_round64_error(float original, float rounded);\n              void round_according_to_fcsr(double toRound, double* rounded,\n                                           int32_t* rounded_int);\n              void round64_according_to_fcsr(double toRound, double* rounded,\n                                             int64_t* rounded_int);\n              void round_according_to_fcsr(float toRound, float* rounded,\n                                           int32_t* rounded_int);\n              void round64_according_to_fcsr(float toRound, float* rounded,\n                                             int64_t* rounded_int);\n              // Special case of set_register and get_register to access the raw PC value.\n              void set_pc(int64_t value);\n              V8_EXPORT_PRIVATE int64_t get_pc() const;\n\n              Address get_sp() const { return static_cast<Address>(get_register(sp)); }\n\n              // Accessor to the internal simulator stack area. Adds a safety\n              // margin to prevent overflows (kAdditionalStackMargin).\n              uintptr_t StackLimit(uintptr_t c_limit) const;\n\n              // Return central stack view, without additional safety margins.\n              // Users, for example wasm::StackMemory, can add their own.\n              base::Vector<uint8_t> GetCentralStackView() const;\n\n              // Executes LOONG64 instructions until the PC reaches end_sim_pc.\n              void Execute();\n\n              // Only arguments up to 64 bits in size are supported.\n              class CallArgument {\n               public:\n                template <typename T>\n                explicit CallArgument(T argument) {\n                  bits_ = 0;\n                  DCHECK(sizeof(argument) <= sizeof(bits_));\n                  bits_ = ConvertArg(argument);\n                  type_ = GP_ARG;\n                }\n\n                explicit CallArgument(double argument) {\n                  DCHECK(sizeof(argument) == sizeof(bits_));\n                  memcpy(&bits_, &argument, sizeof(argument));\n                  type_ = FP_ARG;\n                }\n\n                explicit CallArgument(float argument) {\n                  // TODO(all): CallArgument(float) is untested.\n                  UNIMPLEMENTED();\n                }\n\n                // This indicates the end of the arguments list, so that CallArgument\n                // objects can be passed into varargs functions.\n                static CallArgument End() { return CallArgument(); }\n\n                int64_t bits() const { return bits_; }\n                bool IsEnd() const { return type_ == NO_ARG; }\n                bool IsGP() const { return type_ == GP_ARG; }\n                bool IsFP() const { return type_ == FP_ARG; }\n\n               private:\n                enum CallArgumentType { GP_ARG, FP_ARG, NO_ARG };\n\n                // All arguments are aligned to at least 64 bits and we don't support\n                // passing bigger arguments, so the payload size can be fixed at 64 bits.\n                int64_t bits_;\n                CallArgumentType type_;\n\n                CallArgument() { type_ = NO_ARG; }\n              };\n\n              template <typename Return, typename... Args>\n              Return Call(Address entry, Args... args) {\n                // Convert all arguments to CallArgument.\n                CallArgument call_args[] = {CallArgument(args)..., CallArgument::End()};\n                CallImpl(entry, call_args);\n                return ReadReturn<Return>();\n              }\n\n              // Alternative: call a 2-argument double function.\n              double CallFP(Address entry, double d0, double d1);\n\n              // Push an address onto the JS stack.\n              V8_EXPORT_PRIVATE uintptr_t PushAddress(uintptr_t address);\n\n              // Pop an address from the JS stack.\n              V8_EXPORT_PRIVATE uintptr_t PopAddress();\n\n              // Debugger input.\n              void set_last_debugger_input(char* input);\n              char* last_debugger_input() { return last_debugger_input_; }\n\n              // Redirection support.\n              static void SetRedirectInstruction(Instruction* instruction);\n\n              // ICache checking.\n              static bool ICacheMatch(void* one, void* two);\n              static void FlushICache(base::CustomMatcherHashMap* i_cache, void* start,\n                                      size_t size);\n\n              // Returns true if pc register contains one of the 'special_values' defined\n              // below (bad_ra, end_sim_pc).\n              bool has_bad_pc() const;\n\n             private:\n              enum special_values {\n                // Known bad pc value to ensure that the simulator does not execute\n                // without being properly setup.\n                bad_ra = -1,\n                // A pc value used to signal the simulator to stop execution.  Generally\n                // the ra is set to this value on transition from native C code to\n                // simulated execution, so that the simulator can \"return\" to the native\n                // C code.\n                end_sim_pc = -2,\n                // Unpredictable value.\n                Unpredictable = 0xbadbeaf\n              };\n\n              V8_EXPORT_PRIVATE void CallImpl(Address entry, CallArgument* args);\n\n              void CallAnyCTypeFunction(Address target_address,\n                                        const EncodedCSignature& signature);\n\n              // Read floating point return values.\n              template <typename T>\n              typename std::enable_if<std::is_floating_point<T>::value, T>::type\n              ReadReturn() {\n                return static_cast<T>(get_fpu_register_double(f0));\n              }\n              // Read non-float return values.\n              template <typename T>\n              typename std::enable_if<!std::is_floating_point<T>::value, T>::type\n              ReadReturn() {\n                return ConvertReturn<T>(get_register(a0));\n              }\n\n              // Unsupported instructions use Format to print an error and stop execution.\n              void Format(Instruction* instr, const char* format);\n\n              // Helpers for data value tracing.\n              enum TraceType {\n                BYTE,\n                HALF,\n                WORD,\n                DWORD,\n                FLOAT,\n                DOUBLE,\n                FLOAT_DOUBLE,\n                WORD_DWORD\n              };\n\n              // \"Probe\" if an address range can be read. This is currently implemented\n              // by doing a 1-byte read of the last accessed byte, since the assumption is\n              // that if the last byte is accessible, also all lower bytes are accessible\n              // (which holds true for Wasm).\n              // Returns true if the access was successful, false if the access raised a\n              // signal which was then handled by the trap handler (also see\n              // {trap_handler::ProbeMemory}). If the access raises a signal which is not\n              // handled by the trap handler (e.g. because the current PC is not registered\n              // as a protected instruction), the signal will propagate and make the process\n              // crash. If no trap handler is available, this always returns true.\n              bool ProbeMemory(uintptr_t address, uintptr_t access_size);\n\n              // Read and write memory.\n              inline uint32_t ReadBU(int64_t addr);\n              inline int32_t ReadB(int64_t addr);\n              inline void WriteB(int64_t addr, uint8_t value);\n              inline void WriteB(int64_t addr, int8_t value);\n\n              inline uint16_t ReadHU(int64_t addr, Instruction* instr);\n              inline int16_t ReadH(int64_t addr, Instruction* instr);\n              // Note: Overloaded on the sign of the value.\n              inline void WriteH(int64_t addr, uint16_t value, Instruction* instr);\n              inline void WriteH(int64_t addr, int16_t value, Instruction* instr);\n\n              inline uint32_t ReadWU(int64_t addr, Instruction* instr);\n              inline int32_t ReadW(int64_t addr, Instruction* instr, TraceType t = WORD);\n              inline void WriteW(int64_t addr, int32_t value, Instruction* instr);\n              void WriteConditionalW(int64_t addr, int32_t value, Instruction* instr,\n                                     int32_t* done);\n              inline int64_t Read2W(int64_t addr, Instruction* instr);\n              inline void Write2W(int64_t addr, int64_t value, Instruction* instr);\n              inline void WriteConditional2W(int64_t addr, int64_t value,\n                                             Instruction* instr, int32_t* done);\n\n              inline double ReadD(int64_t addr, Instruction* instr);\n              inline void WriteD(int64_t addr, double value, Instruction* instr);\n\n              template <typename T>\n              T ReadMem(int64_t addr, Instruction* instr);\n              template <typename T>\n              void WriteMem(int64_t addr, T value, Instruction* instr);\n\n              // Helper for debugging memory access.\n              inline void DieOrDebug();\n\n              void TraceRegWr(int64_t value, TraceType t = DWORD);\n              void TraceMemWr(int64_t addr, int64_t value, TraceType t);\n              void TraceMemRd(int64_t addr, int64_t value, TraceType t = DWORD);\n              template <typename T>\n              void TraceMemRd(int64_t addr, T value);\n              template <typename T>\n              void TraceMemWr(int64_t addr, T value);\n\n              SimInstruction instr_;\n\n              // Executing is handled based on the instruction type.\n              void DecodeTypeOp6();\n              void DecodeTypeOp7();\n              void DecodeTypeOp8();\n              void DecodeTypeOp10();\n              void DecodeTypeOp12();\n              void DecodeTypeOp14();\n              void DecodeTypeOp17();\n              void DecodeTypeOp22();\n\n              inline int32_t rj_reg() const { return instr_.RjValue(); }\n              inline int64_t rj() const { return get_register(rj_reg()); }\n              inline uint64_t rj_u() const {\n                return static_cast<uint64_t>(get_register(rj_reg()));\n              }\n              inline int32_t rk_reg() const { return instr_.RkValue(); }\n              inline int64_t rk() const { return get_register(rk_reg()); }\n              inline uint64_t rk_u() const {\n                return static_cast<uint64_t>(get_register(rk_reg()));\n              }\n              inline int32_t rd_reg() const { return instr_.RdValue(); }\n              inline int64_t rd() const { return get_register(rd_reg()); }\n              inline uint64_t rd_u() const {\n                return static_cast<uint64_t>(get_register(rd_reg()));\n              }\n              inline int32_t fa_reg() const { return instr_.FaValue(); }\n              inline float fa_float() const { return get_fpu_register_float(fa_reg()); }\n              inline double fa_double() const { return get_fpu_register_double(fa_reg()); }\n              inline int32_t fj_reg() const { return instr_.FjValue(); }\n              inline float fj_float() const { return get_fpu_register_float(fj_reg()); }\n              inline double fj_double() const { return get_fpu_register_double(fj_reg()); }\n              inline int32_t fk_reg() const { return instr_.FkValue(); }\n              inline float fk_float() const { return get_fpu_register_float(fk_reg()); }\n              inline double fk_double() const { return get_fpu_register_double(fk_reg()); }\n              inline int32_t fd_reg() const { return instr_.FdValue(); }\n              inline float fd_float() const { return get_fpu_register_float(fd_reg()); }\n              inline double fd_double() const { return get_fpu_register_double(fd_reg()); }\n              inline int32_t cj_reg() const { return instr_.CjValue(); }\n              inline bool cj() const { return get_cf_register(cj_reg()); }\n              inline int32_t cd_reg() const { return instr_.CdValue(); }\n              inline bool cd() const { return get_cf_register(cd_reg()); }\n              inline int32_t ca_reg() const { return instr_.CaValue(); }\n              inline bool ca() const { return get_cf_register(ca_reg()); }\n              inline uint32_t sa2() const { return instr_.Sa2Value(); }\n              inline uint32_t sa3() const { return instr_.Sa3Value(); }\n              inline uint32_t ui5() const { return instr_.Ui5Value(); }\n              inline uint32_t ui6() const { return instr_.Ui6Value(); }\n              inline uint32_t lsbw() const { return instr_.LsbwValue(); }\n              inline uint32_t msbw() const { return instr_.MsbwValue(); }\n              inline uint32_t lsbd() const { return instr_.LsbdValue(); }\n              inline uint32_t msbd() const { return instr_.MsbdValue(); }\n              inline uint32_t cond() const { return instr_.CondValue(); }\n              inline int32_t si12() const { return (instr_.Si12Value() << 20) >> 20; }\n              inline uint32_t ui12() const { return instr_.Ui12Value(); }\n              inline int32_t si14() const { return (instr_.Si14Value() << 18) >> 18; }\n              inline int32_t si16() const { return (instr_.Si16Value() << 16) >> 16; }\n              inline int32_t si20() const { return (instr_.Si20Value() << 12) >> 12; }\n\n              inline void SetResult(const int32_t rd_reg, const int64_t alu_out) {\n                set_register(rd_reg, alu_out);\n                TraceRegWr(alu_out);\n              }\n\n              inline void SetFPUWordResult(int32_t fd_reg, int32_t alu_out) {\n                set_fpu_register_word(fd_reg, alu_out);\n                TraceRegWr(get_fpu_register(fd_reg), WORD);\n              }\n\n              inline void SetFPUWordResult2(int32_t fd_reg, int32_t alu_out) {\n                set_fpu_register_word(fd_reg, alu_out);\n                TraceRegWr(get_fpu_register(fd_reg));\n              }\n\n              inline void SetFPUResult(int32_t fd_reg, int64_t alu_out) {\n                set_fpu_register(fd_reg, alu_out);\n                TraceRegWr(get_fpu_register(fd_reg));\n              }\n\n              inline void SetFPUResult2(int32_t fd_reg, int64_t alu_out) {\n                set_fpu_register(fd_reg, alu_out);\n                TraceRegWr(get_fpu_register(fd_reg), DOUBLE);\n              }\n\n              inline void SetFPUFloatResult(int32_t fd_reg, float alu_out) {\n                set_fpu_register_float(fd_reg, alu_out);\n                TraceRegWr(get_fpu_register(fd_reg), FLOAT);\n              }\n\n              inline void SetFPUDoubleResult(int32_t fd_reg, double alu_out) {\n                set_fpu_register_double(fd_reg, alu_out);\n                TraceRegWr(get_fpu_register(fd_reg), DOUBLE);\n              }\n\n              // Used for breakpoints.\n              void SoftwareInterrupt();\n\n              // Stop helper functions.\n              bool IsWatchpoint(uint64_t code);\n              void PrintWatchpoint(uint64_t code);\n              void HandleStop(uint64_t code, Instruction* instr);\n              bool IsStopInstruction(Instruction* instr);\n              bool IsEnabledStop(uint64_t code);\n              void EnableStop(uint64_t code);\n              void DisableStop(uint64_t code);\n              void IncreaseStopCounter(uint64_t code);\n              void PrintStopInfo(uint64_t code);\n\n              // Executes one instruction.\n              void InstructionDecode(Instruction* instr);\n              // Execute one instruction placed in a branch delay slot.\n\n              // ICache.\n              static void CheckICache(base::CustomMatcherHashMap* i_cache,\n                                    Instruction* instr);\n              static void FlushOnePage(base::CustomMatcherHashMap* i_cache, intptr_t start,\n                                     size_t size);\n              static CachePage* GetCachePage(base::CustomMatcherHashMap* i_cache,\n                                           "
}