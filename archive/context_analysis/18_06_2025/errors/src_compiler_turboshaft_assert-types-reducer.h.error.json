{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/assert-types-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 42, column 68",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/assert-types-reducer.h\",\n            \"file_name\": \"assert-types-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the AssertTypesReducer class, which inserts runtime type assertions into the Turboshaft graph to verify type assumptions made during compilation.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for logging, templates, vectors, compiler operations, frames, assemblers, Turboshaft operations and phases, representations, side tables, type inference, types, uniform reducer adapters, and heap management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <limits>\n\n#include \"src/base/logging.h\"\n#include \"src/base/template-utils.h\"\n#include \"src/base/vector.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/frame.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/compiler/turboshaft/sidetable.h\"\n#include \"src/compiler/turboshaft/type-inference-reducer.h\"\n#include \"src/compiler/turboshaft/types.h\"\n#include \"src/compiler/turboshaft/uniform-reducer-adapter.h\"\n#include \"src/heap/parked-scope.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AssertTypesReducer\",\n                \"extends\": \"UniformReducerAdapter<AssertTypesReducer, Next>\",\n                \"about\": \"A reducer that inserts type assertions into the Turboshaft graph to validate type assumptions at runtime.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Isolate object, providing access to V8's runtime environment.\"\n                    },\n                    {\n                        \"name\": \"type_assertions_allowed_\",\n                        \"type\": \"const bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether type assertions are allowed in the current context. Disabled when fast API calls that can throw have been lowered, to avoid violating exception handling constraints.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"UniformReducerAdapter\",\n                    \"Next\",\n                    \"TypeInferenceReducer\",\n                    \"Smi\",\n                    \"Context\",\n                    \"OpIndex\",\n                    \"Op\",\n                    \"LoadRootRegisterOp\",\n                    \"ConstantOp\",\n                    \"Type\",\n                    \"RegisterRepresentation\",\n                    \"Builtin\",\n                    \"Handle\",\n                    \"TurboshaftType\",\n                    \"Factory\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass AssertTypesReducer\n    : public UniformReducerAdapter<AssertTypesReducer, Next> {\n#if defined(__clang__)\n  static_assert(next_contains_reducer<Next, TypeInferenceReducer>::value);\n#endif\n\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(AssertTypes)\n\n  using Adapter = UniformReducerAdapter<AssertTypesReducer, Next>;\n\n  i::Tagged<Smi> NoContextConstant() {\n    return Smi::FromInt(Context::kNoContext);\n  }\n\n  template <typename Op, typename Continuation>\n  OpIndex ReduceInputGraphOperation(OpIndex ig_index, const Op& operation) {\n    OpIndex og_index = Continuation{this}.ReduceInputGraph(ig_index, operation);\n    if constexpr (std::is_same_v<Op, LoadRootRegisterOp>) {\n      // LoadRootRegister is a bit special and should never be materialized,\n      // hence we cannot assert its type.\n      return og_index;\n    }\n    if (std::is_same_v<Op, ConstantOp>) {\n      // Constants are constant by definition, so asserting their types doesn't\n      // seem super useful. Additionally, they can appear before Parameters in\n      // the graph, which leads to issues because asserting their types requires\n      // inserting a Call in the graph, which can overwrite the value of\n      // Parameters.\n      return og_index;\n    }\n    if (!og_index.valid()) return og_index;\n    if (!CanBeTyped(operation)) return og_index;\n    // Unfortunately, we cannot insert assertions after block terminators, so we\n    // skip them here.\n    if (operation.IsBlockTerminator()) return og_index;\n\n    auto reps = operation.outputs_rep();\n    DCHECK_GT(reps.size(), 0);\n    if (reps.size() == 1) {\n      Type type = __ GetInputGraphType(ig_index);\n      InsertTypeAssert(reps[0], og_index, type);\n    }\n    return og_index;\n  }\n\n  void InsertTypeAssert(RegisterRepresentation rep, OpIndex value,\n                        const Type& type) {\n    if (!type_assertions_allowed_) return;\n\n    DCHECK(!type.IsInvalid());\n    if (type.IsNone()) {\n      __ Unreachable();\n      return;\n    }\n\n    if (type.IsAny()) {\n      // Ignore any typed for now.\n      return;\n    }\n\n    auto GenerateBuiltinCall =\n        [this](Builtin builtin, OpIndex original_value,\n               base::SmallVector<OpIndex, 6> actual_value_indices,\n               const Type& type) {\n          i::Tagged<Smi> op_id = Smi::FromInt(original_value.id());\n          // Add expected type and operation id.\n          Handle<TurboshaftType> expected_type = type.AllocateOnHeap(factory());\n          actual_value_indices.push_back(__ HeapConstant(expected_type));\n          actual_value_indices.push_back(__ SmiConstant(op_id));\n          actual_value_indices.push_back(__ SmiConstant(NoContextConstant()));\n          __ CallBuiltin(\n              builtin, OpIndex::Invalid(),\n              {actual_value_indices.data(), actual_value_indices.size()},\n              CanThrow::kNo, isolate_);\n#ifdef DEBUG\n          // Used for debugging\n          if (v8_flags.turboshaft_trace_typing) {\n            PrintF(\"Inserted assert for %3d:%-40s (%s)\\n\", original_value.id(),\n                   __ output_graph().Get(original_value).ToString().c_str(),\n                   type.ToString().c_str());\n          }\n#endif\n        };\n\n    switch (rep.value()) {\n      case RegisterRepresentation::Word32(): {\n        DCHECK(type.IsWord32());\n        base::SmallVector<OpIndex, 6> actual_value_indices = {value};\n        GenerateBuiltinCall(Builtin::kCheckTurboshaftWord32Type, value,\n                            std::move(actual_value_indices), type);\n        break;\n      }\n      case RegisterRepresentation::Word64(): {\n        DCHECK(type.IsWord64());\n        OpIndex value_high =\n            __ TruncateWord64ToWord32(__ Word64ShiftRightLogical(value, 32));\n        OpIndex value_low = __ TruncateWord64ToWord32(value);\n        base::SmallVector<OpIndex, 6> actual_value_indices = {value_high,\n                                                              value_low};\n        GenerateBuiltinCall(Builtin::kCheckTurboshaftWord64Type, value,\n                            std::move(actual_value_indices), type);\n        break;\n      }\n      case RegisterRepresentation::Float32(): {\n        DCHECK(type.IsFloat32());\n        base::SmallVector<OpIndex, 6> actual_value_indices = {value};\n        GenerateBuiltinCall(Builtin::kCheckTurboshaftFloat32Type, value,\n                            std::move(actual_value_indices), type);\n        break;\n      }\n      case RegisterRepresentation::Float64(): {\n        DCHECK(type.IsFloat64());\n        base::SmallVector<OpIndex, 6> actual_value_indices = {value};\n        GenerateBuiltinCall(Builtin::kCheckTurboshaftFloat64Type, value,\n                            std::move(actual_value_indices), type);\n        break;\n      }\n      case RegisterRepresentation::Tagged():\n      case RegisterRepresentation::Compressed():\n      case RegisterRepresentation::Simd128():\n      case RegisterRepresentation::Simd256():\n        // TODO(nicohartmann@): Handle remaining cases.\n        break;\n    }\n  }\n\n private:\n  Factory* factory() { return isolate_->factory(); }\n  Isolate* isolate_ = __ data() -> isolate();\n  // We cannot emit type assertions in graphs that have lowered fast api\n  // calls that can throw, because a call to the type assertion builtin could\n  // be emitted between the throwing call and the branch to the handler. This\n  // will violate checks that we are not crossing runtime boundaries while an\n  // exception is still pending.\n  const bool type_assertions_allowed_ =\n      !__ data() -> graph_has_lowered_fast_api_calls();\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"NoContextConstant\",\n                \"parent\": \"AssertTypesReducer\",\n                \"about\": \"Returns the Smi representation of Context::kNoContext.\",\n                \"logic\": \"Creates a Smi from the Context::kNoContext integer value, used as a constant.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"i::Tagged<Smi>\",\n                    \"description\": \"The Smi representation of Context::kNoContext.\"\n                },\n                \"dependencies\": [\n                    \"Smi\",\n                    \"Context\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  i::Tagged<Smi> NoContextConstant() {\n    return Smi::FromInt(Context::kNoContext);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceInputGraphOperation\",\n                \"parent\": \"AssertTypesReducer\",\n                \"about\": \"Reduces an input graph operation by potentially inserting a type assertion.\",\n                \"logic\": \"This function is the core of the reducer. It first reduces the operation using the continuation. Then, it checks if the operation's output can be typed, and if so, inserts a type assertion call.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ig_index\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The index of the input graph operation.\"\n                    },\n                    {\n                        \"name\": \"operation\",\n                        \"type\": \"const Op&\",\n                        \"purpose\": \"The operation to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The index of the reduced operation, which might be the original index or a new one if the operation was modified.\"\n                },\n                \"dependencies\": [\n                    \"OpIndex\",\n                    \"Op\",\n                    \"Continuation\",\n                    \"LoadRootRegisterOp\",\n                    \"ConstantOp\",\n                    \"CanBeTyped\",\n                    \"Type\",\n                    \"RegisterRepresentation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  template <typename Op, typename Continuation>\n  OpIndex ReduceInputGraphOperation(OpIndex ig_index, const Op& operation) {\n    OpIndex og_index = Continuation{this}.ReduceInputGraph(ig_index, operation);\n    if constexpr (std::is_same_v<Op, LoadRootRegisterOp>) {\n      // LoadRootRegister is a bit special and should never be materialized,\n      // hence we cannot assert its type.\n      return og_index;\n    }\n    if (std::is_same_v<Op, ConstantOp>) {\n      // Constants are constant by definition, so asserting their types doesn't\n      // seem super useful. Additionally, they can appear before Parameters in\n      // the graph, which leads to issues because asserting their types requires\n      // inserting a Call in the graph, which can overwrite the value of\n      // Parameters.\n      return og_index;\n    }\n    if (!og_index.valid()) return og_index;\n    if (!CanBeTyped(operation)) return og_index;\n    // Unfortunately, we cannot insert assertions after block terminators, so we\n    // skip them here.\n    if (operation.IsBlockTerminator()) return og_index;\n\n    auto reps = operation.outputs_rep();\n    DCHECK_GT(reps.size(), 0);\n    if (reps.size() == 1) {\n      Type type = __ GetInputGraphType(ig_index);\n      InsertTypeAssert(reps[0], og_index, type);\n    }\n    return og_index;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InsertTypeAssert\",\n                \"parent\": \"AssertTypesReducer\",\n                \"about\": \"Inserts a type assertion call into the graph for a given value and type.\",\n                \"logic\": \"This function generates a call to a builtin function that checks the type of the provided value at runtime. The specific builtin is selected based on the register representation of the value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"rep\",\n                        \"type\": \"RegisterRepresentation\",\n                        \"purpose\": \"The register representation of the value being asserted.\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The index of the value in the graph.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type&\",\n                        \"purpose\": \"The expected type of the value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RegisterRepresentation\",\n                    \"OpIndex\",\n                    \"Type\",\n                    \"Builtin\",\n                    \"Smi\",\n                    \"Handle\",\n                    \"TurboshaftType\",\n                    \"Factory\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void InsertTypeAssert(RegisterRepresentation rep, OpIndex value,\n                        const Type& type) {\n    if (!type_assertions_allowed_) return;\n\n    DCHECK(!type.IsInvalid());\n    if (type.IsNone()) {\n      __ Unreachable();\n      return;\n    }\n\n    if (type.IsAny()) {\n      // Ignore any typed for now.\n      return;\n    }\n\n    auto GenerateBuiltinCall =\n        [this](Builtin builtin, OpIndex original_value,\n               base::SmallVector<OpIndex, 6> actual_value_indices,\n               const Type& type) {\n          i::Tagged<Smi> op_id = Smi::FromInt(original_value.id());\n          // Add expected type and operation id.\n          Handle<TurboshaftType> expected_type = type.AllocateOnHeap(factory());\n          actual_value_indices.push_back(__ HeapConstant(expected_type));\n          actual_value_indices.push_back(__ SmiConstant(op_id));\n          actual_value_indices.push_back(__ SmiConstant(NoContextConstant()));\n          __ CallBuiltin(\n              builtin, OpIndex::Invalid(),\n              {actual_value_indices.data(), actual_value_indices.size()},\n              CanThrow::kNo, isolate_);\n#ifdef DEBUG\n          // Used for debugging\n          if (v8_flags.turboshaft_trace_typing) {\n            PrintF(\"Inserted assert for %3d:%-40s (%s)\\n\", original_value.id(),\n                   __ output_graph().Get(original_value).ToString().c_str(),\n                   type.ToString().c_str());\n          }\n#endif\n        };\n\n    switch (rep.value()) {\n      case RegisterRepresentation::Word32(): {\n        DCHECK(type.IsWord32());\n        base::SmallVector<OpIndex, 6> actual_value_indices = {value};\n        GenerateBuiltinCall(Builtin::kCheckTurboshaftWord32Type, value,\n                            std::move(actual_value_indices), type);\n        break;\n      }\n      case RegisterRepresentation::Word64(): {\n        DCHECK(type.IsWord64());\n        OpIndex value_high =\n            __ TruncateWord64ToWord32(__ Word64ShiftRightLogical(value, 32));\n        OpIndex value_low = __ TruncateWord64ToWord32(value);\n        base::SmallVector<OpIndex, 6> actual_value_indices = {value_high,\n                                                              value_low};\n        GenerateBuiltinCall(Builtin::kCheckTurboshaftWord64Type, value,\n                            std::move(actual_value_indices), type);\n        break;\n      }\n      case RegisterRepresentation::Float32(): {\n        DCHECK(type.IsFloat32());\n        base::SmallVector<OpIndex, 6> actual_value_indices = {value};\n        GenerateBuiltinCall(Builtin::kCheckTurboshaftFloat32Type, value,\n                            std::move(actual_value_indices), type);\n        break;\n      }\n      case RegisterRepresentation::Float64(): {\n        DCHECK(type.IsFloat64());\n        base::SmallVector<OpIndex, 6> actual_value_indices = {value};\n        GenerateBuiltinCall(Builtin::kCheckTurboshaftFloat64Type, value,\n                            std::move(actual_value_indices), type);\n        break;\n      }\n      case RegisterRepresentation::Tagged():\n      case RegisterRepresentation::Compressed():\n      case RegisterRepresentation::Simd128():\n      case RegisterRepresentation::Simd256():\n        // TODO(nicohartmann@): Handle remaining cases.\n        break;\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"factory\",\n                \"parent\": \"AssertTypesReducer\",\n                \"about\": \"Returns the Factory object associated with the current Isolate.\",\n                \"logic\": \"Retrieves the Factory from the Isolate.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Factory*\",\n                    \"description\": \"The Factory object.\"\n                },\n                \"dependencies\": [\n                    \"Factory\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n private:\n  Factory* factory() { return isolate_->factory(); }\n        ]]></code>\n    </func>\n</file>\n```"
}