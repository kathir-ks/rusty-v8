{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/bigint/bigint.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/bigint/bigint.h\",\n            \"file_name\": \"bigint.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the BigInt class and related functions for arbitrary-precision integer arithmetic.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers for integer types, algorithms, string manipulation, I/O streams, and dynamic arrays.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <stdint.h>\n\n#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <vector>\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Digits\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents a read-only array of digits for a BigInt.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"digits_\",\n                        \"type\": \"digit_t*\",\n                        \"access\": \"protected\",\n                        \"purpose\": \"Pointer to the array of digits.\"\n                    },\n                    {\n                        \"name\": \"len_\",\n                        \"type\": \"int\",\n                        \"access\": \"protected\",\n                        \"purpose\": \"The number of digits in the array.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"digit_t\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass Digits {\n public:\n  // This is the constructor intended for public consumption.\n  Digits(const digit_t* mem, int len)\n      // The const_cast here is ugly, but we need the digits field to be mutable\n      // for the RWDigits subclass. We pinky swear to not mutate the memory with\n      // this class.\n      : Digits(const_cast<digit_t*>(mem), len) {}\n\n  Digits(digit_t* mem, int len) : digits_(mem), len_(len) {\n    // Require 4-byte alignment (even on 64-bit platforms).\n    // TODO(jkummerow): See if we can tighten BigInt alignment in V8 to\n    // system pointer size, and raise this requirement to that.\n    BIGINT_H_DCHECK((reinterpret_cast<uintptr_t>(mem) & 3) == 0);\n  }\n\n  // Provides a \"slice\" view into another Digits object.\n  Digits(Digits src, int offset, int len)\n      : digits_(src.digits_ + offset),\n        len_(std::max(0, std::min(src.len_ - offset, len))) {\n    BIGINT_H_DCHECK(offset >= 0);\n  }\n\n  Digits() : Digits(static_cast<digit_t*>(nullptr), 0) {}\n\n  // Alternative way to get a \"slice\" view into another Digits object.\n  Digits operator+(int i) {\n    BIGINT_H_DCHECK(i >= 0 && i <= len_);\n    return Digits(digits_ + i, len_ - i);\n  }\n\n  // Provides access to individual digits.\n  digit_t operator[](int i) {\n    BIGINT_H_DCHECK(i >= 0 && i < len_);\n    return read_4byte_aligned(i);\n  }\n  // Convenience accessor for the most significant digit.\n  digit_t msd() {\n    BIGINT_H_DCHECK(len_ > 0);\n    return read_4byte_aligned(len_ - 1);\n  }\n  // Checks \"pointer equality\" (does not compare digits contents).\n  bool operator==(const Digits& other) const {\n    return digits_ == other.digits_ && len_ == other.len_;\n  }\n\n  // Decrements {len_} until there are no leading zero digits left.\n  void Normalize() {\n    while (len_ > 0 && msd() == 0) len_--;\n  }\n  // Unconditionally drops exactly one leading zero digit.\n  void TrimOne() {\n    BIGINT_H_DCHECK(len_ > 0 && msd() == 0);\n    len_--;\n  }\n\n  int len() { return len_; }\n  const digit_t* digits() const { return digits_; }\n\n protected:\n  friend class ShiftedDigits;\n  digit_t* digits_;\n  int len_;\n\n private:\n  // We require externally-provided digits arrays to be 4-byte aligned, but\n  // not necessarily 8-byte aligned; so on 64-bit platforms we use memcpy\n  // to allow unaligned reads.\n  digit_t read_4byte_aligned(int i) {\n    if (sizeof(digit_t) == 4) {\n      return digits_[i];\n    } else {\n      digit_t result;\n      memcpy(&result, static_cast<const void*>(digits_ + i), sizeof(result));\n      return result;\n    }\n  }\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RWDigits\",\n                \"extends\": \"Digits\",\n                \"implements\": [],\n                \"about\": \"Represents a writable array of digits for a BigInt, inheriting from Digits.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Digits\",\n                    \"digit_t\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass RWDigits : public Digits {\n public:\n  RWDigits(digit_t* mem, int len) : Digits(mem, len) {}\n  RWDigits(RWDigits src, int offset, int len) : Digits(src, offset, len) {}\n  RWDigits operator+(int i) {\n    BIGINT_H_DCHECK(i >= 0 && i <= len_);\n    return RWDigits(digits_ + i, len_ - i);\n  }\n\n#if UINTPTR_MAX == 0xFFFFFFFF\n  digit_t& operator[](int i) {\n    BIGINT_H_DCHECK(i >= 0 && i < len_);\n    return digits_[i];\n  }\n#else\n  // 64-bit platform. We only require digits arrays to be 4-byte aligned,\n  // so we use a wrapper class to allow regular array syntax while\n  // performing unaligned memory accesses under the hood.\n  class WritableDigitReference {\n   public:\n    // Support \"X[i] = x\" notation.\n    void operator=(digit_t digit) { memcpy(ptr_, &digit, sizeof(digit)); }\n    // Support \"X[i] = Y[j]\" notation.\n    WritableDigitReference& operator=(const WritableDigitReference& src) {\n      memcpy(ptr_, src.ptr_, sizeof(digit_t));\n      return *this;\n    }\n    // Support \"x = X[i]\" notation.\n    operator digit_t() {\n      digit_t result;\n      memcpy(&result, ptr_, sizeof(result));\n      return result;\n    }\n\n   private:\n    // This class is not for public consumption.\n    friend class RWDigits;\n    // Primary constructor.\n    explicit WritableDigitReference(digit_t* ptr)\n        : ptr_(reinterpret_cast<uint32_t*>(ptr)) {}\n    // Required for returning WDR instances from \"operator[]\" below.\n    WritableDigitReference(const WritableDigitReference& src) = default;\n\n    uint32_t* ptr_;\n  };\n\n  WritableDigitReference operator[](int i) {\n    BIGINT_H_DCHECK(i >= 0 && i < len_);\n    return WritableDigitReference(digits_ + i);\n  }\n#endif\n\n  digit_t* digits() { return digits_; }\n  void set_len(int len) { len_ = len; }\n\n  void Clear() { memset(digits_, 0, len_ * sizeof(digit_t)); }\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Platform\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Abstract base class for providing platform-specific functionality, such as interrupt handling.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass Platform {\n public:\n  virtual ~Platform() = default;\n\n  // If you want the ability to interrupt long-running operations, implement\n  // a Platform subclass that overrides this method. It will be queried\n  // every now and then by long-running operations.\n  virtual bool InterruptRequested() { return false; }\n};\n        ]]></code>\n    </class>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"Status\",\n                \"about\": \"Represents the status of long-running BigInt operations, indicating success or interruption.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class Status { kOk, kInterrupted };\n        ]]></code>\n    </enum>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FromStringAccumulator\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Accumulates intermediate state when parsing a BigInt from a string.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"stack_parts_\",\n                        \"type\": \"digit_t[kStackParts]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the initial parts of the BigInt on the stack.\"\n                    },\n                    {\n                        \"name\": \"heap_parts_\",\n                        \"type\": \"std::vector<digit_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores additional parts of the BigInt on the heap, if the stack is not sufficient.\"\n                    },\n                    {\n                        \"name\": \"max_multiplier_\",\n                        \"type\": \"digit_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the maximum multiplier used during parsing.\"\n                    },\n                    {\n                        \"name\": \"last_multiplier_\",\n                        \"type\": \"digit_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the last multiplier used during parsing.\"\n                    },\n                    {\n                        \"name\": \"max_digits_\",\n                        \"type\": \"const int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The maximum number of digits allowed.\"\n                    },\n                    {\n                        \"name\": \"result_\",\n                        \"type\": \"Result\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates the result of the parsing operation.\"\n                    },\n                    {\n                        \"name\": \"stack_parts_used_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The number of stack parts currently in use.\"\n                    },\n                    {\n                        \"name\": \"inline_everything_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether inline parsing is enabled.\"\n                    },\n                    {\n                        \"name\": \"radix_\",\n                        \"type\": \"uint8_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The radix of the number being parsed.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"digit_t\",\n                    \"std::vector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass FromStringAccumulator {\n public:\n  enum class Result { kOk, kMaxSizeExceeded };\n\n  // Step 1: Create a FromStringAccumulator instance. For best performance,\n  // stack allocation is recommended.\n  // {max_digits} is only used for refusing to grow beyond a given size\n  // (see \"Step 2\" below). It does not cause pre-allocation, so feel free to\n  // specify a large maximum.\n  // TODO(jkummerow): The limit applies to the number of intermediate chunks,\n  // whereas the final result will be slightly smaller (depending on {radix}).\n  // So for sufficiently large N, setting max_digits=N here will not actually\n  // allow parsing BigInts with N digits. We can fix that if/when anyone cares.\n  explicit FromStringAccumulator(int max_digits)\n      : max_digits_(std::max(max_digits, kStackParts)) {}\n\n  // Step 2: Call this method to read all characters.\n  // {CharIt} should be a forward iterator and\n  // std::iterator_traits<CharIt>::value_type shall be a character type, such as\n  // uint8_t or uint16_t. {end} should be one past the last character (i.e.\n  // {start == end} would indicate an empty string). Returns the current\n  // position when an invalid character is encountered.\n  template <class CharIt>\n  ALWAYS_INLINE CharIt Parse(CharIt start, CharIt end, digit_t radix);\n\n  // Step 3: Check if a result is available, and determine its required\n  // allocation size (guaranteed to be <= max_digits passed to the constructor).\n  Result result() { return result_; }\n  int ResultLength() {\n    return std::max(stack_parts_used_, static_cast<int>(heap_parts_.size()));\n  }\n\n  // Step 4: Use BigIntProcessor::FromString() to retrieve the result into an\n  // {RWDigits} struct allocated for the size returned by step 3.\n\n private:\n  friend class ProcessorImpl;\n\n  template <class CharIt>\n  ALWAYS_INLINE CharIt ParsePowerTwo(CharIt start, CharIt end, digit_t radix);\n\n  ALWAYS_INLINE bool AddPart(digit_t multiplier, digit_t part, bool is_last);\n  ALWAYS_INLINE bool AddPart(digit_t part);\n\n  digit_t stack_parts_[kStackParts];\n  std::vector<digit_t> heap_parts_;\n  digit_t max_multiplier_{0};\n  digit_t last_multiplier_;\n  const int max_digits_;\n  Result result_{Result::kOk};\n  int stack_parts_used_{0};\n  bool inline_everything_{false};\n  uint8_t radix_{0};\n};\n        ]]></code>\n    </class>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"FromStringAccumulator::Result\",\n                \"parent\": \"FromStringAccumulator\",\n                \"about\": \"Enum representing the result of accumulating digits from string, either kOk or kMaxSizeExceeded.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  enum class Result { kOk, kMaxSizeExceeded };\n        ]]></code>\n    </enum>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Processor\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Provides methods for performing BigInt operations that may be interrupted.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Platform\",\n                    \"FromStringAccumulator\",\n                    \"RWDigits\",\n                    \"Digits\",\n                    \"Status\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass Processor {\n public:\n  // Takes ownership of {platform}.\n  static Processor* New(Platform* platform);\n\n  // Use this for any std::unique_ptr holding an instance of {Processor}.\n  class Destroyer {\n   public:\n    void operator()(Processor* proc) { proc->Destroy(); }\n  };\n  // When not using std::unique_ptr, call this to delete the instance.\n  void Destroy();\n\n  // Z := X * Y\n  Status Multiply(RWDigits Z, Digits X, Digits Y);\n  // Q := A / B\n  Status Divide(RWDigits Q, Digits A, Digits B);\n  // R := A % B\n  Status Modulo(RWDigits R, Digits A, Digits B);\n\n  // {out_length} initially contains the allocated capacity of {out}, and\n  // upon return will be set to the actual length of the result string.\n  Status ToString(char* out, uint32_t* out_length, Digits X, int radix,\n                  bool sign);\n\n  // Z := the contents of {accumulator}.\n  // Assume that this leaves {accumulator} in unusable state.\n  Status FromString(RWDigits Z, FromStringAccumulator* accumulator);\n\n protected:\n  // Use {Destroy} or {Destroyer} instead of the destructor directly.\n  ~Processor() = default;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Compare\",\n                \"parent\": null,\n                \"about\": \"Compares two Digits objects and returns -1, 0, or 1 if A < B, A == B, or A > B, respectively.\",\n                \"logic\": \"Normalizes both Digits objects by removing leading zeros. Compares the lengths of the digit arrays. If the lengths differ, returns the difference. If the lengths are the same, compares the digits from most significant to least significant. Returns -1, 0, or 1 depending on whether A < B, A == B, or A > B.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"A\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object to compare.\"\n                    },\n                    {\n                        \"name\": \"B\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second Digits object to compare.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Returns -1 if A < B, 0 if A == B, and 1 if A > B.\"\n                },\n                \"dependencies\": [\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ninline int Compare(Digits A, Digits B) {\n  A.Normalize();\n  B.Normalize();\n  int diff = A.len() - B.len();\n  if (diff != 0) return diff;\n  int i = A.len() - 1;\n  while (i >= 0 && A[i] == B[i]) i--;\n  if (i < 0) return 0;\n  return A[i] > B[i] ? 1 : -1;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Add\",\n                \"parent\": null,\n                \"about\": \"Adds two Digits objects (X and Y) and stores the result in Z.\",\n                \"logic\": \"Performs digit-by-digit addition with carry propagation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object to add.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second Digits object to add.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Add(RWDigits Z, Digits X, Digits Y);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"AddSigned\",\n                \"parent\": null,\n                \"about\": \"Adds two signed Digits objects (X and Y) and stores the result in Z. Returns true if the result is negative.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object to add.\"\n                    },\n                    {\n                        \"name\": \"x_negative\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the first Digits object is negative.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second Digits object to add.\"\n                    },\n                    {\n                        \"name\": \"y_negative\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the second Digits object is negative.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"Returns true if the result is negative.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool AddSigned(RWDigits Z, Digits X, bool x_negative, Digits Y,\n               bool y_negative);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"AddOne\",\n                \"parent\": null,\n                \"about\": \"Adds 1 to a Digits object (X) and stores the result in Z.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The Digits object to add 1 to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AddOne(RWDigits Z, Digits X);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Subtract\",\n                \"parent\": null,\n                \"about\": \"Subtracts one Digits object (Y) from another (X) and stores the result in Z. Requires X >= Y.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The Digits object to subtract from.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The Digits object to subtract.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Subtract(RWDigits Z, Digits X, Digits Y);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SubtractSigned\",\n                \"parent\": null,\n                \"about\": \"Subtracts signed Digits objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The Digits object to subtract from.\"\n                    },\n                    {\n                        \"name\": \"x_negative\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the first Digits object is negative.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The Digits object to subtract.\"\n                    },\n                    {\n                        \"name\": \"y_negative\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates if the second Digits object is negative.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"Returns true if the result is negative.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool SubtractSigned(RWDigits Z, Digits X, bool x_negative, Digits Y,\n                    bool y_negative);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SubtractOne\",\n                \"parent\": null,\n                \"about\": \"Subtracts 1 from a Digits object (X) and stores the result in Z.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The Digits object to subtract 1 from.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SubtractOne(RWDigits Z, Digits X);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseAnd_PosPos\",\n                \"parent\": null,\n                \"about\": \"Performs a bitwise AND operation on two positive Digits objects (X and Y) and stores the result in Z.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second Digits object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseAnd_PosPos(RWDigits Z, Digits X, Digits Y);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseAnd_NegNeg\",\n                \"parent\": null,\n                \"about\": \"Performs a bitwise AND operation on two negative Digits objects (X and Y) and stores the result in Z.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second Digits object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseAnd_NegNeg(RWDigits Z, Digits X, Digits Y);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseAnd_PosNeg\",\n                \"parent\": null,\n                \"about\": \"Performs a bitwise AND operation on a positive Digits object (X) and a negative Digits object (Y) and stores the result in Z. Callers must swap arguments as needed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second Digits object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseAnd_PosNeg(RWDigits Z, Digits X, Digits Y);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseOr_PosPos\",\n                \"parent\": null,\n                \"about\": \"Performs a bitwise OR operation on two positive Digits objects (X and Y) and stores the result in Z.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second Digits object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseOr_PosPos(RWDigits Z, Digits X, Digits Y);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseOr_NegNeg\",\n                \"parent\": null,\n                \"about\": \"Performs a bitwise OR operation on two negative Digits objects (X and Y) and stores the result in Z.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second Digits object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseOr_NegNeg(RWDigits Z, Digits X, Digits Y);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseOr_PosNeg\",\n                \"parent\": null,\n                \"about\": \"Performs a bitwise OR operation on a positive Digits object (X) and a negative Digits object (Y) and stores the result in Z.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object.\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second Digits object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RWDigits\",\n                    \"Digits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseOr_PosNeg(RWDigits Z, Digits X, Digits Y);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseXor_PosPos\",\n                \"parent\": null,\n                \"about\": \"Performs a bitwise XOR operation on two positive Digits objects (X and Y) and stores the result in Z.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The RWDigits object to store the result in.\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first Digits object.\""
}