{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-inlining-heuristic.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 122, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-inlining-heuristic.h\",\n            \"file_name\": \"js-inlining-heuristic.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the JSInliningHeuristic class, which determines and performs inlining of JavaScript and WebAssembly calls.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes the JSInlining class definition, which provides core inlining functionality.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/js-inlining.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSInliningHeuristic\",\n                \"extends\": \"AdvancedReducer\",\n                \"about\": \"A reducer that heuristically determines and performs JavaScript and WebAssembly call inlining.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"inliner_\",\n                        \"type\": \"JSInliner\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The JSInliner instance used to perform the actual inlining.\"\n                    },\n                    {\n                        \"name\": \"candidates_\",\n                        \"type\": \"Candidates\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A set of candidate call sites for inlining.\"\n                    },\n                    {\n                        \"name\": \"seen_\",\n                        \"type\": \"ZoneSet<NodeId>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A set of NodeIds that have already been considered for inlining.\"\n                    },\n                    {\n                        \"name\": \"source_positions_\",\n                        \"type\": \"SourcePositionTable*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A table mapping nodes to their source positions.\"\n                    },\n                    {\n                        \"name\": \"jsgraph_\",\n                        \"type\": \"JSGraph* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the JSGraph instance.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the JSHeapBroker instance.\"\n                    },\n                    {\n                        \"name\": \"info_\",\n                        \"type\": \"OptimizedCompilationInfo*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the OptimizedCompilationInfo instance.\"\n                    },\n                    {\n                        \"name\": \"total_inlined_bytecode_size_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The cumulative size of inlined bytecode.\"\n                    },\n                    {\n                        \"name\": \"mode_\",\n                        \"type\": \"Mode\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The inlining mode (JS only, wasm wrappers only, or full wasm inlining).\"\n                    },\n                    {\n                        \"name\": \"max_inlined_bytecode_size_cumulative_\",\n                        \"type\": \"const int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The maximum cumulative size of inlined bytecode allowed.\"\n                    },\n                    {\n                        \"name\": \"max_inlined_bytecode_size_absolute_\",\n                        \"type\": \"const int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The maximum absolute size of inlined bytecode allowed for a single function.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"JSInliner\",\n                    \"Zone\",\n                    \"OptimizedCompilationInfo\",\n                    \"JSGraph\",\n                    \"JSHeapBroker\",\n                    \"SourcePositionTable\",\n                    \"NodeOriginTable\",\n                    \"wasm::WasmModule\",\n                    \"JsWasmCallsSidetable\",\n                    \"ZoneSet\",\n                    \"NodeId\",\n                    \"CallFrequency\",\n                    \"OptionalJSFunctionRef\",\n                    \"OptionalBytecodeArrayRef\",\n                    \"OptionalSharedFunctionInfoRef\",\n                    \"CommonOperatorBuilder\",\n                    \"TFGraph\",\n                    \"CompilationDependencies\",\n                    \"Isolate\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"FrameState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass JSInliningHeuristic final : public AdvancedReducer {\n public:\n  enum Mode {\n    kJSOnly,            // Inline JS calls only.\n    kWasmWrappersOnly,  // Inline wasm wrappers only.\n    kWasmFullInlining,  // Inline wasm wrappers and (if supported) whole wasm\n                        // functions.\n  };\n\n  JSInliningHeuristic(Editor* editor, Zone* local_zone,\n                      OptimizedCompilationInfo* info, JSGraph* jsgraph,\n                      JSHeapBroker* broker,\n                      SourcePositionTable* source_positions,\n                      NodeOriginTable* node_origins, Mode mode,\n                      // The two following arguments should be `nullptr` iff\n                      // inlining with `mode == kJSOnly`.\n                      const wasm::WasmModule* wasm_module,\n                      JsWasmCallsSidetable* js_wasm_calls_sidetable)\n      : AdvancedReducer(editor),\n        inliner_(editor, local_zone, info, jsgraph, broker, source_positions,\n                 node_origins, wasm_module, js_wasm_calls_sidetable,\n                 mode == kWasmFullInlining),\n        candidates_(local_zone),\n        seen_(local_zone),\n        source_positions_(source_positions),\n        jsgraph_(jsgraph),\n        broker_(broker),\n        info_(info),\n        mode_(mode),\n        max_inlined_bytecode_size_cumulative_(\n            v8_flags.max_inlined_bytecode_size_cumulative),\n        max_inlined_bytecode_size_absolute_(\n            v8_flags.max_inlined_bytecode_size_absolute) {\n    DCHECK_EQ(mode == kWasmWrappersOnly || mode == kWasmFullInlining,\n              wasm_module != nullptr && js_wasm_calls_sidetable != nullptr);\n  }\n\n  const char* reducer_name() const override { return \"JSInliningHeuristic\"; }\n\n  Reduction Reduce(Node* node) final;\n\n  // Processes the list of candidates gathered while the reducer was running,\n  // and inlines call sites that the heuristic determines to be important.\n  void Finalize() final;\n\n  int total_inlined_bytecode_size() const {\n    return total_inlined_bytecode_size_;\n  }\n\n private:\n  // This limit currently matches what the old compiler did. We may want to\n  // re-evaluate and come up with a proper limit for TurboFan.\n  static const int kMaxCallPolymorphism = 4;\n\n  struct Candidate {\n    OptionalJSFunctionRef functions[kMaxCallPolymorphism];\n    // In the case of polymorphic inlining, this tells if each of the\n    // functions could be inlined.\n    bool can_inline_function[kMaxCallPolymorphism];\n    // Strong references to bytecode to ensure it is not flushed from SFI\n    // while choosing inlining candidates.\n    OptionalBytecodeArrayRef bytecode[kMaxCallPolymorphism];\n    // TODO(2206): For now polymorphic inlining is treated orthogonally to\n    // inlining based on SharedFunctionInfo. This should be unified and the\n    // above array should be switched to SharedFunctionInfo instead. Currently\n    // we use {num_functions == 1 && functions[0].is_null()} as an indicator.\n    OptionalSharedFunctionInfoRef shared_info;\n    int num_functions;\n    Node* node = nullptr;     // The call site at which to inline.\n    CallFrequency frequency;  // Relative frequency of this call site.\n    int total_size = 0;\n  };\n\n  // Comparator for candidates.\n  struct CandidateCompare {\n    bool operator()(const Candidate& left, const Candidate& right) const;\n  };\n\n  // Candidates are kept in a sorted set of unique candidates.\n  using Candidates = ZoneSet<Candidate, CandidateCompare>;\n\n  // Dumps candidates to console.\n  void PrintCandidates();\n  Reduction InlineCandidate(Candidate const& candidate, bool small_function);\n  void CreateOrReuseDispatch(Node* node, Node* callee,\n                             Candidate const& candidate, Node** if_successes,\n                             Node** calls, Node** inputs, int input_count,\n                             int* num_calls);\n  bool TryReuseDispatch(Node* node, Node* callee, Node** if_successes,\n                        Node** calls, Node** inputs, int input_count,\n                        int* num_calls);\n  enum StateCloneMode { kCloneState, kChangeInPlace };\n  FrameState DuplicateFrameStateAndRename(FrameState frame_state, Node* from,\n                                          Node* to, StateCloneMode mode);\n  Node* DuplicateStateValuesAndRename(Node* state_values, Node* from, Node* to,\n                                      StateCloneMode mode);\n  Candidate CollectFunctions(Node* node, int functions_size);\n\n  CommonOperatorBuilder* common() const;\n  TFGraph* graph() const;\n  JSGraph* jsgraph() const { return jsgraph_; }\n  // TODO(neis): Make heap broker a component of JSGraph?\n  JSHeapBroker* broker() const { return broker_; }\n  CompilationDependencies* dependencies() const;\n  Isolate* isolate() const { return jsgraph_->isolate(); }\n  SimplifiedOperatorBuilder* simplified() const;\n  Mode mode() const { return mode_; }\n\n  JSInliner inliner_;\n  Candidates candidates_;\n  ZoneSet<NodeId> seen_;\n  SourcePositionTable* source_positions_;\n  JSGraph* const jsgraph_;\n  JSHeapBroker* const broker_;\n  OptimizedCompilationInfo* info_;\n  int total_inlined_bytecode_size_ = 0;\n  const Mode mode_;\n  const int max_inlined_bytecode_size_cumulative_;\n  const int max_inlined_bytecode_size_absolute_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"reducer_name\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the name of the reducer.\",\n                \"logic\": \"Overrides the AdvancedReducer::reducer_name() method to return a string literal.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"const char*\",\n                    \"description\": \"The name of the reducer.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  const char* reducer_name() const override { return \"JSInliningHeuristic\"; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reduce\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Reduces a node in the graph, potentially triggering inlining.\",\n                \"logic\": \"This method is the entry point for the reducer. It likely checks if the node is a call site and, if so, adds it to the list of candidates for inlining.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction Reduce(Node* node) final;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Finalize\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Finalizes the inlining process.\",\n                \"logic\": \"This method is called after the reducer has finished traversing the graph. It processes the list of inlining candidates and performs the actual inlining based on the heuristic.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  void Finalize() final;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"total_inlined_bytecode_size\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the total size of inlined bytecode.\",\n                \"logic\": \"A simple getter for the total_inlined_bytecode_size_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The total size of inlined bytecode.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  int total_inlined_bytecode_size() const {\n    return total_inlined_bytecode_size_;\n  }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"Candidate\",\n                \"about\": \"Represents a candidate call site for inlining.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"functions\",\n                        \"type\": \"OptionalJSFunctionRef[kMaxCallPolymorphism]\",\n                        \"access\": \"public\",\n                        \"purpose\": \"An array of OptionalJSFunctionRef objects representing the possible target functions of the call site.\"\n                    },\n                    {\n                        \"name\": \"can_inline_function\",\n                        \"type\": \"bool[kMaxCallPolymorphism]\",\n                        \"access\": \"public\",\n                        \"purpose\": \"An array of booleans indicating whether each of the target functions can be inlined.\"\n                    },\n                    {\n                        \"name\": \"bytecode\",\n                        \"type\": \"OptionalBytecodeArrayRef[kMaxCallPolymorphism]\",\n                        \"access\": \"public\",\n                        \"purpose\": \"An array of OptionalBytecodeArrayRef objects representing the bytecode of the target functions.\"\n                    },\n                    {\n                        \"name\": \"shared_info\",\n                        \"type\": \"OptionalSharedFunctionInfoRef\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The SharedFunctionInfo of the target function, if available.\"\n                    },\n                    {\n                        \"name\": \"num_functions\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The number of target functions for the call site.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The call site node.\"\n                    },\n                    {\n                        \"name\": \"frequency\",\n                        \"type\": \"CallFrequency\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The relative frequency of the call site.\"\n                    },\n                    {\n                        \"name\": \"total_size\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Total size of the call target.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"OptionalJSFunctionRef\",\n                    \"OptionalBytecodeArrayRef\",\n                    \"OptionalSharedFunctionInfoRef\",\n                    \"Node\",\n                    \"CallFrequency\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  struct Candidate {\n    OptionalJSFunctionRef functions[kMaxCallPolymorphism];\n    // In the case of polymorphic inlining, this tells if each of the\n    // functions could be inlined.\n    bool can_inline_function[kMaxCallPolymorphism];\n    // Strong references to bytecode to ensure it is not flushed from SFI\n    // while choosing inlining candidates.\n    OptionalBytecodeArrayRef bytecode[kMaxCallPolymorphism];\n    // TODO(2206): For now polymorphic inlining is treated orthogonally to\n    // inlining based on SharedFunctionInfo. This should be unified and the\n    // above array should be switched to SharedFunctionInfo instead. Currently\n    // we use {num_functions == 1 && functions[0].is_null()} as an indicator.\n    OptionalSharedFunctionInfoRef shared_info;\n    int num_functions;\n    Node* node = nullptr;     // The call site at which to inline.\n    CallFrequency frequency;  // Relative frequency of this call site.\n    int total_size = 0;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"CandidateCompare\",\n                \"about\": \"A comparator for Candidate objects, used to sort the candidates.\",\n                \"dependencies\": [\n                    \"Candidate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  // Comparator for candidates.\n  struct CandidateCompare {\n    bool operator()(const Candidate& left, const Candidate& right) const;\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PrintCandidates\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Dumps the list of inlining candidates to the console.\",\n                \"logic\": \"This function is likely used for debugging and profiling.  It iterates through the list of candidates and prints information about each one.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  // Dumps candidates to console.\n  void PrintCandidates();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InlineCandidate\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Inlines a specific candidate call site.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"candidate\",\n                        \"type\": \"Candidate const&\",\n                        \"purpose\": \"The candidate call site to inline.\"\n                    },\n                    {\n                        \"name\": \"small_function\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether the function being inlined is considered small.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the inlining.\"\n                },\n                \"dependencies\": [\n                    \"Candidate\",\n                    \"Reduction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction InlineCandidate(Candidate const& candidate, bool small_function);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CreateOrReuseDispatch\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Creates or reuses a dispatch node for polymorphic inlining.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The call site node.\"\n                    },\n                    {\n                        \"name\": \"callee\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The callee node.\"\n                    },\n                    {\n                        \"name\": \"candidate\",\n                        \"type\": \"Candidate const&\",\n                        \"purpose\": \"The inlining candidate.\"\n                    },\n                    {\n                        \"name\": \"if_successes\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"An array of nodes representing the success paths for each possible inlining target.\"\n                    },\n                    {\n                        \"name\": \"calls\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"An array of nodes representing the call sites for each possible inlining target.\"\n                    },\n                    {\n                        \"name\": \"inputs\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"An array of nodes representing the inputs to the call site.\"\n                    },\n                    {\n                        \"name\": \"input_count\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of inputs to the call site.\"\n                    },\n                    {\n                        \"name\": \"num_calls\",\n                        \"type\": \"int*\",\n                        \"purpose\": \"A pointer to the number of calls.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Candidate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void CreateOrReuseDispatch(Node* node, Node* callee,\n                             Candidate const& candidate, Node** if_successes,\n                             Node** calls, Node** inputs, int input_count,\n                             int* num_calls);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TryReuseDispatch\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Tries to reuse an existing dispatch node for polymorphic inlining.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The call site node.\"\n                    },\n                    {\n                        \"name\": \"callee\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The callee node.\"\n                    },\n                    {\n                        \"name\": \"if_successes\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"An array of nodes representing the success paths for each possible inlining target.\"\n                    },\n                    {\n                        \"name\": \"calls\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"An array of nodes representing the call sites for each possible inlining target.\"\n                    },\n                    {\n                        \"name\": \"inputs\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"An array of nodes representing the inputs to the call site.\"\n                    },\n                    {\n                        \"name\": \"input_count\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of inputs to the call site.\"\n                    },\n                    {\n                        \"name\": \"num_calls\",\n                        \"type\": \"int*\",\n                        \"purpose\": \"A pointer to the number of calls.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if a dispatch node was reused, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  bool TryReuseDispatch(Node* node, Node* callee, Node** if_successes,\n                        Node** calls, Node** inputs, int input_count,\n                        int* num_calls);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DuplicateFrameStateAndRename\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Duplicates a frame state and renames nodes within it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"frame_state\",\n                        \"type\": \"FrameState\",\n                        \"purpose\": \"The frame state to duplicate.\"\n                    },\n                    {\n                        \"name\": \"from\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to rename from.\"\n                    },\n                    {\n                        \"name\": \"to\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to rename to.\"\n                    },\n                    {\n                        \"name\": \"mode\",\n                        \"type\": \"StateCloneMode\",\n                        \"purpose\": \"The mode of cloning (clone or change in place).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"FrameState\",\n                    \"description\": \"The duplicated frame state.\"\n                },\n                \"dependencies\": [\n                    \"FrameState\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  enum StateCloneMode { kCloneState, kChangeInPlace };\n  FrameState DuplicateFrameStateAndRename(FrameState frame_state, Node* from,\n                                          Node* to, StateCloneMode mode);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DuplicateStateValuesAndRename\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Duplicates a state values node and renames nodes within it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"state_values\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The state values node to duplicate.\"\n                    },\n                    {\n                        \"name\": \"from\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to rename from.\"\n                    },\n                    {\n                        \"name\": \"to\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to rename to.\"\n                    },\n                    {\n                        \"name\": \"mode\",\n                        \"type\": \"StateCloneMode\",\n                        \"purpose\": \"The mode of cloning (clone or change in place).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The duplicated state values node.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* DuplicateStateValuesAndRename(Node* state_values, Node* from, Node* to,\n                                      StateCloneMode mode);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CollectFunctions\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Collects the possible target functions for a call site.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The call site node.\"\n                    },\n                    {\n                        \"name\": \"functions_size\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The maximum number of functions to collect.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Candidate\",\n                    \"description\": \"A Candidate object containing the collected functions.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Candidate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Candidate CollectFunctions(Node* node, int functions_size);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"common\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the CommonOperatorBuilder instance.\",\n                \"logic\": \"A simple getter for the CommonOperatorBuilder.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"CommonOperatorBuilder*\",\n                    \"description\": \"The CommonOperatorBuilder instance.\"\n                },\n                \"dependencies\": [\n                    \"CommonOperatorBuilder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  CommonOperatorBuilder* common() const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"graph\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the TFGraph instance.\",\n                \"logic\": \"A simple getter for the TFGraph.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"TFGraph*\",\n                    \"description\": \"The TFGraph instance.\"\n                },\n                \"dependencies\": [\n                    \"TFGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  TFGraph* graph() const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"jsgraph\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the JSGraph instance.\",\n                \"logic\": \"A simple getter for the jsgraph_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"JSGraph*\",\n                    \"description\": \"The JSGraph instance.\"\n                },\n                \"dependencies\": [\n                    \"JSGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  JSGraph* jsgraph() const { return jsgraph_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"broker\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the JSHeapBroker instance.\",\n                \"logic\": \"A simple getter for the broker_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"JSHeapBroker*\",\n                    \"description\": \"The JSHeapBroker instance.\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  // TODO(neis): Make heap broker a component of JSGraph?\n  JSHeapBroker* broker() const { return broker_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"dependencies\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the CompilationDependencies instance.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"CompilationDependencies*\",\n                    \"description\": \"The CompilationDependencies instance.\"\n                },\n                \"dependencies\": [\n                    \"CompilationDependencies\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  CompilationDependencies* dependencies() const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"isolate\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the Isolate instance.\",\n                \"logic\": \"A simple getter for the Isolate, obtained from the JSGraph.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Isolate*\",\n                    \"description\": \"The Isolate instance.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Isolate* isolate() const { return jsgraph_->isolate(); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"simplified\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the SimplifiedOperatorBuilder instance.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"SimplifiedOperatorBuilder*\",\n                    \"description\": \"The SimplifiedOperatorBuilder instance.\"\n                },\n                \"dependencies\": [\n                    \"SimplifiedOperatorBuilder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  SimplifiedOperatorBuilder* simplified() const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"mode\",\n                \"parent\": \"JSInliningHeuristic\",\n                \"about\": \"Returns the inlining mode.\",\n                \"logic\": \"A simple getter for the mode_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Mode\",\n                    \"description\": \"The inlining mode.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  Mode mode() const { return mode_; }\n        ]]></code>\n    </func>\n</file>\n```"
}