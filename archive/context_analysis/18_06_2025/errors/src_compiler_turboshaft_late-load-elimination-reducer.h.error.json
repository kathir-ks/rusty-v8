{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/late-load-elimination-reducer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/late-load-elimination-reducer.h\",\n        \"file_name\": \"late-load-elimination-reducer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the LateLoadEliminationReducer and related classes for performing load elimination in the Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for data structures, compiler phases, and Turboshaft components.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <optional>\n\n            #include \"src/base/doubly-threaded-list.h\"\n            #include \"src/compiler/turboshaft/analyzer-iterator.h\"\n            #include \"src/compiler/turboshaft/assembler.h\"\n            #include \"src/compiler/turboshaft/graph.h\"\n            #include \"src/compiler/turboshaft/index.h\"\n            #include \"src/compiler/turboshaft/loop-finder.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/opmasks.h\"\n            #include \"src/compiler/turboshaft/phase.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n            #include \"src/compiler/turboshaft/sidetable.h\"\n            #include \"src/compiler/turboshaft/snapshot-table-opindex.h\"\n            #include \"src/compiler/turboshaft/utils.h\"\n            #include \"src/zone/zone-containers.h\"\n            #include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes macro definitions for the assembler.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/turboshaft/define-assembler-macros.inc\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"MapMaskAndOr\",\n            \"about\": \"Represents the minimum and maximum map hashes for an object, used to determine potential aliasing.\",\n            \"attributes\": [\n                {\n                    \"name\": \"or_\",\n                    \"type\": \"MapMask\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The union (logical OR) of all potential map hashes.\"\n                },\n                {\n                    \"name\": \"and_\",\n                    \"type\": \"MapMask\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The intersection (logical AND) of all potential map hashes.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct MapMaskAndOr {\n            MapMask or_ = 0;\n            MapMask and_ = -1ull;\n\n            bool operator==(const MapMaskAndOr& other) const {\n                return or_ == other.or_ && and_ == other.and_;\n            }\n\n            bool operator!=(const MapMaskAndOr& other) const { return !(*this == other); }\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"inline function\",\n            \"name\": \"is_empty\",\n            \"about\": \"Checks if a MapMaskAndOr is empty (no maps).\",\n            \"parameters\": [\n                {\n                    \"name\": \"minmax\",\n                    \"type\": \"MapMaskAndOr\",\n                    \"purpose\": \"The MapMaskAndOr to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the MapMaskAndOr is empty, false otherwise.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            inline bool is_empty(MapMaskAndOr minmax) {\n            return minmax.or_ == 0 && minmax.and_ == -1ull;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"inline function\",\n            \"name\": \"ComputeMapHash\",\n            \"about\": \"Computes a hash value for a MapRef.\",\n            \"parameters\": [\n                {\n                    \"name\": \"map\",\n                    \"type\": \"MapRef\",\n                    \"purpose\": \"The MapRef to hash.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MapMask\",\n                \"description\": \"The computed hash value.\"\n            },\n            \"logic\": \"Uses xorshift64* to re-hash the original map's hash value, aiming for better distribution.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            inline MapMask ComputeMapHash(MapRef map) {\n            // `map.hash_value()` is probably not a good enough hash, since most user maps\n            // will have the same upper bits, so we re-hash. We're using xorshift64* (from\n            // \"An experimental exploration of Marsaglia\u2019s xorshift generators, scrambled\"\n            // by Vigna in ACM Transactions on Mathematical Software, Volume 42).\n            MapMask hash = map.hash_value();\n            hash ^= hash >> 12;\n            hash ^= hash << 25;\n            hash ^= hash >> 27;\n            return hash * 0x2545f4914f6cdd1d;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"inline function\",\n            \"name\": \"ComputeMinMaxHash\",\n            \"about\": \"Computes the minimum and maximum map hashes for a set of maps.\",\n            \"parameters\": [\n                {\n                    \"name\": \"maps\",\n                    \"type\": \"ZoneRefSet<Map>\",\n                    \"purpose\": \"The set of maps to compute the hashes for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MapMaskAndOr\",\n                \"description\": \"The computed minimum and maximum map hashes.\"\n            },\n            \"dependencies\": [\n                \"ComputeMapHash\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            inline MapMaskAndOr ComputeMinMaxHash(ZoneRefSet<Map> maps) {\n            MapMaskAndOr minmax;\n            for (MapRef map : maps) {\n                MapMask hash = ComputeMapHash(map);\n                minmax.or_ |= hash;\n                minmax.and_ &= hash;\n            }\n            return minmax;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"inline function\",\n            \"name\": \"CombineMinMax\",\n            \"about\": \"Combines two MapMaskAndOr values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"MapMaskAndOr\",\n                    \"purpose\": \"The first MapMaskAndOr.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"MapMaskAndOr\",\n                    \"purpose\": \"The second MapMaskAndOr.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MapMaskAndOr\",\n                \"description\": \"The combined MapMaskAndOr.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            inline MapMaskAndOr CombineMinMax(MapMaskAndOr a, MapMaskAndOr b) {\n            return {a.or_ | b.or_, a.and_ & b.and_};\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"inline function\",\n            \"name\": \"CouldHaveSameMap\",\n            \"about\": \"Checks if two MapMaskAndOr values could have a map in common.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"MapMaskAndOr\",\n                    \"purpose\": \"The first MapMaskAndOr.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"MapMaskAndOr\",\n                    \"purpose\": \"The second MapMaskAndOr.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the MapMaskAndOr values could have a map in common, false otherwise.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            inline bool CouldHaveSameMap(MapMaskAndOr a, MapMaskAndOr b) {\n            return ((a.and_ & b.or_) == a.and_) || ((b.and_ & a.or_) == b.and_);\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"MemoryAddress\",\n            \"about\": \"Represents a memory address with a base, optional index, offset, element size, and size.\",\n            \"attributes\": [\n                {\n                    \"name\": \"base\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The base OpIndex of the memory address.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"OptionalOpIndex\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The optional index OpIndex of the memory address.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"int32_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The offset of the memory address.\"\n                },\n                {\n                    \"name\": \"element_size_log2\",\n                    \"type\": \"uint8_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The logarithm base 2 of the element size.\"\n                },\n                {\n                    \"name\": \"size\",\n                    \"type\": \"uint8_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The size of the memory region.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct MemoryAddress {\n            OpIndex base;\n            OptionalOpIndex index;\n            int32_t offset;\n            uint8_t element_size_log2;\n            uint8_t size;\n\n            bool operator==(const MemoryAddress& other) const {\n                return base == other.base && index == other.index &&\n                    offset == other.offset &&\n                    element_size_log2 == other.element_size_log2 && size == other.size;\n            }\n\n            template <typename H>\n            friend H AbslHashValue(H h, const MemoryAddress& mem) {\n                return H::combine(std::move(h), mem.base, mem.index, mem.offset,\n                                    mem.element_size_log2, mem.size);\n            }\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for MemoryAddress, enabling printing of MemoryAddress objects to an output stream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream.\"\n                },\n                {\n                    \"name\": \"mem\",\n                    \"type\": \"const MemoryAddress&\",\n                    \"purpose\": \"The MemoryAddress object to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os, const MemoryAddress& mem);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"inline function\",\n            \"name\": \"hash_value\",\n            \"about\": \"Computes a hash value for a MemoryAddress object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"mem\",\n                    \"type\": \"const MemoryAddress&\",\n                    \"purpose\": \"The MemoryAddress object to hash.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The computed hash value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            inline size_t hash_value(MemoryAddress const& mem) {\n            return fast_hash_combine(mem.base, mem.index, mem.offset,\n                                    mem.element_size_log2, mem.size);\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"KeyData\",\n            \"about\": \"Holds data associated with a SnapshotTable key, including the MemoryAddress and pointers to other keys in the same base and offset lists.\",\n            \"attributes\": [\n                {\n                    \"name\": \"mem\",\n                    \"type\": \"MemoryAddress\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The memory address associated with the key.\"\n                },\n                {\n                    \"name\": \"prev_same_base\",\n                    \"type\": \"Key*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Pointer to the previous key with the same base.\"\n                },\n                {\n                    \"name\": \"next_same_base\",\n                    \"type\": \"Key\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The next key with the same base.\"\n                },\n                {\n                    \"name\": \"prev_same_offset\",\n                    \"type\": \"Key*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Pointer to the previous key with the same offset.\"\n                },\n                {\n                    \"name\": \"next_same_offset\",\n                    \"type\": \"Key\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The next key with the same offset.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct KeyData {\n            using Key = SnapshotTableKey<OpIndex, KeyData>;\n            MemoryAddress mem;\n            // Pointers to the previous and the next Keys at the same base.\n            Key* prev_same_base = nullptr;\n            Key next_same_base = {};\n            // Pointers to either the next/previous Keys at the same offset.\n            Key* prev_same_offset = nullptr;\n            Key next_same_offset = {};\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"OffsetListTraits\",\n            \"about\": \"Traits class for DoublyThreadedList used to manage keys with the same offset.\",\n            \"methods\": [\n                {\n                    \"name\": \"prev\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"t\",\n                            \"type\": \"T\"\n                        }\n                    ],\n                    \"return\": \"T**\",\n                    \"purpose\": \"Returns a pointer to the previous pointer.\"\n                },\n                {\n                    \"name\": \"next\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"t\",\n                            \"type\": \"T\"\n                        }\n                    ],\n                    \"return\": \"T*\",\n                    \"purpose\": \"Returns a pointer to the next element.\"\n                },\n                {\n                    \"name\": \"non_empty\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"t\",\n                            \"type\": \"T\"\n                        }\n                    ],\n                    \"return\": \"bool\",\n                    \"purpose\": \"Checks if the element is non-empty.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct OffsetListTraits {\n            using T = SnapshotTable<OpIndex, KeyData>::Key;\n            static T** prev(T t) { return &(t.data().prev_same_offset); }\n            static T* next(T t) { return &(t.data().next_same_offset); }\n            static bool non_empty(T t) { return t.valid(); }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"BaseListTraits\",\n            \"about\": \"Traits class for DoublyThreadedList used to manage keys with the same base.\",\n            \"methods\": [\n                {\n                    \"name\": \"prev\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"t\",\n                            \"type\": \"T\"\n                        }\n                    ],\n                    \"return\": \"T**\",\n                    \"purpose\": \"Returns a pointer to the previous pointer.\"\n                },\n                {\n                    \"name\": \"next\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"t\",\n                            \"type\": \"T\"\n                        }\n                    ],\n                    \"return\": \"T*\",\n                    \"purpose\": \"Returns a pointer to the next element.\"\n                },\n                {\n                    \"name\": \"non_empty\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"t\",\n                            \"type\": \"T\"\n                        }\n                    ],\n                    \"return\": \"bool\",\n                    \"purpose\": \"Checks if the element is non-empty.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct BaseListTraits {\n            using T = SnapshotTable<OpIndex, KeyData>::Key;\n            static T** prev(T t) { return &(t.data().prev_same_base); }\n            static T* next(T t) { return &(t.data().next_same_base); }\n            static bool non_empty(T t) { return t.valid(); }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"BaseData\",\n            \"about\": \"Holds lists of keys associated with a base, separated by whether they have an offset or index.\",\n            \"attributes\": [\n                {\n                    \"name\": \"with_offsets\",\n                    \"type\": \"v8::base::DoublyThreadedList<Key, BaseListTraits>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"List of keys with an offset for this base.\"\n                },\n                {\n                    \"name\": \"with_indices\",\n                    \"type\": \"v8::base::DoublyThreadedList<Key, BaseListTraits>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"List of keys with a valid index for this base.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct BaseData {\n            using Key = SnapshotTable<OpIndex, KeyData>::Key;\n            // List of every value at this base that has an offset rather than an index.\n            v8::base::DoublyThreadedList<Key, BaseListTraits> with_offsets;\n            // List of every value at this base that has a valid index.\n            v8::base::DoublyThreadedList<Key, BaseListTraits> with_indices;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LoadEliminationReplacement\",\n            \"about\": \"Represents a possible replacement for a load operation during load elimination.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class LoadEliminationReplacement {\n            public:\n            enum class Kind {\n                kNone,             // We don't replace the operation\n                kLoadElimination,  // We load eliminate a load operation\n                // The following replacements are used for the special case optimization:\n                // TruncateWord64ToWord32(\n                //     BitcastTaggedToWordPtrForTagAndSmiBits(Load(x, Tagged)))\n                // =>\n                // Load(x, Int32)\n                //\n                kTaggedLoadToInt32Load,     // Turn a tagged load into a direct int32 load.\n                kTaggedBitcastElimination,  // Remove this (now unused) bitcast.\n                kInt32TruncationElimination,  // Replace truncation by the updated load.\n            };\n\n            LoadEliminationReplacement() : kind_(Kind::kNone), replacement_() {}\n\n            static LoadEliminationReplacement None() {\n                return LoadEliminationReplacement{};\n            }\n            static LoadEliminationReplacement LoadElimination(OpIndex replacement) {\n                DCHECK(replacement.valid());\n                return LoadEliminationReplacement{Kind::kLoadElimination, replacement};\n            }\n            static LoadEliminationReplacement TaggedLoadToInt32Load() {\n                return LoadEliminationReplacement{Kind::kTaggedLoadToInt32Load, {}};\n            }\n            static LoadEliminationReplacement TaggedBitcastElimination() {\n                return LoadEliminationReplacement{Kind::kTaggedBitcastElimination, {}};\n            }\n            static LoadEliminationReplacement Int32TruncationElimination(\n                OpIndex replacement) {\n                return LoadEliminationReplacement{Kind::kInt32TruncationElimination,\n                                                    replacement};\n            }\n\n            bool IsNone() const { return kind_ == Kind::kNone; }\n            bool IsLoadElimination() const { return kind_ == Kind::kLoadElimination; }\n            bool IsTaggedLoadToInt32Load() const {\n                return kind_ == Kind::kTaggedLoadToInt32Load;\n            }\n            bool IsTaggedBitcastElimination() const {\n                return kind_ == Kind::kTaggedBitcastElimination;\n            }\n            bool IsInt32TruncationElimination() const {\n                return kind_ == Kind::kInt32TruncationElimination;\n            }\n            OpIndex replacement() const { return replacement_; }\n\n            private:\n            LoadEliminationReplacement(Kind kind, OpIndex replacement)\n                : kind_(kind), replacement_(replacement) {}\n\n            Kind kind_;\n            OpIndex replacement_;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsInt32TruncatedLoadPattern\",\n            \"about\": \"Checks if a given ChangeOp represents a specific pattern of truncating a tagged load to an Int32.\",\n            \"parameters\": [\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"const Graph&\",\n                    \"purpose\": \"The graph in which the operation exists.\"\n                },\n                {\n                    \"name\": \"change_idx\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the ChangeOp to check.\"\n                },\n                {\n                    \"name\": \"change\",\n                    \"type\": \"const ChangeOp&\",\n                    \"purpose\": \"The ChangeOp to check.\"\n                },\n                {\n                    \"name\": \"bitcast_idx\",\n                    \"type\": \"OpIndex*\",\n                    \"purpose\": \"Optional output parameter for the bitcast index.\"\n                },\n                {\n                    \"name\": \"load_idx\",\n                    \"type\": \"OpIndex*\",\n                    \"purpose\": \"Optional output parameter for the load index.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the ChangeOp matches the Int32 truncated load pattern, false otherwise.\"\n            }\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE bool IsInt32TruncatedLoadPattern(\n                const Graph& graph, OpIndex change_idx, const ChangeOp& change,\n                OpIndex* bitcast_idx = nullptr, OpIndex* load_idx = nullptr);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MemoryContentTable\",\n            \"extends\": \"ChangeTrackingSnapshotTable<MemoryContentTable, OpIndex, KeyData>\",\n            \"about\": \"A snapshot table that tracks the content of memory locations, used for load elimination.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ChangeTrackingSnapshotTable\",\n                \"OpIndex\",\n                \"KeyData\",\n                \"LoadEliminationReplacement\",\n                \"SparseOpIndexSnapshotTable\",\n                \"MapMaskAndOr\",\n                \"FixedOpIndexSidetable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class MemoryContentTable\n                : public ChangeTrackingSnapshotTable<MemoryContentTable, OpIndex, KeyData> {\n            public:\n            using Replacement = LoadEliminationReplacement;\n            explicit MemoryContentTable(\n                Zone* zone, SparseOpIndexSnapshotTable<bool>& non_aliasing_objects,\n                SparseOpIndexSnapshotTable<MapMaskAndOr>& object_maps,\n                FixedOpIndexSidetable<Replacement>& replacements)\n                : ChangeTrackingSnapshotTable(zone),\n                    non_aliasing_objects_(non_aliasing_objects),\n                    object_maps_(object_maps),\n                    replacements_(replacements),\n                    all_keys_(zone),\n                    base_keys_(zone),\n                    offset_keys_(zone) {}\n\n            void OnNewKey(Key key, OpIndex value) {\n                if (value.valid()) {\n                AddKeyInBaseOffsetMaps(key);\n                }\n            }\n\n            void OnValueChange(Key key, OpIndex old_value, OpIndex new_value) {\n                DCHECK_NE(old_value, new_value);\n                if (old_value.valid() && !new_value.valid()) {\n                RemoveKeyFromBaseOffsetMaps(key);\n                } else if (new_value.valid() && !old_value.valid()) {\n                AddKeyInBaseOffsetMaps(key);\n                } else {\n                DCHECK_EQ(new_value.valid(), old_value.valid());\n                }\n            }\n\n            // Invalidate all previous known memory that could alias with {store}.\n            void Invalidate(const StoreOp& store) {\n                Invalidate(store.base(), store.index(), store.offset);\n            }\n\n            void Invalidate(OpIndex base, OptionalOpIndex index, int32_t offset) {\n                TRACE(\"> MemoryContentTable: Invalidating based on \"\n                    << base << \", \" << index << \", \" << offset);\n                base = ResolveBase(base);\n\n                if (non_aliasing_objects_.Get(base)) {\n                TRACE(\">> base is non-aliasing\");\n                // Since {base} is non-aliasing, it's enough to just iterate the values at\n                // this base.\n                auto base_keys = base_keys_.find(base);\n                if (base_keys == base_keys_.end()) return;\n                for (auto it = base_keys->second.with_offsets.begin();\n                    it != base_keys->second.with_offsets.end();) {\n                    Key key = *it;\n                    DCHECK_EQ(key.data().mem.base, base);\n                    DCHECK(!key.data().mem.index.valid());\n                    if (index.valid() || offset == key.data().mem.offset) {\n                    // Overwrites {key}.\n                    it = base_keys->second.with_offsets.RemoveAt(it);\n                    TRACE(\">>> invalidating \" << key.data().mem);\n                    Set(key, OpIndex::Invalid());\n                    } else {\n                    ++it;\n                    }\n                }\n                // Invalidating all of the value with valid Index at base {base}.\n                for (auto it = base_keys->second.with_indices.begin();\n                    it != base_keys->second.with_indices.end();) {\n                    Key key = *it;\n                    DCHECK(key.data().mem.index.valid());\n                    it = base_keys->second.with_indices.RemoveAt(it);\n                    Set(key, OpIndex::Invalid());\n                }\n                } else {\n                TRACE(\">> base is maybe-aliasing\");\n                // {base} could alias with other things, so we iterate the whole state.\n                if (index.valid()) {\n                    // {index} could be anything, so we invalidate everything.\n                    TRACE(\">> Invalidating everything because of valid index\");\n                    return InvalidateMaybeAliasing();\n                }\n\n                // Invalidating all of the values with valid Index.\n                // TODO(dmercadier): we could keep keys that don't alias here, but that\n                // would require doing a map lookup on the base of each key. A better\n                // alternative would probably be to have 2 {non_alias_index_keys_} and\n                // {maybe_alias_index_keys_} tables instead of just {index_keys_}. This\n                // has the downside that when a base stops being non-alias, all of its\n                // indexed memory cells have to be moved. This could be worked around by\n                // having these 2 tables contain BaseData.with_indices values instead of\n                // Keys, so that a whole BaseData.with_indices can be removed in a single\n                // operation from the global {non_alias_index_keys_}.\n                for (auto it = index_keys_.begin(); it != index_keys_.end();) {\n                    Key key = *it;\n                    it = index_keys_.RemoveAt(it);\n                    TRACE(\">>> Invalidating indexed memory \" << key.data().mem);\n                    Set(key, OpIndex::Invalid());\n                }\n\n                TRACE(\">>> Invalidating everything maybe-aliasing at offset \" << offset);\n                InvalidateAtOffset(offset, base);\n                }\n            }\n\n            // Invalidates all Keys that are not known as non-aliasing.\n            void InvalidateMaybeAliasing() {\n                TRACE(\">> InvalidateMaybeAliasing\");\n                // We find current active keys through {base_keys_} so that we can bail out\n                // for whole buckets non-aliasing bases (if we had gone through\n                // {offset_keys_} instead, then for each key we would've had to check\n                // whether it was non-aliasing or not).\n                for (auto& base_keys : base_keys_) {\n                OpIndex base = base_keys.first;\n                if (non_aliasing_objects_.Get(base)) continue;\n                for (auto it = base_keys.second.with_offsets.begin();\n                    it != base_keys.second.with_offsets.end();) {\n                    Key key = *it;\n                    // It's important to remove with RemoveAt before Setting the key to\n                    // invalid, otherwise OnKeyChange will remove {key} from {base_keys},\n                    // which will invalidate {it}.\n                    it = base_keys.second.with_offsets.RemoveAt(it);\n                    TRACE(\">>> Invalidating \" << key.data().mem);\n                    Set(key, OpIndex::Invalid());\n                }\n                for (auto it = base_keys.second.with_indices.begin();\n                    it != base_keys.second.with_indices.end();) {\n                    Key key = *it;\n                    it = base_keys.second.with_indices.RemoveAt(it);\n                    TRACE(\">>> Invalidating \" << key.data().mem);\n                    Set(key, OpIndex::Invalid());\n                }\n                }\n            }\n\n            OpIndex Find(const LoadOp& load) {\n                OpIndex base = ResolveBase(load.base());\n                OptionalOpIndex index = load.index();\n                int32_t offset = load.offset;\n                uint8_t element_size_log2 = index.valid() ? load.element_size_log2 : 0;\n                uint8_t size = load.loaded_rep.SizeInBytes();\n\n                MemoryAddress mem{base, index, offset, element_size_log2, size};\n                auto key = all_keys_.find(mem);\n                if (key == all_keys_.end()) return OpIndex::Invalid();\n                return Get(key->second);\n            }\n\n            void Insert(const StoreOp& store) {\n                OpIndex base = ResolveBase(store.base());\n                OptionalOpIndex index = store.index();\n                int32_t offset = store.offset;\n                uint8_t element_size_log2 = index.valid() ? store.element_size_log2 : 0;\n                OpIndex value = store.value();\n                uint8_t size = store.stored_rep.SizeInBytes();\n\n                if (store.kind.is_immutable) {\n                InsertImmutable(base, index, offset, element_size_log2, size, value);\n                } else {\n                Insert(base, index, offset, element_size_log2, size, value);\n                }\n            }\n\n            void Insert(const LoadOp& load, OpIndex load_idx) {\n                OpIndex base = ResolveBase(load.base());\n                OptionalOpIndex index = load.index();\n                int32_t offset = load.offset;\n                uint8_t element_size_log2 = index.valid() ? load.element_size_log2 : 0;\n                uint8_t size = load.loaded_rep.SizeInBytes();\n\n                if (load.kind.is_immutable) {\n                InsertImmutable(base, index, offset, element_size_log2, size, load_idx);\n                } else {\n                Insert(base, index, offset, element_size_log2, size, load_idx);\n                }\n            }\n\n            #ifdef DEBUG\n            void Print() {\n                std::cout << \"MemoryContentTable:\\n\";\n                for (const auto& base_keys : base_keys_) {\n                for (Key key : base_keys.second.with_offsets) {\n                    std::cout << \"  * \" << key.data().mem.base << \" - \"\n                            << key.data().mem.index << \" - \" << key.data().mem.offset\n                            << \" - \" << key.data().mem.element_size"
}