{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 52, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone.cc\",\n        \"file_name\": \"zone.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Zone class for memory management.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for zone functionality and standard library features.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/zone/zone.h\"\n\n            #include <cstring>\n            #include <memory>\n\n            #include \"src/base/sanitizer/asan.h\"\n            #include \"src/init/v8.h\"\n            #include \"src/utils/utils.h\"\n            #include \"src/zone/type-stats.h\"\n        ]]></code>\n    </imports>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8::internal\",\n            \"purpose\": \"Encapsulates V8 internal implementation details.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            namespace internal {\n        ]]></code>\n    </namespace>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"<anonymous>\",\n            \"parent\": \"v8::internal\",\n            \"purpose\": \"Defines constants related to Address Sanitizer (ASan) redzones.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n\n            #ifdef V8_USE_ADDRESS_SANITIZER\n\n            constexpr size_t kASanRedzoneBytes = 24;  // Must be a multiple of 8.\n\n            #else  // !V8_USE_ADDRESS_SANITIZER\n\n            constexpr size_t kASanRedzoneBytes = 0;\n\n            #endif  // V8_USE_ADDRESS_SANITIZER\n\n            }  // namespace\n        ]]></code>\n    </namespace>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Zone\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Manages a memory allocation area, similar to a memory pool.\",\n            \"attributes\": [\n                {\n                    \"name\": \"allocator_\",\n                    \"type\": \"AccountingAllocator*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The allocator used to allocate segments for the zone.\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A name for the zone, useful for debugging.\"\n                },\n                {\n                    \"name\": \"supports_compression_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the zone supports segment compression.\"\n                },\n                {\n                    \"name\": \"segment_head_\",\n                    \"type\": \"Segment*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the first segment in the zone's list of segments.\"\n                },\n                {\n                    \"name\": \"position_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current allocation position within the current segment.\"\n                },\n                {\n                    \"name\": \"limit_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The end address of the current segment.\"\n                },\n                {\n                    \"name\": \"allocation_size_\",\n                    \"type\": \"std::atomic<size_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Total number of bytes allocated in the zone.\"\n                },\n                {\n                    \"name\": \"segment_bytes_allocated_\",\n                    \"type\": \"std::atomic<size_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The total number of bytes allocated for segments in the zone.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AccountingAllocator\",\n                \"Segment\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Zone {\n            public:\n                Zone(AccountingAllocator* allocator, const char* name,\n                    bool support_compression);\n                ~Zone();\n\n                void* AsanNew(size_t size);\n\n                void Reset();\n\n            #ifdef DEBUG\n                bool Contains(const void* ptr) const;\n            #endif\n\n                ZoneSnapshot Snapshot() const;\n\n                void DeleteAll();\n\n            private:\n                void ReleaseSegment(Segment* segment);\n                void Expand(size_t size);\n\n                AccountingAllocator* allocator_;\n                const char* name_;\n                bool supports_compression_;\n                Segment* segment_head_ = nullptr;\n                Address position_ = 0;\n                Address limit_ = 0;\n                std::atomic<size_t> allocation_size_ {0};\n                std::atomic<size_t> segment_bytes_allocated_ {0};\n            #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n                size_t allocation_size_for_tracing_ = 0;\n                size_t freed_size_for_tracing_ = 0;\n            #endif\n                bool sealed_ = false; //Unused, but mentioned to keep the state of the class complete\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"Zone\",\n            \"parent\": \"Zone\",\n            \"about\": \"Constructs a new Zone object.\",\n            \"logic\": \"Initializes the Zone with an allocator, a name, and a compression flag. Traces the zone creation through the allocator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"allocator\",\n                    \"type\": \"AccountingAllocator*\",\n                    \"purpose\": \"The allocator to use for memory allocation.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the zone (for debugging).\"\n                },\n                {\n                    \"name\": \"support_compression\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether the zone supports segment compression.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"AccountingAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Zone::Zone(AccountingAllocator* allocator, const char* name,\n                       bool support_compression)\n                : allocator_(allocator),\n                  name_(name),\n                  supports_compression_(support_compression) {\n              allocator_->TraceZoneCreation(this);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"destructor\",\n            \"name\": \"~Zone\",\n            \"parent\": \"Zone\",\n            \"about\": \"Destroys a Zone object.\",\n            \"logic\": \"Deallocates all memory segments associated with the zone. Asserts that all allocated segment bytes have been freed.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            Zone::~Zone() {\n              DeleteAll();\n              DCHECK_EQ(segment_bytes_allocated_.load(), 0);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AsanNew\",\n            \"parent\": \"Zone\",\n            \"about\": \"Allocates a new block of memory within the zone, using Address Sanitizer (ASan) to detect memory errors.\",\n            \"logic\": \"Rounds up the requested size to the alignment. Checks for available space and expands the zone if necessary. Adds a redzone around the allocated memory for ASan. Poisons the redzone to detect out-of-bounds access.\",\n            \"parameters\": [\n                {\n                    \"name\": \"size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The size of the memory block to allocate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void*\",\n                \"description\": \"A pointer to the allocated memory block.\"\n            },\n            \"dependencies\": [\n                \"RoundUp\",\n                \"kAlignmentInBytes\",\n                \"kASanRedzoneBytes\",\n                \"Expand\",\n                \"IsAligned\",\n                \"ASAN_POISON_MEMORY_REGION\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void* Zone::AsanNew(size_t size) {\n              CHECK(!sealed_);\n\n              // Round up the requested size to fit the alignment.\n              size = RoundUp(size, kAlignmentInBytes);\n\n              // Check if the requested size is available without expanding.\n              const size_t size_with_redzone = size + kASanRedzoneBytes;\n              DCHECK_LE(position_, limit_);\n              if (V8_UNLIKELY(size_with_redzone > limit_ - position_)) {\n                Expand(size_with_redzone);\n              }\n              DCHECK_LE(size_with_redzone, limit_ - position_);\n\n              Address result = position_;\n              position_ += size_with_redzone;\n\n              Address redzone_position = result + size;\n              DCHECK_EQ(redzone_position + kASanRedzoneBytes, position_);\n              ASAN_POISON_MEMORY_REGION(reinterpret_cast<void*>(redzone_position),\n                                        kASanRedzoneBytes);\n\n              // Check that the result has the proper alignment and return it.\n              DCHECK(IsAligned(result, kAlignmentInBytes));\n              return reinterpret_cast<void*>(result);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reset\",\n            \"parent\": \"Zone\",\n            \"about\": \"Resets the zone to its initial state, reusing the first segment if possible.\",\n            \"logic\": \"If the zone has no segments, it returns immediately. Otherwise, it detaches all segments after the first one, deallocates them, and reuses the first segment. Unpoisons and zaps the first segment's contents before reusing it.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"DeleteAll\",\n                \"AccountingAllocator\",\n                \"kAlignmentInBytes\",\n                \"ASAN_UNPOISON_MEMORY_REGION\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Zone::Reset() {\n              if (!segment_head_) return;\n              Segment* keep = segment_head_;\n              segment_head_ = segment_head_->next();\n              if (segment_head_ != nullptr) {\n                // Reset the position to the end of the new head, and uncommit its\n                // allocation size (which will be re-committed in DeleteAll).\n                position_ = segment_head_->end();\n                allocation_size_ -= segment_head_->end() - segment_head_->start();\n              }\n              keep->set_next(nullptr);\n              DeleteAll();\n              allocator_->TraceZoneCreation(this);\n\n              // Un-poison the kept segment content so we can zap and reuse it.\n              ASAN_UNPOISON_MEMORY_REGION(reinterpret_cast<void*>(keep->start()),\n                                          keep->capacity());\n              keep->ZapContents();\n\n              segment_head_ = keep;\n              position_ = RoundUp(keep->start(), kAlignmentInBytes);\n              limit_ = keep->end();\n              DCHECK_LT(allocation_size(), kAlignmentInBytes);\n              DCHECK_EQ(segment_bytes_allocated_, keep->total_size());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Contains\",\n            \"parent\": \"Zone\",\n            \"about\": \"Checks if a given pointer resides within any of the Zone's segments.\",\n            \"logic\": \"Iterates through all segments in the zone. Returns true if the address falls within the start and end address of any segment; otherwise, returns false.\",\n            \"parameters\": [\n                {\n                    \"name\": \"ptr\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The pointer to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the pointer is contained within the zone, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef DEBUG\n            bool Zone::Contains(const void* ptr) const {\n              Address address = reinterpret_cast<Address>(ptr);\n              for (Segment* segment = segment_head_; segment != nullptr;\n                   segment = segment->next()) {\n                if (address >= segment->start() && address < segment->end()) {\n                  return true;\n                }\n              }\n              return false;\n            }\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Snapshot\",\n            \"parent\": \"Zone\",\n            \"about\": \"Creates a snapshot of the Zone's current state.\",\n            \"logic\": \"Creates and returns a `ZoneSnapshot` object, which contains a copy of the Zone's relevant state.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"ZoneSnapshot\",\n                \"description\": \"A snapshot of the Zone's state.\"\n            },\n            \"dependencies\": [\n                \"ZoneSnapshot\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            ZoneSnapshot Zone::Snapshot() const { return ZoneSnapshot{this}; }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeleteAll\",\n            \"parent\": \"Zone\",\n            \"about\": \"Deallocates all memory segments associated with the zone.\",\n            \"logic\": \"Iterates through the list of segments and releases them back to the allocator. Resets the zone's internal pointers and allocation size.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"ReleaseSegment\",\n                \"AccountingAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Zone::DeleteAll() {\n              Segment* current = segment_head_;\n              if (current) {\n                // Commit the allocation_size_ of segment_head_ and disconnect the segments\n                // list from the zone in order to ensure that tracing accounting allocator\n                // will observe value including memory from the head segment.\n                allocation_size_ = allocation_size();\n                segment_head_ = nullptr;\n              }\n              allocator_->TraceZoneDestruction(this);\n\n              // Traverse the chained list of segments and return them all to the allocator.\n              while (current) {\n                Segment* next = current->next();\n                segment_bytes_allocated_ -= current->total_size();\n                ReleaseSegment(current);\n                current = next;\n              }\n\n              position_ = limit_ = 0;\n              allocation_size_ = 0;\n            #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n              allocation_size_for_tracing_ = 0;\n            #endif\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReleaseSegment\",\n            \"parent\": \"Zone\",\n            \"about\": \"Releases a segment back to the allocator.\",\n            \"logic\": \"Unpoisons the segment's memory region and returns the segment to the allocator, indicating whether compression is supported.\",\n            \"parameters\": [\n                {\n                    \"name\": \"segment\",\n                    \"type\": \"Segment*\",\n                    \"purpose\": \"The segment to release.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"AccountingAllocator\",\n                \"ASAN_UNPOISON_MEMORY_REGION\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Zone::ReleaseSegment(Segment* segment) {\n              // Un-poison the segment content so we can reuse or zap it later.\n              ASAN_UNPOISON_MEMORY_REGION(reinterpret_cast<void*>(segment->start()),\n                                          segment->capacity());\n              allocator_->ReturnSegment(segment, supports_compression());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Expand\",\n            \"parent\": \"Zone\",\n            \"about\": \"Expands the zone by allocating a new segment.\",\n            \"logic\": \"Calculates the required size for the new segment, taking into account overhead and the requested size. Allocates a new segment using the allocator, sets the zone and next pointer for the segment. Recomputes the 'position' and 'limit' based on the new segment.\",\n            \"parameters\": [\n                {\n                    \"name\": \"size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The minimum size required for the new segment.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"AccountingAllocator\",\n                \"RoundDown\",\n                \"kAlignmentInBytes\",\n                \"kMinimumSegmentSize\",\n                \"kMaximumSegmentSize\",\n                \"AllocateSegment\",\n                \"V8::FatalProcessOutOfMemory\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Zone::Expand(size_t size) {\n              // Make sure the requested size is already properly aligned and that\n              // there isn't enough room in the Zone to satisfy the request.\n              DCHECK_EQ(size, RoundDown(size, kAlignmentInBytes));\n              DCHECK_LT(limit_ - position_, size);\n\n              // Compute the new segment size. We use a 'high water mark'\n              // strategy, where we increase the segment size every time we expand\n              // except that we employ a maximum segment size when we delete. This\n              // is to avoid excessive malloc() and free() overhead.\n              Segment* head = segment_head_;\n              const size_t old_size = head ? head->total_size() : 0;\n              static const size_t kSegmentOverhead = sizeof(Segment) + kAlignmentInBytes;\n              const size_t new_size_no_overhead = size + (old_size << 1);\n              size_t new_size = kSegmentOverhead + new_size_no_overhead;\n              const size_t min_new_size = kSegmentOverhead + size;\n              // Guard against integer overflow.\n              if (new_size_no_overhead < size || new_size < kSegmentOverhead) {\n                V8::FatalProcessOutOfMemory(nullptr, \"Zone\");\n              }\n              if (new_size < kMinimumSegmentSize) {\n                new_size = kMinimumSegmentSize;\n              } else if (new_size >= kMaximumSegmentSize) {\n                // Limit the size of new segments to avoid growing the segment size\n                // exponentially, thus putting pressure on contiguous virtual address space.\n                // All the while making sure to allocate a segment large enough to hold the\n                // requested size.\n                new_size = std::max({min_new_size, kMaximumSegmentSize});\n              }\n              if (new_size > INT_MAX) {\n                V8::FatalProcessOutOfMemory(nullptr, \"Zone\");\n              }\n              Segment* segment =\n                  allocator_->AllocateSegment(new_size, supports_compression());\n              if (segment == nullptr) {\n                V8::FatalProcessOutOfMemory(nullptr, \"Zone\");\n              }\n\n              DCHECK_GE(segment->total_size(), new_size);\n              segment_bytes_allocated_ += segment->total_size();\n              segment->set_zone(this);\n              segment->set_next(segment_head_);\n              // Commit the allocation_size_ of segment_head_ if any, in order to ensure\n              // that tracing accounting allocator will observe value including memory\n              // from the previous head segment.\n              allocation_size_ = allocation_size();\n              segment_head_ = segment;\n              allocator_->TraceAllocateSegment(segment);\n\n              // Recompute 'top' and 'limit' based on the new segment.\n              position_ = RoundUp(segment->start(), kAlignmentInBytes);\n              limit_ = segment->end();\n              DCHECK_LE(position_, limit_);\n              DCHECK_LE(size, limit_ - position_);\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneSnapshot\",\n            \"about\": \"Represents a snapshot of the Zone's state, allowing for later restoration.\",\n            \"attributes\": [\n                {\n                    \"name\": \"allocation_size_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The total number of bytes allocated in the zone.\"\n                },\n                {\n                    \"name\": \"segment_bytes_allocated_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The total number of bytes allocated for segments in the zone.\"\n                },\n                {\n                    \"name\": \"position_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current allocation position within the current segment.\"\n                },\n                {\n                    \"name\": \"limit_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The end address of the current segment.\"\n                },\n                {\n                    \"name\": \"segment_head_\",\n                    \"type\": \"Segment*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the first segment in the zone's list of segments.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"Segment\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ZoneSnapshot {\n            public:\n                ZoneSnapshot(const Zone* zone);\n                void Restore(Zone* zone) const;\n\n            private:\n            #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n              size_t allocation_size_for_tracing_;\n              size_t freed_size_for_tracing_;\n            #endif\n              size_t allocation_size_;\n              size_t segment_bytes_allocated_;\n              Address position_;\n              Address limit_;\n              Segment* segment_head_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"ZoneSnapshot\",\n            \"parent\": \"ZoneSnapshot\",\n            \"about\": \"Constructs a new ZoneSnapshot object from a Zone object.\",\n            \"logic\": \"Copies the Zone's allocation size, segment bytes allocated, position, limit, and segment head.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"const Zone*\",\n                    \"purpose\": \"The Zone to create a snapshot from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            ZoneSnapshot::ZoneSnapshot(const Zone* zone)\n                :\n            #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n                  allocation_size_for_tracing_(zone->allocation_size_for_tracing_),\n                  freed_size_for_tracing_(zone->freed_size_for_tracing_),\n            #endif\n                  allocation_size_(zone->allocation_size_),\n                  segment_bytes_allocated_(zone->segment_bytes_allocated_),\n                  position_(zone->position_),\n                  limit_(zone->limit_),\n                  segment_head_(zone->segment_head_) {\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Restore\",\n            \"parent\": \"ZoneSnapshot\",\n            \"about\": \"Restores a Zone to the state captured in this snapshot.\",\n            \"logic\": \"Releases segments beyond the snapshot's segment head. Unpoisons the trailing segment content, and resets the zone's allocation size, segment bytes allocated, position, limit, and segment head to the snapshot's values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone to restore.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": [\n                \"ReleaseSegment\",\n                \"Zone\",\n                \"Segment\",\n                \"ASAN_UNPOISON_MEMORY_REGION\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ZoneSnapshot::Restore(Zone* zone) const {\n              // Release segments up to the stored segment_head_.\n              Segment* current = zone->segment_head_;\n              while (current != segment_head_) {\n                // If this check failed, then either you passed a wrong zone, or the zone\n                // was reset to an earlier snapshot already. We cannot move forward again.\n                CHECK_NOT_NULL(current);\n                Segment* next = current->next();\n                zone->ReleaseSegment(current);\n                current = next;\n              }\n\n              // Un-poison the trailing segment content so we can reuse or zap it later.\n              if (segment_head_ != nullptr) {\n                void* const start = reinterpret_cast<void*>(position_);\n                DCHECK_GE(start, reinterpret_cast<void*>(current->start()));\n                DCHECK_LE(start, reinterpret_cast<void*>(current->end()));\n                const size_t length = current->end() - reinterpret_cast<Address>(start);\n                ASAN_UNPOISON_MEMORY_REGION(start, length);\n              }\n\n              // Reset the Zone to the stored state.\n              zone->allocation_size_ = allocation_size_;\n              zone->segment_bytes_allocated_ = segment_bytes_allocated_;\n              zone->position_ = position_;\n              zone->limit_ = limit_;\n              zone->segment_head_ = segment_head_;\n            #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n              zone->allocation_size_for_tracing_ = allocation_size_for_tracing_;\n              zone->freed_size_for_tracing_ = freed_size_for_tracing_;\n            #endif\n            }\n        ]]></code>\n    </func>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8::internal\",\n            \"purpose\": \"Closes the v8::internal namespace.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            }  // namespace internal\n            }  // namespace v8\n        ]]></code>\n    </namespace>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AccountingAllocator\",\n                \"about\": \"Abstracts memory allocation accounting.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class AccountingAllocator {\n                public:\n                    virtual void TraceZoneCreation(Zone* zone) = 0;\n                    virtual void TraceZoneDestruction(Zone* zone) = 0;\n                    virtual void TraceAllocateSegment(Segment* segment) = 0;\n                    virtual Segment* AllocateSegment(size_t size, bool supports_compression) = 0;\n                    virtual void ReturnSegment(Segment* segment, bool supports_compression) = 0;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Segment\",\n                \"about\": \"Represents a contiguous block of memory allocated for the zone.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Segment {\n                public:\n                    Address start() const;\n                    Address end() const;\n                    size_t capacity() const;\n                    size_t total_size() const;\n                    void set_zone(Zone* zone);\n                    void set_next(Segment* next);\n                    Segment* next() const;\n                    void ZapContents();\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}