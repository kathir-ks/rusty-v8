{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/type-oracle.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/type-oracle.h\",\n        \"file_name\": \"type-oracle.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the TypeOracle class, which manages and provides access to various types used in the Torque language within the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary standard library and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <memory>\n#include <optional>\n\n#include \"src/base/contextual.h\"\n#include \"src/torque/constants.h\"\n#include \"src/torque/declarable.h\"\n#include \"src/torque/declarations.h\"\n#include \"src/torque/types.h\"\n#include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypeOracle\",\n            \"extends\": \"base::ContextualClass<TypeOracle>\",\n            \"about\": \"Manages and provides access to various types used in the Torque language.\",\n            \"attributes\": [\n                {\n                    \"name\": \"function_pointer_types_\",\n                    \"type\": \"Deduplicator<BuiltinPointerType>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Deduplicates BuiltinPointerType objects.\"\n                },\n                {\n                    \"name\": \"all_builtin_pointer_types_\",\n                    \"type\": \"std::vector<const BuiltinPointerType*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores all BuiltinPointerType objects.\"\n                },\n                {\n                    \"name\": \"union_types_\",\n                    \"type\": \"Deduplicator<UnionType>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Deduplicates UnionType objects.\"\n                },\n                {\n                    \"name\": \"nominal_types_\",\n                    \"type\": \"std::vector<std::unique_ptr<Type>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores nominal types (e.g., AbstractType).\"\n                },\n                {\n                    \"name\": \"aggregate_types_\",\n                    \"type\": \"std::vector<std::unique_ptr<AggregateType>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores aggregate types (e.g., StructType, ClassType).\"\n                },\n                {\n                    \"name\": \"bit_field_struct_types_\",\n                    \"type\": \"std::vector<std::unique_ptr<BitFieldStructType>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores bit field struct types.\"\n                },\n                {\n                    \"name\": \"top_types_\",\n                    \"type\": \"std::vector<std::unique_ptr<Type>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores top types.\"\n                },\n                {\n                    \"name\": \"generic_type_instantiation_namespaces_\",\n                    \"type\": \"std::vector<std::unique_ptr<Namespace>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores namespaces created for generic type instantiations.\"\n                },\n                {\n                    \"name\": \"next_type_id_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Counter used to assign unique IDs to types.\"\n                }\n            ],\n            \"dependencies\": [\n                \"base::ContextualClass\",\n                \"AbstractType\",\n                \"StructType\",\n                \"BitFieldStructType\",\n                \"ClassType\",\n                \"BuiltinPointerType\",\n                \"Type\",\n                \"TypeVector\",\n                \"GenericType\",\n                \"UnionType\",\n                \"TopType\",\n                \"Namespace\",\n                \"StructDeclaration\",\n                \"BitFieldStructDeclaration\",\n                \"ClassDeclaration\",\n                \"TypeAlias\",\n                \"Deduplicator\",\n                \"Declarations\",\n                \"QualifiedName\",\n                \"GenericCallable\",\n                \"Callable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass TypeOracle : public base::ContextualClass<TypeOracle> {\n public:\n  static const AbstractType* GetAbstractType(\n      const Type* parent, std::string name, AbstractTypeFlags flags,\n      std::string generated, const Type* non_constexpr_version,\n      MaybeSpecializationKey specialized_from);\n\n  static StructType* GetStructType(const StructDeclaration* decl,\n                                   MaybeSpecializationKey specialized_from);\n\n  static BitFieldStructType* GetBitFieldStructType(\n      const Type* parent, const BitFieldStructDeclaration* decl);\n\n  static ClassType* GetClassType(const Type* parent, const std::string& name,\n                                 ClassFlags flags, const std::string& generates,\n                                 ClassDeclaration* decl,\n                                 const TypeAlias* alias);\n\n  static const BuiltinPointerType* GetBuiltinPointerType(\n      TypeVector argument_types, const Type* return_type);\n\n  static const Type* GetGenericTypeInstance(GenericType* generic_type,\n                                            TypeVector arg_types);\n\n  static GenericType* GetReferenceGeneric(bool is_const);\n  static GenericType* GetConstReferenceGeneric() {\n    return GetReferenceGeneric(true);\n  }\n  static GenericType* GetMutableReferenceGeneric() {\n    return GetReferenceGeneric(false);\n  }\n\n  static std::optional<const Type*> MatchReferenceGeneric(\n      const Type* reference_type, bool* is_const = nullptr);\n\n  static GenericType* GetMutableSliceGeneric() {\n    return Declarations::LookupUniqueGenericType(\n        QualifiedName(MUTABLE_SLICE_TYPE_STRING));\n  }\n  static GenericType* GetConstSliceGeneric() {\n    return Declarations::LookupUniqueGenericType(\n        QualifiedName(CONST_SLICE_TYPE_STRING));\n  }\n\n  static GenericType* GetWeakGeneric() {\n    return Declarations::LookupGlobalUniqueGenericType(WEAK_TYPE_STRING);\n  }\n\n  static GenericType* GetSmiTaggedGeneric() {\n    return Declarations::LookupGlobalUniqueGenericType(SMI_TAGGED_TYPE_STRING);\n  }\n\n  static GenericType* GetLazyGeneric() {\n    return Declarations::LookupGlobalUniqueGenericType(LAZY_TYPE_STRING);\n  }\n\n  static const Type* GetReferenceType(const Type* referenced_type,\n                                      bool is_const) {\n    return GetGenericTypeInstance(GetReferenceGeneric(is_const),\n                                  {referenced_type});\n  }\n  static const Type* GetConstReferenceType(const Type* referenced_type) {\n    return GetReferenceType(referenced_type, true);\n  }\n  static const Type* GetMutableReferenceType(const Type* referenced_type) {\n    return GetReferenceType(referenced_type, false);\n  }\n\n  static const Type* GetMutableSliceType(const Type* referenced_type) {\n    return GetGenericTypeInstance(GetMutableSliceGeneric(), {referenced_type});\n  }\n  static const Type* GetConstSliceType(const Type* referenced_type) {\n    return GetGenericTypeInstance(GetConstSliceGeneric(), {referenced_type});\n  }\n\n  static const std::vector<const BuiltinPointerType*>&\n  AllBuiltinPointerTypes() {\n    return Get().all_builtin_pointer_types_;\n  }\n\n  static const Type* GetUnionType(UnionType type) {\n    if (std::optional<const Type*> single = type.GetSingleMember()) {\n      return *single;\n    }\n    return Get().union_types_.Add(std::move(type));\n  }\n\n  static const Type* GetUnionType(const Type* a, const Type* b) {\n    if (a->IsSubtypeOf(b)) return b;\n    if (b->IsSubtypeOf(a)) return a;\n    UnionType result = UnionType::FromType(a);\n    result.Extend(b);\n    return GetUnionType(std::move(result));\n  }\n\n  static const TopType* GetTopType(std::string reason,\n                                   const Type* source_type) {\n    std::unique_ptr<TopType> type(new TopType(std::move(reason), source_type));\n    TopType* result = type.get();\n    Get().top_types_.push_back(std::move(type));\n    return result;\n  }\n\n  static const Type* GetArgumentsType() {\n    return Get().GetBuiltinType(ARGUMENTS_TYPE_STRING);\n  }\n\n  static const Type* GetBoolType() {\n    return Get().GetBuiltinType(BOOL_TYPE_STRING);\n  }\n\n  static const Type* GetConstexprBoolType() {\n    return Get().GetBuiltinType(CONSTEXPR_BOOL_TYPE_STRING);\n  }\n\n  static const Type* GetConstexprStringType() {\n    return Get().GetBuiltinType(CONSTEXPR_STRING_TYPE_STRING);\n  }\n\n  static const Type* GetConstexprIntPtrType() {\n    return Get().GetBuiltinType(CONSTEXPR_INTPTR_TYPE_STRING);\n  }\n\n  static const Type* GetConstexprInstanceTypeType() {\n    return Get().GetBuiltinType(CONSTEXPR_INSTANCE_TYPE_TYPE_STRING);\n  }\n\n  static const Type* GetVoidType() {\n    return Get().GetBuiltinType(VOID_TYPE_STRING);\n  }\n\n  static const Type* GetRawPtrType() {\n    return Get().GetBuiltinType(RAWPTR_TYPE_STRING);\n  }\n\n  static const Type* GetExternalPointerType() {\n    return Get().GetBuiltinType(EXTERNALPTR_TYPE_STRING);\n  }\n\n  static const Type* GetCppHeapPointerType() {\n    return Get().GetBuiltinType(CPPHEAPPTR_TYPE_STRING);\n  }\n\n  static const Type* GetTrustedPointerType() {\n    return Get().GetBuiltinType(TRUSTEDPTR_TYPE_STRING);\n  }\n\n  static const Type* GetProtectedPointerType() {\n    return Get().GetBuiltinType(PROTECTEDPTR_TYPE_STRING);\n  }\n\n  static const Type* GetDispatchHandleType() {\n    return Get().GetBuiltinType(DISPATCH_HANDLE_TYPE_STRING);\n  }\n\n  static const Type* GetMapType() {\n    return Get().GetBuiltinType(MAP_TYPE_STRING);\n  }\n\n  static const Type* GetObjectType() {\n    return Get().GetBuiltinType(OBJECT_TYPE_STRING);\n  }\n\n  static const Type* GetHeapObjectType() {\n    return Get().GetBuiltinType(HEAP_OBJECT_TYPE_STRING);\n  }\n\n  static const Type* GetTaggedZeroPatternType() {\n    return Get().GetBuiltinType(TAGGED_ZERO_PATTERN_TYPE_STRING);\n  }\n\n  static const Type* GetJSAnyType() {\n    return Get().GetBuiltinType(JSANY_TYPE_STRING);\n  }\n\n  static const Type* GetJSObjectType() {\n    return Get().GetBuiltinType(JSOBJECT_TYPE_STRING);\n  }\n\n  static const Type* GetTaggedType() {\n    return Get().GetBuiltinType(TAGGED_TYPE_STRING);\n  }\n\n  static const Type* GetStrongTaggedType() {\n    return Get().GetBuiltinType(STRONG_TAGGED_TYPE_STRING);\n  }\n\n  static const Type* GetUninitializedType() {\n    return Get().GetBuiltinType(UNINITIALIZED_TYPE_STRING);\n  }\n\n  static const Type* GetUninitializedHeapObjectType() {\n    return Get().GetBuiltinType(\n        QualifiedName({TORQUE_INTERNAL_NAMESPACE_STRING},\n                      UNINITIALIZED_HEAP_OBJECT_TYPE_STRING));\n  }\n\n  static const Type* GetSmiType() {\n    return Get().GetBuiltinType(SMI_TYPE_STRING);\n  }\n\n  static const Type* GetConstStringType() {\n    return Get().GetBuiltinType(CONST_STRING_TYPE_STRING);\n  }\n\n  static const Type* GetStringType() {\n    return Get().GetBuiltinType(STRING_TYPE_STRING);\n  }\n\n  static const Type* GetNumberType() {\n    return Get().GetBuiltinType(NUMBER_TYPE_STRING);\n  }\n\n  static const Type* GetIntPtrType() {\n    return Get().GetBuiltinType(INTPTR_TYPE_STRING);\n  }\n\n  static const Type* GetUIntPtrType() {\n    return Get().GetBuiltinType(UINTPTR_TYPE_STRING);\n  }\n\n  static const Type* GetInt64Type() {\n    return Get().GetBuiltinType(INT64_TYPE_STRING);\n  }\n\n  static const Type* GetUint64Type() {\n    return Get().GetBuiltinType(UINT64_TYPE_STRING);\n  }\n\n  static const Type* GetInt32Type() {\n    return Get().GetBuiltinType(INT32_TYPE_STRING);\n  }\n\n  static const Type* GetUint32Type() {\n    return Get().GetBuiltinType(UINT32_TYPE_STRING);\n  }\n\n  static const Type* GetUint31Type() {\n    return Get().GetBuiltinType(UINT31_TYPE_STRING);\n  }\n\n  static const Type* GetInt16Type() {\n    return Get().GetBuiltinType(INT16_TYPE_STRING);\n  }\n\n  static const Type* GetUint16Type() {\n    return Get().GetBuiltinType(UINT16_TYPE_STRING);\n  }\n\n  static const Type* GetInt8Type() {\n    return Get().GetBuiltinType(INT8_TYPE_STRING);\n  }\n\n  static const Type* GetUint8Type() {\n    return Get().GetBuiltinType(UINT8_TYPE_STRING);\n  }\n\n  static const Type* GetFloat64Type() {\n    return Get().GetBuiltinType(FLOAT64_TYPE_STRING);\n  }\n\n  static const Type* GetFloat64OrUndefinedOrHoleType() {\n    return Get().GetBuiltinType(FLOAT64_OR_UNDEFINED_OR_HOLE_TYPE_STRING);\n  }\n\n  static const Type* GetConstFloat64Type() {\n    return Get().GetBuiltinType(CONST_FLOAT64_TYPE_STRING);\n  }\n\n  static const Type* GetIntegerLiteralType() {\n    return Get().GetBuiltinType(INTEGER_LITERAL_TYPE_STRING);\n  }\n\n  static const Type* GetNeverType() {\n    return Get().GetBuiltinType(NEVER_TYPE_STRING);\n  }\n\n  static const Type* GetConstInt31Type() {\n    return Get().GetBuiltinType(CONST_INT31_TYPE_STRING);\n  }\n\n  static const Type* GetConstInt32Type() {\n    return Get().GetBuiltinType(CONST_INT32_TYPE_STRING);\n  }\n\n  static const Type* GetContextType() {\n    return Get().GetBuiltinType(CONTEXT_TYPE_STRING);\n  }\n\n  static const Type* GetNoContextType() {\n    return Get().GetBuiltinType(NO_CONTEXT_TYPE_STRING);\n  }\n\n  static const Type* GetNativeContextType() {\n    return Get().GetBuiltinType(NATIVE_CONTEXT_TYPE_STRING);\n  }\n\n  static const Type* GetJSFunctionType() {\n    return Get().GetBuiltinType(JS_FUNCTION_TYPE_STRING);\n  }\n\n  static const Type* GetUninitializedIteratorType() {\n    return Get().GetBuiltinType(UNINITIALIZED_ITERATOR_TYPE_STRING);\n  }\n\n  static const Type* GetFixedArrayBaseType() {\n    return Get().GetBuiltinType(FIXED_ARRAY_BASE_TYPE_STRING);\n  }\n\n  static std::optional<const Type*> ImplicitlyConvertableFrom(\n      const Type* to, const Type* from) {\n    while (from != nullptr) {\n      for (GenericCallable* from_constexpr :\n           Declarations::LookupGeneric(kFromConstexprMacroName)) {\n        if (std::optional<const Callable*> specialization =\n                from_constexpr->GetSpecialization({to, from})) {\n          if ((*specialization)->signature().GetExplicitTypes() ==\n              TypeVector{from}) {\n            return from;\n          }\n        }\n      }\n      from = from->parent();\n    }\n    return std::nullopt;\n  }\n\n  static const std::vector<std::unique_ptr<AggregateType>>& GetAggregateTypes();\n  static const std::vector<std::unique_ptr<BitFieldStructType>>&\n  GetBitFieldStructTypes();\n\n  // By construction, this list of all classes is topologically sorted w.r.t.\n  // inheritance.\n  static std::vector<const ClassType*> GetClasses();\n\n  static void FinalizeAggregateTypes();\n\n  static size_t FreshTypeId() { return Get().next_type_id_++; }\n\n  static Namespace* CreateGenericTypeInstantiationNamespace();\n\n private:\n  const Type* GetBuiltinType(const QualifiedName& name) {\n    return Declarations::LookupGlobalType(name);\n  }\n  const Type* GetBuiltinType(const std::string& name) {\n    return GetBuiltinType(QualifiedName(name));\n  }\n\n  Deduplicator<BuiltinPointerType> function_pointer_types_;\n  std::vector<const BuiltinPointerType*> all_builtin_pointer_types_;\n  Deduplicator<UnionType> union_types_;\n  std::vector<std::unique_ptr<Type>> nominal_types_;\n  std::vector<std::unique_ptr<AggregateType>> aggregate_types_;\n  std::vector<std::unique_ptr<BitFieldStructType>> bit_field_struct_types_;\n  std::vector<std::unique_ptr<Type>> top_types_;\n  std::vector<std::unique_ptr<Namespace>>\n      generic_type_instantiation_namespaces_;\n  size_t next_type_id_ = 0;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetAbstractType\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves or creates an AbstractType.\",\n            \"logic\": \"Creates a new AbstractType with the given parameters and stores it in the nominal_types_ vector. If a non-constexpr version is provided, it sets the constexpr version of that type to the newly created type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parent\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The parent type.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The name of the abstract type.\"\n                },\n                {\n                    \"name\": \"flags\",\n                    \"type\": \"AbstractTypeFlags\",\n                    \"purpose\": \"Flags associated with the abstract type.\"\n                },\n                {\n                    \"name\": \"generated\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"Indicates if the type is generated.\"\n                },\n                {\n                    \"name\": \"non_constexpr_version\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The non-constexpr version of the type, if any.\"\n                },\n                {\n                    \"name\": \"specialized_from\",\n                    \"type\": \"MaybeSpecializationKey\",\n                    \"purpose\": \"Specialization key (if specialized from a generic)\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const AbstractType*\",\n                \"description\": \"A pointer to the created AbstractType.\"\n            },\n            \"dependencies\": [\n                \"AbstractType\",\n                \"std::unique_ptr\",\n                \"Type\",\n                \"AbstractTypeFlags\",\n                \"MaybeSpecializationKey\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static const AbstractType* GetAbstractType(\n      const Type* parent, std::string name, AbstractTypeFlags flags,\n      std::string generated, const Type* non_constexpr_version,\n      MaybeSpecializationKey specialized_from) {\n    auto ptr = std::unique_ptr<AbstractType>(\n        new AbstractType(parent, flags, std::move(name), std::move(generated),\n                         non_constexpr_version, specialized_from));\n    const AbstractType* result = ptr.get();\n    if (non_constexpr_version) {\n      DCHECK(ptr->IsConstexpr());\n      non_constexpr_version->SetConstexprVersion(result);\n    }\n    Get().nominal_types_.push_back(std::move(ptr));\n    return result;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetStructType\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves or creates a StructType.\",\n            \"logic\": \"Creates a new StructType with the given StructDeclaration and stores it in the aggregate_types_ vector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"decl\",\n                    \"type\": \"const StructDeclaration*\",\n                    \"purpose\": \"The StructDeclaration for the struct.\"\n                },\n                {\n                    \"name\": \"specialized_from\",\n                    \"type\": \"MaybeSpecializationKey\",\n                    \"purpose\": \"Specialization key (if specialized from a generic)\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"StructType*\",\n                \"description\": \"A pointer to the created StructType.\"\n            },\n            \"dependencies\": [\n                \"StructType\",\n                \"std::unique_ptr\",\n                \"StructDeclaration\",\n                \"MaybeSpecializationKey\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static StructType* GetStructType(const StructDeclaration* decl,\n                                   MaybeSpecializationKey specialized_from) {\n    auto ptr = std::unique_ptr<StructType>(\n        new StructType(CurrentNamespace(), decl, specialized_from));\n    StructType* result = ptr.get();\n    Get().aggregate_types_.push_back(std::move(ptr));\n    return result;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetBitFieldStructType\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves or creates a BitFieldStructType.\",\n            \"logic\": \"Creates a new BitFieldStructType with the given parent type and BitFieldStructDeclaration, and stores it in the bit_field_struct_types_ vector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parent\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The parent type.\"\n                },\n                {\n                    \"name\": \"decl\",\n                    \"type\": \"const BitFieldStructDeclaration*\",\n                    \"purpose\": \"The BitFieldStructDeclaration for the struct.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"BitFieldStructType*\",\n                \"description\": \"A pointer to the created BitFieldStructType.\"\n            },\n            \"dependencies\": [\n                \"BitFieldStructType\",\n                \"std::unique_ptr\",\n                \"Type\",\n                \"BitFieldStructDeclaration\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static BitFieldStructType* GetBitFieldStructType(\n      const Type* parent, const BitFieldStructDeclaration* decl) {\n    auto ptr = std::unique_ptr<BitFieldStructType>(\n        new BitFieldStructType(CurrentNamespace(), parent, decl));\n    BitFieldStructType* result = ptr.get();\n    Get().bit_field_struct_types_.push_back(std::move(ptr));\n    return result;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetClassType\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves or creates a ClassType.\",\n            \"logic\": \"Creates a new ClassType with the given parameters and stores it in the aggregate_types_ vector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parent\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The parent type.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The name of the class.\"\n                },\n                {\n                    \"name\": \"flags\",\n                    \"type\": \"ClassFlags\",\n                    \"purpose\": \"Flags associated with the class.\"\n                },\n                {\n                    \"name\": \"generates\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"Indicates if the class generates code.\"\n                },\n                {\n                    \"name\": \"decl\",\n                    \"type\": \"ClassDeclaration*\",\n                    \"purpose\": \"The ClassDeclaration for the class.\"\n                },\n                {\n                    \"name\": \"alias\",\n                    \"type\": \"const TypeAlias*\",\n                    \"purpose\": \"The TypeAlias for the class.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ClassType*\",\n                \"description\": \"A pointer to the created ClassType.\"\n            },\n            \"dependencies\": [\n                \"ClassType\",\n                \"std::unique_ptr\",\n                \"Type\",\n                \"ClassFlags\",\n                \"ClassDeclaration\",\n                \"TypeAlias\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static ClassType* GetClassType(const Type* parent, const std::string& name,\n                                 ClassFlags flags, const std::string& generates,\n                                 ClassDeclaration* decl,\n                                 const TypeAlias* alias) {\n    std::unique_ptr<ClassType> type(new ClassType(\n        parent, CurrentNamespace(), name, flags, generates, decl, alias));\n    ClassType* result = type.get();\n    Get().aggregate_types_.push_back(std::move(type));\n    return result;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetBuiltinPointerType\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves or creates a BuiltinPointerType.\",\n            \"logic\": \"Uses a Deduplicator to ensure that only unique BuiltinPointerType objects are created. Stores all created BuiltinPointerType objects in a vector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"argument_types\",\n                    \"type\": \"TypeVector\",\n                    \"purpose\": \"The argument types of the function pointer.\"\n                },\n                {\n                    \"name\": \"return_type\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"The return type of the function pointer.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const BuiltinPointerType*\",\n                \"description\": \"A pointer to the created or existing BuiltinPointerType.\"\n            },\n            \"dependencies\": [\n                \"BuiltinPointerType\",\n                \"Type\",\n                \"TypeVector\",\n                \"Deduplicator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static const BuiltinPointerType* GetBuiltinPointerType(\n      TypeVector argument_types, const Type* return_type) {\n    TypeOracle& self = Get();\n    const Type* builtin_type = self.GetBuiltinType(BUILTIN_POINTER_TYPE_STRING);\n    const BuiltinPointerType* result = self.function_pointer_types_.Add(\n        BuiltinPointerType(builtin_type, std::move(argument_types), return_type,\n                           self.all_builtin_pointer_types_.size()));\n    if (result->function_pointer_type_id() ==\n        self.all_builtin_pointer_types_.size()) {\n      self.all_builtin_pointer_types_.push_back(result);\n    }\n    return result;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetGenericTypeInstance\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves or creates an instance of a generic type.\",\n            \"logic\": \"This method is declared but not defined in the provided code snippet. Likely involves substituting type arguments into a generic type definition.\",\n            \"parameters\": [\n                {\n                    \"name\": \"generic_type\",\n                    \"type\": \"GenericType*\",\n                    \"purpose\": \"The generic type.\"\n                },\n                {\n                    \"name\": \"arg_types\",\n                    \"type\": \"TypeVector\",\n                    \"purpose\": \"The type arguments to the generic type.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const Type*\",\n                \"description\": \"A pointer to the instantiated type.\"\n            },\n            \"dependencies\": [\n                \"GenericType\",\n                \"Type\",\n                \"TypeVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static const Type* GetGenericTypeInstance(GenericType* generic_type,\n                                            TypeVector arg_types);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetReferenceGeneric\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves the GenericType for a reference (const or mutable).\",\n            \"logic\": \"Looks up the GenericType by its qualified name using Declarations::LookupUniqueGenericType.\",\n            \"parameters\": [\n                {\n                    \"name\": \"is_const\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the reference is const.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"GenericType*\",\n                \"description\": \"A pointer to the GenericType representing the reference.\"\n            },\n            \"dependencies\": [\n                \"GenericType\",\n                \"Declarations\",\n                \"QualifiedName\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static GenericType* GetReferenceGeneric(bool is_const) {\n    return Declarations::LookupUniqueGenericType(\n        QualifiedName({TORQUE_INTERNAL_NAMESPACE_STRING},\n                      is_const ? CONST_REFERENCE_TYPE_STRING\n                               : MUTABLE_REFERENCE_TYPE_STRING));\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetConstReferenceGeneric\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves the GenericType for a const reference.\",\n            \"logic\": \"Calls GetReferenceGeneric(true).\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"GenericType*\",\n                \"description\": \"A pointer to the GenericType representing the const reference.\"\n            },\n            \"dependencies\": [\n                \"GetReferenceGeneric\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static GenericType* GetConstReferenceGeneric() {\n    return GetReferenceGeneric(true);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetMutableReferenceGeneric\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves the GenericType for a mutable reference.\",\n            \"logic\": \"Calls GetReferenceGeneric(false).\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"GenericType*\",\n                \"description\": \"A pointer to the GenericType representing the mutable reference.\"\n            },\n            \"dependencies\": [\n                \"GetReferenceGeneric\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static GenericType* GetMutableReferenceGeneric() {\n    return GetReferenceGeneric(false);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MatchReferenceGeneric\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Attempts to match a given Type* to the known Reference Generics\",\n            \"logic\": \"This method is declared but not defined in the provided code snippet. Likely involves comparing given types to reference generic definitions\",\n            \"parameters\": [\n                {\n                    \"name\": \"reference_type\",\n                    \"type\": \"const Type*\",\n                    \"purpose\": \"A pointer to the type you're trying to match to a reference generic.\"\n                },\n                {\n                    \"name\": \"is_const\",\n                    \"type\": \"bool*\",\n                    \"purpose\": \"A pointer to a bool which will be set to true/false if match is found to a const/mutable reference type respectively.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<const Type*>\",\n                \"description\": \"If given reference_type matches a reference generic, an optional Type* to it is returned.\"\n            },\n            \"dependencies\": [\n                \"Type\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static std::optional<const Type*> MatchReferenceGeneric(\n      const Type* reference_type, bool* is_const = nullptr);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetMutableSliceGeneric\",\n            \"parent\": \"TypeOracle\",\n            \"about\": \"Retrieves the GenericType for a mutable slice.\",\n            \"logic\": \"Looks up the GenericType by its qualified name using Declarations::LookupUniqueGenericType.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"GenericType*\",\n                \"description\": \"A pointer to the GenericType representing the mutable slice.\"\n            },\n            \"dependencies\": [\n                \"GenericType\",\n                \"Declarations\",\n                \"QualifiedName\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static GenericType* GetMutableSliceGeneric() {\n    return Declarations::LookupUniqueGenericType(\n        QualifiedName(MUTABLE_SLICE_"
}