{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/typed-optimization.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/typed-optimization.cc\",\n        \"file_name\": \"typed-optimization.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Performs type-based optimizations on the V8 compiler's intermediate representation (IR) graph.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for compiler, data structures, and utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/typed-optimization.h\"\n\n#include <optional>\n\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/type-cache.h\"\n#include \"src/execution/isolate-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypedOptimization\",\n            \"extends\": \"AdvancedReducer\",\n            \"about\": \"Performs type-based optimizations on the V8 compiler's IR graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"dependencies_\",\n                    \"type\": \"CompilationDependencies*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Keeps track of compilation dependencies.\"\n                },\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the JavaScript graph.\"\n                },\n                {\n                    \"name\": \"broker_\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the JavaScript heap broker.\"\n                },\n                {\n                    \"name\": \"true_type_\",\n                    \"type\": \"Type\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Represents the type of the true value.\"\n                },\n                {\n                    \"name\": \"false_type_\",\n                    \"type\": \"Type\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Represents the type of the false value.\"\n                },\n                {\n                    \"name\": \"type_cache_\",\n                    \"type\": \"TypeCache*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the type cache.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AdvancedReducer\",\n                \"CompilationDependencies\",\n                \"JSGraph\",\n                \"JSHeapBroker\",\n                \"Type\",\n                \"TypeCache\",\n                \"Node\",\n                \"Editor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass TypedOptimization : public AdvancedReducer {\n public:\n  TypedOptimization(Editor* editor, CompilationDependencies* dependencies,\n                      JSGraph* jsgraph, JSHeapBroker* broker);\n  ~TypedOptimization() override;\n\n  Reduction Reduce(Node* node) override;\n\n private:\n  Reduction ReduceConvertReceiver(Node* node);\n  Reduction ReduceCheckHeapObject(Node* node);\n  Reduction ReduceMaybeGrowFastElements(Node* node);\n  Reduction ReduceCheckBounds(Node* node);\n  Reduction ReduceCheckNotTaggedHole(Node* node);\n  Reduction ReduceCheckMaps(Node* node);\n  Reduction ReduceCheckNumber(Node* node);\n  Reduction ReduceCheckNumberFitsInt32(Node* node);\n  Reduction ReduceCheckString(Node* node);\n  Reduction ReduceCheckStringOrStringWrapper(Node* node);\n  Reduction ReduceCheckEqualsInternalizedString(Node* node);\n  Reduction ReduceCheckEqualsSymbol(Node* node);\n  Reduction ReduceLoadField(Node* node);\n  Reduction ReduceNumberFloor(Node* node);\n  Reduction ReduceNumberRoundop(Node* node);\n  Reduction ReduceNumberSilenceNaN(Node* node);\n  Reduction ReduceNumberToUint8Clamped(Node* node);\n  Reduction ReducePhi(Node* node);\n  Reduction ReduceReferenceEqual(Node* node);\n  Reduction ReduceStringComparison(Node* node);\n  Reduction ReduceStringLength(Node* node);\n  Reduction ReduceSameValue(Node* node);\n  Reduction ReduceSelect(Node* node);\n  Reduction ReduceSpeculativeToNumber(Node* node);\n  Reduction ReduceTypedArrayLength(Node* node);\n  Reduction ReduceTypeOf(Node* node);\n  Reduction ReduceToBoolean(Node* node);\n  Reduction ReduceSpeculativeNumberAdd(Node* node);\n  Reduction ReduceSpeculativeNumberBinop(Node* node);\n  Reduction ReduceSpeculativeNumberComparison(Node* node);\n  Reduction ReduceTransitionElementsKindOrCheckMap(Node* node);\n\n  Node* ConvertPlainPrimitiveToNumber(Node* node);\n  Reduction ReduceJSToNumberInput(Node* input);\n\n  Factory* factory() const;\n  TFGraph* graph() const;\n  SimplifiedOperatorBuilder* simplified() const;\n\n  const Operator* NumberComparisonFor(const Operator* op);\n  Reduction TryReduceStringComparisonOfStringFromSingleCharCodeToConstant(\n      Node* comparison, StringRef string, bool inverted);\n  Reduction TryReduceStringComparisonOfStringFromSingleCharCode(\n      Node* comparison, Node* from_char_code, Type constant_type,\n      bool inverted);\n\n  CompilationDependencies* dependencies_;\n  JSGraph* jsgraph_;\n  JSHeapBroker* broker_;\n  Type true_type_;\n  Type false_type_;\n  TypeCache* type_cache_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TypedOptimization\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Constructor for the TypedOptimization class.\",\n            \"logic\": \"Initializes the member variables.\",\n            \"parameters\": [\n                {\n                    \"name\": \"editor\",\n                    \"type\": \"Editor*\",\n                    \"purpose\": \"The editor for modifying the IR graph.\"\n                },\n                {\n                    \"name\": \"dependencies\",\n                    \"type\": \"CompilationDependencies*\",\n                    \"purpose\": \"Keeps track of compilation dependencies.\"\n                },\n                {\n                    \"name\": \"jsgraph\",\n                    \"type\": \"JSGraph*\",\n                    \"purpose\": \"Provides access to the JavaScript graph.\"\n                },\n                {\n                    \"name\": \"broker\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"purpose\": \"Provides access to the JavaScript heap broker.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"AdvancedReducer\",\n                \"Type\",\n                \"TypeCache\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTypedOptimization::TypedOptimization(Editor* editor,\n                                     CompilationDependencies* dependencies,\n                                     JSGraph* jsgraph, JSHeapBroker* broker)\n    : AdvancedReducer(editor),\n      dependencies_(dependencies),\n      jsgraph_(jsgraph),\n      broker_(broker),\n      true_type_(Type::Constant(broker, broker->true_value(), graph()->zone())),\n      false_type_(\n          Type::Constant(broker, broker->false_value(), graph()->zone())),\n      type_cache_(TypeCache::Get()) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"~TypedOptimization\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Destructor for the TypedOptimization class.\",\n            \"logic\": \"The default destructor.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nTypedOptimization::~TypedOptimization() = default;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces the given node based on its opcode and type information.\",\n            \"logic\": \"A large switch statement handles different opcodes. Each case attempts to perform type-based optimizations specific to that opcode.  The general strategy involves checking the input types of the node and, if certain type conditions are met, replacing the node with a simpler or more efficient equivalent.  This could involve direct replacement with an input, replacing the operator, or constant folding.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": [\n                \"ReduceConvertReceiver\",\n                \"ReduceCheckHeapObject\",\n                \"ReduceMaybeGrowFastElements\",\n                \"ReduceCheckBounds\",\n                \"ReduceCheckNotTaggedHole\",\n                \"ReduceCheckMaps\",\n                \"ReduceCheckNumber\",\n                \"ReduceCheckNumberFitsInt32\",\n                \"ReduceCheckString\",\n                \"ReduceCheckStringOrStringWrapper\",\n                \"ReduceCheckEqualsInternalizedString\",\n                \"ReduceCheckEqualsSymbol\",\n                \"ReduceLoadField\",\n                \"ReduceNumberFloor\",\n                \"ReduceNumberRoundop\",\n                \"ReduceNumberSilenceNaN\",\n                \"ReduceNumberToUint8Clamped\",\n                \"ReducePhi\",\n                \"ReduceReferenceEqual\",\n                \"ReduceStringComparison\",\n                \"ReduceStringLength\",\n                \"ReduceSameValue\",\n                \"ReduceSelect\",\n                \"ReduceSpeculativeToNumber\",\n                \"ReduceTypedArrayLength\",\n                \"ReduceTypeOf\",\n                \"ReduceToBoolean\",\n                \"ReduceSpeculativeNumberAdd\",\n                \"ReduceSpeculativeNumberBinop\",\n                \"ReduceSpeculativeNumberComparison\",\n                \"ReduceTransitionElementsKindOrCheckMap\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kConvertReceiver:\n      return ReduceConvertReceiver(node);\n    case IrOpcode::kMaybeGrowFastElements:\n      return ReduceMaybeGrowFastElements(node);\n    case IrOpcode::kCheckHeapObject:\n      return ReduceCheckHeapObject(node);\n    case IrOpcode::kCheckBounds:\n      return ReduceCheckBounds(node);\n    case IrOpcode::kCheckNotTaggedHole:\n      return ReduceCheckNotTaggedHole(node);\n    case IrOpcode::kCheckMaps:\n      return ReduceCheckMaps(node);\n    case IrOpcode::kCheckNumber:\n      return ReduceCheckNumber(node);\n    case IrOpcode::kCheckNumberFitsInt32:\n      return ReduceCheckNumberFitsInt32(node);\n    case IrOpcode::kCheckString:\n      return ReduceCheckString(node);\n    case IrOpcode::kCheckStringOrStringWrapper:\n      return ReduceCheckStringOrStringWrapper(node);\n    case IrOpcode::kCheckEqualsInternalizedString:\n      return ReduceCheckEqualsInternalizedString(node);\n    case IrOpcode::kCheckEqualsSymbol:\n      return ReduceCheckEqualsSymbol(node);\n    case IrOpcode::kLoadField:\n      return ReduceLoadField(node);\n    case IrOpcode::kNumberCeil:\n    case IrOpcode::kNumberRound:\n    case IrOpcode::kNumberTrunc:\n      return ReduceNumberRoundop(node);\n    case IrOpcode::kNumberFloor:\n      return ReduceNumberFloor(node);\n    case IrOpcode::kNumberSilenceNaN:\n      return ReduceNumberSilenceNaN(node);\n    case IrOpcode::kNumberToUint8Clamped:\n      return ReduceNumberToUint8Clamped(node);\n    case IrOpcode::kPhi:\n      return ReducePhi(node);\n    case IrOpcode::kReferenceEqual:\n      return ReduceReferenceEqual(node);\n    case IrOpcode::kStringEqual:\n    case IrOpcode::kStringLessThan:\n    case IrOpcode::kStringLessThanOrEqual:\n      return ReduceStringComparison(node);\n    case IrOpcode::kStringLength:\n      return ReduceStringLength(node);\n    case IrOpcode::kSameValue:\n      return ReduceSameValue(node);\n    case IrOpcode::kSelect:\n      return ReduceSelect(node);\n    case IrOpcode::kTypedArrayLength:\n      return ReduceTypedArrayLength(node);\n    case IrOpcode::kTypeOf:\n      return ReduceTypeOf(node);\n    case IrOpcode::kToBoolean:\n      return ReduceToBoolean(node);\n    case IrOpcode::kSpeculativeToNumber:\n      return ReduceSpeculativeToNumber(node);\n    case IrOpcode::kSpeculativeNumberAdd:\n      return ReduceSpeculativeNumberAdd(node);\n    case IrOpcode::kSpeculativeNumberSubtract:\n    case IrOpcode::kSpeculativeNumberMultiply:\n    case IrOpcode::kSpeculativeNumberPow:\n    case IrOpcode::kSpeculativeNumberDivide:\n    case IrOpcode::kSpeculativeNumberModulus:\n      return ReduceSpeculativeNumberBinop(node);\n    case IrOpcode::kSpeculativeNumberEqual:\n    case IrOpcode::kSpeculativeNumberLessThan:\n    case IrOpcode::kSpeculativeNumberLessThanOrEqual:\n      return ReduceSpeculativeNumberComparison(node);\n    case IrOpcode::kTransitionElementsKindOrCheckMap:\n      return ReduceTransitionElementsKindOrCheckMap(node);\n    default:\n      break;\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceConvertReceiver\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a ConvertReceiver node based on the input type.\",\n            \"logic\": \"If the input is already a Receiver, the ConvertReceiver node is replaced with the input. If the input is NullOrUndefined, it's replaced with the global proxy.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The ConvertReceiver node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceConvertReceiver(Node* node) {\n  Node* const value = NodeProperties::GetValueInput(node, 0);\n  Type const value_type = NodeProperties::GetType(value);\n  Node* const global_proxy = NodeProperties::GetValueInput(node, 2);\n  if (value_type.Is(Type::Receiver())) {\n    ReplaceWithValue(node, value);\n    return Replace(value);\n  } else if (value_type.Is(Type::NullOrUndefined())) {\n    ReplaceWithValue(node, global_proxy);\n    return Replace(global_proxy);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckHeapObject\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckHeapObject node based on the input type.\",\n            \"logic\": \"If the input is not potentially a SignedSmall (Smi), the CheckHeapObject node is redundant and is replaced with the input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckHeapObject node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckHeapObject(Node* node) {\n  Node* const input = NodeProperties::GetValueInput(node, 0);\n  Type const input_type = NodeProperties::GetType(input);\n  if (!input_type.Maybe(Type::SignedSmall())) {\n    ReplaceWithValue(node, input);\n    return Replace(input);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceMaybeGrowFastElements\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a MaybeGrowFastElements node based on the input types.\",\n            \"logic\": \"If the index is known to be within the bounds of the length, the MaybeGrowFastElements node can be replaced with the elements node. In turbo_typer_hardening mode, a check bounds node will be introduced.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The MaybeGrowFastElements node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceMaybeGrowFastElements(Node* node) {\n  Node* const elements = NodeProperties::GetValueInput(node, 1);\n  Node* const index = NodeProperties::GetValueInput(node, 2);\n  Node* const length = NodeProperties::GetValueInput(node, 3);\n  Node* const effect = NodeProperties::GetEffectInput(node);\n  Node* const control = NodeProperties::GetControlInput(node);\n\n  Type const index_type = NodeProperties::GetType(index);\n  Type const length_type = NodeProperties::GetType(length);\n  CHECK(index_type.Is(Type::Unsigned31()));\n  CHECK(length_type.Is(Type::Unsigned31()));\n\n  if (!index_type.IsNone() && !length_type.IsNone() &&\n      index_type.Max() < length_type.Min()) {\n    if (v8_flags.turbo_typer_hardening) {\n      Node* check_bounds = graph()->NewNode(\n          simplified()->CheckBounds(FeedbackSource{},\n                                    CheckBoundsFlag::kAbortOnOutOfBounds),\n          index, length, effect, control);\n      ReplaceWithValue(node, elements, check_bounds);\n      return Replace(check_bounds);\n    } else {\n      RelaxEffectsAndControls(node);\n      return Replace(elements);\n    }\n  }\n\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckBounds\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckBounds node based on the input type.\",\n            \"logic\": \"If the CheckBounds node attempts to convert strings and minus zero when it doesn't need to, it removes those flags to improve performance.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckBounds node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckBounds(Node* node) {\n  CheckBoundsParameters const& p = CheckBoundsParametersOf(node->op());\n  Node* const input = NodeProperties::GetValueInput(node, 0);\n  Type const input_type = NodeProperties::GetType(input);\n  if (p.flags() & CheckBoundsFlag::kConvertStringAndMinusZero &&\n      !input_type.Maybe(Type::String()) &&\n      !input_type.Maybe(Type::MinusZero())) {\n    NodeProperties::ChangeOp(\n        node,\n        simplified()->CheckBounds(\n            p.check_parameters().feedback(),\n            p.flags().without(CheckBoundsFlag::kConvertStringAndMinusZero)));\n    return Changed(node);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckNotTaggedHole\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckNotTaggedHole node based on the input type.\",\n            \"logic\": \"If the input cannot be a tagged hole value, the CheckNotTaggedHole node is redundant and is replaced with the input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckNotTaggedHole node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckNotTaggedHole(Node* node) {\n  Node* const input = NodeProperties::GetValueInput(node, 0);\n  Type const input_type = NodeProperties::GetType(input);\n  if (!input_type.Maybe(Type::Hole())) {\n    ReplaceWithValue(node, input);\n    return Replace(input);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckMaps\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckMaps node if the object's map is stable and matches one of the expected maps.\",\n            \"logic\": \"If the object is a constant and its map is stable and matches one of the expected maps, the CheckMaps node can be replaced with an effect node. This is based on the principle of map stability and code dependencies on map transitions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckMaps node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": [\n                \"GetStableMapFromObjectType\",\n                \"CheckMapsHelper\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckMaps(Node* node) {\n  Node* const object = NodeProperties::GetValueInput(node, 0);\n  Type const object_type = NodeProperties::GetType(object);\n  Node* const effect = NodeProperties::GetEffectInput(node);\n  OptionalMapRef object_map = GetStableMapFromObjectType(broker(), object_type);\n  CheckMapsParameters p = CheckMapsParametersOf(node->op());\n  if (CheckMapsHelper(object_map, p.maps(), dependencies())) {\n    return Replace(effect);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceTransitionElementsKindOrCheckMap\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a TransitionElementsKindOrCheckMap node if the object's map is stable and matches one of the expected maps.\",\n            \"logic\": \"If the object is a constant and its map is stable and matches one of the expected maps, the TransitionElementsKindOrCheckMap node can be replaced with an effect node. This is based on the principle of map stability and code dependencies on map transitions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The TransitionElementsKindOrCheckMap node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": [\n                \"GetStableMapFromObjectType\",\n                \"CheckMapsHelper\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceTransitionElementsKindOrCheckMap(\n    Node* node) {\n  Node* const object = NodeProperties::GetValueInput(node, 0);\n  Type const object_type = NodeProperties::GetType(object);\n  Node* const effect = NodeProperties::GetEffectInput(node);\n  OptionalMapRef object_map = GetStableMapFromObjectType(broker(), object_type);\n  ElementsTransitionWithMultipleSources p =\n      ElementsTransitionWithMultipleSourcesOf(node->op());\n  if (CheckMapsHelper(object_map, ZoneRefSet<Map>(p.target()),\n                      dependencies())) {\n    return Replace(effect);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckNumber\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckNumber node based on the input type.\",\n            \"logic\": \"If the input is already known to be a Number, the CheckNumber node is redundant and is replaced with the input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckNumber node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckNumber(Node* node) {\n  Node* const input = NodeProperties::GetValueInput(node, 0);\n  Type const input_type = NodeProperties::GetType(input);\n  if (input_type.Is(Type::Number())) {\n    ReplaceWithValue(node, input);\n    return Replace(input);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckNumberFitsInt32\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckNumberFitsInt32 node based on the input type.\",\n            \"logic\": \"If the input is already known to be a Signed32, the CheckNumberFitsInt32 node is redundant and is replaced with the input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckNumberFitsInt32 node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckNumberFitsInt32(Node* node) {\n  Node* const input = NodeProperties::GetValueInput(node, 0);\n  Type const input_type = NodeProperties::GetType(input);\n  if (input_type.Is(Type::Signed32())) {\n    ReplaceWithValue(node, input);\n    return Replace(input);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckString\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckString node based on the input type.\",\n            \"logic\": \"If the input is already known to be a String, the CheckString node is redundant and is replaced with the input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckString node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckString(Node* node) {\n  Node* const input = NodeProperties::GetValueInput(node, 0);\n  Type const input_type = NodeProperties::GetType(input);\n  if (input_type.Is(Type::String())) {\n    ReplaceWithValue(node, input);\n    return Replace(input);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckStringOrStringWrapper\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckStringOrStringWrapper node based on the input type.\",\n            \"logic\": \"If the input is already known to be a StringOrStringWrapper, the CheckStringOrStringWrapper node is redundant and is replaced with the input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckStringOrStringWrapper node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckStringOrStringWrapper(Node* node) {\n  Node* const input = NodeProperties::GetValueInput(node, 0);\n  Type const input_type = NodeProperties::GetType(input);\n  if (input_type.Is(Type::StringOrStringWrapper())) {\n    ReplaceWithValue(node, input);\n    return Replace(input);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckEqualsInternalizedString\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckEqualsInternalizedString node based on the input types.\",\n            \"logic\": \"If the value and the expected value have the same type, the CheckEqualsInternalizedString node can be replaced with the effect.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckEqualsInternalizedString node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckEqualsInternalizedString(Node* node) {\n  Node* const exp = NodeProperties::GetValueInput(node, 0);\n  Type const exp_type = NodeProperties::GetType(exp);\n  Node* const val = NodeProperties::GetValueInput(node, 1);\n  Type const val_type = NodeProperties::GetType(val);\n  Node* const effect = NodeProperties::GetEffectInput(node);\n  if (val_type.Is(exp_type)) return Replace(effect);\n  // TODO(turbofan): Should we also try to optimize the\n  // non-internalized String case for {val} here?\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckEqualsSymbol\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a CheckEqualsSymbol node based on the input types.\",\n            \"logic\": \"If the value and the expected value have the same type, the CheckEqualsSymbol node can be replaced with the effect.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The CheckEqualsSymbol node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether a change was made and, if so, what the replacement node is.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReduction TypedOptimization::ReduceCheckEqualsSymbol(Node* node) {\n  Node* const exp = NodeProperties::GetValueInput(node, 0);\n  Type const exp_type = NodeProperties::GetType(exp);\n  Node* const val = NodeProperties::GetValueInput(node, 1);\n  Type const val_type = NodeProperties::GetType(val);\n  Node* const effect = NodeProperties::GetEffectInput(node);\n  if (val_type.Is(exp_type)) return Replace(effect);\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceLoadField\",\n            \"parent\": \"TypedOptimization\",\n            \"about\": \"Reduces a LoadField node based on type information and map stability.\",\n            \"logic\": \"If the field being loaded is the map of a heap object and the object's map is stable, the LoadField can be replaced with the constant map value. This relies on the compilation"
}