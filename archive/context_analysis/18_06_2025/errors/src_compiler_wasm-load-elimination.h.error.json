{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-load-elimination.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-load-elimination.h\",\n            \"file_name\": \"wasm-load-elimination.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Header file for the WasmLoadElimination class, which performs load elimination optimizations in the WebAssembly compiler pipeline.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for base types, compiler specifics, code generation, graph reduction, node auxiliary data, and persistent maps.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/compiler-specific.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/compiler/graph-reducer.h\"\n#include \"src/compiler/node-aux-data.h\"\n#include \"src/compiler/persistent-map.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmLoadElimination\",\n                \"extends\": \"AdvancedReducer\",\n                \"about\": \"This class implements load elimination for WebAssembly code. It attempts to replace redundant loads with previously computed values.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"empty_state_\",\n                        \"type\": \"AbstractState const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the empty abstract state.\"\n                    },\n                    {\n                        \"name\": \"node_states_\",\n                        \"type\": \"NodeAuxData<AbstractState const*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores abstract states associated with nodes in the graph.\"\n                    },\n                    {\n                        \"name\": \"jsgraph_\",\n                        \"type\": \"JSGraph* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the JSGraph.\"\n                    },\n                    {\n                        \"name\": \"dead_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents a dead node in the graph (used for unreachable code).\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating data structures.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"Editor\",\n                    \"JSGraph\",\n                    \"Zone\",\n                    \"Node\",\n                    \"FieldOrElementValue\",\n                    \"HalfState\",\n                    \"AbstractState\",\n                    \"CommonOperatorBuilder\",\n                    \"MachineOperatorBuilder\",\n                    \"Isolate\",\n                    \"TFGraph\",\n                    \"wasm::ValueType\",\n                    \"ObjectAccess\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE WasmLoadElimination final\n    : public NON_EXPORTED_BASE(AdvancedReducer) {\n public:\n  WasmLoadElimination(Editor* editor, JSGraph* jsgraph, Zone* zone);\n  ~WasmLoadElimination() final = default;\n  WasmLoadElimination(const WasmLoadElimination&) = delete;\n  WasmLoadElimination& operator=(const WasmLoadElimination&) = delete;\n\n  const char* reducer_name() const override { return \"WasmLoadElimination\"; }\n\n  Reduction Reduce(Node* node) final;\n\n private:\n  struct FieldOrElementValue {\n    FieldOrElementValue() = default;\n    explicit FieldOrElementValue(Node* value) : value(value) {}\n\n    bool operator==(const FieldOrElementValue& other) const {\n      return value == other.value;\n    }\n\n    bool operator!=(const FieldOrElementValue& other) const {\n      return !(*this == other);\n    }\n\n    bool IsEmpty() const { return value == nullptr; }\n\n    Node* value = nullptr;\n  };\n\n  class HalfState final : public ZoneObject {\n   public:\n    explicit HalfState(Zone* zone)\n        : zone_(zone),\n          fields_(zone, InnerMap(zone)),\n          elements_(zone, InnerMap(zone)) {}\n\n    bool Equals(HalfState const* that) const {\n      return fields_ == that->fields_ && elements_ == that->elements_;\n    }\n    bool IsEmpty() const {\n      return fields_.begin() == fields_.end() &&\n             elements_.begin() == elements_.end();\n    }\n    void IntersectWith(HalfState const* that);\n    HalfState const* KillField(int field_index, Node* object) const;\n    HalfState const* AddField(int field_index, Node* object, Node* value) const;\n    FieldOrElementValue LookupField(int field_index, Node* object) const;\n    void Print() const;\n\n   private:\n    using InnerMap = PersistentMap<Node*, FieldOrElementValue>;\n    template <typename OuterKey>\n    using OuterMap = PersistentMap<OuterKey, InnerMap>;\n    // offset -> object -> info\n    using FieldInfos = OuterMap<int>;\n    // object -> offset -> info\n    using ElementInfos = OuterMap<Node*>;\n\n    // Update {map} so that {map.Get(outer_key).Get(inner_key)} returns {info}.\n    template <typename OuterKey>\n    static void Update(OuterMap<OuterKey>& map, OuterKey outer_key,\n                       Node* inner_key, FieldOrElementValue info) {\n      InnerMap map_copy(map.Get(outer_key));\n      map_copy.Set(inner_key, info);\n      map.Set(outer_key, map_copy);\n    }\n\n    static void Print(const FieldInfos& infos);\n    static void Print(const ElementInfos& infos);\n\n    Zone* zone_;\n    FieldInfos fields_;\n    ElementInfos elements_;\n  };\n\n  // An {AbstractState} consists of two {HalfState}s, representing the sets of\n  // known mutable and immutable struct fields, respectively. The two\n  // half-states should not overlap.\n  struct AbstractState : public ZoneObject {\n    explicit AbstractState(Zone* zone)\n        : mutable_state(zone), immutable_state(zone) {}\n    explicit AbstractState(HalfState mutable_state, HalfState immutable_state)\n        : mutable_state(mutable_state), immutable_state(immutable_state) {}\n\n    bool Equals(AbstractState const* that) const {\n      return this->immutable_state.Equals(&that->immutable_state) &&\n             this->mutable_state.Equals(&that->mutable_state);\n    }\n    void IntersectWith(AbstractState const* that) {\n      mutable_state.IntersectWith(&that->mutable_state);\n      immutable_state.IntersectWith(&that->immutable_state);\n    }\n\n    HalfState mutable_state;\n    HalfState immutable_state;\n  };\n\n  Reduction ReduceWasmStructGet(Node* node);\n  Reduction ReduceWasmStructSet(Node* node);\n  Reduction ReduceWasmArrayLength(Node* node);\n  Reduction ReduceWasmArrayInitializeLength(Node* node);\n  Reduction ReduceStringPrepareForGetCodeunit(Node* node);\n  Reduction ReduceStringAsWtf16(Node* node);\n  Reduction ReduceAnyConvertExtern(Node* node);\n  Reduction ReduceEffectPhi(Node* node);\n  Reduction ReduceStart(Node* node);\n  Reduction ReduceOtherNode(Node* node);\n\n  // Reduce an operation that could be treated as a load from an immutable\n  // object.\n  Reduction ReduceLoadLikeFromImmutable(Node* node, int index);\n\n  Reduction UpdateState(Node* node, AbstractState const* state);\n\n  AbstractState const* ComputeLoopState(Node* node,\n                                        AbstractState const* state) const;\n  // Returns the replacement value and effect for a load given an initial value\n  // node, after optional {TypeGuard}ing and i8/i16 adaptation to i32.\n  std::tuple<Node*, Node*> TruncateAndExtendOrType(Node* value, Node* effect,\n                                                   Node* control,\n                                                   wasm::ValueType field_type,\n                                                   bool is_signed);\n  Reduction AssertUnreachable(Node* node);\n\n  CommonOperatorBuilder* common() const;\n  MachineOperatorBuilder* machine() const;\n  Isolate* isolate() const;\n  TFGraph* graph() const;\n  JSGraph* jsgraph() const { return jsgraph_; }\n  Node* dead() const { return dead_; }\n  Zone* zone() const { return zone_; }\n  AbstractState const* empty_state() const { return &empty_state_; }\n\n  AbstractState const empty_state_;\n  NodeAuxData<AbstractState const*> node_states_;\n  JSGraph* const jsgraph_;\n  Node* dead_;\n  Zone* zone_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"FieldOrElementValue\",\n                \"about\": \"Represents either a field or element value in the abstract state.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The value associated with the field or element.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  struct FieldOrElementValue {\n    FieldOrElementValue() = default;\n    explicit FieldOrElementValue(Node* value) : value(value) {}\n\n    bool operator==(const FieldOrElementValue& other) const {\n      return value == other.value;\n    }\n\n    bool operator!=(const FieldOrElementValue& other) const {\n      return !(*this == other);\n    }\n\n    bool IsEmpty() const { return value == nullptr; }\n\n    Node* value = nullptr;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"HalfState\",\n                \"extends\": \"ZoneObject\",\n                \"about\": \"Represents half of the abstract state, tracking known values of struct fields or array elements.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocations.\"\n                    },\n                    {\n                        \"name\": \"fields_\",\n                        \"type\": \"FieldInfos\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map from field offset to known values.\"\n                    },\n                    {\n                        \"name\": \"elements_\",\n                        \"type\": \"ElementInfos\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map from array index (Node*) to known values.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneObject\",\n                    \"Zone\",\n                    \"PersistentMap\",\n                    \"Node\",\n                    \"FieldOrElementValue\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class HalfState final : public ZoneObject {\n   public:\n    explicit HalfState(Zone* zone)\n        : zone_(zone),\n          fields_(zone, InnerMap(zone)),\n          elements_(zone, InnerMap(zone)) {}\n\n    bool Equals(HalfState const* that) const {\n      return fields_ == that->fields_ && elements_ == that->elements_;\n    }\n    bool IsEmpty() const {\n      return fields_.begin() == fields_.end() &&\n             elements_.begin() == elements_.end();\n    }\n    void IntersectWith(HalfState const* that);\n    HalfState const* KillField(int field_index, Node* object) const;\n    HalfState const* AddField(int field_index, Node* object, Node* value) const;\n    FieldOrElementValue LookupField(int field_index, Node* object) const;\n    void Print() const;\n\n   private:\n    using InnerMap = PersistentMap<Node*, FieldOrElementValue>;\n    template <typename OuterKey>\n    using OuterMap = PersistentMap<OuterKey, InnerMap>;\n    // offset -> object -> info\n    using FieldInfos = OuterMap<int>;\n    // object -> offset -> info\n    using ElementInfos = OuterMap<Node*>;\n\n    // Update {map} so that {map.Get(outer_key).Get(inner_key)} returns {info}.\n    template <typename OuterKey>\n    static void Update(OuterMap<OuterKey>& map, OuterKey outer_key,\n                       Node* inner_key, FieldOrElementValue info) {\n      InnerMap map_copy(map.Get(outer_key));\n      map_copy.Set(inner_key, info);\n      map.Set(outer_key, map_copy);\n    }\n\n    static void Print(const FieldInfos& infos);\n    static void Print(const ElementInfos& infos);\n\n    Zone* zone_;\n    FieldInfos fields_;\n    ElementInfos elements_;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"AbstractState\",\n                \"extends\": \"ZoneObject\",\n                \"about\": \"Represents the abstract state, consisting of two HalfStates: one for mutable fields and another for immutable fields.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"mutable_state\",\n                        \"type\": \"HalfState\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Represents the state of mutable fields.\"\n                    },\n                    {\n                        \"name\": \"immutable_state\",\n                        \"type\": \"HalfState\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Represents the state of immutable fields.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneObject\",\n                    \"HalfState\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  // An {AbstractState} consists of two {HalfState}s, representing the sets of\n  // known mutable and immutable struct fields, respectively. The two\n  // half-states should not overlap.\n  struct AbstractState : public ZoneObject {\n    explicit AbstractState(Zone* zone)\n        : mutable_state(zone), immutable_state(zone) {}\n    explicit AbstractState(HalfState mutable_state, HalfState immutable_state)\n        : mutable_state(mutable_state), immutable_state(immutable_state) {}\n\n    bool Equals(AbstractState const* that) const {\n      return this->immutable_state.Equals(&that->immutable_state) &&\n             this->mutable_state.Equals(&that->mutable_state);\n    }\n    void IntersectWith(AbstractState const* that) {\n      mutable_state.IntersectWith(&that->mutable_state);\n      immutable_state.IntersectWith(&that->immutable_state);\n    }\n\n    HalfState mutable_state;\n    HalfState immutable_state;\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceWasmStructGet\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces a WasmStructGet node.\",\n                \"logic\": \"Attempts to replace the struct get with a known value from the abstract state.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceWasmStructGet(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceWasmStructSet\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces a WasmStructSet node.\",\n                \"logic\": \"Updates the abstract state with the new value being set.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceWasmStructSet(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceWasmArrayLength\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces a WasmArrayLength node.\",\n                \"logic\": \"Attempts to determine the array length from the abstract state.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceWasmArrayLength(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceWasmArrayInitializeLength\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces a WasmArrayInitializeLength node.\",\n                \"logic\": \"Handles initialization of the array length and updates the abstract state.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceWasmArrayInitializeLength(Node* node);\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceStringPrepareForGetCodeunit\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces a StringPrepareForGetCodeunit node.\",\n                \"logic\": \"Handles preparing a string for getting a code unit, potentially involving length checks and bounds checks that can be optimized via load elimination.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceStringPrepareForGetCodeunit(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceStringAsWtf16\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces a StringAsWtf16 node.\",\n                \"logic\": \"Deals with obtaining a WTF-16 representation of a string, which could be subject to load elimination if the string's underlying data is known.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceStringAsWtf16(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceAnyConvertExtern\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces an AnyConvertExtern node.\",\n                \"logic\": \"Handles conversion from 'any' type to an external type, potentially simplifying the conversion if the source type is known.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceAnyConvertExtern(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceEffectPhi\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces an EffectPhi node.\",\n                \"logic\": \"Merges effect states at control flow join points (Phi nodes) by intersecting the abstract states.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceEffectPhi(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceStart\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces a Start node.\",\n                \"logic\": \"Initializes the abstract state at the start of the function.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceStart(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceOtherNode\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces other nodes that don't have specific reduction logic.\",\n                \"logic\": \"A fallback reducer for nodes that are not explicitly handled.  It may perform generic analysis or simply forward the reduction.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction ReduceOtherNode(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceLoadLikeFromImmutable\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces a load-like operation from an immutable object.\",\n                \"logic\": \"Attempts to replace the load with a known value from the immutable state.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the field/element being accessed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  // Reduce an operation that could be treated as a load from an immutable\n  // object.\n  Reduction ReduceLoadLikeFromImmutable(Node* node, int index);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"UpdateState\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Updates the abstract state associated with a node.\",\n                \"logic\": \"Associates the given abstract state with the given node for future analysis.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to update.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"AbstractState const*\",\n                        \"purpose\": \"The abstract state to associate with the node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the update.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"AbstractState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction UpdateState(Node* node, AbstractState const* state);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ComputeLoopState\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Computes the abstract state at the head of a loop.\",\n                \"logic\": \"Merges the abstract states from different loop iterations to compute a fixed-point state.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The loop head node.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"AbstractState const*\",\n                        \"purpose\": \"The abstract state from the previous iteration.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"AbstractState const*\",\n                    \"description\": \"The computed abstract state at the loop head.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"AbstractState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  AbstractState const* ComputeLoopState(Node* node,\n                                        AbstractState const* state) const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TruncateAndExtendOrType\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Returns the replacement value and effect for a load, after optional type guarding and i8/i16 adaptation to i32.\",\n                \"logic\": \"Takes a loaded value, an effect, and control node, applies a type guard based on field_type, and potentially extends i8/i16 values to i32. This is used to ensure the value has the expected type after the load.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The loaded value node.\"\n                    },\n                    {\n                        \"name\": \"effect\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The effect node.\"\n                    },\n                    {\n                        \"name\": \"control\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The control node.\"\n                    },\n                    {\n                        \"name\": \"field_type\",\n                        \"type\": \"wasm::ValueType\",\n                        \"purpose\": \"The expected type of the field.\"\n                    },\n                    {\n                        \"name\": \"is_signed\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Whether the field is signed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::tuple<Node*, Node*>\",\n                    \"description\": \"A tuple containing the replacement value and effect nodes.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"wasm::ValueType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  // Returns the replacement value and effect for a load given an initial value\n  // node, after optional {TypeGuard}ing and i8/i16 adaptation to i32.\n  std::tuple<Node*, Node*> TruncateAndExtendOrType(Node* value, Node* effect,\n                                                   Node* control,\n                                                   wasm::ValueType field_type,\n                                                   bool is_signed);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AssertUnreachable\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Reduces a node by replacing it with an Unreachable node.\",\n                \"logic\": \"This function is used to indicate that the current code path is unreachable, typically after some form of analysis has proven that the current node cannot be reached during execution.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction, indicating that the node has been replaced.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Reduction AssertUnreachable(Node* node);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"common\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Returns the CommonOperatorBuilder.\",\n                \"logic\": \"Provides access to the CommonOperatorBuilder, which is used to create common operators.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"CommonOperatorBuilder*\",\n                    \"description\": \"The CommonOperatorBuilder.\"\n                },\n                \"dependencies\": [\n                    \"CommonOperatorBuilder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  CommonOperatorBuilder* common() const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"machine\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Returns the MachineOperatorBuilder.\",\n                \"logic\": \"Provides access to the MachineOperatorBuilder, which is used to create machine-specific operators.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"MachineOperatorBuilder*\",\n                    \"description\": \"The MachineOperatorBuilder.\"\n                },\n                \"dependencies\": [\n                    \"MachineOperatorBuilder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  MachineOperatorBuilder* machine() const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"isolate\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Returns the Isolate.\",\n                \"logic\": \"Provides access to the Isolate, which represents the current V8 isolate.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Isolate*\",\n                    \"description\": \"The Isolate.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Isolate* isolate() const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"graph\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Returns the TFGraph.\",\n                \"logic\": \"Provides access to the TFGraph, which represents the graph being optimized.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"TFGraph*\",\n                    \"description\": \"The TFGraph.\"\n                },\n                \"dependencies\": [\n                    \"TFGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  TFGraph* graph() const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"jsgraph\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Returns the JSGraph.\",\n                \"logic\": \"Provides access to the JSGraph, which contains information about the JavaScript graph.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"JSGraph*\",\n                    \"description\": \"The JSGraph.\"\n                },\n                \"dependencies\": [\n                    \"JSGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  JSGraph* jsgraph() const { return jsgraph_; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"dead\",\n                \"parent\": \"WasmLoadElimination\",\n                \"about\": \"Returns the dead node.\",\n                \"logic\": \"Provides access to a 'dead' node, which can be"
}