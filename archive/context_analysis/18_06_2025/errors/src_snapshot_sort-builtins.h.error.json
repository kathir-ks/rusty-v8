{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/sort-builtins.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 65, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/sort-builtins.h\",\n            \"file_name\": \"sort-builtins.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares classes and data structures for sorting built-in functions in V8 based on their call graph and execution density, aiming to optimize snapshot generation.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for data structures, built-in function definitions, and diagnostics.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <unordered_map>\n#include <vector>\n\n#include \"src/builtins/builtins.h\"\n#include \"src/diagnostics/basic-block-profiler.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Cluster\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents a cluster of built-in functions that are grouped together during the sorting process. It stores the density, size, and a list of builtins within the cluster.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"density_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the execution density of the cluster (normalized to 10000).\"\n                    },\n                    {\n                        \"name\": \"size_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the size of the cluster in bytes.\"\n                    },\n                    {\n                        \"name\": \"targets_\",\n                        \"type\": \"std::vector<Builtin>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of Builtin enums representing the built-in functions within the cluster.\"\n                    },\n                    {\n                        \"name\": \"sorter_\",\n                        \"type\": \"BuiltinsSorter*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the BuiltinsSorter instance managing this cluster.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Builtin\",\n                    \"BuiltinsSorter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass Cluster {\n public:\n  Cluster(uint32_t density, uint32_t size, Builtin target,\n          BuiltinsSorter* sorter);\n  void Merge(Cluster* other);\n  uint64_t time_approximation();\n\n private:\n  // Max initialized density was normalized as 10000.\n  uint32_t density_;\n  // Size of the cluster in bytes.\n  uint32_t size_;\n  std::vector<Builtin> targets_;\n  BuiltinsSorter* sorter_;\n\n  friend class BuiltinsSorter;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BuiltinsSorter\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Orchestrates the sorting of built-in functions based on profiling data and call graph information. It manages clusters of builtins and uses several heuristics to determine the optimal order for snapshot generation.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kMinEdgeProbabilityThreshold\",\n                        \"type\": \"const int32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Minimum probability threshold for considering an edge in the call graph during cluster merging (set to 10).\"\n                    },\n                    {\n                        \"name\": \"kMaxClusterSize\",\n                        \"type\": \"const uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maximum size of a cluster in bytes (set to 1MB).\"\n                    },\n                    {\n                        \"name\": \"kMaxDensityDecreaseThreshold\",\n                        \"type\": \"const uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maximum allowable density decrease factor when merging clusters (set to 8).\"\n                    },\n                    {\n                        \"name\": \"kBuiltinCallBlockDensityMarker\",\n                        \"type\": \"const std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Marker string used to identify lines in the profiling file that contain block count information.\"\n                    },\n                    {\n                        \"name\": \"kBuiltinDensityMarker\",\n                        \"type\": \"const std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Marker string used to identify lines in the profiling file that contain overall builtin density.\"\n                    },\n                    {\n                        \"name\": \"builtin_density_order_\",\n                        \"type\": \"std::vector<BuiltinDensitySlot>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of BuiltinDensitySlot structs, sorted by density, used to iterate through builtins in descending order of density.\"\n                    },\n                    {\n                        \"name\": \"clusters_\",\n                        \"type\": \"std::vector<Cluster*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of pointers to Cluster objects, representing the current set of clusters.\"\n                    },\n                    {\n                        \"name\": \"call_graph_\",\n                        \"type\": \"CallGraph\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map representing the call graph between built-in functions. The key is the caller Builtin, and the value is a CallProbabilities map.\"\n                    },\n                    {\n                        \"name\": \"builtin_density_map_\",\n                        \"type\": \"BuiltinDensityMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map storing the density of each built-in function. The key is the Builtin enum, and the value is the density (range 0-10000).\"\n                    },\n                    {\n                        \"name\": \"builtin_size_\",\n                        \"type\": \"BuiltinSize\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector storing the size of each built-in function (in bytes). The index corresponds to the Builtin enum value.\"\n                    },\n                    {\n                        \"name\": \"builtin_cluster_map_\",\n                        \"type\": \"BuiltinClusterMap\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map storing the cluster to which each built-in function belongs. The key is the Builtin enum, and the value is a pointer to the Cluster object.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Builtin\",\n                    \"Cluster\",\n                    \"CallGraph\",\n                    \"BuiltinDensityMap\",\n                    \"BuiltinSize\",\n                    \"BuiltinClusterMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass BuiltinsSorter {\n  const int32_t kMinEdgeProbabilityThreshold = 10;\n  const uint32_t kMaxClusterSize = 1 * MB;\n  const uint32_t kMaxDensityDecreaseThreshold = 8;\n\n  const std::string kBuiltinCallBlockDensityMarker = \"block_count\";\n  const std::string kBuiltinDensityMarker = \"builtin_count\";\n\n  // Pair of denstity of builtin and builtin id.\n  struct BuiltinDensitySlot {\n    BuiltinDensitySlot(uint32_t density, Builtin builtin)\n        : density_(density), builtin_(builtin) {}\n\n    uint32_t density_;\n    Builtin builtin_;\n  };\n\n public:\n  BuiltinsSorter();\n  ~BuiltinsSorter();\n  std::vector<Builtin> SortBuiltins(const char* profiling_file,\n                                    const std::vector<uint32_t>& builtin_size);\n\n private:\n  void InitializeCallGraph(const char* profiling_file,\n                           const std::vector<uint32_t>& size);\n  void InitializeClusters();\n  void MergeBestPredecessors();\n  void SortClusters();\n  Builtin FindBestPredecessorOf(Builtin callee);\n  void ProcessBlockCountLineInfo(\n      std::istringstream& line_stream,\n      std::unordered_map<std::string, Builtin>& name2id);\n  void ProcessBuiltinDensityLineInfo(\n      std::istringstream& line_stream,\n      std::unordered_map<std::string, Builtin>& name2id);\n\n  std::vector<Cluster*> clusters_;\n\n  std::vector<BuiltinDensitySlot> builtin_density_order_;\n\n  CallGraph call_graph_;\n\n  BuiltinDensityMap builtin_density_map_;\n\n  BuiltinSize builtin_size_;\n\n  BuiltinClusterMap builtin_cluster_map_;\n\n  friend class Cluster;\n};\n        ]]></code>\n    </class>\n    <interface>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"CallProbability\",\n                \"extends\": [],\n                \"about\": \"Represents the probability of calls between built-in functions.  It stores incoming and outgoing call probabilities as integers.  -1 is used to denote cases where the count is zero.\",\n                \"methods\": [],\n                \"dependencies\": [\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct CallProbability {\n  CallProbability(int32_t incoming = 0, int32_t outgoing = 0)\n      : incoming_(incoming), outgoing_(outgoing) {}\n\n  // There are a caller and a callee, we assume caller was invoked\n  // \"caller-count\" times, it calls callee \"call-count\" times, the callee was\n  // invoked \"callee-count\" times. imcoming_ means the possibity the callee\n  // calls from caller, it was calculted by call-count / callee-count. If\n  // callee-count is 0 (may not be compiled by TurboFan or normalized as 0 due\n  // to too small), we set imcoming_ as -1.\n  int32_t incoming_;\n  // outgoing_ means the possibity the caller\n  // calls to callee, it was calculted by call-count / caller-count. If\n  // caller-count is 0 (may not be compiled by TurboFan or normalized as 0 due\n  // to too small), we set outgoing_ as -1. We didn't use outgoing_ as condition\n  // for reordering builtins yet, but we could try to do some experiments with\n  // it later for obtaining a better order of builtins.\n  int32_t outgoing_;\n};\n        ]]></code>\n    </interface>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"Builtin\",\n                    \"about\": \"Represents the built-in function identifier. Defined in src/builtins/builtins.h\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum class Builtin : uint32_t {\n                  kNoBuiltin = 0,\n                  kAbort,\n                  kAdd,\n                  // ... more builtins ...\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"macro\",\n                    \"name\": \"MB\",\n                    \"about\": \"Defines a megabyte constant. Probably defined elsewhere in the codebase.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                #define MB (1024 * 1024)\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"type alias\",\n                    \"name\": \"CallProbabilities\",\n                    \"about\": \"Type alias for std::unordered_map<Builtin, CallProbability>.\"\n                }\n            </metadata>\n            <code><![CDATA[\nusing CallProbabilities = std::unordered_map<Builtin, CallProbability>;\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"type alias\",\n                    \"name\": \"CallGraph\",\n                    \"about\": \"Type alias for std::unordered_map<Builtin, CallProbabilities>.\"\n                }\n            </metadata>\n            <code><![CDATA[\nusing CallGraph = std::unordered_map<Builtin, CallProbabilities>;\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"type alias\",\n                    \"name\": \"BuiltinDensityMap\",\n                    \"about\": \"Type alias for std::unordered_map<Builtin, uint32_t>.\"\n                }\n            </metadata>\n            <code><![CDATA[\nusing BuiltinDensityMap = std::unordered_map<Builtin, uint32_t>;\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"type alias\",\n                    \"name\": \"BuiltinSize\",\n                    \"about\": \"Type alias for std::vector<uint32_t>.\"\n                }\n            </metadata>\n            <code><![CDATA[\nusing BuiltinSize = std::vector<uint32_t>;\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"type alias\",\n                    \"name\": \"BuiltinClusterMap\",\n                    \"about\": \"Type alias for std::unordered_map<Builtin, Cluster*>.\"\n                }\n            </metadata>\n            <code><![CDATA[\nusing BuiltinClusterMap = std::unordered_map<Builtin, Cluster*>;\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}