{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/type-parser.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 184, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/type-parser.h\",\n        \"file_name\": \"type-parser.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the TypeParser class, which is used to construct a Type from a string literal representation. This is primarily used by the %CheckTurboshaftTypeOf intrinsic for mjsunit tests to check static types.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for optional types, string views, and Turboshaft types.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/compiler/turboshaft/types.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypeParser\",\n            \"about\": \"Parses a string representation of a Type into an actual Type object.\",\n            \"attributes\": [\n                {\n                    \"name\": \"str_\",\n                    \"type\": \"std::string_view\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The string to be parsed.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The memory zone used for allocating the Type object.\"\n                },\n                {\n                    \"name\": \"pos_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current parsing position within the string.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Type\",\n                \"Zone\",\n                \"std::string_view\",\n                \"std::optional\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass TypeParser {\n public:\n  explicit TypeParser(const std::string_view& str, Zone* zone)\n      : str_(str), zone_(zone) {}\n\n  std::optional<Type> Parse() {\n    std::optional<Type> type = ParseType();\n    // Skip trailing whitespace.\n    while (pos_ < str_.length() && str_[pos_] == ' ') ++pos_;\n    if (pos_ < str_.length()) return std::nullopt;\n    return type;\n  }\n\n private:\n  std::optional<Type> ParseType();\n\n  template <typename T>\n  std::optional<T> ParseRange() {\n    if (!ConsumeIf(\"[\")) return std::nullopt;\n    auto from = ReadValue<typename T::value_type>();\n    if (!from) return std::nullopt;\n    if (!ConsumeIf(\",\")) return std::nullopt;\n    auto to = ReadValue<typename T::value_type>();\n    if (!to) return std::nullopt;\n    if (!ConsumeIf(\"]\")) return std::nullopt;\n    if constexpr (!std::is_same_v<T, Word32Type> &&\n                  !std::is_same_v<T, Word64Type>) {\n      CHECK_LE(*from, *to);\n    }\n    return T::Range(*from, *to, zone_);\n  }\n\n  template <typename T>\n  std::optional<T> ParseSet() {\n    if (!ConsumeIf(\"{\")) return std::nullopt;\n    auto elements = ParseSetElements<typename T::value_type>();\n    if (!elements) return std::nullopt;\n    if (!ConsumeIf(\"}\")) return std::nullopt;\n    CHECK_LT(0, elements->size());\n    CHECK_LE(elements->size(), T::kMaxSetSize);\n    return T::Set(*elements, zone_);\n  }\n\n  template <typename T>\n  std::optional<std::vector<T>> ParseSetElements() {\n    std::vector<T> elements;\n    if (IsNext(\"}\")) return elements;\n    while (true) {\n      auto element_opt = ReadValue<T>();\n      if (!element_opt) return std::nullopt;\n      elements.push_back(*element_opt);\n\n      if (IsNext(\"}\")) break;\n      if (!ConsumeIf(\",\")) return std::nullopt;\n    }\n    base::sort(elements);\n    elements.erase(std::unique(elements.begin(), elements.end()),\n                   elements.end());\n    return elements;\n  }\n\n  bool ConsumeIf(const std::string_view& prefix) {\n    if (IsNext(prefix)) {\n      pos_ += prefix.length();\n      return true;\n    }\n    return false;\n  }\n\n  bool IsNext(const std::string_view& prefix) {\n    // Skip leading whitespace.\n    while (pos_ < str_.length() && str_[pos_] == ' ') ++pos_;\n    if (pos_ >= str_.length()) return false;\n    size_t remaining_length = str_.length() - pos_;\n    if (prefix.length() > remaining_length) return false;\n    return str_.compare(pos_, prefix.length(), prefix, 0, prefix.length()) == 0;\n  }\n\n  template <typename T>\n  std::optional<T> ReadValue() {\n    T result;\n    size_t read = 0;\n    // TODO(nicohartmann@): Ideally we want to avoid this string construction\n    // (e.g. using std::from_chars).\n    std::string s(str_.cbegin() + pos_, str_.cend());\n    if constexpr (std::is_same_v<T, uint32_t>) {\n      result = static_cast<uint32_t>(std::stoul(s, &read));\n    } else if constexpr (std::is_same_v<T, uint64_t>) {\n      result = std::stoull(s, &read);\n    } else if constexpr (std::is_same_v<T, float>) {\n      result = std::stof(s, &read);\n    } else if constexpr (std::is_same_v<T, double>) {\n      result = std::stod(s, &read);\n    }\n    if (read == 0) return std::nullopt;\n    pos_ += read;\n    return result;\n  }\n\n  std::string_view str_;\n  Zone* zone_;\n  size_t pos_ = 0;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Parse\",\n            \"parent\": \"TypeParser\",\n            \"about\": \"Parses the string and returns an optional Type object.  Returns nullopt if parsing fails.\",\n            \"logic\": \"Calls ParseType() to do the actual parsing, then checks for trailing whitespace. If any non-whitespace characters remain after parsing the type, it indicates a parsing error.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::optional<Type>\",\n                \"description\": \"The parsed Type, or std::nullopt if parsing failed.\"\n            },\n            \"dependencies\": [\n                \"ParseType\",\n                \"Type\",\n                \"std::optional\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  std::optional<Type> Parse() {\n    std::optional<Type> type = ParseType();\n    // Skip trailing whitespace.\n    while (pos_ < str_.length() && str_[pos_] == ' ') ++pos_;\n    if (pos_ < str_.length()) return std::nullopt;\n    return type;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ParseType\",\n            \"parent\": \"TypeParser\",\n            \"about\": \"Parses a Type from the input string.\",\n            \"logic\": \"Abstract method, its implementation is not available in the header file.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::optional<Type>\",\n                \"description\": \"The parsed Type, or std::nullopt if parsing failed.\"\n            },\n            \"dependencies\": [\n                \"Type\",\n                \"std::optional\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n private:\n  std::optional<Type> ParseType();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ParseRange\",\n            \"parent\": \"TypeParser\",\n            \"about\": \"Parses a range from the input string.\",\n            \"logic\": \"Parses a range enclosed in square brackets. It reads two values separated by a comma and constructs a range type using T::Range(). There's a check to make sure 'from' <= 'to'\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::optional<T>\",\n                \"description\": \"The parsed range, or std::nullopt if parsing failed.\"\n            },\n            \"dependencies\": [\n                \"ConsumeIf\",\n                \"ReadValue\",\n                \"T::Range\",\n                \"Word32Type\",\n                \"Word64Type\",\n                \"std::optional\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  template <typename T>\n  std::optional<T> ParseRange() {\n    if (!ConsumeIf(\"[\")) return std::nullopt;\n    auto from = ReadValue<typename T::value_type>();\n    if (!from) return std::nullopt;\n    if (!ConsumeIf(\",\")) return std::nullopt;\n    auto to = ReadValue<typename T::value_type>();\n    if (!to) return std::nullopt;\n    if (!ConsumeIf(\"]\")) return std::nullopt;\n    if constexpr (!std::is_same_v<T, Word32Type> &&\n                  !std::is_same_v<T, Word64Type>) {\n      CHECK_LE(*from, *to);\n    }\n    return T::Range(*from, *to, zone_);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ParseSet\",\n            \"parent\": \"TypeParser\",\n            \"about\": \"Parses a set from the input string.\",\n            \"logic\": \"Parses a set enclosed in curly braces. It reads multiple values separated by commas and constructs a set type using T::Set().\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::optional<T>\",\n                \"description\": \"The parsed set, or std::nullopt if parsing failed.\"\n            },\n            \"dependencies\": [\n                \"ConsumeIf\",\n                \"ParseSetElements\",\n                \"T::Set\",\n                \"std::optional\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  template <typename T>\n  std::optional<T> ParseSet() {\n    if (!ConsumeIf(\"{\")) return std::nullopt;\n    auto elements = ParseSetElements<typename T::value_type>();\n    if (!elements) return std::nullopt;\n    if (!ConsumeIf(\"}\")) return std::nullopt;\n    CHECK_LT(0, elements->size());\n    CHECK_LE(elements->size(), T::kMaxSetSize);\n    return T::Set(*elements, zone_);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ParseSetElements\",\n            \"parent\": \"TypeParser\",\n            \"about\": \"Parses a list of set elements from the input string.\",\n            \"logic\": \"Reads a comma-separated list of values until it encounters a closing curly brace. It sorts the elements and removes duplicates before returning the vector.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::optional<std::vector<T>>\",\n                \"description\": \"The vector of parsed elements, or std::nullopt if parsing failed.\"\n            },\n            \"dependencies\": [\n                \"ReadValue\",\n                \"ConsumeIf\",\n                \"std::vector\",\n                \"std::optional\",\n                \"base::sort\",\n                \"std::unique\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  template <typename T>\n  std::optional<std::vector<T>> ParseSetElements() {\n    std::vector<T> elements;\n    if (IsNext(\"}\")) return elements;\n    while (true) {\n      auto element_opt = ReadValue<T>();\n      if (!element_opt) return std::nullopt;\n      elements.push_back(*element_opt);\n\n      if (IsNext(\"}\")) break;\n      if (!ConsumeIf(\",\")) return std::nullopt;\n    }\n    base::sort(elements);\n    elements.erase(std::unique(elements.begin(), elements.end()),\n                   elements.end());\n    return elements;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ConsumeIf\",\n            \"parent\": \"TypeParser\",\n            \"about\": \"Consumes the given prefix if it's the next part of the input string.\",\n            \"logic\": \"Checks if the input string starts with the specified prefix at the current position. If so, it advances the position and returns true; otherwise, it returns false.\",\n            \"parameters\": [\n                {\n                    \"name\": \"prefix\",\n                    \"type\": \"const std::string_view&\",\n                    \"purpose\": \"The prefix to consume.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the prefix was consumed, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"IsNext\",\n                \"std::string_view\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  bool ConsumeIf(const std::string_view& prefix) {\n    if (IsNext(prefix)) {\n      pos_ += prefix.length();\n      return true;\n    }\n    return false;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsNext\",\n            \"parent\": \"TypeParser\",\n            \"about\": \"Checks if the given prefix is the next part of the input string.\",\n            \"logic\": \"Skips leading whitespace and then checks if the input string starts with the specified prefix at the current position.\",\n            \"parameters\": [\n                {\n                    \"name\": \"prefix\",\n                    \"type\": \"const std::string_view&\",\n                    \"purpose\": \"The prefix to check for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the prefix is next, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"std::string_view\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  bool IsNext(const std::string_view& prefix) {\n    // Skip leading whitespace.\n    while (pos_ < str_.length() && str_[pos_] == ' ') ++pos_;\n    if (pos_ >= str_.length()) return false;\n    size_t remaining_length = str_.length() - pos_;\n    if (prefix.length() > remaining_length) return false;\n    return str_.compare(pos_, prefix.length(), prefix, 0, prefix.length()) == 0;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReadValue\",\n            \"parent\": \"TypeParser\",\n            \"about\": \"Reads a value of type T from the input string.\",\n            \"logic\": \"Uses `std::stoul`, `std::stoull`, `std::stof`, or `std::stod` to convert a portion of the input string into a value of type T. The template uses `if constexpr` to handle different types. The amount read is then advanced. `std::from_chars` is being considered as an alternative.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::optional<T>\",\n                \"description\": \"The parsed value, or std::nullopt if parsing failed.\"\n            },\n            \"dependencies\": [\n                \"std::stoul\",\n                \"std::stoull\",\n                \"std::stof\",\n                \"std::stod\",\n                \"std::string\",\n                \"std::optional\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  template <typename T>\n  std::optional<T> ReadValue() {\n    T result;\n    size_t read = 0;\n    // TODO(nicohartmann@): Ideally we want to avoid this string construction\n    // (e.g. using std::from_chars).\n    std::string s(str_.cbegin() + pos_, str_.cend());\n    if constexpr (std::is_same_v<T, uint32_t>) {\n      result = static_cast<uint32_t>(std::stoul(s, &read));\n    } else if constexpr (std::is_same_v<T, uint64_t>) {\n      result = std::stoull(s, &read);\n    } else if constexpr (std::is_same_v<T, float>) {\n      result = std::stof(s, &read);\n    } else if constexpr (std::is_same_v<T, double>) {\n      result = std::stod(s, &read);\n    }\n    if (read == 0) return std::nullopt;\n    pos_ += read;\n    return result;\n  }\n        ]]></code>\n    </func>\n</file>\n```"
}