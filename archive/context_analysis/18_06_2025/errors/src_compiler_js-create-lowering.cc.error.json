{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-create-lowering.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-create-lowering.cc\",\n        \"file_name\": \"js-create-lowering.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Lowers JSCreate operations to simpler primitives for the Turbofan compiler in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for compiler, objects, and other utility classes.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/js-create-lowering.h\"\n\n#include <optional>\n\n#include \"src/compiler/access-builder.h\"\n#include \"src/compiler/allocation-builder-inl.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/js-heap-broker-inl.h\"\n#include \"src/compiler/js-operator.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/state-values-utils.h\"\n#include \"src/execution/protectors.h\"\n#include \"src/objects/arguments.h\"\n#include \"src/objects/contexts.h\"\n#include \"src/objects/hash-table-inl.h\"\n#include \"src/objects/heap-number.h\"\n#include \"src/objects/js-collection-iterator.h\"\n#include \"src/objects/js-generator.h\"\n#include \"src/objects/js-promise.h\"\n#include \"src/objects/js-regexp-inl.h\"\n#include \"src/objects/objects-inl.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetArgumentsFrameState\",\n            \"about\": \"Retrieves the frame state holding actual argument values.\",\n            \"logic\": \"Navigates the frame state chain until it finds a frame state of type kInlinedExtraArguments, or the original frame state if no such state exists.\",\n            \"parameters\": [\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"FrameState\",\n                    \"purpose\": \"The frame state to start from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"FrameState\",\n                \"description\": \"The frame state containing the arguments.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"FrameStateType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nFrameState GetArgumentsFrameState(FrameState frame_state) {\n  FrameState outer_state{NodeProperties::GetFrameStateInput(frame_state)};\n  return outer_state.frame_state_info().type() ==\n                 FrameStateType::kInlinedExtraArguments\n             ? outer_state\n             : frame_state;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JSCreateLowering\",\n            \"about\": \"Lowers JSCreate operations to simpler primitives.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass JSCreateLowering {\n public:\n  JSCreateLowering(JSGraph* jsgraph, JSHeapBroker* broker)\n      : jsgraph_(jsgraph), broker_(broker), zone_(jsgraph->zone()) {}\n\n  Reduction Reduce(Node* node);\n\n private:\n  // Helper functions for reducing specific JSCreate opcodes.\n  Reduction ReduceJSCreate(Node* node);\n  Reduction ReduceJSCreateArguments(Node* node);\n  Reduction ReduceJSCreateArray(Node* node);\n  Reduction ReduceJSCreateArrayIterator(Node* node);\n  Reduction ReduceJSCreateAsyncFunctionObject(Node* node);\n  Reduction ReduceJSCreateBoundFunction(Node* node);\n  Reduction ReduceJSCreateClosure(Node* node);\n  Reduction ReduceJSCreateCollectionIterator(Node* node);\n  Reduction ReduceJSCreateIterResultObject(Node* node);\n  Reduction ReduceJSCreateStringIterator(Node* node);\n  Reduction ReduceJSCreateKeyValueArray(Node* node);\n  Reduction ReduceJSCreatePromise(Node* node);\n  Reduction ReduceJSCreateLiteralArrayOrObject(Node* node);\n  Reduction ReduceJSCreateLiteralRegExp(Node* node);\n  Reduction ReduceJSGetTemplateObject(Node* node);\n  Reduction ReduceJSCreateEmptyLiteralArray(Node* node);\n  Reduction ReduceJSCreateEmptyLiteralObject(Node* node);\n  Reduction ReduceJSCreateFunctionContext(Node* node);\n  Reduction ReduceJSCreateWithContext(Node* node);\n  Reduction ReduceJSCreateCatchContext(Node* node);\n  Reduction ReduceJSCreateBlockContext(Node* node);\n  Reduction ReduceJSCreateGeneratorObject(Node* node);\n  Reduction ReduceJSCreateObject(Node* node);\n  Reduction ReduceJSCreateStringWrapper(Node* node);\n\n  // Helper functions for allocating arrays.\n  Reduction ReduceNewArray(Node* node, Node* length, MapRef initial_map,\n                           ElementsKind elements_kind,\n                           AllocationType allocation,\n                           const SlackTrackingPrediction& slack_tracking_prediction);\n  Reduction ReduceNewArray(Node* node, Node* length, int capacity,\n                           MapRef initial_map, ElementsKind elements_kind,\n                           AllocationType allocation,\n                           const SlackTrackingPrediction& slack_tracking_prediction);\n  Reduction ReduceNewArray(Node* node, std::vector<Node*> values,\n                           MapRef initial_map, ElementsKind elements_kind,\n                           AllocationType allocation,\n                           const SlackTrackingPrediction& slack_tracking_prediction);\n\n  // Helper functions for allocating objects.\n  std::optional<Node*> TryAllocateFastLiteral(\n      Node* effect, Node* control, JSObjectRef boilerplate,\n      AllocationType allocation, int max_depth, int* max_properties);\n  std::optional<Node*> TryAllocateFastLiteralElements(\n      Node* effect, Node* control, JSObjectRef boilerplate,\n      AllocationType allocation, int max_depth, int* max_properties);\n  Node* AllocateLiteralRegExp(Node* effect, Node* control,\n                              RegExpBoilerplateDescriptionRef boilerplate);\n  Node* AllocateElements(Node* effect, Node* control, ElementsKind elements_kind,\n                         int capacity, AllocationType allocation);\n  Node* AllocateElements(Node* effect, Node* control, ElementsKind elements_kind,\n                         std::vector<Node*> const& values,\n                         AllocationType allocation);\n  Node* TryAllocateArguments(Node* effect, Node* control, FrameState frame_state);\n  Node* TryAllocateRestArguments(Node* effect, Node* control,\n                                                 FrameState frame_state,\n                                                 int start_index);\n  Node* TryAllocateAliasedArguments(Node* effect, Node* control,\n                                     FrameState frame_state, Node* context,\n                                     SharedFunctionInfoRef shared,\n                                     bool* has_aliased_arguments);\n  Node* TryAllocateAliasedArguments(Node* effect, Node* control, Node* context,\n                                     Node* arguments_length,\n                                     SharedFunctionInfoRef shared,\n                                     bool* has_aliased_arguments);\n\n  Factory* factory() const;\n  TFGraph* graph() const;\n  CommonOperatorBuilder* common() const;\n  CompilationDependencies* dependencies() const;\n  SimplifiedOperatorBuilder* simplified() const;\n  NativeContextRef native_context() const;\n\n  JSGraph* jsgraph() const { return jsgraph_; }\n  JSHeapBroker* broker() const { return broker_; }\n  Zone* zone() const { return zone_; }\n\n  JSGraph* const jsgraph_;\n  JSHeapBroker* const broker_;\n  Zone* const zone_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"JSCreateLowering\",\n            \"about\": \"Main dispatch method for reducing JSCreate nodes based on their opcode.\",\n            \"logic\": \"A switch statement that calls the appropriate ReduceJS* method based on the node's opcode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The reduction result.\"\n            },\n            \"dependencies\": [\n                \"ReduceJSCreate\",\n                \"ReduceJSCreateArguments\",\n                \"ReduceJSCreateArray\",\n                \"ReduceJSCreateArrayIterator\",\n                \"ReduceJSCreateAsyncFunctionObject\",\n                \"ReduceJSCreateBoundFunction\",\n                \"ReduceJSCreateClosure\",\n                \"ReduceJSCreateCollectionIterator\",\n                \"ReduceJSCreateIterResultObject\",\n                \"ReduceJSCreateStringIterator\",\n                \"ReduceJSCreateKeyValueArray\",\n                \"ReduceJSCreatePromise\",\n                \"ReduceJSCreateLiteralArrayOrObject\",\n                \"ReduceJSCreateLiteralRegExp\",\n                \"ReduceJSGetTemplateObject\",\n                \"ReduceJSCreateEmptyLiteralArray\",\n                \"ReduceJSCreateEmptyLiteralObject\",\n                \"ReduceJSCreateFunctionContext\",\n                \"ReduceJSCreateWithContext\",\n                \"ReduceJSCreateCatchContext\",\n                \"ReduceJSCreateBlockContext\",\n                \"ReduceJSCreateGeneratorObject\",\n                \"ReduceJSCreateObject\",\n                \"ReduceJSCreateStringWrapper\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction JSCreateLowering::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kJSCreate:\n      return ReduceJSCreate(node);\n    case IrOpcode::kJSCreateArguments:\n      return ReduceJSCreateArguments(node);\n    case IrOpcode::kJSCreateArray:\n      return ReduceJSCreateArray(node);\n    case IrOpcode::kJSCreateArrayIterator:\n      return ReduceJSCreateArrayIterator(node);\n    case IrOpcode::kJSCreateAsyncFunctionObject:\n      return ReduceJSCreateAsyncFunctionObject(node);\n    case IrOpcode::kJSCreateBoundFunction:\n      return ReduceJSCreateBoundFunction(node);\n    case IrOpcode::kJSCreateClosure:\n      return ReduceJSCreateClosure(node);\n    case IrOpcode::kJSCreateCollectionIterator:\n      return ReduceJSCreateCollectionIterator(node);\n    case IrOpcode::kJSCreateIterResultObject:\n      return ReduceJSCreateIterResultObject(node);\n    case IrOpcode::kJSCreateStringIterator:\n      return ReduceJSCreateStringIterator(node);\n    case IrOpcode::kJSCreateKeyValueArray:\n      return ReduceJSCreateKeyValueArray(node);\n    case IrOpcode::kJSCreatePromise:\n      return ReduceJSCreatePromise(node);\n    case IrOpcode::kJSCreateLiteralArray:\n    case IrOpcode::kJSCreateLiteralObject:\n      return ReduceJSCreateLiteralArrayOrObject(node);\n    case IrOpcode::kJSCreateLiteralRegExp:\n      return ReduceJSCreateLiteralRegExp(node);\n    case IrOpcode::kJSGetTemplateObject:\n      return ReduceJSGetTemplateObject(node);\n    case IrOpcode::kJSCreateEmptyLiteralArray:\n      return ReduceJSCreateEmptyLiteralArray(node);\n    case IrOpcode::kJSCreateEmptyLiteralObject:\n      return ReduceJSCreateEmptyLiteralObject(node);\n    case IrOpcode::kJSCreateFunctionContext:\n      return ReduceJSCreateFunctionContext(node);\n    case IrOpcode::kJSCreateWithContext:\n      return ReduceJSCreateWithContext(node);\n    case IrOpcode::kJSCreateCatchContext:\n      return ReduceJSCreateCatchContext(node);\n    case IrOpcode::kJSCreateBlockContext:\n      return ReduceJSCreateBlockContext(node);\n    case IrOpcode::kJSCreateGeneratorObject:\n      return ReduceJSCreateGeneratorObject(node);\n    case IrOpcode::kJSCreateObject:\n      return ReduceJSCreateObject(node);\n    case IrOpcode::kJSCreateStringWrapper:\n      return ReduceJSCreateStringWrapper(node);\n    default:\n      break;\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceJSCreate\",\n            \"parent\": \"JSCreateLowering\",\n            \"about\": \"Lowers JSCreate nodes for regular JS objects.\",\n            \"logic\": \"Allocates memory for a JSObject, initializes its map, properties, elements, and in-object properties.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The JSCreate node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The reduction result.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"AllocationBuilder\",\n                \"AccessBuilder\",\n                \"HeapObjectMatcher\",\n                \"dependencies\",\n                \"DependOnInitialMapInstanceSizePrediction\",\n                \"RelaxControls\",\n                \"Changed\",\n                \"jsgraph\",\n                \"broker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction JSCreateLowering::ReduceJSCreate(Node* node) {\n  DCHECK_EQ(IrOpcode::kJSCreate, node->opcode());\n  Node* const new_target = NodeProperties::GetValueInput(node, 1);\n  Node* const effect = NodeProperties::GetEffectInput(node);\n  Node* const control = NodeProperties::GetControlInput(node);\n\n  OptionalMapRef initial_map = NodeProperties::GetJSCreateMap(broker(), node);\n  if (!initial_map.has_value()) return NoChange();\n\n  JSFunctionRef original_constructor =\n      HeapObjectMatcher(new_target).Ref(broker()).AsJSFunction();\n  SlackTrackingPrediction slack_tracking_prediction =\n      dependencies()->DependOnInitialMapInstanceSizePrediction(\n          original_constructor);\n\n  // Emit code to allocate the JSObject instance for the\n  // {original_constructor}.\n  AllocationBuilder a(jsgraph(), broker(), effect, control);\n  a.Allocate(slack_tracking_prediction.instance_size());\n  a.Store(AccessBuilder::ForMap(), *initial_map);\n  a.Store(AccessBuilder::ForJSObjectPropertiesOrHashKnownPointer(),\n          jsgraph()->EmptyFixedArrayConstant());\n  a.Store(AccessBuilder::ForJSObjectElements(),\n          jsgraph()->EmptyFixedArrayConstant());\n  for (int i = 0; i < slack_tracking_prediction.inobject_property_count();\n       ++i) {\n    a.Store(AccessBuilder::ForJSObjectInObjectProperty(*initial_map, i),\n            jsgraph()->UndefinedConstant());\n  }\n\n  RelaxControls(node);\n  a.FinishAndChange(node);\n  return Changed(node);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceJSCreateArguments\",\n            \"parent\": \"JSCreateLowering\",\n            \"about\": \"Lowers JSCreateArguments nodes to allocate and initialize arguments objects.\",\n            \"logic\": \"Handles different types of arguments objects (mapped, unmapped, rest parameters) and uses inline allocation for inlined frames. Allocates elements backing store and initializes the arguments object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The JSCreateArguments node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The reduction result.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"CreateArgumentsType\",\n                \"FrameState\",\n                \"FrameStateInfo\",\n                \"SharedFunctionInfoRef\",\n                \"MakeRef\",\n                \"native_context\",\n                \"ArgumentsLength\",\n                \"TryAllocateAliasedArguments\",\n                \"AllocationBuilder\",\n                \"AccessBuilder\",\n                \"RelaxControls\",\n                \"RestLength\",\n                \"NewArgumentsElements\",\n                \"jsgraph\",\n                \"broker\",\n                \"GetArgumentsFrameState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction JSCreateLowering::ReduceJSCreateArguments(Node* node) {\n  DCHECK_EQ(IrOpcode::kJSCreateArguments, node->opcode());\n  CreateArgumentsType type = CreateArgumentsTypeOf(node->op());\n  FrameState frame_state{NodeProperties::GetFrameStateInput(node)};\n  Node* const control = graph()->start();\n  FrameStateInfo state_info = frame_state.frame_state_info();\n  SharedFunctionInfoRef shared =\n      MakeRef(broker(), state_info.shared_info().ToHandleChecked());\n\n  // Use the ArgumentsAccessStub for materializing both mapped and unmapped\n  // arguments object, but only for non-inlined (i.e. outermost) frames.\n  if (frame_state.outer_frame_state()->opcode() != IrOpcode::kFrameState) {\n    switch (type) {\n      case CreateArgumentsType::kMappedArguments: {\n        // TODO(turbofan): Duplicate parameters are not handled yet.\n        if (shared.has_duplicate_parameters()) return NoChange();\n        Node* const callee = NodeProperties::GetValueInput(node, 0);\n        Node* const context = NodeProperties::GetContextInput(node);\n        Node* effect = NodeProperties::GetEffectInput(node);\n        Node* const arguments_length =\n            graph()->NewNode(simplified()->ArgumentsLength());\n        // Allocate the elements backing store.\n        bool has_aliased_arguments = false;\n        Node* const elements = effect = TryAllocateAliasedArguments(\n            effect, control, context, arguments_length, shared,\n            &has_aliased_arguments);\n        if (elements == nullptr) return NoChange();\n\n        // Load the arguments object map.\n        Node* const arguments_map = jsgraph()->ConstantNoHole(\n            has_aliased_arguments\n                ? native_context().fast_aliased_arguments_map(broker())\n                : native_context().sloppy_arguments_map(broker()),\n            broker());\n        // Actually allocate and initialize the arguments object.\n        AllocationBuilder a(jsgraph(), broker(), effect, control);\n        static_assert(JSSloppyArgumentsObject::kSize == 5 * kTaggedSize);\n        a.Allocate(JSSloppyArgumentsObject::kSize);\n        a.Store(AccessBuilder::ForMap(), arguments_map);\n        a.Store(AccessBuilder::ForJSObjectPropertiesOrHashKnownPointer(),\n                jsgraph()->EmptyFixedArrayConstant());\n        a.Store(AccessBuilder::ForJSObjectElements(), elements);\n        a.Store(AccessBuilder::ForArgumentsLength(), arguments_length);\n        a.Store(AccessBuilder::ForArgumentsCallee(), callee);\n        RelaxControls(node);\n        a.FinishAndChange(node);\n        return Changed(node);\n      }\n      case CreateArgumentsType::kUnmappedArguments: {\n        Node* effect = NodeProperties::GetEffectInput(node);\n        Node* const arguments_length =\n            graph()->NewNode(simplified()->ArgumentsLength());\n        // Allocate the elements backing store.\n        Node* const elements = effect = graph()->NewNode(\n            simplified()->NewArgumentsElements(\n                CreateArgumentsType::kUnmappedArguments,\n                shared.internal_formal_parameter_count_without_receiver()),\n            arguments_length, effect);\n        // Load the arguments object map.\n        Node* const arguments_map = jsgraph()->ConstantNoHole(\n            native_context().strict_arguments_map(broker()), broker());\n        // Actually allocate and initialize the arguments object.\n        AllocationBuilder a(jsgraph(), broker(), effect, control);\n        static_assert(JSStrictArgumentsObject::kSize == 4 * kTaggedSize);\n        a.Allocate(JSStrictArgumentsObject::kSize);\n        a.Store(AccessBuilder::ForMap(), arguments_map);\n        a.Store(AccessBuilder::ForJSObjectPropertiesOrHashKnownPointer(),\n                jsgraph()->EmptyFixedArrayConstant());\n        a.Store(AccessBuilder::ForJSObjectElements(), elements);\n        a.Store(AccessBuilder::ForArgumentsLength(), arguments_length);\n        RelaxControls(node);\n        a.FinishAndChange(node);\n        return Changed(node);\n      }\n      case CreateArgumentsType::kRestParameter: {\n        Node* effect = NodeProperties::GetEffectInput(node);\n        Node* const arguments_length =\n            graph()->NewNode(simplified()->ArgumentsLength());\n        Node* const rest_length = graph()->NewNode(simplified()->RestLength(\n            shared.internal_formal_parameter_count_without_receiver()));\n        // Allocate the elements backing store.\n        Node* const elements = effect = graph()->NewNode(\n            simplified()->NewArgumentsElements(\n                CreateArgumentsType::kRestParameter,\n                shared.internal_formal_parameter_count_without_receiver()),\n            arguments_length, effect);\n        // Load the JSArray object map.\n        Node* const jsarray_map = jsgraph()->ConstantNoHole(\n            native_context().js_array_packed_elements_map(broker()), broker());\n        // Actually allocate and initialize the jsarray.\n        AllocationBuilder a(jsgraph(), broker(), effect, control);\n        static_assert(JSArray::kHeaderSize == 4 * kTaggedSize);\n        a.Allocate(JSArray::kHeaderSize);\n        a.Store(AccessBuilder::ForMap(), jsarray_map);\n        a.Store(AccessBuilder::ForJSObjectPropertiesOrHashKnownPointer(),\n                jsgraph()->EmptyFixedArrayConstant());\n        a.Store(AccessBuilder::ForJSObjectElements(), elements);\n        a.Store(AccessBuilder::ForJSArrayLength(PACKED_ELEMENTS), rest_length);\n        RelaxControls(node);\n        a.FinishAndChange(node);\n        return Changed(node);\n      }\n    }\n    UNREACHABLE();\n  }\n  // Use inline allocation for all mapped arguments objects within inlined\n  // (i.e. non-outermost) frames, independent of the object size.\n  DCHECK_EQ(frame_state.outer_frame_state()->opcode(), IrOpcode::kFrameState);\n  switch (type) {\n    case CreateArgumentsType::kMappedArguments: {\n      Node* const callee = NodeProperties::GetValueInput(node, 0);\n      Node* const context = NodeProperties::GetContextInput(node);\n      Node* effect = NodeProperties::GetEffectInput(node);\n      // TODO(turbofan): Duplicate parameters are not handled yet.\n      if (shared.has_duplicate_parameters()) return NoChange();\n      // Choose the correct frame state and frame state info depending on\n      // whether there conceptually is an inlined arguments frame in the call\n      // chain.\n      FrameState args_state = GetArgumentsFrameState(frame_state);\n      if (args_state.parameters()->opcode() == IrOpcode::kDeadValue) {\n        // This protects against an incompletely propagated DeadValue node.\n        // If the FrameState has a DeadValue input, then this node will be\n        // pruned anyway.\n        return NoChange();\n      }\n      FrameStateInfo args_state_info = args_state.frame_state_info();\n      int length = args_state_info.parameter_count() - 1;  // Minus receiver.\n      // Prepare element backing store to be used by arguments object.\n      bool has_aliased_arguments = false;\n      Node* const elements = TryAllocateAliasedArguments(\n          effect, control, args_state, context, shared, &has_aliased_arguments);\n      if (elements == nullptr) return NoChange();\n      effect = elements->op()->EffectOutputCount() > 0 ? elements : effect;\n      // Load the arguments object map.\n      Node* const arguments_map = jsgraph()->ConstantNoHole(\n          has_aliased_arguments\n              ? native_context().fast_aliased_arguments_map(broker())\n              : native_context().sloppy_arguments_map(broker()),\n          broker());\n      // Actually allocate and initialize the arguments object.\n      AllocationBuilder a(jsgraph(), broker(), effect, control);\n      static_assert(JSSloppyArgumentsObject::kSize == 5 * kTaggedSize);\n      a.Allocate(JSSloppyArgumentsObject::kSize);\n      a.Store(AccessBuilder::ForMap(), arguments_map);\n      a.Store(AccessBuilder::ForJSObjectPropertiesOrHashKnownPointer(),\n              jsgraph()->EmptyFixedArrayConstant());\n      a.Store(AccessBuilder::ForJSObjectElements(), elements);\n      a.Store(AccessBuilder::ForArgumentsLength(),\n              jsgraph()->ConstantNoHole(length));\n      a.Store(AccessBuilder::ForArgumentsCallee(), callee);\n      RelaxControls(node);\n      a.FinishAndChange(node);\n      return Changed(node);\n    }\n    case CreateArgumentsType::kUnmappedArguments: {\n      // Use inline allocation for all unmapped arguments objects within inlined\n      // (i.e. non-outermost) frames, independent of the object size.\n      Node* effect = NodeProperties::GetEffectInput(node);\n      // Choose the correct frame state and frame state info depending on\n      // whether there conceptually is an inlined arguments frame in the call\n      // chain.\n      FrameState args_state = GetArgumentsFrameState(frame_state);\n      if (args_state.parameters()->opcode() == IrOpcode::kDeadValue) {\n        // This protects against an incompletely propagated DeadValue node.\n        // If the FrameState has a DeadValue input, then this node will be\n        // pruned anyway.\n        return NoChange();\n      }\n      FrameStateInfo args_state_info = args_state.frame_state_info();\n      int length = args_state_info.parameter_count() - 1;  // Minus receiver.\n      // Prepare element backing store to be used by arguments object.\n      Node* const elements = TryAllocateArguments(effect, control, args_state);\n      if (elements == nullptr) return NoChange();\n      effect = elements->op()->EffectOutputCount() > 0 ? elements : effect;\n      // Load the arguments object map.\n      Node* const arguments_map = jsgraph()->ConstantNoHole(\n          native_context().strict_arguments_map(broker()), broker());\n      // Actually allocate and initialize the arguments object.\n      AllocationBuilder a(jsgraph(), broker(), effect, control);\n      static_assert(JSStrictArgumentsObject::kSize == 4 * kTaggedSize);\n      a.Allocate(JSStrictArgumentsObject::kSize);\n      a.Store(AccessBuilder::ForMap(), arguments_map);\n      a.Store(AccessBuilder::ForJSObjectPropertiesOrHashKnownPointer(),\n              jsgraph()->EmptyFixedArrayConstant());\n      a.Store(AccessBuilder::ForJSObjectElements(), elements);\n      a.Store(AccessBuilder::ForArgumentsLength(),\n              jsgraph()->ConstantNoHole(length));\n      RelaxControls(node);\n      a.FinishAndChange(node);\n      return Changed(node);\n    }\n    case CreateArgumentsType::kRestParameter: {\n      int start_index =\n          shared.internal_formal_parameter_count_without_receiver();\n      // Use inline allocation for all unmapped arguments objects within inlined\n      // (i.e. non-outermost) frames, independent of the object size.\n      Node* effect = NodeProperties::GetEffectInput(node);\n      // Choose the correct frame state and frame state info depending on\n      // whether there conceptually is an inlined arguments frame in the call\n      // chain.\n      FrameState args_state = GetArgumentsFrameState(frame_state);\n      if (args_state.parameters()->opcode() == IrOpcode::kDeadValue) {\n        // This protects against an incompletely propagated DeadValue node.\n        // If the FrameState has a DeadValue input, then this node will be\n        // pruned anyway.\n        return NoChange();\n      }\n      FrameStateInfo args_state_info = args_state.frame_state_info();\n      // Prepare element backing store to be used by the rest array.\n      Node* const elements =\n          TryAllocateRestArguments(effect, control, args_state, start_index);\n      if (elements == nullptr) return NoChange();\n      effect = elements->op()->EffectOutputCount() > 0 ? elements : effect;\n      // Load the JSArray object map.\n      Node* const jsarray_map = jsgraph()->ConstantNoHole(\n          native_context().js_array_packed_elements_map(broker()), broker());\n      // Actually allocate and initialize the jsarray.\n      AllocationBuilder a(jsgraph(), broker(), effect, control);\n\n      // -1 to minus receiver\n      int argument_count = args_state_info.parameter_count() - 1;\n      int length = std::max(0, argument_count - start_index);\n      static_assert(JSArray::kHeaderSize == 4 * kTaggedSize);\n      a.Allocate(ALIGN_TO_ALLOCATION_ALIGNMENT(JSArray::kHeaderSize));\n      a.Store(AccessBuilder::ForMap(), jsarray_map);\n      a.Store(AccessBuilder::ForJSObjectPropertiesOrHashKnownPointer(),\n              jsgraph()->EmptyFixedArrayConstant());\n      a.Store(AccessBuilder::ForJSObjectElements(), elements);\n      a.Store(AccessBuilder::ForJSArrayLength(PACKED_ELEMENTS),\n              jsgraph()->ConstantNoHole(length));\n      RelaxControls(node);\n      a.FinishAndChange(node);\n      return Changed(node);\n    }\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceJSCreateGeneratorObject\",\n            \"parent\": \"JSCreateLowering\",\n            \"about\": \"Lowers JSCreateGeneratorObject nodes.\",\n            \"logic\": \"Allocates a register file and the JSGeneratorObject instance. Initializes the generator object with context, function, receiver, and register file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The JSCreateGeneratorObject node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The reduction result.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"Type\",\n                \"jsgraph\",\n                \"broker\",\n                \"AllocationBuilder\",\n                \"AccessBuilder\",\n                \"RelaxControls\",\n                \"dependencies\",\n                \"DependOnInitialMapInstanceSizePrediction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction JSCreateLowering::ReduceJSCreateGeneratorObject(Node* node) {\n  DCHECK_EQ(IrOpcode::kJSCreateGeneratorObject, node->opcode());\n  Node* const closure = NodeProperties::GetValueInput(node, 0);\n  Node* const receiver = NodeProperties::GetValueInput(node, 1);\n  Node* const context = NodeProperties::GetContextInput(node);\n  Type const closure_type = NodeProperties::GetType(closure);\n  Node* effect = NodeProperties::GetEffectInput(node);\n  Node* const control = NodeProperties::GetControlInput(node);\n  if (closure_type.IsHeapConstant()) {\n    DCHECK(closure_type.AsHeapConstant()->Ref().IsJSFunction());\n    JSFunctionRef js_function =\n        closure_type.AsHeapConstant()->Ref().AsJSFunction();\n    if (!js_function.has_initial_map(broker())) return NoChange();\n\n    SlackTrackingPrediction slack_tracking_prediction =\n        dependencies()->DependOnInitialMapInstanceSizePrediction(js_function);\n\n    MapRef initial_map = js_function.initial_map(broker());\n    DCHECK(initial_map.instance_type() == JS_GENERATOR_OBJECT_TYPE ||\n           initial_map.instance_type() == JS_ASYNC_GENERATOR_OBJECT_TYPE);\n\n    // Allocate a register file.\n    SharedFunctionInfoRef shared = js_function.shared(broker());\n    DCHECK(shared.HasBytecodeArray());\n    int parameter_count_no_receiver =\n        shared.internal_formal_parameter_count_without_receiver();\n    int length = parameter_count_no_receiver +\n                 shared.GetBytecodeArray(broker()).register_count();\n    MapRef fixed_array_map = broker()->fixed_array_map();\n    AllocationBuilder ab(jsgraph(), broker(), effect, control);\n    if (!ab.CanAllocateArray(length, fixed_array_map)) {\n      return NoChange();\n    }\n    ab.AllocateArray(length, fixed_array_map);\n    for (int i = 0; i < length; ++i) {\n      ab.Store(AccessBuilder::ForFixedArraySlot(i),\n               jsgraph()->UndefinedConstant());\n    }\n    Node* parameters_and_registers = effect = ab.Finish();\n\n    // Emit code to allocate the JS[Async]GeneratorObject instance.\n    AllocationBuilder a(jsgraph(), broker(), effect, control);\n    a.Allocate(slack_tracking_prediction.instance_size());\n    Node* undefined = jsgraph()->UndefinedConstant();\n    a.Store(AccessBuilder::ForMap(), initial_map);\n    a.Store(AccessBuilder::ForJSObjectPropertiesOrHashKnownPointer(),\n            jsgraph()->EmptyFixedArrayConstant());\n    a.Store(AccessBuilder::ForJSObjectElements(),\n            jsgraph()->EmptyFixedArrayConstant());\n    a.Store(AccessBuilder::ForJSGeneratorObjectContext(), context);\n    a.Store(AccessBuilder::ForJSGeneratorObjectFunction(), closure);\n    a.Store(AccessBuilder::ForJSGeneratorObjectReceiver(), receiver);\n    a.Store(AccessBuilder::ForJSGeneratorObjectInputOrDebugPos(), undefined);\n    a.Store(AccessBuilder::ForJSGeneratorObjectResumeMode(),\n            jsgraph()->ConstantNoHole(JSGeneratorObject::kNext));\n    a.Store(AccessBuilder::ForJSGeneratorObjectContinuation(),\n            jsgraph()->ConstantNoHole(JSGeneratorObject::kGeneratorExecuting));\n    a.Store(AccessBuilder::ForJSGeneratorObjectParametersAndRegisters(),\n            parameters_and_registers);\n\n    if (initial_map.instance_type() == JS_ASYNC_GENERATOR"
}