{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/thread-local-top.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 239, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/thread-local-top.h\",\n            \"file_name\": \"thread-local-top.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the ThreadLocalTop class, which stores thread-local data for the V8 JavaScript engine.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for V8 API callbacks, context management, exception handling, unwinding, global definitions, thread IDs, object contexts, and utility functions.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"include/v8-callbacks.h\"\n#include \"include/v8-context.h\"\n#include \"include/v8-exception.h\"\n#include \"include/v8-unwinder.h\"\n#include \"src/common/globals.h\"\n#include \"src/execution/thread-id.h\"\n#include \"src/objects/contexts.h\"\n#include \"src/utils/utils.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ThreadLocalTop\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Stores thread-local data for the V8 JavaScript engine, including context, exception handling information, and other thread-specific state.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"c_entry_fp_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The frame pointer of the top C entry frame.\"\n                    },\n                    {\n                        \"name\": \"c_function_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"C function that was called at C entry.\"\n                    },\n                    {\n                        \"name\": \"context_\",\n                        \"type\": \"Tagged<Context>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The context where the current execution method is created and for variable lookups.\"\n                    },\n                    {\n                        \"name\": \"topmost_script_having_context_\",\n                        \"type\": \"Tagged<Context>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The context of the topmost user JavaScript code.\"\n                    },\n                    {\n                        \"name\": \"last_api_entry_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The stack height of the last API entry.\"\n                    },\n                    {\n                        \"name\": \"exception_\",\n                        \"type\": \"Tagged<Object>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the current exception object.\"\n                    },\n                    {\n                        \"name\": \"pending_handler_context_\",\n                        \"type\": \"Tagged<Context>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Communication channel between Isolate::FindHandler and the CEntry.\"\n                    },\n                    {\n                        \"name\": \"pending_handler_entrypoint_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Address of the pending exception handler entrypoint.\"\n                    },\n                    {\n                        \"name\": \"pending_handler_constant_pool_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Address of the constant pool for the pending exception handler.\"\n                    },\n                    {\n                        \"name\": \"pending_handler_fp_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Frame pointer for the pending exception handler.\"\n                    },\n                    {\n                        \"name\": \"pending_handler_sp_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stack pointer for the pending exception handler.\"\n                    },\n                    {\n                        \"name\": \"try_catch_handler_\",\n                        \"type\": \"v8::TryCatch*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The top C++ try catch handler.\"\n                    },\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Pointer to the Isolate.\"\n                    },\n                    {\n                        \"name\": \"thread_id_\",\n                        \"type\": \"std::atomic<ThreadId>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The ID of the current thread.\"\n                    },\n                    {\n                        \"name\": \"num_frames_above_pending_handler_\",\n                        \"type\": \"uintptr_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Number of frames above the pending handler.\"\n                    },\n                    {\n                        \"name\": \"is_on_central_stack_flag_\",\n                        \"type\": \"uint8_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Flag indicating if the code is currently executing on the central stack.\"\n                    },\n                    {\n                        \"name\": \"rethrowing_message_\",\n                        \"type\": \"uint8_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Flag indicating if a message is being rethrown.\"\n                    },\n                    {\n                        \"name\": \"pending_message_\",\n                        \"type\": \"Tagged<Object>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Communication channel between Isolate::Throw and message consumers.\"\n                    },\n                    {\n                        \"name\": \"handler_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The top try-block handler on the stack.\"\n                    },\n                    {\n                        \"name\": \"simulator_\",\n                        \"type\": \"Simulator*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Pointer to the simulator (if running in simulation mode).\"\n                    },\n                    {\n                        \"name\": \"js_entry_sp_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The stack pointer of the bottom JS entry frame.\"\n                    },\n                    {\n                        \"name\": \"external_callback_scope_\",\n                        \"type\": \"ExternalCallbackScope*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The external callback we're currently in.\"\n                    },\n                    {\n                        \"name\": \"current_vm_state_\",\n                        \"type\": \"StateTag\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The current VM state.\"\n                    },\n                    {\n                        \"name\": \"current_embedder_state_\",\n                        \"type\": \"EmbedderState*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The current embedder state.\"\n                    },\n                    {\n                        \"name\": \"top_backup_incumbent_scope_\",\n                        \"type\": \"const v8::Context::BackupIncumbentScope*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The top entry of the v8::Context::BackupIncumbentScope stack.\"\n                    },\n                    {\n                        \"name\": \"failed_access_check_callback_\",\n                        \"type\": \"v8::FailedAccessCheckCallback\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Call back function to report unsafe JS accesses.\"\n                    },\n                    {\n                        \"name\": \"thread_in_wasm_flag_address_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Address of the thread-local 'thread in wasm' flag.\"\n                    },\n                    {\n                        \"name\": \"central_stack_sp_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"On switching from the central stack this contains the central stack's SP.\"\n                    },\n                    {\n                        \"name\": \"central_stack_limit_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"On switching from the central stack this contains the central stack's stack limit.\"\n                    },\n                    {\n                        \"name\": \"secondary_stack_sp_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"On switching to the central stack this contains the secondary stack's SP.\"\n                    },\n                    {\n                        \"name\": \"secondary_stack_limit_\",\n                        \"type\": \"Address\",\n                        \"access\": \"public\",\n                        \"purpose\": \"On switching to the central stack this contains the secondary stack's stack limit.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"v8::TryCatch\",\n                    \"EmbedderState\",\n                    \"ExternalCallbackScope\",\n                    \"Isolate\",\n                    \"Simulator\",\n                    \"ThreadId\",\n                    \"Context\",\n                    \"Object\",\n                    \"StateTag\",\n                    \"v8::Context::BackupIncumbentScope\",\n                    \"v8::FailedAccessCheckCallback\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass ThreadLocalTop {\n public:\n  // TODO(all): This is not particularly beautiful. We should probably\n  // refactor this to really consist of just Addresses and 32-bit\n  // integer fields.\n  static constexpr uint32_t kSizeInBytes = 30 * kSystemPointerSize;\n\n  // Does early low-level initialization that does not depend on the\n  // isolate being present.\n  ThreadLocalTop() { Clear(); }\n\n  void Clear();\n\n  // Initialize the thread data.\n  void Initialize(Isolate*);\n\n  // Get the address of the top C++ try catch handler or nullptr if\n  // none are registered.\n  //\n  // This method always returns an address that can be compared to\n  // pointers into the JavaScript stack.  When running on actual\n  // hardware, try_catch_handler_address and TryCatchHandler return\n  // the same pointer.  When running on a simulator with a separate JS\n  // stack, try_catch_handler_address returns a JS stack address that\n  // corresponds to the place on the JS stack where the C++ handler\n  // would have been if the stack were not separate.\n  Address try_catch_handler_address() {\n    if (try_catch_handler_) {\n      return try_catch_handler_->JSStackComparableAddressPrivate();\n    }\n    return kNullAddress;\n  }\n\n  // Call depth represents nested v8 api calls. Instead of storing the nesting\n  // level as an integer, we store the stack height of the last API entry. This\n  // additional information is used when we decide whether to trigger a debug\n  // break at a function entry.\n  template <bool clear_exception, typename Scope>\n  void IncrementCallDepth(Scope* stack_allocated_scope) {\n    stack_allocated_scope->previous_stack_height_ = last_api_entry_;\n#if defined(USE_SIMULATOR) || defined(V8_USE_ADDRESS_SANITIZER)\n    StoreCurrentStackPosition();\n#else\n    last_api_entry_ = reinterpret_cast<i::Address>(stack_allocated_scope);\n#endif\n    if constexpr (clear_exception) {\n      exception_ = Tagged<Object>(\n          Internals::GetRoot(reinterpret_cast<v8::Isolate*>(isolate_),\n                             Internals::kTheHoleValueRootIndex));\n    }\n  }\n\n#if defined(USE_SIMULATOR) || defined(V8_USE_ADDRESS_SANITIZER)\n  void StoreCurrentStackPosition();\n#endif\n\n  template <typename Scope>\n  void DecrementCallDepth(Scope* stack_allocated_scope) {\n    last_api_entry_ = stack_allocated_scope->previous_stack_height_;\n  }\n\n  bool CallDepthIsZero() const { return last_api_entry_ == kNullAddress; }\n\n  void Free();\n\n  // Group fields updated on every CEntry/CallApiCallback/CallApiGetter call\n  // together. See MacroAssembler::EnterExitFram/LeaveExitFrame.\n  // [ CEntry/CallApiCallback/CallApiGetter\n\n  // The frame pointer of the top c entry frame.\n  Address c_entry_fp_;\n  // C function that was called at c entry.\n  Address c_function_;\n  // The context where the current execution method is created and for\n  // variable lookups.\n  // TODO(3770): This field is read/written from generated code, so it would\n  // be cleaner to make it an \"Address raw_context_\", and construct a Context\n  // object in the getter. Same for {pending_handler_context_} below. In the\n  // meantime, assert that the memory layout is the same.\n  static_assert(sizeof(Tagged<Context>) == kSystemPointerSize);\n  Tagged<Context> context_;\n\n  // The \"topmost script-having execution context\" from the Web IDL spec\n  // (i.e. the context of the topmost user JavaScript code, see\n  // https://html.spec.whatwg.org/multipage/webappapis.html#topmost-script-having-execution-context)\n  // if known or Context::kNoContext otherwise. It's guaranteed to be valid\n  // only when read from within Api function callback or Api getter/setter\n  // callbacks. The caller context is set to the current context from generated\n  // code/builtins right before calling the Api callback when it's guaraneed\n  // that current context belongs to user JavaScript code:\n  //  - when an Api getter/setter function callback is called by IC system\n  //    from interpreter or baseline code,\n  //  - when an Api callback is called from optimized code (Maglev or TurboFan).\n  //\n  // Once the caller context value becomes outdated it's reset to kNoContext\n  // in order to enforce the slow mechanism involving stack iteration.\n  // This happens in the following cases:\n  //  - when an Api function is called as a regular JSFunction (it's not worth\n  //    the efforts of properly propagating the topmost user script-having\n  //    context through a potential sequence of builtin function calls),\n  //  - when execution crosses C++ to JS boundary (Execution::Call*/New),\n  //  - when execution crosses JS to Wasm boundary or Wasm to JS bounary\n  //    (it's not worth the efforts of propagating the caller context\n  //    through Wasm, especially with Wasm stack switching),\n  //  - when an optimized function is deoptimized (for simplicity),\n  //  - after stack unwinding because of thrown exception.\n  //\n  // GC treats this value as a weak reference and resets it back to kNoContext\n  // if the context dies.\n  Tagged<Context> topmost_script_having_context_;\n\n  // This field is updated along with context_ on every operation triggered\n  // via V8 Api.\n  Address last_api_entry_;\n\n  // ] CEntry/CallApiCallback/CallApiGetter fields.\n\n  Tagged<Object> exception_ = Smi::zero();\n\n  static constexpr int exception_offset() {\n    return offsetof(ThreadLocalTop, exception_);\n  }\n\n  // Communication channel between Isolate::FindHandler and the CEntry.\n  Tagged<Context> pending_handler_context_;\n  Address pending_handler_entrypoint_;\n  Address pending_handler_constant_pool_;\n  Address pending_handler_fp_;\n  Address pending_handler_sp_;\n\n  // The top C++ try catch handler or nullptr if none are registered.\n  //\n  // This field is not guaranteed to hold an address that can be\n  // used for comparison with addresses into the JS stack. If such\n  // an address is needed, use try_catch_handler_address.\n  v8::TryCatch* try_catch_handler_;\n\n  // These two fields are updated rarely (on every thread restore).\n  Isolate* isolate_;\n  std::atomic<ThreadId> thread_id_;\n\n  // TODO(all): Combine into a bitfield.\n  uintptr_t num_frames_above_pending_handler_;\n  // Wasm Stack Switching: The central stack.\n  // If set, then we are currently executing code on the central stack.\n  uint8_t is_on_central_stack_flag_;\n  uint8_t rethrowing_message_;\n\n  // Communication channel between Isolate::Throw and message consumers.\n  Tagged<Object> pending_message_ = Smi::zero();\n\n  // Try-blocks are chained through the stack.\n  Address handler_;\n\n  // Simulator field is always present to get predictable layout.\n  Simulator* simulator_;\n  // The stack pointer of the bottom JS entry frame.\n  Address js_entry_sp_;\n  // The external callback we're currently in.\n  ExternalCallbackScope* external_callback_scope_;\n  StateTag current_vm_state_;\n  EmbedderState* current_embedder_state_;\n\n  // The top entry of the v8::Context::BackupIncumbentScope stack.\n  const v8::Context::BackupIncumbentScope* top_backup_incumbent_scope_;\n\n  // Call back function to report unsafe JS accesses.\n  v8::FailedAccessCheckCallback failed_access_check_callback_;\n\n  // Address of the thread-local \"thread in wasm\" flag.\n  Address thread_in_wasm_flag_address_;\n\n  // On switching from the central stack these fields are set\n  // to the central stack's SP and stack limit accordingly,\n  // to use for switching from secondary stacks.\n  Address central_stack_sp_;\n  Address central_stack_limit_;\n  // On switching to the central stack these fields are set\n  // to the secondary stack's SP and stack limit accordingly.\n  // It is used if we need to check for the stack overflow condition\n  // on the secondary stack, during execution on the central stack.\n  Address secondary_stack_sp_;\n  Address secondary_stack_limit_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ThreadLocalTop\",\n                \"parent\": \"ThreadLocalTop\",\n                \"about\": \"Constructor for the ThreadLocalTop class.\",\n                \"logic\": \"Calls the Clear() method to initialize the ThreadLocalTop object.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Clear\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  ThreadLocalTop() { Clear(); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Clear\",\n                \"parent\": \"ThreadLocalTop\",\n                \"about\": \"Clears the thread-local data.\",\n                \"logic\": \"Implementation not provided in the header.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  void Clear();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Initialize\",\n                \"parent\": \"ThreadLocalTop\",\n                \"about\": \"Initializes the thread data.\",\n                \"logic\": \"Implementation not provided in the header.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"Pointer to the Isolate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void Initialize(Isolate*);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"try_catch_handler_address\",\n                \"parent\": \"ThreadLocalTop\",\n                \"about\": \"Gets the address of the top C++ try catch handler.\",\n                \"logic\": \"Returns the JSStackComparableAddressPrivate() of the try_catch_handler_ if it exists, otherwise returns kNullAddress.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Address\",\n                    \"description\": \"Address of the try catch handler.\"\n                },\n                \"dependencies\": [\n                    \"v8::TryCatch\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Address try_catch_handler_address() {\n    if (try_catch_handler_) {\n      return try_catch_handler_->JSStackComparableAddressPrivate();\n    }\n    return kNullAddress;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IncrementCallDepth\",\n                \"parent\": \"ThreadLocalTop\",\n                \"about\": \"Increments the call depth.\",\n                \"logic\": \"Stores the stack height of the last API entry, clears the exception if clear_exception is true. Uses StoreCurrentStackPosition if USE_SIMULATOR or V8_USE_ADDRESS_SANITIZER is defined, otherwise stores the address of the stack_allocated_scope.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"stack_allocated_scope\",\n                        \"type\": \"Scope*\",\n                        \"purpose\": \"Pointer to the stack allocated scope.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Object\",\n                    \"Internals\",\n                    \"Isolate\",\n                    \"StoreCurrentStackPosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  template <bool clear_exception, typename Scope>\n  void IncrementCallDepth(Scope* stack_allocated_scope) {\n    stack_allocated_scope->previous_stack_height_ = last_api_entry_;\n#if defined(USE_SIMULATOR) || defined(V8_USE_ADDRESS_SANITIZER)\n    StoreCurrentStackPosition();\n#else\n    last_api_entry_ = reinterpret_cast<i::Address>(stack_allocated_scope);\n#endif\n    if constexpr (clear_exception) {\n      exception_ = Tagged<Object>(\n          Internals::GetRoot(reinterpret_cast<v8::Isolate*>(isolate_),\n                             Internals::kTheHoleValueRootIndex));\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"StoreCurrentStackPosition\",\n                \"parent\": \"ThreadLocalTop\",\n                \"about\": \"Stores the current stack position.\",\n                \"logic\": \"Implementation not provided in the header.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#if defined(USE_SIMULATOR) || defined(V8_USE_ADDRESS_SANITIZER)\n  void StoreCurrentStackPosition();\n#endif\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DecrementCallDepth\",\n                \"parent\": \"ThreadLocalTop\",\n                \"about\": \"Decrements the call depth.\",\n                \"logic\": \"Restores the last_api_entry_ from the stack_allocated_scope.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"stack_allocated_scope\",\n                        \"type\": \"Scope*\",\n                        \"purpose\": \"Pointer to the stack allocated scope.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  template <typename Scope>\n  void DecrementCallDepth(Scope* stack_allocated_scope) {\n    last_api_entry_ = stack_allocated_scope->previous_stack_height_;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CallDepthIsZero\",\n                \"parent\": \"ThreadLocalTop\",\n                \"about\": \"Checks if the call depth is zero.\",\n                \"logic\": \"Returns true if last_api_entry_ is kNullAddress, false otherwise.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the call depth is zero, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  bool CallDepthIsZero() const { return last_api_entry_ == kNullAddress; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Free\",\n                \"parent\": \"ThreadLocalTop\",\n                \"about\": \"Frees the thread-local data.\",\n                \"logic\": \"Implementation not provided in the header.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  void Free();\n        ]]></code>\n    </func>\n</file>\n```"
}