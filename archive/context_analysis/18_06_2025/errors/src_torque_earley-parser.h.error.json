{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/earley-parser.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/earley-parser.h\",\n            \"file_name\": \"earley-parser.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares classes and functions for an Earley parser used in the Torque language processing tool for V8.\",\n            \"note\": \"The V8_EXPORT_PRIVATE macro likely controls visibility of symbols, and may need to be handled during migration. The 'base::hash' namespace is used for hashing, which is relevant for the Item class's use in a hash table.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and Torque-specific headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <map>\n#include <memory>\n#include <optional>\n#include <vector>\n\n#include \"src/base/contextual.h\"\n#include \"src/torque/source-positions.h\"\n#include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ParseResultHolderBase\",\n                \"about\": \"Base class for holding parse results of various types. Uses a type ID to ensure correct casting.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"type_id_\",\n                        \"type\": \"TypeId\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the type ID of the held value.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass ParseResultHolderBase {\n public:\n  enum class TypeId;\n  virtual ~ParseResultHolderBase() = default;\n  template <class T>\n  T& Cast();\n  template <class T>\n  const T& Cast() const;\n\n protected:\n  explicit ParseResultHolderBase(TypeId type_id) : type_id_(type_id) {\n    // MSVC wrongly complains about type_id_ being an unused private field.\n    USE(type_id_);\n  }\n\n private:\n  const TypeId type_id_;\n};\n        ]]></code>\n    </class>\n\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum class\",\n                \"name\": \"ParseResultHolderBase::TypeId\",\n                \"about\": \"Enumerates the possible types of parse results that can be held by ParseResultHolderBase.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class ParseResultHolderBase::TypeId {\n  kStdString,\n  kBool,\n  kInt32,\n  kDouble,\n  kIntegerLiteral,\n  kStdVectorOfString,\n  kExpressionPtr,\n  kIdentifierPtr,\n  kOptionalIdentifierPtr,\n  kStatementPtr,\n  kDeclarationPtr,\n  kTypeExpressionPtr,\n  kOptionalTypeExpressionPtr,\n  kTryHandlerPtr,\n  kNameAndTypeExpression,\n  kEnumEntry,\n  kStdVectorOfEnumEntry,\n  kImplicitParameters,\n  kOptionalImplicitParameters,\n  kNameAndExpression,\n  kAnnotation,\n  kVectorOfAnnotation,\n  kAnnotationParameter,\n  kOptionalAnnotationParameter,\n  kClassFieldExpression,\n  kStructFieldExpression,\n  kBitFieldDeclaration,\n  kStdVectorOfNameAndTypeExpression,\n  kStdVectorOfNameAndExpression,\n  kStdVectorOfClassFieldExpression,\n  kStdVectorOfStructFieldExpression,\n  kStdVectorOfBitFieldDeclaration,\n  kIncrementDecrementOperator,\n  kOptionalStdString,\n  kStdVectorOfStatementPtr,\n  kStdVectorOfDeclarationPtr,\n  kStdVectorOfStdVectorOfDeclarationPtr,\n  kStdVectorOfExpressionPtr,\n  kExpressionWithSource,\n  kParameterList,\n  kTypeList,\n  kOptionalTypeList,\n  kLabelAndTypes,\n  kStdVectorOfLabelAndTypes,\n  kStdVectorOfTryHandlerPtr,\n  kOptionalStatementPtr,\n  kOptionalExpressionPtr,\n  kTypeswitchCase,\n  kStdVectorOfTypeswitchCase,\n  kStdVectorOfIdentifierPtr,\n  kOptionalClassBody,\n  kGenericParameter,\n  kGenericParameters,\n\n  kJsonValue,\n  kJsonMember,\n  kStdVectorOfJsonValue,\n  kStdVectorOfJsonMember,\n};\n        ]]></code>\n    </enum>\n\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"ParseResultTypeId\",\n                \"type\": \"type alias\",\n                \"target_type\": \"ParseResultHolderBase::TypeId\",\n                \"about\": \"Alias for ParseResultHolderBase::TypeId for convenience.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing ParseResultTypeId = ParseResultHolderBase::TypeId;\n        ]]></code>\n    </type_alias>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ParseResultHolder\",\n                \"about\": \"Template class for holding a parse result of a specific type. Derives from ParseResultHolderBase.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"value_\",\n                        \"type\": \"T\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the parse result value.\"\n                    },\n                     {\n                        \"name\": \"id\",\n                        \"type\": \"TypeId\",\n                        \"access\": \"private static\",\n                        \"purpose\": \"The static `TypeId` identifying the `ParseResultHolder`.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ParseResultHolderBase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nclass ParseResultHolder : public ParseResultHolderBase {\n public:\n  explicit ParseResultHolder(T value)\n      : ParseResultHolderBase(id), value_(std::move(value)) {}\n\n private:\n  V8_EXPORT_PRIVATE static const TypeId id;\n  friend class ParseResultHolderBase;\n  T value_;\n};\n        ]]></code>\n    </class>\n   \n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Cast\",\n                \"parent\": \"ParseResultHolderBase\",\n                \"about\": \"Casts the ParseResultHolderBase to a ParseResultHolder<T> and returns a reference to the held value.\",\n                \"logic\": \"Checks if the type ID matches the expected type and then performs a static cast.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"T&\",\n                    \"description\": \"A reference to the held value of type T.\"\n                },\n                \"dependencies\": [\n                    \"ParseResultHolderBase\",\n                    \"ParseResultHolder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nT& ParseResultHolderBase::Cast() {\n  CHECK_EQ(ParseResultHolder<T>::id, type_id_);\n  return static_cast<ParseResultHolder<T>*>(this)->value_;\n}\n        ]]></code>\n    </func>\n\n     <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Cast\",\n                \"parent\": \"ParseResultHolderBase\",\n                \"about\": \"Casts the ParseResultHolderBase to a ParseResultHolder<T> and returns a const reference to the held value.\",\n                \"logic\": \"Checks if the type ID matches the expected type and then performs a static cast.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"const T&\",\n                    \"description\": \"A const reference to the held value of type T.\"\n                },\n                \"dependencies\": [\n                    \"ParseResultHolderBase\",\n                    \"ParseResultHolder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nconst T& ParseResultHolderBase::Cast() const {\n  CHECK_EQ(ParseResultHolder<T>::id, type_id_);\n  return static_cast<const ParseResultHolder<T>*>(this)->value_;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ParseResult\",\n                \"about\": \"Wrapper class for a ParseResultHolderBase.  Provides a type-safe way to access the underlying parse result.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"value_\",\n                        \"type\": \"std::unique_ptr<ParseResultHolderBase>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the pointer to ParseResultHolderBase.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ParseResultHolderBase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass ParseResult {\n public:\n  template <class T>\n  explicit ParseResult(T x) : value_(new ParseResultHolder<T>(std::move(x))) {}\n\n  template <class T>\n  const T& Cast() const& {\n    return value_->Cast<T>();\n  }\n  template <class T>\n  T& Cast() & {\n    return value_->Cast<T>();\n  }\n  template <class T>\n  T&& Cast() && {\n    return std::move(value_->Cast<T>());\n  }\n\n private:\n  std::unique_ptr<ParseResultHolderBase> value_;\n};\n        ]]></code>\n    </class>\n\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"InputPosition\",\n                \"type\": \"type alias\",\n                \"target_type\": \"const char*\",\n                \"about\": \"Type alias for a const char*, representing a position in the input string.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nusing InputPosition = const char*;\n        ]]></code>\n    </type_alias>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"MatchedInput\",\n                \"about\": \"Represents a matched section of the input string along with its source position.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"begin\",\n                        \"type\": \"InputPosition\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Start of the matched input.\"\n                    },\n                    {\n                        \"name\": \"end\",\n                        \"type\": \"InputPosition\",\n                        \"access\": \"public\",\n                        \"purpose\": \"End of the matched input.\"\n                    },\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"SourcePosition\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Source position of the matched input.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"InputPosition\",\n                    \"SourcePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct MatchedInput {\n  MatchedInput(InputPosition begin, InputPosition end, SourcePosition pos)\n      : begin(begin), end(end), pos(pos) {}\n  InputPosition begin;\n  InputPosition end;\n  SourcePosition pos;\n  std::string ToString() const { return {begin, end}; }\n};\n        ]]></code>\n    </struct>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ParseResultIterator\",\n                \"about\": \"Iterator for accessing parse results. Holds a vector of ParseResult and a MatchedInput.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"results_\",\n                        \"type\": \"std::vector<ParseResult>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the parse results.\"\n                    },\n                    {\n                        \"name\": \"i_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Index of the current result.\"\n                    },\n                    {\n                        \"name\": \"matched_input_\",\n                        \"type\": \"MatchedInput\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the matched input for the results.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ParseResult\",\n                    \"MatchedInput\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass ParseResultIterator {\n public:\n  explicit ParseResultIterator(std::vector<ParseResult> results,\n                               MatchedInput matched_input)\n      : results_(std::move(results)), matched_input_(matched_input) {}\n\n  ParseResultIterator(const ParseResultIterator&) = delete;\n  ParseResultIterator& operator=(const ParseResultIterator&) = delete;\n\n  ParseResult Next() {\n    CHECK_LT(i_, results_.size());\n    return std::move(results_[i_++]);\n  }\n  template <class T>\n  T NextAs() {\n    return std::move(Next().Cast<T>());\n  }\n  bool HasNext() const { return i_ < results_.size(); }\n\n  const MatchedInput& matched_input() const { return matched_input_; }\n\n private:\n  std::vector<ParseResult> results_;\n  size_t i_ = 0;\n  MatchedInput matched_input_;\n};\n        ]]></code>\n    </class>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"LexerResult\",\n                \"about\": \"Represents the result of the lexer, containing the token symbols and their corresponding matched input.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"token_symbols\",\n                        \"type\": \"std::vector<Symbol*>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the token symbols.\"\n                    },\n                    {\n                        \"name\": \"token_contents\",\n                        \"type\": \"std::vector<MatchedInput>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the matched input for each token.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Symbol\",\n                    \"MatchedInput\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstruct LexerResult {\n  std::vector<Symbol*> token_symbols;\n  std::vector<MatchedInput> token_contents;\n};\n        ]]></code>\n    </struct>\n\n    <type_alias>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"Action\",\n                \"type\": \"type alias\",\n                \"target_type\": \"std::optional<ParseResult> (*)(ParseResultIterator* child_results)\",\n                \"about\": \"Type alias for a function pointer that represents a parsing action.\",\n                \"dependencies\": [\n                    \"ParseResult\",\n                    \"ParseResultIterator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing Action =\n    std::optional<ParseResult> (*)(ParseResultIterator* child_results);\n        ]]></code>\n    </type_alias>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DefaultAction\",\n                \"about\": \"Default parsing action that returns the first result from the child results.\",\n                \"logic\": \"If there are no child results, it returns an empty optional. Otherwise, it returns the first result.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"Iterator for the child parse results.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The first parse result or an empty optional.\"\n                },\n                \"dependencies\": [\n                    \"ParseResult\",\n                    \"ParseResultIterator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ninline std::optional<ParseResult> DefaultAction(\n    ParseResultIterator* child_results) {\n  if (!child_results->HasNext()) return std::nullopt;\n  return child_results->Next();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"AsSingletonVector\",\n                \"about\": \"Helper function that creates an action that returns a vector containing the result of another action.\",\n                \"logic\": \"It takes an action as a template parameter and returns a new action that calls the original action and wraps its result in a vector.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Action\",\n                    \"description\": \"A new action that returns a vector containing the result of the original action.\"\n                },\n                \"dependencies\": [\n                    \"ParseResult\",\n                    \"ParseResultIterator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, Action action>\ninline Action AsSingletonVector() {\n  return [](ParseResultIterator* child_results) -> std::optional<ParseResult> {\n    auto result = action(child_results);\n    if (!result) return result;\n    return ParseResult{std::vector<T>{(*result).Cast<T>()}};\n  };\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Rule\",\n                \"about\": \"Represents a rule in the context-free grammar.  Contains the right-hand side symbols and the action to be performed when the rule is matched.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"left_hand_side_\",\n                        \"type\": \"Symbol*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The symbol on the left-hand side of the rule.\"\n                    },\n                    {\n                        \"name\": \"right_hand_side_\",\n                        \"type\": \"std::vector<Symbol*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The symbols on the right-hand side of the rule.\"\n                    },\n                    {\n                        \"name\": \"action_\",\n                        \"type\": \"Action\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The action to be performed when the rule is matched.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Symbol\",\n                    \"Action\",\n                    \"ParseResult\",\n                    \"Item\",\n                    \"LexerResult\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// A rule of the context-free grammar. Each rule can have an action attached to\n// it, which is executed after the parsing is finished.\nclass Rule final {\n public:\n  explicit Rule(std::vector<Symbol*> right_hand_side,\n                Action action = DefaultAction)\n      : right_hand_side_(std::move(right_hand_side)), action_(action) {}\n\n  Symbol* left() const {\n    DCHECK_NOT_NULL(left_hand_side_);\n    return left_hand_side_;\n  }\n  const std::vector<Symbol*>& right() const { return right_hand_side_; }\n\n  void SetLeftHandSide(Symbol* left_hand_side) {\n    DCHECK_NULL(left_hand_side_);\n    left_hand_side_ = left_hand_side;\n  }\n\n  V8_EXPORT_PRIVATE std::optional<ParseResult> RunAction(\n      const Item* completed_item, const LexerResult& tokens) const;\n\n private:\n  Symbol* left_hand_side_ = nullptr;\n  std::vector<Symbol*> right_hand_side_;\n  Action action_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Symbol\",\n                \"about\": \"Represents a terminal or non-terminal symbol in the grammar. Stores rules where this symbol is on the left-hand side.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"rules_\",\n                        \"type\": \"std::vector<std::unique_ptr<Rule>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the rules where this symbol is on the left-hand side.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Rule\",\n                    \"Item\",\n                    \"LexerResult\",\n                    \"ParseResult\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// A Symbol represents a terminal or a non-terminal of the grammar.\n// It stores the list of rules, which have this symbol as the\n// left-hand side.\n// Terminals have an empty list of rules, they are created by the Lexer\n// instead of from rules.\n// Symbols need to reside at stable memory addresses, because the addresses are\n// used in the parser.\nclass Symbol {\n public:\n  Symbol() = default;\n  Symbol(std::initializer_list<Rule> rules) { *this = rules; }\n\n  // Disallow copying and moving to ensure Symbol has a stable address.\n  Symbol(const Symbol&) = delete;\n  Symbol& operator=(const Symbol&) = delete;\n\n  V8_EXPORT_PRIVATE Symbol& operator=(std::initializer_list<Rule> rules);\n\n  bool IsTerminal() const { return rules_.empty(); }\n  Rule* rule(size_t index) const { return rules_[index].get(); }\n  size_t rule_number() const { return rules_.size(); }\n\n  void AddRule(const Rule& rule) {\n    rules_.push_back(std::make_unique<Rule>(rule));\n    rules_.back()->SetLeftHandSide(this);\n  }\n\n  V8_EXPORT_PRIVATE std::optional<ParseResult> RunAction(\n      const Item* item, const LexerResult& tokens);\n\n private:\n  std::vector<std::unique_ptr<Rule>> rules_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Item\",\n                \"about\": \"Represents an item in the Earley parsing algorithm. Stores a rule, the current mark position, and the start and end positions in the input.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"rule_\",\n                        \"type\": \"const Rule*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The rule associated with this item.\"\n                    },\n                    {\n                        \"name\": \"mark_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current mark position in the rule's right-hand side.\"\n                    },\n                    {\n                        \"name\": \"start_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The start position of the input range matched by the item.\"\n                    },\n                    {\n                        \"name\": \"pos_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The end position of the input range matched by the item.\"\n                    },\n                    {\n                        \"name\": \"prev_\",\n                        \"type\": \"const Item*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the previous item in the parse tree.\"\n                    },\n                    {\n                        \"name\": \"child_\",\n                        \"type\": \"const Item*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the child item in the parse tree.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Rule\",\n                    \"Symbol\",\n                    \"LexerResult\",\n                    \"MatchedInput\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// Items are the core datastructure of Earley's algorithm.\n// They consist of a (partially) matched rule, a marked position inside of the\n// right-hand side of the rule (traditionally written as a dot) and an input\n// range from {start} to {pos} that matches the symbols of the right-hand side\n// that are left of the mark. In addition, they store a child and a left-sibling\n// pointer to reconstruct the AST in the end.\nclass Item {\n public:\n  Item(const Rule* rule, size_t mark, size_t start, size_t pos)\n      : rule_(rule), mark_(mark), start_(start), pos_(pos) {\n    DCHECK_LE(mark_, right().size());\n  }\n\n  // A complete item has the mark at the right end, which means the input range\n  // matches the complete rule.\n  bool IsComplete() const {\n    DCHECK_LE(mark_, right().size());\n    return mark_ == right().size();\n  }\n\n  // The symbol right after the mark is expected at {pos} for this item to\n  // advance.\n  Symbol* NextSymbol() const {\n    DCHECK(!IsComplete());\n    DCHECK_LT(mark_, right().size());\n    return right()[mark_];\n  }\n\n  // We successfully parsed NextSymbol() between {pos} and {new_pos}.\n  // If NextSymbol() was a non-terminal, then {child} is a pointer to a\n  // completed item for this parse.\n  // We create a new item, which moves the mark one forward.\n  Item Advance(size_t new_pos, const Item* child = nullptr) const {\n    if (child) {\n      DCHECK(child->IsComplete());\n      DCHECK_EQ(pos(), child->start());\n      DCHECK_EQ(new_pos, child->pos());\n      DCHECK_EQ(NextSymbol(), child->left());\n    }\n    Item result(rule_, mark_ + 1, start_, new_pos);\n    result.prev_ = this;\n    result.child_ = child;\n    return result;\n  }\n\n  // Collect the items representing the AST children of this completed item.\n  std::vector<const Item*> Children() const;\n  // The matched input separated according to the next branching AST level.\n  std::string SplitByChildren(const LexerResult& tokens) const;\n  // Check if {other} results in the same AST as this Item.\n  void CheckAmbiguity(const Item& other, const LexerResult& tokens) const;\n\n  MatchedInput GetMatchedInput(const LexerResult& tokens) const {\n    const MatchedInput& start = tokens.token_contents[start_];\n    const MatchedInput& end = start_ == pos_ ? tokens.token_contents[start_]\n                                             : tokens.token_contents[pos_ - 1];\n    CHECK_EQ(start.pos.source, end.pos.source);\n    SourcePosition combined{start.pos.source, start.pos.start, end.pos.end};\n\n    return {start.begin, end.end, combined};\n  }\n\n  // We exclude {prev_} and {child_} from equality and hash computations,\n  // because they are just globally unique data associated with an item.\n  bool operator==(const Item& other) const {\n    return rule_ == other.rule_ && mark_ == other.mark_ &&\n           start_ == other.start_ && pos_ == other.pos_;\n  }\n\n  friend size_t hash_value(const Item& i) {\n    return base::hash_combine(i.rule_, i.mark_, i.start_, i.pos_);\n  }\n\n  const Rule* rule() const { return rule_; }\n  Symbol* left() const { return rule_->left(); }\n  const std::vector<Symbol*>& right() const { return rule_->right(); }\n  size_t pos() const { return pos_; }\n  size_t start() const { return start_; }\n\n private:\n  const Rule* rule_;\n  size_t mark_;\n  size_t start_;\n  size_t pos_;\n\n  const Item* prev_ = nullptr;\n  const Item* child_ = nullptr;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RunAction\",\n                \"parent\": \"Symbol\",\n                \"about\": \"Runs the action associated with the given item's rule.\",\n                \"logic\": \"Verifies that the item is complete and that the item's left-hand side symbol is the current symbol, then runs the action associated with the rule.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"item\",\n                        \"type\": \"const Item*\",\n                        \"purpose\": \"The item to run the action for.\"\n                    },\n                    {\n                        \"name\": \"tokens\",\n                        \"type\": \"const LexerResult&\",\n                        \"purpose\": \"The lexer results.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The result of running the action.\"\n                },\n                \"dependencies\": [\n                    \"Item\",\n                    \"LexerResult\",\n                    \"ParseResult\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ninline std::optional<ParseResult> Symbol::RunAction(const Item* item,\n                                                    const LexerResult& tokens) {\n  DCHECK(item->IsComplete());\n  DCHECK_EQ(item->left(), this);\n  return item->rule()->RunAction(item, tokens);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RunEarleyAlgorithm\",\n                \"about\": \"Runs the Earley parsing algorithm.\",\n                \"logic\": \"Executes the Earley parsing algorithm using the provided start symbol, lexer tokens, and a set to track processed items.  Returns a pointer to the final item if the parse is successful.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"start\",\n                        \"type\": \"Symbol*\",\n                        \"purpose\": \"The start symbol of the grammar.\"\n                    },\n                    {\n                        \"name\": \"tokens\",\n                        \"type\": \"const LexerResult&\",\n                        \"purpose\": \"The lexer results.\"\n                    },\n                    {\n                        \"name\": \"processed\",\n                        \"type\": \"std::unordered_set<Item, base::hash<Item>>*\",\n                        \"purpose\": \"A set to track processed items.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const Item*\",\n                    \"description\": \"A pointer to the final item if the parse is successful, otherwise nullptr.\"\n                },\n                \"dependencies\": [\n                    \"Symbol\",\n                    \"LexerResult\",\n                    \"Item\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nV8_EXPORT_PRIVATE const Item* RunEarleyAlgorithm(\n    Symbol* start, const LexerResult& tokens,\n    std::unordered_set<Item, base::hash<Item>>* processed);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ParseTokens\",\n                \"about\": \"Parses the given tokens using the Earley algorithm.\",\n                \"logic\": \"Runs the Earley algorithm and then runs the action associated with the start symbol.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"start\",\n                        \"type\": \"Symbol*\",\n                        \"purpose\": \"The start symbol of the grammar.\"\n                    },\n                    {\n                        \"name\": \"tokens\",\n                        \"type\": \"const LexerResult&\",\n                        \"purpose\": \"The lexer results.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The result of parsing the tokens.\"\n                },\n                \"dependencies\": [\n                    \"Symbol\",\n                    \"LexerResult\",\n                    \"ParseResult\",\n                    \"Item\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ninline std::optional<ParseResult> ParseTokens(Symbol* start,\n                                              const LexerResult& tokens) {\n  std::unordered_set<Item, base::hash<Item>> table;\n  const Item* final_item = RunEarleyAlgorithm(start, tokens, &table);\n  return start->RunAction(final_item, tokens);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Lexer\",\n                \"about\": \"The Lexer class is responsible for tokenizing the input string. It matches patterns and keywords to generate a list of tokens.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"match_whitespace_\",\n                        \"type\": \"PatternFunction\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A function to match whitespace characters.\"\n                    },\n                    {\n                        \"name\": \"patterns_\",\n                        \"type\": \"std::map<PatternFunction, Symbol>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map of pattern functions to their corresponding symbols.\"\n                    },\n                    {\n                        \"name\": \"keywords_\",\n                        \"type\": \"std::map<std::string, Symbol>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map of keywords to their corresponding symbols.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Symbol\",\n                    \"LexerResult\",\n                    \"MatchedInput\",\n                    \"InputPosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// The lexical syntax is dynamically defined while building the grammar by\n// adding patterns and keywords to the Lexer.\n// The term keyword here can stand for any fixed character sequence, including\n// operators and parentheses.\n// Each pattern or keyword automatically gets a terminal symbol associated with\n// it. These symbols form the result of the lexing.\n// Patterns and keywords are matched using the longest match principle. If the\n// longest matching pattern coincides with a keyword, the keyword symbol is\n// chosen instead of the pattern.\n// In addition, there is a single whitespace pattern which is consumed but does\n// not become part of the token list.\nclass Lexer {\n public:\n  // Functions to define patterns. They try to match starting from {pos}. If\n  // successful, they return true and advance {pos}. Otherwise, {pos} stays\n  // unchanged.\n  using PatternFunction = bool (*)(InputPosition"
}