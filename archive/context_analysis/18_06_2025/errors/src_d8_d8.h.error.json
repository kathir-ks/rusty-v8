{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8.h\",\n        \"file_name\": \"d8.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Header file for the d8 shell, providing classes and functions for interacting with the V8 JavaScript engine in a shell environment.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard C++ library headers for various functionalities like iterators, maps, memory management, optional values, queues, strings, unordered maps and sets, and vectors.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <iterator>\n            #include <map>\n            #include <memory>\n            #include <optional>\n            #include <queue>\n            #include <string>\n            #include <unordered_map>\n            #include <unordered_set>\n            #include <vector>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"V8 public API headers for array buffers, isolates, scripts, and value serialization.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"include/v8-array-buffer.h\"\n            #include \"include/v8-isolate.h\"\n            #include \"include/v8-script.h\"\n            #include \"include/v8-value-serializer.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"V8 internal headers for base functionalities like one-time initialization, platform-specific time functions, platform wrappers, async hooks wrapper, global handles, parked scope, and task cancellation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/once.h\"\n            #include \"src/base/platform/time.h\"\n            #include \"src/base/platform/wrappers.h\"\n            #include \"src/d8/async-hooks-wrapper.h\"\n            #include \"src/handles/global-handles.h\"\n            #include \"src/heap/parked-scope.h\"\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8\",\n            \"purpose\": \"Enclosing namespace for V8 public API.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n        ]]></code>\n    </namespace>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Counter\",\n            \"about\": \"Represents a single counter in a counter collection, used for performance monitoring. Can be either a simple counter or a histogram.\",\n            \"attributes\": [\n                {\n                    \"name\": \"count_\",\n                    \"type\": \"std::atomic<int>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Atomic integer representing the counter's value.\"\n                },\n                {\n                    \"name\": \"sample_total_\",\n                    \"type\": \"std::atomic<int>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Atomic integer representing the sum of all samples added to the histogram.\"\n                },\n                {\n                    \"name\": \"is_histogram_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Boolean flag indicating whether the counter is a histogram.\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"char[kMaxNameSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Character array storing the counter's name.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class Counter {\n            public:\n                static const int kMaxNameSize = 64;\n                void Bind(const char* name, bool histogram);\n                // TODO(12482): Return pointer to an atomic.\n                int* ptr() {\n                    static_assert(sizeof(int) == sizeof(count_));\n                    return reinterpret_cast<int*>(&count_);\n                }\n                int count() const { return count_.load(std::memory_order_relaxed); }\n                int sample_total() const {\n                    return sample_total_.load(std::memory_order_relaxed);\n                }\n                bool is_histogram() const { return is_histogram_; }\n                void AddSample(int32_t sample);\n\n            private:\n                std::atomic<int> count_;\n                std::atomic<int> sample_total_;\n                bool is_histogram_;\n                char name_[kMaxNameSize];\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CounterCollection\",\n            \"about\": \"Represents a collection of counters, used for performance monitoring. Can be stored in a memory-mapped file.\",\n            \"attributes\": [\n                {\n                    \"name\": \"magic_number_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Magic number for identifying the counter collection file.\"\n                },\n                {\n                    \"name\": \"max_counters_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maximum number of counters in the collection.\"\n                },\n                {\n                    \"name\": \"max_name_size_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maximum size of counter names.\"\n                },\n                {\n                    \"name\": \"counters_in_use_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of counters currently in use.\"\n                },\n                {\n                    \"name\": \"counters_\",\n                    \"type\": \"Counter[kMaxCounters]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of Counter objects.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Counter\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CounterCollection {\n            public:\n                CounterCollection();\n                Counter* GetNextCounter();\n\n            private:\n                static const unsigned kMaxCounters = 512;\n                uint32_t magic_number_;\n                uint32_t max_counters_;\n                uint32_t max_name_size_;\n                uint32_t counters_in_use_;\n                Counter counters_[kMaxCounters];\n            };\n        ]]></code>\n    </class>\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"CounterMap\",\n            \"type\": \"std::unordered_map<std::string, Counter*>\",\n            \"purpose\": \"Type alias for a map that stores counters by name.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            using CounterMap = std::unordered_map<std::string, Counter*>;\n        ]]></code>\n    </typedef>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SourceGroup\",\n            \"about\": \"Represents a group of source files to be executed, potentially in a separate thread.\",\n            \"attributes\": [\n                {\n                    \"name\": \"next_semaphore_\",\n                    \"type\": \"i::ParkingSemaphore\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Semaphore used for signaling the next task.\"\n                },\n                {\n                    \"name\": \"done_semaphore_\",\n                    \"type\": \"i::ParkingSemaphore\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Semaphore used for signaling task completion.\"\n                },\n                {\n                    \"name\": \"thread_\",\n                    \"type\": \"base::Thread*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the thread used for execution.\"\n                },\n                {\n                    \"name\": \"argv_\",\n                    \"type\": \"const char**\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Argument vector for the source group.\"\n                },\n                {\n                    \"name\": \"begin_offset_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Starting offset in the argument vector.\"\n                },\n                {\n                    \"name\": \"end_offset_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Ending offset in the argument vector.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class SourceGroup {\n            public:\n                SourceGroup()\n                    : next_semaphore_(0),\n                    done_semaphore_(0),\n                    thread_(nullptr),\n                    argv_(nullptr),\n                    begin_offset_(0),\n                    end_offset_(0) {}\n\n                ~SourceGroup();\n\n                void Begin(char** argv, int offset) {\n                    argv_ = const_cast<const char**>(argv);\n                    begin_offset_ = offset;\n                }\n\n                void End(int offset) { end_offset_ = offset; }\n\n                // Returns true on success, false if an uncaught exception was thrown.\n                bool Execute(Isolate* isolate);\n\n                void StartExecuteInThread();\n                void WaitForThread(const i::ParkedScope& parked);\n                void JoinThread(const i::ParkedScope& parked);\n\n            private:\n                class IsolateThread : public base::Thread {\n                public:\n                    explicit IsolateThread(SourceGroup* group);\n\n                    void Run() override { group_->ExecuteInThread(); }\n\n                private:\n                    SourceGroup* group_;\n                };\n\n                void ExecuteInThread();\n\n                i::ParkingSemaphore next_semaphore_;\n                i::ParkingSemaphore done_semaphore_;\n                base::Thread* thread_;\n\n                void ExitShell(int exit_code);\n\n                const char** argv_;\n                int begin_offset_;\n                int end_offset_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SerializationData\",\n            \"about\": \"Holds the serialized data and associated backing stores for transferring data between isolates.\",\n            \"attributes\": [\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"std::unique_ptr<uint8_t, DataDeleter>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Unique pointer to the serialized data buffer.\"\n                },\n                {\n                    \"name\": \"size_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Size of the serialized data.\"\n                },\n                {\n                    \"name\": \"backing_stores_\",\n                    \"type\": \"std::vector<std::shared_ptr<v8::BackingStore>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of shared pointers to backing stores (ArrayBuffer data).\"\n                },\n                {\n                    \"name\": \"sab_backing_stores_\",\n                    \"type\": \"std::vector<std::shared_ptr<v8::BackingStore>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of shared pointers to SharedArrayBuffer backing stores.\"\n                },\n                {\n                    \"name\": \"compiled_wasm_modules_\",\n                    \"type\": \"std::vector<CompiledWasmModule>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of compiled WebAssembly modules.\"\n                },\n                {\n                    \"name\": \"shared_value_conveyor_\",\n                    \"type\": \"std::optional<v8::SharedValueConveyor>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Optional shared value conveyor for transferring data.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class SerializationData {\n            public:\n                SerializationData() = default;\n                SerializationData(const SerializationData&) = delete;\n                SerializationData& operator=(const SerializationData&) = delete;\n\n                uint8_t* data() { return data_.get(); }\n                size_t size() { return size_; }\n                const std::vector<std::shared_ptr<v8::BackingStore>>& backing_stores() {\n                    return backing_stores_;\n                }\n                const std::vector<std::shared_ptr<v8::BackingStore>>& sab_backing_stores() {\n                    return sab_backing_stores_;\n                }\n                const std::vector<CompiledWasmModule>& compiled_wasm_modules() {\n                    return compiled_wasm_modules_;\n                }\n                const std::optional<v8::SharedValueConveyor>& shared_value_conveyor() {\n                    return shared_value_conveyor_;\n                }\n\n            private:\n                struct DataDeleter {\n                    void operator()(uint8_t* p) const { base::Free(p); }\n                };\n\n                std::unique_ptr<uint8_t, DataDeleter> data_;\n                size_t size_ = 0;\n                std::vector<std::shared_ptr<v8::BackingStore>> backing_stores_;\n                std::vector<std::shared_ptr<v8::BackingStore>> sab_backing_stores_;\n                std::vector<CompiledWasmModule> compiled_wasm_modules_;\n                std::optional<v8::SharedValueConveyor> shared_value_conveyor_;\n\n            private:\n                friend class Serializer;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SerializationDataQueue\",\n            \"about\": \"A thread-safe queue for storing SerializationData objects, used for communication between threads.\",\n            \"attributes\": [\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mutex for protecting the queue.\"\n                },\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"std::vector<std::unique_ptr<SerializationData>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of unique pointers to SerializationData objects.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SerializationData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SerializationDataQueue {\n            public:\n                void Enqueue(std::unique_ptr<SerializationData> data);\n                bool Dequeue(std::unique_ptr<SerializationData>* data);\n                bool IsEmpty();\n                void Clear();\n\n            private:\n                base::Mutex mutex_;\n                std::vector<std::unique_ptr<SerializationData>> data_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Worker\",\n            \"extends\": \"std::enable_shared_from_this<Worker>\",\n            \"about\": \"Represents a worker thread that can execute JavaScript code in a separate isolate.\",\n            \"attributes\": [\n                {\n                    \"name\": \"out_semaphore_\",\n                    \"type\": \"i::ParkingSemaphore\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Semaphore for signaling the availability of outgoing messages.\"\n                },\n                {\n                    \"name\": \"out_queue_\",\n                    \"type\": \"SerializationDataQueue\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Queue for storing outgoing messages (SerializationData objects).\"\n                },\n                {\n                    \"name\": \"thread_\",\n                    \"type\": \"base::Thread*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the worker thread.\"\n                },\n                {\n                    \"name\": \"script_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the script to be executed by the worker.\"\n                },\n                {\n                    \"name\": \"flush_denormals_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether to flush denormals in the worker.\"\n                },\n                {\n                    \"name\": \"state_\",\n                    \"type\": \"std::atomic<State>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Atomic variable tracking the worker's state.\"\n                },\n                {\n                    \"name\": \"is_joined_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether the worker thread has been joined.\"\n                },\n                {\n                    \"name\": \"started_semaphore_\",\n                    \"type\": \"i::ParkingSemaphore\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Semaphore for signalling that the worker has started.\"\n                },\n                {\n                    \"name\": \"task_runner_\",\n                    \"type\": \"std::shared_ptr<TaskRunner>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Task runner for posting tasks to the worker.\"\n                },\n                {\n                    \"name\": \"task_manager_\",\n                    \"type\": \"i::CancelableTaskManager*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Task manager for managing cancelable tasks.\"\n                },\n                {\n                    \"name\": \"worker_mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mutex for protecting access to the worker's data members.\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the worker's isolate.\"\n                },\n                {\n                    \"name\": \"parent_isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the parent isolate that created the worker.\"\n                },\n                {\n                    \"name\": \"context_\",\n                    \"type\": \"Global<Context>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Global handle to the worker's context.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SerializationData\",\n                \"SerializationDataQueue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Worker : public std::enable_shared_from_this<Worker> {\n            public:\n                static constexpr i::ExternalPointerTag kManagedTag = i::kD8WorkerTag;\n\n                explicit Worker(Isolate* parent_isolate, const char* script,\n                                bool flush_denormals);\n                ~Worker();\n\n                // Post a message to the worker. The worker will take ownership of the\n                // SerializationData. This function should only be called by the thread that\n                // created the Worker.\n                void PostMessage(std::unique_ptr<SerializationData> data);\n                // Synchronously retrieve messages from the worker's outgoing message queue.\n                // If there is no message in the queue, block until a message is available.\n                // If there are no messages in the queue and the worker is no longer running,\n                // return nullptr.\n                // This function should only be called by the thread that created the Worker.\n                std::unique_ptr<SerializationData> GetMessage(Isolate* requester);\n                // Synchronously retrieve messages from the worker's outgoing message queue.\n                // If there is no message in the queue, or the worker is no longer running,\n                // return nullptr.\n                // This function should only be called by the thread that created the Worker.\n                std::unique_ptr<SerializationData> TryGetMessage();\n                // Terminate the worker's event loop. Messages from the worker that have been\n                // queued can still be read via GetMessage().\n                // This function can be called by any thread.\n                void Terminate();\n                // Terminate and join the thread.\n                // This function can be called by any thread.\n                void TerminateAndWaitForThread(const i::ParkedScope& parked);\n\n                // Start running the given worker in another thread.\n                static bool StartWorkerThread(Isolate* requester,\n                                                std::shared_ptr<Worker> worker,\n                                                base::Thread::Priority priority);\n\n                // Enters State::kTerminated for the Worker and resets the task runner.\n                void EnterTerminatedState();\n                bool IsTerminated() const { return state_ == State::kTerminated; }\n\n                // Returns the Worker instance for this thread.\n                static Worker* GetCurrentWorker();\n\n            private:\n                friend class ProcessMessageTask;\n                friend class TerminateTask;\n\n                enum class State {\n                    kReady,\n                    kPrepareRunning,\n                    kRunning,\n                    kTerminating,\n                    kTerminated,\n                };\n                bool is_running() const;\n\n                void ProcessMessage(std::unique_ptr<SerializationData> data);\n                void ProcessMessages();\n\n                class WorkerThread : public base::Thread {\n                public:\n                    explicit WorkerThread(std::shared_ptr<Worker> worker,\n                                            base::Thread::Priority priority)\n                        : base::Thread(base::Thread::Options(\"WorkerThread\", priority)),\n                        worker_(std::move(worker)) {}\n\n                    void Run() override;\n\n                private:\n                    std::shared_ptr<Worker> worker_;\n                };\n\n                void ExecuteInThread();\n                static void PostMessageOut(const v8::FunctionCallbackInfo<v8::Value>& info);\n                static void ImportScripts(const v8::FunctionCallbackInfo<v8::Value>& info);\n                static void Close(const v8::FunctionCallbackInfo<v8::Value>& info);\n\n                static void SetCurrentWorker(Worker* worker);\n\n                i::ParkingSemaphore out_semaphore_{0};\n                SerializationDataQueue out_queue_;\n\n                base::Thread* thread_ = nullptr;\n                char* script_;\n                bool flush_denormals_;\n                std::atomic<State> state_;\n                bool is_joined_ = false;\n                // For signalling that the worker has started.\n                i::ParkingSemaphore started_semaphore_{0};\n\n                // For posting tasks to the worker\n                std::shared_ptr<TaskRunner> task_runner_;\n                i::CancelableTaskManager* task_manager_;\n\n                // Protects reading / writing task_runner_. (The TaskRunner itself doesn't\n                // need locking, but accessing the Worker's data member does.)\n                base::Mutex worker_mutex_;\n\n                // The isolate should only be accessed by the worker itself, or when holding\n                // the worker_mutex_ and after checking the worker state.\n                Isolate* isolate_ = nullptr;\n                Isolate* parent_isolate_;\n\n                // Only accessed by the worker thread.\n                Global<Context> context_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PerIsolateData\",\n            \"about\": \"Stores per-isolate data required by the d8 shell.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The isolate associated with this data.\"\n                },\n                {\n                    \"name\": \"realm_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of realms created in this isolate.\"\n                },\n                {\n                    \"name\": \"realm_current_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Index of the current realm.\"\n                },\n                {\n                    \"name\": \"realm_switch_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Index of the realm to switch to.\"\n                },\n                {\n                    \"name\": \"realms_\",\n                    \"type\": \"Global<Context>*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of global handles to realms.\"\n                },\n                {\n                    \"name\": \"realm_shared_\",\n                    \"type\": \"Global<Value>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Global handle to a shared value across realms.\"\n                },\n                {\n                    \"name\": \"ignore_unhandled_promises_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether to ignore unhandled promise rejections.\"\n                },\n                {\n                    \"name\": \"unhandled_promises_\",\n                    \"type\": \"std::vector<std::tuple<Global<Promise>, Global<Message>, Global<Value>>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of unhandled promises and associated data.\"\n                },\n                {\n                    \"name\": \"async_hooks_wrapper_\",\n                    \"type\": \"AsyncHooks*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Wrapper for asynchronous hooks.\"\n                },\n                {\n                    \"name\": \"import_data_\",\n                    \"type\": \"std::unordered_set<DynamicImportData*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Set of dynamic import data (only in LEAK_SANITIZER builds).\"\n                },\n                {\n                    \"name\": \"test_api_object_ctor_\",\n                    \"type\": \"Global<FunctionTemplate>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Global handle to the test API object constructor.\"\n                },\n                {\n                    \"name\": \"dom_node_ctor_\",\n                    \"type\": \"Global<FunctionTemplate>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Global handle to the DOM node constructor.\"\n                },\n                {\n                    \"name\": \"registered_workers_\",\n                    \"type\": \"std::set<std::shared_ptr<Worker>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Set of registered workers.\"\n                },\n                {\n                    \"name\": \"worker_message_callbacks_\",\n                    \"type\": \"std::map<std::shared_ptr<Worker>, std::pair<Global<Context>, Global<Function>>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of worker message callbacks.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AsyncHooks\",\n                \"Worker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class PerIsolateData {\n            public:\n                explicit PerIsolateData(Isolate* isolate);\n\n                ~PerIsolateData();\n\n                inline static PerIsolateData* Get(Isolate* isolate) {\n                    return reinterpret_cast<PerIsolateData*>(isolate->GetData(0));\n                }\n\n                class V8_NODISCARD RealmScope {\n                public:\n                    explicit RealmScope(Isolate* isolate, const Global<Context>& context);\n                    ~RealmScope();\n\n                private:\n                    PerIsolateData* data_;\n                };\n\n                // Contrary to RealmScope (which creates a new Realm), ExplicitRealmScope\n                // allows for entering an existing Realm, as specified by its index.\n                class V8_NODISCARD ExplicitRealmScope {\n                public:\n                    explicit ExplicitRealmScope(PerIsolateData* data, int index);\n                    ~ExplicitRealmScope();\n\n                    Local<Context> context() const;\n\n                private:\n                    PerIsolateData* data_;\n                    Local<Context> realm_;\n                    int index_;\n                    int previous_index_;\n                };\n\n                AsyncHooks* GetAsyncHooks() { return async_hooks_wrapper_; }\n\n                void RemoveUnhandledPromise(Local<Promise> promise);\n                void AddUnhandledPromise(Local<Promise> promise, Local<Message> message,\n                                        Local<Value> exception);\n                int HandleUnhandledPromiseRejections();\n\n                // Keep track of DynamicImportData so we can properly free it on shutdown\n                // when LEAK_SANITIZER is active.\n                void AddDynamicImportData(DynamicImportData*);\n                void DeleteDynamicImportData(DynamicImportData*);\n\n                Local<FunctionTemplate> GetTestApiObjectCtor() const;\n                void SetTestApiObjectCtor(Local<FunctionTemplate> ctor);\n\n                Local<FunctionTemplate> GetDomNodeCtor() const;\n                void SetDomNodeCtor(Local<FunctionTemplate> ctor);\n\n                bool HasRunningSubscribedWorkers();\n                void RegisterWorker(std::shared_ptr<Worker> worker);\n                void SubscribeWorkerOnMessage(const std::shared_ptr<Worker>& worker,\n                                                Local<Context> context,\n                                                Local<Function> callback);\n                std::pair<Local<Context>, Local<Function>> GetWorkerOnMessage(\n                    const std::shared_ptr<Worker>& worker) const;\n                void UnregisterWorker(const std::shared_ptr<Worker>& worker);\n\n            private:\n                friend class Shell;\n                friend class RealmScope;\n                Isolate* isolate_;\n                int realm_count_;\n                int realm_current_;\n                int realm_switch_;\n                Global<Context>* realms_;\n                Global<Value> realm_shared_;\n                bool ignore_unhandled_promises_;\n                std::vector<std::tuple<Global<Promise>, Global<Message>, Global<Value>>>\n                    unhandled_promises_;\n                AsyncHooks* async_hooks_wrapper_;\n#if defined(LEAK_SANITIZER)\n                std::unordered_set<DynamicImportData*> import_data_;\n#endif\n                Global<FunctionTemplate> test_api_object_ctor_;\n                Global<FunctionTemplate> dom_node_ctor_;\n                // Track workers and their callbacks separately, so that we know both which\n                // workers are still registered, and which of them have callbacks. We can't\n                // rely on Shell::running_workers_ or worker.IsTerminated(), because these are\n                // set concurrently and may race with callback subscription.\n                std::set<std::shared_ptr<Worker>> registered_workers_;\n                std::map<std::shared_ptr<Worker>,\n                            std::pair<Global<Context>, Global<Function>>>\n                    worker_message_callbacks_;\n\n                int RealmIndexOrThrow(const v8::FunctionCallbackInfo<v8::Value>& info,\n                                        int arg_offset);\n                int RealmFind(Local<Context> context);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ShellOptions\",\n            \"about\": \"Stores command-line options for the d8 shell.\",\n            \"attributes\": [\n                {\n                    \"name\": \"d8_path\",\n                    \"type\": \"DisallowReassignment<const char*>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Path to the d8 executable.\"\n                },\n                {\n                    \"name\": \"fuzzilli_coverage_statistics\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Enable Fuzzilli coverage statistics.\"\n                },\n                {\n                    \"name\": \"fuzzilli_enable_builtins_coverage\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Enable Fuzzilli builtins coverage.\"\n                },\n                {\n                    \"name\": \"send_idle_notification\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Send idle notifications to the V8 engine.\"\n                },\n                {\n                    \"name\": \"invoke_weak_callbacks\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Invoke weak callbacks.\"\n                },\n                {\n                    \"name\": \"omit_quit\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Omit the quit function from the global scope.\"\n                },\n                {\n                    \"name\": \"wait_for_background_tasks\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Wait for background tasks to complete.\"\n                },\n                {\n                    \"name\": \"simulate_errors\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Simulate errors for testing purposes.\"\n                },\n                {\n                    \"name\": \"stress_runs\",\n                    \"type\": \"DisallowReassignment<int>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Number of stress runs to perform.\"\n                },\n                {\n                    \"name\": \"interactive_shell\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Enable interactive shell mode.\"\n                },\n                {\n                    \"name\": \"test_shell\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Enable test shell mode.\"\n                },\n                {\n                    \"name\": \"expected_to_throw\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Expect the script to throw an exception.\"\n                },\n                {\n                    \"name\": \"no_fail\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Do not fail if an exception is thrown.\"\n                },\n                {\n                    \"name\": \"dump_counters\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Dump V8 counters.\"\n                },\n                {\n                    \"name\": \"dump_counters_nvp\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Dump V8 counters in name-value pair format.\"\n                },\n                {\n                    \"name\": \"dump_system_memory_stats\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Dump system memory statistics.\"\n                },\n                {\n                    \"name\": \"ignore_unhandled_promises\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Ignore unhandled promise rejections.\"\n                },\n                {\n                    \"name\": \"mock_arraybuffer_allocator\",\n                    \"type\": \"DisallowReassignment<bool>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Mock ArrayBuffer allocator.\"\n                },\n                {\n                    \"name\": \"mock_arraybuffer_allocator_limit\",\n                    \"type\": \"DisallowReassignment<size_t>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Limit for the mock ArrayBuffer allocator.\"\n                },\n                {\n                    "
}