{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/types.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/types.h\",\n            \"file_name\": \"types.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the type system for the Torque language, including classes for representing various types and their properties.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers for data structures and utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <algorithm>\n            #include <optional>\n            #include <set>\n            #include <string>\n            #include <vector>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes Torque-specific headers for AST nodes, constants, source positions, and utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/torque/ast.h\"\n            #include \"src/torque/constants.h\"\n            #include \"src/torque/source-positions.h\"\n            #include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::internal::torque\",\n                \"purpose\": \"Encapsulates all Torque-related code within the V8 namespace.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8::internal::torque {\n        ]]></code>\n    </namespace>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TypeBase\",\n                \"about\": \"Base class for all types in the Torque type system.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"kind_\",\n                        \"type\": \"Kind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the kind of the type.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class TypeBase {\n            public:\n              enum class Kind {\n                kTopType,\n                kAbstractType,\n                kBuiltinPointerType,\n                kUnionType,\n                kBitFieldStructType,\n                kStructType,\n                kClassType\n              };\n              virtual ~TypeBase() = default;\n              bool IsTopType() const { return kind() == Kind::kTopType; }\n              bool IsAbstractType() const { return kind() == Kind::kAbstractType; }\n              bool IsBuiltinPointerType() const {\n                return kind() == Kind::kBuiltinPointerType;\n              }\n              bool IsUnionType() const { return kind() == Kind::kUnionType; }\n              bool IsBitFieldStructType() const {\n                return kind() == Kind::kBitFieldStructType;\n              }\n              bool IsStructType() const { return kind() == Kind::kStructType; }\n              bool IsClassType() const { return kind() == Kind::kClassType; }\n              bool IsAggregateType() const { return IsStructType() || IsClassType(); }\n\n             protected:\n              explicit TypeBase(Kind kind) : kind_(kind) {}\n              Kind kind() const { return kind_; }\n\n             private:\n              const Kind kind_;\n            };\n        ]]></code>\n    </class>\n    <macro>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"DECLARE_TYPE_BOILERPLATE\",\n                \"purpose\": \"Defines a set of static methods for casting TypeBase pointers to specific derived types.  Helps with downcasting within the type hierarchy.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #define DECLARE_TYPE_BOILERPLATE(x)                         \\\n              static x* cast(TypeBase* declarable) {                    \\\n                DCHECK(declarable->Is##x());                            \\\n                return static_cast<x*>(declarable);                     \\\n              }                                                         \\\n              static const x* cast(const TypeBase* declarable) {        \\\n                DCHECK(declarable->Is##x());                            \\\n                return static_cast<const x*>(declarable);               \\\n              }                                                         \\\n              static x* DynamicCast(TypeBase* declarable) {             \\\n                if (!declarable) return nullptr;                        \\\n                if (!declarable->Is##x()) return nullptr;               \\\n                return static_cast<x*>(declarable);                     \\\n              }                                                         \\\n              static const x* DynamicCast(const TypeBase* declarable) { \\\n                if (!declarable) return nullptr;                        \\\n                if (!declarable->Is##x()) return nullptr;               \\\n                return static_cast<const x*>(declarable);               \\\n              }\n        ]]></code>\n    </macro>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"TypeVector\",\n                \"type\": \"std::vector<const Type*>\",\n                \"purpose\": \"Defines a type alias for a vector of Type pointers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            using TypeVector = std::vector<const Type*>;\n        ]]></code>\n    </typedef>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"SpecializationKey\",\n                \"about\": \"Key for generic type specialization, holds the generic type and the specialized types.\",\n                \"dependencies\": [\n                    \"GenericType\",\n                    \"TypeVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            struct SpecializationKey {\n              T* generic;\n              TypeVector specialized_types;\n            };\n        ]]></code>\n    </struct>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"MaybeSpecializationKey\",\n                \"type\": \"std::optional<SpecializationKey<GenericType>>\",\n                \"purpose\": \"Defines a type alias for an optional SpecializationKey for GenericType.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            using MaybeSpecializationKey = std::optional<SpecializationKey<GenericType>>;\n        ]]></code>\n    </typedef>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"TypeChecker\",\n                \"about\": \"Represents a type checker function and optional weak reference information.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"std::string\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Name of the type checker function (e.g., 'IsFoo').\"\n                    },\n                    {\n                        \"name\": \"weak_ref_to\",\n                        \"type\": \"std::string\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Corresponding strong object type if the type is 'MaybeObject', otherwise empty.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            struct TypeChecker {\n              // The type of the object. This string is not guaranteed to correspond to a\n              // C++ class, but just to a type checker function: for any type \"Foo\" here,\n              // the function IsFoo must exist.\n              std::string type;\n              // If {type} is \"MaybeObject\", then {weak_ref_to} indicates the corresponding\n              // strong object type. Otherwise, {weak_ref_to} is empty.\n              std::string weak_ref_to;\n            };\n        ]]></code>\n    </struct>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Type\",\n                \"extends\": \"TypeBase\",\n                \"about\": \"Represents a type in the Torque type system, inheriting from TypeBase.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"parent_\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The supertype of this type, if any.\"\n                    },\n                    {\n                        \"name\": \"aliases_\",\n                        \"type\": \"mutable std::set<std::string>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of aliases for this type.\"\n                    },\n                    {\n                        \"name\": \"id_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Unique identifier for this type.\"\n                    },\n                    {\n                        \"name\": \"specialized_from_\",\n                        \"type\": \"MaybeSpecializationKey\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Information about how this type was specialized from a generic type.\"\n                    },\n                    {\n                        \"name\": \"constexpr_version_\",\n                        \"type\": \"mutable const Type*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Corresponding constexpr version of this type, if any.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TypeBase\",\n                    \"MaybeSpecializationKey\",\n                    \"ClassType\",\n                    \"StructType\",\n                    \"AggregateType\",\n                    \"TypeChecker\",\n                    \"VOID_TYPE_STRING\",\n                    \"NEVER_TYPE_STRING\",\n                    \"BOOL_TYPE_STRING\",\n                    \"CONSTEXPR_BOOL_TYPE_STRING\",\n                    \"FLOAT32_TYPE_STRING\",\n                    \"FLOAT64_TYPE_STRING\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE Type : public TypeBase {\n             public:\n              Type& operator=(const Type& other) = delete;\n              virtual bool IsSubtypeOf(const Type* supertype) const;\n\n              // Default rendering for error messages etc.\n              std::string ToString() const;\n\n              // This name is not unique, but short and somewhat descriptive.\n              // Used for naming generated code.\n              virtual std::string SimpleName() const;\n\n              enum class HandleKind { kIndirect, kDirect };\n              std::string GetHandleTypeName(HandleKind kind,\n                                            const std::string& type_name) const;\n\n              std::string TagglifiedCppTypeName() const;\n              std::string HandlifiedCppTypeName(HandleKind kind) const;\n\n              const Type* parent() const { return parent_; }\n              bool IsVoid() const { return IsAbstractName(VOID_TYPE_STRING); }\n              bool IsNever() const { return IsAbstractName(NEVER_TYPE_STRING); }\n              bool IsBool() const { return IsAbstractName(BOOL_TYPE_STRING); }\n              bool IsConstexprBool() const {\n                return IsAbstractName(CONSTEXPR_BOOL_TYPE_STRING);\n              }\n              bool IsVoidOrNever() const { return IsVoid() || IsNever(); }\n              bool IsFloat32() const { return IsAbstractName(FLOAT32_TYPE_STRING); }\n              bool IsFloat64() const { return IsAbstractName(FLOAT64_TYPE_STRING); }\n              std::string GetGeneratedTypeName() const;\n              std::string GetGeneratedTNodeTypeName() const;\n              virtual bool IsConstexpr() const {\n                if (parent()) DCHECK(!parent()->IsConstexpr());\n                return false;\n              }\n              virtual bool IsTransient() const { return false; }\n              virtual const Type* NonConstexprVersion() const { return this; }\n              virtual std::string GetConstexprGeneratedTypeName() const;\n              std::optional<const ClassType*> ClassSupertype() const;\n              std::optional<const StructType*> StructSupertype() const;\n              std::optional<const AggregateType*> AggregateSupertype() const;\n              virtual std::vector<TypeChecker> GetTypeCheckers() const { return {}; }\n              virtual std::string GetRuntimeType() const;\n              virtual std::string GetDebugType() const;\n              static const Type* CommonSupertype(const Type* a, const Type* b);\n              void AddAlias(std::string alias) const { aliases_.insert(std::move(alias)); }\n              size_t id() const { return id_; }\n              const MaybeSpecializationKey& GetSpecializedFrom() const {\n                return specialized_from_;\n              }\n\n              static std::optional<const Type*> MatchUnaryGeneric(const Type* type,\n                                                                  GenericType* generic);\n\n              static std::string ComputeName(const std::string& basename,\n                                             MaybeSpecializationKey specialized_from);\n              virtual void SetConstexprVersion(const Type* type) const {\n                constexpr_version_ = type;\n              }\n\n              virtual const Type* ConstexprVersion() const {\n                if (constexpr_version_) return constexpr_version_;\n                if (IsConstexpr()) return this;\n                if (parent()) return parent()->ConstexprVersion();\n                return nullptr;\n              }\n\n              virtual size_t AlignmentLog2() const;\n\n             protected:\n              Type(TypeBase::Kind kind, const Type* parent,\n                   MaybeSpecializationKey specialized_from = std::nullopt);\n              Type(const Type& other) V8_NOEXCEPT;\n              void set_parent(const Type* t) { parent_ = t; }\n              int Depth() const;\n              virtual std::string ToExplicitString() const = 0;\n              virtual std::string GetGeneratedTypeNameImpl() const = 0;\n              virtual std::string GetGeneratedTNodeTypeNameImpl() const = 0;\n              virtual std::string SimpleNameImpl() const = 0;\n\n             private:\n              bool IsAbstractName(const std::string& name) const;\n\n              // If {parent_} is not nullptr, then this type is a subtype of {parent_}.\n              const Type* parent_;\n              mutable std::set<std::string> aliases_;\n              size_t id_;\n              MaybeSpecializationKey specialized_from_;\n              mutable const Type* constexpr_version_ = nullptr;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"hash_value\",\n                \"about\": \"Computes a hash value for a TypeVector.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"types\",\n                        \"type\": \"const TypeVector&\",\n                        \"purpose\": \"The TypeVector to hash.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The computed hash value.\"\n                },\n                \"dependencies\": [\n                    \"TypeVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            inline size_t hash_value(const TypeVector& types) {\n              size_t hash = 0;\n              for (const Type* t : types) {\n                hash = base::hash_combine(hash, t);\n              }\n              return hash;\n            }\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"NameAndType\",\n                \"about\": \"Represents a name and a type.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"std::string\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The name.\"\n                    },\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The type.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct NameAndType {\n              std::string name;\n              const Type* type;\n            };\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for NameAndType to allow printing it to an ostream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The ostream to print to.\"\n                    },\n                    {\n                        \"name\": \"name_and_type\",\n                        \"type\": \"const NameAndType&\",\n                        \"purpose\": \"The NameAndType to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The ostream.\"\n                },\n                \"dependencies\": [\n                    \"NameAndType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os, const NameAndType& name_and_type);\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"Field\",\n                \"about\": \"Represents a field in a struct or class.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"SourcePosition\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The source position where the field is declared.\"\n                    },\n                    {\n                        \"name\": \"aggregate\",\n                        \"type\": \"const AggregateType*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The aggregate type (struct or class) that contains this field.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"std::optional<ClassFieldIndexInfo>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Index information if this field is part of an indexed field.\"\n                    },\n                    {\n                        \"name\": \"name_and_type\",\n                        \"type\": \"NameAndType\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The name and type of the field.\"\n                    },\n                    {\n                        \"name\": \"offset\",\n                        \"type\": \"std::optional<size_t>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The byte offset of this field within the containing struct or class.\"\n                    },\n                    {\n                        \"name\": \"custom_weak_marking\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether the field requires custom weak marking.\"\n                    },\n                    {\n                        \"name\": \"const_qualified\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether the field is const qualified.\"\n                    },\n                    {\n                        \"name\": \"synchronization\",\n                        \"type\": \"FieldSynchronization\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Synchronization properties of this field\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"SourcePosition\",\n                    \"AggregateType\",\n                    \"NameAndType\",\n                    \"ClassFieldIndexInfo\",\n                    \"FieldSynchronization\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct Field {\n              // TODO(danno): This likely should be refactored, the handling of the types\n              // using the universal grab-bag utility with std::tie, as well as the\n              // reliance of string types is quite clunky.\n              std::tuple<size_t, std::string> GetFieldSizeInformation() const;\n\n              void ValidateAlignment(ResidueClass at_offset) const;\n\n              SourcePosition pos;\n              const AggregateType* aggregate;\n              std::optional<ClassFieldIndexInfo> index;\n              NameAndType name_and_type;\n\n              // The byte offset of this field from the beginning of the containing class or\n              // struct. Most structs are never packed together in memory, and are only used\n              // to hold a batch of related CSA TNode values, in which case |offset| is\n              // irrelevant.\n              // The offset may be unknown because the field is after an indexed field or\n              // because we don't support the struct field for on-heap layouts.\n              std::optional<size_t> offset;\n\n              bool custom_weak_marking;\n              bool const_qualified;\n              FieldSynchronization synchronization;\n            };\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for Field to allow printing it to an ostream.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The ostream to print to.\"\n                    },\n                    {\n                        \"name\": \"name_and_type\",\n                        \"type\": \"const Field&\",\n                        \"purpose\": \"The Field to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The ostream.\"\n                },\n                \"dependencies\": [\n                    \"Field\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os, const Field& name_and_type);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TopType\",\n                \"extends\": \"Type\",\n                \"about\": \"Represents the top type in the type system (inaccessible type).\",\n                \"attributes\": [\n                    {\n                        \"name\": \"reason_\",\n                        \"type\": \"std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reason why this type is inaccessible.\"\n                    },\n                    {\n                        \"name\": \"source_type_\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The type that is now inaccessible.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class TopType final : public Type {\n             public:\n              DECLARE_TYPE_BOILERPLATE(TopType)\n              std::string GetGeneratedTypeNameImpl() const override { UNREACHABLE(); }\n              std::string GetGeneratedTNodeTypeNameImpl() const override {\n                return source_type_->GetGeneratedTNodeTypeName();\n              }\n              std::string ToExplicitString() const override {\n                std::stringstream s;\n                s << \"inaccessible \" + source_type_->ToString();\n                return s.str();\n              }\n\n              const Type* source_type() const { return source_type_; }\n              const std::string reason() const { return reason_; }\n\n             private:\n              friend class TypeOracle;\n              explicit TopType(std::string reason, const Type* source_type)\n                  : Type(Kind::kTopType, nullptr),\n                    reason_(std::move(reason)),\n                    source_type_(source_type) {}\n              std::string SimpleNameImpl() const override { return \"TopType\"; }\n\n              std::string reason_;\n              const Type* source_type_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AbstractType\",\n                \"extends\": \"Type\",\n                \"about\": \"Represents an abstract type in the Torque type system.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"flags_\",\n                        \"type\": \"AbstractTypeFlags\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flags indicating properties of the abstract type.\"\n                    },\n                    {\n                        \"name\": \"name_\",\n                        \"type\": \"const std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The name of the abstract type.\"\n                    },\n                    {\n                        \"name\": \"generated_type_\",\n                        \"type\": \"const std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Name of the generated type for this abstract type.\"\n                    },\n                    {\n                        \"name\": \"non_constexpr_version_\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The non-constexpr version of this type, if it is a constexpr type.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\",\n                    \"AbstractTypeFlags\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class AbstractType final : public Type {\n             public:\n              DECLARE_TYPE_BOILERPLATE(AbstractType)\n              const std::string& name() const { return name_; }\n              std::string ToExplicitString() const override { return name(); }\n              std::string GetGeneratedTypeNameImpl() const override;\n              std::string GetGeneratedTNodeTypeNameImpl() const override;\n              bool IsConstexpr() const final {\n                const bool is_constexpr = flags_ & AbstractTypeFlag::kConstexpr;\n                DCHECK_IMPLIES(non_constexpr_version_ != nullptr, is_constexpr);\n                return is_constexpr;\n              }\n\n              const Type* NonConstexprVersion() const override {\n                if (non_constexpr_version_) return non_constexpr_version_;\n                if (!IsConstexpr()) return this;\n                if (parent()) return parent()->NonConstexprVersion();\n                return nullptr;\n              }\n\n              std::vector<TypeChecker> GetTypeCheckers() const override;\n\n              size_t AlignmentLog2() const override;\n\n             private:\n              friend class TypeOracle;\n              AbstractType(const Type* parent, AbstractTypeFlags flags,\n                           const std::string& name, const std::string& generated_type,\n                           const Type* non_constexpr_version,\n                           MaybeSpecializationKey specialized_from)\n                  : Type(Kind::kAbstractType, parent, specialized_from),\n                    flags_(flags),\n                    name_(name),\n                    generated_type_(generated_type),\n                    non_constexpr_version_(non_constexpr_version) {\n                if (parent) DCHECK_EQ(parent->IsConstexpr(), IsConstexpr());\n                DCHECK_EQ(IsConstexprName(name), IsConstexpr());\n                DCHECK_IMPLIES(non_constexpr_version_ != nullptr, IsConstexpr());\n                DCHECK(!(IsConstexpr() && (flags_ & AbstractTypeFlag::kTransient)));\n              }\n\n              std::string SimpleNameImpl() const override {\n                if (IsConstexpr()) {\n                  const Type* non_constexpr_version = NonConstexprVersion();\n                  if (non_constexpr_version == nullptr) {\n                    ReportError(\"Cannot find non-constexpr type corresponding to \", *this);\n                  }\n                  return \"constexpr_\" + non_constexpr_version->SimpleName();\n                }\n                return name();\n              }\n\n              bool IsTransient() const override {\n                return flags_ & AbstractTypeFlag::kTransient;\n              }\n\n              bool UseParentTypeChecker() const {\n                return flags_ & AbstractTypeFlag::kUseParentTypeChecker;\n              }\n\n              AbstractTypeFlags flags_;\n              const std::string name_;\n              const std::string generated_type_;\n              const Type* non_constexpr_version_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BuiltinPointerType\",\n                \"extends\": \"Type\",\n                \"about\": \"Represents a builtin pointer type in the Torque type system.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"parameter_types_\",\n                        \"type\": \"const TypeVector\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of parameter types for the builtin pointer.\"\n                    },\n                    {\n                        \"name\": \"return_type_\",\n                        \"type\": \"const Type* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The return type of the builtin pointer.\"\n                    },\n                    {\n                        \"name\": \"function_pointer_type_id_\",\n                        \"type\": \"const size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"ID of the function pointer type.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\",\n                    \"TypeVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // For now, builtin pointers are restricted to Torque-defined builtins.\n            class V8_EXPORT_PRIVATE BuiltinPointerType final : public Type {\n             public:\n              DECLARE_TYPE_BOILERPLATE(BuiltinPointerType)\n              std::string ToExplicitString() const override;\n              std::string GetGeneratedTypeNameImpl() const override {\n                return parent()->GetGeneratedTypeName();\n              }\n              std::string GetGeneratedTNodeTypeNameImpl() const override {\n                return parent()->GetGeneratedTNodeTypeName();\n              }\n\n              const TypeVector& parameter_types() const { return parameter_types_; }\n              const Type* return_type() const { return return_type_; }\n\n              friend size_t hash_value(const BuiltinPointerType& p) {\n                size_t result = base::hash_value(p.return_type_);\n                for (const Type* parameter : p.parameter_types_) {\n                  result = base::hash_combine(result, parameter);\n                }\n                return result;\n              }\n              bool operator==(const BuiltinPointerType& other) const {\n                return parameter_types_ == other.parameter_types_ &&\n                       return_type_ == other.return_type_;\n              }\n              size_t function_pointer_type_id() const { return function_pointer_type_id_; }\n\n              std::vector<TypeChecker> GetTypeCheckers() const override {\n                return {{\"Smi\", \"\"}};\n              }\n\n              bool HasContextParameter() const;\n\n             private:\n              friend class TypeOracle;\n              BuiltinPointerType(const Type* parent, TypeVector parameter_types,\n                                 const Type* return_type, size_t function_pointer_type_id)\n                  : Type(Kind::kBuiltinPointerType, parent),\n                    parameter_types_(parameter_types),\n                    return_type_(return_type),\n                    function_pointer_type_id_(function_pointer_type_id) {}\n              std::string SimpleNameImpl() const override;\n\n              const TypeVector parameter_types_;\n              const Type* const return_type_;\n              const size_t function_pointer_type_id_;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<\",\n                \"about\": \"Overloads the < operator for Type to allow comparison of Type objects.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"const Type&\",\n                        \"purpose\": \"The first Type to compare.\"\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"type\": \"const Type&\",\n                        \"purpose\": \"The second Type to compare.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if a < b, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool operator<(const Type& a, const Type& b);\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"TypeLess\",\n                \"about\": \"Functor for comparing Type pointers.\",\n                \"dependencies\": [\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct TypeLess {\n              bool operator()(const Type* const a, const Type* const b) const {\n                return *a < *b;\n              }\n            };\n        ]]></code>\n    </struct>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UnionType\",\n                \"extends\": \"Type\",\n                \"about\": \"Represents a union type in the Torque type system.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"types_\",\n                        \"type\": \"std::set<const Type*, TypeLess>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of types that are part of this union.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\",\n                    \"TypeLess\",\n                    \"TypeChecker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE UnionType final : public Type {\n             public:\n              DECLARE_TYPE_BOILERPLATE(UnionType)\n              std::string GetGeneratedTypeNameImpl() const override {\n                return \"TNode<\" + GetGeneratedTNodeTypeName() + \">\";\n              }\n              std::string GetGeneratedTNodeTypeNameImpl() const override;\n              std::string GetRuntimeType() const override;\n              std::string GetDebugType() const override;\n              std::string GetConstexprGeneratedTypeName() const override;\n\n              friend size_t hash_value(const UnionType& p) {\n                size_t result = 0;\n                for (const Type* t : p.types_) {\n                  result = base::hash_combine(result, t);\n                }\n                return result;\n              }\n              bool operator==(const UnionType& other) const {\n                return types_ == other.types_;\n              }\n\n              std::optional<const Type*> GetSingleMember() const {\n                if (types_.size() == 1) {\n                  DCHECK_EQ(*types_.begin(), parent());\n                  return *types_.begin();\n                }\n                return std::nullopt;\n              }\n\n              bool IsSubtypeOf(const Type* other) const override {\n                for (const Type* member : types_) {\n                  if (!member->IsSubtypeOf(other)) return false;\n                }\n                return true;\n              }\n\n              bool IsSupertypeOf(const Type* other) const {\n                for (const Type* member : types_) {\n                  if (other->IsSubtypeOf(member)) {\n                    return true;\n                  }\n                }\n                return false;\n              }\n\n              bool IsTransient() const override {\n                for (const Type* member : types_) {\n                  if (member->IsTransient()) {\n                    return true;\n                  }\n                }\n                return false;\n              }\n\n              bool IsConstexpr() const override { return parent()->IsConstexpr"
}