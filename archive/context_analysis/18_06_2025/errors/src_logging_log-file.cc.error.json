{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/logging/log-file.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/logging/log-file.cc\",\n            \"file_name\": \"log-file.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the LogFile class for writing log messages to a file or console.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for logging functionality, string manipulation, platform abstraction, and V8 internals.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/logging/log-file.h\"\n\n#include <atomic>\n#include <memory>\n#include <optional>\n\n#include \"src/base/platform/mutex.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/base/strings.h\"\n#include \"src/base/vector.h\"\n#include \"src/common/assert-scope.h\"\n#include \"src/common/globals.h\"\n#include \"src/execution/isolate-utils.h\"\n#include \"src/logging/log.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/string-inl.h\"\n#include \"src/objects/tagged.h\"\n#include \"src/strings/string-stream.h\"\n#include \"src/utils/version.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LogFile\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents a log file and provides methods for writing messages to it.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"logger_\",\n                        \"type\": \"V8FileLogger*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the logger object.\"\n                    },\n                    {\n                        \"name\": \"file_name_\",\n                        \"type\": \"std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The name of the log file.\"\n                    },\n                    {\n                        \"name\": \"output_handle_\",\n                        \"type\": \"FILE*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"File handle for the log file.\"\n                    },\n                    {\n                        \"name\": \"os_\",\n                        \"type\": \"OFStream\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Output stream associated with the log file.\"\n                    },\n                    {\n                        \"name\": \"format_buffer_\",\n                        \"type\": \"std::unique_ptr<char[]>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Buffer for formatting log messages.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"V8FileLogger\",\n                    \"std::string\",\n                    \"base::OS\",\n                    \"Version\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nconst char* const LogFile::kLogToTemporaryFile = \"+\";\nconst char* const LogFile::kLogToConsole = \"-\";\n\nclass LogFile {\n public:\n  static FILE* CreateOutputHandle(std::string file_name);\n  static bool IsLoggingToConsole(std::string file_name);\n  static bool IsLoggingToTemporaryFile(std::string file_name);\n\n  LogFile(V8FileLogger* logger, std::string file_name);\n  void WriteLogHeader();\n  std::unique_ptr<LogFile::MessageBuilder> NewMessageBuilder();\n  FILE* Close();\n  std::string file_name() const { return file_name_; }\n\n  class MessageBuilder {\n   public:\n    MessageBuilder(LogFile* log);\n    void AppendString(Tagged<String> str, std::optional<int> length_limit = {});\n    void AppendString(base::Vector<const char> str);\n    void AppendString(const char* str);\n    void AppendString(const char* str, size_t length, bool is_one_byte);\n    void AppendFormatString(const char* format, ...);\n    void AppendTwoByteCharacter(char c1, char c2);\n    void AppendCharacter(char c);\n    void AppendSymbolName(Tagged<Symbol> symbol);\n    void AppendSymbolNameDetails(Tagged<String> str, bool show_impl_info);\n    int FormatStringIntoBuffer(const char* format, va_list args);\n    void AppendRawFormatString(const char* format, ...);\n    void AppendRawString(const char* str);\n    void AppendRawCharacter(char c);\n    void WriteToLogFile();\n\n    template <typename T>\n    MessageBuilder& operator<<(T data) {\n      AppendString(base::CStrVector(base::NumberToString(data)));\n      return *this;\n    }\n\n    template <>\n    MessageBuilder& operator<<<const char*>(const char* string);\n\n    template <>\n    MessageBuilder& operator<<<void*>(void* pointer);\n\n    template <>\n    MessageBuilder& operator<<<char>(char c);\n\n    template <>\n    MessageBuilder& operator<< <Tagged<String>>(Tagged<String> string);\n\n    template <>\n    MessageBuilder& operator<< <Tagged<Symbol>>(Tagged<Symbol> symbol);\n\n    template <>\n    MessageBuilder& operator<< <Tagged<Name>>(Tagged<Name> name);\n\n    template <>\n    MessageBuilder& operator<<<LogSeparator>(LogSeparator separator);\n\n   private:\n    LogFile* log_;\n    base::MutexGuard lock_guard_;\n  };\n\n private:\n  V8FileLogger* logger_;\n  std::string file_name_;\n  FILE* output_handle_;\n  OFStream os_;\n  std::unique_ptr<char[]> format_buffer_;\n\n  static constexpr int kMessageBufferSize = 2048;\n};\n\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CreateOutputHandle\",\n                \"parent\": \"LogFile\",\n                \"about\": \"Creates and returns a file handle for the log file based on the given file name.\",\n                \"logic\": \"Checks the file name to determine whether to log to console, a temporary file, or a specified file. Returns the appropriate file handle.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"file_name\",\n                        \"type\": \"std::string\",\n                        \"purpose\": \"The name of the log file.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"FILE*\",\n                    \"description\": \"The file handle for the log file, or nullptr if logging is disabled.\"\n                },\n                \"dependencies\": [\n                    \"v8_flags\",\n                    \"IsLoggingToConsole\",\n                    \"IsLoggingToTemporaryFile\",\n                    \"base::OS\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nFILE* LogFile::CreateOutputHandle(std::string file_name) {\n  // If we're logging anything, we need to open the log file.\n  if (!v8_flags.log) {\n    return nullptr;\n  } else if (LogFile::IsLoggingToConsole(file_name)) {\n    return stdout;\n  } else if (LogFile::IsLoggingToTemporaryFile(file_name)) {\n    return base::OS::OpenTemporaryFile();\n  } else {\n    return base::OS::FOpen(file_name.c_str(), base::OS::LogFileOpenMode);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsLoggingToConsole\",\n                \"parent\": \"LogFile\",\n                \"about\": \"Checks if the log file name indicates logging to the console.\",\n                \"logic\": \"Compares the file name to the constant kLogToConsole.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"file_name\",\n                        \"type\": \"std::string\",\n                        \"purpose\": \"The name of the log file.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if logging to the console, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"kLogToConsole\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nbool LogFile::IsLoggingToConsole(std::string file_name) {\n  return file_name.compare(LogFile::kLogToConsole) == 0;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsLoggingToTemporaryFile\",\n                \"parent\": \"LogFile\",\n                \"about\": \"Checks if the log file name indicates logging to a temporary file.\",\n                \"logic\": \"Compares the file name to the constant kLogToTemporaryFile.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"file_name\",\n                        \"type\": \"std::string\",\n                        \"purpose\": \"The name of the log file.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if logging to a temporary file, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"kLogToTemporaryFile\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nbool LogFile::IsLoggingToTemporaryFile(std::string file_name) {\n  return file_name.compare(LogFile::kLogToTemporaryFile) == 0;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LogFile\",\n                \"parent\": \"LogFile\",\n                \"about\": \"Constructor for the LogFile class.\",\n                \"logic\": \"Initializes the LogFile object, creates the output handle, and writes the log header if a file is opened successfully.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"logger\",\n                        \"type\": \"V8FileLogger*\",\n                        \"purpose\": \"Pointer to the logger object.\"\n                    },\n                    {\n                        \"name\": \"file_name\",\n                        \"type\": \"std::string\",\n                        \"purpose\": \"The name of the log file.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"CreateOutputHandle\",\n                    \"WriteLogHeader\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nLogFile::LogFile(V8FileLogger* logger, std::string file_name)\n    : logger_(logger),\n      file_name_(file_name),\n      output_handle_(LogFile::CreateOutputHandle(file_name)),\n      os_(output_handle_ == nullptr ? stdout : output_handle_),\n      format_buffer_(NewArray<char>(kMessageBufferSize)) {\n  if (output_handle_) WriteLogHeader();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"WriteLogHeader\",\n                \"parent\": \"LogFile\",\n                \"about\": \"Writes the log header to the log file.\",\n                \"logic\": \"Constructs a log header string containing version information and platform details, and writes it to the log file.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"MessageBuilder\",\n                    \"Version\",\n                    \"V8_OS_STRING\",\n                    \"V8_TARGET_OS_STRING\",\n                    \"LogSeparator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::WriteLogHeader() {\n  LogFile::MessageBuilder msg(this);\n  LogSeparator kNext = LogSeparator::kSeparator;\n  msg << \"v8-version\" << kNext << Version::GetMajor() << kNext\n      << Version::GetMinor() << kNext << Version::GetBuild() << kNext\n      << Version::GetPatch();\n  if (strlen(Version::GetEmbedder()) != 0) {\n    msg << kNext << Version::GetEmbedder();\n  }\n  msg << kNext << Version::IsCandidate();\n  msg.WriteToLogFile();\n  msg << \"v8-platform\" << kNext << V8_OS_STRING << kNext << V8_TARGET_OS_STRING;\n  msg.WriteToLogFile();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"NewMessageBuilder\",\n                \"parent\": \"LogFile\",\n                \"about\": \"Creates a new MessageBuilder object.\",\n                \"logic\": \"Allocates a new MessageBuilder on the heap and checks if logging is enabled.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"std::unique_ptr<LogFile::MessageBuilder>\",\n                    \"description\": \"Returns a unique pointer to a MessageBuilder object.\"\n                },\n                \"dependencies\": [\n                    \"logger_->is_logging\",\n                    \"MessageBuilder\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<LogFile::MessageBuilder> LogFile::NewMessageBuilder() {\n  // Fast check of is_logging() without taking the lock. Bail out immediately if\n  // logging isn't enabled.\n  if (!logger_->is_logging()) return {};\n\n  std::unique_ptr<LogFile::MessageBuilder> result(\n      new LogFile::MessageBuilder(this));\n\n  // The first invocation of is_logging() might still read an old value. It is\n  // fine if a background thread starts logging a bit later, but we want to\n  // avoid background threads continue logging after logging was already closed.\n  if (!logger_->is_logging()) return {};\n  DCHECK_NOT_NULL(format_buffer_.get());\n\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Close\",\n                \"parent\": \"LogFile\",\n                \"about\": \"Closes the log file.\",\n                \"logic\": \"Flushes the output stream and closes the file handle, if it is open.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"FILE*\",\n                    \"description\": \"Returns the file handle if it was open, otherwise returns nullptr.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nFILE* LogFile::Close() {\n  FILE* result = nullptr;\n  if (output_handle_ != nullptr) {\n    fflush(output_handle_);\n    result = output_handle_;\n  }\n  output_handle_ = nullptr;\n  format_buffer_.reset();\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"file_name\",\n                \"parent\": \"LogFile\",\n                \"about\": \"Returns the file name of the log file.\",\n                \"logic\": \"Returns the file name stored in the file_name_ member.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"The name of the log file.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::string LogFile::file_name() const { return file_name_; }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MessageBuilder\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Helper class for building log messages.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"log_\",\n                        \"type\": \"LogFile*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the LogFile object.\"\n                    },\n                    {\n                        \"name\": \"lock_guard_\",\n                        \"type\": \"base::MutexGuard\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mutex guard for thread-safe access to the log file.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"LogFile\",\n                    \"base::MutexGuard\",\n                    \"Tagged<String>\",\n                    \"base::Vector\",\n                    \"Tagged<Symbol>\",\n                    \"Tagged<Name>\",\n                    \"LogSeparator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  class MessageBuilder {\n   public:\n    MessageBuilder(LogFile* log);\n    void AppendString(Tagged<String> str, std::optional<int> length_limit = {});\n    void AppendString(base::Vector<const char> str);\n    void AppendString(const char* str);\n    void AppendString(const char* str, size_t length, bool is_one_byte);\n    void AppendFormatString(const char* format, ...);\n    void AppendTwoByteCharacter(char c1, char c2);\n    void AppendCharacter(char c);\n    void AppendSymbolName(Tagged<Symbol> symbol);\n    void AppendSymbolNameDetails(Tagged<String> str, bool show_impl_info);\n    int FormatStringIntoBuffer(const char* format, va_list args);\n    void AppendRawFormatString(const char* format, ...);\n    void AppendRawString(const char* str);\n    void AppendRawCharacter(char c);\n    void WriteToLogFile();\n\n    template <typename T>\n    MessageBuilder& operator<<(T data) {\n      AppendString(base::CStrVector(base::NumberToString(data)));\n      return *this;\n    }\n\n    template <>\n    MessageBuilder& operator<<<const char*>(const char* string);\n\n    template <>\n    MessageBuilder& operator<<<void*>(void* pointer);\n\n    template <>\n    MessageBuilder& operator<<<char>(char c);\n\n    template <>\n    MessageBuilder& operator<< <Tagged<String>>(Tagged<String> string);\n\n    template <>\n    MessageBuilder& operator<< <Tagged<Symbol>>(Tagged<Symbol> symbol);\n\n    template <>\n    MessageBuilder& operator<< <Tagged<Name>>(Tagged<Name> name);\n\n    template <>\n    MessageBuilder& operator<<<LogSeparator>(LogSeparator separator);\n\n   private:\n    LogFile* log_;\n    base::MutexGuard lock_guard_;\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"MessageBuilder\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Constructor for the MessageBuilder class.\",\n                \"logic\": \"Initializes the MessageBuilder object with a pointer to the LogFile and acquires a mutex lock.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"log\",\n                        \"type\": \"LogFile*\",\n                        \"purpose\": \"Pointer to the LogFile object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nLogFile::MessageBuilder::MessageBuilder(LogFile* log)\n    : log_(log), lock_guard_(&log_->mutex_) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AppendString\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Appends a Tagged<String> to the message.\",\n                \"logic\": \"Iterates over the string and appends each character to the message, escaping non-ascii characters.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"str\",\n                        \"type\": \"Tagged<String>\",\n                        \"purpose\": \"The string to append.\"\n                    },\n                    {\n                        \"name\": \"length_limit\",\n                        \"type\": \"std::optional<int>\",\n                        \"purpose\": \"Optional length limit for the string.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"DisallowGarbageCollection\",\n                    \"SharedStringAccessGuardIfNeeded\",\n                    \"AppendCharacter\",\n                    \"AppendRawFormatString\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::MessageBuilder::AppendString(Tagged<String> str,\n                                           std::optional<int> length_limit) {\n  if (str.is_null()) return;\n\n  DisallowGarbageCollection no_gc;  // Ensure string stays valid.\n  SharedStringAccessGuardIfNeeded access_guard(str);\n  int length = str->length();\n  if (length_limit) length = std::min(length, *length_limit);\n  for (int i = 0; i < length; i++) {\n    uint16_t c = str->Get(i, access_guard);\n    if (c <= 0xFF) {\n      AppendCharacter(static_cast<char>(c));\n    } else {\n      // Escape non-ascii characters.\n      AppendRawFormatString(\"\\\\u%04x\", c & 0xFFFF);\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AppendString\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Appends a base::Vector<const char> to the message.\",\n                \"logic\": \"Iterates over the vector and appends each character to the message.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"str\",\n                        \"type\": \"base::Vector<const char>\",\n                        \"purpose\": \"The string to append.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AppendCharacter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::MessageBuilder::AppendString(base::Vector<const char> str) {\n  for (auto i = str.begin(); i < str.end(); i++) AppendCharacter(*i);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AppendString\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Appends a const char* to the message.\",\n                \"logic\": \"Appends a C-style string to the message.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"str\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The string to append.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AppendString\",\n                    \"strlen\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::MessageBuilder::AppendString(const char* str) {\n  if (str == nullptr) return;\n  AppendString(str, strlen(str));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AppendString\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Appends a const char* with a given length to the message.\",\n                \"logic\": \"Appends a character array to the message. Handles one-byte and two-byte characters.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"str\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The string to append.\"\n                    },\n                    {\n                        \"name\": \"length\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The length of the string.\"\n                    },\n                    {\n                        \"name\": \"is_one_byte\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Whether the string is encoded using one byte per character.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AppendCharacter\",\n                    \"AppendTwoByteCharacter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::MessageBuilder::AppendString(const char* str, size_t length,\n                                           bool is_one_byte) {\n  if (str == nullptr) return;\n  if (is_one_byte) {\n    for (size_t i = 0; i < length; i++) {\n      DCHECK_IMPLIES(is_one_byte, str[i] != '\\0');\n      AppendCharacter(str[i]);\n    }\n  } else {\n    DCHECK_EQ(length % 2, 0);\n    for (size_t i = 0; i + 1 < length; i += 2) {\n      AppendTwoByteCharacter(str[i], str[i + 1]);\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AppendFormatString\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Appends a formatted string to the message.\",\n                \"logic\": \"Formats the string using a variable argument list and appends the result to the message.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"format\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"The format string.\"\n                    },\n                    {\n                        \"name\": \"...\",\n                        \"type\": \"...\",\n                        \"purpose\": \"Variable arguments for the format string.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"FormatStringIntoBuffer\",\n                    \"AppendCharacter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::MessageBuilder::AppendFormatString(const char* format, ...) {\n  va_list args;\n  va_start(args, format);\n  const int length = FormatStringIntoBuffer(format, args);\n  va_end(args);\n  for (int i = 0; i < length; i++) {\n    DCHECK_NE(log_->format_buffer_[i], '\\0');\n    AppendCharacter(log_->format_buffer_[i]);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AppendTwoByteCharacter\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Appends a two-byte character to the message.\",\n                \"logic\": \"Handles two-byte characters by either appending the first byte if the second is zero, or escaping the character if it's non-printable.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"c1\",\n                        \"type\": \"char\",\n                        \"purpose\": \"The first byte of the character.\"\n                    },\n                    {\n                        \"name\": \"c2\",\n                        \"type\": \"char\",\n                        \"purpose\": \"The second byte of the character.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AppendCharacter\",\n                    \"AppendRawFormatString\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::MessageBuilder::AppendTwoByteCharacter(char c1, char c2) {\n  if (c2 == 0) {\n    AppendCharacter(c1);\n  } else {\n    // Escape non-printable characters.\n    AppendRawFormatString(\"\\\\u%02x%02x\", c1 & 0xFF, c2 & 0xFF);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AppendCharacter\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Appends a single character to the message, escaping special characters.\",\n                \"logic\": \"Escapes commas, backslashes, and newlines. Escapes non-printable characters.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"c\",\n                        \"type\": \"char\",\n                        \"purpose\": \"The character to append.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"std::isprint\",\n                    \"AppendRawString\",\n                    \"AppendRawCharacter\",\n                    \"AppendRawFormatString\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::MessageBuilder::AppendCharacter(char c) {\n  if (std::isprint(c)) {\n    if (c == ',') {\n      // Escape commas to avoid adding column separators.\n      AppendRawString(\"\\\\x2C\");\n    } else if (c == '\\\\') {\n      AppendRawString(\"\\\\\\\\\");\n    } else {\n      // Safe, printable ascii character.\n      AppendRawCharacter(c);\n    }\n  } else if (c == '\\n') {\n    // Escape newlines to avoid adding row separators.\n    AppendRawString(\"\\\\n\");\n  } else {\n    // Escape non-printable characters.\n    AppendRawFormatString(\"\\\\x%02x\", c & 0xFF);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AppendSymbolName\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Appends a symbol name to the message.\",\n                \"logic\": \"Formats the symbol name by printing 'symbol(' and then the symbol description if present, and finally the hash.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"symbol\",\n                        \"type\": \"Tagged<Symbol>\",\n                        \"purpose\": \"The symbol whose name is to be appended.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IsUndefined\",\n                    \"Cast<String>\",\n                    \"AppendSymbolNameDetails\",\n                    \"symbol->description\",\n                    \"symbol->hash\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::MessageBuilder::AppendSymbolName(Tagged<Symbol> symbol) {\n  DCHECK(!symbol.is_null());\n  OFStream& os = log_->os_;\n  os << \"symbol(\";\n  if (!IsUndefined(symbol->description())) {\n    os << \"\\\"\";\n    AppendSymbolNameDetails(Cast<String>(symbol->description()), false);\n    os << \"\\\" \";\n  }\n  os << \"hash \" << std::hex << symbol->hash() << std::dec << \")\";\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AppendSymbolNameDetails\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Appends details of a symbol name to the message.\",\n                \"logic\": \"Appends symbol details including string representation and implementation information if requested.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"str\",\n                        \"type\": \"Tagged<String>\",\n                        \"purpose\": \"The string representing the symbol's name.\"\n                    },\n                    {\n                        \"name\": \"show_impl_info\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Flag indicating whether to show implementation details.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"DisallowGarbageCollection\",\n                    \"StringShape\",\n                    \"AppendString\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LogFile::MessageBuilder::AppendSymbolNameDetails(Tagged<String> str,\n                                                      bool show_impl_info) {\n  if (str.is_null()) return;\n\n  DisallowGarbageCollection no_gc;  // Ensure string stays valid.\n  OFStream& os = log_->os_;\n  int limit = str->length();\n  if (limit > 0x1000) limit = 0x1000;\n  if (show_impl_info) {\n    os << (str->IsOneByteRepresentation() ? 'a' : '2');\n    if (StringShape(str).IsExternal()) os << 'e';\n    if (StringShape(str).IsInternalized()) os << '#';\n    os << ':' << str->length() << ':';\n  }\n  AppendString(str, limit);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FormatStringIntoBuffer\",\n                \"parent\": \"LogFile::MessageBuilder\",\n                \"about\": \"Formats a string into the format buffer using a variable argument list.\",\n                \"logic\": \"Formats a string using base::VSNPrintF and checks for truncation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"format\",\n                        \"type\": \"const char*\","
}