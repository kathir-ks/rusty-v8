{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/spill-placer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/spill-placer.cc\",\n            \"file_name\": \"spill-placer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the SpillPlacer class, which determines where spill moves should be inserted in the code to minimize performance impact.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for spill placement, bit manipulation, and register allocation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/backend/spill-placer.h\"\n\n#include \"src/base/bits-iterator.h\"\n#include \"src/compiler/backend/register-allocator.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SpillPlacer\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"The SpillPlacer class determines where spill moves should be inserted in the code to minimize performance impact. It uses a data-flow analysis to find optimal spill locations.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"data_\",\n                        \"type\": \"RegisterAllocationData*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the register allocation data, providing access to live ranges, instructions, and other relevant information.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the memory zone used for allocations.\"\n                    },\n                    {\n                        \"name\": \"entries_\",\n                        \"type\": \"Entry*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of Entry objects, one per instruction block, storing information about spill requirements.\"\n                    },\n                    {\n                        \"name\": \"vreg_numbers_\",\n                        \"type\": \"int*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array mapping indices to vreg numbers for efficient tracking of spill requirements.\"\n                    },\n                    {\n                        \"name\": \"assigned_indices_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Counter for the number of vregs currently tracked in the vreg_numbers_ array.\"\n                    },\n                    {\n                        \"name\": \"first_block_\",\n                        \"type\": \"RpoNumber\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The first block to iterate over.\"\n                    },\n                    {\n                        \"name\": \"last_block_\",\n                        \"type\": \"RpoNumber\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The last block to iterate over.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"RegisterAllocationData\",\n                    \"Zone\",\n                    \"TopLevelLiveRange\",\n                    \"InstructionOperand\",\n                    \"InstructionSequence\",\n                    \"InstructionBlock\",\n                    \"RpoNumber\",\n                    \"LiveRange\",\n                    \"UseInterval\",\n                    \"LifetimePosition\",\n                    \"UsePosition\",\n                    \"UsePositionType\",\n                    \"Instruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass SpillPlacer::Entry {\n public:\n  // Functions operating on single values (during setup):\n\n  void SetSpillRequiredSingleValue(int value_index) {\n    DCHECK_LT(value_index, kValueIndicesPerEntry);\n    uint64_t bit = uint64_t{1} << value_index;\n    SetSpillRequired(bit);\n  }\n  void SetDefinitionSingleValue(int value_index) {\n    DCHECK_LT(value_index, kValueIndicesPerEntry);\n    uint64_t bit = uint64_t{1} << value_index;\n    SetDefinition(bit);\n  }\n\n  // Functions operating on all values simultaneously, as bitfields:\n\n  uint64_t SpillRequired() const { return GetValuesInState<kSpillRequired>(); }\n  void SetSpillRequired(uint64_t mask) {\n    UpdateValuesToState<kSpillRequired>(mask);\n  }\n  uint64_t SpillRequiredInNonDeferredSuccessor() const {\n    return GetValuesInState<kSpillRequiredInNonDeferredSuccessor>();\n  }\n  void SetSpillRequiredInNonDeferredSuccessor(uint64_t mask) {\n    UpdateValuesToState<kSpillRequiredInNonDeferredSuccessor>(mask);\n  }\n  uint64_t SpillRequiredInDeferredSuccessor() const {\n    return GetValuesInState<kSpillRequiredInDeferredSuccessor>();\n  }\n  void SetSpillRequiredInDeferredSuccessor(uint64_t mask) {\n    UpdateValuesToState<kSpillRequiredInDeferredSuccessor>(mask);\n  }\n  uint64_t Definition() const { return GetValuesInState<kDefinition>(); }\n  void SetDefinition(uint64_t mask) { UpdateValuesToState<kDefinition>(mask); }\n\n private:\n  // Possible states for every value, at every block.\n  enum State {\n    // This block is not (yet) known to require the on-stack value.\n    kUnmarked,\n\n    // The value must be on the stack in this block.\n    kSpillRequired,\n\n    // The value doesn't need to be on-stack in this block, but some\n    // non-deferred successor needs it.\n    kSpillRequiredInNonDeferredSuccessor,\n\n    // The value doesn't need to be on-stack in this block, but some\n    // deferred successor needs it.\n    kSpillRequiredInDeferredSuccessor,\n\n    // The value is defined in this block.\n    kDefinition,\n  };\n\n  template <State state>\n  uint64_t GetValuesInState() const {\n    static_assert(state < 8);\n    return ((state & 1) ? first_bit_ : ~first_bit_) &\n           ((state & 2) ? second_bit_ : ~second_bit_) &\n           ((state & 4) ? third_bit_ : ~third_bit_);\n  }\n\n  template <State state>\n  void UpdateValuesToState(uint64_t mask) {\n    static_assert(state < 8);\n    first_bit_ =\n        Entry::UpdateBitDataWithMask<(state & 1) != 0>(first_bit_, mask);\n    second_bit_ =\n        Entry::UpdateBitDataWithMask<(state & 2) != 0>(second_bit_, mask);\n    third_bit_ =\n        Entry::UpdateBitDataWithMask<(state & 4) != 0>(third_bit_, mask);\n  }\n\n  template <bool set_ones>\n  static uint64_t UpdateBitDataWithMask(uint64_t data, uint64_t mask) {\n    return set_ones ? data | mask : data & ~mask;\n  }\n\n  // Storage for the states of up to 64 live ranges.\n  uint64_t first_bit_ = 0;\n  uint64_t second_bit_ = 0;\n  uint64_t third_bit_ = 0;\n};\n\nSpillPlacer::SpillPlacer(RegisterAllocationData* data, Zone* zone)\n    : data_(data), zone_(zone) {}\n\nSpillPlacer::~SpillPlacer() {\n  if (assigned_indices_ > 0) {\n    CommitSpills();\n  }\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Add\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Adds a live range to the spill placer, determining where to insert spill moves.\",\n                \"logic\": \"This function analyzes a live range and decides whether to spill at the definition or at a later point (late spilling). It considers factors like whether the value is already moved on-stack, if it's the first spilled live range, if it's defined in a deferred block, and if it's a loop-top phi.  It iterates through the live range's intervals and positions, marking blocks where the value needs to be spilled.  A three-pass data-flow algorithm is used to refine the spill locations. It optimizes the placement of spill moves based on control flow and deferred blocks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"range\",\n                        \"type\": \"TopLevelLiveRange*\",\n                        \"purpose\": \"The live range to be processed for spill placement.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"TopLevelLiveRange\",\n                    \"InstructionOperand\",\n                    \"InstructionSequence\",\n                    \"InstructionBlock\",\n                    \"RpoNumber\",\n                    \"LiveRange\",\n                    \"UseInterval\",\n                    \"LifetimePosition\",\n                    \"UsePosition\",\n                    \"UsePositionType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SpillPlacer::Add(TopLevelLiveRange* range) {\n  DCHECK(range->HasGeneralSpillRange());\n  InstructionOperand spill_operand = range->GetSpillRangeOperand();\n  range->FilterSpillMoves(data(), spill_operand);\n\n  InstructionSequence* code = data_->code();\n  InstructionBlock* top_start_block =\n      code->GetInstructionBlock(range->Start().ToInstructionIndex());\n  RpoNumber top_start_block_number = top_start_block->rpo_number();\n\n  // Check for several cases where spilling at the definition is best.\n  // - The value is already moved on-stack somehow so the list of insertion\n  //   locations for spilling at the definition is empty.\n  // - If the first LiveRange is spilled, then there's no sense in doing\n  //   anything other than spilling at the definition.\n  // - If the value is defined in a deferred block, then the logic to select\n  //   the earliest deferred block as the insertion point would cause\n  //   incorrect behavior, so the value must be spilled at the definition.\n  // - We haven't seen any indication of performance improvements from seeking\n  //   optimal spilling positions except on loop-top phi values, so spill\n  //   any value that isn't a loop-top phi at the definition to avoid\n  //   increasing the code size for no benefit.\n  if (range->GetSpillMoveInsertionLocations(data()) == nullptr ||\n      range->spilled() || top_start_block->IsDeferred() ||\n      (!v8_flags.stress_turbo_late_spilling && !range->is_loop_phi())) {\n    range->CommitSpillMoves(data(), spill_operand);\n    return;\n  }\n\n  // Iterate through the range and mark every block that needs the value to be\n  // spilled.\n  for (const LiveRange* child = range; child != nullptr;\n       child = child->next()) {\n    if (child->spilled()) {\n      // Add every block that contains part of this live range.\n      for (const UseInterval& interval : child->intervals()) {\n        RpoNumber start_block =\n            code->GetInstructionBlock(interval.start().ToInstructionIndex())\n                ->rpo_number();\n        if (start_block == top_start_block_number) {\n          // Can't do late spilling if the first spill is within the\n          // definition block.\n          range->CommitSpillMoves(data(), spill_operand);\n          // Verify that we never added any data for this range to the table.\n          DCHECK(!IsLatestVreg(range->vreg()));\n          return;\n        }\n        LifetimePosition end = interval.end();\n        int end_instruction = end.ToInstructionIndex();\n        // The end position is exclusive, so an end position exactly on a block\n        // boundary indicates that the range applies only to the prior block.\n        if (data()->IsBlockBoundary(end)) {\n          --end_instruction;\n        }\n        RpoNumber end_block =\n            code->GetInstructionBlock(end_instruction)->rpo_number();\n        while (start_block <= end_block) {\n          SetSpillRequired(code->InstructionBlockAt(start_block), range->vreg(),\n                           top_start_block_number);\n          start_block = start_block.Next();\n        }\n      }\n    } else {\n      // Add every block that contains a use which requires the on-stack value.\n      for (const UsePosition* pos : child->positions()) {\n        if (pos->type() != UsePositionType::kRequiresSlot) continue;\n        InstructionBlock* block =\n            code->GetInstructionBlock(pos->pos().ToInstructionIndex());\n        RpoNumber block_number = block->rpo_number();\n        if (block_number == top_start_block_number) {\n          // Can't do late spilling if the first spill is within the\n          // definition block.\n          range->CommitSpillMoves(data(), spill_operand);\n          // Verify that we never added any data for this range to the table.\n          DCHECK(!IsLatestVreg(range->vreg()));\n          return;\n        }\n        SetSpillRequired(block, range->vreg(), top_start_block_number);\n      }\n    }\n  }\n\n  // If we haven't yet marked anything for this range, then it never needs to\n  // spill at all.\n  if (!IsLatestVreg(range->vreg())) {\n    range->SetLateSpillingSelected(true);\n    return;\n  }\n\n  SetDefinition(top_start_block_number, range->vreg());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetOrCreateIndexForLatestVreg\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Gets or creates an index for the given virtual register (vreg).\",\n                \"logic\": \"This function maintains a mapping between vregs and indices into the entries_ array. It checks if the vreg is already the last one in the list. If not, it adds it to the list, allocating memory if necessary. If the table is full, it commits the current set of spills and clears the data. This function ensures that each vreg has a unique index for tracking spill requirements.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"vreg\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The virtual register number.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The index for the vreg.\"\n                },\n                \"dependencies\": [\n                    \"Entry\",\n                    \"RpoNumber\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nint SpillPlacer::GetOrCreateIndexForLatestVreg(int vreg) {\n  DCHECK_LE(assigned_indices_, kValueIndicesPerEntry);\n  // If this vreg isn't yet the last one in the list, then add it.\n  if (!IsLatestVreg(vreg)) {\n    if (vreg_numbers_ == nullptr) {\n      DCHECK_EQ(assigned_indices_, 0);\n      DCHECK_EQ(entries_, nullptr);\n      // We lazily allocate these arrays because many functions don't have any\n      // values that use SpillPlacer.\n      entries_ = zone_->AllocateArray<Entry>(\n          data()->code()->instruction_blocks().size());\n      for (size_t i = 0; i < data()->code()->instruction_blocks().size(); ++i) {\n        new (&entries_[i]) Entry();\n      }\n      vreg_numbers_ = zone_->AllocateArray<int>(kValueIndicesPerEntry);\n    }\n\n    if (assigned_indices_ == kValueIndicesPerEntry) {\n      // The table is full; commit the current set of values and clear it.\n      CommitSpills();\n      ClearData();\n    }\n\n    vreg_numbers_[assigned_indices_] = vreg;\n    ++assigned_indices_;\n  }\n  return assigned_indices_ - 1;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CommitSpills\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Commits the current set of spills by performing the three-pass data-flow analysis.\",\n                \"logic\": \"This function executes the FirstBackwardPass, ForwardPass, and SecondBackwardPass to determine the optimal spill locations based on the current state of the tracked vregs.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"FirstBackwardPass\",\n                    \"ForwardPass\",\n                    \"SecondBackwardPass\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SpillPlacer::CommitSpills() {\n  FirstBackwardPass();\n  ForwardPass();\n  SecondBackwardPass();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ClearData\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Clears the data structures used for tracking spill requirements.\",\n                \"logic\": \"Resets assigned_indices_ to 0, reinitializes the entries_ array, and resets first_block_ and last_block_ to invalid.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Entry\",\n                    \"RpoNumber\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SpillPlacer::ClearData() {\n  assigned_indices_ = 0;\n  for (int i = 0; i < data()->code()->InstructionBlockCount(); ++i) {\n    new (&entries_[i]) Entry();\n  }\n  first_block_ = RpoNumber::Invalid();\n  last_block_ = RpoNumber::Invalid();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ExpandBoundsToInclude\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Expands the range of blocks being analyzed to include the given block.\",\n                \"logic\": \"This function updates the first_block_ and last_block_ RpoNumbers to include the given block. This ensures that the data-flow analysis covers all relevant blocks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"RpoNumber\",\n                        \"purpose\": \"The block to include in the analysis range.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RpoNumber\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SpillPlacer::ExpandBoundsToInclude(RpoNumber block) {\n  if (!first_block_.IsValid()) {\n    DCHECK(!last_block_.IsValid());\n    first_block_ = block;\n    last_block_ = block;\n  } else {\n    if (first_block_ > block) {\n      first_block_ = block;\n    }\n    if (last_block_ < block) {\n      last_block_ = block;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetSpillRequired\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Marks a block as requiring a spill for the given virtual register.\",\n                \"logic\": \"This function sets the 'spill required' flag for a given block and vreg. It checks if the block is non-deferred and nested within a loop, and if the definition is before that loop, it marks the loop top instead to reduce spilling in loops.  It updates the entries_ array and expands the analysis bounds.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"InstructionBlock*\",\n                        \"purpose\": \"The block to mark.\"\n                    },\n                    {\n                        \"name\": \"vreg\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The virtual register number.\"\n                    },\n                    {\n                        \"name\": \"top_start_block\",\n                        \"type\": \"RpoNumber\",\n                        \"purpose\": \"The RPO number of the block where the live range starts.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"InstructionBlock\",\n                    \"RpoNumber\",\n                    \"GetOrCreateIndexForLatestVreg\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SpillPlacer::SetSpillRequired(InstructionBlock* block, int vreg,\n                                   RpoNumber top_start_block) {\n  // Spilling in loops is bad, so if the block is non-deferred and nested\n  // within a loop, and the definition is before that loop, then mark the loop\n  // top instead. Of course we must find the outermost such loop.\n  if (!block->IsDeferred()) {\n    while (block->loop_header().IsValid() &&\n           block->loop_header() > top_start_block) {\n      block = data()->code()->InstructionBlockAt(block->loop_header());\n    }\n  }\n\n  int value_index = GetOrCreateIndexForLatestVreg(vreg);\n  entries_[block->rpo_number().ToSize()].SetSpillRequiredSingleValue(\n      value_index);\n  ExpandBoundsToInclude(block->rpo_number());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetDefinition\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Marks a block as defining a virtual register.\",\n                \"logic\": \"This function sets the 'definition' flag for a given block and vreg. It updates the entries_ array and expands the analysis bounds.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"RpoNumber\",\n                        \"purpose\": \"The block to mark.\"\n                    },\n                    {\n                        \"name\": \"vreg\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The virtual register number.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"RpoNumber\",\n                    \"GetOrCreateIndexForLatestVreg\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SpillPlacer::SetDefinition(RpoNumber block, int vreg) {\n  int value_index = GetOrCreateIndexForLatestVreg(vreg);\n  entries_[block.ToSize()].SetDefinitionSingleValue(value_index);\n  ExpandBoundsToInclude(block);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FirstBackwardPass\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Performs the first backward data-flow pass to propagate spill requirements from successors to predecessors.\",\n                \"logic\": \"This function iterates through the instruction blocks in reverse RPO order. It calculates spill requirements based on the spill requirements of the successors, distinguishing between deferred and non-deferred successors. It updates the SpillRequiredInDeferredSuccessor and SpillRequiredInNonDeferredSuccessor fields in the entries_ array.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"InstructionSequence\",\n                    \"InstructionBlock\",\n                    \"RpoNumber\",\n                    \"Entry\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SpillPlacer::FirstBackwardPass() {\n  InstructionSequence* code = data()->code();\n\n  for (int i = last_block_.ToInt(); i >= first_block_.ToInt(); --i) {\n    RpoNumber block_id = RpoNumber::FromInt(i);\n    InstructionBlock* block = code->instruction_blocks()[i];\n\n    Entry& entry = entries_[i];\n\n    // State that will be accumulated from successors.\n    uint64_t spill_required_in_non_deferred_successor = 0;\n    uint64_t spill_required_in_deferred_successor = 0;\n\n    for (RpoNumber successor_id : block->successors()) {\n      // Ignore loop back-edges.\n      if (successor_id <= block_id) continue;\n\n      InstructionBlock* successor = code->InstructionBlockAt(successor_id);\n      const Entry& successor_entry = entries_[successor_id.ToSize()];\n      if (successor->IsDeferred()) {\n        spill_required_in_deferred_successor |= successor_entry.SpillRequired();\n      } else {\n        spill_required_in_non_deferred_successor |=\n            successor_entry.SpillRequired();\n      }\n      spill_required_in_deferred_successor |=\n          successor_entry.SpillRequiredInDeferredSuccessor();\n      spill_required_in_non_deferred_successor |=\n          successor_entry.SpillRequiredInNonDeferredSuccessor();\n    }\n\n    // Starting state of the current block.\n    uint64_t defs = entry.Definition();\n    uint64_t needs_spill = entry.SpillRequired();\n\n    // Info about successors doesn't get to override existing info about\n    // definitions and spills required by this block itself.\n    spill_required_in_deferred_successor &= ~(defs | needs_spill);\n    spill_required_in_non_deferred_successor &= ~(defs | needs_spill);\n\n    entry.SetSpillRequiredInDeferredSuccessor(\n        spill_required_in_deferred_successor);\n    entry.SetSpillRequiredInNonDeferredSuccessor(\n        spill_required_in_non_deferred_successor);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ForwardPass\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Performs the forward data-flow pass to propagate spill requirements from predecessors to successors.\",\n                \"logic\": \"This function iterates through the instruction blocks in RPO order. It calculates spill requirements based on the spill requirements of the predecessors, considering only non-deferred predecessors. It updates the SpillRequired field in the entries_ array based on the predecessor and successor information. It avoids pushing data too far down the graph to prevent confusion in the next backward pass.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"InstructionSequence\",\n                    \"InstructionBlock\",\n                    \"RpoNumber\",\n                    \"Entry\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SpillPlacer::ForwardPass() {\n  InstructionSequence* code = data()->code();\n  for (int i = first_block_.ToInt(); i <= last_block_.ToInt(); ++i) {\n    RpoNumber block_id = RpoNumber::FromInt(i);\n    InstructionBlock* block = code->instruction_blocks()[i];\n\n    // Deferred blocks don't need to participate in the forward pass, because\n    // their spills all get pulled forward to the earliest possible deferred\n    // block (where a non-deferred block jumps to a deferred block), and\n    // decisions about spill requirements for non-deferred blocks don't take\n    // deferred blocks into account.\n    if (block->IsDeferred()) continue;\n\n    Entry& entry = entries_[i];\n\n    // State that will be accumulated from predecessors.\n    uint64_t spill_required_in_non_deferred_predecessor = 0;\n    uint64_t spill_required_in_all_non_deferred_predecessors =\n        static_cast<uint64_t>(int64_t{-1});\n\n    for (RpoNumber predecessor_id : block->predecessors()) {\n      // Ignore loop back-edges.\n      if (predecessor_id >= block_id) continue;\n\n      InstructionBlock* predecessor = code->InstructionBlockAt(predecessor_id);\n      if (predecessor->IsDeferred()) continue;\n      const Entry& predecessor_entry = entries_[predecessor_id.ToSize()];\n      spill_required_in_non_deferred_predecessor |=\n          predecessor_entry.SpillRequired();\n      spill_required_in_all_non_deferred_predecessors &=\n          predecessor_entry.SpillRequired();\n    }\n\n    // Starting state of the current block.\n    uint64_t spill_required_in_non_deferred_successor =\n        entry.SpillRequiredInNonDeferredSuccessor();\n    uint64_t spill_required_in_any_successor =\n        spill_required_in_non_deferred_successor |\n        entry.SpillRequiredInDeferredSuccessor();\n\n    // If all of the predecessors agree that a spill is required, then a\n    // spill is required. Note that we don't set anything for values that\n    // currently have no markings in this block, to avoid pushing data too\n    // far down the graph and confusing the next backward pass.\n    entry.SetSpillRequired(spill_required_in_any_successor &\n                           spill_required_in_non_deferred_predecessor &\n                           spill_required_in_all_non_deferred_predecessors);\n\n    // If only some of the predecessors require a spill, but some successor\n    // of this block also requires a spill, then this merge point requires a\n    // spill. This ensures that no control-flow path through non-deferred\n    // blocks ever has to spill twice.\n    entry.SetSpillRequired(spill_required_in_non_deferred_successor &\n                           spill_required_in_non_deferred_predecessor);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SecondBackwardPass\",\n                \"parent\": \"SpillPlacer\",\n                \"about\": \"Performs the second backward data-flow pass to refine spill locations and insert spill moves.\",\n                \"logic\": \"This function iterates through the instruction blocks in reverse RPO order. It calculates spill requirements based on the spill requirements of the successors. If all successors of a definition need the value spilled, it commits the spill moves at the definition. It also handles deferred blocks, propagating spill requirements upwards. Finally, it iterates through the successors again to find which ones require spills at their beginnings and inserts those spills using CommitSpill.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"InstructionSequence\",\n                    \"InstructionBlock\",\n                    \"RpoNumber\",\n                    \"Entry\",\n                    \"TopLevelLiveRange\",\n                    \"CommitSpill\",\n                    \"base::bits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SpillPlacer::SecondBackwardPass() {\n  InstructionSequence* code = data()->code();\n  for (int i = last_block_.ToInt(); i >= first_block_.ToInt(); --i) {\n    RpoNumber block_id = RpoNumber::FromInt(i);\n    InstructionBlock* block = code->instruction_blocks()[i];\n\n    Entry& entry = entries_[i];\n\n    // State that will be accumulated from successors.\n    uint64_t spill_required_in_non_deferred_successor = 0;\n    uint64_t spill_required_in_deferred_successor = 0;\n    uint64_t spill_required_in_all_non_deferred_successors =\n        static_cast<uint64_t>(int64_t{-1});\n\n    for (RpoNumber successor_id : block->successors()) {\n      // Ignore loop back-edges.\n      if (successor_id <= block_id) continue;\n\n      InstructionBlock* successor = code->InstructionBlockAt(successor_id);\n      const Entry& successor_entry = entries_[successor_id.ToSize()];\n      if (successor->IsDeferred()) {\n        spill_required_in_deferred_successor |= successor_entry.SpillRequired();\n      } else {\n        spill_required_in_non_deferred_successor |=\n            successor_entry.SpillRequired();\n        spill_required_in_all_non_deferred_successors &=\n            successor_entry.SpillRequired();\n      }\n    }\n\n    // Starting state of the current block.\n    uint64_t defs = entry.Definition();\n\n    // If all of the successors of a definition need the value to be\n    // spilled, then the value should be spilled at the definition.\n    uint64_t spill_at_def = defs & spill_required_in_non_deferred_successor &\n                            spill_required_in_all_non_deferred_successors;\n    for (int index_to_spill : base::bits::IterateBits(spill_at_def)) {\n      int vreg_to_spill = vreg_numbers_[index_to_spill];\n      TopLevelLiveRange* top = data()->live_ranges()[vreg_to_spill];\n      top->CommitSpillMoves(data(), top->GetSpillRangeOperand());\n    }\n\n    if (block->IsDeferred()) {\n      DCHECK_EQ(defs, 0);\n      // Any deferred successor needing a spill is sufficient to make the\n      // current block need a spill.\n      entry.SetSpillRequired(spill_required_in_deferred_successor);\n"
}