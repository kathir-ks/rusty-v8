{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/instruction-selection-phase.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 56, column 14",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/instruction-selection-phase.cc\",\n            \"file_name\": \"instruction-selection-phase.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the instruction selection phase for the Turboshaft compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for instruction selection, graph manipulation, code tracing, and other utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/turboshaft/instruction-selection-phase.h\"\n\n            #include <optional>\n\n            #include \"src/builtins/profile-data-reader.h\"\n            #include \"src/codegen/optimized-compilation-info.h\"\n            #include \"src/compiler/backend/instruction-selector-impl.h\"\n            #include \"src/compiler/backend/instruction-selector.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/pipeline.h\"\n            #include \"src/compiler/turbofan-graph-visualizer.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/phase.h\"\n            #include \"src/compiler/turboshaft/sidetable.h\"\n            #include \"src/diagnostics/code-tracer.h\"\n            #include \"src/utils/sparse-bit-vector.h\"\n        ]]></code>\n    </imports>\n\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::internal::compiler::turboshaft\",\n                \"purpose\": \"Encapsulates the Turboshaft compiler components.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8::internal::compiler::turboshaft {\n        ]]></code>\n\n        <namespace>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"name\": \"<anonymous>\",\n                    \"purpose\": \"Contains utility functions for tracing the instruction sequence.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace {\n\n                void TraceSequence(OptimizedCompilationInfo* info,\n                                   InstructionSequence* sequence, JSHeapBroker* broker,\n                                   CodeTracer* code_tracer, const char* phase_name) {\n                  if (info->trace_turbo_json()) {\n                    UnparkedScopeIfNeeded scope(broker);\n                    AllowHandleDereference allow_deref;\n                    TurboJsonFile json_of(info, std::ios_base::app);\n                    json_of << \"{\\\"name\\\":\\\"\" << phase_name << \"\\\",\\\"type\\\":\\\"sequence\\\"\"\n                            << \",\\\"blocks\\\":\" << InstructionSequenceAsJSON{sequence}\n                            << \",\\\"register_allocation\\\":{\"\n                            << \"\\\"fixed_double_live_ranges\\\": {}\"\n                            << \",\\\"fixed_live_ranges\\\": {}\"\n                            << \",\\\"live_ranges\\\": {}\"\n                            << \"}},\\n\";\n                  }\n                  if (info->trace_turbo_graph()) {\n                    UnparkedScopeIfNeeded scope(broker);\n                    AllowHandleDereference allow_deref;\n                    CodeTracer::StreamScope tracing_scope(code_tracer);\n                    tracing_scope.stream() << \"----- Instruction sequence \" << phase_name\n                                           << \" -----\\n\"\n                                           << *sequence;\n                  }\n                }\n\n                }  // namespace\n            ]]></code>\n        </namespace>\n\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TurboshaftSpecialRPONumberer\",\n                    \"extends\": null,\n                    \"implements\": [],\n                    \"about\": \"Computes a special reverse postorder (RPO) numbering for Turboshaft blocks, taking loops into account.\",\n                    \"attributes\": [\n                        {\n                            \"name\": \"graph_\",\n                            \"type\": \"Graph*\",\n                            \"access\": \"private\",\n                            \"purpose\": \"The graph being processed.\"\n                        },\n                        {\n                            \"name\": \"block_data_\",\n                            \"type\": \"ZoneVector<BlockData>\",\n                            \"access\": \"private\",\n                            \"purpose\": \"Stores metadata associated with each block.\"\n                        },\n                        {\n                            \"name\": \"loops_\",\n                            \"type\": \"ZoneVector<LoopInfo>\",\n                            \"access\": \"private\",\n                            \"purpose\": \"Stores loop information.\"\n                        }\n                    ],\n                    \"dependencies\": [\n                        \"Graph\",\n                        \"Block\",\n                        \"Zone\",\n                        \"ZoneVector\",\n                        \"SuccessorBlocks\",\n                        \"SparseBitVector\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                ZoneVector<uint32_t> TurboshaftSpecialRPONumberer::ComputeSpecialRPO() {\n                  ZoneVector<SpecialRPOStackFrame> stack(zone());\n                  ZoneVector<Backedge> backedges(zone());\n                  // Determined empirically on a large Wasm module. Since they are allocated\n                  // only once per function compilation, the memory usage is not critical.\n                  stack.reserve(64);\n                  backedges.reserve(32);\n                  size_t num_loops = 0;\n\n                  auto Push = [&](const Block* block) {\n                    auto succs = SuccessorBlocks(*block, *graph_);\n                    stack.emplace_back(block, 0, std::move(succs));\n                    set_rpo_number(block, kBlockOnStack);\n                  };\n\n                  const Block* entry = &graph_->StartBlock();\n\n                  // Find correct insertion point within existing order.\n                  const Block* order = nullptr;\n\n                  Push(&graph_->StartBlock());\n\n                  while (!stack.empty()) {\n                    SpecialRPOStackFrame& frame = stack.back();\n\n                    if (frame.index < frame.successors.size()) {\n                      // Process the next successor.\n                      const Block* succ = frame.successors[frame.index++];\n                      if (rpo_number(succ) == kBlockVisited1) continue;\n                      if (rpo_number(succ) == kBlockOnStack) {\n                        // The successor is on the stack, so this is a backedge (cycle).\n                        DCHECK_EQ(frame.index - 1, 0);\n                        backedges.emplace_back(frame.block, frame.index - 1);\n                        // Assign a new loop number to the header.\n                        DCHECK(!has_loop_number(succ));\n                        set_loop_number(succ, num_loops++);\n                      } else {\n                        // Push the successor onto the stack.\n                        DCHECK_EQ(rpo_number(succ), kBlockUnvisited);\n                        Push(succ);\n                      }\n                    } else {\n                      // Finished with all successors; pop the stack and add the block.\n                      order = PushFront(order, frame.block);\n                      set_rpo_number(frame.block, kBlockVisited1);\n                      stack.pop_back();\n                    }\n                  }\n\n                  // If no loops were encountered, then the order we computed was correct.\n                  if (num_loops == 0) return ComputeBlockPermutation(entry);\n\n                  // Otherwise, compute the loop information from the backedges in order\n                  // to perform a traversal that groups loop bodies together.\n                  ComputeLoopInfo(num_loops, backedges);\n\n                  // Initialize the \"loop stack\". We assume that the entry cannot be a loop\n                  // header.\n                  CHECK(!has_loop_number(entry));\n                  LoopInfo* loop = nullptr;\n                  order = nullptr;\n\n                  // Perform an iterative post-order traversal, visiting loop bodies before\n                  // edges that lead out of loops. Visits each block once, but linking loop\n                  // sections together is linear in the loop size, so overall is\n                  // O(|B| + max(loop_depth) * max(|loop|))\n                  DCHECK(stack.empty());\n                  Push(&graph_->StartBlock());\n                  while (!stack.empty()) {\n                    SpecialRPOStackFrame& frame = stack.back();\n                    const Block* block = frame.block;\n                    const Block* succ = nullptr;\n\n                    if (frame.index < frame.successors.size()) {\n                      // Process the next normal successor.\n                      succ = frame.successors[frame.index++];\n                    } else if (has_loop_number(block)) {\n                      // Process additional outgoing edges from the loop header.\n                      if (rpo_number(block) == kBlockOnStack) {\n                        // Finish the loop body the first time the header is left on the\n                        // stack.\n                        DCHECK_NOT_NULL(loop);\n                        DCHECK_EQ(loop->header, block);\n                        loop->start = PushFront(order, block);\n                        order = loop->end;\n                        set_rpo_number(block, kBlockVisited2);\n                        // Pop the loop stack and continue visiting outgoing edges within\n                        // the context of the outer loop, if any.\n                        loop = loop->prev;\n                        // We leave the loop header on the stack; the rest of this iteration\n                        // and later iterations will go through its outgoing edges list.\n                      }\n\n                      // Use the next outgoing edge if there are any.\n                      size_t outgoing_index = frame.index - frame.successors.size();\n                      LoopInfo* info = &loops_[loop_number(block)];\n                      DCHECK_NE(loop, info);\n                      if (block != entry && outgoing_index < info->outgoing.size()) {\n                        succ = info->outgoing[outgoing_index];\n                        ++frame.index;\n                      }\n                    }\n\n                    if (succ != nullptr) {\n                      // Process the next successor.\n                      if (rpo_number(succ) == kBlockOnStack) continue;\n                      if (rpo_number(succ) == kBlockVisited2) continue;\n                      DCHECK_EQ(kBlockVisited1, rpo_number(succ));\n                      if (loop != nullptr && !loop->members->Contains(succ->index().id())) {\n                        // The successor is not in the current loop or any nested loop.\n                        // Add it to the outgoing edges of this loop and visit it later.\n                        loop->AddOutgoing(zone(), succ);\n                      } else {\n                        // Push the successor onto the stack.\n                        Push(succ);\n                        if (has_loop_number(succ)) {\n                          // Push the inner loop onto the loop stack.\n                          DCHECK_LT(loop_number(succ), num_loops);\n                          LoopInfo* next = &loops_[loop_number(succ)];\n                          next->end = order;\n                          next->prev = loop;\n                          loop = next;\n                        }\n                      }\n                    } else {\n                      // Finish with all successors of the current block.\n                      if (has_loop_number(block)) {\n                        // If we are going to pop a loop header, then add its entire body.\n                        LoopInfo* info = &loops_[loop_number(block)];\n                        for (const Block* b = info->start; true;\n                             b = block_data_[b->index()].rpo_next) {\n                          if (block_data_[b->index()].rpo_next == info->end) {\n                            PushFront(order, b);\n                            info->end = order;\n                            break;\n                          }\n                        }\n                        order = info->start;\n                      } else {\n                        // Pop a single node off the stack and add it to the order.\n                        order = PushFront(order, block);\n                        set_rpo_number(block, kBlockVisited2);\n                      }\n                      stack.pop_back();\n                    }\n                  }\n\n                  return ComputeBlockPermutation(entry);\n                }\n            ]]></code>\n        </class>\n\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"ComputeLoopInfo\",\n                    \"parent\": \"TurboshaftSpecialRPONumberer\",\n                    \"about\": \"Computes loop membership information from the backedges of the control flow graph.\",\n                    \"logic\": \"Iterates through backedges, identifying loop headers and members. Uses a stack to propagate membership backwards from backedges to loop headers.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"num_loops\",\n                            \"type\": \"size_t\",\n                            \"purpose\": \"The number of loops in the graph.\"\n                        },\n                        {\n                            \"name\": \"backedges\",\n                            \"type\": \"ZoneVector<Backedge>&\",\n                            \"purpose\": \"A vector of backedges in the control flow graph.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"void\",\n                        \"description\": \"No return value.\"\n                    },\n                    \"dependencies\": [\n                        \"Graph\",\n                        \"Block\",\n                        \"Zone\",\n                        \"ZoneVector\",\n                        \"SparseBitVector\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                void TurboshaftSpecialRPONumberer::ComputeLoopInfo(\n                    size_t num_loops, ZoneVector<Backedge>& backedges) {\n                  ZoneVector<const Block*> stack(zone());\n\n                  // Extend loop information vector.\n                  loops_.resize(num_loops, LoopInfo{});\n\n                  // Compute loop membership starting from backedges.\n                  // O(max(loop_depth) * |loop|)\n                  for (auto [backedge, header_index] : backedges) {\n                    const Block* header = SuccessorBlocks(*backedge, *graph_)[header_index];\n                    DCHECK(header->IsLoop());\n                    size_t loop_num = loop_number(header);\n                    DCHECK_NULL(loops_[loop_num].header);\n                    loops_[loop_num].header = header;\n                    loops_[loop_num].members = zone()->New<SparseBitVector>(zone());\n\n                    if (backedge != header) {\n                      // As long as the header doesn't have a backedge to itself,\n                      // Push the member onto the queue and process its predecessors.\n                      DCHECK(!loops_[loop_num].members->Contains(backedge->index().id()));\n                      loops_[loop_num].members->Add(backedge->index().id());\n                      stack.push_back(backedge);\n                    }\n\n                    // Propagate loop membership backwards. All predecessors of M up to the\n                    // loop header H are members of the loop too. O(|blocks between M and H|).\n                    while (!stack.empty()) {\n                      const Block* block = stack.back();\n                      stack.pop_back();\n                      for (const Block* pred : block->PredecessorsIterable()) {\n                        if (pred != header) {\n                          if (!loops_[loop_num].members->Contains(pred->index().id())) {\n                            loops_[loop_num].members->Add(pred->index().id());\n                            stack.push_back(pred);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n            ]]></code>\n        </func>\n\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"ComputeBlockPermutation\",\n                    \"parent\": \"TurboshaftSpecialRPONumberer\",\n                    \"about\": \"Computes a block permutation vector from the RPO linked list.\",\n                    \"logic\": \"Traverses the RPO linked list and creates a vector containing the block indices in the computed order.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"entry\",\n                            \"type\": \"const Block*\",\n                            \"purpose\": \"The entry block of the graph.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"ZoneVector<uint32_t>\",\n                        \"description\": \"A vector containing the block indices in the computed RPO.\"\n                    },\n                    \"dependencies\": [\n                        \"Graph\",\n                        \"Block\",\n                        \"Zone\",\n                        \"ZoneVector\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                ZoneVector<uint32_t> TurboshaftSpecialRPONumberer::ComputeBlockPermutation(\n                    const Block* entry) {\n                  ZoneVector<uint32_t> result(graph_->block_count(), zone());\n                  size_t i = 0;\n                  for (const Block* b = entry; b; b = block_data_[b->index()].rpo_next) {\n                    result[i++] = b->index().id();\n                  }\n                  DCHECK_EQ(i, graph_->block_count());\n                  return result;\n                }\n            ]]></code>\n        </func>\n\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"function\",\n                    \"name\": \"PropagateDeferred\",\n                    \"parent\": null,\n                    \"about\": \"Propagates deferred execution status through the graph based on branch hints and predecessor information.\",\n                    \"logic\": \"Iterates through the blocks of the graph, determining whether each block should be deferred based on branch hints from predecessors and the presence of multiple predecessors.\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"graph\",\n                            \"type\": \"Graph&\",\n                            \"purpose\": \"The graph to process.\"\n                        }\n                    ],\n                    \"return\": {\n                        \"type\": \"void\",\n                        \"description\": \"No return value.\"\n                    },\n                    \"dependencies\": [\n                        \"Graph\",\n                        \"Block\",\n                        \"BranchOp\",\n                        \"IsUnlikelySuccessor\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                void PropagateDeferred(Graph& graph) {\n                  graph.StartBlock().set_custom_data(\n                      0, Block::CustomDataKind::kDeferredInSchedule);\n                  for (Block& block : graph.blocks()) {\n                    const Block* predecessor = block.LastPredecessor();\n                    if (predecessor == nullptr) {\n                      continue;\n                    } else if (block.IsLoop()) {\n                      // We only consider the forward edge for loop headers.\n                      predecessor = predecessor->NeighboringPredecessor();\n                      DCHECK_NOT_NULL(predecessor);\n                      DCHECK_EQ(predecessor->NeighboringPredecessor(), nullptr);\n                      block.set_custom_data(predecessor->get_custom_data(\n                                                Block::CustomDataKind::kDeferredInSchedule),\n                                              Block::CustomDataKind::kDeferredInSchedule);\n                    } else if (predecessor->NeighboringPredecessor() == nullptr) {\n                      // This block has only a single predecessor. Due to edge-split form, those\n                      // are the only blocks that can be the target of a branch-like op which\n                      // might potentially provide a BranchHint to defer this block.\n                      const bool is_deferred =\n                          predecessor->get_custom_data(\n                              Block::CustomDataKind::kDeferredInSchedule) ||\n                          IsUnlikelySuccessor(predecessor, &block, graph);\n                      block.set_custom_data(is_deferred,\n                                            Block::CustomDataKind::kDeferredInSchedule);\n                    } else {\n                      block.set_custom_data(true, Block::CustomDataKind::kDeferredInSchedule);\n                      for (; predecessor; predecessor = predecessor->NeighboringPredecessor()) {\n                        // If there is a single predecessor that is not deferred, then block is\n                        // also not deferred.\n                        if (!predecessor->get_custom_data(\n                                Block::CustomDataKind::kDeferredInSchedule)) {\n                          block.set_custom_data(false,\n                                                Block::CustomDataKind::kDeferredInSchedule);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n            ]]></code>\n        </func>\n\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ProfileApplicationPhase\",\n                    \"extends\": null,\n                    \"implements\": [],\n                    \"about\": \"Applies branch prediction hints from a profile to the Turboshaft graph.\",\n                    \"attributes\": [],\n                    \"dependencies\": [\n                        \"Graph\",\n                        \"BranchOp\",\n                        \"ProfileDataFromFile\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                void ProfileApplicationPhase::Run(PipelineData* data, Zone* temp_zone,\n                                                    const ProfileDataFromFile* profile) {\n                  Graph& graph = data->graph();\n                  for (auto& op : graph.AllOperations()) {\n                    if (BranchOp* branch = op.TryCast<BranchOp>()) {\n                      uint32_t true_block_id = branch->if_true->index().id();\n                      uint32_t false_block_id = branch->if_false->index().id();\n                      BranchHint hint = profile->GetHint(true_block_id, false_block_id);\n                      if (hint != BranchHint::kNone) {\n                        // We update the hint in-place.\n                        branch->hint = hint;\n                      }\n                    }\n                  }\n                }\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SpecialRPOSchedulingPhase\",\n                    \"extends\": null,\n                    \"implements\": [],\n                    \"about\": \"Performs special reverse postorder (RPO) scheduling and propagates deferred execution status.\",\n                    \"attributes\": [],\n                    \"dependencies\": [\n                        \"Graph\",\n                        \"TurboshaftSpecialRPONumberer\",\n                        \"PropagateDeferred\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                void SpecialRPOSchedulingPhase::Run(PipelineData* data, Zone* temp_zone) {\n                  Graph& graph = data->graph();\n\n                  // Compute special RPO order....\n                  TurboshaftSpecialRPONumberer numberer(graph, temp_zone);\n                  if (!data->graph_has_special_rpo()) {\n                    auto schedule = numberer.ComputeSpecialRPO();\n                    graph.ReorderBlocks(base::VectorOf(schedule));\n                    data->set_graph_has_special_rpo();\n                  }\n\n                  // Determine deferred blocks.\n                  PropagateDeferred(graph);\n                }\n            ]]></code>\n        </class>\n\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"InstructionSelectionPhase\",\n                    \"extends\": null,\n                    \"implements\": [],\n                    \"about\": \"Performs instruction selection for the Turboshaft graph.\",\n                    \"attributes\": [],\n                    \"dependencies\": [\n                        \"Graph\",\n                        \"InstructionSelector\",\n                        \"PipelineData\",\n                        \"CallDescriptor\",\n                        \"Linkage\",\n                        \"CodeTracer\",\n                        \"InstructionSequence\",\n                        \"TraceSequence\"\n                    ]\n                }\n            </metadata>\n            <code><![CDATA[\n                std::optional<BailoutReason> InstructionSelectionPhase::Run(\n                    PipelineData* data, Zone* temp_zone, const CallDescriptor* call_descriptor,\n                    Linkage* linkage, CodeTracer* code_tracer) {\n                  Graph& graph = data->graph();\n\n                  // Initialize an instruction sequence.\n                  data->InitializeInstructionComponent(call_descriptor);\n\n                  // Run the actual instruction selection.\n                  InstructionSelector selector = InstructionSelector::ForTurboshaft(\n                      temp_zone, graph.op_id_count(), linkage, data->sequence(), &graph,\n                      data->frame(),\n                      data->info()->switch_jump_table()\n                          ? InstructionSelector::kEnableSwitchJumpTable\n                          : InstructionSelector::kDisableSwitchJumpTable,\n                      &data->info()->tick_counter(), data->broker(),\n                      &data->max_unoptimized_frame_height(), &data->max_pushed_argument_count(),\n                      data->info()->source_positions()\n                          ? InstructionSelector::kAllSourcePositions\n                          : InstructionSelector::kCallSourcePositions,\n                      InstructionSelector::SupportedFeatures(),\n                      v8_flags.turbo_instruction_scheduling\n                          ? InstructionSelector::kEnableScheduling\n                          : InstructionSelector::kDisableScheduling,\n                      data->assembler_options().enable_root_relative_access\n                          ? InstructionSelector::kEnableRootsRelativeAddressing\n                          : InstructionSelector::kDisableRootsRelativeAddressing,\n                      data->info()->trace_turbo_json()\n                          ? InstructionSelector::kEnableTraceTurboJson\n                          : InstructionSelector::kDisableTraceTurboJson);\n                  if (std::optional<BailoutReason> bailout = selector.SelectInstructions()) {\n                    return bailout;\n                  }\n                  TraceSequence(data->info(), data->sequence(), data->broker(), code_tracer,\n                                \"after instruction selection\");\n                  return std::nullopt;\n                }\n            ]]></code>\n        </class>\n\n    <code><![CDATA[\n        }  // namespace v8::internal::compiler::turboshaft\n    ]]></code>\n    </namespace>\n</file>\n```"
}