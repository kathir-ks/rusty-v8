{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/loong64/code-generator-loong64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/loong64/code-generator-loong64.cc\",\n        \"file_name\": \"code-generator-loong64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the CodeGenerator class for the Loong64 architecture, responsible for translating TurboFan's intermediate representation to Loong64 machine code.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary header files for assembler, code generation, and architecture-specific constants.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/callable.h\"\n#include \"src/codegen/interface-descriptors-inl.h\"\n#include \"src/codegen/loong64/constants-loong64.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/backend/code-generator-impl.h\"\n#include \"src/compiler/backend/code-generator.h\"\n#include \"src/compiler/backend/gap-resolver.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/osr.h\"\n#include \"src/heap/mutable-page-metadata.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Loong64OperandConverter\",\n            \"extends\": \"InstructionOperandConverter\",\n            \"about\": \"A helper class that provides Loong64-specific methods for converting InstructionOperands to architecture-specific representations (registers, immediate values, memory operands).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"Instruction\",\n                \"InstructionOperand\",\n                \"FloatRegister\",\n                \"Register\",\n                \"Operand\",\n                \"Constant\",\n                \"RootIndex\",\n                \"Isolate\",\n                \"MemOperand\",\n                \"FrameOffset\",\n                \"AddressingModeField\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass Loong64OperandConverter final : public InstructionOperandConverter {\n public:\n  Loong64OperandConverter(CodeGenerator* gen, Instruction* instr)\n      : InstructionOperandConverter(gen, instr) {}\n\n  FloatRegister OutputSingleRegister(size_t index = 0) {\n    return ToSingleRegister(instr_->OutputAt(index));\n  }\n\n  FloatRegister InputSingleRegister(size_t index) {\n    return ToSingleRegister(instr_->InputAt(index));\n  }\n\n  FloatRegister ToSingleRegister(InstructionOperand* op) {\n    // Single (Float) and Double register namespace is same on LOONG64,\n    // both are typedefs of FPURegister.\n    return ToDoubleRegister(op);\n  }\n\n  Register InputOrZeroRegister(size_t index) {\n    if (instr_->InputAt(index)->IsImmediate()) {\n      DCHECK_EQ(0, InputInt32(index));\n      return zero_reg;\n    }\n    return InputRegister(index);\n  }\n\n  DoubleRegister InputOrZeroDoubleRegister(size_t index) {\n    if (instr_->InputAt(index)->IsImmediate()) return kDoubleRegZero;\n\n    return InputDoubleRegister(index);\n  }\n\n  DoubleRegister InputOrZeroSingleRegister(size_t index) {\n    if (instr_->InputAt(index)->IsImmediate()) return kDoubleRegZero;\n\n    return InputSingleRegister(index);\n  }\n\n  Operand InputImmediate(size_t index) {\n    Constant constant = ToConstant(instr_->InputAt(index));\n    switch (constant.type()) {\n      case Constant::kInt32:\n        return Operand(constant.ToInt32());\n      case Constant::kInt64:\n        return Operand(constant.ToInt64());\n      case Constant::kFloat32:\n        return Operand::EmbeddedNumber(constant.ToFloat32());\n      case Constant::kFloat64:\n        return Operand::EmbeddedNumber(constant.ToFloat64().value());\n      case Constant::kCompressedHeapObject: {\n        RootIndex root_index;\n        if (gen_->isolate()->roots_table().IsRootHandle(constant.ToHeapObject(),\n                                                        &root_index)) {\n          CHECK(COMPRESS_POINTERS_BOOL);\n          CHECK(V8_STATIC_ROOTS_BOOL || !gen_->isolate()->bootstrapper());\n          Tagged_t ptr =\n              MacroAssemblerBase::ReadOnlyRootPtr(root_index, gen_->isolate());\n          return Operand(ptr);\n        }\n        return Operand(constant.ToHeapObject());\n      }\n      case Constant::kExternalReference:\n      case Constant::kHeapObject:\n        break;\n      case Constant::kRpoNumber:\n        UNREACHABLE();  // TODO(titzer): RPO immediates on loong64?\n    }\n    UNREACHABLE();\n  }\n\n  Operand InputOperand(size_t index) {\n    InstructionOperand* op = instr_->InputAt(index);\n    if (op->IsRegister()) {\n      return Operand(ToRegister(op));\n    }\n    return InputImmediate(index);\n  }\n\n  MemOperand MemoryOperand(size_t* first_index) {\n    const size_t index = *first_index;\n    switch (AddressingModeField::decode(instr_->opcode())) {\n      case kMode_None:\n        break;\n      case kMode_Root:\n        *first_index += 1;\n        return MemOperand(kRootRegister, InputInt32(index));\n      case kMode_MRI:\n        *first_index += 2;\n        return MemOperand(InputRegister(index + 0), InputInt32(index + 1));\n      case kMode_MRR:\n        *first_index += 2;\n        return MemOperand(InputRegister(index + 0), InputRegister(index + 1));\n    }\n    UNREACHABLE();\n  }\n\n  MemOperand MemoryOperand(size_t index = 0) { return MemoryOperand(&index); }\n\n  MemOperand ToMemOperand(InstructionOperand* op) const {\n    DCHECK_NOT_NULL(op);\n    DCHECK(op->IsStackSlot() || op->IsFPStackSlot());\n    return SlotToMemOperand(AllocatedOperand::cast(op)->index());\n  }\n\n  MemOperand SlotToMemOperand(int slot) const {\n    FrameOffset offset = frame_access_state()->GetFrameOffset(slot);\n    return MemOperand(offset.from_stack_pointer() ? sp : fp, offset.offset());\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"HasRegisterInput\",\n            \"about\": \"Helper function to check if an instruction input at a given index is a register.\",\n            \"logic\": \"Checks if the instruction input at the specified index is a register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the input to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the input is a register, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic inline bool HasRegisterInput(Instruction* instr, size_t index) {\n  return instr->InputAt(index)->IsRegister();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineRecordWrite\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"Generates out-of-line code for record write operations, including write barriers.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"Register\",\n                \"Operand\",\n                \"RecordWriteMode\",\n                \"StubCallMode\",\n                \"Zone\",\n                \"MemoryChunk\",\n                \"Frame\",\n                \"SaveFPRegsMode\",\n                \"IndirectPointerTag\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass OutOfLineRecordWrite final : public OutOfLineCode {\n public:\n  OutOfLineRecordWrite(\n      CodeGenerator* gen, Register object, Operand offset, Register value,\n      RecordWriteMode mode, StubCallMode stub_mode,\n      IndirectPointerTag indirect_pointer_tag = kIndirectPointerNullTag)\n      : OutOfLineCode(gen),\n        object_(object),\n        offset_(offset),\n        value_(value),\n        mode_(mode),\n#if V8_ENABLE_WEBASSEMBLY\n        stub_mode_(stub_mode),\n#endif  // V8_ENABLE_WEBASSEMBLY\n        must_save_lr_(!gen->frame_access_state()->has_frame()),\n        zone_(gen->zone()),\n        indirect_pointer_tag_(indirect_pointer_tag) {\n  }\n\n  void Generate() final {\n    // When storing an indirect pointer, the value will always be a\n    // full/decompressed pointer.\n    if (COMPRESS_POINTERS_BOOL &&\n        mode_ != RecordWriteMode::kValueIsIndirectPointer) {\n      __ DecompressTagged(value_, value_);\n    }\n\n    __ CheckPageFlag(value_, MemoryChunk::kPointersToHereAreInterestingMask, eq,\n                     exit());\n\n    SaveFPRegsMode const save_fp_mode = frame()->DidAllocateDoubleRegisters()\n                                            ? SaveFPRegsMode::kSave\n                                            : SaveFPRegsMode::kIgnore;\n    if (must_save_lr_) {\n      // We need to save and restore ra if the frame was elided.\n      __ Push(ra);\n    }\n    if (mode_ == RecordWriteMode::kValueIsEphemeronKey) {\n      __ CallEphemeronKeyBarrier(object_, offset_, save_fp_mode);\n    } else if (mode_ == RecordWriteMode::kValueIsIndirectPointer) {\n      DCHECK(IsValidIndirectPointerTag(indirect_pointer_tag_));\n      __ CallIndirectPointerBarrier(object_, offset_, save_fp_mode,\n                                    indirect_pointer_tag_);\n#if V8_ENABLE_WEBASSEMBLY\n    } else if (stub_mode_ == StubCallMode::kCallWasmRuntimeStub) {\n      // A direct call to a wasm runtime stub defined in this module.\n      // Just encode the stub index. This will be patched when the code\n      // is added to the native module and copied into wasm code space.\n      __ CallRecordWriteStubSaveRegisters(object_, offset_, save_fp_mode,\n                                          StubCallMode::kCallWasmRuntimeStub);\n#endif  // V8_ENABLE_WEBASSEMBLY\n    } else {\n      __ CallRecordWriteStubSaveRegisters(object_, offset_, save_fp_mode);\n    }\n    if (must_save_lr_) {\n      __ Pop(ra);\n    }\n  }\n\n private:\n  Register const object_;\n  Operand const offset_;\n  Register const value_;\n  RecordWriteMode const mode_;\n#if V8_ENABLE_WEBASSEMBLY\n  StubCallMode const stub_mode_;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  bool must_save_lr_;\n  Zone* zone_;\n  IndirectPointerTag indirect_pointer_tag_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineFloat32Max\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"OutOfLine code class to perform Float32Max operation\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"FPURegister\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCREATE_OOL_CLASS(OutOfLineFloat32Max, Float32MaxOutOfLine, FPURegister);\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineFloat32Min\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"OutOfLine code class to perform Float32Min operation\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"FPURegister\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCREATE_OOL_CLASS(OutOfLineFloat32Min, Float32MinOutOfLine, FPURegister);\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineFloat64Max\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"OutOfLine code class to perform Float64Max operation\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"FPURegister\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCREATE_OOL_CLASS(OutOfLineFloat64Max, Float64MaxOutOfLine, FPURegister);\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineFloat64Min\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"OutOfLine code class to perform Float64Min operation\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"FPURegister\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nCREATE_OOL_CLASS(OutOfLineFloat64Min, Float64MinOutOfLine, FPURegister);\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmOutOfLineTrap\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"Defines an out-of-line code sequence that calls the runtime to handle a Wasm trap.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"Instruction\",\n                \"TrapId\",\n                \"Loong64OperandConverter\",\n                \"Address\",\n                \"RelocInfo\",\n                \"ReferenceMap\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\nclass WasmOutOfLineTrap : public OutOfLineCode {\n public:\n  WasmOutOfLineTrap(CodeGenerator* gen, Instruction* instr)\n      : OutOfLineCode(gen), gen_(gen), instr_(instr) {}\n  void Generate() override {\n    Loong64OperandConverter i(gen_, instr_);\n    TrapId trap_id =\n        static_cast<TrapId>(i.InputInt32(instr_->InputCount() - 1));\n    GenerateCallToTrap(trap_id);\n  }\n\n protected:\n  CodeGenerator* gen_;\n\n  void GenerateWithTrapId(TrapId trap_id) { GenerateCallToTrap(trap_id); }\n\n private:\n  void GenerateCallToTrap(TrapId trap_id) {\n    gen_->AssembleSourcePosition(instr_);\n    // A direct call to a wasm runtime stub defined in this module.\n    // Just encode the stub index. This will be patched when the code\n    // is added to the native module and copied into wasm code space.\n    __ Call(static_cast<Address>(trap_id), RelocInfo::WASM_STUB_CALL);\n    ReferenceMap* reference_map = gen_->zone()->New<ReferenceMap>(gen_->zone());\n    gen_->RecordSafepoint(reference_map);\n    __ AssertUnreachable(AbortReason::kUnexpectedReturnFromWasmTrap);\n  }\n\n  Instruction* instr_;\n};\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"RecordTrapInfoIfNeeded\",\n            \"about\": \"Records trap information for protected memory access in WebAssembly.\",\n            \"logic\": \"If memory access mode indicates out-of-bounds access or null dereference, records safepoint and protected instruction information.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone for memory allocation.\"\n                },\n                {\n                    \"name\": \"codegen\",\n                    \"type\": \"CodeGenerator*\",\n                    \"purpose\": \"The code generator instance.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction.\"\n                },\n                {\n                    \"name\": \"pc\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The program counter.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"AccessModeField\",\n                \"ReferenceMap\",\n                \"CodeGenerator\",\n                \"Instruction\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid RecordTrapInfoIfNeeded(Zone* zone, CodeGenerator* codegen,\n                            InstructionCode opcode, Instruction* instr,\n                            int pc) {\n  const MemoryAccessMode access_mode = AccessModeField::decode(opcode);\n  if (access_mode == kMemoryAccessProtectedMemOutOfBounds ||\n      access_mode == kMemoryAccessProtectedNullDereference) {\n    ReferenceMap* reference_map =\n        codegen->zone()->New<ReferenceMap>(codegen->zone());\n    // The safepoint has to be recorded at the return address of a call. Address\n    // we use as the fake return address in the case of the trap handler is the\n    // fault address (here `pc`) + 1. Therefore the safepoint here has to be\n    // recorded at pc + 1;\n    codegen->RecordSafepoint(reference_map, pc + 1);\n    codegen->RecordProtectedInstruction(pc);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FlagsConditionToConditionCmp\",\n            \"about\": \"Converts a FlagsCondition to a Condition for compare operations.\",\n            \"logic\": \"Maps FlagsCondition enum values to Condition enum values for compare operations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"condition\",\n                    \"type\": \"FlagsCondition\",\n                    \"purpose\": \"The flags condition to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Condition\",\n                \"description\": \"The corresponding Condition enum value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nCondition FlagsConditionToConditionCmp(FlagsCondition condition) {\n  switch (condition) {\n    case kEqual:\n      return eq;\n    case kNotEqual:\n      return ne;\n    case kSignedLessThan:\n      return lt;\n    case kSignedGreaterThanOrEqual:\n      return ge;\n    case kSignedLessThanOrEqual:\n      return le;\n    case kSignedGreaterThan:\n      return gt;\n    case kUnsignedLessThan:\n      return lo;\n    case kUnsignedGreaterThanOrEqual:\n      return hs;\n    case kUnsignedLessThanOrEqual:\n      return ls;\n    case kUnsignedGreaterThan:\n      return hi;\n    case kUnorderedEqual:\n    case kUnorderedNotEqual:\n      break;\n    default:\n      break;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FlagsConditionToConditionTst\",\n            \"about\": \"Converts a FlagsCondition to a Condition for test operations.\",\n            \"logic\": \"Maps FlagsCondition enum values to Condition enum values for test operations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"condition\",\n                    \"type\": \"FlagsCondition\",\n                    \"purpose\": \"The flags condition to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Condition\",\n                \"description\": \"The corresponding Condition enum value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nCondition FlagsConditionToConditionTst(FlagsCondition condition) {\n  switch (condition) {\n    case kNotEqual:\n      return ne;\n    case kEqual:\n      return eq;\n    default:\n      break;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FlagsConditionToConditionOvf\",\n            \"about\": \"Converts a FlagsCondition to a Condition for overflow operations.\",\n            \"logic\": \"Maps FlagsCondition enum values to Condition enum values for overflow operations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"condition\",\n                    \"type\": \"FlagsCondition\",\n                    \"purpose\": \"The flags condition to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Condition\",\n                \"description\": \"The corresponding Condition enum value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nCondition FlagsConditionToConditionOvf(FlagsCondition condition) {\n  switch (condition) {\n    case kOverflow:\n      return ne;\n    case kNotOverflow:\n      return eq;\n    default:\n      break;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FlagsConditionToConditionCmpFPU\",\n            \"about\": \"Converts a FlagsCondition to a FPUCondition for floating-point compare operations.\",\n            \"logic\": \"Maps FlagsCondition enum values to FPUCondition enum values for floating-point compare operations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"predicate\",\n                    \"type\": \"bool*\",\n                    \"purpose\": \"Pointer to a boolean variable to store predicate.\"\n                },\n                {\n                    \"name\": \"condition\",\n                    \"type\": \"FlagsCondition\",\n                    \"purpose\": \"The flags condition to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"FPUCondition\",\n                \"description\": \"The corresponding FPUCondition enum value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nFPUCondition FlagsConditionToConditionCmpFPU(bool* predicate,\n                                             FlagsCondition condition) {\n  switch (condition) {\n    case kEqual:\n      *predicate = true;\n      return CEQ;\n    case kNotEqual:\n      *predicate = false;\n      return CEQ;\n    case kUnsignedLessThan:\n    case kFloatLessThan:\n      *predicate = true;\n      return CLT;\n    case kUnsignedGreaterThanOrEqual:\n      *predicate = false;\n      return CLT;\n    case kUnsignedLessThanOrEqual:\n    case kFloatLessThanOrEqual:\n      *predicate = true;\n      return CLE;\n    case kUnsignedGreaterThan:\n      *predicate = false;\n      return CLE;\n    case kFloatGreaterThan:\n      *predicate = false;\n      return CULE;\n    case kFloatGreaterThanOrEqual:\n      *predicate = false;\n      return CULT;\n    case kFloatLessThanOrUnordered:\n      *predicate = true;\n      return CULT;\n    case kFloatGreaterThanOrUnordered:\n      *predicate = false;\n      return CLE;\n    case kFloatGreaterThanOrEqualOrUnordered:\n      *predicate = false;\n      return CLT;\n    case kFloatLessThanOrEqualOrUnordered:\n      *predicate = true;\n      return CULE;\n    case kUnorderedEqual:\n    case kUnorderedNotEqual:\n      *predicate = true;\n      break;\n    default:\n      *predicate = true;\n      break;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleDeconstructFrame\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the code to deconstruct a stack frame.\",\n            \"logic\": \"Restores the stack pointer and frame pointer from the current frame.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Frame\",\n                \"MacroAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleDeconstructFrame() {\n  __ mov(sp, fp);\n  __ Pop(ra, fp);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssemblePrepareTailCall\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the code to prepare for a tail call.\",\n            \"logic\": \"Loads the return address and frame pointer from the caller's frame, then sets the frame access state to SP-based.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FrameAccessState\",\n                \"MacroAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssemblePrepareTailCall() {\n  if (frame_access_state()->has_frame()) {\n    __ Ld_d(ra, MemOperand(fp, StandardFrameConstants::kCallerPCOffset));\n    __ Ld_d(fp, MemOperand(fp, StandardFrameConstants::kCallerFPOffset));\n  }\n  frame_access_state()->SetFrameAccessToSP();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AdjustStackPointerForTailCall\",\n            \"about\": \"Adjusts the stack pointer to prepare for a tail call.\",\n            \"logic\": \"Calculates the difference between the current stack slot count and the desired slot count, then adjusts the stack pointer accordingly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"masm\",\n                    \"type\": \"MacroAssembler*\",\n                    \"purpose\": \"The macro assembler.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"FrameAccessState*\",\n                    \"purpose\": \"The frame access state.\"\n                },\n                {\n                    \"name\": \"new_slot_above_sp\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The desired stack slot count above the stack pointer.\"\n                },\n                {\n                    \"name\": \"allow_shrinkage\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether stack shrinkage is allowed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FrameAccessState\",\n                \"MacroAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AdjustStackPointerForTailCall(MacroAssembler* masm,\n                                   FrameAccessState* state,\n                                   int new_slot_above_sp,\n                                   bool allow_shrinkage = true) {\n  int current_sp_offset = state->GetSPToFPSlotCount() +\n                          StandardFrameConstants::kFixedSlotCountAboveFp;\n  int stack_slot_delta = new_slot_above_sp - current_sp_offset;\n  if (stack_slot_delta > 0) {\n    masm->Sub_d(sp, sp, stack_slot_delta * kSystemPointerSize);\n    state->IncreaseSPDelta(stack_slot_delta);\n  } else if (allow_shrinkage && stack_slot_delta < 0) {\n    masm->Add_d(sp, sp, -stack_slot_delta * kSystemPointerSize);\n    state->IncreaseSPDelta(stack_slot_delta);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleTailCallBeforeGap\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles a tail call before a gap in the instruction sequence.\",\n            \"logic\": \"Adjusts the stack pointer to the specified slot offset, disallowing stack shrinkage.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction.\"\n                },\n                {\n                    \"name\": \"first_unused_slot_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The offset of the first unused stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleTailCallBeforeGap(Instruction* instr,\n                                              int first_unused_slot_offset) {\n  AdjustStackPointerForTailCall(masm(), frame_access_state(),\n                                first_unused_slot_offset, false);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleTailCallAfterGap\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles a tail call after a gap in the instruction sequence.\",\n            \"logic\": \"Adjusts the stack pointer to the specified slot offset, allowing stack shrinkage.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction.\"\n                },\n                {\n                    \"name\": \"first_unused_slot_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The offset of the first unused stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleTailCallAfterGap(Instruction* instr,\n                                             int first_unused_slot_offset) {\n  AdjustStackPointerForTailCall(masm(), frame_access_state(),\n                                first_unused_slot_offset);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleCodeStartRegisterCheck\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles code to check that the kJavaScriptCallCodeStartRegister is correct.\",\n            \"logic\": \"Computes the code start address and asserts that it matches the value in kJavaScriptCallCodeStartRegister.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"MacroAssembler\",\n                \"UseScratchRegisterScope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Check that {kJavaScriptCallCodeStartRegister} is correct.\nvoid CodeGenerator::AssembleCodeStartRegisterCheck() {\n  UseScratchRegisterScope temps(masm());\n  Register scratch = temps.Acquire();\n  __ ComputeCodeStartAddress(scratch);\n  __ Assert(eq, AbortReason::kWrongFunctionCodeStart,\n            kJavaScriptCallCodeStartRegister, Operand(scratch));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BailoutIfDeoptimized\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles a bailout if the code has been deoptimized.\",\n            \"logic\": \"Emits a call to BailoutIfDeoptimized\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"MacroAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::BailoutIfDeoptimized() { __ BailoutIfDeoptimized(); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleArchInstruction\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles an architecture-specific instruction, producing machine code.\",\n            \"logic\": \"Translates TurboFan's IR instructions to Loong64 assembly instructions. This function encompasses a large switch statement handling each supported opcode.\",\n            \"parameters\": ["
}