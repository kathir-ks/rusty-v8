{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/bytecode-graph-builder.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/bytecode-graph-builder.cc\",\n        \"file_name\": \"bytecode-graph-builder.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the BytecodeGraphBuilder class, which constructs a graph representation from bytecode instructions.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for bytecode processing, graph construction, and other compiler components.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/bytecode-graph-builder.h\"\n\n#include <optional>\n\n#include \"src/ast/ast.h\"\n#include \"src/codegen/source-position-table.h\"\n#include \"src/codegen/tick-counter.h\"\n#include \"src/common/assert-scope.h\"\n#include \"src/compiler/bytecode-analysis.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/js-type-hint-lowering.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-observer.h\"\n#include \"src/compiler/node-origin-table.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/state-values-utils.h\"\n#include \"src/interpreter/bytecode-array-iterator.h\"\n#include \"src/interpreter/bytecode-flags-and-tokens.h\"\n#include \"src/interpreter/bytecode-register.h\"\n#include \"src/interpreter/bytecodes.h\"\n#include \"src/objects/elements-kind.h\"\n#include \"src/objects/js-generator.h\"\n#include \"src/objects/literal-objects-inl.h\"\n#include \"src/objects/scope-info.h\"\n#include \"src/objects/template-objects-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BytecodeGraphBuilder\",\n            \"about\": \"The main class responsible for building the graph representation from bytecode.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"JSHeapBroker\",\n                \"Zone\",\n                \"NativeContextRef\",\n                \"SharedFunctionInfoRef\",\n                \"BytecodeArrayRef\",\n                \"FeedbackCellRef\",\n                \"BytecodeOffset\",\n                \"JSGraph\",\n                \"CallFrequency\",\n                \"SourcePositionTable\",\n                \"NodeOriginTable\",\n                \"CodeKind\",\n                \"BytecodeGraphBuilderFlags\",\n                \"TickCounter\",\n                \"ObserveNodeInfo\",\n                \"Environment\",\n                \"OsrIteratorState\",\n                \"BytecodePositionDecorator\",\n                \"SubEnvironment\",\n                \"Node\",\n                \"Operator\",\n                \"interpreter::Register\",\n                \"FeedbackSource\",\n                \"JSTypeHintLowering\",\n                \"FrameStateFunctionInfo\",\n                \"BytecodeAnalysis\",\n                \"ObjectRef\",\n                \"NameRef\",\n                \"StringRef\",\n                \"ArrayBoilerplateDescriptionRef\",\n                \"ObjectBoilerplateDescriptionRef\",\n                \"CodeRef\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass BytecodeGraphBuilder {\n public:\n  BytecodeGraphBuilder(\n      JSHeapBroker* broker, Zone* local_zone, NativeContextRef native_context,\n      SharedFunctionInfoRef shared_info, BytecodeArrayRef bytecode,\n      FeedbackCellRef feedback_cell, BytecodeOffset osr_offset,\n      JSGraph* jsgraph, CallFrequency const& invocation_frequency,\n      SourcePositionTable* source_positions, NodeOriginTable* node_origins,\n      int inlining_id, CodeKind code_kind, BytecodeGraphBuilderFlags flags,\n      TickCounter* tick_counter, ObserveNodeInfo const& observe_node_info);\n\n  BytecodeGraphBuilder(const BytecodeGraphBuilder&) = delete;\n  BytecodeGraphBuilder& operator=(const BytecodeGraphBuilder&) = delete;\n\n  // Creates a graph by visiting bytecodes.\n  void CreateGraph();\n\n private:\n  class Environment;\n  class OsrIteratorState;\n  class BytecodePositionDecorator;\n  struct SubEnvironment;\n\n  void RemoveMergeEnvironmentsBeforeOffset(int limit_offset);\n  void AdvanceToOsrEntryAndPeelLoops();\n\n  // Advance {bytecode_iterator} to the given offset. If possible, also advance\n  // {source_position_iterator} while updating the source position table.\n  void AdvanceIteratorsTo(int bytecode_offset);\n\n  void VisitSingleBytecode();\n  void VisitBytecodes();\n\n  void AddBytecodePositionDecorator();\n  void RemoveBytecodePositionDecorator();\n\n  // Get or create the node that represents the outer function closure.\n  Node* GetFunctionClosure();\n\n  // Get or create the node for this parameter index. If such a node is\n  // already cached, it is returned directly and the {debug_name_hint} is\n  // ignored.\n  Node* GetParameter(int index, const char* debug_name_hint = nullptr);\n\n  CodeKind code_kind() const { return code_kind_; }\n\n  // The node representing the current feedback vector is generated once prior\n  // to visiting bytecodes, and is later passed as input to other nodes that\n  // may need it.\n  // TODO(jgruber): Remove feedback_vector() and rename feedback_vector_node()\n  // to feedback_vector() once all uses of the direct heap object reference\n  // have been replaced with a Node* reference.\n  void CreateFeedbackVectorNode();\n  Node* feedback_vector_node() const {\n    DCHECK_NOT_NULL(feedback_vector_node_);\n    return feedback_vector_node_;\n  }\n\n  // Same as above for the feedback vector node.\n  void CreateNativeContextNode();\n  Node* native_context_node() const {\n    DCHECK_NOT_NULL(native_context_node_);\n    return native_context_node_;\n  }\n\n  Node* BuildLoadFeedbackCell(int index);\n\n  // Builder for loading a native context field.\n  Node* BuildLoadNativeContextField(int index);\n\n  // Helper function for creating a feedback source containing type feedback\n  // vector and a feedback slot.\n  FeedbackSource CreateFeedbackSource(int slot_id);\n  FeedbackSource CreateFeedbackSource(FeedbackSlot slot);\n\n  void set_environment(Environment* env) { environment_ = env; }\n  const Environment* environment() const { return environment_; }\n  Environment* environment() { return environment_; }\n\n  // Node creation helpers\n  Node* NewNode(const Operator* op, bool incomplete = false) {\n    return MakeNode(op, 0, static_cast<Node**>(nullptr), incomplete);\n  }\n\n  template <class... Args>\n  Node* NewNode(const Operator* op, Node* n0, Args... nodes) {\n    Node* buffer[] = {n0, nodes...};\n    return MakeNode(op, arraysize(buffer), buffer);\n  }\n\n  // Helpers to create new control nodes.\n  Node* NewIfTrue() { return NewNode(common()->IfTrue()); }\n  Node* NewIfFalse() { return NewNode(common()->IfFalse()); }\n  Node* NewIfValue(int32_t value) { return NewNode(common()->IfValue(value)); }\n  Node* NewIfDefault() { return NewNode(common()->IfDefault()); }\n  Node* NewMerge() { return NewNode(common()->Merge(1), true); }\n  Node* NewLoop() { return NewNode(common()->Loop(1), true); }\n  Node* NewBranch(Node* condition, BranchHint hint = BranchHint::kNone) {\n    return NewNode(common()->Branch(hint), condition);\n  }\n  Node* NewSwitch(Node* condition, int control_output_count) {\n    return NewNode(common()->Switch(control_output_count), condition);\n  }\n\n  // Creates a new Phi node having {count} input values.\n  Node* NewPhi(int count, Node* input, Node* control);\n  Node* NewEffectPhi(int count, Node* input, Node* control);\n\n  // Helpers for merging control, effect or value dependencies.\n  Node* MergeControl(Node* control, Node* other);\n  Node* MergeEffect(Node* effect, Node* other_effect, Node* control);\n  Node* MergeValue(Node* value, Node* other_value, Node* control);\n\n  // The main node creation chokepoint. Adds context, frame state, effect,\n  // and control dependencies depending on the operator.\n  Node* MakeNode(const Operator* op, int value_input_count,\n                 Node* const* value_inputs, bool incomplete = false);\n\n  Node** EnsureInputBufferSize(int size);\n\n  Node* const* GetCallArgumentsFromRegisters(Node* callee, Node* receiver,\n                                              interpreter::Register first_arg,\n                                              int arg_count);\n  Node* const* ProcessCallVarArgs(ConvertReceiverMode receiver_mode,\n                                  Node* callee, interpreter::Register first_reg,\n                                  int arg_count);\n  Node* const* GetConstructArgumentsFromRegister(\n      Node* target, Node* new_target, interpreter::Register first_arg,\n      int arg_count);\n  Node* ProcessCallRuntimeArguments(const Operator* call_runtime_op,\n                                    interpreter::Register receiver,\n                                    size_t reg_count);\n\n  // Prepare information for eager deoptimization. This information is carried\n  // by dedicated {Checkpoint} nodes that are wired into the effect chain.\n  // Conceptually this frame state is \"before\" a given operation.\n  void PrepareEagerCheckpoint();\n\n  // Prepare information for lazy deoptimization. This information is attached\n  // to the given node and the output value produced by the node is combined.\n  //\n  // The low-level chokepoint - use the variants below instead.\n  void PrepareFrameState(Node* node, OutputFrameStateCombine combine,\n                         BytecodeOffset bailout_id,\n                         const BytecodeLivenessState* liveness);\n\n  // In the common case, frame states are conceptually \"after\" a given\n  // operation and at the current bytecode offset.\n  void PrepareFrameState(Node* node, OutputFrameStateCombine combine) {\n    if (!OperatorProperties::HasFrameStateInput(node->op())) return;\n    const int offset = bytecode_iterator().current_offset();\n    return PrepareFrameState(node, combine, BytecodeOffset(offset),\n                             bytecode_analysis().GetOutLivenessFor(offset));\n  }\n\n  // For function-entry stack checks, they're conceptually \"before\" the first\n  // bytecode and at a special marker bytecode offset.\n  // In the case of FE stack checks, the current bytecode is also the first\n  // bytecode, so we use a special marker bytecode offset to signify a virtual\n  // bytecode before the first physical bytecode.\n  void PrepareFrameStateForFunctionEntryStackCheck(Node* node) {\n    DCHECK_EQ(bytecode_iterator().current_offset(), 0);\n    DCHECK(OperatorProperties::HasFrameStateInput(node->op()));\n    DCHECK(node->opcode() == IrOpcode::kJSStackCheck);\n    return PrepareFrameState(node, OutputFrameStateCombine::Ignore(),\n                             BytecodeOffset(kFunctionEntryBytecodeOffset),\n                             bytecode_analysis().GetInLivenessFor(0));\n  }\n\n  // For OSR-entry stack checks, they're conceptually \"before\" the first\n  // bytecode of the current loop. We implement this in a similar manner to\n  // function-entry (FE) stack checks above, i.e. we deopt at the predecessor\n  // of the current bytecode.\n  // In the case of OSR-entry stack checks, a physical predecessor bytecode\n  // exists: the JumpLoop bytecode. We attach to JumpLoop by using\n  // `bytecode_analysis().osr_bailout_id()` instead of current_offset (the\n  // former points at JumpLoop, the latter at the loop header, i.e. the target\n  // of JumpLoop).\n  void PrepareFrameStateForOSREntryStackCheck(Node* node) {\n    DCHECK(OperatorProperties::HasFrameStateInput(node->op()));\n    DCHECK(node->opcode() == IrOpcode::kJSStackCheck);\n    const int offset = bytecode_analysis().osr_bailout_id().ToInt();\n    return PrepareFrameState(node, OutputFrameStateCombine::Ignore(),\n                             BytecodeOffset(offset),\n                             bytecode_analysis().GetOutLivenessFor(offset));\n  }\n\n  void BuildCreateArguments(CreateArgumentsType type);\n  Node* BuildLoadGlobal(NameRef name, uint32_t feedback_slot_index,\n                        TypeofMode typeof_mode);\n\n  enum class NamedStoreMode {\n    // Check the prototype chain before storing.\n    kSet,\n    // Define value to the receiver without checking the prototype chain.\n    kDefineOwn,\n  };\n  void BuildNamedStore(NamedStoreMode store_mode);\n  void BuildLdaLookupSlot(TypeofMode typeof_mode);\n  void BuildLdaLookupContextSlot(ContextKind context_kind,\n                                 TypeofMode typeof_mode);\n  void BuildLdaLookupGlobalSlot(TypeofMode typeof_mode);\n  void BuildCallVarArgs(ConvertReceiverMode receiver_mode);\n  void BuildCall(ConvertReceiverMode receiver_mode, Node* const* args,\n                 size_t arg_count, int slot_id);\n  void BuildCall(ConvertReceiverMode receiver_mode,\n                 std::initializer_list<Node*> args, int slot_id) {\n    BuildCall(receiver_mode, args.begin(), args.size(), slot_id);\n  }\n  void BuildUnaryOp(const Operator* op);\n  void BuildBinaryOp(const Operator* op);\n  void BuildBinaryOpWithImmediate(const Operator* op);\n  void BuildCompareOp(const Operator* op);\n  void BuildDelete(LanguageMode language_mode);\n  void BuildCastOperator(const Operator* op);\n  void BuildHoleCheckAndThrow(Node* condition, Runtime::FunctionId runtime_id,\n                              Node* name = nullptr);\n\n  // Optional early lowering to the simplified operator level.  Note that\n  // the result has already been wired into the environment just like\n  // any other invocation of {NewNode} would do.\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedUnaryOp(\n      const Operator* op, Node* operand, FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedBinaryOp(\n      const Operator* op, Node* left, Node* right, FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedForInNext(\n      Node* receiver, Node* cache_array, Node* cache_type, Node* index,\n      FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedForInPrepare(\n      Node* receiver, FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedToNumber(\n      Node* input, FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedCall(const Operator* op,\n                                                            Node* const* args,\n                                                            int arg_count,\n                                                            FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedConstruct(\n      const Operator* op, Node* const* args, int arg_count, FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedGetIterator(\n      const Operator* op, Node* receiver, FeedbackSlot load_slot,\n      FeedbackSlot call_slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedLoadNamed(\n      const Operator* op, FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedLoadKeyed(\n      const Operator* op, Node* receiver, Node* key, FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedStoreNamed(\n      const Operator* op, Node* receiver, Node* value, FeedbackSlot slot);\n  JSTypeHintLowering::LoweringResult TryBuildSimplifiedStoreKeyed(\n      const Operator* op, Node* receiver, Node* key, Node* value,\n      FeedbackSlot slot);\n\n  // Applies the given early reduction onto the current environment.\n  void ApplyEarlyReduction(JSTypeHintLowering::LoweringResult reduction);\n\n  // Check the context chain for extensions, for lookup fast paths.\n  Environment* CheckContextExtensions(uint32_t depth);\n  // Slow path taken when we cannot figure out the current scope info.\n  Environment* CheckContextExtensionsSlowPath(uint32_t depth);\n  // Helper function that tries to get the current scope info.\n  OptionalScopeInfoRef TryGetScopeInfo();\n  // Helper function to create a context extension check.\n  Environment* CheckContextExtensionAtDepth(Environment* slow_environment,\n                                            uint32_t depth);\n\n  // Helper function to create for-in mode from the recorded type feedback.\n  ForInMode GetForInMode(FeedbackSlot slot);\n\n  // Helper function to compute call frequency from the recorded type\n  // feedback. Returns unknown if invocation count is unknown. Returns 0 if\n  // feedback is insufficient.\n  CallFrequency ComputeCallFrequency(int slot_id) const;\n\n  // Helper function to extract the speculation mode from the recorded type\n  // feedback. Returns kDisallowSpeculation if feedback is insufficient.\n  SpeculationMode GetSpeculationMode(int slot_id) const;\n\n  // Helper function to determine the call feedback relation from the recorded\n  // type feedback. Returns kUnrelated if feedback is insufficient.\n  CallFeedbackRelation ComputeCallFeedbackRelation(int slot_id) const;\n\n  // Helpers for building the implicit FunctionEntry and IterationBody\n  // StackChecks.\n  void BuildFunctionEntryStackCheck();\n  void BuildIterationBodyStackCheck();\n  void BuildOSREntryStackCheck();\n\n  // Control flow plumbing.\n  void BuildJump();\n  void BuildJumpIf(Node* condition);\n  void BuildJumpIfNot(Node* condition);\n  void BuildJumpIfEqual(Node* comperand);\n  void BuildJumpIfNotEqual(Node* comperand);\n  void BuildJumpIfTrue();\n  void BuildJumpIfFalse();\n  void BuildJumpIfToBooleanTrue();\n  void BuildJumpIfToBooleanFalse();\n  void BuildJumpIfNotHole();\n  void BuildJumpIfJSReceiver();\n  void BuildJumpIfForInDone();\n\n  void BuildSwitchOnSmi(Node* condition);\n  void BuildSwitchOnGeneratorState(\n      const ZoneVector<ResumeJumpTarget>& resume_jump_targets,\n      bool allow_fallthrough_on_executing);\n\n  // Simulates control flow by forward-propagating environments.\n  void MergeIntoSuccessorEnvironment(int target_offset);\n  void BuildLoopHeaderEnvironment(int current_offset);\n  void SwitchToMergeEnvironment(int current_offset);\n\n  // Simulates control flow that exits the function body.\n  void MergeControlToLeaveFunction(Node* exit);\n\n  // Builds loop exit nodes for every exited loop between the current bytecode\n  // offset and {target_offset}.\n  void BuildLoopExitsForBranch(int target_offset);\n  void BuildLoopExitsForFunctionExit(const BytecodeLivenessState* liveness);\n  void BuildLoopExitsUntilLoop(int loop_offset,\n                               const BytecodeLivenessState* liveness);\n\n  // Helper for building a return (from an actual return or a suspend).\n  void BuildReturn(const BytecodeLivenessState* liveness);\n\n  // Simulates entry and exit of exception handlers.\n  void ExitThenEnterExceptionHandlers(int current_offset);\n\n  // Update the current position of {SourcePositionTable} and\n  // {NodeOriginTable} to that bytecode at {offset}, if any.\n  void UpdateSourceAndBytecodePosition(int offset);\n\n  // Growth increment for the temporary buffer used to construct input lists to\n  // new nodes.\n  static const int kInputBufferSizeIncrement = 64;\n\n  // An abstract representation for an exception handler that is being\n  // entered and exited while the graph builder is iterating over the\n  // underlying bytecode. The exception handlers within the bytecode are\n  // well scoped, hence will form a stack during iteration.\n  struct ExceptionHandler {\n    int start_offset_;      // Start offset of the handled area in the bytecode.\n    int end_offset_;        // End offset of the handled area in the bytecode.\n    int handler_offset_;    // Handler entry offset within the bytecode.\n    int context_register_;  // Index of register holding handler context.\n  };\n\n  template <class T = Object>\n  typename ref_traits<T>::ref_type MakeRefForConstantForIndexOperand(\n      int operand_index) {\n    // The BytecodeArray itself was fetched by using a barrier so all reads\n    // from the constant pool are safe.\n    return MakeRefAssumeMemoryFence(\n        broker(), broker()->CanonicalPersistentHandle(\n                      Cast<T>(bytecode_iterator().GetConstantForIndexOperand(\n                          operand_index, local_isolate_))));\n  }\n\n  TFGraph* graph() const { return jsgraph_->graph(); }\n  CommonOperatorBuilder* common() const { return jsgraph_->common(); }\n  Zone* graph_zone() const { return graph()->zone(); }\n  JSGraph* jsgraph() const { return jsgraph_; }\n  Isolate* isolate() const { return jsgraph_->isolate(); }\n  JSOperatorBuilder* javascript() const { return jsgraph_->javascript(); }\n  SimplifiedOperatorBuilder* simplified() const {\n    return jsgraph_->simplified();\n  }\n  Zone* local_zone() const { return local_zone_; }\n  BytecodeArrayRef bytecode_array() const { return bytecode_array_; }\n  FeedbackVectorRef feedback_vector() const { return feedback_vector_; }\n  const JSTypeHintLowering& type_hint_lowering() const {\n    return type_hint_lowering_;\n  }\n  const FrameStateFunctionInfo* frame_state_function_info() const {\n    return frame_state_function_info_;\n  }\n  SourcePositionTableIterator& source_position_iterator() {\n    return source_position_iterator_;\n  }\n  interpreter::BytecodeArrayIterator const& bytecode_iterator() const {\n    return bytecode_iterator_;\n  }\n  interpreter::BytecodeArrayIterator& bytecode_iterator() {\n    return bytecode_iterator_;\n  }\n  BytecodeAnalysis const& bytecode_analysis() const {\n    return bytecode_analysis_;\n  }\n  int currently_peeled_loop_offset() const {\n    return currently_peeled_loop_offset_;\n  }\n  void set_currently_peeled_loop_offset(int offset) {\n    currently_peeled_loop_offset_ = offset;\n  }\n  bool skip_first_stack_check() const {\n    return skip_first_stack_and_tierup_check_;\n  }\n  bool skip_tierup_check() const {\n    return skip_first_stack_and_tierup_check_ || osr_;\n  }\n  int current_exception_handler() const { return current_exception_handler_; }\n  void set_current_exception_handler(int index) {\n    current_exception_handler_ = index;\n  }\n  bool needs_eager_checkpoint() const { return needs_eager_checkpoint_; }\n  void mark_as_needing_eager_checkpoint(bool value) {\n    needs_eager_checkpoint_ = value;\n  }\n  JSHeapBroker* broker() const { return broker_; }\n  NativeContextRef native_context() const { return native_context_; }\n  SharedFunctionInfoRef shared_info() const { return shared_info_; }\n\n#define DECLARE_VISIT_BYTECODE(name, ...) void Visit##name();\n  BYTECODE_LIST(DECLARE_VISIT_BYTECODE, DECLARE_VISIT_BYTECODE)\n#undef DECLARE_VISIT_BYTECODE\n\n  JSHeapBroker* const broker_;\n  LocalIsolate* const local_isolate_;\n  Zone* const local_zone_;\n  JSGraph* const jsgraph_;\n  // The native context for which we optimize.\n  NativeContextRef const native_context_;\n  SharedFunctionInfoRef const shared_info_;\n  BytecodeArrayRef const bytecode_array_;\n  FeedbackCellRef const feedback_cell_;\n  FeedbackVectorRef const feedback_vector_;\n  CallFrequency const invocation_frequency_;\n  JSTypeHintLowering const type_hint_lowering_;\n  const FrameStateFunctionInfo* const frame_state_function_info_;\n  SourcePositionTableIterator source_position_iterator_;\n  interpreter::BytecodeArrayIterator bytecode_iterator_;\n  BytecodeAnalysis const bytecode_analysis_;\n  Environment* environment_;\n  BytecodePositionDecorator* decorator_;\n  bool const osr_;\n  int currently_peeled_loop_offset_;\n\n  const bool skip_first_stack_and_tierup_check_;\n\n  // Merge environments are snapshots of the environment at points where the\n  // control flow merges. This models a forward data flow propagation of all\n  // values from all predecessors of the merge in question. They are indexed by\n  // the bytecode offset\n  ZoneMap<int, Environment*> merge_environments_;\n\n  // Generator merge environments are snapshots of the current resume\n  // environment, tracing back through loop headers to the resume switch of a\n  // generator. They allow us to model a single resume jump as several switch\n  // statements across loop headers, keeping those loop headers reducible,\n  // without having to merge the \"executing\" environments of the generator into\n  // the \"resuming\" ones. They are indexed by the suspend id of the resume.\n  ZoneMap<int, Environment*> generator_merge_environments_;\n\n  ZoneVector<Node*> cached_parameters_;\n\n  // Exception handlers currently entered by the iteration.\n  ZoneStack<ExceptionHandler> exception_handlers_;\n  int current_exception_handler_;\n\n  // Temporary storage for building node input lists.\n  int input_buffer_size_;\n  Node** input_buffer_;\n\n  const CodeKind code_kind_;\n  Node* feedback_vector_node_;\n  Node* native_context_node_;\n\n  // Optimization to only create checkpoints when the current position in the\n  // control-flow is not effect-dominated by another checkpoint already. All\n  // operations that do not have observable side-effects can be re-evaluated.\n  bool needs_eager_checkpoint_;\n\n  // Nodes representing values in the activation record.\n  SetOncePointer<Node> function_closure_;\n\n  // Control nodes that exit the function body.\n  ZoneVector<Node*> exit_controls_;\n\n  StateValuesCache state_values_cache_;\n\n  // The node origins table, to store bytecode origins.\n  NodeOriginTable* const node_origins_;\n\n  // The source position table, to be populated.\n  SourcePositionTable* const source_positions_;\n\n  SourcePosition const start_position_;\n\n  TickCounter* const tick_counter_;\n\n  ObserveNodeInfo const observe_node_info_;\n\n  static constexpr int kBinaryOperationHintIndex = 1;\n  static constexpr int kBinaryOperationSmiHintIndex = 1;\n  static constexpr int kCompareOperationHintIndex = 1;\n  static constexpr int kCountOperationHintIndex = 0;\n  static constexpr int kUnaryOperationHintIndex = 0;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Environment\",\n            \"about\": \"Represents the abstract execution environment, simulating the interpreter's register file and performing SSA-renaming.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"BytecodeGraphBuilder\",\n                \"Node\",\n                \"interpreter::Register\",\n                \"BytecodeOffset\",\n                \"BytecodeLivenessState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// The abstract execution environment simulates the content of the interpreter\n// register file. The environment performs SSA-renaming of all tracked nodes at\n// split and merge points in the control flow.\nclass BytecodeGraphBuilder::Environment : public ZoneObject {\n public:\n  Environment(BytecodeGraphBuilder* builder, int register_count,\n              int parameter_count,\n              interpreter::Register incoming_new_target_or_generator,\n              Node* control_dependency);\n\n  // Specifies whether environment binding methods should attach frame state\n  // inputs to nodes representing the value being bound. This is done because\n  // the {OutputFrameStateCombine} is closely related to the binding method.\n  enum FrameStateAttachmentMode { kAttachFrameState, kDontAttachFrameState };\n\n  int parameter_count() const { return parameter_count_; }\n  int register_count() const { return register_count_; }\n\n  Node* LookupAccumulator() const;\n  Node* LookupRegister(interpreter::Register the_register) const;\n  Node* LookupGeneratorState() const;\n\n  void BindAccumulator(Node* node,\n                       FrameStateAttachmentMode mode = kDontAttachFrameState);\n  void BindRegister(interpreter::Register the_register, Node* node,\n                    FrameStateAttachmentMode mode = kDontAttachFrameState);\n  void BindRegistersToProjections(\n      interpreter::Register first_reg, Node* node,\n      FrameStateAttachmentMode mode = kDontAttachFrameState);\n  void BindGeneratorState(Node* node);\n  void RecordAfterState(Node* node,\n                        FrameStateAttachmentMode mode = kDontAttachFrameState);\n\n  // Effect dependency tracked by this environment.\n  Node* GetEffectDependency() { return effect_dependency_; }\n  void UpdateEffectDependency(Node* dependency) {\n    effect_dependency_ = dependency;\n  }\n\n  // Preserve a checkpoint of the environment for the IR graph. Any\n  // further mutation of the environment will not affect checkpoints.\n  Node* Checkpoint(BytecodeOffset bytecode_offset,\n                   OutputFrameStateCombine combine,\n                   const BytecodeLivenessState* liveness);\n\n  // Control dependency tracked by this environment.\n  Node* GetControlDependency() const { return control_dependency_; }\n  void UpdateControlDependency(Node* dependency) {\n    control_dependency_ = dependency;\n  }\n\n  Node* Context() const { return context_; }\n  void SetContext(Node* new_context) { context_ = new_context; }\n\n  Environment* Copy();\n  void Merge(Environment* other, const BytecodeLivenessState* liveness);\n\n  void FillWithOsrValues();\n  void PrepareForLoop(const BytecodeLoopAssignments& assignments,\n                      const BytecodeLivenessState* liveness);\n  void PrepareForLoopExit(Node* loop,\n                          const BytecodeLoopAssignments& assignments,\n                          const BytecodeLivenessState* liveness);\n\n private:\n  friend Zone;\n\n  explicit Environment(const Environment* copy);\n\n  bool StateValuesRequireUpdate(Node** state_values, Node** values, int count);\n  void UpdateStateValues(Node** state_values, Node** values, int count);\n  Node* GetStateValuesFromCache(Node** values, int count,\n                                const BytecodeLivenessState* liveness);\n\n  int RegisterToValuesIndex(interpreter::Register the_register) const;\n\n  Zone* zone() const { return builder_->local_zone(); }\n  TFGraph* graph() const { return builder_->graph(); }\n  CommonOperatorBuilder* common() const { return builder_->common(); }\n  BytecodeGraphBuilder* builder() const { return builder_; }\n  const NodeVector* values() const { return &values_; }\n  NodeVector* values() { return &values_; }\n  int register_base() const { return register_base_; }\n  int accumulator_base() const { return accumulator_base_; }\n\n  BytecodeGraphBuilder* builder_;\n  int register_count_;\n  int parameter_count_;\n  Node* context_;\n  Node* control_dependency_;\n  Node* effect_dependency_;\n  NodeVector values_;\n  Node* parameters_state_values_;\n  Node* generator_state_;\n  int register_base_;\n  int accumulator_base_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SubEnvironment\",\n            \"about\": \"A helper struct for creating temporary sub-environments for simple branches.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"BytecodeGraphBuilder\",\n                \"Environment\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// A helper for creating a temporary sub-environment for simple branches.\nstruct BytecodeGraphBuilder::SubEnvironment final {\n public:\n  explicit SubEnvironment(BytecodeGraphBuilder* builder)\n      : builder_(builder), parent_(builder->environment()->Copy()) {}\n\n  ~SubEnvironment() { builder_->set_environment(parent_); }\n\n private:\n  BytecodeGraphBuilder* builder_;\n  BytecodeGraphBuilder::Environment* parent_;\n};\n        ]]></code>\n    </class>\n\n   <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BytecodeGraphBuilder\",\n            \"parent\": \"BytecodeGraphBuilder\",\n            \"about\": \"The constructor for the BytecodeGraphBuilder class.\",\n            \"logic\": \"Initializes the BytecodeGraphBuilder with necessary components like JSHeapBroker, Zone, and bytecode information. Sets up the graph and iterators.\",\n            \"parameters\": [\n                {\n                    \"name\": \"broker\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"purpose\": \"The JSHeapBroker for accessing heap objects.\"\n                },\n                {\n                    \"name\": \"local_zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The local Zone for memory allocation.\"\n                },\n                {\n                    \"name\": \"native_context\",\n                    \"type\": \"NativeContextRef\",\n                    \"purpose\": \"A reference to the native context.\"\n                },\n                {\n                    \"name\": \"shared_info\",\n                    \"type\": \"SharedFunctionInfoRef\",\n                    \"purpose\": \"A reference to the shared function information.\"\n                },\n                {\n                    \"name\": \"bytecode\",\n                    \"type\": \"BytecodeArrayRef\",\n                    \"purpose\": \"A reference to the bytecode array.\"\n                },\n                {\n                    \"name\": \"feedback_cell\",\n                    \"type\": \"FeedbackCellRef\",\n                    \"purpose\": \"A reference to the feedback cell.\"\n                },\n                {\n                    \"name\": \"osr_offset\",\n                    \"type\": \"BytecodeOffset\",\n                    \"purpose\": \"The offset for on-stack replacement (OSR).\"\n                },\n                {\n                    \"name"
}