{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/code-serializer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/code-serializer.cc\",\n        \"file_name\": \"code-serializer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements code serialization and deserialization for V8's code caching.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for code serialization, memory management, logging, and V8 specific objects.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/snapshot/code-serializer.h\"\n\n            #include <memory>\n\n            #include \"src/base/logging.h\"\n            #include \"src/base/platform/elapsed-timer.h\"\n            #include \"src/base/platform/platform.h\"\n            #include \"src/baseline/baseline-batch-compiler.h\"\n            #include \"src/codegen/background-merge-task.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/handles/maybe-handles.h\"\n            #include \"src/handles/persistent-handles.h\"\n            #include \"src/heap/heap-inl.h\"\n            #include \"src/heap/parked-scope.h\"\n            #include \"src/logging/counters-scopes.h\"\n            #include \"src/logging/log.h\"\n            #include \"src/logging/runtime-call-stats-scope.h\"\n            #include \"src/objects/objects-inl.h\"\n            #include \"src/objects/shared-function-info.h\"\n            #include \"src/objects/slots.h\"\n            #include \"src/objects/visitors.h\"\n            #include \"src/snapshot/object-deserializer.h\"\n            #include \"src/snapshot/snapshot-utils.h\"\n            #include \"src/snapshot/snapshot.h\"\n            #include \"src/utils/version.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AlignedCachedData\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents cached data that is aligned in memory.  Ensures data is properly aligned and handles cases where alignment is not initially guaranteed.\",\n            \"attributes\": [\n                {\n                    \"name\": \"owns_data_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the AlignedCachedData object owns the underlying data buffer.\"\n                },\n                {\n                    \"name\": \"rejected_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the cached data has been rejected due to a sanity check failure.\"\n                },\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"const uint8_t*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the start of the data.\"\n                },\n                {\n                    \"name\": \"length_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Length of the data in bytes.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            AlignedCachedData::AlignedCachedData(const uint8_t* data, int length)\n                : owns_data_(false), rejected_(false), data_(data), length_(length) {\n              if (!IsAligned(reinterpret_cast<intptr_t>(data), kPointerAlignment)) {\n                uint8_t* copy = NewArray<uint8_t>(length);\n                DCHECK(IsAligned(reinterpret_cast<intptr_t>(copy), kPointerAlignment));\n                CopyBytes(copy, data, length);\n                data_ = copy;\n                AcquireDataOwnership();\n              }\n            }\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CodeSerializer\",\n            \"extends\": \"Serializer\",\n            \"implements\": [],\n            \"about\": \"Serializes SharedFunctionInfo objects for code caching.\",\n            \"attributes\": [\n                {\n                    \"name\": \"source_hash_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Hash of the source code being serialized. Used for integrity checks during deserialization.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Serializer\",\n                \"SharedFunctionInfo\",\n                \"ScriptCompiler::CachedData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            CodeSerializer::CodeSerializer(Isolate* isolate, uint32_t source_hash)\n                : Serializer(isolate, Snapshot::kDefaultSerializerFlags),\n                  source_hash_(source_hash) {}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Serialize\",\n            \"parent\": \"CodeSerializer\",\n            \"about\": \"Serializes a SharedFunctionInfo object into a ScriptCompiler::CachedData object.\",\n            \"logic\": \"Creates a CodeSerializer, visits the SharedFunctionInfo object to serialize it, and returns the serialized data as a ScriptCompiler::CachedData.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"info\",\n                    \"type\": \"Handle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo object to serialize.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ScriptCompiler::CachedData*\",\n                \"description\": \"The serialized code data, or nullptr if serialization fails (e.g., due to Asm.js module).\"\n            },\n            \"dependencies\": [\n                \"CodeSerializer\",\n                \"AlignedCachedData\",\n                \"SharedFunctionInfo\",\n                \"ScriptCompiler::CachedData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // static\n            ScriptCompiler::CachedData* CodeSerializer::Serialize(\n                Isolate* isolate, Handle<SharedFunctionInfo> info) {\n              TRACE_EVENT_CALL_STATS_SCOPED(isolate, \"v8\", \"V8.SerializeCode\");\n              NestedTimedHistogramScope histogram_timer(\n                  isolate->counters()->compile_serialize());\n              RCS_SCOPE(isolate, RuntimeCallCounterId::kCompileSerialize);\n              TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.compile\"), \"V8.CompileSerialize\");\n\n              base::ElapsedTimer timer;\n              if (v8_flags.profile_deserialization) timer.Start();\n              DirectHandle<Script> script(Cast<Script>(info->script()), isolate);\n              if (v8_flags.trace_serializer) {\n                PrintF(\"[Serializing from\");\n                ShortPrint(script->name());\n                PrintF(\"]\\n\");\n              }\n            #if V8_ENABLE_WEBASSEMBLY\n              // TODO(7110): Enable serialization of Asm modules once the AsmWasmData is\n              // context independent.\n              if (script->ContainsAsmModule()) return nullptr;\n            #endif  // V8_ENABLE_WEBASSEMBLY\n\n              // Serialize code object.\n              DirectHandle<String> source(Cast<String>(script->source()), isolate);\n              DirectHandle<FixedArray> wrapped_arguments;\n              if (script->is_wrapped()) {\n                wrapped_arguments =\n                    DirectHandle<FixedArray>(script->wrapped_arguments(), isolate);\n              }\n\n              HandleScope scope(isolate);\n              CodeSerializer cs(isolate,\n                                SerializedCodeData::SourceHash(source, wrapped_arguments,\n                                                               script->origin_options()));\n              DisallowGarbageCollection no_gc;\n\n            #ifndef DEBUG\n              cs.reference_map()->AddAttachedReference(*source);\n            #endif\n              AlignedCachedData* cached_data = cs.SerializeSharedFunctionInfo(info);\n\n              if (v8_flags.profile_deserialization) {\n                double ms = timer.Elapsed().InMillisecondsF();\n                int length = cached_data->length();\n                PrintF(\"[Serializing to %d bytes took %0.3f ms]\\n\", length, ms);\n              }\n\n              ScriptCompiler::CachedData* result =\n                  new ScriptCompiler::CachedData(cached_data->data(), cached_data->length(),\n                                                 ScriptCompiler::CachedData::BufferOwned);\n              cached_data->ReleaseDataOwnership();\n              delete cached_data;\n\n              return result;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SerializeSharedFunctionInfo\",\n            \"parent\": \"CodeSerializer\",\n            \"about\": \"Serializes a SharedFunctionInfo object to a data buffer.\",\n            \"logic\": \"Visits the root pointer of the SharedFunctionInfo and then serializes deferred objects. Returns the data as an AlignedCachedData object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"Handle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo object to serialize.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AlignedCachedData*\",\n                \"description\": \"The serialized code data as an AlignedCachedData object.\"\n            },\n            \"dependencies\": [\n                \"AlignedCachedData\",\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            AlignedCachedData* CodeSerializer::SerializeSharedFunctionInfo(\n                Handle<SharedFunctionInfo> info) {\n              DisallowGarbageCollection no_gc;\n\n              VisitRootPointer(Root::kHandleScope, nullptr,\n                               FullObjectSlot(info.location()));\n              SerializeDeferredObjects();\n              Pad();\n\n              SerializedCodeData data(sink_.data(), this);\n\n              return data.GetScriptData();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SerializeObjectImpl\",\n            \"parent\": \"CodeSerializer\",\n            \"about\": \"Implementation of serializing a heap object, handling different object types specially.\",\n            \"logic\": \"Handles various object types differently during serialization, including Scripts, SharedFunctionInfos, and ScopeInfos.  It checks for hot objects, root objects, and back references before proceeding with generic serialization.\",\n            \"parameters\": [\n                {\n                    \"name\": \"obj\",\n                    \"type\": \"Handle<HeapObject>\",\n                    \"purpose\": \"The heap object to serialize.\"\n                },\n                {\n                    \"name\": \"slot_type\",\n                    \"type\": \"SlotType\",\n                    \"purpose\": \"The type of the slot where the object is located.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"HeapObject\",\n                \"Script\",\n                \"SharedFunctionInfo\",\n                \"ScopeInfo\",\n                \"InterpreterData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CodeSerializer::SerializeObjectImpl(Handle<HeapObject> obj,\n                                                     SlotType slot_type) {\n              ReadOnlyRoots roots(isolate());\n              InstanceType instance_type;\n              {\n                DisallowGarbageCollection no_gc;\n                Tagged<HeapObject> raw = *obj;\n                if (SerializeHotObject(raw)) return;\n                if (SerializeRoot(raw)) return;\n                if (SerializeBackReference(raw)) return;\n                if (SerializeReadOnlyObjectReference(raw, &sink_)) return;\n\n                instance_type = raw->map()->instance_type();\n                CHECK(!InstanceTypeChecker::IsInstructionStream(instance_type));\n              }\n\n              if (InstanceTypeChecker::IsScript(instance_type)) {\n                DirectHandle<FixedArray> host_options;\n                DirectHandle<UnionOf<Smi, Symbol, Undefined>> context_data;\n                {\n                  DisallowGarbageCollection no_gc;\n                  Tagged<Script> script_obj = Cast<Script>(*obj);\n                  DCHECK_NE(script_obj->compilation_type(), Script::CompilationType::kEval);\n                  // We want to differentiate between undefined and uninitialized_symbol for\n                  // context_data for now. It is hack to allow debugging for scripts that\n                  // are included as a part of custom snapshot. (see\n                  // debug::Script::IsEmbedded())\n                  Tagged<UnionOf<Smi, Symbol, Undefined>> raw_context_data =\n                      script_obj->context_data();\n                  if (raw_context_data != roots.undefined_value() &&\n                      raw_context_data != roots.uninitialized_symbol()) {\n                    script_obj->set_context_data(roots.undefined_value());\n                  }\n                  context_data = direct_handle(raw_context_data, isolate());\n                  // We don't want to serialize host options to avoid serializing\n                  // unnecessary object graph.\n                  host_options =\n                      direct_handle(script_obj->host_defined_options(), isolate());\n                  script_obj->set_host_defined_options(roots.empty_fixed_array());\n                }\n                SerializeGeneric(obj, slot_type);\n                {\n                  DisallowGarbageCollection no_gc;\n                  Tagged<Script> script_obj = Cast<Script>(*obj);\n                  script_obj->set_host_defined_options(*host_options);\n                  script_obj->set_context_data(*context_data);\n                }\n                return;\n              } else if (InstanceTypeChecker::IsSharedFunctionInfo(instance_type)) {\n                DirectHandle<DebugInfo> debug_info;\n                CachedTieringDecision cached_tiering_decision;\n                bool restore_bytecode = false;\n                {\n                  DisallowGarbageCollection no_gc;\n                  Tagged<SharedFunctionInfo> sfi = Cast<SharedFunctionInfo>(*obj);\n                  DCHECK(!sfi->IsApiFunction());\n            #if V8_ENABLE_WEBASSEMBLY\n                  // TODO(7110): Enable serializing of Asm modules once the AsmWasmData\n                  // is context independent.\n                  DCHECK(!sfi->HasAsmWasmData());\n            #endif  // V8_ENABLE_WEBASSEMBLY\n\n                  if (auto maybe_debug_info = sfi->TryGetDebugInfo(isolate())) {\n                    debug_info = direct_handle(maybe_debug_info.value(), isolate());\n                    // Clear debug info.\n                    if (debug_info->HasInstrumentedBytecodeArray()) {\n                      restore_bytecode = true;\n                      sfi->SetActiveBytecodeArray(\n                          debug_info->OriginalBytecodeArray(isolate()), isolate());\n                    }\n                  }\n                  if (v8_flags.profile_guided_optimization) {\n                    cached_tiering_decision = sfi->cached_tiering_decision();\n                    if (cached_tiering_decision > CachedTieringDecision::kEarlySparkplug) {\n                      sfi->set_cached_tiering_decision(\n                          CachedTieringDecision::kEarlySparkplug);\n                    }\n                  }\n                }\n                SerializeGeneric(obj, slot_type);\n                DisallowGarbageCollection no_gc;\n                Tagged<SharedFunctionInfo> sfi = Cast<SharedFunctionInfo>(*obj);\n                if (restore_bytecode) {\n                  sfi->SetActiveBytecodeArray(debug_info->DebugBytecodeArray(isolate()),\n                                              isolate());\n                }\n                if (v8_flags.profile_guided_optimization &&\n                    cached_tiering_decision > CachedTieringDecision::kEarlySparkplug) {\n                  sfi->set_cached_tiering_decision(cached_tiering_decision);\n                }\n                return;\n              } else if (InstanceTypeChecker::IsUncompiledDataWithoutPreparseDataWithJob(\n                           instance_type)) {\n                Handle<UncompiledDataWithoutPreparseDataWithJob> data =\n                    Cast<UncompiledDataWithoutPreparseDataWithJob>(obj);\n                Address job = data->job();\n                data->set_job(kNullAddress);\n                SerializeGeneric(data, slot_type);\n                data->set_job(job);\n                return;\n              } else if (InstanceTypeChecker::IsUncompiledDataWithPreparseDataAndJob(\n                           instance_type)) {\n                Handle<UncompiledDataWithPreparseDataAndJob> data =\n                    Cast<UncompiledDataWithPreparseDataAndJob>(obj);\n                Address job = data->job();\n                data->set_job(kNullAddress);\n                SerializeGeneric(data, slot_type);\n                data->set_job(job);\n                return;\n              } else if (InstanceTypeChecker::IsScopeInfo(instance_type)) {\n                // TODO(ishell): define a dedicated instance type for DependentCode and\n                // serialize DependentCode objects as an empty_dependent_code instead\n                // of customizing ScopeInfo serialization.\n                static_assert(DEPENDENT_CODE_TYPE == WEAK_ARRAY_LIST_TYPE);\n                Handle<ScopeInfo> scope_info = Cast<ScopeInfo>(obj);\n                DirectHandle<DependentCode> dependent_code;\n                bool restore_dependent_code = false;\n                if (scope_info->SloppyEvalCanExtendVars()) {\n                  // If |scope_info| has a dependent code field, serialize it as an empty\n                  // dependent code in order to avoid accidental serialization of optimized\n                  // code.\n                  Tagged<DependentCode> empty_dependent_code =\n                      DependentCode::empty_dependent_code(ReadOnlyRoots(isolate()));\n                  if (scope_info->dependent_code() != empty_dependent_code) {\n                    dependent_code = direct_handle(scope_info->dependent_code(), isolate());\n                    restore_dependent_code = true;\n                    scope_info->set_dependent_code(empty_dependent_code);\n                  }\n                }\n                SerializeGeneric(scope_info, slot_type);\n                if (restore_dependent_code) {\n                  scope_info->set_dependent_code(*dependent_code);\n                }\n                return;\n              }\n\n              // NOTE(mmarchini): If we try to serialize an InterpreterData our process\n              // will crash since it stores a code object. Instead, we serialize the\n              // bytecode array stored within the InterpreterData, which is the important\n              // information. On deserialization we'll create our code objects again, if\n              // --interpreted-frames-native-stack is on. See v8:9122 for more context\n              if (V8_UNLIKELY(isolate()->interpreted_frames_native_stack()) &&\n                  IsInterpreterData(*obj)) {\n                obj = handle(Cast<InterpreterData>(*obj)->bytecode_array(), isolate());\n              }\n\n              // Past this point we should not see any (context-specific) maps anymore.\n              CHECK(!InstanceTypeChecker::IsMap(instance_type));\n              // There should be no references to the global object embedded.\n              CHECK(!InstanceTypeChecker::IsJSGlobalProxy(instance_type) &&\n                    !InstanceTypeChecker::IsJSGlobalObject(instance_type));\n              // Embedded FixedArrays that need rehashing must support rehashing.\n              CHECK_IMPLIES(obj->NeedsRehashing(cage_base()),\n                            obj->CanBeRehashed(cage_base()));\n              // We expect no instantiated function objects or contexts.\n              CHECK(!InstanceTypeChecker::IsJSFunction(instance_type) &&\n                    !InstanceTypeChecker::IsContext(instance_type));\n\n              SerializeGeneric(obj, slot_type);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SerializeGeneric\",\n            \"parent\": \"CodeSerializer\",\n            \"about\": \"Serializes a HeapObject using the ObjectSerializer.\",\n            \"logic\": \"Creates an ObjectSerializer and uses it to serialize the given HeapObject.\",\n            \"parameters\": [\n                {\n                    \"name\": \"heap_object\",\n                    \"type\": \"Handle<HeapObject>\",\n                    \"purpose\": \"The HeapObject to serialize.\"\n                },\n                {\n                    \"name\": \"slot_type\",\n                    \"type\": \"SlotType\",\n                    \"purpose\": \"The type of the slot where the object is located.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ObjectSerializer\",\n                \"HeapObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CodeSerializer::SerializeGeneric(Handle<HeapObject> heap_object,\n                                          SlotType slot_type) {\n              // Object has not yet been serialized.  Serialize it here.\n              ObjectSerializer serializer(this, heap_object, &sink_);\n              serializer.Serialize(slot_type);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CreateInterpreterDataForDeserializedCode\",\n            \"parent\": null,\n            \"about\": \"Creates InterpreterData objects for deserialized code when interpreted_frames_native_stack is enabled.\",\n            \"logic\": \"When interpreted frames are on native stack, duplicate InterpreterEntryTrampolines are made for deserialized functions. Iterates through SharedFunctionInfos within a script and creates new InterpreterData objects.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"result_sfi\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo for which to create InterpreterData.\"\n                },\n                {\n                    \"name\": \"log_code_creation\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Flag indicating whether to log code creation events.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"SharedFunctionInfo\",\n                \"Script\",\n                \"BytecodeArray\",\n                \"Code\",\n                \"InterpreterData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n\n            // NOTE(mmarchini): when v8_flags.interpreted_frames_native_stack is on, we want\n            // to create duplicates of InterpreterEntryTrampoline for the deserialized\n            // functions, otherwise we'll call the builtin IET for those functions (which\n            // is not what a user of this flag wants).\n            void CreateInterpreterDataForDeserializedCode(\n                Isolate* isolate, DirectHandle<SharedFunctionInfo> result_sfi,\n                bool log_code_creation) {\n              DCHECK_IMPLIES(log_code_creation, isolate->NeedsSourcePositions());\n\n              DirectHandle<Script> script(Cast<Script>(result_sfi->script()), isolate);\n              if (log_code_creation) Script::InitLineEnds(isolate, script);\n\n              Tagged<String> name = ReadOnlyRoots(isolate).empty_string();\n              if (IsString(script->name())) name = Cast<String>(script->name());\n              DirectHandle<String> name_handle(name, isolate);\n\n              SharedFunctionInfo::ScriptIterator iter(isolate, *script);\n              for (Tagged<SharedFunctionInfo> shared_info = iter.Next();\n                   !shared_info.is_null(); shared_info = iter.Next()) {\n                IsCompiledScope is_compiled(shared_info, isolate);\n                if (!is_compiled.is_compiled()) continue;\n                DCHECK(shared_info->HasBytecodeArray());\n                DirectHandle<SharedFunctionInfo> sfi(shared_info, isolate);\n\n                DirectHandle<BytecodeArray> bytecode(sfi->GetBytecodeArray(isolate),\n                                                     isolate);\n                DirectHandle<Code> code =\n                    Builtins::CreateInterpreterEntryTrampolineForProfiling(isolate);\n                DirectHandle<InterpreterData> interpreter_data =\n                    isolate->factory()->NewInterpreterData(bytecode, code);\n\n                if (sfi->HasBaselineCode()) {\n                  sfi->baseline_code(kAcquireLoad)\n                      ->set_bytecode_or_interpreter_data(*interpreter_data);\n                } else {\n                  sfi->set_interpreter_data(isolate, *interpreter_data);\n                }\n\n                if (!log_code_creation) continue;\n\n                DirectHandle<AbstractCode> abstract_code = Cast<AbstractCode>(code);\n                Script::PositionInfo info;\n                Script::GetPositionInfo(script, sfi->StartPosition(), &info);\n                int line_num = info.line_start + 1;\n                int column_num = info.line_end + 1;\n                PROFILE(isolate,\n                        CodeCreateEvent(LogEventListener::CodeTag::kFunction, abstract_code,\n                                        sfi, name_handle, line_num, column_num));\n              }\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StressOffThreadDeserializeThread\",\n            \"extends\": \"base::Thread\",\n            \"implements\": [],\n            \"about\": \"A thread used for stressing off-thread deserialization during testing.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"cached_data_\",\n                    \"type\": \"AlignedCachedData*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The cached data to deserialize off-thread.\"\n                },\n                {\n                    \"name\": \"off_thread_data_\",\n                    \"type\": \"CodeSerializer::OffThreadDeserializeData\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the data from the off-thread deserialization process.\"\n                }\n            ],\n            \"dependencies\": [\n                \"base::Thread\",\n                \"Isolate\",\n                \"AlignedCachedData\",\n                \"CodeSerializer::OffThreadDeserializeData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class StressOffThreadDeserializeThread final : public base::Thread {\n             public:\n              explicit StressOffThreadDeserializeThread(Isolate* isolate,\n                                                        AlignedCachedData* cached_data)\n                  : Thread(\n                        base::Thread::Options(\"StressOffThreadDeserializeThread\", 2 * MB)),\n                    isolate_(isolate),\n                    cached_data_(cached_data) {}\n\n              void Run() final {\n                LocalIsolate local_isolate(isolate_, ThreadKind::kBackground);\n                UnparkedScope unparked_scope(&local_isolate);\n                LocalHandleScope handle_scope(&local_isolate);\n                off_thread_data_ =\n                    CodeSerializer::StartDeserializeOffThread(&local_isolate, cached_data_);\n              }\n\n              MaybeDirectHandle<SharedFunctionInfo> Finalize(\n                  Isolate* isolate, DirectHandle<String> source,\n                  const ScriptDetails& script_details) {\n                return CodeSerializer::FinishOffThreadDeserialize(\n                    isolate, std::move(off_thread_data_), cached_data_, source,\n                    script_details);\n              }\n\n             private:\n              Isolate* isolate_;\n              AlignedCachedData* cached_data_;\n              CodeSerializer::OffThreadDeserializeData off_thread_data_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FinalizeDeserialization\",\n            \"parent\": null,\n            \"about\": \"Finalizes the deserialization process.\",\n            \"logic\": \"Performs post-deserialization tasks, such as creating InterpreterData, resetting script details, and logging function events.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"result\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"The deserialized SharedFunctionInfo.\"\n                },\n                {\n                    \"name\": \"timer\",\n                    \"type\": \"const base::ElapsedTimer&\",\n                    \"purpose\": \"The timer used to measure deserialization time.\"\n                },\n                {\n                    \"name\": \"script_details\",\n                    \"type\": \"const ScriptDetails&\",\n                    \"purpose\": \"Details about the script being deserialized.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"SharedFunctionInfo\",\n                \"Script\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void FinalizeDeserialization(Isolate* isolate,\n                                         DirectHandle<SharedFunctionInfo> result,\n                                         const base::ElapsedTimer& timer,\n                                         const ScriptDetails& script_details) {\n              // Devtools can report time in this function as profiler overhead, since none\n              // of the following tasks would need to happen normally.\n              TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.compile\"),\n                           \"V8.FinalizeDeserialization\");\n\n              const bool log_code_creation = isolate->IsLoggingCodeCreation();\n\n              if (V8_UNLIKELY(isolate->interpreted_frames_native_stack())) {\n                CreateInterpreterDataForDeserializedCode(isolate, result,\n                                                         log_code_creation);\n              }\n\n              DirectHandle<Script> script(Cast<Script>(result->script()), isolate);\n              // Reset the script details, including host-defined options.\n              {\n                DisallowGarbageCollection no_gc;\n                SetScriptFieldsFromDetails(isolate, *script, script_details, &no_gc);\n              }\n\n              bool needs_source_positions = isolate->NeedsSourcePositions();\n              if (!log_code_creation && !needs_source_positions) return;\n\n              if (needs_source_positions) {\n                Script::InitLineEnds(isolate, script);\n              }\n\n              DirectHandle<String> name(IsString(script->name())\n                                            ? Cast<String>(script->name())\n                                            : ReadOnlyRoots(isolate).empty_string(),\n                                        isolate);\n\n              if (V8_UNLIKELY(v8_flags.log_function_events)) {\n                LOG(isolate,\n                    FunctionEvent(\"deserialize\", script->id(),\n                                  timer.Elapsed().InMillisecondsF(),\n                                  result->StartPosition(), result->EndPosition(), *name));\n              }\n\n              SharedFunctionInfo::ScriptIterator iter(isolate, *script);\n              for (Tagged<SharedFunctionInfo> info = iter.Next(); !info.is_null();\n                   info = iter.Next()) {\n                if (!info->is_compiled()) continue;\n                DirectHandle<SharedFunctionInfo> shared_info(info, isolate);\n                if (needs_source_positions) {\n                  SharedFunctionInfo::EnsureSourcePositionsAvailable(isolate, shared_info);\n                }\n                Script::PositionInfo pos_info;\n                Script::GetPositionInfo(script, shared_info->StartPosition(), &pos_info);\n                int line_num = pos_info.line + 1;\n                int column_num = pos_info.column + 1;\n                PROFILE(\n                    isolate,\n                    CodeCreateEvent(\n                        shared_info->is_toplevel() ? LogEventListener::CodeTag::kScript\n                                                   : LogEventListener::CodeTag::kFunction,\n                        direct_handle(shared_info->abstract_code(isolate), isolate),\n                        shared_info, name, line_num, column_num));\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"BaselineBatchCompileIfSparkplugCompiled\",\n            \"parent\": null,\n            \"about\": \"Enqueues shared function infos for baseline batch compilation if they were sparkplug compiled\",\n            \"logic\": \"If concurrent sparkplug and baseline batch compilation flags are enabled, this enqueues appropriate SharedFunctionInfos for baseline compilation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"script\",\n                    \"type\": \"Tagged<Script>\",\n                    \"purpose\": \"The script to check and potentially compile.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"Script\",\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_ENABLE_SPARKPLUG\n            void BaselineBatchCompileIfSparkplugCompiled(Isolate* isolate,\n                                                         Tagged<Script> script) {\n              // Here is main thread, we trigger early baseline compilation only in\n              // concurrent sparkplug and baseline batch compilation mode which consumes\n              // little main thread execution time.\n              if (v8_flags.concurrent_sparkplug && v8_flags.baseline_batch_compilation) {\n                SharedFunctionInfo::ScriptIterator iter(isolate, script);\n                for (Tagged<SharedFunctionInfo> info = iter.Next(); !info.is_null();\n                     info = iter.Next()) {\n                  if (info->cached_tiering_decision() != CachedTieringDecision::kPending &&\n                      CanCompileWithBaseline(isolate, info)) {\n                    isolate->baseline_batch_compiler()->EnqueueSFI(info);\n                  }\n                }\n              }\n            }\n            #else\n            void BaselineBatchCompileIfSparkplugCompiled(Isolate*, Tagged<Script>) {}\n            #endif  // V8_ENABLE_SPARKPLUG\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ToString\",\n            \"parent\": null,\n            \"about\": \"Converts a SerializedCodeSanityCheckResult enum to a string representation.\",\n            \"logic\": \"A simple switch statement that returns the string associated with each value of the enum.\",\n            \"parameters\": [\n                {\n                    \"name\": \"result\",\n                    \"type\":"
}