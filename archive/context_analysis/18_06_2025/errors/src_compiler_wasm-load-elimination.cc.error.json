{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-load-elimination.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-load-elimination.cc\",\n        \"file_name\": \"wasm-load-elimination.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements load elimination optimization for WebAssembly code in the V8 compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for compiler components and WebAssembly support.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/wasm-load-elimination.h\"\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/wasm/struct-types.h\"\n#include \"src/wasm/wasm-subtyping.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TypesUnrelated\",\n            \"about\": \"Checks if two WebAssembly types are unrelated.\",\n            \"logic\": \"Compares the types using the wasm::TypesUnrelated function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The first node representing a WebAssembly type.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The second node representing a WebAssembly type.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the types are unrelated, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"wasm::TypesUnrelated\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\nbool TypesUnrelated(Node* lhs, Node* rhs) {\n  wasm::TypeInModule type1 = NodeProperties::GetType(lhs).AsWasm();\n  wasm::TypeInModule type2 = NodeProperties::GetType(rhs).AsWasm();\n  return wasm::TypesUnrelated(type1.type, type2.type, type1.module,\n                              type2.module);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsFresh\",\n            \"about\": \"Checks if a node represents a fresh allocation.\",\n            \"logic\": \"Determines if the node's opcode is kAllocate or kAllocateRaw.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the node represents a fresh allocation, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsFresh(Node* node) {\n  return node->opcode() == IrOpcode::kAllocate ||\n         node->opcode() == IrOpcode::kAllocateRaw;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsConstant\",\n            \"about\": \"Checks if a node represents a constant value.\",\n            \"logic\": \"Determines if the node's opcode is kParameter or kHeapConstant.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the node represents a constant, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsConstant(Node* node) {\n  return node->opcode() == IrOpcode::kParameter ||\n         node->opcode() == IrOpcode::kHeapConstant;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MayAlias\",\n            \"about\": \"Checks if two nodes may alias each other.\",\n            \"logic\": \"Checks for equality, unrelated types, fresh allocations, or constant values to determine potential aliasing.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The first node to check.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The second node to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the nodes may alias, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"TypesUnrelated\",\n                \"IsFresh\",\n                \"IsConstant\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MayAlias(Node* lhs, Node* rhs) {\n  if (lhs == rhs) return true;\n  if (TypesUnrelated(lhs, rhs) || (IsFresh(lhs) && IsFresh(rhs)) ||\n      (IsFresh(lhs) && IsConstant(rhs)) || (IsConstant(lhs) && IsFresh(rhs))) {\n    return false;\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ResolveAliases\",\n            \"about\": \"Resolves aliases by traversing through type casts and assertions.\",\n            \"logic\": \"Iteratively follows ValueInput of kWasmTypeCast, kWasmTypeCastAbstract, kAssertNotNull, and kTypeGuard nodes until a non-alias node is found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to start resolving from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The resolved node after traversing aliases.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* ResolveAliases(Node* node) {\n  while (node->opcode() == IrOpcode::kWasmTypeCast ||\n         node->opcode() == IrOpcode::kWasmTypeCastAbstract ||\n         node->opcode() == IrOpcode::kAssertNotNull ||\n         node->opcode() == IrOpcode::kTypeGuard) {\n    node = NodeProperties::GetValueInput(node, 0);\n  }\n  return node;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UpdateState\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Updates the abstract state of a node.\",\n            \"logic\": \"Checks if the new state is different from the original state. If so, updates the node's state and signals a change.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to update the state for.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"AbstractState const*\",\n                    \"purpose\": \"The new abstract state.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction indicating whether the node changed.\"\n            },\n            \"dependencies\": [\n                \"AbstractState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmLoadElimination::UpdateState(Node* node,\n                                           AbstractState const* state) {\n  AbstractState const* original = node_states_.Get(node);\n  // Only signal that the {node} has Changed, if the information about {state}\n  // has changed wrt. the {original}.\n  if (state != original) {\n    if (original == nullptr || !state->Equals(original)) {\n      node_states_.Set(node, state);\n      return Changed(node);\n    }\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TruncateAndExtendOrType\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Truncates and extends or inserts a type guard for a value based on the field type.\",\n            \"logic\": \"Handles i8 and i16 truncation/extension with shifts and masks.  Adds a TypeGuard if the value's type is not a subtype of the field type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The value node.\"\n                },\n                {\n                    \"name\": \"effect\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The effect node.\"\n                },\n                {\n                    \"name\": \"control\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The control node.\"\n                },\n                {\n                    \"name\": \"field_type\",\n                    \"type\": \"wasm::ValueType\",\n                    \"purpose\": \"The expected field type.\"\n                },\n                {\n                    \"name\": \"is_signed\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether the field is signed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::tuple<Node*, Node*>\",\n                \"description\": \"The truncated/extended value and the updated effect.\"\n            },\n            \"dependencies\": [\n                \"wasm::TypesUnrelated\",\n                \"wasm::IsSubtypeOf\",\n                \"Type\",\n                \"NodeProperties\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::tuple<Node*, Node*> WasmLoadElimination::TruncateAndExtendOrType(\n    Node* value, Node* effect, Node* control, wasm::ValueType field_type,\n    bool is_signed) {\n  if (field_type == wasm::kWasmI8 || field_type == wasm::kWasmI16) {\n    Node* ret = nullptr;\n    if (is_signed) {\n      int shift = 32 - 8 * field_type.value_kind_size();\n      ret = graph()->NewNode(machine()->Word32Sar(),\n                             graph()->NewNode(machine()->Word32Shl(), value,\n                                              jsgraph()->Int32Constant(shift)),\n                             jsgraph()->Int32Constant(shift));\n    } else {\n      int mask = (1 << 8 * field_type.value_kind_size()) - 1;\n      ret = graph()->NewNode(machine()->Word32And(), value,\n                             jsgraph()->Int32Constant(mask));\n    }\n\n    NodeProperties::SetType(ret, NodeProperties::GetType(value));\n    return {ret, effect};\n  }\n\n  // The value might be untyped in case of wasm inlined into JS if the value\n  // comes from a JS node.\n  if (!NodeProperties::IsTyped(value)) {\n    return {value, effect};\n  }\n\n  Type value_type = NodeProperties::GetType(value);\n  if (!value_type.IsWasm()) {\n    return {value, effect};\n  }\n\n  wasm::TypeInModule node_type = value_type.AsWasm();\n\n  // TODO(12166): Adapt this if cross-module inlining is allowed.\n  if (wasm::TypesUnrelated(node_type.type, field_type, node_type.module,\n                           node_type.module)) {\n    // Unrelated types can occur as a result of unreachable code.\n    // Example: Storing a value x of type A in a struct, then casting the struct\n    // to a different struct type to then load type B from the same offset\n    // results in trying to replace the load with value x.\n    return {dead(), dead()};\n  }\n  if (!wasm::IsSubtypeOf(node_type.type, field_type, node_type.module)) {\n    Type type = Type::Wasm({field_type, node_type.module}, graph()->zone());\n    Node* ret =\n        graph()->NewNode(common()->TypeGuard(type), value, effect, control);\n    NodeProperties::SetType(ret, type);\n    return {ret, ret};\n  }\n\n  return {value, effect};\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Reduces a node based on its opcode.\",\n            \"logic\": \"Dispatches to specific reduction methods based on the node's opcode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction indicating the result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"ReduceWasmStructGet\",\n                \"ReduceWasmStructSet\",\n                \"ReduceWasmArrayLength\",\n                \"ReduceWasmArrayInitializeLength\",\n                \"ReduceStringPrepareForGetCodeunit\",\n                \"ReduceStringAsWtf16\",\n                \"ReduceAnyConvertExtern\",\n                \"ReduceEffectPhi\",\n                \"ReduceStart\",\n                \"ReduceOtherNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmLoadElimination::Reduce(Node* node) {\n  if (v8_flags.trace_turbo_load_elimination) {\n    // TODO(manoskouk): Add some tracing.\n  }\n  switch (node->opcode()) {\n    case IrOpcode::kWasmStructGet:\n      return ReduceWasmStructGet(node);\n    case IrOpcode::kWasmStructSet:\n      return ReduceWasmStructSet(node);\n    case IrOpcode::kWasmArrayLength:\n      return ReduceWasmArrayLength(node);\n    case IrOpcode::kWasmArrayInitializeLength:\n      return ReduceWasmArrayInitializeLength(node);\n    case IrOpcode::kStringPrepareForGetCodeunit:\n      return ReduceStringPrepareForGetCodeunit(node);\n    case IrOpcode::kStringAsWtf16:\n      return ReduceStringAsWtf16(node);\n    case IrOpcode::kWasmAnyConvertExtern:\n      return ReduceAnyConvertExtern(node);\n    case IrOpcode::kEffectPhi:\n      return ReduceEffectPhi(node);\n    case IrOpcode::kDead:\n      return NoChange();\n    case IrOpcode::kStart:\n      return ReduceStart(node);\n    default:\n      return ReduceOtherNode(node);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceWasmStructGet\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Reduces a kWasmStructGet node.\",\n            \"logic\": \"Attempts to replace the struct get with a previously stored value, using abstract state to track field values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The kWasmStructGet node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction indicating the result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"ResolveAliases\",\n                \"AbstractState\",\n                \"WasmFieldInfo\",\n                \"TruncateAndExtendOrType\",\n                \"MergeControlToEnd\",\n                \"dead\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmLoadElimination::ReduceWasmStructGet(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kWasmStructGet);\n  Node* input_struct = NodeProperties::GetValueInput(node, 0);\n  Node* object = ResolveAliases(input_struct);\n  Node* effect = NodeProperties::GetEffectInput(node);\n  Node* control = NodeProperties::GetControlInput(node);\n\n  if (object->opcode() == IrOpcode::kDead) return NoChange();\n  AbstractState const* state = node_states_.Get(effect);\n  if (state == nullptr) return NoChange();\n\n  const WasmFieldInfo& field_info = OpParameter<WasmFieldInfo>(node->op());\n  bool is_mutable = field_info.type->mutability(field_info.field_index);\n\n  if (!NodeProperties::IsTyped(input_struct) ||\n      !NodeProperties::GetType(input_struct).IsWasm()) {\n    // The input should always be typed.  https://crbug.com/1507106 reported\n    // that we can end up with Type None here instead of a wasm type.\n    // In the worst case this only means that we miss a potential optimization,\n    // still the assumption is that all inputs into StructGet should be typed.\n    return NoChange();\n  }\n  // Skip reduction if the input type is nullref. in this case, the struct get\n  // will always trap.\n  wasm::ValueType struct_type =\n      NodeProperties::GetType(input_struct).AsWasm().type;\n  if (struct_type == wasm::kWasmNullRef) {\n    return NoChange();\n  }\n  // The node is in unreachable code if its input is uninhabitable (bottom or\n  // ref none type). It can also be treated as unreachable if the field index is\n  // in the wrong half state. This can happen if an object gets cast to two\n  // unrelated types subsequently (as the state only tracks the field index)\n  // independent of the underlying type.\n  if (struct_type.is_uninhabited() ||\n      !(is_mutable ? state->immutable_state : state->mutable_state)\n           .LookupField(field_info.field_index, object)\n           .IsEmpty()) {\n    ReplaceWithValue(node, dead(), dead(), dead());\n    MergeControlToEnd(graph(), common(),\n                      graph()->NewNode(common()->Throw(), effect, control));\n    node->Kill();\n    return Replace(dead());\n  }\n  // If the input type is not (ref null? none) or bottom and we don't have type\n  // inconsistencies, then the result type must be valid.\n  DCHECK(!NodeProperties::GetType(node).AsWasm().type.is_bottom());\n\n  HalfState const* half_state =\n      is_mutable ? &state->mutable_state : &state->immutable_state;\n\n  FieldOrElementValue lookup_result =\n      half_state->LookupField(field_info.field_index, object);\n\n  if (!lookup_result.IsEmpty() && !lookup_result.value->IsDead()) {\n    std::tuple<Node*, Node*> replacement = TruncateAndExtendOrType(\n        lookup_result.value, effect, control,\n        field_info.type->field(field_info.field_index), field_info.is_signed);\n    if (std::get<0>(replacement) == dead()) {\n      // If the value is dead (unreachable), this whole code path is unreachable\n      // and we can mark this control flow path as dead.\n      ReplaceWithValue(node, dead(), dead(), dead());\n      MergeControlToEnd(graph(), common(),\n                        graph()->NewNode(common()->Throw(), effect, control));\n      node->Kill();\n      return Replace(dead());\n    }\n    ReplaceWithValue(node, std::get<0>(replacement), std::get<1>(replacement),\n                     control);\n    node->Kill();\n    return Replace(std::get<0>(replacement));\n  }\n\n  half_state = half_state->AddField(field_info.field_index, object, node);\n\n  AbstractState const* new_state =\n      is_mutable\n          ? zone()->New<AbstractState>(*half_state, state->immutable_state)\n          : zone()->New<AbstractState>(state->mutable_state, *half_state);\n\n  return UpdateState(node, new_state);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceWasmStructSet\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Reduces a kWasmStructSet node.\",\n            \"logic\": \"Updates the abstract state to reflect the new value of the field, potentially killing previous values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The kWasmStructSet node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction indicating the result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"ResolveAliases\",\n                \"AbstractState\",\n                \"WasmFieldInfo\",\n                \"MergeControlToEnd\",\n                \"dead\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmLoadElimination::ReduceWasmStructSet(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kWasmStructSet);\n  Node* input_struct = NodeProperties::GetValueInput(node, 0);\n  Node* object = ResolveAliases(input_struct);\n  Node* value = NodeProperties::GetValueInput(node, 1);\n  Node* effect = NodeProperties::GetEffectInput(node);\n  Node* control = NodeProperties::GetControlInput(node);\n\n  if (object->opcode() == IrOpcode::kDead) return NoChange();\n  AbstractState const* state = node_states_.Get(effect);\n  if (state == nullptr) return NoChange();\n\n  if (!NodeProperties::IsTyped(input_struct) ||\n      !NodeProperties::GetType(input_struct).IsWasm()) {\n    // Also see the same pattern in ReduceWasmStructGet. Note that this is\n    // reached for cases where the StructSet has a value input that is\n    // DeadValue(). Above we check for `object->opcode() == IrOpcode::kDead.\n    // As an alternative that check could be extended to also check for\n    // ... || object->opcode() == IrOpcode::kDeadValue.\n    // It seems that the DeadValue may be caused by\n    // DeadCodeElimination::ReducePureNode. If that finds any input that is a\n    // Dead() node, it will replace that input with a DeadValue().\n    return NoChange();\n  }\n\n  // Skip reduction if the input type is nullref. in this case, the struct get\n  // will always trap.\n  wasm::ValueType struct_type =\n      NodeProperties::GetType(input_struct).AsWasm().type;\n  if (struct_type == wasm::kWasmNullRef) {\n    return NoChange();\n  }\n\n  const WasmFieldInfo& field_info = OpParameter<WasmFieldInfo>(node->op());\n  bool is_mutable = field_info.type->mutability(field_info.field_index);\n\n  // The struct.set is unreachable if its input struct is an uninhabitable type.\n  // It can also be treated as unreachable if the field index is in the wrong\n  // half state. This can happen if an object gets cast to two unrelated types\n  // subsequently (as the state only tracks the field index) independent of the\n  // underlying type.\n  if (struct_type.is_uninhabited() ||\n      !(is_mutable ? state->immutable_state : state->mutable_state)\n           .LookupField(field_info.field_index, object)\n           .IsEmpty()) {\n    ReplaceWithValue(node, dead(), dead(), dead());\n    MergeControlToEnd(graph(), common(),\n                      graph()->NewNode(common()->Throw(), effect, control));\n    node->Kill();\n    return Replace(dead());\n  }\n\n  if (is_mutable) {\n    HalfState const* mutable_state =\n        state->mutable_state.KillField(field_info.field_index, object);\n    mutable_state =\n        mutable_state->AddField(field_info.field_index, object, value);\n    AbstractState const* new_state =\n        zone()->New<AbstractState>(*mutable_state, state->immutable_state);\n    return UpdateState(node, new_state);\n  } else {\n    // We should not initialize the same immutable field twice.\n    DCHECK(state->immutable_state.LookupField(field_info.field_index, object)\n               .IsEmpty());\n    HalfState const* immutable_state =\n        state->immutable_state.AddField(field_info.field_index, object, value);\n    AbstractState const* new_state =\n        zone()->New<AbstractState>(state->mutable_state, *immutable_state);\n    return UpdateState(node, new_state);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceLoadLikeFromImmutable\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Reduces a load-like operation from an immutable field (e.g., array length).\",\n            \"logic\": \"Attempts to replace the load with a previously stored value from the immutable half-state.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node representing the load-like operation.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the immutable field.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction indicating the result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"ResolveAliases\",\n                \"AbstractState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmLoadElimination::ReduceLoadLikeFromImmutable(Node* node,\n                                                           int index) {\n  // The index must be negative as it is not a real load, to not confuse it with\n  // actual loads.\n  DCHECK_LT(index, 0);\n  Node* object = ResolveAliases(NodeProperties::GetValueInput(node, 0));\n  Node* effect = NodeProperties::GetEffectInput(node);\n  Node* control = NodeProperties::GetControlInput(node);\n\n  if (object->opcode() == IrOpcode::kDead) return NoChange();\n  AbstractState const* state = node_states_.Get(effect);\n  if (state == nullptr) return NoChange();\n\n  HalfState const* immutable_state = &state->immutable_state;\n\n  FieldOrElementValue lookup_result =\n      immutable_state->LookupField(index, object);\n\n  if (!lookup_result.IsEmpty() && !lookup_result.value->IsDead()) {\n    ReplaceWithValue(node, lookup_result.value, effect, control);\n    node->Kill();\n    return Replace(lookup_result.value);\n  }\n\n  immutable_state = immutable_state->AddField(index, object, node);\n\n  AbstractState const* new_state =\n      zone()->New<AbstractState>(state->mutable_state, *immutable_state);\n\n  return UpdateState(node, new_state);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceWasmArrayLength\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Reduces a kWasmArrayLength node.\",\n            \"logic\": \"Utilizes ReduceLoadLikeFromImmutable with kArrayLengthFieldIndex.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The kWasmArrayLength node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction indicating the result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"ReduceLoadLikeFromImmutable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmLoadElimination::ReduceWasmArrayLength(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kWasmArrayLength);\n  return ReduceLoadLikeFromImmutable(node, kArrayLengthFieldIndex);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceWasmArrayInitializeLength\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Reduces a kWasmArrayInitializeLength node.\",\n            \"logic\": \"Stores the initial array length in the immutable half-state.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The kWasmArrayInitializeLength node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction indicating the result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"ResolveAliases\",\n                \"AbstractState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmLoadElimination::ReduceWasmArrayInitializeLength(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kWasmArrayInitializeLength);\n  Node* object = ResolveAliases(NodeProperties::GetValueInput(node, 0));\n  Node* value = NodeProperties::GetValueInput(node, 1);\n  Node* effect = NodeProperties::GetEffectInput(node);\n\n  if (object->opcode() == IrOpcode::kDead) return NoChange();\n  AbstractState const* state = node_states_.Get(effect);\n  if (state == nullptr) return NoChange();\n\n  // We should not initialize the length twice.\n  DCHECK(state->immutable_state.LookupField(kArrayLengthFieldIndex, object)\n             .IsEmpty());\n  HalfState const* immutable_state =\n      state->immutable_state.AddField(kArrayLengthFieldIndex, object, value);\n  AbstractState const* new_state =\n      zone()->New<AbstractState>(state->mutable_state, *immutable_state);\n  return UpdateState(node, new_state);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceStringPrepareForGetCodeunit\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Reduces a kStringPrepareForGetCodeunit node.\",\n            \"logic\": \"Attempts to replace the node with a previously prepared value for string access.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The kStringPrepareForGetCodeunit node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction indicating the result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"ResolveAliases\",\n                \"AbstractState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmLoadElimination::ReduceStringPrepareForGetCodeunit(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kStringPrepareForGetCodeunit);\n  Node* object = ResolveAliases(NodeProperties::GetValueInput(node, 0));\n  Node* effect = NodeProperties::GetEffectInput(node);\n  Node* control = NodeProperties::GetControlInput(node);\n\n  if (object->opcode() == IrOpcode::kDead) return NoChange();\n  AbstractState const* state = node_states_.Get(effect);\n  if (state == nullptr) return NoChange();\n\n  HalfState const* mutable_state = &state->mutable_state;\n\n  FieldOrElementValue lookup_result =\n      mutable_state->LookupField(kStringPrepareForGetCodeunitIndex, object);\n\n  if (!lookup_result.IsEmpty() && !lookup_result.value->IsDead()) {\n    for (size_t i : {0, 1, 2}) {\n      Node* proj_to_replace = NodeProperties::FindProjection(node, i);\n      ReplaceWithValue(proj_to_replace,\n                       NodeProperties::FindProjection(lookup_result.value, i));\n      proj_to_replace->Kill();\n    }\n    ReplaceWithValue(node, lookup_result.value, effect, control);\n    node->Kill();\n    return Replace(lookup_result.value);\n  }\n\n  mutable_state =\n      mutable_state->AddField(kStringPrepareForGetCodeunitIndex, object, node);\n\n  AbstractState const* new_state =\n      zone()->New<AbstractState>(*mutable_state, state->immutable_state);\n\n  return UpdateState(node, new_state);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceStringAsWtf16\",\n            \"parent\": \"WasmLoadElimination\",\n            \"about\": \"Reduces a kStringAsWtf16 node.\",\n            \"logic\": \"Utilizes ReduceLoadLikeFromImmutable with kStringAsWtf16Index.\",\n            \"parameters"
}