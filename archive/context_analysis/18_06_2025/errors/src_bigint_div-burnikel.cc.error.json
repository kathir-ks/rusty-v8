{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/bigint/div-burnikel.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 55, column 59",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/bigint/div-burnikel.cc\",\n        \"file_name\": \"div-burnikel.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Burnikel-Ziegler division algorithm for BigIntegers\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library and V8 BigInt headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <string.h>\n\n            #include \"src/bigint/bigint-internal.h\"\n            #include \"src/bigint/digit-arithmetic.h\"\n            #include \"src/bigint/div-helpers.h\"\n            #include \"src/bigint/util.h\"\n            #include \"src/bigint/vector-arithmetic.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SpecialCompare\",\n            \"about\": \"Compares a digit and a Digits object with another Digits object.\",\n            \"logic\": \"Compares [a_high, A] with B, considering the length and individual digits. Normalizes B and A if a_high is 0 to correctly determine their effective lengths.  Handles the case where a_high is non-zero by comparing it to the most significant digit of B before comparing the remaining digits of A and B.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a_high\",\n                    \"type\": \"digit_t\",\n                    \"purpose\": \"The high digit of the first number.\"\n                },\n                {\n                    \"name\": \"A\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The low digits of the first number.\"\n                },\n                {\n                    \"name\": \"B\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The second number to compare with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"Returns -1 if [a_high, A] < B, 0 if [a_high, A] == B, and 1 if [a_high, A] > B.\"\n            },\n            \"dependencies\": [\n                \"Digits::Normalize\",\n                \"Digits::len\",\n                \"Digits::operator[]\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            int SpecialCompare(digit_t a_high, Digits A, Digits B) {\n              B.Normalize();\n              int a_len;\n              if (a_high == 0) {\n                A.Normalize();\n                a_len = A.len();\n              } else {\n                a_len = A.len() + 1;\n              }\n              int diff = a_len - B.len();\n              if (diff != 0) return diff;\n              int i = a_len - 1;\n              if (a_high != 0) {\n                if (a_high > B[i]) return 1;\n                if (a_high < B[i]) return -1;\n                i--;\n              }\n              while (i >= 0 && A[i] == B[i]) i--;\n              if (i < 0) return 0;\n              return A[i] > B[i] ? 1 : -1;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SetOnes\",\n            \"about\": \"Sets all digits in a RWDigits object to the maximum possible value (all bits set to 1).\",\n            \"logic\": \"Uses memset to fill the digit array with 0xFF, effectively setting each digit to all ones.\",\n            \"parameters\": [\n                {\n                    \"name\": \"X\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The RWDigits object to set to all ones.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"RWDigits::digits\",\n                \"RWDigits::len\",\n                \"memset\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void SetOnes(RWDigits X) {\n              memset(X.digits(), 0xFF, X.len() * sizeof(digit_t));\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BZ\",\n            \"about\": \"Container for non-changing data used within the recursive Burnikel-Ziegler division algorithm.\",\n            \"attributes\": [\n                {\n                    \"name\": \"proc_\",\n                    \"type\": \"ProcessorImpl*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the ProcessorImpl object providing low-level arithmetic operations.\"\n                },\n                {\n                    \"name\": \"scratch_mem_\",\n                    \"type\": \"Storage\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Storage object used for allocating temporary memory during division.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ProcessorImpl\",\n                \"Storage\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class BZ {\n             public:\n              BZ(ProcessorImpl* proc, int scratch_space)\n                  : proc_(proc),\n                    scratch_mem_(scratch_space >= kBurnikelThreshold ? scratch_space : 0) {}\n\n              void DivideBasecase(RWDigits Q, RWDigits R, Digits A, Digits B);\n              void D3n2n(RWDigits Q, RWDigits R, Digits A1A2, Digits A3, Digits B);\n              void D2n1n(RWDigits Q, RWDigits R, Digits A, Digits B);\n\n             private:\n              ProcessorImpl* proc_;\n              Storage scratch_mem_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DivideBasecase\",\n            \"parent\": \"BZ\",\n            \"about\": \"Handles the base case for the Burnikel-Ziegler division algorithm.\",\n            \"logic\": \"Normalizes the input Digits. Compares A and B. If A <= B, sets Q and R appropriately (Q=1, R=0 if A==B; Q=0, R=A if A<B).  If B.len() is 1, uses DivideSingle.  Otherwise, uses DivideSchoolbook.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Q\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The quotient.\"\n                },\n                {\n                    \"name\": \"R\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The remainder.\"\n                },\n                {\n                    \"name\": \"A\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The dividend.\"\n                },\n                {\n                    \"name\": \"B\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The divisor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Digits::Normalize\",\n                \"Compare\",\n                \"Q.Clear\",\n                \"R.Clear\",\n                \"Q::operator[]\",\n                \"PutAt\",\n                \"ProcessorImpl::DivideSingle\",\n                \"ProcessorImpl::DivideSchoolbook\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BZ::DivideBasecase(RWDigits Q, RWDigits R, Digits A, Digits B) {\n              A.Normalize();\n              B.Normalize();\n              DCHECK(B.len() > 0);\n              int cmp = Compare(A, B);\n              if (cmp <= 0) {\n                Q.Clear();\n                if (cmp == 0) {\n                  // If A == B, then Q=1, R=0.\n                  R.Clear();\n                  Q[0] = 1;\n                } else {\n                  // If A < B, then Q=0, R=A.\n                  PutAt(R, A, R.len());\n                }\n                return;\n              }\n              if (B.len() == 1) {\n                return proc_->DivideSingle(Q, R.digits(), A, B[0]);\n              }\n              return proc_->DivideSchoolbook(Q, R, A, B);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"D3n2n\",\n            \"parent\": \"BZ\",\n            \"about\": \"Implements Algorithm 2 from the Burnikel-Ziegler paper.\",\n            \"logic\": \"Divides a 3n-digit number A by a 2n-digit number B. It splits A into [A1, A2, A3] and B into [B1, B2]. Depending on whether A1 < B1, it either computes Qhat = floor([A1, A2] / B1) or sets Qhat to all ones and performs subtraction and addition to adjust R1. Then calculates D = Qhat * B2. Finally, it computes Rhat = [R1, A3] - D and iteratively adjusts Qhat and Rhat until Rhat >= 0.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Q\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The quotient.\"\n                },\n                {\n                    \"name\": \"R\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The remainder.\"\n                },\n                {\n                    \"name\": \"A1A2\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The high 2n digits of the dividend A.\"\n                },\n                {\n                    \"name\": \"A3\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The low n digits of the dividend A.\"\n                },\n                {\n                    \"name\": \"B\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The divisor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Compare\",\n                \"D2n1n\",\n                \"ProcessorImpl::should_terminate\",\n                \"SetOnes\",\n                \"Subtract\",\n                \"AddAndReturnCarry\",\n                \"ProcessorImpl::Multiply\",\n                \"PutAt\",\n                \"SpecialCompare\",\n                \"SubtractAndReturnBorrow\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BZ::D3n2n(RWDigits Q, RWDigits R, Digits A1A2, Digits A3, Digits B) {\n              DCHECK((B.len() & 1) == 0);\n              int n = B.len() / 2;\n              DCHECK(A1A2.len() == 2 * n);\n              // Actual condition is stricter than length: A < B * 2^(kDigitBits * n)\n              DCHECK(Compare(A1A2, B) < 0);\n              DCHECK(A3.len() == n);\n              DCHECK(Q.len() == n);\n              DCHECK(R.len() == 2 * n);\n              // 1. Split A into three parts A = [A1, A2, A3] with Ai < 2^(kDigitBits * n).\n              Digits A1(A1A2, n, n);\n              // 2. Split B into two parts B = [B1, B2] with Bi < 2^(kDigitBits * n).\n              Digits B1(B, n, n);\n              Digits B2(B, 0, n);\n              // 3. Distinguish the cases A1 < B1 or A1 >= B1.\n              RWDigits Qhat = Q;\n              RWDigits R1(R, n, n);\n              digit_t r1_high = 0;\n              if (Compare(A1, B1) < 0) {\n                // 3a. If A1 < B1, compute Qhat = floor([A1, A2] / B1) with remainder R1\n                //     using algorithm D2n1n.\n                D2n1n(Qhat, R1, A1A2, B1);\n                if (proc_->should_terminate()) return;\n              } else {\n                // 3b. If A1 >= B1, set Qhat = 2^(kDigitBits * n) - 1 and set\n                //     R1 = [A1, A2] - [B1, 0] + [0, B1]\n                SetOnes(Qhat);\n                // Step 1: compute A1 - B1, which can't underflow because of the comparison\n                // guarding this else-branch, and always has a one-digit result because\n                // of this function's preconditions.\n                RWDigits temp = R1;\n                Subtract(temp, A1, B1);\n                temp.Normalize();\n                DCHECK(temp.len() <= 1);\n                if (temp.len() > 0) r1_high = temp[0];\n                // Step 2: compute A2 + B1.\n                Digits A2(A1A2, 0, n);\n                r1_high += AddAndReturnCarry(R1, A2, B1);\n              }\n              // 4. Compute D = Qhat * B2 using (Karatsuba) multiplication.\n              RWDigits D(scratch_mem_.get(), 2 * n);\n              proc_->Multiply(D, Qhat, B2);\n              if (proc_->should_terminate()) return;\n\n              // 5. Compute Rhat = R1*2^(kDigitBits * n) + A3 - D = [R1, A3] - D.\n              PutAt(R, A3, n);\n              // 6. As long as Rhat < 0, repeat:\n              while (SpecialCompare(r1_high, R, D) < 0) {\n                // 6a. Rhat = Rhat + B\n                r1_high += AddAndReturnCarry(R, R, B);\n                // 6b. Qhat = Qhat - 1\n                Subtract(Qhat, 1);\n              }\n              // 5. Compute Rhat = R1*2^(kDigitBits * n) + A3 - D = [R1, A3] - D.\n              digit_t borrow = SubtractAndReturnBorrow(R, R, D);\n              DCHECK(borrow == r1_high);\n              DCHECK(Compare(R, B) < 0);\n              (void)borrow;\n              // 7. Return R = Rhat, Q = Qhat.\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"D2n1n\",\n            \"parent\": \"BZ\",\n            \"about\": \"Implements Algorithm 1 from the Burnikel-Ziegler paper.\",\n            \"logic\": \"Divides a 2n-digit number A by an n-digit number B. If n is odd or smaller than kBurnikelThreshold, it calls DivideBasecase. Otherwise, it splits A into [A1, A2, A3, A4] and B into [B1, B2]. It recursively calls D3n2n twice to compute the high part Q1 and the low part Q2 of the quotient. Finally, it returns Q = [Q1, Q2] and R.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Q\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The quotient.\"\n                },\n                {\n                    \"name\": \"R\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The remainder.\"\n                },\n                {\n                    \"name\": \"A\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The dividend.\"\n                },\n                {\n                    \"name\": \"B\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The divisor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DivideBasecase\",\n                \"Compare\",\n                \"D3n2n\",\n                \"ProcessorImpl::should_terminate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BZ::D2n1n(RWDigits Q, RWDigits R, Digits A, Digits B) {\n              int n = B.len();\n              DCHECK(A.len() <= 2 * n);\n              // A < B * 2^(kDigitsBits * n)\n              DCHECK(Compare(Digits(A, n, n), B) < 0);\n              DCHECK(Q.len() == n);\n              DCHECK(R.len() == n);\n              // 1. If n is odd or smaller than some convenient constant, compute Q and R\n              //    by school division and return.\n              if ((n & 1) == 1 || n < kBurnikelThreshold) {\n                return DivideBasecase(Q, R, A, B);\n              }\n              // 2. Split A into four parts A = [A1, ..., A4] with\n              //    Ai < 2^(kDigitBits * n / 2). Split B into two parts [B2, B1] with\n              //    Bi < 2^(kDigitBits * n / 2).\n              Digits A1A2(A, n, n);\n              Digits A3(A, n / 2, n / 2);\n              Digits A4(A, 0, n / 2);\n              // 3. Compute the high part Q1 of floor(A/B) as\n              //    Q1 = floor([A1, A2, A3] / [B1, B2]) with remainder R1 = [R11, R12],\n              //    using algorithm D3n2n.\n              RWDigits Q1(Q, n / 2, n / 2);\n              ScratchDigits R1(n);\n              D3n2n(Q1, R1, A1A2, A3, B);\n              if (proc_->should_terminate()) return;\n              // 4. Compute the low part Q2 of floor(A/B) as\n              //    Q2 = floor([R11, R12, A4] / [B1, B2]) with remainder R, using\n              //    algorithm D3n2n.\n              RWDigits Q2(Q, 0, n / 2);\n              D3n2n(Q2, R, R1, A4, B);\n              // 5. Return Q = [Q1, Q2] and R.\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DivideBurnikelZiegler\",\n            \"parent\": \"ProcessorImpl\",\n            \"about\": \"Implements Algorithm 3 from the Burnikel-Ziegler paper.\",\n            \"logic\": \"Divides A by B using the Burnikel-Ziegler algorithm. It first normalizes B by shifting it left by sigma bits. Then, it shifts A by the same amount. It splits A into t blocks and iteratively calls D2n1n to compute the quotient blocks. Finally, it returns the quotient and the remainder (right-shifted by sigma bits).\",\n            \"parameters\": [\n                {\n                    \"name\": \"Q\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The quotient.\"\n                },\n                {\n                    \"name\": \"R\",\n                    \"type\": \"RWDigits\",\n                    \"purpose\": \"The remainder (optional).\"\n                },\n                {\n                    \"name\": \"A\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The dividend.\"\n                },\n                {\n                    \"name\": \"B\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The divisor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"BitLength\",\n                \"CountLeadingZeros\",\n                \"LeftShift\",\n                \"BZ\",\n                \"D2n1n\",\n                \"ProcessorImpl::should_terminate\",\n                \"PutAt\",\n                \"RightShift\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ProcessorImpl::DivideBurnikelZiegler(RWDigits Q, RWDigits R, Digits A,\n                                                      Digits B) {\n              DCHECK(A.len() >= B.len());\n              DCHECK(R.len() == 0 || R.len() >= B.len());\n              DCHECK(Q.len() > A.len() - B.len());\n              int r = A.len();\n              int s = B.len();\n              // The requirements are:\n              // - n >= s, n as small as possible.\n              // - m must be a power of two.\n              // 1. Set m = min {2^k | 2^k * kBurnikelThreshold > s}.\n              int m = 1 << BitLength(s / kBurnikelThreshold);\n              // 2. Set j = roundup(s/m) and n = j * m.\n              int j = DIV_CEIL(s, m);\n              int n = j * m;\n              // 3. Set sigma = max{tao | 2^tao * B < 2^(kDigitBits * n)}.\n              int sigma = CountLeadingZeros(B[s - 1]);\n              int digit_shift = n - s;\n              // 4. Set B = B * 2^sigma to normalize B. Shift A by the same amount.\n              ScratchDigits B_shifted(n);\n              LeftShift(B_shifted + digit_shift, B, sigma);\n              for (int i = 0; i < digit_shift; i++) B_shifted[i] = 0;\n              B = B_shifted;\n              // We need an extra digit if A's top digit does not have enough space for\n              // the left-shift by {sigma}. Additionally, the top bit of A must be 0\n              // (see \"-1\" in step 5 below), which combined with B being normalized (i.e.\n              // B's top bit is 1) ensures the preconditions of the helper functions.\n              int extra_digit = CountLeadingZeros(A[r - 1]) < (sigma + 1) ? 1 : 0;\n              r = A.len() + digit_shift + extra_digit;\n              ScratchDigits A_shifted(r);\n              LeftShift(A_shifted + digit_shift, A, sigma);\n              for (int i = 0; i < digit_shift; i++) A_shifted[i] = 0;\n              A = A_shifted;\n              // 5. Set t = min{t >= 2 | A < 2^(kDigitBits * t * n - 1)}.\n              int t = std::max(DIV_CEIL(r, n), 2);\n              // 6. Split A conceptually into t blocks.\n              // 7. Set Z_(t-2) = [A_(t-1), A_(t-2)].\n              int z_len = n * 2;\n              ScratchDigits Z(z_len);\n              PutAt(Z, A + n * (t - 2), z_len);\n              // 8. For i from t-2 downto 0 do:\n              BZ bz(this, n);\n              ScratchDigits Ri(n);\n              {\n                // First iteration unrolled and specialized.\n                // We might not have n digits at the top of Q, so use temporary storage\n                // for Qi...\n                ScratchDigits Qi(n);\n                bz.D2n1n(Qi, Ri, Z, B);\n                if (should_terminate()) return;\n                // ...but there *will* be enough space for any non-zero result digits!\n                Qi.Normalize();\n                RWDigits target = Q + n * (t - 2);\n                DCHECK(Qi.len() <= target.len());\n                PutAt(target, Qi, target.len());\n              }\n              // Now loop over any remaining iterations.\n              for (int i = t - 3; i >= 0; i--) {\n                // 8b. If i > 0, set Z_(i-1) = [Ri, A_(i-1)].\n                // (De-duped with unrolled first iteration, hence reading A_(i).)\n                PutAt(Z + n, Ri, n);\n                PutAt(Z, A + n * i, n);\n                // 8a. Using algorithm D2n1n compute Qi, Ri such that Zi = B*Qi + Ri.\n                RWDigits Qi(Q, i * n, n);\n                bz.D2n1n(Qi, Ri, Z, B);\n                if (should_terminate()) return;\n              }\n              // 9. Return Q = [Q_(t-2), ..., Q_0] and R = R_0 * 2^(-sigma).\n        #if DEBUG\n              for (int i = 0; i < digit_shift; i++) {\n                DCHECK(Ri[i] == 0);\n              }\n        #endif\n              if (R.len() != 0) {\n                Digits Ri_part(Ri, digit_shift, Ri.len());\n                Ri_part.Normalize();\n                DCHECK(Ri_part.len() <= R.len());\n                RightShift(R, Ri_part, sigma);\n              }\n            }\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Digits\",\n                \"about\": \"Represents a read-only sequence of digits.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Digits {\n                public:\n                    digit_t operator[](int i) const;\n                    int len() const;\n                    void Normalize();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RWDigits\",\n                \"about\": \"Represents a read-write sequence of digits.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class RWDigits {\n                public:\n                    digit_t* digits();\n                    int len() const;\n                    digit_t& operator[](int i);\n                    void Clear();\n                    void Normalize();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ScratchDigits\",\n                \"about\": \"Represents temporary storage for digits.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ScratchDigits : public RWDigits {\n                public:\n                 ScratchDigits(int size);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ProcessorImpl\",\n                \"about\": \"Abstracts out low-level arithmetic operations.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ProcessorImpl {\n                public:\n                    void Multiply(RWDigits dst, Digits x, Digits y);\n                    void DivideSingle(RWDigits Q, digit_t* R, Digits A, digit_t b);\n                    void DivideSchoolbook(RWDigits Q, RWDigits R, Digits A, Digits B);\n                    bool should_terminate() const;\n                };\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Storage\",\n                \"about\": \"Manages memory allocation for big integer operations\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Storage {\n                public:\n                    digit_t* get();\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}