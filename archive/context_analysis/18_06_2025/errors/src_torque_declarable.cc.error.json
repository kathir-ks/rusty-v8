{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/declarable.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 41, column 49",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/declarable.cc\",\n            \"file_name\": \"declarable.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines classes and functions related to declarables (e.g., functions, classes, types) in the Torque language, including scope management, type constraints, and generic callable specialization.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for Torque declarable functionality\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/declarable.h\"\n\n#include <fstream>\n#include <iostream>\n#include <optional>\n\n#include \"src/torque/ast.h\"\n#include \"src/torque/global-context.h\"\n#include \"src/torque/type-inference.h\"\n#include \"src/torque/type-visitor.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"QualifiedName\",\n                \"about\": \"Represents a qualified name, including namespace qualifications and the actual name.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"namespace_qualification\",\n                        \"type\": \"std::vector<std::string>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the namespace qualification components of the name.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"std::string\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the unqualified name.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::torque {\n\nQualifiedName QualifiedName::Parse(std::string qualified_name) {\n  std::vector<std::string> qualifications;\n  while (true) {\n    size_t namespace_delimiter_index = qualified_name.find(\"::\");\n    if (namespace_delimiter_index == std::string::npos) break;\n    qualifications.push_back(\n        qualified_name.substr(0, namespace_delimiter_index));\n    qualified_name = qualified_name.substr(namespace_delimiter_index + 2);\n  }\n  return QualifiedName(std::move(qualifications), qualified_name);\n}\n\nstd::ostream& operator<<(std::ostream& os, const QualifiedName& name) {\n  for (const std::string& qualifier : name.namespace_qualification) {\n    os << qualifier << \"::\";\n  }\n  return os << name.name;\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"QualifiedName::Parse\",\n                \"parent\": \"QualifiedName\",\n                \"about\": \"Parses a qualified name string into a QualifiedName object.\",\n                \"logic\": \"Splits the input string by '::' to separate namespace qualifications, storing them in a vector. The remaining part is the actual name.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"qualified_name\",\n                        \"type\": \"std::string\",\n                        \"purpose\": \"The string representation of the qualified name.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"QualifiedName\",\n                    \"description\": \"The parsed QualifiedName object.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nQualifiedName QualifiedName::Parse(std::string qualified_name) {\n  std::vector<std::string> qualifications;\n  while (true) {\n    size_t namespace_delimiter_index = qualified_name.find(\"::\");\n    if (namespace_delimiter_index == std::string::npos) break;\n    qualifications.push_back(\n        qualified_name.substr(0, namespace_delimiter_index));\n    qualified_name = qualified_name.substr(namespace_delimiter_index + 2);\n  }\n  return QualifiedName(std::move(qualifications), qualified_name);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for QualifiedName to print its string representation to an ostream.\",\n                \"logic\": \"Iterates through the namespace qualifications, printing each followed by '::'. Then, prints the actual name.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const QualifiedName&\",\n                        \"purpose\": \"The QualifiedName object to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream, allowing for chaining.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const QualifiedName& name) {\n  for (const std::string& qualifier : name.namespace_qualification) {\n    os << qualifier << \"::\";\n  }\n  return os << name.name;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for Callable to print its string representation to an ostream.\",\n                \"logic\": \"Prints 'callable', the callable's name, and its signature, differentiating between implicit and explicit parameters.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"m\",\n                        \"type\": \"const Callable&\",\n                        \"purpose\": \"The Callable object to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream, allowing for chaining.\"\n                },\n                \"dependencies\": [\n                    \"Callable\",\n                    \"TypeVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const Callable& m) {\n  os << \"callable \" << m.ReadableName() << \"(\";\n  if (m.signature().implicit_count != 0) {\n    os << \"implicit \";\n    TypeVector implicit_parameter_types(\n        m.signature().parameter_types.types.begin(),\n        m.signature().parameter_types.types.begin() +\n            m.signature().implicit_count);\n    os << implicit_parameter_types << \")(\";\n    TypeVector explicit_parameter_types(\n        m.signature().parameter_types.types.begin() +\n            m.signature().implicit_count,\n        m.signature().parameter_types.types.end());\n    os << explicit_parameter_types;\n  } else {\n    os << m.signature().parameter_types;\n  }\n  os << \"): \" << *m.signature().return_type;\n  return os;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for Builtin to print its string representation to an ostream.\",\n                \"logic\": \"Prints 'builtin', the return type, the builtin's name, and its parameter types.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"type\": \"const Builtin&\",\n                        \"purpose\": \"The Builtin object to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream, allowing for chaining.\"\n                },\n                \"dependencies\": [\n                    \"Builtin\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const Builtin& b) {\n  os << \"builtin \" << *b.signature().return_type << \" \" << b.ReadableName()\n     << b.signature().parameter_types;\n  return os;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for RuntimeFunction to print its string representation to an ostream.\",\n                \"logic\": \"Prints 'runtime function', the return type, the function's name, and its parameter types.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"type\": \"const RuntimeFunction&\",\n                        \"purpose\": \"The RuntimeFunction object to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream, allowing for chaining.\"\n                },\n                \"dependencies\": [\n                    \"RuntimeFunction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const RuntimeFunction& b) {\n  os << \"runtime function \" << *b.signature().return_type << \" \"\n     << b.ReadableName() << b.signature().parameter_types;\n  return os;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for GenericCallable to print its string representation to an ostream.\",\n                \"logic\": \"Prints 'generic', the generic callable's name, and its generic parameters.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream to write to.\"\n                    },\n                    {\n                        \"name\": \"g\",\n                        \"type\": \"const GenericCallable&\",\n                        \"purpose\": \"The GenericCallable object to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream, allowing for chaining.\"\n                },\n                \"dependencies\": [\n                    \"GenericCallable\",\n                    \"PrintCommaSeparatedList\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const GenericCallable& g) {\n  os << \"generic \" << g.name() << \"<\";\n  PrintCommaSeparatedList(os, g.generic_parameters(),\n                          [](const GenericParameter& identifier) {\n                            return identifier.name->value;\n                          });\n  os << \">\";\n\n  return os;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SpecializationRequester\",\n                \"about\": \"Represents a request for a template specialization, associated with a source position and scope.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"position\",\n                        \"type\": \"SourcePosition\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The source position where the specialization is requested.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"std::string\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The name of the specialization.\"\n                    },\n                    {\n                        \"name\": \"scope\",\n                        \"type\": \"Scope*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The scope in which the specialization is requested.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"SourcePosition\",\n                    \"Scope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSpecializationRequester::SpecializationRequester(SourcePosition position,\n                                                 Scope* s, std::string name)\n    : position(position), name(std::move(name)) {\n  // Skip scopes that are not related to template specializations, they might be\n  // stack-allocated and not live for long enough.\n  while (s && s->GetSpecializationRequester().IsNone()) s = s->ParentScope();\n  this->scope = s;\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SpecializationRequester::SpecializationRequester\",\n                \"parent\": \"SpecializationRequester\",\n                \"about\": \"Constructor for the SpecializationRequester class.\",\n                \"logic\": \"Initializes the position, name, and scope.  It walks up the scope chain to find the closest scope that is related to template specialization\",\n                \"parameters\": [\n                    {\n                        \"name\": \"position\",\n                        \"type\": \"SourcePosition\",\n                        \"purpose\": \"The source position.\"\n                    },\n                    {\n                        \"name\": \"s\",\n                        \"type\": \"Scope*\",\n                        \"purpose\": \"The scope.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"std::string\",\n                        \"purpose\": \"The name of the specialization.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"SourcePosition\",\n                    \"Scope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSpecializationRequester::SpecializationRequester(SourcePosition position,\n                                                 Scope* s, std::string name)\n    : position(position), name(std::move(name)) {\n  // Skip scopes that are not related to template specializations, they might be\n  // stack-allocated and not live for long enough.\n  while (s && s->GetSpecializationRequester().IsNone()) s = s->ParentScope();\n  this->scope = s;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Scope::Lookup\",\n                \"parent\": \"Scope\",\n                \"about\": \"Looks up a declarable in the scope, considering parent scopes and namespaces.\",\n                \"logic\": \"If the qualified name starts with the default namespace, the lookup is delegated to that namespace. Otherwise, the lookup is performed recursively in parent scopes and then in the current scope.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const QualifiedName&\",\n                        \"purpose\": \"The qualified name to lookup.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::vector<Declarable*>\",\n                    \"description\": \"A vector of declarables with the given name.\"\n                },\n                \"dependencies\": [\n                    \"QualifiedName\",\n                    \"Declarable\",\n                    \"GlobalContext\",\n                    \"Namespace\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::vector<Declarable*> Scope::Lookup(const QualifiedName& name) {\n  if (!name.namespace_qualification.empty() &&\n      name.namespace_qualification[0].empty()) {\n    return GlobalContext::GetDefaultNamespace()->Lookup(\n        name.DropFirstNamespaceQualification());\n  }\n  std::vector<Declarable*> result;\n  if (ParentScope()) {\n    result = ParentScope()->Lookup(name);\n  }\n  for (Declarable* declarable : LookupShallow(name)) {\n    result.push_back(declarable);\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TypeConstraint\",\n                \"about\": \"Represents a constraint on a type, specifically an upper bound.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"upper_bound\",\n                        \"type\": \"const Type* const*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to a constant pointer to a Type, representing the upper bound.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<std::string> TypeConstraint::IsViolated(const Type* type) const {\n  if (upper_bound && !type->IsSubtypeOf(*upper_bound)) {\n    if (type->IsTopType()) {\n      return TopType::cast(type)->reason();\n    } else {\n      return {\n          ToString(\"expected \", *type, \" to be a subtype of \", **upper_bound)};\n    }\n  }\n  return std::nullopt;\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TypeConstraint::IsViolated\",\n                \"parent\": \"TypeConstraint\",\n                \"about\": \"Checks if a given type violates the constraint (being a subtype of the upper bound).\",\n                \"logic\": \"If an upper bound is defined, it checks if the given type is a subtype of it. If the given type is a TopType, it returns the reason for being a TopType, otherwise returns that the type is not a subtype of the upper bound\",\n                \"parameters\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const Type*\",\n                        \"purpose\": \"The type to check against the constraint.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<std::string>\",\n                    \"description\": \"An optional string containing the violation message, or std::nullopt if no violation.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"ToString\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<std::string> TypeConstraint::IsViolated(const Type* type) const {\n  if (upper_bound && !type->IsSubtypeOf(*upper_bound)) {\n    if (type->IsTopType()) {\n      return TopType::cast(type)->reason();\n    } else {\n      return {\n          ToString(\"expected \", *type, \" to be a subtype of \", **upper_bound)};\n    }\n  }\n  return std::nullopt;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"FindConstraintViolation\",\n                \"about\": \"Finds if any type in a vector violates its corresponding constraint.\",\n                \"logic\": \"Iterates through the types and constraints, checking each type against its constraint using `IsViolated`. Returns the first violation found.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"types\",\n                        \"type\": \"const std::vector<const Type*>&\",\n                        \"purpose\": \"A vector of types.\"\n                    },\n                    {\n                        \"name\": \"constraints\",\n                        \"type\": \"const std::vector<TypeConstraint>&\",\n                        \"purpose\": \"A vector of type constraints.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<std::string>\",\n                    \"description\": \"An optional string containing the violation message, or std::nullopt if no violation.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"TypeConstraint\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<std::string> FindConstraintViolation(\n    const std::vector<const Type*>& types,\n    const std::vector<TypeConstraint>& constraints) {\n  DCHECK_EQ(constraints.size(), types.size());\n  for (size_t i = 0; i < types.size(); ++i) {\n    if (auto violation = constraints[i].IsViolated(types[i])) {\n      return {\"Could not instantiate generic, \" + *violation + \".\"};\n    }\n  }\n  return std::nullopt;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ComputeConstraints\",\n                \"about\": \"Computes the type constraints for a set of generic parameters.\",\n                \"logic\": \"Iterates through the generic parameters, creating a TypeConstraint based on the parameter's constraint (if any).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"scope\",\n                        \"type\": \"Scope*\",\n                        \"purpose\": \"The scope in which the generic parameters are defined.\"\n                    },\n                    {\n                        \"name\": \"parameters\",\n                        \"type\": \"const GenericParameters&\",\n                        \"purpose\": \"The generic parameters.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::vector<TypeConstraint>\",\n                    \"description\": \"A vector of type constraints.\"\n                },\n                \"dependencies\": [\n                    \"Scope\",\n                    \"GenericParameters\",\n                    \"TypeConstraint\",\n                    \"TypeVisitor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::vector<TypeConstraint> ComputeConstraints(\n    Scope* scope, const GenericParameters& parameters) {\n  CurrentScope::Scope scope_scope(scope);\n  std::vector<TypeConstraint> result;\n  for (const GenericParameter& parameter : parameters) {\n    if (parameter.constraint) {\n      result.push_back(TypeConstraint::SubtypeConstraint(\n          TypeVisitor::ComputeType(*parameter.constraint)));\n    } else {\n      result.push_back(TypeConstraint::Unconstrained());\n    }\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GenericCallable::InferSpecializationTypes\",\n                \"parent\": \"GenericCallable\",\n                \"about\": \"Infers the specialization types for a generic callable based on explicit specialization types and arguments.\",\n                \"logic\": \"Creates a TypeArgumentInference object to infer types, then checks for constraint violations using `FindConstraintViolation`. Returns the inference result.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"explicit_specialization_types\",\n                        \"type\": \"const TypeVector&\",\n                        \"purpose\": \"Explicitly provided specialization types.\"\n                    },\n                    {\n                        \"name\": \"arguments\",\n                        \"type\": \"const std::vector<std::optional<const Type*>>&\",\n                        \"purpose\": \"The types of the arguments passed to the callable.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"TypeArgumentInference\",\n                    \"description\": \"The result of the type inference.\"\n                },\n                \"dependencies\": [\n                    \"TypeVector\",\n                    \"TypeArgumentInference\",\n                    \"GenericCallable\",\n                    \"FindConstraintViolation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nTypeArgumentInference GenericCallable::InferSpecializationTypes(\n    const TypeVector& explicit_specialization_types,\n    const std::vector<std::optional<const Type*>>& arguments) {\n  const std::vector<TypeExpression*>& parameters =\n      declaration()->parameters.types;\n  CurrentScope::Scope generic_scope(ParentScope());\n  TypeArgumentInference inference(generic_parameters(),\n                                  explicit_specialization_types, parameters,\n                                  arguments);\n  if (!inference.HasFailed()) {\n    if (auto violation =\n            FindConstraintViolation(inference.GetResult(), Constraints())) {\n      inference.Fail(*violation);\n    }\n  }\n  return inference;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GenericCallable::CallableBody\",\n                \"parent\": \"GenericCallable\",\n                \"about\": \"Gets the body of the callable (either a TorqueMacroDeclaration or a TorqueBuiltinDeclaration).\",\n                \"logic\": \"Attempts to cast the declaration to a TorqueMacroDeclaration or a TorqueBuiltinDeclaration, and returns the corresponding body. Returns std::nullopt if the declaration is neither.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"std::optional<Statement*>\",\n                    \"description\": \"An optional pointer to the statement representing the callable's body, or std::nullopt if not found.\"\n                },\n                \"dependencies\": [\n                    \"Statement\",\n                    \"TorqueMacroDeclaration\",\n                    \"TorqueBuiltinDeclaration\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<Statement*> GenericCallable::CallableBody() {\n  if (auto* macro_decl = TorqueMacroDeclaration::DynamicCast(declaration())) {\n    return macro_decl->body;\n  } else if (auto* builtin_decl =\n                 TorqueBuiltinDeclaration::DynamicCast(declaration())) {\n    return builtin_decl->body;\n  } else {\n    return std::nullopt;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Namespace::IsDefaultNamespace\",\n                \"parent\": \"Namespace\",\n                \"about\": \"Checks if the namespace is the default namespace.\",\n                \"logic\": \"Compares the namespace object with the result of GlobalContext::GetDefaultNamespace().\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the namespace is the default namespace, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"GlobalContext\",\n                    \"Namespace\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Namespace::IsDefaultNamespace() const {\n  return this == GlobalContext::GetDefaultNamespace();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Namespace::IsTestNamespace\",\n                \"parent\": \"Namespace\",\n                \"about\": \"Checks if the namespace is the test namespace.\",\n                \"logic\": \"Compares the namespace name with `kTestNamespaceName`.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the namespace is the test namespace, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Namespace\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Namespace::IsTestNamespace() const { return name() == kTestNamespaceName; }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TypeAlias::Resolve\",\n                \"parent\": \"TypeAlias\",\n                \"about\": \"Resolves the type alias to its underlying type.\",\n                \"logic\": \"If the type hasn't been resolved yet, it computes the type using `TypeVisitor::ComputeType` within a scope and source position context. It also handles circular dependencies.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"const Type*\",\n                    \"description\": \"The resolved type.\"\n                },\n                \"dependencies\": [\n                    \"Type\",\n                    \"TypeVisitor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconst Type* TypeAlias::Resolve() const {\n  if (!type_) {\n    CurrentScope::Scope scope_activator(ParentScope());\n    CurrentSourcePosition::Scope position_activator(Position());\n    TypeDeclaration* decl = *delayed_;\n    if (being_resolved_) {\n      std::stringstream s;\n      s << \"Cannot create type \" << decl->name->value\n        << \" due to circular dependencies.\";\n      ReportError(s.str());\n    }\n    type_ = TypeVisitor::ComputeType(decl);\n  }\n  return *type_;\n}\n        ]]></code>\n    </func>\n</file>\n```"
}