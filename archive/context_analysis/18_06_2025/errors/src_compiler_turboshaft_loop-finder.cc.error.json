{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/loop-finder.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 45, column 49",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/loop-finder.cc\",\n            \"file_name\": \"loop-finder.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Finds loops in a turboshaft graph and provides information about them.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes the header file for the LoopFinder class.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/loop-finder.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LoopFinder\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Finds and analyzes loops within a turboshaft graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"input_graph_\",\n                        \"type\": \"Graph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the input graph being analyzed.\"\n                    },\n                    {\n                        \"name\": \"phase_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone used for allocations during the loop finding phase.\"\n                    },\n                    {\n                        \"name\": \"loop_headers_\",\n                        \"type\": \"ZoneVector<Block*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the loop header for each block.  Used to determine loop membership during traversal.\"\n                    },\n                    {\n                        \"name\": \"loop_header_info_\",\n                        \"type\": \"ZoneMap<const Block*, LoopInfo>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores information about each loop, keyed by the loop header block.\"\n                    },\n                    {\n                        \"name\": \"queue_\",\n                        \"type\": \"ZoneVector<const Block*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A queue used for breadth-first traversal of the graph.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Block\",\n                    \"Graph\",\n                    \"Zone\",\n                    \"ZoneVector\",\n                    \"ZoneMap\",\n                    \"base::Reversed\",\n                    \"GotoOp\",\n                    \"LoopInfo\",\n                    \"ZoneSet\",\n                    \"NeighboringPredecessorIterable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::compiler::turboshaft {\n\nclass LoopFinder {\n public:\n  struct LoopInfo {\n    const Block* start = nullptr;\n    const Block* end = nullptr;\n    size_t block_count = 0;\n    size_t op_count = 0;\n    bool has_inner_loops = false;\n  };\n\n  using BlockCmp = std::less<const Block*>;\n\n  LoopFinder(Graph* graph, Zone* phase_zone)\n      : input_graph_(graph),\n        phase_zone_(phase_zone),\n        loop_headers_(phase_zone),\n        loop_header_info_(phase_zone),\n        queue_(phase_zone_) {\n    loop_headers_.resize(graph->blocks().size());\n  }\n\n  LoopInfo GetLoopInfo(const Block* loop_header) const {\n    auto it = loop_header_info_.find(loop_header);\n    DCHECK(it != loop_header_info_.end());\n    return it->second;\n  }\n\n  void Run();\n\n  ZoneSet<const Block*, BlockCmp> GetLoopBody(const Block* loop_header);\n\n private:\n  LoopInfo VisitLoop(const Block* header);\n\n  Graph* const input_graph_;\n  Zone* const phase_zone_;\n  ZoneVector<Block*> loop_headers_;\n  ZoneMap<const Block*, LoopInfo> loop_header_info_;\n  ZoneVector<const Block*> queue_;\n};\n\n}  // namespace v8::internal::compiler::turboshaft\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Run\",\n                \"parent\": \"LoopFinder\",\n                \"about\": \"Identifies and analyzes all loops in the input graph.\",\n                \"logic\": \"Iterates through the blocks in reverse order. If a block is a loop header, it calls VisitLoop to analyze the loop and stores the results in loop_header_info_.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"base::Reversed\",\n                    \"Block::IsLoop\",\n                    \"VisitLoop\",\n                    \"loop_header_info_\",\n                    \"Block::OpCountUpperBound\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LoopFinder::Run() {\n  ZoneVector<Block*> all_loops(phase_zone_);\n  for (const Block& block : base::Reversed(input_graph_->blocks())) {\n    if (block.IsLoop()) {\n      LoopInfo info = VisitLoop(&block);\n      loop_header_info_.insert({&block, info});\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"VisitLoop\",\n                \"parent\": \"LoopFinder\",\n                \"about\": \"Analyzes a single loop, starting from its header block.\",\n                \"logic\": \"Performs a breadth-first search to identify all blocks within the loop.  It uses `loop_headers_` to avoid re-visiting blocks that are part of inner loops, and marks `has_inner_loops` if it encounters an inner loop.  It calculates `block_count` and `op_count` for the loop.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"header\",\n                        \"type\": \"const Block*\",\n                        \"purpose\": \"The header block of the loop.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"LoopInfo\",\n                    \"description\": \"Information about the loop, including its block count, operation count, and whether it contains inner loops.\"\n                },\n                \"dependencies\": [\n                    \"Block::LastPredecessor\",\n                    \"GotoOp\",\n                    \"Block::OpCountUpperBound\",\n                    \"queue_\",\n                    \"loop_headers_\",\n                    \"Block::index\",\n                    \"NeighboringPredecessorIterable\",\n                    \"DCHECK\",\n                    \"DCHECK_EQ\",\n                    \"DCHECK_GE\",\n                    \"DCHECK_NOT_NULL\",\n                    \"GotoOp::destination\",\n                    \"Graph::blocks\",\n                    \"Graph::size\",\n                    \"Is\",\n                    \"Cast\",\n                    \"index\",\n                    \"id\",\n                    \"NeighboringPredecessor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nLoopFinder::LoopInfo LoopFinder::VisitLoop(const Block* header) {\n  Block* backedge = header->LastPredecessor();\n  DCHECK(backedge->LastOperation(*input_graph_).Is<GotoOp>());\n  DCHECK_EQ(backedge->LastOperation(*input_graph_).Cast<GotoOp>().destination,\n            header);\n  DCHECK_GE(backedge->index().id(), header->index().id());\n\n  LoopInfo info;\n  // The header is skipped by the while-loop below, so we initialize {info} with\n  // the `op_count` from {header}, and a `block_count` of 1 (= the header).\n  info.op_count = header->OpCountUpperBound();\n  info.start = header;\n  info.end = backedge;\n  info.block_count = 1;\n\n  queue_.clear();\n  queue_.push_back(backedge);\n  while (!queue_.empty()) {\n    const Block* curr = queue_.back();\n    queue_.pop_back();\n    if (curr == header) continue;\n    if (loop_headers_[curr->index()] != nullptr) {\n      const Block* curr_parent = loop_headers_[curr->index()];\n      if (curr_parent == header) {\n        // If {curr}'s parent is already marked as being {header}, then we've\n        // already visited {curr}.\n        continue;\n      } else {\n        // If {curr}'s parent is not {header}, then {curr} is part of an inner\n        // loop. We should continue the search on the loop header: the\n        // predecessors of {curr} will all be in this inner loop.\n        queue_.push_back(curr_parent);\n        info.has_inner_loops = true;\n        continue;\n      }\n    }\n    info.block_count++;\n    info.op_count += curr->OpCountUpperBound();\n    loop_headers_[curr->index()] = header;\n    const Block* pred_start = curr->LastPredecessor();\n    if (curr->IsLoop()) {\n      // Skipping the backedge of inner loops since we don't want to visit inner\n      // loops now (they should already have been visited).\n      DCHECK_NOT_NULL(pred_start);\n      pred_start = pred_start->NeighboringPredecessor();\n      info.has_inner_loops = true;\n    }\n    for (const Block* pred : NeighboringPredecessorIterable(pred_start)) {\n      queue_.push_back(pred);\n    }\n  }\n\n  return info;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetLoopBody\",\n                \"parent\": \"LoopFinder\",\n                \"about\": \"Returns a set of blocks that constitute the body of the loop.\",\n                \"logic\": \"Performs a breadth-first search to collect all blocks reachable from the loop's backedge, excluding the header itself. It asserts that the loop has no inner loops (as this function is intended for simple loops).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"loop_header\",\n                        \"type\": \"const Block*\",\n                        \"purpose\": \"The header block of the loop.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ZoneSet<const Block*, LoopFinder::BlockCmp>\",\n                    \"description\": \"A set containing all blocks in the loop body.\"\n                },\n                \"dependencies\": [\n                    \"GetLoopInfo\",\n                    \"ZoneSet\",\n                    \"queue_\",\n                    \"Block::LastPredecessor\",\n                    \"NeighboringPredecessor\",\n                    \"find\",\n                    \"end\",\n                    \"insert\",\n                    \"empty\",\n                    \"back\",\n                    \"pop_back\",\n                    \"push_back\",\n                    \"DCHECK\",\n                    \"has_inner_loops\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nZoneSet<const Block*, LoopFinder::BlockCmp> LoopFinder::GetLoopBody(\n    const Block* loop_header) {\n  DCHECK(!GetLoopInfo(loop_header).has_inner_loops);\n  ZoneSet<const Block*, BlockCmp> body(phase_zone_);\n  body.insert(loop_header);\n\n  ZoneVector<const Block*> queue(phase_zone_);\n  queue.push_back(loop_header->LastPredecessor());\n  while (!queue.empty()) {\n    const Block* curr = queue.back();\n    queue.pop_back();\n    if (body.find(curr) != body.end()) continue;\n    body.insert(curr);\n    for (const Block* pred = curr->LastPredecessor(); pred != nullptr;\n         pred = pred->NeighboringPredecessor()) {\n      if (pred == loop_header) continue;\n      queue.push_back(pred);\n    }\n  }\n\n  return body;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetLoopInfo\",\n                \"parent\": \"LoopFinder\",\n                \"about\": \"Retrieves the `LoopInfo` for a given loop header.\",\n                \"logic\": \"Looks up the `LoopInfo` in the `loop_header_info_` map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"loop_header\",\n                        \"type\": \"const Block*\",\n                        \"purpose\": \"The header block of the loop.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"LoopInfo\",\n                    \"description\": \"The `LoopInfo` associated with the loop header.\"\n                },\n                \"dependencies\": [\n                    \"loop_header_info_\",\n                    \"find\",\n                    \"end\",\n                    \"DCHECK\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  LoopInfo LoopFinder::GetLoopInfo(const Block* loop_header) const {\n    auto it = loop_header_info_.find(loop_header);\n    DCHECK(it != loop_header_info_.end());\n    return it->second;\n  }\n        ]]></code>\n    </func>\n</file>\n```"
}