{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/deserializer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 115, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/deserializer.h\",\n        \"file_name\": \"deserializer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the Deserializer class for reconstructing object graphs from snapshots, used during V8's startup and code loading processes.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for data structures, memory management, object representation, and snapshot handling.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <utility>\n#include <vector>\n\n#include \"src/base/macros.h\"\n#include \"src/common/globals.h\"\n#include \"src/execution/local-isolate.h\"\n#include \"src/handles/global-handles.h\"\n#include \"src/objects/allocation-site.h\"\n#include \"src/objects/api-callbacks.h\"\n#include \"src/objects/backing-store.h\"\n#include \"src/objects/code.h\"\n#include \"src/objects/map.h\"\n#include \"src/objects/objects.h\"\n#include \"src/objects/string-table.h\"\n#include \"src/objects/string.h\"\n#include \"src/snapshot/serializer-deserializer.h\"\n#include \"src/snapshot/snapshot-source-sink.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Deserializer\",\n            \"extends\": \"SerializerDeserializer\",\n            \"about\": \"Deserializes a snapshot to reconstruct the object graph. This class handles the process of reading a snapshot and creating the corresponding objects in memory.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"IsolateT*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Cached pointer to the isolate.\"\n                },\n                {\n                    \"name\": \"attached_objects_\",\n                    \"type\": \"DirectHandleVector<HeapObject>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores objects attached from serialized user code.\"\n                },\n                {\n                    \"name\": \"source_\",\n                    \"type\": \"SnapshotByteSource\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides the byte stream to read the snapshot from.\"\n                },\n                {\n                    \"name\": \"magic_number_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores a magic number for snapshot validation.\"\n                },\n                {\n                    \"name\": \"hot_objects_\",\n                    \"type\": \"HotObjectsList\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Circular queue of hot objects.\"\n                },\n                {\n                    \"name\": \"new_maps_\",\n                    \"type\": \"DirectHandleVector<Map>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores newly created maps.\"\n                },\n                {\n                    \"name\": \"new_allocation_sites_\",\n                    \"type\": \"DirectHandleVector<AllocationSite>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores newly created allocation sites.\"\n                },\n                {\n                    \"name\": \"new_code_objects_\",\n                    \"type\": \"DirectHandleVector<InstructionStream>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores newly created code objects.\"\n                },\n                {\n                    \"name\": \"accessor_infos_\",\n                    \"type\": \"DirectHandleVector<AccessorInfo>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores newly created accessor infos.\"\n                },\n                {\n                    \"name\": \"function_template_infos_\",\n                    \"type\": \"DirectHandleVector<FunctionTemplateInfo>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores newly created function template infos.\"\n                },\n                {\n                    \"name\": \"new_scripts_\",\n                    \"type\": \"DirectHandleVector<Script>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores newly created scripts.\"\n                },\n                {\n                    \"name\": \"backing_stores_\",\n                    \"type\": \"std::vector<std::shared_ptr<BackingStore>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores backing stores.\"\n                },\n                {\n                    \"name\": \"new_descriptor_arrays_\",\n                    \"type\": \"GlobalHandleVector<DescriptorArray>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores newly created descriptor arrays.\"\n                },\n                {\n                    \"name\": \"back_refs_\",\n                    \"type\": \"std::vector<IndirectHandle<HeapObject>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores back references to allocated objects.\"\n                },\n                {\n                    \"name\": \"js_dispatch_entries_\",\n                    \"type\": \"std::vector<JSDispatchHandle>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores already allocated JSDispatchTable entries.\"\n                },\n                {\n                    \"name\": \"unresolved_forward_refs_\",\n                    \"type\": \"std::vector<UnresolvedForwardRef>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores unresolved forward references.\"\n                },\n                {\n                    \"name\": \"num_unresolved_forward_refs_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Keeps track of the number of unresolved forward references.\"\n                },\n                {\n                    \"name\": \"deserializing_user_code_\",\n                    \"type\": \"const bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if user code is being deserialized.\"\n                },\n                {\n                    \"name\": \"next_reference_is_weak_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the next reference is weak.\"\n                },\n                {\n                    \"name\": \"next_reference_is_indirect_pointer_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the next reference is an indirect pointer.\"\n                },\n                {\n                    \"name\": \"next_reference_is_protected_pointer\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the next reference is a protected pointer\"\n                },\n                {\n                    \"name\": \"should_rehash_\",\n                    \"type\": \"const bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to indicate whether rehashing is needed.\"\n                },\n                {\n                    \"name\": \"to_rehash_\",\n                    \"type\": \"DirectHandleVector<HeapObject>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Objects that need rehashing.\"\n                },\n                {\n                    \"name\": \"no_gc_stats_\",\n                    \"type\": \"DisableGCStats\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Object to disable GC stats during deserialization.\"\n                },\n                {\n                    \"name\": \"depth_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Keeps track of the recursion depth\"\n                }\n            ],\n            \"dependencies\": [\n                \"SerializerDeserializer\",\n                \"HeapObject\",\n                \"Object\",\n                \"SnapshotByteSource\",\n                \"AllocationSite\",\n                \"InstructionStream\",\n                \"Map\",\n                \"AccessorInfo\",\n                \"FunctionTemplateInfo\",\n                \"Script\",\n                \"BackingStore\",\n                \"DescriptorArray\",\n                \"StringTableKey\",\n                \"String\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename IsolateT>\nclass Deserializer : public SerializerDeserializer {\n public:\n  ~Deserializer() override;\n  Deserializer(const Deserializer&) = delete;\n  Deserializer& operator=(const Deserializer&) = delete;\n\n protected:\n  // Create a deserializer from a snapshot byte source.\n  Deserializer(IsolateT* isolate, base::Vector<const uint8_t> payload,\n               uint32_t magic_number, bool deserializing_user_code,\n               bool can_rehash);\n\n  void DeserializeDeferredObjects();\n\n  // Create Log events for newly deserialized objects.\n  void LogNewObjectEvents();\n  void LogScriptEvents(Tagged<Script> script);\n  void LogNewMapEvents();\n\n  // Descriptor arrays are deserialized as \"strong\", so that there is no risk of\n  // them getting trimmed during a partial deserialization. This method makes\n  // them \"weak\" again after deserialization completes.\n  void WeakenDescriptorArrays();\n\n  // This returns the address of an object that has been described in the\n  // snapshot by object vector index.\n  Handle<HeapObject> GetBackReferencedObject();\n  Handle<HeapObject> GetBackReferencedObject(uint32_t index);\n\n  // Add an object to back an attached reference. The order to add objects must\n  // mirror the order they are added in the serializer.\n  void AddAttachedObject(DirectHandle<HeapObject> attached_object) {\n    attached_objects_.push_back(attached_object);\n  }\n\n  IsolateT* isolate() const { return isolate_; }\n\n  Isolate* main_thread_isolate() const { return isolate_->AsIsolate(); }\n\n  SnapshotByteSource* source() { return &source_; }\n\n  base::Vector<const DirectHandle<AllocationSite>> new_allocation_sites()\n      const {\n    return {new_allocation_sites_.data(), new_allocation_sites_.size()};\n  }\n  base::Vector<const DirectHandle<InstructionStream>> new_code_objects() const {\n    return {new_code_objects_.data(), new_code_objects_.size()};\n  }\n  base::Vector<const DirectHandle<Map>> new_maps() const {\n    return {new_maps_.data(), new_maps_.size()};\n  }\n  base::Vector<const DirectHandle<AccessorInfo>> accessor_infos() const {\n    return {accessor_infos_.data(), accessor_infos_.size()};\n  }\n  base::Vector<const DirectHandle<FunctionTemplateInfo>>\n  function_template_infos() const {\n    return {function_template_infos_.data(), function_template_infos_.size()};\n  }\n  base::Vector<const DirectHandle<Script>> new_scripts() const {\n    return {new_scripts_.data(), new_scripts_.size()};\n  }\n\n  std::shared_ptr<BackingStore> backing_store(size_t i) {\n    DCHECK_LT(i, backing_stores_.size());\n    return backing_stores_[i];\n  }\n\n  bool deserializing_user_code() const { return deserializing_user_code_; }\n  bool should_rehash() const { return should_rehash_; }\n\n  void PushObjectToRehash(DirectHandle<HeapObject> object) {\n    to_rehash_.push_back(object);\n  }\n  void Rehash();\n\n  DirectHandle<HeapObject> ReadObject();\n\n private:\n  // A circular queue of hot objects. This is added to in the same order as in\n  // Serializer::HotObjectsList, but this stores the objects as a vector of\n  // existing handles. This allows us to add Handles to the queue without having\n  // to create new handles. Note that this depends on those Handles staying\n  // valid as long as the HotObjectsList is alive.\n  class HotObjectsList {\n   public:\n    HotObjectsList() = default;\n    HotObjectsList(const HotObjectsList&) = delete;\n    HotObjectsList& operator=(const HotObjectsList&) = delete;\n\n    void Add(DirectHandle<HeapObject> object) {\n      circular_queue_[index_] = object;\n      index_ = (index_ + 1) & kSizeMask;\n    }\n\n    DirectHandle<HeapObject> Get(int index) {\n      DCHECK(!circular_queue_[index].is_null());\n      return circular_queue_[index];\n    }\n\n   private:\n    static const int kSize = kHotObjectCount;\n    static const int kSizeMask = kSize - 1;\n    static_assert(base::bits::IsPowerOfTwo(kSize));\n    DirectHandle<HeapObject> circular_queue_[kSize];\n    int index_ = 0;\n  };\n\n  struct ReferenceDescriptor {\n    HeapObjectReferenceType type;\n    bool is_indirect_pointer;\n    bool is_protected_pointer;\n  };\n\n  void VisitRootPointers(Root root, const char* description,\n                         FullObjectSlot start, FullObjectSlot end) override;\n\n  void Synchronize(VisitorSynchronization::SyncTag tag) override;\n\n  template <typename SlotAccessor>\n  int WriteHeapPointer(SlotAccessor slot_accessor,\n                       Tagged<HeapObject> heap_object,\n                       ReferenceDescriptor descr,\n                       WriteBarrierMode mode = UPDATE_WRITE_BARRIER);\n  template <typename SlotAccessor>\n  int WriteHeapPointer(SlotAccessor slot_accessor,\n                       DirectHandle<HeapObject> heap_object,\n                       ReferenceDescriptor descr,\n                       WriteBarrierMode mode = UPDATE_WRITE_BARRIER);\n\n  inline int WriteExternalPointer(Tagged<HeapObject> host,\n                                  ExternalPointerSlot dest, Address value,\n                                  ExternalPointerTag tag);\n  inline int WriteIndirectPointer(IndirectPointerSlot dest,\n                                  Tagged<HeapObject> value);\n\n  // Fills in a heap object's data from start to end (exclusive). Start and end\n  // are slot indices within the object.\n  void ReadData(Handle<HeapObject> object, int start_slot_index,\n                int end_slot_index);\n\n  // Fills in a contiguous range of full object slots (e.g. root pointers) from\n  // start to end (exclusive).\n  void ReadData(FullMaybeObjectSlot start, FullMaybeObjectSlot end);\n\n  // Helper for ReadData which reads the given bytecode and fills in some heap\n  // data into the given slot. May fill in zero or multiple slots, so it returns\n  // the number of slots filled.\n  template <typename SlotAccessor>\n  int ReadSingleBytecodeData(uint8_t data, SlotAccessor slot_accessor);\n\n  template <typename SlotAccessor>\n  int ReadNewObject(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadBackref(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadReadOnlyHeapRef(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadRootArray(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadStartupObjectCache(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadSharedHeapObjectCache(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadNewMetaMap(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadExternalReference(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadRawExternalReference(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadAttachedReference(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadRegisterPendingForwardRef(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadResolvePendingForwardRef(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadVariableRawData(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadVariableRepeatRoot(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadOffHeapBackingStore(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadApiReference(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadClearedWeakReference(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadWeakPrefix(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadIndirectPointerPrefix(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadInitializeSelfIndirectPointer(uint8_t data,\n                                        SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadAllocateJSDispatchEntry(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadJSDispatchEntry(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadProtectedPointerPrefix(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadRootArrayConstants(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadHotObject(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadFixedRawData(uint8_t data, SlotAccessor slot_accessor);\n  template <typename SlotAccessor>\n  int ReadFixedRepeatRoot(uint8_t data, SlotAccessor slot_accessor);\n\n  // A helper function for ReadData for reading external references.\n  inline Address ReadExternalReferenceCase();\n\n  // A helper function for reading external pointer tags.\n  ExternalPointerTag ReadExternalPointerTag();\n\n  Handle<HeapObject> ReadObject(SnapshotSpace space);\n  Handle<HeapObject> ReadMetaMap(SnapshotSpace space);\n\n  ReferenceDescriptor GetAndResetNextReferenceDescriptor();\n\n  template <typename SlotGetter>\n  int ReadRepeatedRoot(SlotGetter slot_getter, int repeat_count);\n\n  // Special handling for serialized code like hooking up internalized strings.\n  void PostProcessNewObject(DirectHandle<Map> map, Handle<HeapObject> obj,\n                            SnapshotSpace space);\n  void PostProcessNewJSReceiver(Tagged<Map> map, DirectHandle<JSReceiver> obj,\n                                InstanceType instance_type,\n                                SnapshotSpace space);\n\n  Tagged<HeapObject> Allocate(AllocationType allocation, int size,\n                              AllocationAlignment alignment);\n\n  // Cached current isolate.\n  IsolateT* isolate_;\n\n  // Objects from the attached object descriptions in the serialized user code.\n  DirectHandleVector<HeapObject> attached_objects_;\n\n  SnapshotByteSource source_;\n  uint32_t magic_number_;\n\n  HotObjectsList hot_objects_;\n  DirectHandleVector<Map> new_maps_;\n  DirectHandleVector<AllocationSite> new_allocation_sites_;\n  DirectHandleVector<InstructionStream> new_code_objects_;\n  DirectHandleVector<AccessorInfo> accessor_infos_;\n  DirectHandleVector<FunctionTemplateInfo> function_template_infos_;\n  DirectHandleVector<Script> new_scripts_;\n  std::vector<std::shared_ptr<BackingStore>> backing_stores_;\n\n  // Roots vector as those arrays are passed to Heap, see\n  // WeakenDescriptorArrays().\n  GlobalHandleVector<DescriptorArray> new_descriptor_arrays_;\n\n  // Vector of allocated objects that can be accessed by a backref, by index.\n  std::vector<IndirectHandle<HeapObject>> back_refs_;\n\n  // Vector of already allocated JSDispatchTable entries.\n  std::vector<JSDispatchHandle> js_dispatch_entries_;\n\n  // Unresolved forward references (registered with kRegisterPendingForwardRef)\n  // are collected in order as (object, field offset) pairs. The subsequent\n  // forward ref resolution (with kResolvePendingForwardRef) accesses this\n  // vector by index.\n  //\n  // The vector is cleared when there are no more unresolved forward refs.\n  struct UnresolvedForwardRef {\n    UnresolvedForwardRef(Handle<HeapObject> object, int offset,\n                         ReferenceDescriptor descr)\n        : object(object), offset(offset), descr(descr) {}\n\n    IndirectHandle<HeapObject> object;\n    int offset;\n    ReferenceDescriptor descr;\n  };\n  std::vector<UnresolvedForwardRef> unresolved_forward_refs_;\n  int num_unresolved_forward_refs_ = 0;\n\n  const bool deserializing_user_code_;\n\n  bool next_reference_is_weak_ = false;\n  bool next_reference_is_indirect_pointer_ = false;\n  bool next_reference_is_protected_pointer = false;\n\n  // TODO(6593): generalize rehashing, and remove this flag.\n  const bool should_rehash_;\n  DirectHandleVector<HeapObject> to_rehash_;\n\n  // Do not collect any gc stats during deserialization since objects might\n  // be in an invalid state\n  class V8_NODISCARD DisableGCStats {\n   public:\n    DisableGCStats() {\n      original_gc_stats_ = TracingFlags::gc_stats;\n      TracingFlags::gc_stats = 0;\n    }\n    ~DisableGCStats() { TracingFlags::gc_stats = original_gc_stats_; }\n\n   private:\n    unsigned int original_gc_stats_;\n  };\n  DisableGCStats no_gc_stats_;\n\n  int depth_ = 0;\n\n#ifdef DEBUG\n  uint32_t num_api_references_;\n\n  // Record the previous object allocated for DCHECKs.\n  DirectHandle<HeapObject> previous_allocation_obj_;\n  int previous_allocation_size_ = 0;\n#endif  // DEBUG\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"HotObjectsList\",\n            \"parent\": \"Deserializer\",\n            \"about\": \"A circular queue for storing hot objects during deserialization, optimizing access to frequently referenced objects.\",\n            \"attributes\": [\n                {\n                    \"name\": \"circular_queue_\",\n                    \"type\": \"DirectHandle<HeapObject>[kSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The circular queue storing the hot objects.\"\n                },\n                {\n                    \"name\": \"index_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current index within the circular queue.\"\n                }\n            ],\n            \"dependencies\": [\n                \"HeapObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class HotObjectsList {\n   public:\n    HotObjectsList() = default;\n    HotObjectsList(const HotObjectsList&) = delete;\n    HotObjectsList& operator=(const HotObjectsList&) = delete;\n\n    void Add(DirectHandle<HeapObject> object) {\n      circular_queue_[index_] = object;\n      index_ = (index_ + 1) & kSizeMask;\n    }\n\n    DirectHandle<HeapObject> Get(int index) {\n      DCHECK(!circular_queue_[index].is_null());\n      return circular_queue_[index];\n    }\n\n   private:\n    static const int kSize = kHotObjectCount;\n    static const int kSizeMask = kSize - 1;\n    static_assert(base::bits::IsPowerOfTwo(kSize));\n    DirectHandle<HeapObject> circular_queue_[kSize];\n    int index_ = 0;\n  };\n        ]]></code>\n    </class>\n\n   <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ReferenceDescriptor\",\n            \"parent\": \"Deserializer\",\n            \"about\": \"Describes the type of reference being deserialized.\",\n            \"attributes\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"HeapObjectReferenceType\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The type of reference.\"\n                },\n                {\n                    \"name\": \"is_indirect_pointer\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates if the reference is an indirect pointer.\"\n                },\n                {\n                    \"name\": \"is_protected_pointer\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates if the reference is a protected pointer\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  struct ReferenceDescriptor {\n    HeapObjectReferenceType type;\n    bool is_indirect_pointer;\n    bool is_protected_pointer;\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"UnresolvedForwardRef\",\n            \"parent\": \"Deserializer\",\n            \"about\": \"Represents an unresolved forward reference during deserialization.\",\n            \"attributes\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"IndirectHandle<HeapObject>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The object containing the forward reference.\"\n                },\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The offset within the object where the reference is located.\"\n                },\n                {\n                    \"name\": \"descr\",\n                    \"type\": \"ReferenceDescriptor\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The reference descriptor\"\n                }\n            ],\n            \"dependencies\": [\n                \"HeapObject\",\n                \"ReferenceDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  struct UnresolvedForwardRef {\n    UnresolvedForwardRef(Handle<HeapObject> object, int offset,\n                         ReferenceDescriptor descr)\n        : object(object), offset(offset), descr(descr) {}\n\n    IndirectHandle<HeapObject> object;\n    int offset;\n    ReferenceDescriptor descr;\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DisableGCStats\",\n            \"parent\": \"Deserializer\",\n            \"about\": \"A helper class to disable GC stats during deserialization.\",\n            \"attributes\": [\n                {\n                    \"name\": \"original_gc_stats_\",\n                    \"type\": \"unsigned int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the original value of the gc_stats tracing flag.\"\n                }\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class V8_NODISCARD DisableGCStats {\n   public:\n    DisableGCStats() {\n      original_gc_stats_ = TracingFlags::gc_stats;\n      TracingFlags::gc_stats = 0;\n    }\n    ~DisableGCStats() { TracingFlags::gc_stats = original_gc_stats_; }\n\n   private:\n    unsigned int original_gc_stats_;\n  };\n        ]]></code>\n    </class>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"DeserializingUserCodeOption\",\n            \"about\": \"Enum to represent if user code is being deserialized.\"\n        }\n        </metadata>\n        <code><![CDATA[\nenum class DeserializingUserCodeOption {\n  kNotDeserializingUserCode,\n  kIsDeserializingUserCode\n};\n        ]]></code>\n    </enum>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StringTableInsertionKey\",\n            \"extends\": \"StringTableKey\",\n            \"about\": \"Key used for inserting deserialized internalized strings into the string table.\",\n            \"attributes\": [\n                {\n                    \"name\": \"string_\",\n                    \"type\": \"DirectHandle<String>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The string being inserted.\"\n                }\n            ],\n            \"dependencies\": [\n                \"StringTableKey\",\n                \"String\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass StringTableInsertionKey final : public StringTableKey {\n public:\n  explicit StringTableInsertionKey(\n      Isolate* isolate, DirectHandle<String> string,\n      DeserializingUserCodeOption deserializing_user_code);\n  explicit StringTableInsertionKey(\n      LocalIsolate* isolate, DirectHandle<String> string,\n      DeserializingUserCodeOption deserializing_user_code);\n\n  template <typename IsolateT>\n  bool IsMatch(IsolateT* isolate, Tagged<String> string);\n\n  void PrepareForInsertion(Isolate* isolate) {\n    // When sharing the string table, all string table lookups during snapshot\n    // deserialization are hits.\n    DCHECK(isolate->OwnsStringTables() ||\n           deserializing_user_code_ ==\n               DeserializingUserCodeOption::kIsDeserializingUserCode);\n  }\n  void PrepareForInsertion(LocalIsolate* isolate) {}\n  V8_WARN_UNUSED_RESULT DirectHandle<String> GetHandleForInsertion(\n      Isolate* isolate) {\n    return string_;\n  }\n\n private:\n  DirectHandle<String> string_;\n#ifdef DEBUG\n  DeserializingUserCodeOption deserializing_user_code_;\n#endif\n  DISALLOW_GARBAGE_COLLECTION(no_gc)\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"V8_CODE_EMBEDS_OBJECT_POINTER\",\n            \"about\": \"A macro definition to determine if the target architecture embeds object pointers directly in the generated code.\",\n            \"logic\": \"Determines whether code embeds object pointers based on target architecture or a global flag. The macro expands to '1' if object pointers are embedded, and '0' otherwise.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#if defined(V8_TARGET_ARCH_MIPS64) || defined(V8_TARGET_ARCH_S390X) ||  \\\n    defined(V8_TARGET_ARCH_PPC64) || defined(V8_TARGET_ARCH_RISCV32) || \\\n    defined(V8_TARGET_ARCH_RISCV64) || V8_EMBEDDED_CONSTANT_POOL_BOOL\n#define V8_CODE_EMBEDS_OBJECT_POINTER 1\n#else\n#define V8_CODE_EMBEDS_OBJECT_POINTER 0\n#endif\n        ]]></code>\n    </func>\n</file>\n```"
}