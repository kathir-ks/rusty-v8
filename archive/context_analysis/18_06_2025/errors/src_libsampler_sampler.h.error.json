{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/libsampler/sampler.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 88, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/libsampler/sampler.h\",\n        \"file_name\": \"sampler.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Sampler class and related classes for sampling the state of the V8 VM, especially for profiling purposes.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8 specific headers for data structures, memory management, and OS-specific configurations.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <atomic>\n            #include <memory>\n            #include <unordered_map>\n            #include <vector>\n\n            #include \"src/base/lazy-instance.h\"\n            #include \"src/base/macros.h\"\n\n            #if V8_OS_POSIX && !V8_OS_CYGWIN && !V8_OS_FUCHSIA\n            #define USE_SIGNALS\n            #endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Sampler\",\n            \"about\": \"Abstract base class for sampling the VM state. Can be used for profiling to capture program counter and stack pointer.\",\n            \"attributes\": [\n                {\n                    \"name\": \"is_counting_samples_\",\n                    \"type\": \"bool\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Indicates whether stack samples are being counted.\"\n                },\n                {\n                    \"name\": \"js_sample_count_\",\n                    \"type\": \"unsigned\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Counts stack samples taken in JavaScript code.\"\n                },\n                {\n                    \"name\": \"external_sample_count_\",\n                    \"type\": \"unsigned\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Counts stack samples taken in external (non-JavaScript) code.\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the V8 Isolate.\"\n                },\n                {\n                    \"name\": \"active_\",\n                    \"type\": \"std::atomic_bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Atomic boolean indicating whether the sampler is active.\"\n                },\n                {\n                    \"name\": \"record_sample_\",\n                    \"type\": \"std::atomic_bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Atomic boolean to signal if a sample should be recorded.\"\n                },\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"std::unique_ptr<PlatformData>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Platform-specific data.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"RegisterState\",\n                \"PlatformData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE Sampler {\n            public:\n            static const int kMaxFramesCountLog2 = 8;\n            static const unsigned kMaxFramesCount = (1u << kMaxFramesCountLog2) - 1;\n\n            // Initialize sampler.\n            explicit Sampler(Isolate* isolate);\n            virtual ~Sampler();\n\n            Isolate* isolate() const { return isolate_; }\n\n            // Performs stack sampling.\n            // Clients should override this method in order to do something on samples,\n            // for example buffer samples in a queue.\n            virtual void SampleStack(const v8::RegisterState& regs) = 0;\n\n            // Start and stop sampler.\n            void Start();\n            void Stop();\n\n            // Whether the sampler is running (start has been called).\n            bool IsActive() const { return active_.load(std::memory_order_relaxed); }\n\n            // Returns true and consumes the pending sample bit if a sample should be\n            // dispatched to this sampler.\n            bool ShouldRecordSample() {\n                return record_sample_.exchange(false, std::memory_order_relaxed);\n            }\n\n            void DoSample();\n\n            // Used in tests to make sure that stack sampling is performed.\n            unsigned js_sample_count() const { return js_sample_count_; }\n            unsigned external_sample_count() const { return external_sample_count_; }\n            void StartCountingSamples() {\n                js_sample_count_ = 0;\n                external_sample_count_ = 0;\n                is_counting_samples_ = true;\n            }\n\n            class PlatformData;\n            PlatformData* platform_data() const { return data_.get(); }\n\n            protected:\n            // Counts stack samples taken in various VM states.\n            bool is_counting_samples_ = false;\n            unsigned js_sample_count_ = 0;\n            unsigned external_sample_count_ = 0;\n\n            void SetActive(bool value) {\n                active_.store(value, std::memory_order_relaxed);\n            }\n\n            void SetShouldRecordSample() {\n                record_sample_.store(true, std::memory_order_relaxed);\n            }\n\n            Isolate* isolate_;\n            std::atomic_bool active_{false};\n            std::atomic_bool record_sample_{false};\n            std::unique_ptr<PlatformData> data_;  // Platform specific data.\n            DISALLOW_IMPLICIT_CONSTRUCTORS(Sampler);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AtomicGuard\",\n            \"about\": \"A helper class that uses std::atomic_bool to implement a lock, acquired on construction and released on destruction.\",\n            \"attributes\": [\n                {\n                    \"name\": \"atomic_\",\n                    \"type\": \"AtomicMutex* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the atomic mutex.\"\n                },\n                {\n                    \"name\": \"is_success_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the lock was successfully obtained in the constructor.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AtomicMutex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using AtomicMutex = std::atomic_bool;\n\n            // A helper that uses an std::atomic_bool to create a lock that is obtained on\n            // construction and released on destruction.\n            class V8_EXPORT_PRIVATE V8_NODISCARD AtomicGuard {\n            public:\n            // Attempt to obtain the lock represented by |atomic|. |is_blocking|\n            // determines whether we will block to obtain the lock, or only make one\n            // attempt to gain the lock and then stop. If we fail to gain the lock,\n            // is_success will be false.\n            explicit AtomicGuard(AtomicMutex* atomic, bool is_blocking = true);\n\n            // Releases the lock represented by atomic, if it is held by this guard.\n            ~AtomicGuard();\n\n            // Whether the lock was successfully obtained in the constructor. This will\n            // always be true if is_blocking was true.\n            bool is_success() const;\n\n            private:\n            AtomicMutex* const atomic_;\n            bool is_success_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SamplerManager\",\n            \"about\": \"Manages a list of Samplers per thread, allowing the caller to trigger a sample for each Sampler on the current thread.\",\n            \"attributes\": [\n                {\n                    \"name\": \"sampler_map_\",\n                    \"type\": \"std::unordered_map<int, SamplerList>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of thread IDs to lists of Samplers.\"\n                },\n                {\n                    \"name\": \"samplers_access_counter_\",\n                    \"type\": \"AtomicMutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Atomic mutex to protect access to the sampler map.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Sampler\",\n                \"SamplerList\",\n                \"AtomicMutex\",\n                \"RegisterState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // SamplerManager keeps a list of Samplers per thread, and allows the caller to\n            // take a sample for every Sampler on the current thread.\n            class V8_EXPORT_PRIVATE SamplerManager {\n            public:\n            using SamplerList = std::vector<Sampler*>;\n\n            SamplerManager(const SamplerManager&) = delete;\n            SamplerManager& operator=(const SamplerManager&) = delete;\n\n            // Add |sampler| to the map if it is not already present.\n            void AddSampler(Sampler* sampler);\n\n            // If |sampler| exists in the map, remove it and delete the SamplerList if\n            // |sampler| was the last sampler in the list.\n            void RemoveSampler(Sampler* sampler);\n\n            // Take a sample for every sampler on the current thread. This function can\n            // return without taking samples if AddSampler or RemoveSampler are being\n            // concurrently called on any thread.\n            void DoSample(const v8::RegisterState& state);\n\n            // Get the lazily instantiated, global SamplerManager instance.\n            static SamplerManager* instance();\n\n            private:\n            SamplerManager() = default;\n            // Must be a friend so that it can access the private constructor for the\n            // global lazy instance.\n            friend class base::LeakyObject<SamplerManager>;\n\n            std::unordered_map<int, SamplerList> sampler_map_;\n            AtomicMutex samplers_access_counter_{false};\n            };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {};\n            ]]></code>\n        </class>\n        <struct>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"RegisterState\",\n                \"about\": \"Represents the state of CPU registers.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                struct RegisterState {};\n            ]]></code>\n        </struct>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PlatformData\",\n                \"about\": \"Abstracts platform-specific data required by the sampler.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class PlatformData {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"base::LeakyObject\",\n                \"about\": \"A base class for creating leaky singleton objects.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base {\n                    template <typename T>\n                    class LeakyObject {};\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}