{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/shared-heap-serializer.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 52, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/shared-heap-serializer.cc\",\n            \"file_name\": \"shared-heap-serializer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Serializes the shared heap for V8 snapshots, enabling sharing of certain objects (primarily internalized strings) between isolates to reduce memory usage.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for shared heap serialization, heap management, object representation, and read-only snapshot serialization.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/shared-heap-serializer.h\"\n\n#include \"src/heap/read-only-heap.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/snapshot/read-only-serializer.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CanBeInSharedOldSpace\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Determines whether a given heap object can reside in the shared old space.\",\n                \"logic\": \"Checks if the object is not in the read-only heap and, if it's a string, whether it's internalized or internalizable in-place.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The heap object to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object can be in shared old space, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"ReadOnlyHeap\",\n                    \"IsString\",\n                    \"IsInternalizedString\",\n                    \"String::IsInPlaceInternalizable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nbool SharedHeapSerializer::CanBeInSharedOldSpace(Tagged<HeapObject> obj) {\n  if (ReadOnlyHeap::Contains(obj)) return false;\n  if (IsString(obj)) {\n    return IsInternalizedString(obj) ||\n           String::IsInPlaceInternalizable(Cast<String>(obj));\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ShouldBeInSharedHeapObjectCache\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Determines whether a given heap object should be included in the shared heap object cache.\",\n                \"logic\": \"Only internalized strings are included in the cache to avoid duplication and ensure they stay alive. In-place internalizable strings are allocated in the shared heap but are not cached permanently.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Tagged<HeapObject>\",\n                        \"purpose\": \"The heap object to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object should be in the cache, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"CanBeInSharedOldSpace\",\n                    \"IsInternalizedString\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nbool SharedHeapSerializer::ShouldBeInSharedHeapObjectCache(\n    Tagged<HeapObject> obj) {\n  // To keep the shared heap object cache lean, only include objects that should\n  // not be duplicated. Currently, that is only internalized strings. In-place\n  // internalizable strings will still be allocated in the shared heap by the\n  // deserializer, but do not need to be kept alive forever in the cache.\n  if (CanBeInSharedOldSpace(obj)) {\n    if (IsInternalizedString(obj)) return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SharedHeapSerializer\",\n                \"extends\": \"RootsSerializer\",\n                \"about\": \"Serializes the shared heap, responsible for writing shared objects (internalized strings) to the snapshot.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"RootsSerializer\",\n                    \"Isolate\",\n                    \"Snapshot::SerializerFlags\",\n                    \"RootIndex\",\n                    \"DEBUG\",\n                    \"IdentityMap\",\n                    \"HeapObject\",\n                    \"ReadOnlyRoots\",\n                    \"StringTable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass SharedHeapSerializer : public RootsSerializer {\n public:\n  SharedHeapSerializer(Isolate* isolate, Snapshot::SerializerFlags flags);\n  ~SharedHeapSerializer() override;\n\n  void FinalizeSerialization() override;\n\n  bool SerializeUsingSharedHeapObjectCache(SnapshotByteSink* sink,\n                                           Handle<HeapObject> obj);\n\n protected:\n  void SerializeObjectImpl(Handle<HeapObject> obj, SlotType slot_type) override;\n\n private:\n  void SerializeStringTable(StringTable* string_table);\n\n  bool ShouldReconstructSharedHeapObjectCacheForTesting() const;\n  void ReconstructSharedHeapObjectCacheForTesting();\n\n#ifdef DEBUG\n  IdentityMap<int, base::DefaultAllocationPolicy> serialized_objects_;\n#endif\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constructor\",\n                \"name\": \"SharedHeapSerializer\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Constructor for the SharedHeapSerializer class.\",\n                \"logic\": \"Initializes the RootsSerializer and potentially reconstructs the shared heap object cache for testing.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"flags\",\n                        \"type\": \"Snapshot::SerializerFlags\",\n                        \"purpose\": \"Flags for the serializer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"RootsSerializer\",\n                    \"ShouldReconstructSharedHeapObjectCacheForTesting\",\n                    \"ReconstructSharedHeapObjectCacheForTesting\",\n                    \"isolate->heap()\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSharedHeapSerializer::SharedHeapSerializer(Isolate* isolate,\n                                           Snapshot::SerializerFlags flags)\n    : RootsSerializer(isolate, flags, RootIndex::kFirstStrongRoot)\n#ifdef DEBUG\n      ,\n      serialized_objects_(isolate->heap())\n#endif\n{\n  if (ShouldReconstructSharedHeapObjectCacheForTesting()) {\n    ReconstructSharedHeapObjectCacheForTesting();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"destructor\",\n                \"name\": \"~SharedHeapSerializer\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Destructor for the SharedHeapSerializer class.\",\n                \"logic\": \"Outputs statistics about the serialization process.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"OutputStatistics\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSharedHeapSerializer::~SharedHeapSerializer() {\n  OutputStatistics(\"SharedHeapSerializer\");\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FinalizeSerialization\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Finalizes the serialization process.\",\n                \"logic\": \"Adds an undefined value to terminate the shared heap object cache, serializes the string table, serializes deferred objects, and pads the output.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"ReadOnlyRoots\",\n                    \"isolate().undefined_value\",\n                    \"VisitRootPointer\",\n                    \"Root::kSharedHeapObjectCache\",\n                    \"FullObjectSlot\",\n                    \"SerializeStringTable\",\n                    \"isolate()->string_table\",\n                    \"SerializeDeferredObjects\",\n                    \"Pad\",\n                    \"CanBeInSharedOldSpace\",\n                    \"ReadOnlyHeap::Contains\",\n                    \"Cast<HeapObject>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SharedHeapSerializer::FinalizeSerialization() {\n  // This is called after serialization of the startup and context snapshots\n  // which entries are added to the shared heap object cache. Terminate the\n  // cache with an undefined.\n  Tagged<Object> undefined = ReadOnlyRoots(isolate()).undefined_value();\n  VisitRootPointer(Root::kSharedHeapObjectCache, nullptr,\n                   FullObjectSlot(&undefined));\n\n  // When v8_flags.shared_string_table is true, all internalized and\n  // internalizable-in-place strings are in the shared heap.\n  SerializeStringTable(isolate()->string_table());\n  SerializeDeferredObjects();\n  Pad();\n\n#ifdef DEBUG\n  // Check that all serialized object are in shared heap and not RO. RO objects\n  // should be in the RO snapshot.\n  IdentityMap<int, base::DefaultAllocationPolicy>::IteratableScope it_scope(\n      &serialized_objects_);\n  for (auto it = it_scope.begin(); it != it_scope.end(); ++it) {\n    Tagged<HeapObject> obj = Cast<HeapObject>(it.key());\n    CHECK(CanBeInSharedOldSpace(obj));\n    CHECK(!ReadOnlyHeap::Contains(obj));\n  }\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeUsingSharedHeapObjectCache\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Serializes a heap object using the shared heap object cache.\",\n                \"logic\": \"Checks if the object should be in the cache. If so, it serializes the object's index in the cache into the snapshot byte sink. Also handles testing edge cases where the shared heap object cache may need to be reconstructed and extended.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"sink\",\n                        \"type\": \"SnapshotByteSink*\",\n                        \"purpose\": \"The byte sink to write the serialized data to.\"\n                    },\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"purpose\": \"The heap object to serialize.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the object was serialized using the shared heap object cache, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"ShouldBeInSharedHeapObjectCache\",\n                    \"SerializeInObjectCache\",\n                    \"ShouldReconstructSharedHeapObjectCacheForTesting\",\n                    \"isolate()->shared_space_isolate()->shared_heap_object_cache()\",\n                    \"kSharedHeapObjectCache\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool SharedHeapSerializer::SerializeUsingSharedHeapObjectCache(\n    SnapshotByteSink* sink, Handle<HeapObject> obj) {\n  if (!ShouldBeInSharedHeapObjectCache(*obj)) return false;\n  int cache_index = SerializeInObjectCache(obj);\n\n  // When testing deserialization of a snapshot from a live Isolate where there\n  // is also a shared Isolate, the shared object cache needs to be extended\n  // because the live isolate may have had new internalized strings that were\n  // not present in the startup snapshot to be serialized.\n  if (ShouldReconstructSharedHeapObjectCacheForTesting()) {\n    std::vector<Tagged<Object>>* existing_cache =\n        isolate()->shared_space_isolate()->shared_heap_object_cache();\n    const size_t existing_cache_size = existing_cache->size();\n    // This is strictly < because the existing cache contains the terminating\n    // undefined value, which the reconstructed cache does not.\n    DCHECK_LT(base::checked_cast<size_t>(cache_index), existing_cache_size);\n    if (base::checked_cast<size_t>(cache_index) == existing_cache_size - 1) {\n      ReadOnlyRoots roots(isolate());\n      DCHECK(IsUndefined(existing_cache->back(), roots));\n      existing_cache->back() = *obj;\n      existing_cache->push_back(roots.undefined_value());\n    }\n  }\n\n  sink->Put(kSharedHeapObjectCache, \"SharedHeapObjectCache\");\n  sink->PutUint30(cache_index, \"shared_heap_object_cache_index\");\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeStringTable\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Serializes the string table.\",\n                \"logic\": \"Serializes the number of elements in the string table and then iterates through the table, serializing each string entry using a custom RootVisitor. The hashmap structure is not serialized.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"string_table\",\n                        \"type\": \"StringTable*\",\n                        \"purpose\": \"The string table to serialize.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"sink_.PutUint30\",\n                    \"StringTable::NumberOfElements\",\n                    \"RootVisitor\",\n                    \"Root::kStringTable\",\n                    \"IsHeapObject\",\n                    \"IsInternalizedString\",\n                    \"SerializeObject\",\n                    \"handle\",\n                    \"Cast<HeapObject>\",\n                    \"SlotType::kAnySlot\",\n                    \"StringTable::IterateElements\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SharedHeapSerializer::SerializeStringTable(StringTable* string_table) {\n  // A StringTable is serialized as:\n  //\n  //   N : int\n  //   string 1\n  //   string 2\n  //   ...\n  //   string N\n  //\n  // Notably, the hashmap structure, including empty and deleted elements, is\n  // not serialized.\n\n  sink_.PutUint30(string_table->NumberOfElements(),\n                  \"String table number of elements\");\n\n  // Custom RootVisitor which walks the string table, but only serializes the\n  // string entries. This is an inline class to be able to access the non-public\n  // SerializeObject method.\n  class SharedHeapSerializerStringTableVisitor : public RootVisitor {\n   public:\n    explicit SharedHeapSerializerStringTableVisitor(\n        SharedHeapSerializer* serializer)\n        : serializer_(serializer) {}\n\n    void VisitRootPointers(Root root, const char* description,\n                           FullObjectSlot start, FullObjectSlot end) override {\n      UNREACHABLE();\n    }\n\n    void VisitRootPointers(Root root, const char* description,\n                           OffHeapObjectSlot start,\n                           OffHeapObjectSlot end) override {\n      DCHECK_EQ(root, Root::kStringTable);\n      Isolate* isolate = serializer_->isolate();\n      for (OffHeapObjectSlot current = start; current < end; ++current) {\n        Tagged<Object> obj = current.load(isolate);\n        if (IsHeapObject(obj)) {\n          DCHECK(IsInternalizedString(obj));\n          serializer_->SerializeObject(handle(Cast<HeapObject>(obj), isolate),\n                                       SlotType::kAnySlot);\n        }\n      }\n    }\n\n   private:\n    SharedHeapSerializer* serializer_;\n  };\n\n  SharedHeapSerializerStringTableVisitor string_table_visitor(this);\n  isolate()->string_table()->IterateElements(&string_table_visitor);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SerializeObjectImpl\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Serializes a heap object, ensuring it resides in the shared heap or read-only heap.\",\n                \"logic\": \"Checks if the object is hot or a root, and serializes it accordingly. Otherwise, uses ObjectSerializer to serialize the object and adds it to a set of serialized objects for debugging purposes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"obj\",\n                        \"type\": \"Handle<HeapObject>\",\n                        \"purpose\": \"The heap object to serialize.\"\n                    },\n                    {\n                        \"name\": \"slot_type\",\n                        \"type\": \"SlotType\",\n                        \"purpose\": \"The type of slot the object occupies.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"CanBeInSharedOldSpace\",\n                    \"ReadOnlyHeap::Contains\",\n                    \"SerializeHotObject\",\n                    \"IsRootAndHasBeenSerialized\",\n                    \"SerializeRoot\",\n                    \"SerializeReadOnlyObjectReference\",\n                    \"SerializeBackReference\",\n                    \"CheckRehashability\",\n                    \"ObjectSerializer\",\n                    \"serialized_objects_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SharedHeapSerializer::SerializeObjectImpl(Handle<HeapObject> obj,\n                                               SlotType slot_type) {\n  // Objects in the shared heap cannot depend on per-Isolate roots but can\n  // depend on RO roots since sharing objects requires sharing the RO space.\n  DCHECK(CanBeInSharedOldSpace(*obj) || ReadOnlyHeap::Contains(*obj));\n  {\n    DisallowGarbageCollection no_gc;\n    Tagged<HeapObject> raw = *obj;\n    if (SerializeHotObject(raw)) return;\n    if (IsRootAndHasBeenSerialized(raw) && SerializeRoot(raw)) return;\n  }\n  if (SerializeReadOnlyObjectReference(*obj, &sink_)) return;\n  {\n    DisallowGarbageCollection no_gc;\n    Tagged<HeapObject> raw = *obj;\n    if (SerializeBackReference(raw)) return;\n    CheckRehashability(raw);\n\n    DCHECK(!ReadOnlyHeap::Contains(raw));\n  }\n\n  ObjectSerializer object_serializer(this, obj, &sink_);\n  object_serializer.Serialize(slot_type);\n\n#ifdef DEBUG\n  CHECK_NULL(serialized_objects_.Find(obj));\n  // There's no \"IdentitySet\", so use an IdentityMap with a value that is\n  // later ignored.\n  serialized_objects_.Insert(obj, 0);\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ShouldReconstructSharedHeapObjectCacheForTesting\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Determines whether the shared heap object cache should be reconstructed for testing purposes.\",\n                \"logic\": \"Checks if reconstruction is enabled and if the isolate has a shared space.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the cache should be reconstructed, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"reconstruct_read_only_and_shared_object_caches_for_testing()\",\n                    \"isolate()->has_shared_space()\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool SharedHeapSerializer::ShouldReconstructSharedHeapObjectCacheForTesting()\n    const {\n  // When the live Isolate being serialized is not a client Isolate, there's no\n  // need to reconstruct the shared heap object cache because it is not actually\n  // shared.\n  return reconstruct_read_only_and_shared_object_caches_for_testing() &&\n         isolate()->has_shared_space();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReconstructSharedHeapObjectCacheForTesting\",\n                \"parent\": \"SharedHeapSerializer\",\n                \"about\": \"Reconstructs the shared heap object cache for testing purposes.\",\n                \"logic\": \"Iterates through the existing cache, serializing each object and ensuring it's correctly indexed in the cache. It also checks that the last element is undefined.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"isolate()->shared_space_isolate()->shared_heap_object_cache()\",\n                    \"ShouldBeInSharedHeapObjectCache\",\n                    \"SerializeInObjectCache\",\n                    \"IsUndefined\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid SharedHeapSerializer::ReconstructSharedHeapObjectCacheForTesting() {\n  std::vector<Tagged<Object>>* cache =\n      isolate()->shared_space_isolate()->shared_heap_object_cache();\n  // Don't reconstruct the final element, which is always undefined and marks\n  // the end of the cache, since serializing the live Isolate may extend the\n  // shared object cache.\n  for (size_t i = 0, size = cache->size(); i < size - 1; i++) {\n    Handle<HeapObject> obj(Cast<HeapObject>(cache->at(i)), isolate());\n    DCHECK(ShouldBeInSharedHeapObjectCache(*obj));\n    int cache_index = SerializeInObjectCache(obj);\n    USE(cache_index);\n    DCHECK_EQ(cache_index, i);\n  }\n  DCHECK(IsUndefined(cache->back(), isolate()));\n}\n        ]]></code>\n    </func>\n</file>\n```"
}