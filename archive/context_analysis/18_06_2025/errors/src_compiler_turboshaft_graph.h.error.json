{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/graph.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/graph.h\",\n        \"file_name\": \"graph.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Graph data structure for the Turboshaft compiler, including classes for managing operations, blocks, and dominator trees.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard library headers for various functionalities like algorithms, iterators, memory management, tuples, and type traits.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <algorithm>\n            #include <iterator>\n            #include <limits>\n            #include <memory>\n            #include <tuple>\n            #include <type_traits>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"V8 specific headers for base utilities, code generation, compiler operations, side tables, and types.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/iterator.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/base/small-vector.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/codegen/source-position.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/sidetable.h\"\n            #include \"src/compiler/turboshaft/types.h\"\n            #include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OperationBuffer\",\n            \"about\": \"A growable, Zone-allocated buffer to store Turboshaft operations.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone used for memory allocation.\"\n                },\n                {\n                    \"name\": \"begin_\",\n                    \"type\": \"OperationStorageSlot*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the beginning of the buffer.\"\n                },\n                {\n                    \"name\": \"end_\",\n                    \"type\": \"OperationStorageSlot*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the end of the buffer (next available slot).\"\n                },\n                {\n                    \"name\": \"end_cap_\",\n                    \"type\": \"OperationStorageSlot*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the end of the allocated capacity.\"\n                },\n                {\n                    \"name\": \"operation_sizes_\",\n                    \"type\": \"uint16_t*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array storing the size (in slots) of each operation. Indexed by OpIndex::id().\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"OpIndex\",\n                \"OperationStorageSlot\",\n                \"Operation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class OperationBuffer {\n            public:\n            // A `ReplaceScope` is to overwrite an existing operation.\n            // It moves the end-pointer temporarily so that the next emitted operation\n            // overwrites an old one.\n            class ReplaceScope {\n            public:\n                ReplaceScope(OperationBuffer* buffer, OpIndex replaced)\n                    : buffer_(buffer),\n                    replaced_(replaced),\n                    old_end_(buffer->end_),\n                    old_slot_count_(buffer->SlotCount(replaced)) {\n                buffer_->end_ = buffer->Get(replaced);\n                }\n                ~ReplaceScope() {\n                DCHECK_LE(buffer_->SlotCount(replaced_), old_slot_count_);\n                buffer_->end_ = old_end_;\n                // Preserve the original operation size in case it has become smaller.\n                buffer_->operation_sizes_[replaced_.id()] = old_slot_count_;\n                buffer_->operation_sizes_[OpIndex(replaced_.offset() +\n                                                    static_cast<uint32_t>(old_slot_count_) *\n                                                        sizeof(OperationStorageSlot))\n                                            .id() -\n                                        1] = old_slot_count_;\n                }\n\n                ReplaceScope(const ReplaceScope&) = delete;\n                ReplaceScope& operator=(const ReplaceScope&) = delete;\n\n            private:\n                OperationBuffer* buffer_;\n                OpIndex replaced_;\n                OperationStorageSlot* old_end_;\n                uint16_t old_slot_count_;\n            };\n\n            explicit OperationBuffer(Zone* zone, size_t initial_capacity) : zone_(zone) {\n                DCHECK_NE(initial_capacity, 0);\n                begin_ = end_ =\n                    zone_->AllocateArray<OperationStorageSlot>(initial_capacity);\n                operation_sizes_ =\n                    zone_->AllocateArray<uint16_t>((initial_capacity + 1) / kSlotsPerId);\n                end_cap_ = begin_ + initial_capacity;\n            }\n\n            OperationStorageSlot* Allocate(size_t slot_count) {\n                if (V8_UNLIKELY(static_cast<size_t>(end_cap_ - end_) < slot_count)) {\n                Grow(capacity() + slot_count);\n                DCHECK(slot_count <= static_cast<size_t>(end_cap_ - end_));\n                }\n                OperationStorageSlot* result = end_;\n                end_ += slot_count;\n                OpIndex idx = Index(result);\n                // Store the size in both for the first and last id corresponding to the new\n                // operation. This enables iteration in both directions. The two id's are\n                // the same if the operation is small.\n                operation_sizes_[idx.id()] = slot_count;\n                operation_sizes_[OpIndex(idx.offset() + static_cast<uint32_t>(slot_count) *\n                                                            sizeof(OperationStorageSlot))\n                                    .id() -\n                                1] = slot_count;\n                return result;\n            }\n\n            void RemoveLast() {\n                size_t slot_count = operation_sizes_[EndIndex().id() - 1];\n                end_ -= slot_count;\n                DCHECK_GE(end_, begin_);\n            }\n\n            OpIndex Index(const Operation& op) const {\n                return Index(reinterpret_cast<const OperationStorageSlot*>(&op));\n            }\n            OpIndex Index(const OperationStorageSlot* ptr) const {\n                DCHECK(begin_ <= ptr && ptr <= end_);\n                return OpIndex(static_cast<uint32_t>(reinterpret_cast<Address>(ptr) -\n                                                    reinterpret_cast<Address>(begin_)));\n            }\n\n            OperationStorageSlot* Get(OpIndex idx) {\n                DCHECK_LT(idx.offset() / sizeof(OperationStorageSlot), size());\n                return reinterpret_cast<OperationStorageSlot*>(\n                    reinterpret_cast<Address>(begin_) + idx.offset());\n            }\n            uint16_t SlotCount(OpIndex idx) {\n                DCHECK_LT(idx.offset() / sizeof(OperationStorageSlot), size());\n                return operation_sizes_[idx.id()];\n            }\n\n            const OperationStorageSlot* Get(OpIndex idx) const {\n                DCHECK_LT(idx.offset(), capacity() * sizeof(OperationStorageSlot));\n                return reinterpret_cast<const OperationStorageSlot*>(\n                    reinterpret_cast<Address>(begin_) + idx.offset());\n            }\n\n            OpIndex Next(OpIndex idx) const {\n                DCHECK_GT(operation_sizes_[idx.id()], 0);\n                OpIndex result = OpIndex(idx.offset() + operation_sizes_[idx.id()] *\n                                                    sizeof(OperationStorageSlot));\n                DCHECK_LT(0, result.offset());\n                DCHECK_LE(result.offset(), capacity() * sizeof(OperationStorageSlot));\n                return result;\n            }\n            OpIndex Previous(OpIndex idx) const {\n                DCHECK_GT(idx.id(), 0);\n                DCHECK_GT(operation_sizes_[idx.id() - 1], 0);\n                OpIndex result = OpIndex(idx.offset() - operation_sizes_[idx.id() - 1] *\n                                                    sizeof(OperationStorageSlot));\n                DCHECK_LE(0, result.offset());\n                DCHECK_LT(result.offset(), capacity() * sizeof(OperationStorageSlot));\n                return result;\n            }\n\n            // Offset of the first operation.\n            OpIndex BeginIndex() const { return OpIndex(0); }\n            // One-past-the-end offset.\n            OpIndex EndIndex() const { return Index(end_); }\n\n            uint32_t size() const { return static_cast<uint32_t>(end_ - begin_); }\n            uint32_t capacity() const { return static_cast<uint32_t>(end_cap_ - begin_); }\n\n            void Grow(size_t min_capacity) {\n                size_t size = this->size();\n                size_t capacity = this->capacity();\n                size_t new_capacity = 2 * capacity;\n                while (new_capacity < min_capacity) new_capacity *= 2;\n                CHECK_LT(new_capacity, std::numeric_limits<uint32_t>::max() /\n                                        sizeof(OperationStorageSlot));\n\n                OperationStorageSlot* new_buffer =\n                    zone_->AllocateArray<OperationStorageSlot>(new_capacity);\n                memcpy(new_buffer, begin_, size * sizeof(OperationStorageSlot));\n\n                uint16_t* new_operation_sizes =\n                    zone_->AllocateArray<uint16_t>(new_capacity / kSlotsPerId);\n                memcpy(new_operation_sizes, operation_sizes_,\n                    size / kSlotsPerId * sizeof(uint16_t));\n\n                begin_ = new_buffer;\n                end_ = new_buffer + size;\n                end_cap_ = new_buffer + new_capacity;\n                operation_sizes_ = new_operation_sizes;\n            }\n\n            void Reset() { end_ = begin_; }\n\n            private:\n            Zone* zone_;\n            OperationStorageSlot* begin_;\n            OperationStorageSlot* end_;\n            OperationStorageSlot* end_cap_;\n            uint16_t* operation_sizes_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DominatorForwardTreeNode\",\n            \"about\": \"A class storing a forward representation of the dominator tree (parent to children).\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Derived>\n            class DominatorForwardTreeNode {\n            // A class storing a forward representation of the dominator tree, since the\n            // regular dominator tree is represented as pointers from the children to\n            // parents rather than parents to children.\n            public:\n            void AddChild(Derived* next) {\n                DCHECK_EQ(static_cast<Derived*>(this)->len_ + 1, next->len_);\n                next->neighboring_child_ = last_child_;\n                last_child_ = next;\n            }\n\n            Derived* LastChild() const { return last_child_; }\n            Derived* NeighboringChild() const { return neighboring_child_; }\n            bool HasChildren() const { return last_child_ != nullptr; }\n\n            base::SmallVector<Derived*, 8> Children() const {\n                base::SmallVector<Derived*, 8> result;\n                for (Derived* child = last_child_; child != nullptr;\n                    child = child->neighboring_child_) {\n                result.push_back(child);\n                }\n                std::reverse(result.begin(), result.end());\n                return result;\n            }\n\n            private:\n        #ifdef DEBUG\n            friend class RandomAccessStackDominatorNode<Derived>;\n        #endif\n            Derived* neighboring_child_ = nullptr;\n            Derived* last_child_ = nullptr;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RandomAccessStackDominatorNode\",\n            \"extends\": \"DominatorForwardTreeNode\",\n            \"about\": \"A node in a dominator tree implemented using Myers' Random-Access Stack.\",\n            \"attributes\": [\n                {\n                    \"name\": \"jmp_len_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores jmp_->len_ to speed up operations.\"\n                },\n                {\n                    \"name\": \"len_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Length of the path to the root.\"\n                },\n                {\n                    \"name\": \"nxt_\",\n                    \"type\": \"Derived*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The immediate dominator.\"\n                },\n                {\n                    \"name\": \"jmp_\",\n                    \"type\": \"Derived*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A node used for fast access to ancestors.\"\n                }\n            ],\n            \"dependencies\": [\n                \"DominatorForwardTreeNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Derived>\n            class RandomAccessStackDominatorNode\n                : public DominatorForwardTreeNode<Derived> {\n            // This class represents a node of a dominator tree implemented using Myers'\n            // Random-Access Stack (see\n            // https://publications.mpi-cbg.de/Myers_1983_6328.pdf). This datastructure\n            // enables searching for a predecessor of a node in log(h) time, where h is\n            // the height of the dominator tree.\n            public:\n            void SetDominator(Derived* dominator);\n            void SetAsDominatorRoot();\n            Derived* GetDominator() const { return nxt_; }\n\n            // Returns the lowest common dominator of {this} and {other}.\n            Derived* GetCommonDominator(\n                RandomAccessStackDominatorNode<Derived>* other) const;\n\n            bool IsDominatedBy(const Derived* other) const {\n                // TODO(dmercadier): we don't have to call GetCommonDominator and could\n                // determine quicker that {this} isn't dominated by {other}.\n                return GetCommonDominator(other) == other;\n            }\n\n            int Depth() const { return len_; }\n\n            private:\n            friend class DominatorForwardTreeNode<Derived>;\n        #ifdef DEBUG\n            friend class Block;\n        #endif\n\n            // Myers' original datastructure requires to often check jmp_->len_, which is\n            // not so great on modern computers (memory access, caches & co). To speed up\n            // things a bit, we store here jmp_len_.\n            int jmp_len_ = 0;\n\n            int len_ = 0;\n            Derived* nxt_ = nullptr;\n            Derived* jmp_ = nullptr;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PredecessorIterator\",\n            \"about\": \"A simple iterator to walk over the predecessors of a block.\",\n            \"attributes\": [\n                {\n                    \"name\": \"current_\",\n                    \"type\": \"const Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current block in the iteration.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Block\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class PredecessorIterator {\n            public:\n            explicit PredecessorIterator(const Block* block) : current_(block) {}\n\n            PredecessorIterator& operator++();\n            constexpr bool operator==(const PredecessorIterator& other) const {\n                return current_ == other.current_;\n            }\n            constexpr bool operator!=(const PredecessorIterator& other) const {\n                return !(*this == other);\n            }\n\n            const Block* operator*() const { return current_; }\n\n            private:\n            const Block* current_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NeighboringPredecessorIterable\",\n            \"about\": \"An iterable wrapper for the predecessors of a block.\",\n            \"attributes\": [\n                {\n                    \"name\": \"begin_\",\n                    \"type\": \"const Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The first predecessor in the list.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Block\",\n                \"PredecessorIterator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class NeighboringPredecessorIterable {\n            public:\n            explicit NeighboringPredecessorIterable(const Block* begin) : begin_(begin) {}\n\n            PredecessorIterator begin() const { return PredecessorIterator(begin_); }\n            PredecessorIterator end() const { return PredecessorIterator(nullptr); }\n\n            private:\n            const Block* begin_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Block\",\n            \"extends\": \"RandomAccessStackDominatorNode\",\n            \"about\": \"A basic block in the Turboshaft graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"kind_\",\n                    \"type\": \"Kind\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The kind of the block (Merge, LoopHeader, BranchTarget).\"\n                },\n                {\n                    \"name\": \"begin_\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Index of the first operation in the block.\"\n                },\n                {\n                    \"name\": \"end_\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Index of the operation after the last operation in the block.\"\n                },\n                {\n                    \"name\": \"index_\",\n                    \"type\": \"BlockIndex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The index of the block in the graph.\"\n                },\n                {\n                    \"name\": \"last_predecessor_\",\n                    \"type\": \"Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the last predecessor added to this block.\"\n                },\n                {\n                    \"name\": \"neighboring_predecessor_\",\n                    \"type\": \"Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the next predecessor in the list.\"\n                },\n                {\n                    \"name\": \"single_loop_predecessor_\",\n                    \"type\": \"Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The single predecessor of a loop header (the backedge).\"\n                },\n                {\n                    \"name\": \"predecessor_count_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Number of predecessors this block has.\"\n                },\n                {\n                    \"name\": \"origin_\",\n                    \"type\": \"const Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The origin block from the previous graph, if any.\"\n                },\n                {\n                    \"name\": \"custom_data_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Custom data field for temporary block-specific information.\"\n                }\n            ],\n            \"dependencies\": [\n                \"RandomAccessStackDominatorNode\",\n                \"BlockIndex\",\n                \"OpIndex\",\n                \"Graph\",\n                \"GotoOp\",\n                \"PhiOp\",\n                \"PendingLoopPhiOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Block : public RandomAccessStackDominatorNode<Block> {\n            public:\n            enum class Kind : uint8_t { kMerge, kLoopHeader, kBranchTarget };\n\n            explicit Block(Kind kind) : kind_(kind) {}\n\n            bool IsLoopOrMerge() const { return IsLoop() || IsMerge(); }\n            bool IsLoop() const { return kind_ == Kind::kLoopHeader; }\n            bool IsMerge() const { return kind_ == Kind::kMerge; }\n            bool IsBranchTarget() const { return kind_ == Kind::kBranchTarget; }\n\n            Kind kind() const { return kind_; }\n            void SetKind(Kind kind) { kind_ = kind; }\n\n            BlockIndex index() const { return index_; }\n\n            bool Contains(OpIndex op_idx) const {\n                return begin_ <= op_idx && op_idx < end_;\n            }\n\n            bool IsBound() const { return index_ != BlockIndex::Invalid(); }\n\n            base::SmallVector<Block*, 8> Predecessors() const {\n                base::SmallVector<Block*, 8> result;\n                for (Block* pred = last_predecessor_; pred != nullptr;\n                    pred = pred->neighboring_predecessor_) {\n                result.push_back(pred);\n                }\n                std::reverse(result.begin(), result.end());\n                return result;\n            }\n\n            // Returns an iterable object (defining begin() and end()) to iterate over the\n            // block's predecessors.\n            NeighboringPredecessorIterable PredecessorsIterable() const {\n                return NeighboringPredecessorIterable(last_predecessor_);\n            }\n\n            int PredecessorCount() const {\n        #ifdef DEBUG\n                CheckPredecessorCount();\n        #endif\n                return predecessor_count_;\n            }\n\n        #ifdef DEBUG\n            // Checks that the {predecessor_count_} is equal to the number of predecessors\n            // reachable through {last_predecessor_}.\n            void CheckPredecessorCount() const {\n                int count = 0;\n                for (Block* pred = last_predecessor_; pred != nullptr;\n                    pred = pred->neighboring_predecessor_) {\n                count++;\n                }\n                DCHECK_EQ(count, predecessor_count_);\n            }\n        #endif\n\n            static constexpr int kInvalidPredecessorIndex = -1;\n\n            // Returns the index of {target} in the predecessors of the current Block.\n            // If {target} is not a direct predecessor, returns -1.\n            int GetPredecessorIndex(const Block* target) const {\n                int pred_count = 0;\n                int pred_reverse_index = -1;\n                for (Block* pred = last_predecessor_; pred != nullptr;\n                    pred = pred->neighboring_predecessor_) {\n                if (pred == target) {\n                    DCHECK_EQ(pred_reverse_index, -1);\n                    pred_reverse_index = pred_count;\n                }\n                pred_count++;\n                }\n                if (pred_reverse_index == -1) {\n                return kInvalidPredecessorIndex;\n                }\n                return pred_count - pred_reverse_index - 1;\n            }\n\n            Block* LastPredecessor() const { return last_predecessor_; }\n            Block* NeighboringPredecessor() const { return neighboring_predecessor_; }\n            bool HasPredecessors() const {\n                DCHECK_EQ(predecessor_count_ == 0, last_predecessor_ == nullptr);\n                return last_predecessor_ != nullptr;\n            }\n            void ResetLastPredecessor() {\n                last_predecessor_ = nullptr;\n                predecessor_count_ = 0;\n            }\n            void ResetAllPredecessors() {\n                Block* pred = last_predecessor_;\n                last_predecessor_ = nullptr;\n                while (pred->neighboring_predecessor_) {\n                Block* tmp = pred->neighboring_predecessor_;\n                pred->neighboring_predecessor_ = nullptr;\n                pred = tmp;\n                }\n                predecessor_count_ = 0;\n            }\n\n            Block* single_loop_predecessor() const {\n                DCHECK(IsLoop());\n                return single_loop_predecessor_;\n            }\n            void SetSingleLoopPredecessor(Block* single_loop_predecessor) {\n                DCHECK(IsLoop());\n                DCHECK_NULL(single_loop_predecessor_);\n                DCHECK_NOT_NULL(single_loop_predecessor);\n                single_loop_predecessor_ = single_loop_predecessor;\n            }\n\n            // The block from the previous graph which produced the current block. This\n            // has to be updated to be the last block that contributed operations to the\n            // current block to ensure that phi nodes are created correctly.\n            void SetOrigin(const Block* origin) {\n                DCHECK_IMPLIES(origin != nullptr,\n                            origin->graph_generation_ + 1 == graph_generation_);\n                origin_ = origin;\n            }\n            // The block from the input graph that is equivalent as a predecessor. It is\n            // only available for bound blocks and it does *not* refer to an equivalent\n            // block as a branch destination.\n            const Block* OriginForBlockEnd() const {\n                DCHECK(IsBound());\n                return origin_;\n            }\n            const Block* OriginForLoopHeader() const {\n                DCHECK(IsLoop());\n                return origin_;\n            }\n\n            bool IsComplete() const { return end_.valid(); }\n            OpIndex begin() const {\n                DCHECK(begin_.valid());\n                return begin_;\n            }\n            OpIndex end() const {\n                DCHECK(end_.valid());\n                return end_;\n            }\n\n            // Returns an approximation of the number of operations contained in this\n            // block, by counting how many slots it contains. Depending on the size of the\n            // operations it contains, this could be exactly how many operations it\n            // contains, or it could be less.\n            int OpCountUpperBound() const { return end().id() - begin().id(); }\n\n            const Operation& FirstOperation(const Graph& graph) const;\n            const Operation& LastOperation(const Graph& graph) const;\n            Operation& LastOperation(Graph& graph) const;\n\n            bool EndsWithBranchingOp(const Graph& graph) const {\n                switch (LastOperation(graph).opcode) {\n                case Opcode::kBranch:\n                case Opcode::kSwitch:\n                case Opcode::kCheckException:\n                    return true;\n                default:\n                    DCHECK_LE(SuccessorBlocks(*this, graph).size(), 1);\n                    return false;\n                }\n            }\n\n            bool HasPhis(const Graph& graph) const;\n\n            bool HasBackedge(const Graph& graph) const {\n                if (const GotoOp* gto = LastOperation(graph).TryCast<GotoOp>()) {\n                return gto->destination->index().id() <= index().id();\n                }\n                return false;\n            }\n\n        #ifdef DEBUG\n            // {has_peeled_iteration_} is currently only updated for loops peeled in\n            // Turboshaft (it is true only for loop headers of loops that have had their\n            // first iteration peeled). So be aware that while Turbofan loop peeling is\n            // enabled, this is not a reliable way to check if a loop has a peeled\n            // iteration.\n            bool has_peeled_iteration() const {\n                DCHECK(IsLoop());\n                return has_peeled_iteration_;\n            }\n            void set_has_peeled_iteration() {\n                DCHECK(IsLoop());\n                has_peeled_iteration_ = true;\n            }\n        #endif\n\n            // Computes the dominators of the this block, assuming that the dominators of\n            // its predecessors are already computed. Returns the depth of the current\n            // block in the dominator tree.\n            uint32_t ComputeDominator();\n\n            void PrintDominatorTree(\n                std::vector<const char*> tree_symbols = std::vector<const char*>(),\n                bool has_next = false) const;\n\n            enum class CustomDataKind {\n                kUnset,  // No custom data has been set for this block.\n                kPhiInputIndex,\n                kDeferredInSchedule,\n            };\n\n            void set_custom_data(uint32_t data, CustomDataKind kind_for_debug_check) {\n                custom_data_ = data;\n        #ifdef DEBUG\n                custom_data_kind_for_debug_check_ = kind_for_debug_check;\n        #endif\n            }\n\n            uint32_t get_custom_data(CustomDataKind kind_for_debug_check) const {\n                DCHECK_EQ(custom_data_kind_for_debug_check_, kind_for_debug_check);\n                return custom_data_;\n            }\n\n            void clear_custom_data() {\n                custom_data_ = 0;\n        #ifdef DEBUG\n                custom_data_kind_for_debug_check_ = CustomDataKind::kUnset;\n        #endif\n            }\n\n            private:\n            // AddPredecessor should never be called directly except from Assembler's\n            // AddPredecessor and SplitEdge methods, which takes care of maintaining\n            // split-edge form.\n            void AddPredecessor(Block* predecessor) {\n                DCHECK(!IsBound() ||\n                    (Predecessors().size() == 1 && kind_ == Kind::kLoopHeader));\n                DCHECK_EQ(predecessor->neighboring_predecessor_, nullptr);\n                predecessor->neighboring_predecessor_ = last_predecessor_;\n                last_predecessor_ = predecessor;\n                predecessor_count_++;\n            }\n\n\n            Kind kind_;\n            OpIndex begin_ = OpIndex::Invalid();\n            OpIndex end_ = OpIndex::Invalid();\n            BlockIndex index_ = BlockIndex::Invalid();\n            Block* last_predecessor_ = nullptr;\n            Block* neighboring_predecessor_ = nullptr;\n            Block* single_loop_predecessor_ = nullptr;\n            uint32_t predecessor_count_ = 0;\n            const Block* origin_ = nullptr;\n            // The {custom_data_} field can be used by algorithms to temporarily store\n            // block-specific data. This field is not preserved when constructing a new\n            // output graph and algorithms cannot rely on this field being properly reset\n            // after previous uses.\n            uint32_t custom_data_ = 0;\n        #ifdef DEBUG\n            CustomDataKind custom_data_kind_for_debug_check_ = CustomDataKind::kUnset;\n            size_t graph_generation_ = 0;\n            // True if this is a loop header of a loop with a peeled iteration.\n            bool has_peeled_iteration_ = false;\n        #endif\n\n            friend class Graph;\n            template <class Reducers>\n            friend class Assembler;\n            template <class Assembler>\n            friend class GraphVisitor;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Graph\",\n            \"about\": \"Represents the Turboshaft graph, containing operations, blocks, and other compiler-related data structures.\",\n            \"attributes\": [\n                {\n                    \"name\": \"operations_\",\n                    \"type\": \"OperationBuffer\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Buffer to store operations.\"\n                },\n                {\n                    \"name\": \"bound_blocks_\",\n                    \"type\": \"ZoneVector<Block*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of blocks that are part of the graph.\"\n                },\n                {\n                    \"name\": \"all_blocks_\",\n                    \"type\": \"base::Vector<Block*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector holding all allocated blocks.\"\n                },\n                {\n                    \"name\": \"next_block_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Index of the next available block in all_blocks_.\"\n                },\n                {\n                    \"name\": \"op_to_block_\",\n                    \"type\": \"GrowingOpIndexSidetable<BlockIndex>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Side table mapping operations to their containing blocks.\"\n                },\n                {\n                    \"name\": \"block_permutation_\",\n                    \"type\": \"ZoneVector<Block*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores block order after reordering.\"\n                },\n                {\n                    \"name\": \"graph_zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory zone used for graph allocations.\"\n                },\n                {\n                    \"name\": \"source_positions_\",\n                    \"type\": \"GrowingOpIndexSidetable<SourcePosition>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Side table mapping operations to source positions.\"\n                },\n                {\n                    \"name\": \"operation_origins_\",\n                    \"type\": \"GrowingOpIndexSidetable<OpIndex>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Side table to store operation origins.\"\n                },\n                {\n                    \"name\": \"operation_types_\",\n                    \"type\": \"GrowingOpIndexSidetable<Type>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Side table to store operation types.\"\n                },\n                {\n                    \"name\": \"dominator_tree_depth_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Depth of the dominator tree.\"\n                },\n                {\n                    \"name\": \"companion_\",\n                    \"type\": \"Graph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A companion graph for graph transformations.\"\n                },\n                {\n                    \"name\": \"loop_unrolling_analyzer_\",\n                    \"type\": \"LoopUnrollingAnalyzer*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Analyzer for loop unrolling.\"\n                },\n                {\n                    \"name\": \"stack_checks_to_remove_\",\n                    \"type\": \"ZoneAbslFlatHashSet<uint32_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indices of loop headers whose stack checks should be removed.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n"
}