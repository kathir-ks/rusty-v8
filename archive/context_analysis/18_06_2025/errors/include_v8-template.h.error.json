{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-template.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-template.h\",\n            \"file_name\": \"v8-template.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the Template, FunctionTemplate, ObjectTemplate, DictionaryTemplate, and Signature classes, used for creating functions and objects at runtime in V8.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for data structures and functionalities used in template creation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cstddef>\n            #include <string_view>\n\n            #include \"v8-data.h\"               // NOLINT(build/include_directory)\n            #include \"v8-exception.h\"          // NOLINT(build/include_directory)\n            #include \"v8-function-callback.h\"  // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"       // NOLINT(build/include_directory)\n            #include \"v8-memory-span.h\"        // NOLINT(build/include_directory)\n            #include \"v8-object.h\"             // NOLINT(build/include_directory)\n            #include \"v8config.h\"              // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Template\",\n                \"extends\": \"Data\",\n                \"about\": \"The superclass of object and function templates.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Name\",\n                    \"Data\",\n                    \"Private\",\n                    \"PropertyAttribute\",\n                    \"Value\",\n                    \"FunctionTemplate\",\n                    \"Isolate\",\n                    \"AccessorNameGetterCallback\",\n                    \"AccessorNameSetterCallback\",\n                    \"SideEffectType\",\n                    \"Intrinsic\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Template : public Data {\n            public:\n            /**\n             * Adds a property to each instance created by this template.\n             *\n             * The property must be defined either as a primitive value, or a template.\n             */\n            void Set(Local<Name> name, Local<Data> value,\n                    PropertyAttribute attributes = None);\n            void SetPrivate(Local<Private> name, Local<Data> value,\n                            PropertyAttribute attributes = None);\n            V8_INLINE void Set(Isolate* isolate, const char* name, Local<Data> value,\n                               PropertyAttribute attributes = None);\n\n            /**\n             * Sets an \"accessor property\" on the object template, see\n             * https://tc39.es/ecma262/#sec-object-type.\n             *\n             * Whenever the property with the given name is accessed on objects\n             * created from this ObjectTemplate the getter and setter functions\n             * are called.\n             *\n             * \\param name The name of the property for which an accessor is added.\n             * \\param getter The callback to invoke when getting the property.\n             * \\param setter The callback to invoke when setting the property.\n             * \\param attribute The attributes of the property for which an accessor\n             *   is added.\n             */\n            void SetAccessorProperty(\n                Local<Name> name,\n                Local<FunctionTemplate> getter = Local<FunctionTemplate>(),\n                Local<FunctionTemplate> setter = Local<FunctionTemplate>(),\n                PropertyAttribute attribute = None);\n\n            /**\n             * Sets a \"data property\" on the object template, see\n             * https://tc39.es/ecma262/#sec-object-type.\n             *\n             * Whenever the property with the given name is accessed on objects\n             * created from this Template the getter and setter callbacks\n             * are called instead of getting and setting the property directly\n             * on the JavaScript object.\n             * Note that in case a property is written via a \"child\" object, the setter\n             * will not be called according to the JavaScript specification. See\n             * https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver.\n             *\n             * \\param name The name of the data property for which an accessor is added.\n             * \\param getter The callback to invoke when getting the property.\n             * \\param setter The callback to invoke when setting the property.\n             * \\param data A piece of data that will be passed to the getter and setter\n             *   callbacks whenever they are invoked.\n             * \\param attribute The attributes of the property for which an accessor\n             *   is added.\n             */\n            void SetNativeDataProperty(\n                Local<Name> name, AccessorNameGetterCallback getter,\n                AccessorNameSetterCallback setter = nullptr,\n                Local<Value> data = Local<Value>(), PropertyAttribute attribute = None,\n                SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect,\n                SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);\n\n            /**\n             * Like SetNativeDataProperty, but V8 will replace the native data property\n             * with a real data property on first access.\n             */\n            void SetLazyDataProperty(\n                Local<Name> name, AccessorNameGetterCallback getter,\n                Local<Value> data = Local<Value>(), PropertyAttribute attribute = None,\n                SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect,\n                SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);\n\n            /**\n             * During template instantiation, sets the value with the intrinsic property\n             * from the correct context.\n             */\n            void SetIntrinsicDataProperty(Local<Name> name, Intrinsic intrinsic,\n                                        PropertyAttribute attribute = None);\n\n            private:\n            Template();\n\n            friend class ObjectTemplate;\n            friend class FunctionTemplate;\n            };\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"Intercepted\",\n                \"about\": \"Indicates whether an interceptor callback handled a request or not.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class Intercepted : uint8_t { kNo = 0, kYes = 1 };\n        ]]></code>\n    </enum>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"NamedPropertyGetterCallback\",\n                \"about\": \"Defines the signature for a named property getter interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using NamedPropertyGetterCallback = Intercepted (*)(\n                Local<Name> property, const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"GenericNamedPropertyGetterCallback\",\n                \"about\": \"Defines the signature for a generic named property getter interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using GenericNamedPropertyGetterCallback =\n                void (*)(Local<Name> property, const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"NamedPropertySetterCallback\",\n                \"about\": \"Defines the signature for a named property setter interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"Local\",\n                    \"Name\",\n                    \"Value\",\n                    \"PropertyCallbackInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using NamedPropertySetterCallback =\n                Intercepted (*)(Local<Name> property, Local<Value> value,\n                                const PropertyCallbackInfo<void>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"GenericNamedPropertySetterCallback\",\n                \"about\": \"Defines the signature for a generic named property setter interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"Local\",\n                    \"Name\",\n                    \"Value\",\n                    \"PropertyCallbackInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using GenericNamedPropertySetterCallback =\n                void (*)(Local<Name> property, Local<Value> value,\n                         const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"NamedPropertyQueryCallback\",\n                \"about\": \"Defines the signature for a named property query interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyCallbackInfo\",\n                    \"Integer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using NamedPropertyQueryCallback = Intercepted (*)(\n                Local<Name> property, const PropertyCallbackInfo<Integer>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"GenericNamedPropertyQueryCallback\",\n                \"about\": \"Defines the signature for a generic named property query interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyCallbackInfo\",\n                    \"Integer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using GenericNamedPropertyQueryCallback =\n                void (*)(Local<Name> property, const PropertyCallbackInfo<Integer>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"NamedPropertyDeleterCallback\",\n                \"about\": \"Defines the signature for a named property deleter interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyCallbackInfo\",\n                    \"Boolean\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using NamedPropertyDeleterCallback = Intercepted (*)(\n                Local<Name> property, const PropertyCallbackInfo<Boolean>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"GenericNamedPropertyDeleterCallback\",\n                \"about\": \"Defines the signature for a generic named property deleter interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyCallbackInfo\",\n                    \"Boolean\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using GenericNamedPropertyDeleterCallback =\n                void (*)(Local<Name> property, const PropertyCallbackInfo<Boolean>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"NamedPropertyEnumeratorCallback\",\n                \"about\": \"Defines the signature for a named property enumerator interceptor callback.\",\n                \"dependencies\": [\n                    \"PropertyCallbackInfo\",\n                    \"Array\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using NamedPropertyEnumeratorCallback =\n                void (*)(const PropertyCallbackInfo<Array>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"GenericNamedPropertyEnumeratorCallback\",\n                \"about\": \"Alias for NamedPropertyEnumeratorCallback (deprecated).\",\n                \"dependencies\": [\n                    \"NamedPropertyEnumeratorCallback\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using GenericNamedPropertyEnumeratorCallback = NamedPropertyEnumeratorCallback;\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"NamedPropertyDefinerCallback\",\n                \"about\": \"Defines the signature for a named property definer interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyDescriptor\",\n                    \"PropertyCallbackInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using NamedPropertyDefinerCallback =\n                Intercepted (*)(Local<Name> property, const PropertyDescriptor& desc,\n                                const PropertyCallbackInfo<void>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"GenericNamedPropertyDefinerCallback\",\n                \"about\": \"Defines the signature for a generic named property definer interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyDescriptor\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using GenericNamedPropertyDefinerCallback =\n                void (*)(Local<Name> property, const PropertyDescriptor& desc,\n                         const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"NamedPropertyDescriptorCallback\",\n                \"about\": \"Defines the signature for a named property descriptor interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using NamedPropertyDescriptorCallback = Intercepted (*)(\n                Local<Name> property, const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"GenericNamedPropertyDescriptorCallback\",\n                \"about\": \"Defines the signature for a generic named property descriptor interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"Local\",\n                    \"Name\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using GenericNamedPropertyDescriptorCallback =\n                void (*)(Local<Name> property, const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyGetterCallbackV2\",\n                \"about\": \"Defines the signature for an indexed property getter interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"uint32_t\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyGetterCallbackV2 =\n                Intercepted (*)(uint32_t index, const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyGetterCallback\",\n                \"about\": \"Defines the signature for an indexed property getter interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"uint32_t\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyGetterCallback =\n                void (*)(uint32_t index, const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertySetterCallbackV2\",\n                \"about\": \"Defines the signature for an indexed property setter interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"uint32_t\",\n                    \"Local\",\n                    \"Value\",\n                    \"PropertyCallbackInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertySetterCallbackV2 = Intercepted (*)(\n                uint32_t index, Local<Value> value, const PropertyCallbackInfo<void>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertySetterCallback\",\n                \"about\": \"Defines the signature for an indexed property setter interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"uint32_t\",\n                    \"Local\",\n                    \"Value\",\n                    \"PropertyCallbackInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertySetterCallback =\n                void (*)(uint32_t index, Local<Value> value,\n                         const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyQueryCallbackV2\",\n                \"about\": \"Defines the signature for an indexed property query interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"uint32_t\",\n                    \"PropertyCallbackInfo\",\n                    \"Integer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyQueryCallbackV2 =\n                Intercepted (*)(uint32_t index, const PropertyCallbackInfo<Integer>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyQueryCallback\",\n                \"about\": \"Defines the signature for an indexed property query interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"uint32_t\",\n                    \"PropertyCallbackInfo\",\n                    \"Integer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyQueryCallback =\n                void (*)(uint32_t index, const PropertyCallbackInfo<Integer>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyDeleterCallbackV2\",\n                \"about\": \"Defines the signature for an indexed property deleter interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"uint32_t\",\n                    \"PropertyCallbackInfo\",\n                    \"Boolean\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyDeleterCallbackV2 =\n                Intercepted (*)(uint32_t index, const PropertyCallbackInfo<Boolean>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyDeleterCallback\",\n                \"about\": \"Defines the signature for an indexed property deleter interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"uint32_t\",\n                    \"PropertyCallbackInfo\",\n                    \"Boolean\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyDeleterCallback =\n                void (*)(uint32_t index, const PropertyCallbackInfo<Boolean>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyEnumeratorCallback\",\n                \"about\": \"Defines the signature for an indexed property enumerator interceptor callback.\",\n                \"dependencies\": [\n                    \"PropertyCallbackInfo\",\n                    \"Array\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyEnumeratorCallback =\n                void (*)(const PropertyCallbackInfo<Array>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyDefinerCallbackV2\",\n                \"about\": \"Defines the signature for an indexed property definer interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"uint32_t\",\n                    \"PropertyDescriptor\",\n                    \"PropertyCallbackInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyDefinerCallbackV2 =\n                Intercepted (*)(uint32_t index, const PropertyDescriptor& desc,\n                                const PropertyCallbackInfo<void>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyDefinerCallback\",\n                \"about\": \"Defines the signature for an indexed property definer interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"uint32_t\",\n                    \"PropertyDescriptor\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyDefinerCallback =\n                void (*)(uint32_t index, const PropertyDescriptor& desc,\n                         const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyDescriptorCallbackV2\",\n                \"about\": \"Defines the signature for an indexed property descriptor interceptor callback.\",\n                \"dependencies\": [\n                    \"Intercepted\",\n                    \"uint32_t\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyDescriptorCallbackV2 =\n                Intercepted (*)(uint32_t index, const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"IndexedPropertyDescriptorCallback\",\n                \"about\": \"Defines the signature for an indexed property descriptor interceptor callback (deprecated).\",\n                \"dependencies\": [\n                    \"uint32_t\",\n                    \"PropertyCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using IndexedPropertyDescriptorCallback =\n                void (*)(uint32_t index, const PropertyCallbackInfo<Value>& info);\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"AccessCheckCallback\",\n                \"about\": \"Defines the signature for an access check callback.\",\n                \"dependencies\": [\n                    \"Local\",\n                    \"Context\",\n                    \"Object\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using AccessCheckCallback = bool (*)(Local<Context> accessing_context,\n                                                 Local<Object> accessed_object,\n                                                 Local<Value> data);\n        ]]></code>\n    </typedef>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"ConstructorBehavior\",\n                \"about\": \"Defines the behavior of a function when used as a constructor.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class ConstructorBehavior { kThrow, kAllow };\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FunctionTemplate\",\n                \"extends\": \"Template\",\n                \"about\": \"Used to create functions at runtime.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Template\",\n                    \"Isolate\",\n                    \"FunctionCallback\",\n                    \"Local\",\n                    \"Value\",\n                    \"Signature\",\n                    \"ConstructorBehavior\",\n                    \"SideEffectType\",\n                    \"CFunction\",\n                    \"ObjectTemplate\",\n                    \"Context\",\n                    \"Function\",\n                    \"MemorySpan\",\n                    \"Private\",\n                    \"String\",\n                    \"ExceptionContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT FunctionTemplate : public Template {\n            public:\n            /** Creates a function template.*/\n            static Local<FunctionTemplate> New(\n                Isolate* isolate, FunctionCallback callback = nullptr,\n                Local<Value> data = Local<Value>(),\n                Local<Signature> signature = Local<Signature>(), int length = 0,\n                ConstructorBehavior behavior = ConstructorBehavior::kAllow,\n                SideEffectType side_effect_type = SideEffectType::kHasSideEffect,\n                const CFunction* c_function = nullptr, uint16_t instance_type = 0,\n                uint16_t allowed_receiver_instance_type_range_start = 0,\n                uint16_t allowed_receiver_instance_type_range_end = 0);\n\n            /** Creates a function template for multiple overloaded fast API calls.*/\n            static Local<FunctionTemplate> NewWithCFunctionOverloads(\n                Isolate* isolate, FunctionCallback callback = nullptr,\n                Local<Value> data = Local<Value>(),\n                Local<Signature> signature = Local<Signature>(), int length = 0,\n                ConstructorBehavior behavior = ConstructorBehavior::kAllow,\n                SideEffectType side_effect_type = SideEffectType::kHasSideEffect,\n                const MemorySpan<const CFunction>& c_function_overloads = {});\n\n            /**\n             * Creates a function template backed/cached by a private property.\n             */\n            static Local<FunctionTemplate> NewWithCache(\n                Isolate* isolate, FunctionCallback callback,\n                Local<Private> cache_property, Local<Value> data = Local<Value>(),\n                Local<Signature> signature = Local<Signature>(), int length = 0,\n                SideEffectType side_effect_type = SideEffectType::kHasSideEffect);\n\n            /** Returns the unique function instance in the current execution context.*/\n            V8_WARN_UNUSED_RESULT MaybeLocal<Function> GetFunction(\n                Local<Context> context);\n\n            /**\n             * Similar to Context::NewRemoteContext, this creates an instance that\n             * isn't backed by an actual object.\n             *\n             * The InstanceTemplate of this FunctionTemplate must have access checks with\n             * handlers installed.\n             */\n            V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewRemoteInstance();\n\n            /**\n             * Set the call-handler callback for a FunctionTemplate.  This\n             * callback is called whenever the function created from this\n             * FunctionTemplate is called. The 'c_function' represents a fast\n             * API call, see the comment above the class declaration.\n             */\n            void SetCallHandler(\n                FunctionCallback callback, Local<Value> data = Local<Value>(),\n                SideEffectType side_effect_type = SideEffectType::kHasSideEffect,\n                const MemorySpan<const CFunction>& c_function_overloads = {});\n\n            /** Set the predefined length property for the FunctionTemplate. */\n            void SetLength(int length);\n\n            /** Get the InstanceTemplate. */\n            Local<ObjectTemplate> InstanceTemplate();\n\n            /**\n             * Causes the function template to inherit from a parent function template.\n             * This means the function's prototype.__proto__ is set to the parent\n             * function's prototype.\n             **/\n            void Inherit(Local<FunctionTemplate> parent);\n\n            /**\n             * A PrototypeTemplate is the template used to create the prototype object\n             * of the function created by this template.\n             */\n            Local<ObjectTemplate> PrototypeTemplate();\n\n            /**\n             * A PrototypeProviderTemplate is another function template whose prototype\n             * property is used for this template. This is mutually exclusive with setting\n             * a prototype template indirectly by calling PrototypeTemplate() or using\n             * Inherit().\n             **/\n            void SetPrototypeProviderTemplate(Local<FunctionTemplate> prototype_provider);\n\n            /**\n             * Set the class name of the FunctionTemplate.  This is used for\n             * printing objects created with the function created from the\n             * FunctionTemplate as its constructor.\n             */\n            void SetClassName(Local<String> name);\n\n            /**\n             * Set the interface name of the FunctionTemplate. This is provided as\n             * contextual information in an ExceptionPropagationMessage to the embedder.\n             */\n            void SetInterfaceName(Local<String> name);\n\n            /**\n             * Provides information on the type of FunctionTemplate for embedder\n             * exception handling.\n             */\n            void SetExceptionContext(ExceptionContext context);\n\n            /**\n             * When set to true, no access check will be performed on the receiver of a\n             * function call.  Currently defaults to true, but this is subject to change.\n             */\n            void SetAcceptAnyReceiver(bool value);\n\n            /**\n             * Sets the ReadOnly flag in the attributes of the 'prototype' property\n             * of functions created from this FunctionTemplate to true.\n             */\n            void ReadOnlyPrototype();\n\n            /**\n             * Removes the prototype property from functions created from this\n             * FunctionTemplate.\n             */\n            void RemovePrototype();\n\n            /**\n             * Returns true if the given object is an instance of this function\n             * template.\n             */\n            bool HasInstance(Local<Value> object);\n\n            /**\n             * Returns true if the given value is an API object that was constructed by an\n             * instance of this function template (without checking for inheriting\n             * function templates).\n             *\n             * This is an experimental feature and may still change significantly.\n             */\n            bool IsLeafTemplateForApiObject(v8::Local<v8::Value> value) const;\n\n            V8_INLINE static FunctionTemplate* Cast(Data* data);\n\n            private:\n            FunctionTemplate();\n\n            static void CheckCast(Data* that);\n            friend class Context;\n            friend class ObjectTemplate;\n            };\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"PropertyHandlerFlags\",\n                \"about\": \"Configuration flags for NamedPropertyHandlerConfiguration and IndexedPropertyHandlerConfiguration.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class PropertyHandlerFlags {\n            /**\n             * None.\n             */\n            kNone = 0,\n\n            /**\n             * Will not call into interceptor for properties on the receiver or prototype\n             * chain, i.e., only call into interceptor for properties that do not exist.\n             * Currently only valid for named interceptors.\n             */\n            kNonMasking = 1,\n\n            /**\n             * Will not call into interceptor for symbol lookup.  Only meaningful for\n             * named interceptors.\n             */\n            kOnlyInterceptStrings = 1 << 1,\n\n            /**\n             * The getter, query, enumerator callbacks do not produce side effects.\n             */\n            kHasNoSideEffect = 1 << 2,\n\n            /**\n             * This flag is used to distinguish which callbacks were provided -\n             * GenericNamedPropertyXXXCallback (old signature) or\n             * NamedPropertyXXXCallback (new signature).\n             * DO NOT use this flag, it'll be removed once embedders migrate to new\n             * callbacks signatures.\n             */\n            kInternalNewCallbacksSignatures = 1 << 10,\n            };\n        ]]></code>\n    </enum>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"NamedPropertyHandlerConfiguration\",\n                \"about\": \"Configuration structure for named property handlers.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"NamedPropertyGetterCallback\",\n                    \"NamedPropertySetterCallback\",\n                    \"NamedPropertyQueryCallback\",\n                    \"NamedPropertyDeleterCallback\",\n                    \"NamedPropertyEnumeratorCallback\",\n                    \"NamedPropertyDefinerCallback\",\n                    \"NamedPropertyDescriptorCallback\",\n                    \"Local\",\n                    \"Value\",\n                    \"PropertyHandlerFlags\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct NamedPropertyHandlerConfiguration {\n            private:\n            static constexpr PropertyHandlerFlags WithNewSignatureFlag(\n                PropertyHandlerFlags flags) {\n                return static_cast<PropertyHandlerFlags>(\n                    static_cast<int>(flags) |\n                    static_cast<int>(\n                        PropertyHandlerFlags::kInternalNewCallbacksSignatures));\n            }\n\n            public:\n            NamedPropertyHandlerConfiguration(\n                NamedPropertyGetterCallback getter,          //\n                NamedPropertySetterCallback setter,          //\n                NamedPropertyQueryCallback query,            //\n                NamedPropertyDeleterCallback deleter,        //\n                NamedPropertyEnumeratorCallback enumerator,  //\n                NamedPropertyDefinerCallback definer,        //\n                NamedPropertyDescriptorCallback descriptor,  //\n                Local<Value> data = Local<Value>(),\n                PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)\n                : getter(getter),\n                setter(setter),\n                query(query),\n                deleter(deleter),\n                enumerator(enumerator),\n                definer(definer),\n                descriptor(descriptor),\n                data(data),\n                flags(flags) {}\n\n            explicit NamedPropertyHandlerConfiguration(\n                NamedPropertyGetterCallback getter,\n                NamedPropertySetterCallback setter = nullptr,\n                NamedPropertyQueryCallback"
}