{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-graph-assembler.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-graph-assembler.cc\",\n            \"file_name\": \"wasm-graph-assembler.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides a utility class, WasmGraphAssembler, for constructing a graph representation of WebAssembly code within the V8 compiler.\"\n        }\n    </metadata>\n\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for the WasmGraphAssembler class, V8 internals, and WebAssembly specific definitions.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/wasm-graph-assembler.h\"\n\n#include \"src/common/globals.h\"\n#include \"src/compiler/access-builder.h\"\n#include \"src/compiler/diamond.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/wasm-compiler-definitions.h\"\n#include \"src/objects/string.h\"\n#include \"src/wasm/object-access.h\"\n#include \"src/wasm/wasm-objects.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetBuiltinCallDescriptor\",\n                \"about\": \"Creates a CallDescriptor for calls to built-in functions.\",\n                \"logic\": \"Uses Builtins::CallInterfaceDescriptorFor to obtain the appropriate interface descriptor.  Then uses Linkage::GetStubCallDescriptor to construct and return the CallDescriptor.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"Builtin\",\n                        \"purpose\": \"The identifier for the built-in function.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to allocate the CallDescriptor in.\"\n                    },\n                    {\n                        \"name\": \"stub_mode\",\n                        \"type\": \"StubCallMode\",\n                        \"purpose\": \"The stub call mode.\"\n                    },\n                    {\n                        \"name\": \"needs_frame_state\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether a frame state is needed.\"\n                    },\n                    {\n                        \"name\": \"properties\",\n                        \"type\": \"Operator::Properties\",\n                        \"purpose\": \"The properties of the operator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"CallDescriptor*\",\n                    \"description\": \"A pointer to the created CallDescriptor.\"\n                },\n                \"dependencies\": [\n                    \"Builtins\",\n                    \"CallInterfaceDescriptor\",\n                    \"Linkage\",\n                    \"CallDescriptor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nCallDescriptor* GetBuiltinCallDescriptor(Builtin name, Zone* zone,\n                                         StubCallMode stub_mode,\n                                         bool needs_frame_state,\n                                         Operator::Properties properties) {\n  CallInterfaceDescriptor interface_descriptor =\n      Builtins::CallInterfaceDescriptorFor(name);\n  return Linkage::GetStubCallDescriptor(\n      zone,                                           // zone\n      interface_descriptor,                           // descriptor\n      interface_descriptor.GetStackParameterCount(),  // stack parameter count\n      needs_frame_state ? CallDescriptor::kNeedsFrameState\n                        : CallDescriptor::kNoFlags,  // flags\n      properties,                                    // properties\n      stub_mode);                                    // stub call mode\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ObjectAccessForGCStores\",\n                \"about\": \"Determines the ObjectAccess parameters for garbage-collected stores based on the value type.\",\n                \"logic\": \"Returns an ObjectAccess struct, setting the MachineType and write barrier flag according to the provided ValueType.  It uses kFullWriteBarrier for references, kNoWriteBarrier otherwise.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"wasm::ValueType\",\n                        \"purpose\": \"The value type being stored.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ObjectAccess\",\n                    \"description\": \"The ObjectAccess parameters for the store.\"\n                },\n                \"dependencies\": [\n                    \"ObjectAccess\",\n                    \"MachineType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nObjectAccess ObjectAccessForGCStores(wasm::ValueType type) {\n  return ObjectAccess(\n      MachineType::TypeForRepresentation(type.machine_representation(),\n                                         !type.is_packed()),\n      type.is_reference() ? kFullWriteBarrier : kNoWriteBarrier);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmGraphAssembler\",\n                \"about\": \"Provides helper methods for building a graph representation for WebAssembly code.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Node\",\n                    \"MachineGraph\",\n                    \"CommonOperatorBuilder\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"Zone\",\n                    \"wasm::ValueType\",\n                    \"ObjectAccess\",\n                    \"BranchHint\",\n                    \"Diamond\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::compiler {\n\nclass WasmGraphAssembler {\n public:\n  explicit WasmGraphAssembler(MachineGraph* mcgraph, Zone* zone)\n      : mcgraph_(mcgraph),\n        simplified_(zone),\n        graph_(mcgraph->graph()),\n        control_(graph()->start()),\n        effect_(graph()->start()) {}\n\n  Graph* graph() { return graph_; }\n  MachineGraph* mcgraph() { return mcgraph_; }\n  Node* control() { return control_; }\n  void set_control(Node* control) { control_ = control; }\n  Node* effect() { return effect_; }\n  void set_effect(Node* effect) { effect_ = effect; }\n\n  Node* AddNode(Node* node) {\n    set_effect(node);\n    return node;\n  }\n\n  // Sets {true_node} and {false_node} to their corresponding Branch outputs.\n  // Returns the Branch node. Does not change control().\n  Node* Branch(Node* cond, Node** true_node, Node** false_node,\n                                  BranchHint hint);\n\n  Node* BuildTruncateIntPtrToInt32(Node* value);\n  Node* BuildChangeInt32ToIntPtr(Node* value);\n  Node* BuildChangeIntPtrToInt64(Node* value);\n  Node* BuildChangeUint32ToUintPtr(Node* node);\n  Node* BuildSmiShiftBitsConstant();\n  Node* BuildSmiShiftBitsConstant32();\n  Node* BuildChangeInt32ToSmi(Node* value);\n  Node* BuildChangeUint31ToSmi(Node* value);\n  Node* BuildChangeSmiToInt32(Node* value);\n  Node* BuildConvertUint32ToSmiWithSaturation(Node* value, uint32_t maxval);\n  Node* BuildChangeSmiToIntPtr(Node* value);\n\n  // Helper functions for dealing with HeapObjects.\n  // Rule of thumb: if access to a given field in an object is required in\n  // at least two places, put a helper function here.\n\n  Node* Allocate(int size);\n  Node* Allocate(Node* size);\n  Node* LoadFromObject(MachineType type, Node* base, Node* offset);\n  Node* LoadProtectedPointerFromObject(Node* object, Node* offset);\n  Node* LoadImmutableProtectedPointerFromObject(Node* object, Node* offset);\n  Node* LoadImmutableFromObject(MachineType type, Node* base, Node* offset);\n  Node* LoadImmutable(LoadRepresentation rep, Node* base, Node* offset);\n  Node* LoadWasmCodePointer(Node* code_pointer);\n  Node* StoreToObject(ObjectAccess access, Node* base, Node* offset,\n                                  Node* value);\n  Node* InitializeImmutableInObject(ObjectAccess access, Node* base,\n                                                      Node* offset,\n                                                      Node* value);\n\n  Node* BuildDecodeSandboxedExternalPointer(\n      Node* handle, ExternalPointerTagRange tag_range, Node* isolate_root);\n  Node* BuildDecodeTrustedPointer(Node* handle, IndirectPointerTag tag);\n  Node* BuildLoadExternalPointerFromObject(Node* object, int field_offset,\n                                           ExternalPointerTagRange tag_range,\n                                           Node* isolate_root);\n\n  Node* IsSmi(Node* object);\n\n  // Maps and their contents.\n  Node* LoadMap(Node* object);\n  void StoreMap(Node* heap_object, Node* map);\n  Node* LoadInstanceType(Node* map);\n  Node* LoadWasmTypeInfo(Node* map);\n\n  // FixedArrays.\n  Node* LoadFixedArrayLengthAsSmi(Node* fixed_array);\n  Node* LoadFixedArrayElement(Node* fixed_array, Node* index_intptr,\n                                                MachineType type);\n  Node* LoadWeakFixedArrayElement(Node* fixed_array,\n                                                    Node* index_intptr);\n  Node* LoadImmutableFixedArrayElement(Node* fixed_array,\n                                                         Node* index_intptr,\n                                                         MachineType type);\n  Node* LoadFixedArrayElement(Node* array, int index,\n                                                MachineType type);\n  Node* LoadProtectedFixedArrayElement(Node* array,\n                                                         int index);\n  Node* LoadProtectedFixedArrayElement(Node* array,\n                                                         Node* index_intptr);\n  Node* LoadByteArrayElement(Node* byte_array,\n                                               Node* index_intptr,\n                                               MachineType type);\n  Node* LoadImmutableTrustedPointerFromObject(\n      Node* object, int field_offset, IndirectPointerTag tag);\n  Node* LoadTrustedPointerFromObject(Node* object,\n                                                       int field_offset,\n                                                       IndirectPointerTag tag);\n  std::pair<Node*, Node*>\n  LoadTrustedPointerFromObjectTrapOnNull(\n    Node* object, int field_offset, IndirectPointerTag tag);\n  Node* StoreFixedArrayElement(Node* array, int index,\n                                                 Node* value,\n                                                 ObjectAccess access);\n\n  // Functions, SharedFunctionInfos, FunctionData.\n  Node* LoadSharedFunctionInfo(Node* js_function);\n  Node* LoadContextFromJSFunction(Node* js_function);\n  Node* LoadFunctionDataFromJSFunction(Node* js_function);\n  Node* LoadExportedFunctionIndexAsSmi(\n    Node* exported_function_data);\n  Node* LoadExportedFunctionInstanceData(\n    Node* exported_function_data);\n\n  // JavaScript objects.\n  Node* LoadJSArrayElements(Node* js_array);\n\n  // WasmGC objects.\n  Node* FieldOffset(const wasm::StructType* type,\n                                      uint32_t field_index);\n  Node* WasmArrayElementOffset(Node* index, wasm::ValueType element_type);\n  Node* IsDataRefMap(Node* map);\n  Node* WasmTypeCheck(Node* object, Node* rtt,\n                                        WasmTypeCheckConfig config);\n  Node* WasmTypeCheckAbstract(Node* object,\n                                                WasmTypeCheckConfig config);\n  Node* WasmTypeCast(Node* object, Node* rtt,\n                                       WasmTypeCheckConfig config);\n  Node* WasmTypeCastAbstract(Node* object,\n                                               WasmTypeCheckConfig config);\n  Node* Null(wasm::ValueType type);\n  Node* IsNull(Node* object, wasm::ValueType type);\n  Node* IsNotNull(Node* object, wasm::ValueType type);\n  Node* AssertNotNull(Node* object, wasm::ValueType type,\n                                        TrapId trap_id);\n  Node* WasmAnyConvertExtern(Node* object);\n  Node* WasmExternConvertAny(Node* object);\n  Node* StructGet(Node* object, const wasm::StructType* type,\n                                    int field_index, bool is_signed,\n                                    CheckForNull null_check);\n  void StructSet(Node* object, Node* value,\n                                   const wasm::StructType* type,\n                                   int field_index, CheckForNull null_check);\n  Node* ArrayGet(Node* array, Node* index,\n                                   const wasm::ArrayType* type,\n                                   bool is_signed);\n  void ArraySet(Node* array, Node* index, Node* value,\n                                  const wasm::ArrayType* type);\n  Node* ArrayLength(Node* array, CheckForNull null_check);\n  void ArrayInitializeLength(Node* array, Node* length);\n  Node* LoadStringLength(Node* string);\n  Node* StringAsWtf16(Node* string);\n  Node* StringPrepareForGetCodeunit(Node* string);\n  Node* LoadTrustedDataFromInstanceObject(\n    Node* instance_object);\n\n  // Generic HeapObject helpers.\n  Node* HasInstanceType(Node* heap_object, InstanceType type);\n\n private:\n  MachineGraph* mcgraph_;\n  SimplifiedOperatorBuilder simplified_;\n  Graph* graph_;\n  Node* control_;\n  Node* effect_;\n};\n\n}  // namespace v8::internal::compiler\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Branch\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Creates a Branch node and its corresponding IfTrue and IfFalse nodes.\",\n                \"logic\": \"Creates a Branch node based on the condition, then creates IfTrue and IfFalse nodes that consume the Branch node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cond\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The condition node for the branch.\"\n                    },\n                    {\n                        \"name\": \"true_node\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Output parameter to store the IfTrue node.\"\n                    },\n                    {\n                        \"name\": \"false_node\",\n                        \"type\": \"Node**\",\n                        \"purpose\": \"Output parameter to store the IfFalse node.\"\n                    },\n                    {\n                        \"name\": \"hint\",\n                        \"type\": \"BranchHint\",\n                        \"purpose\": \"Hint for the branch prediction.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The Branch node.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"CommonOperatorBuilder\",\n                    \"BranchHint\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::Branch(Node* cond, Node** true_node,\n                                 Node** false_node, BranchHint hint) {\n  DCHECK_NOT_NULL(cond);\n  Node* branch =\n      graph()->NewNode(mcgraph()->common()->Branch(hint), cond, control());\n  *true_node = graph()->NewNode(mcgraph()->common()->IfTrue(), branch);\n  *false_node = graph()->NewNode(mcgraph()->common()->IfFalse(), branch);\n  return branch;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildTruncateIntPtrToInt32\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Truncates an IntPtr (intptr_t) to an Int32.\",\n                \"logic\": \"If the machine is 64-bit, it explicitly truncates the Int64 to Int32. Otherwise, it returns the original value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The IntPtr value to truncate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The truncated Int32 value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"TruncateInt64ToInt32\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildTruncateIntPtrToInt32(Node* value) {\n  return mcgraph()->machine()->Is64() ? TruncateInt64ToInt32(value) : value;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildChangeInt32ToIntPtr\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Changes an Int32 to an IntPtr.\",\n                \"logic\": \"If the machine is 64-bit, it explicitly changes the Int32 to Int64. Otherwise, it returns the original value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Int32 value to change.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The IntPtr value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"ChangeInt32ToInt64\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildChangeInt32ToIntPtr(Node* value) {\n  return mcgraph()->machine()->Is64() ? ChangeInt32ToInt64(value) : value;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildChangeIntPtrToInt64\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Changes an IntPtr to an Int64.\",\n                \"logic\": \"If the machine is 32-bit, it explicitly changes the Int32 to Int64. Otherwise, it returns the original value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The IntPtr value to change.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The Int64 value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"ChangeInt32ToInt64\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildChangeIntPtrToInt64(Node* value) {\n  return mcgraph()->machine()->Is32() ? ChangeInt32ToInt64(value) : value;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildChangeUint32ToUintPtr\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Changes a Uint32 to a UintPtr.\",\n                \"logic\": \"If the machine is 32-bit, it returns the original value. If the node is an IntConstant it converts the constant directly. Otherwise, it changes the Uint32 to Uint64.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Uint32 value to change.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The UintPtr value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"ChangeUint32ToUint64\",\n                    \"Node\",\n                    \"Uint32Matcher\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildChangeUint32ToUintPtr(Node* node) {\n  if (mcgraph()->machine()->Is32()) return node;\n  // Fold instances of ChangeUint32ToUint64(IntConstant) directly.\n  Uint32Matcher matcher(node);\n  if (matcher.HasResolvedValue()) {\n    uintptr_t value = matcher.ResolvedValue();\n    return mcgraph()->IntPtrConstant(base::bit_cast<intptr_t>(value));\n  }\n  return ChangeUint32ToUint64(node);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildSmiShiftBitsConstant\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Builds a constant node representing the number of bits to shift for Smi representation.\",\n                \"logic\": \"Creates an IntPtr constant with the value kSmiShiftSize + kSmiTagSize.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The IntPtr constant node.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildSmiShiftBitsConstant() {\n  return IntPtrConstant(kSmiShiftSize + kSmiTagSize);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildSmiShiftBitsConstant32\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Builds a constant node representing the number of bits to shift for Smi representation (32 bit version).\",\n                \"logic\": \"Creates an Int32 constant with the value kSmiShiftSize + kSmiTagSize.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The Int32 constant node.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildSmiShiftBitsConstant32() {\n  return Int32Constant(kSmiShiftSize + kSmiTagSize);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildChangeInt32ToSmi\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Changes an Int32 to a Smi.\",\n                \"logic\": \"If pointer compression is enabled, it bitcasts the shifted Int32 to Word64. Otherwise, it shifts the IntPtr and returns it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Int32 value to change.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The Smi value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"BitcastWord32ToWord64\",\n                    \"Word32Shl\",\n                    \"BuildSmiShiftBitsConstant32\",\n                    \"WordShl\",\n                    \"BuildChangeInt32ToIntPtr\",\n                    \"BuildSmiShiftBitsConstant\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildChangeInt32ToSmi(Node* value) {\n  // With pointer compression, only the lower 32 bits are used.\n  return COMPRESS_POINTERS_BOOL ? BitcastWord32ToWord64(Word32Shl(\n                                      value, BuildSmiShiftBitsConstant32()))\n                                : WordShl(BuildChangeInt32ToIntPtr(value),\n                                          BuildSmiShiftBitsConstant());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildChangeUint31ToSmi\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Changes a Uint31 to a Smi.\",\n                \"logic\": \"If pointer compression is enabled, it shifts the value. Otherwise, it changes the Uint32 to UintPtr, shifts it, and returns it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Uint31 value to change.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The Smi value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Word32Shl\",\n                    \"BuildSmiShiftBitsConstant32\",\n                    \"WordShl\",\n                    \"BuildChangeUint32ToUintPtr\",\n                    \"BuildSmiShiftBitsConstant\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildChangeUint31ToSmi(Node* value) {\n  return COMPRESS_POINTERS_BOOL\n             ? Word32Shl(value, BuildSmiShiftBitsConstant32())\n             : WordShl(BuildChangeUint32ToUintPtr(value),\n                       BuildSmiShiftBitsConstant());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildChangeSmiToInt32\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Changes a Smi to an Int32.\",\n                \"logic\": \"If pointer compression is enabled, it arithmetically shifts the Smi. Otherwise, it arithmetically shifts the Smi and truncates it to Int32.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Smi value to change.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The Int32 value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"Word32Sar\",\n                    \"BuildSmiShiftBitsConstant32\",\n                    \"BuildTruncateIntPtrToInt32\",\n                    \"WordSar\",\n                    \"BuildSmiShiftBitsConstant\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildChangeSmiToInt32(Node* value) {\n  return COMPRESS_POINTERS_BOOL\n             ? Word32Sar(value, BuildSmiShiftBitsConstant32())\n             : BuildTruncateIntPtrToInt32(\n                   WordSar(value, BuildSmiShiftBitsConstant()));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildConvertUint32ToSmiWithSaturation\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Converts a Uint32 to a Smi with saturation.\",\n                \"logic\": \"Checks if the Uint32 is less than or equal to maxval. If it is, it changes the Uint32 to a Smi. Otherwise, it uses maxsmi.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Uint32 value to convert.\"\n                    },\n                    {\n                        \"name\": \"maxval\",\n                        \"type\": \"uint32_t\",\n                        \"purpose\": \"The maximum value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The Smi value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"BuildChangeUint31ToSmi\",\n                    \"NumberConstant\",\n                    \"Uint32LessThanOrEqual\",\n                    \"Diamond\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildConvertUint32ToSmiWithSaturation(\n    Node* value, uint32_t maxval) {\n  DCHECK(Smi::IsValid(maxval));\n  Node* max = mcgraph()->Uint32Constant(maxval);\n  Node* check = Uint32LessThanOrEqual(value, max);\n  Node* valsmi = BuildChangeUint31ToSmi(value);\n  Node* maxsmi = NumberConstant(maxval);\n  Diamond d(graph(), mcgraph()->common(), check, BranchHint::kTrue);\n  d.Chain(control());\n  return d.Phi(MachineRepresentation::kTagged, valsmi, maxsmi);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BuildChangeSmiToIntPtr\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Changes a Smi to an IntPtr.\",\n                \"logic\": \"If pointer compression is enabled, it arithmetically shifts the Smi and converts it to an IntPtr. Otherwise, it arithmetically shifts the Smi.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Smi value to change.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The IntPtr value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"BuildChangeInt32ToIntPtr\",\n                    \"Word32Sar\",\n                    \"BuildSmiShiftBitsConstant32\",\n                    \"WordSar\",\n                    \"BuildSmiShiftBitsConstant\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::BuildChangeSmiToIntPtr(Node* value) {\n  return COMPRESS_POINTERS_BOOL ? BuildChangeInt32ToIntPtr(Word32Sar(\n                                      value, BuildSmiShiftBitsConstant32()))\n                                : WordSar(value, BuildSmiShiftBitsConstant());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Allocate\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Allocates a memory block of the specified size.\",\n                \"logic\": \"Creates an AllocateRaw node with the specified size and allocation type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"size\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The size of the memory block to allocate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the allocated memory block.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::Allocate(int size) {\n  return Allocate(Int32Constant(size));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Allocate\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Allocates a memory block of the specified size (Node* version).\",\n                \"logic\": \"Creates an AllocateRaw node with the specified size and allocation type.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"size\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The size of the memory block to allocate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the allocated memory block.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::Allocate(Node* size) {\n  return AddNode(graph()->NewNode(\n      simplified_.AllocateRaw(Type::Any(), AllocationType::kYoung), size,\n      effect(), control()));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LoadFromObject\",\n                \"parent\": \"WasmGraphAssembler\",\n                \"about\": \"Loads a value from an object at a specified offset.\",\n                \"logic\": \"Creates a LoadFromObject node with the specified MachineType and ObjectAccess.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"MachineType\",\n                        \"purpose\": \"The MachineType of the value to load.\"\n                    },\n                    {\n                        \"name\": \"base\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The base object to load from.\"\n                    },\n                    {\n                        \"name\": \"offset\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The offset from the base object to load from.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The loaded value.\"\n                },\n                \"dependencies\": [\n                    \"MachineGraph\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"Node\",\n                    \"ObjectAccess\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* WasmGraphAssembler::LoadFromObject(MachineType type, Node* base,\n                                         Node* offset) {\n  return AddNode(graph()->NewNode(\n      simplified_.LoadFromObject(ObjectAccess(type, kNoWriteBarrier)), base,\n      offset, effect(), control()));\n}\n        ]]></code>\n    </func>\n\n    <"
}