{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/mips64/simulator-mips64.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/mips64/simulator-mips64.h\",\n        \"file_name\": \"simulator-mips64.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the Simulator class for MIPS64 instructions, used when not generating native MIPS64 binaries.  Allows running and debugging MIPS64 code on other architectures.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include guard\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifndef V8_EXECUTION_MIPS64_SIMULATOR_MIPS64_H_\n            #define V8_EXECUTION_MIPS64_SIMULATOR_MIPS64_H_\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes USE_SIMULATOR definition\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Compare\",\n            \"about\": \"Compares two values of the same type.\",\n            \"logic\": \"Returns 0 if a == b, -1 if a < b, and 1 if a > b.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"T\",\n                    \"purpose\": \"First value to compare.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"T\",\n                    \"purpose\": \"Second value to compare.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"0, -1, or 1 depending on the comparison result.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            int Compare(const T& a, const T& b) {\n              if (a == b)\n                return 0;\n              else if (a < b)\n                return -1;\n              else\n                return 1;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Nabs\",\n            \"about\": \"Returns the negative absolute value of a signed number.\",\n            \"logic\": \"If a is negative, returns a; otherwise, returns -a.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The value for which to compute the negative absolute value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T\",\n                \"description\": \"The negative absolute value of a.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T,\n                      typename = typename std::enable_if<std::is_signed<T>::value>::type>\n            T Nabs(T a) {\n              return a < 0 ? a : -a;\n            }\n        ]]></code>\n    </func>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Conditional compilation based on USE_SIMULATOR\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #if defined(USE_SIMULATOR)\n            // Running with a simulator.\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for simulator functionality\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/hashmap.h\"\n            #include \"src/base/strings.h\"\n            #include \"src/codegen/assembler.h\"\n            #include \"src/codegen/mips64/constants-mips64.h\"\n            #include \"src/execution/simulator-base.h\"\n            #include \"src/utils/allocation.h\"\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8\",\n            \"purpose\": \"Namespace for the V8 JavaScript engine\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"internal\",\n            \"purpose\": \"Internal namespace within V8\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n        ]]></code>\n    </namespace>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CachePage\",\n            \"about\": \"Represents a page in the instruction cache used by the simulator.\",\n            \"attributes\": [\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"char[kPageSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The cached data.\"\n                },\n                {\n                    \"name\": \"validity_map_\",\n                    \"type\": \"char[kValidityMapSize]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"One byte per cache line, indicating validity.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class CachePage {\n             public:\n              static const int LINE_VALID = 0;\n              static const int LINE_INVALID = 1;\n\n              static const int kPageShift = 12;\n              static const int kPageSize = 1 << kPageShift;\n              static const int kPageMask = kPageSize - 1;\n              static const int kLineShift = 2;  // The cache line is only 4 bytes right now.\n              static const int kLineLength = 1 << kLineShift;\n              static const int kLineMask = kLineLength - 1;\n\n              CachePage() { memset(&validity_map_, LINE_INVALID, sizeof(validity_map_)); }\n\n              char* ValidityByte(int offset) {\n                return &validity_map_[offset >> kLineShift];\n              }\n\n              char* CachedData(int offset) { return &data_[offset]; }\n\n             private:\n              char data_[kPageSize];  // The cached data.\n              static const int kValidityMapSize = kPageSize >> kLineShift;\n              char validity_map_[kValidityMapSize];  // One byte per line.\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimInstructionBase\",\n            \"extends\": \"InstructionBase\",\n            \"about\": \"Base class for simulator instructions, providing basic instruction properties.\",\n            \"attributes\": [\n                {\n                    \"name\": \"operand_\",\n                    \"type\": \"int32_t\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Integer representation of the instruction.\"\n                },\n                {\n                    \"name\": \"instr_\",\n                    \"type\": \"Instruction*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"Pointer to the actual Instruction object.\"\n                },\n                {\n                    \"name\": \"type_\",\n                    \"type\": \"Type\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"The type of the instruction\"\n                }\n            ],\n            \"dependencies\": [\n                \"InstructionBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SimInstructionBase : public InstructionBase {\n             public:\n              Type InstructionType() const { return type_; }\n              inline Instruction* instr() const { return instr_; }\n              inline int32_t operand() const { return operand_; }\n\n             protected:\n              SimInstructionBase() : operand_(-1), instr_(nullptr), type_(kUnsupported) {}\n              explicit SimInstructionBase(Instruction* instr) {}\n\n              int32_t operand_;\n              Instruction* instr_;\n              Type type_;\n\n             private:\n              DISALLOW_ASSIGN(SimInstructionBase);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimInstruction\",\n            \"extends\": \"InstructionGetters<SimInstructionBase>\",\n            \"about\": \"Represents a MIPS instruction in the simulator, extending SimInstructionBase with instruction getter functionalities.\",\n            \"dependencies\": [\n                \"InstructionGetters\",\n                \"SimInstructionBase\",\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class SimInstruction : public InstructionGetters<SimInstructionBase> {\n             public:\n              SimInstruction() {}\n\n              explicit SimInstruction(Instruction* instr) { *this = instr; }\n\n              SimInstruction& operator=(Instruction* instr) {\n                operand_ = *reinterpret_cast<const int32_t*>(instr);\n                instr_ = instr;\n                type_ = InstructionBase::InstructionType();\n                DCHECK(reinterpret_cast<void*>(&operand_) == this);\n                return *this;\n              }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Simulator\",\n            \"extends\": \"SimulatorBase\",\n            \"about\": \"The MIPS64 instruction simulator.\",\n            \"attributes\": [\n                {\n                    \"name\": \"registers_\",\n                    \"type\": \"int64_t[kNumSimuRegisters]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"General-purpose registers.\"\n                },\n                {\n                    \"name\": \"FPUregisters_\",\n                    \"type\": \"int64_t[kNumFPURegisters * 2]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Floating-point registers.\"\n                },\n                {\n                    \"name\": \"FCSR_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"FPU control register.\"\n                },\n                {\n                    \"name\": \"MSACSR_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"MSA control register.\"\n                },\n                {\n                    \"name\": \"stack_\",\n                    \"type\": \"uintptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stack pointer for the simulator.\"\n                },\n                {\n                    \"name\": \"stack_limit_\",\n                    \"type\": \"uintptr_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stack limit for overflow detection.\"\n                },\n                {\n                    \"name\": \"pc_modified_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the program counter has been modified.\"\n                },\n                {\n                    \"name\": \"icount_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Instruction counter.\"\n                },\n                {\n                    \"name\": \"break_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Breakpoint counter.\"\n                },\n                {\n                    \"name\": \"trace_buf_\",\n                    \"type\": \"base::EmbeddedVector<char, 128>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Trace buffer for debugging.\"\n                },\n                {\n                    \"name\": \"last_debugger_input_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Last debugger input.\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"v8::internal::Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the V8 isolate.\"\n                },\n                {\n                    \"name\": \"break_pc_\",\n                    \"type\": \"Instruction*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Breakpoint address.\"\n                },\n                {\n                    \"name\": \"break_instr_\",\n                    \"type\": \"Instr\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The instruction at the breakpoint address\"\n                },\n                {\n                    \"name\": \"watched_stops_\",\n                    \"type\": \"StopCountAndDesc[kMaxStopCode + 1]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of stop codes, counters and descriptions.\"\n                },\n                {\n                    \"name\": \"local_monitor_\",\n                    \"type\": \"LocalMonitor\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Local monitor used for exclusive memory access.\"\n                },\n                {\n                    \"name\": \"global_monitor_thread_\",\n                    \"type\": \"GlobalMonitor::LinkedAddress\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Thread linked to the global monitor for exclusive memory access.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SimulatorBase\",\n                \"Isolate\",\n                \"base::CustomMatcherHashMap\",\n                \"Instruction\",\n                \"SimInstruction\",\n                \"EncodedCSignature\",\n                \"LocalMonitor\",\n                \"GlobalMonitor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Simulator : public SimulatorBase {\n             public:\n              friend class MipsDebugger;\n\n              // Registers are declared in order. See SMRL chapter 2.\n              enum Register {\n                no_reg = -1,\n                zero_reg = 0,\n                at,\n                v0,\n                v1,\n                a0,\n                a1,\n                a2,\n                a3,\n                a4,\n                a5,\n                a6,\n                a7,\n                t0,\n                t1,\n                t2,\n                t3,\n                s0,\n                s1,\n                s2,\n                s3,\n                s4,\n                s5,\n                s6,\n                s7,\n                t8,\n                t9,\n                k0,\n                k1,\n                gp,\n                sp,\n                s8,\n                ra,\n                // LO, HI, and pc.\n                LO,\n                HI,\n                pc,  // pc must be the last register.\n                kNumSimuRegisters,\n                // aliases\n                fp = s8\n              };\n\n              // Coprocessor registers.\n              // Generated code will always use doubles. So we will only use even registers.\n              enum FPURegister {\n                f0,\n                f1,\n                f2,\n                f3,\n                f4,\n                f5,\n                f6,\n                f7,\n                f8,\n                f9,\n                f10,\n                f11,\n                f12,\n                f13,\n                f14,\n                f15,  // f12 and f14 are arguments FPURegisters.\n                f16,\n                f17,\n                f18,\n                f19,\n                f20,\n                f21,\n                f22,\n                f23,\n                f24,\n                f25,\n                f26,\n                f27,\n                f28,\n                f29,\n                f30,\n                f31,\n                kNumFPURegisters\n              };\n\n              // MSA registers\n              enum MSARegister {\n                w0,\n                w1,\n                w2,\n                w3,\n                w4,\n                w5,\n                w6,\n                w7,\n                w8,\n                w9,\n                w10,\n                w11,\n                w12,\n                w13,\n                w14,\n                w15,\n                w16,\n                w17,\n                w18,\n                w19,\n                w20,\n                w21,\n                w22,\n                w23,\n                w24,\n                w25,\n                w26,\n                w27,\n                w28,\n                w29,\n                w30,\n                w31,\n                kNumMSARegisters\n              };\n\n              explicit Simulator(Isolate* isolate);\n              ~Simulator();\n\n              // The currently executing Simulator instance. Potentially there can be one\n              // for each native thread.\n              V8_EXPORT_PRIVATE static Simulator* current(v8::internal::Isolate* isolate);\n\n              // Accessors for register state. Reading the pc value adheres to the MIPS\n              // architecture specification and is off by a 8 from the currently executing\n              // instruction.\n              void set_register(int reg, int64_t value);\n              void set_register_word(int reg, int32_t value);\n              void set_dw_register(int dreg, const int* dbl);\n              V8_EXPORT_PRIVATE int64_t get_register(int reg) const;\n              double get_double_from_register_pair(int reg);\n              // Same for FPURegisters.\n              void set_fpu_register(int fpureg, int64_t value);\n              void set_fpu_register_word(int fpureg, int32_t value);\n              void set_fpu_register_hi_word(int fpureg, int32_t value);\n              void set_fpu_register_float(int fpureg, float value);\n              void set_fpu_register_double(int fpureg, double value);\n              void set_fpu_register_invalid_result64(float original, float rounded);\n              void set_fpu_register_invalid_result(float original, float rounded);\n              void set_fpu_register_word_invalid_result(float original, float rounded);\n              void set_fpu_register_invalid_result64(double original, double rounded);\n              void set_fpu_register_invalid_result(double original, double rounded);\n              void set_fpu_register_word_invalid_result(double original, double rounded);\n              int64_t get_fpu_register(int fpureg) const;\n              int32_t get_fpu_register_word(int fpureg) const;\n              int32_t get_fpu_register_signed_word(int fpureg) const;\n              int32_t get_fpu_register_hi_word(int fpureg) const;\n              float get_fpu_register_float(int fpureg) const;\n              double get_fpu_register_double(int fpureg) const;\n              template <typename T>\n              void get_msa_register(int wreg, T* value);\n              template <typename T>\n              void set_msa_register(int wreg, const T* value);\n              void set_fcsr_bit(uint32_t cc, bool value);\n              bool test_fcsr_bit(uint32_t cc);\n              bool set_fcsr_round_error(double original, double rounded);\n              bool set_fcsr_round64_error(double original, double rounded);\n              bool set_fcsr_round_error(float original, float rounded);\n              bool set_fcsr_round64_error(float original, float rounded);\n              void round_according_to_fcsr(double toRound, double* rounded,\n                                           int32_t* rounded_int, double fs);\n              void round64_according_to_fcsr(double toRound, double* rounded,\n                                             int64_t* rounded_int, double fs);\n              void round_according_to_fcsr(float toRound, float* rounded,\n                                           int32_t* rounded_int, float fs);\n              void round64_according_to_fcsr(float toRound, float* rounded,\n                                             int64_t* rounded_int, float fs);\n              template <typename T_fp, typename T_int>\n              void round_according_to_msacsr(T_fp toRound, T_fp* rounded,\n                                             T_int* rounded_int);\n              void clear_fcsr_cause();\n              void set_fcsr_rounding_mode(FPURoundingMode mode);\n              void set_msacsr_rounding_mode(FPURoundingMode mode);\n              unsigned int get_fcsr_rounding_mode();\n              unsigned int get_msacsr_rounding_mode();\n              // Special case of set_register and get_register to access the raw PC value.\n              void set_pc(int64_t value);\n              V8_EXPORT_PRIVATE int64_t get_pc() const;\n\n              Address get_sp() const { return static_cast<Address>(get_register(sp)); }\n\n              // Accessor to the internal simulator stack area. Adds a safety\n              // margin to prevent overflows (kAdditionalStackMargin).\n              uintptr_t StackLimit(uintptr_t c_limit) const;\n\n              // Return central stack view, without additional safety margins.\n              // Users, for example wasm::StackMemory, can add their own.\n              base::Vector<uint8_t> GetCentralStackView() const;\n\n              // Executes MIPS instructions until the PC reaches end_sim_pc.\n              void Execute();\n\n              // Only arguments up to 64 bits in size are supported.\n              class CallArgument {\n               public:\n                template <typename T>\n                explicit CallArgument(T argument) {\n                  bits_ = 0;\n                  DCHECK(sizeof(argument) <= sizeof(bits_));\n                  bits_ = ConvertArg(argument);\n                  type_ = GP_ARG;\n                }\n\n                explicit CallArgument(double argument) {\n                  DCHECK(sizeof(argument) == sizeof(bits_));\n                  memcpy(&bits_, &argument, sizeof(argument));\n                  type_ = FP_ARG;\n                }\n\n                explicit CallArgument(float argument) {\n                  // TODO(all): CallArgument(float) is untested.\n                  UNIMPLEMENTED();\n                }\n\n                // This indicates the end of the arguments list, so that CallArgument\n                // objects can be passed into varargs functions.\n                static CallArgument End() { return CallArgument(); }\n\n                int64_t bits() const { return bits_; }\n                bool IsEnd() const { return type_ == NO_ARG; }\n                bool IsGP() const { return type_ == GP_ARG; }\n                bool IsFP() const { return type_ == FP_ARG; }\n\n               private:\n                enum CallArgumentType { GP_ARG, FP_ARG, NO_ARG };\n\n                // All arguments are aligned to at least 64 bits and we don't support\n                // passing bigger arguments, so the payload size can be fixed at 64 bits.\n                int64_t bits_;\n                CallArgumentType type_;\n\n                CallArgument() { type_ = NO_ARG; }\n              };\n\n              template <typename Return, typename... Args>\n              Return Call(Address entry, Args... args) {\n                // Convert all arguments to CallArgument.\n                CallArgument call_args[] = {CallArgument(args)..., CallArgument::End()};\n                CallImpl(entry, call_args);\n                return ReadReturn<Return>();\n              }\n\n              // Alternative: call a 2-argument double function.\n              double CallFP(Address entry, double d0, double d1);\n\n              // Push an address onto the JS stack.\n              V8_EXPORT_PRIVATE uintptr_t PushAddress(uintptr_t address);\n\n              // Pop an address from the JS stack.\n              V8_EXPORT_PRIVATE uintptr_t PopAddress();\n\n              // Debugger input.\n              void set_last_debugger_input(char* input);\n              char* last_debugger_input() { return last_debugger_input_; }\n\n              // Redirection support.\n              static void SetRedirectInstruction(Instruction* instruction);\n\n              // ICache checking.\n              static bool ICacheMatch(void* one, void* two);\n              static void FlushICache(base::CustomMatcherHashMap* i_cache, void* start,\n                                      size_t size);\n\n              // Returns true if pc register contains one of the 'special_values' defined\n              // below (bad_ra, end_sim_pc).\n              bool has_bad_pc() const;\n\n             private:\n              enum special_values {\n                // Known bad pc value to ensure that the simulator does not execute\n                // without being properly setup.\n                bad_ra = -1,\n                // A pc value used to signal the simulator to stop execution.  Generally\n                // the ra is set to this value on transition from native C code to\n                // simulated execution, so that the simulator can \"return\" to the native\n                // C code.\n                end_sim_pc = -2,\n                // Unpredictable value.\n                Unpredictable = 0xbadbeaf\n              };\n\n              V8_EXPORT_PRIVATE void CallImpl(Address entry, CallArgument* args);\n\n              void CallAnyCTypeFunction(Address target_address,\n                                        const EncodedCSignature& signature);\n\n              // Read floating point return values.\n              template <typename T>\n              typename std::enable_if<std::is_floating_point<T>::value, T>::type\n              ReadReturn() {\n                return static_cast<T>(get_fpu_register_double(f0));\n              }\n              // Read non-float return values.\n              template <typename T>\n              typename std::enable_if<!std::is_floating_point<T>::value, T>::type\n              ReadReturn() {\n                return ConvertReturn<T>(get_register(v0));\n              }\n\n              // Unsupported instructions use Format to print an error and stop execution.\n              void Format(Instruction* instr, const char* format);\n\n              // Helpers for data value tracing.\n              enum TraceType {\n                BYTE,\n                HALF,\n                WORD,\n                DWORD,\n                FLOAT,\n                DOUBLE,\n                FLOAT_DOUBLE,\n                WORD_DWORD\n              };\n\n              // MSA Data Format\n              enum MSADataFormat { MSA_VECT = 0, MSA_BYTE, MSA_HALF, MSA_WORD, MSA_DWORD };\n              union msa_reg_t {\n                int8_t b[kMSALanesByte];\n                uint8_t ub[kMSALanesByte];\n                int16_t h[kMSALanesHalf];\n                uint16_t uh[kMSALanesHalf];\n                int32_t w[kMSALanesWord];\n                uint32_t uw[kMSALanesWord];\n                int64_t d[kMSALanesDword];\n                uint64_t ud[kMSALanesDword];\n              };\n\n              // Read and write memory.\n              inline uint32_t ReadBU(int64_t addr);\n              inline int32_t ReadB(int64_t addr);\n              inline void WriteB(int64_t addr, uint8_t value);\n              inline void WriteB(int64_t addr, int8_t value);\n\n              inline uint16_t ReadHU(int64_t addr, Instruction* instr);\n              inline int16_t ReadH(int64_t addr, Instruction* instr);\n              // Note: Overloaded on the sign of the value.\n              inline void WriteH(int64_t addr, uint16_t value, Instruction* instr);\n              inline void WriteH(int64_t addr, int16_t value, Instruction* instr);\n\n              inline uint32_t ReadWU(int64_t addr, Instruction* instr);\n              inline int32_t ReadW(int64_t addr, Instruction* instr, TraceType t = WORD);\n              inline void WriteW(int64_t addr, int32_t value, Instruction* instr);\n              void WriteConditionalW(int64_t addr, int32_t value, Instruction* instr,\n                                     int32_t rt_reg);\n              inline int64_t Read2W(int64_t addr, Instruction* instr);\n              inline void Write2W(int64_t addr, int64_t value, Instruction* instr);\n              inline void WriteConditional2W(int64_t addr, int64_t value,\n                                             Instruction* instr, int32_t rt_reg);\n\n              inline double ReadD(int64_t addr, Instruction* instr);\n              inline void WriteD(int64_t addr, double value, Instruction* instr);\n\n              template <typename T>\n              T ReadMem(int64_t addr, Instruction* instr);\n              template <typename T>\n              void WriteMem(int64_t addr, T value, Instruction* instr);\n\n              // Helper for debugging memory access.\n              inline void DieOrDebug();\n\n              void TraceRegWr(int64_t value, TraceType t = DWORD);\n              template <typename T>\n              void TraceMSARegWr(T* value, TraceType t);\n              template <typename T>\n              void TraceMSARegWr(T* value);\n              void TraceMemWr(int64_t addr, int64_t value, TraceType t);\n              void TraceMemRd(int64_t addr, int64_t value, TraceType t = DWORD);\n              template <typename T>\n              void TraceMemRd(int64_t addr, T value);\n              template <typename T>\n              void TraceMemWr(int64_t addr, T value);\n\n              // Operations depending on endianness.\n              // Get Double Higher / Lower word.\n              inline int32_t GetDoubleHIW(double* addr);\n              inline int32_t GetDoubleLOW(double* addr);\n              // Set Double Higher / Lower word.\n              inline int32_t SetDoubleHIW(double* addr);\n              inline int32_t SetDoubleLOW(double* addr);\n\n              SimInstruction instr_;\n\n              // functions called from DecodeTypeRegister.\n              void DecodeTypeRegisterCOP1();\n\n              void DecodeTypeRegisterCOP1X();\n\n              void DecodeTypeRegisterSPECIAL();\n\n              void DecodeTypeRegisterSPECIAL2();\n\n              void DecodeTypeRegisterSPECIAL3();\n\n              void DecodeTypeRegisterSRsType();\n\n              void DecodeTypeRegisterDRsType();\n\n              void DecodeTypeRegisterWRsType();\n\n              void DecodeTypeRegisterLRsType();\n\n              int DecodeMsaDataFormat();\n              void DecodeTypeMsaI8();\n              void DecodeTypeMsaI5();\n              void DecodeTypeMsaI10();\n              void DecodeTypeMsaELM();\n              void DecodeTypeMsaBIT();\n              void DecodeTypeMsaMI10();\n              void DecodeTypeMsa3R();\n              void DecodeTypeMsa3RF();\n              void DecodeTypeMsaVec();\n              void DecodeTypeMsa2R();\n              void DecodeTypeMsa2RF();\n              template <typename T>\n              T MsaI5InstrHelper(uint32_t opcode, T ws, int32_t i5);\n              template <typename T>\n              T MsaBitInstrHelper(uint32_t opcode, T wd, T ws, int32_t m);\n              template <typename T>\n              T Msa3RInstrHelper(uint32_t opcode, T wd, T ws, T wt);\n\n              // Executing is handled based on the instruction type.\n              void DecodeTypeRegister();\n\n              inline int32_t rs_reg() const { return instr_.RsValue(); }\n              inline int64_t rs() const { return get_register(rs_reg()); }\n              inline uint64_t rs_u() const {\n                return static_cast<uint64_t>(get_register(rs_reg()));\n              }\n              inline int32_t rt_reg() const { return instr_.RtValue(); }\n              inline int64_t rt() const { return get_register(rt_reg()); }\n              inline uint64_t rt_u() const {\n                return static_cast<uint64_t>(get_register(rt_reg()));\n              }\n              inline int32_t rd_reg() const { return instr_.RdValue(); }\n              inline int32_t fr_reg() const { return instr_.FrValue(); }\n              inline int32_t fs_reg() const { return instr_.FsValue(); }\n              inline int32_t ft_reg() const { return instr_.FtValue(); }\n              inline int32_t fd_reg() const { return instr_.FdValue(); }\n              inline int32_t sa() const { return instr_.SaValue(); }\n              inline int32_t lsa_sa() const { return instr_.LsaSaValue(); }\n              inline int32_t ws_reg() const { return instr_.WsValue(); }\n              inline int32_t wt_reg() const { return instr_.WtValue(); }\n              inline int32_t wd_reg() const { return instr_.WdValue(); }\n\n              inline void SetResult(const int32_t rd_reg, const int64_t alu_out) {\n                set_register(rd_reg, alu_out);\n                TraceRegWr(alu_out);\n              }\n\n              inline void SetFPUWordResult(int32_t fd_reg, int32_t alu_out) {\n                set_fpu_register_word(fd_reg, alu_out);\n                TraceRegWr(get_fpu_register(fd_reg), WORD);\n              }\n\n              inline void SetFPUWordResult2(int32_t fd_reg, int32_t alu_out) {\n                set_fpu_register_word(fd_reg, alu_out);\n                TraceRegWr(get_fpu_register(fd_reg));\n              }\n\n              inline void SetFPUResult(int32_t fd_reg, int64_t alu_out) {\n                set_fpu_register(fd_reg, alu_out);\n                TraceRegWr(get_fpu_register(fd_reg));\n              }\n\n              inline void Set"
}