{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/s390/code-generator-s390.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/s390/code-generator-s390.cc\",\n            \"file_name\": \"code-generator-s390.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the code generator for the s390 architecture in the V8 compiler backend.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for code generation, assembler operations, and compiler data structures.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/callable.h\"\n#include \"src/codegen/interface-descriptors-inl.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/backend/code-generator-impl.h\"\n#include \"src/compiler/backend/code-generator.h\"\n#include \"src/compiler/backend/gap-resolver.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/osr.h\"\n#include \"src/heap/mutable-page-metadata.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-linkage.h\"\n#include \"src/wasm/wasm-objects.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"S390OperandConverter\",\n                \"extends\": \"InstructionOperandConverter\",\n                \"about\": \"Converts InstructionOperands to S390-specific operands for code generation.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"CodeGenerator\",\n                    \"Instruction\",\n                    \"LocationOperand\",\n                    \"MachineRepresentation\",\n                    \"Constant\",\n                    \"AddressingModeField\",\n                    \"MemOperand\",\n                    \"FrameOffset\",\n                    \"AllocatedOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass S390OperandConverter final : public InstructionOperandConverter {\n public:\n  S390OperandConverter(CodeGenerator* gen, Instruction* instr)\n      : InstructionOperandConverter(gen, instr) {}\n\n  size_t OutputCount() { return instr_->OutputCount(); }\n\n  bool Is64BitOperand(int index) {\n    return LocationOperand::cast(instr_->InputAt(index))->representation() ==\n           MachineRepresentation::kWord64;\n  }\n\n  bool Is32BitOperand(int index) {\n    return LocationOperand::cast(instr_->InputAt(index))->representation() ==\n           MachineRepresentation::kWord32;\n  }\n\n  bool CompareLogical() const {\n    switch (instr_->flags_condition()) {\n      case kUnsignedLessThan:\n      case kUnsignedGreaterThanOrEqual:\n      case kUnsignedLessThanOrEqual:\n      case kUnsignedGreaterThan:\n        return true;\n      default:\n        return false;\n    }\n    UNREACHABLE();\n  }\n\n  Operand InputImmediate(size_t index) {\n    Constant constant = ToConstant(instr_->InputAt(index));\n    switch (constant.type()) {\n      case Constant::kInt32:\n        return Operand(constant.ToInt32());\n      case Constant::kFloat32:\n        return Operand::EmbeddedNumber(constant.ToFloat32());\n      case Constant::kFloat64:\n        return Operand::EmbeddedNumber(constant.ToFloat64().value());\n      case Constant::kInt64:\n        return Operand(constant.ToInt64());\n      case Constant::kExternalReference:\n        return Operand(constant.ToExternalReference());\n      case Constant::kCompressedHeapObject:\n      case Constant::kHeapObject:\n      case Constant::kRpoNumber:\n        break;\n    }\n    UNREACHABLE();\n  }\n\n  MemOperand MemoryOperand(AddressingMode* mode, size_t* first_index) {\n    const size_t index = *first_index;\n    if (mode) *mode = AddressingModeField::decode(instr_->opcode());\n    switch (AddressingModeField::decode(instr_->opcode())) {\n      case kMode_None:\n        break;\n      case kMode_MR:\n        *first_index += 1;\n        return MemOperand(InputRegister(index + 0), 0);\n      case kMode_MRI:\n        *first_index += 2;\n        return MemOperand(InputRegister(index + 0), InputInt32(index + 1));\n      case kMode_MRR:\n        *first_index += 2;\n        return MemOperand(InputRegister(index + 0), InputRegister(index + 1));\n      case kMode_MRRI:\n        *first_index += 3;\n        return MemOperand(InputRegister(index + 0), InputRegister(index + 1),\n                          InputInt32(index + 2));\n      case kMode_Root:\n        *first_index += 1;\n        return MemOperand(kRootRegister, InputInt32(index));\n    }\n    UNREACHABLE();\n  }\n\n  MemOperand MemoryOperand(AddressingMode* mode = nullptr,\n                           size_t first_index = 0) {\n    return MemoryOperand(mode, &first_index);\n  }\n\n  MemOperand ToMemOperand(InstructionOperand* op) const {\n    DCHECK_NOT_NULL(op);\n    DCHECK(op->IsStackSlot() || op->IsFPStackSlot());\n    return SlotToMemOperand(AllocatedOperand::cast(op)->index());\n  }\n\n  MemOperand SlotToMemOperand(int slot) const {\n    FrameOffset offset = frame_access_state()->GetFrameOffset(slot);\n    return MemOperand(offset.from_stack_pointer() ? sp : fp, offset.offset());\n  }\n\n  MemOperand InputStackSlot(size_t index) {\n    InstructionOperand* op = instr_->InputAt(index);\n    return SlotToMemOperand(AllocatedOperand::cast(op)->index());\n  }\n\n  MemOperand InputStackSlot32(size_t index) {\n#if V8_TARGET_ARCH_S390X && !V8_TARGET_LITTLE_ENDIAN\n    // We want to read the 32-bits directly from memory\n    MemOperand mem = InputStackSlot(index);\n    return MemOperand(mem.rx(), mem.rb(), mem.offset() + 4);\n#else\n    return InputStackSlot(index);\n#endif\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasRegisterOutput\",\n                \"about\": \"Checks if an instruction has a register output at a given index.\",\n                \"logic\": \"Returns true if the instruction's output count is greater than 0 and the output operand at the specified index is a register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the output operand to check. Defaults to 0.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instruction has a register output at the given index, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Instruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstatic inline bool HasRegisterOutput(Instruction* instr, int index = 0) {\n  return instr->OutputCount() > 0 && instr->OutputAt(index)->IsRegister();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasFPRegisterInput\",\n                \"about\": \"Checks if an instruction has a floating-point register input at a given index.\",\n                \"logic\": \"Returns true if the input operand at the specified index is a floating-point register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the input operand to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instruction has a floating-point register input at the given index, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Instruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstatic inline bool HasFPRegisterInput(Instruction* instr, int index) {\n  return instr->InputAt(index)->IsFPRegister();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasRegisterInput\",\n                \"about\": \"Checks if an instruction has a register input (general purpose or floating point) at a given index.\",\n                \"logic\": \"Returns true if the input operand at the specified index is a register (general purpose or floating point).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the input operand to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instruction has a register input at the given index, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Instruction\",\n                    \"HasFPRegisterInput\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstatic inline bool HasRegisterInput(Instruction* instr, int index) {\n  return instr->InputAt(index)->IsRegister() ||\n         HasFPRegisterInput(instr, index);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasImmediateInput\",\n                \"about\": \"Checks if an instruction has an immediate input at a given index.\",\n                \"logic\": \"Returns true if the input operand at the specified index is an immediate value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the input operand to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instruction has an immediate input at the given index, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Instruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstatic inline bool HasImmediateInput(Instruction* instr, size_t index) {\n  return instr->InputAt(index)->IsImmediate();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasFPStackSlotInput\",\n                \"about\": \"Checks if an instruction has a floating-point stack slot input at a given index.\",\n                \"logic\": \"Returns true if the input operand at the specified index is a floating-point stack slot.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the input operand to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instruction has a floating-point stack slot input at the given index, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Instruction\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstatic inline bool HasFPStackSlotInput(Instruction* instr, size_t index) {\n  return instr->InputAt(index)->IsFPStackSlot();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"HasStackSlotInput\",\n                \"about\": \"Checks if an instruction has a stack slot input (general purpose or floating point) at a given index.\",\n                \"logic\": \"Returns true if the input operand at the specified index is a stack slot (general purpose or floating point).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"instr\",\n                        \"type\": \"Instruction*\",\n                        \"purpose\": \"The instruction to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the input operand to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the instruction has a stack slot input at the given index, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Instruction\",\n                    \"HasFPStackSlotInput\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstatic inline bool HasStackSlotInput(Instruction* instr, size_t index) {\n  return instr->InputAt(index)->IsStackSlot() ||\n         HasFPStackSlotInput(instr, index);\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"OutOfLineRecordWrite\",\n                \"extends\": \"OutOfLineCode\",\n                \"about\": \"Generates out-of-line code for record write operations, including write barriers.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"CodeGenerator\",\n                    \"Register\",\n                    \"MemOperand\",\n                    \"RecordWriteMode\",\n                    \"UnwindingInfoWriter\",\n                    \"Zone\",\n                    \"MemoryChunk\",\n                    \"SaveFPRegsMode\",\n                    \"StubCallMode\",\n                    \"COMPRESS_POINTERS_BOOL\",\n                    \"CallEphemeronKeyBarrier\",\n                    \"CallRecordWriteStubSaveRegisters\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass OutOfLineRecordWrite final : public OutOfLineCode {\n public:\n  OutOfLineRecordWrite(CodeGenerator* gen, Register object, MemOperand operand,\n                       Register value, Register scratch0, Register scratch1,\n                       RecordWriteMode mode, StubCallMode stub_mode,\n                       UnwindingInfoWriter* unwinding_info_writer)\n      : OutOfLineCode(gen),\n        object_(object),\n        operand_(operand),\n        value_(value),\n        scratch0_(scratch0),\n        scratch1_(scratch1),\n        mode_(mode),\n#if V8_ENABLE_WEBASSEMBLY\n        stub_mode_(stub_mode),\n#endif  // V8_ENABLE_WEBASSEMBLY\n        must_save_lr_(!gen->frame_access_state()->has_frame()),\n        unwinding_info_writer_(unwinding_info_writer),\n        zone_(gen->zone()) {\n    DCHECK(!AreAliased(object, scratch0, scratch1));\n    DCHECK(!AreAliased(value, scratch0, scratch1));\n  }\n\n  void Generate() final {\n    if (COMPRESS_POINTERS_BOOL) {\n      __ DecompressTagged(value_, value_);\n    }\n    __ CheckPageFlag(value_, scratch0_,\n                     MemoryChunk::kPointersToHereAreInterestingMask, eq,\n                     exit());\n    __ lay(scratch1_, operand_);\n    SaveFPRegsMode const save_fp_mode = frame()->DidAllocateDoubleRegisters()\n                                            ? SaveFPRegsMode::kSave\n                                            : SaveFPRegsMode::kIgnore;\n    if (must_save_lr_) {\n      // We need to save and restore r14 if the frame was elided.\n      __ Push(r14);\n      unwinding_info_writer_->MarkLinkRegisterOnTopOfStack(__ pc_offset());\n    }\n    if (mode_ == RecordWriteMode::kValueIsEphemeronKey) {\n      __ CallEphemeronKeyBarrier(object_, scratch1_, save_fp_mode);\n#if V8_ENABLE_WEBASSEMBLY\n    } else if (stub_mode_ == StubCallMode::kCallWasmRuntimeStub) {\n      __ CallRecordWriteStubSaveRegisters(object_, scratch1_, save_fp_mode,\n                                          StubCallMode::kCallWasmRuntimeStub);\n#endif  // V8_ENABLE_WEBASSEMBLY\n    } else {\n      __ CallRecordWriteStubSaveRegisters(object_, scratch1_, save_fp_mode);\n    }\n    if (must_save_lr_) {\n      // We need to save and restore r14 if the frame was elided.\n      __ Pop(r14);\n      unwinding_info_writer_->MarkPopLinkRegisterFromTopOfStack(__ pc_offset());\n    }\n  }\n\n private:\n  Register const object_;\n  MemOperand const operand_;\n  Register const value_;\n  Register const scratch0_;\n  Register const scratch1_;\n  RecordWriteMode const mode_;\n#if V8_ENABLE_WEBASSEMBLY\n  StubCallMode stub_mode_;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  bool must_save_lr_;\n  UnwindingInfoWriter* const unwinding_info_writer_;\n  Zone* zone_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"FlagsConditionToCondition\",\n                \"about\": \"Converts a FlagsCondition to a Condition code for branching instructions.\",\n                \"logic\": \"Maps FlagsCondition enum values (e.g., kEqual, kLessThan) to Condition enum values (e.g., eq, lt) used by the S390 assembler. Handles special cases for unsigned comparisons and overflow checks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"condition\",\n                        \"type\": \"FlagsCondition\",\n                        \"purpose\": \"The condition to convert.\"\n                    },\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"ArchOpcode\",\n                        \"purpose\": \"The opcode of the instruction that set the flags (used for special cases).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Condition\",\n                    \"description\": \"The equivalent Condition code.\"\n                },\n                \"dependencies\": [\n                    \"FlagsCondition\",\n                    \"ArchOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nCondition FlagsConditionToCondition(FlagsCondition condition, ArchOpcode op) {\n  switch (condition) {\n    case kEqual:\n      return eq;\n    case kNotEqual:\n      return ne;\n    case kUnsignedLessThan:\n      // unsigned number never less than 0\n      if (op == kS390_LoadAndTestWord32 || op == kS390_LoadAndTestWord64)\n        return CC_NOP;\n      [[fallthrough]];\n    case kSignedLessThan:\n      return lt;\n    case kUnsignedGreaterThanOrEqual:\n      // unsigned number always greater than or equal 0\n      if (op == kS390_LoadAndTestWord32 || op == kS390_LoadAndTestWord64)\n        return CC_ALWAYS;\n      [[fallthrough]];\n    case kSignedGreaterThanOrEqual:\n      return ge;\n    case kUnsignedLessThanOrEqual:\n      // unsigned number never less than 0\n      if (op == kS390_LoadAndTestWord32 || op == kS390_LoadAndTestWord64)\n        return CC_EQ;\n      [[fallthrough]];\n    case kSignedLessThanOrEqual:\n      return le;\n    case kUnsignedGreaterThan:\n      // unsigned number always greater than or equal 0\n      if (op == kS390_LoadAndTestWord32 || op == kS390_LoadAndTestWord64)\n        return ne;\n      [[fallthrough]];\n    case kSignedGreaterThan:\n      return gt;\n    case kOverflow:\n      // Overflow checked for AddS64/SubS64 only.\n      switch (op) {\n        case kS390_Add32:\n        case kS390_Add64:\n        case kS390_Sub32:\n        case kS390_Sub64:\n        case kS390_Abs64:\n        case kS390_Abs32:\n        case kS390_Mul32:\n        case kS390_Mul64WithOverflow:\n          return overflow;\n        default:\n          break;\n      }\n      break;\n    case kNotOverflow:\n      switch (op) {\n        case kS390_Add32:\n        case kS390_Add64:\n        case kS390_Sub32:\n        case kS390_Sub64:\n        case kS390_Abs64:\n        case kS390_Abs32:\n        case kS390_Mul32:\n        case kS390_Mul64WithOverflow:\n          return nooverflow;\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GET_MEMOPERAND32\",\n                \"about\": \"Macro to retrieve a 32-bit memory operand.  Handles addressing modes and stack slots.\",\n                \"logic\": \"A lambda expression which resolves memory operands, dealing with different addressing modes and stack slots. It takes the return variable 'ret' and the first index 'fi' as input. If addressing mode is not kMode_None, it utilizes `i.MemoryOperand` to decode the memory operand, incrementing `first_index` appropriately. Otherwise, it assumes the operand is a stack slot and uses `i.InputStackSlot32` to retrieve it.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"The retrieved memory operand.\"\n                },\n                \"dependencies\": [\n                    \"AddressingMode\",\n                    \"MemOperand\",\n                    \"AddressingModeField\",\n                    \"S390OperandConverter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define GET_MEMOPERAND32(ret, fi)                                       \\\n  ([&](int& ret) {                                                      \\\n    AddressingMode mode = AddressingModeField::decode(instr->opcode()); \\\n    MemOperand mem(r0);                                                 \\\n    if (mode != kMode_None) {                                           \\\n      size_t first_index = (fi);                                        \\\n      mem = i.MemoryOperand(&mode, &first_index);                       \\\n      ret = first_index;                                                \\\n    } else {                                                            \\\n      mem = i.InputStackSlot32(fi);                                     \\\n    }                                                                   \\\n    return mem;                                                         \\\n  })(ret)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GET_MEMOPERAND\",\n                \"about\": \"Macro to retrieve a memory operand.  Handles addressing modes and stack slots.\",\n                \"logic\": \"A lambda expression which resolves memory operands, dealing with different addressing modes and stack slots. It takes the return variable 'ret' and the first index 'fi' as input. If addressing mode is not kMode_None, it utilizes `i.MemoryOperand` to decode the memory operand, incrementing `first_index` appropriately. Otherwise, it assumes the operand is a stack slot and uses `i.InputStackSlot` to retrieve it.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"The retrieved memory operand.\"\n                },\n                \"dependencies\": [\n                    \"AddressingMode\",\n                    \"MemOperand\",\n                    \"AddressingModeField\",\n                    \"S390OperandConverter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define GET_MEMOPERAND(ret, fi)                                         \\\n  ([&](int& ret) {                                                      \\\n    AddressingMode mode = AddressingModeField::decode(instr->opcode()); \\\n    MemOperand mem(r0);                                                 \\\n    if (mode != kMode_None) {                                           \\\n      size_t first_index = (fi);                                        \\\n      mem = i.MemoryOperand(&mode, &first_index);                       \\\n      ret = first_index;                                                \\\n    } else {                                                            \\\n      mem = i.InputStackSlot(fi);                                       \\\n    }                                                                   \\\n    return mem;                                                         \\\n  })(ret)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RRInstr\",\n                \"about\": \"Macro to generate code for a register-register instruction (RR format).\",\n                \"logic\": \"A lambda expression that generates code for RR format instructions. It asserts that the output register is the same as the first input register, then emits the instruction using the output register and the second input register. It returns 2, indicating that the instruction consumes two inputs.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Number of operands consumed.\"\n                },\n                \"dependencies\": [\n                    \"MacroAssembler\",\n                    \"S390OperandConverter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define RRInstr(instr)                                \\\n  [&]() {                                             \\\n    DCHECK(i.OutputRegister() == i.InputRegister(0)); \\\n    __ instr(i.OutputRegister(), i.InputRegister(1)); \\\n    return 2;                                         \\\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RIInstr\",\n                \"about\": \"Macro to generate code for a register-immediate instruction (RI format).\",\n                \"logic\": \"A lambda expression that generates code for RI format instructions. It asserts that the output register is the same as the first input register, then emits the instruction using the output register and the immediate value from the second input.  It returns 2, indicating that the instruction consumes two inputs.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Number of operands consumed.\"\n                },\n                \"dependencies\": [\n                    \"MacroAssembler\",\n                    \"S390OperandConverter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define RIInstr(instr)                                 \\\n  [&]() {                                              \\\n    DCHECK(i.OutputRegister() == i.InputRegister(0));  \\\n    __ instr(i.OutputRegister(), i.InputImmediate(1)); \\\n    return 2;                                          \\\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RMInstr\",\n                \"about\": \"Macro to generate code for a register-memory instruction (RM format).\",\n                \"logic\": \"A lambda expression that generates code for RM format instructions. It asserts that the output register is the same as the first input register.  It uses GETMEM to get the memory operand, then emits the instruction. It returns the number of inputs consumed, which is determined by GETMEM.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Number of operands consumed.\"\n                },\n                \"dependencies\": [\n                    \"MacroAssembler\",\n                    \"S390OperandConverter\",\n                    \"GET_MEMOPERAND32\",\n                    \"GET_MEMOPERAND\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define RMInstr(instr, GETMEM)                        \\\n  [&]() {                                             \\\n    DCHECK(i.OutputRegister() == i.InputRegister(0)); \\\n    int ret = 2;                                      \\\n    __ instr(i.OutputRegister(), GETMEM(ret, 1));     \\\n    return ret;                                       \\\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RM32Instr\",\n                \"about\": \"Helper macro that uses `RMInstr` with `GET_MEMOPERAND32`\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Number of operands consumed\"\n                },\n                \"dependencies\": [\n                    \"RMInstr\",\n                    \"GET_MEMOPERAND32\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define RM32Instr(instr) RMInstr(instr, GET_MEMOPERAND32)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RM64Instr\",\n                \"about\": \"Helper macro that uses `RMInstr` with `GET_MEMOPERAND`\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Number of operands consumed\"\n                },\n                \"dependencies\": [\n                    \"RMInstr\",\n                    \"GET_MEMOPERAND\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define RM64Instr(instr) RMInstr(instr, GET_MEMOPERAND)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RRRInstr\",\n                \"about\": \"Macro to generate code for a register-register-register instruction.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Number of operands consumed.\"\n                },\n                \"dependencies\": [\n                    \"MacroAssembler\",\n                    \"S390OperandConverter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define RRRInstr(instr)                                                   \\\n  [&]() {                                                                 \\\n    __ instr(i.OutputRegister(), i.InputRegister(0), i.InputRegister(1)); \\\n    return 2;                                                             \\\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RRIInstr\",\n                \"about\": \"Macro to generate code for a register-register-immediate instruction.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Number of operands consumed.\"\n                },\n                \"dependencies\": [\n                    \"MacroAssembler\",\n                    \"S390OperandConverter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define RRIInstr(instr)                                                    \\\n  [&]() {                                                                  \\\n    __ instr(i.OutputRegister(), i.InputRegister(0), i.InputImmediate(1)); \\\n    return 2;                                                              \\\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RRMInstr\",\n                \"about\": \"Macro to generate code for a register-register-memory instruction.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Number of operands consumed.\"\n                },\n                \"dependencies\": [\n                    \"MacroAssembler\",\n                    \"S390OperandConverter\",\n                    \"GET_MEMOPERAND32\",\n                    \"GET_MEMOPERAND\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define RRMInstr(instr, GETMEM)                                       \\\n  [&]() {                                                             \\\n    int ret = 2;                                                      \\\n    __ instr(i.OutputRegister(), i.InputRegister(0), GETMEM(ret, 1)); \\\n    return ret;                                                       \\\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RRM32Instr\",\n                \"about\": \"Helper macro that uses `RRMInstr` with `GET_MEMOPERAND32`\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Number of operands consumed\"\n                },\n                \"dependencies\": [\n                    \"RRMInstr\",\n                    \"GET_MEMOPERAND32\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#define RRM32Instr(instr) RRMInstr(instr, GET_MEMOPERAND32)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\","
}