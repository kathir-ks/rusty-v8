{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/ast/ast-function-literal-id-reindexer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 42, column 57",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/ast/ast-function-literal-id-reindexer.h\",\n            \"file_name\": \"ast-function-literal-id-reindexer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the AstFunctionLiteralIdReindexer class, which reindexes the IDs of FunctionLiterals in an expression tree by a given delta.  Used for managing function literal IDs during compilation.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for AST traversal and standard library components.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/ast/ast-traversal-visitor.h\"\n\n#ifdef DEBUG\n#include <set>\n#endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AstFunctionLiteralIdReindexer\",\n                \"extends\": \"AstTraversalVisitor<AstFunctionLiteralIdReindexer>\",\n                \"about\": \"Reindexes the IDs of FunctionLiterals in a given expression by adding a delta.  This is a visitor class used to traverse the AST.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"delta_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The amount to add to each FunctionLiteral ID.\"\n                    },\n                    {\n                        \"name\": \"visited_\",\n                        \"type\": \"std::set<FunctionLiteral*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of visited FunctionLiterals during traversal in debug mode to prevent infinite loops.  Only active in DEBUG builds.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AstTraversalVisitor\",\n                    \"FunctionLiteral\",\n                    \"ClassLiteral\",\n                    \"Call\",\n                    \"Expression\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass AstFunctionLiteralIdReindexer final\n    : public AstTraversalVisitor<AstFunctionLiteralIdReindexer> {\n public:\n  AstFunctionLiteralIdReindexer(size_t stack_limit, int delta);\n  AstFunctionLiteralIdReindexer(const AstFunctionLiteralIdReindexer&) = delete;\n  AstFunctionLiteralIdReindexer& operator=(\n      const AstFunctionLiteralIdReindexer&) = delete;\n  ~AstFunctionLiteralIdReindexer();\n\n  void Reindex(Expression* pattern);\n\n  // AstTraversalVisitor implementation.\n  void VisitFunctionLiteral(FunctionLiteral* lit);\n  void VisitClassLiteral(ClassLiteral* lit);\n  void VisitCall(Call* lit);\n\n private:\n  int delta_;\n\n#ifdef DEBUG\n  // Visited set, only used in DCHECKs for verification.\n  std::set<FunctionLiteral*> visited_;\n\n  // Visit all function literals, checking if they have already been visited\n  // (are in the visited set).\n  void CheckVisited(Expression* expr);\n#else\n  void CheckVisited(Expression* expr) {}\n#endif\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"AstTraversalVisitor\",\n                    \"about\": \"Base class for AST visitors. Provides the basic traversal mechanism.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class AstTraversalVisitor {\n                 public:\n                  virtual void VisitFunctionLiteral(FunctionLiteral* node) = 0;\n                  // Other visit methods...\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"FunctionLiteral\",\n                    \"about\": \"Represents a function literal in the AST.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class FunctionLiteral : public Expression {\n                 public:\n                  int id() const;\n                  void set_id(int id);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ClassLiteral\",\n                    \"about\": \"Represents a class literal in the AST.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ClassLiteral : public Expression {\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Call\",\n                    \"about\": \"Represents a call expression in the AST.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Call : public Expression {\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Expression\",\n                    \"about\": \"Base class for all expression nodes in the AST.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Expression {\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}