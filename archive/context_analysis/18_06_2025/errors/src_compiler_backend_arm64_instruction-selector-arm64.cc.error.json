{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm64/instruction-selector-arm64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm64/instruction-selector-arm64.cc\",\n        \"file_name\": \"instruction-selector-arm64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"This file implements the Arm64-specific instruction selector.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard C++ includes and V8 specific headers\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/bits.h\"\n#include \"src/base/logging.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/backend/instruction-codes.h\"\n#include \"src/compiler/backend/instruction-selector-impl.h\"\n#include \"src/compiler/backend/instruction-selector.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/turboshaft/operation-matcher.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/flags/flags.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Arm64OperandGeneratorT\",\n            \"extends\": \"OperandGeneratorT\",\n            \"about\": \"Adds Arm64-specific methods for generating operands.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"ConstantOp\",\n                \"RootsTable\",\n                \"Assembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass Arm64OperandGeneratorT final : public OperandGeneratorT {\n public:\n  explicit Arm64OperandGeneratorT(InstructionSelectorT* selector)\n      : OperandGeneratorT(selector) {}\n\n  InstructionOperand UseOperand(OpIndex node, ImmediateMode mode) {\n    if (CanBeImmediate(node, mode)) {\n      return UseImmediate(node);\n    }\n    return UseRegister(node);\n  }\n\n  bool IsImmediateZero(OpIndex node) {\n    if (const ConstantOp* constant =\n            selector()->Get(node).TryCast<ConstantOp>()) {\n      if (constant->IsIntegral() && constant->integral() == 0) return true;\n      if (constant->kind == ConstantOp::Kind::kFloat32) {\n        return constant->float32().get_bits() == 0;\n      }\n      if (constant->kind == ConstantOp::Kind::kFloat64) {\n        return constant->float64().get_bits() == 0;\n      }\n    }\n    return false;\n  }\n\n  // Use the zero register if the node has the immediate value zero, otherwise\n  // assign a register.\n  InstructionOperand UseRegisterOrImmediateZero(OpIndex node) {\n    if (IsImmediateZero(node)) {\n      return UseImmediate(node);\n    }\n    return UseRegister(node);\n  }\n\n  // Use the zero register if the node has the immediate value zero, otherwise\n  // assign a register, keeping it alive for the whole sequence of continuation\n  // instructions.\n  InstructionOperand UseRegisterAtEndOrImmediateZero(OpIndex node) {\n    if (IsImmediateZero(node)) {\n      return UseImmediate(node);\n    }\n    return this->UseRegisterAtEnd(node);\n  }\n\n  // Use the provided node if it has the required value, or create a\n  // TempImmediate otherwise.\n  InstructionOperand UseImmediateOrTemp(OpIndex node, int32_t value) {\n    if (selector()->Get(node).Cast<ConstantOp>().signed_integral() == value) {\n      return UseImmediate(node);\n    }\n    return TempImmediate(value);\n  }\n\n  bool IsIntegerConstant(OpIndex node) const {\n    int64_t unused;\n    return selector()->MatchSignedIntegralConstant(node, &unused);\n  }\n\n  std::optional<int64_t> GetOptionalIntegerConstant(OpIndex operation) {\n    if (int64_t constant; MatchSignedIntegralConstant(operation, &constant)) {\n      return constant;\n    }\n    return std::nullopt;\n  }\n\n  bool CanBeImmediate(OpIndex node, ImmediateMode mode) {\n    const ConstantOp* constant = selector()->Get(node).TryCast<ConstantOp>();\n    if (!constant) return false;\n    if (constant->kind == ConstantOp::Kind::kCompressedHeapObject) {\n      if (!COMPRESS_POINTERS_BOOL) return false;\n      // For builtin code we need static roots\n      if (selector()->isolate()->bootstrapper() && !V8_STATIC_ROOTS_BOOL) {\n        return false;\n      }\n      const RootsTable& roots_table = selector()->isolate()->roots_table();\n      RootIndex root_index;\n      Handle<HeapObject> value = constant->handle();\n      if (roots_table.IsRootHandle(value, &root_index)) {\n        if (!RootsTable::IsReadOnly(root_index)) return false;\n        return CanBeImmediate(MacroAssemblerBase::ReadOnlyRootPtr(\n                                  root_index, selector()->isolate()),\n                              mode);\n      }\n      return false;\n    }\n\n    int64_t value;\n    return selector()->MatchSignedIntegralConstant(node, &value) &&\n           CanBeImmediate(value, mode);\n  }\n\n  bool CanBeImmediate(int64_t value, ImmediateMode mode) {\n    unsigned ignored;\n    switch (mode) {\n      case kLogical32Imm:\n        // TODO(dcarney): some unencodable values can be handled by\n        // switching instructions.\n        return internal::Assembler::IsImmLogical(\n            static_cast<uint32_t>(value), 32, &ignored, &ignored, &ignored);\n      case kLogical64Imm:\n        return internal::Assembler::IsImmLogical(\n            static_cast<uint64_t>(value), 64, &ignored, &ignored, &ignored);\n      case kArithmeticImm:\n        return internal::Assembler::IsImmAddSub(value);\n      case kLoadStoreImm8:\n        return IsLoadStoreImmediate(value, 0);\n      case kLoadStoreImm16:\n        return IsLoadStoreImmediate(value, 1);\n      case kLoadStoreImm32:\n        return IsLoadStoreImmediate(value, 2);\n      case kLoadStoreImm64:\n        return IsLoadStoreImmediate(value, 3);\n      case kNoImmediate:\n        return false;\n      case kConditionalCompareImm:\n        return internal::Assembler::IsImmConditionalCompare(value);\n      case kShift32Imm:  // Fall through.\n      case kShift64Imm:\n        // Shift operations only observe the bottom 5 or 6 bits of the value.\n        // All possible shifts can be encoded by discarding bits which have no\n        // effect.\n        return true;\n    }\n    return false;\n  }\n\n  bool CanBeLoadStoreShiftImmediate(OpIndex node, MachineRepresentation rep) {\n    if (uint64_t constant;\n        selector()->MatchUnsignedIntegralConstant(node, &constant) &&\n        constant == static_cast<uint64_t>(ElementSizeLog2Of(rep))) {\n      return true;\n    }\n    return false;\n  }\n\n private:\n  bool IsLoadStoreImmediate(int64_t value, unsigned size) {\n    return internal::Assembler::IsImmLSScaled(value, size) ||\n           internal::Assembler::IsImmLSUnscaled(value);\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRR\",\n            \"about\": \"Emits a RR instruction.\",\n            \"logic\": \"Emits the instruction with the given opcode, defining the node as a register and using the input as a register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to define as a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Arm64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ArchOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRR(InstructionSelectorT* selector, ArchOpcode opcode, OpIndex node) {\n  Arm64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRR\",\n            \"about\": \"Emits a RRR instruction.\",\n            \"logic\": \"Emits the instruction with the given opcode, defining the node as a register and using the two inputs as registers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to define as a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Arm64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"InstructionCode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRRR(InstructionSelectorT* selector, InstructionCode opcode,\n              OpIndex node) {\n  Arm64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)),\n                 g.UseRegister(selector->input_at(node, 1)));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRR\",\n            \"about\": \"Emits a RR instruction for WebAssembly.\",\n            \"logic\": \"Emits the instruction with the given opcode, defining the node as a register and using the input as a register. (WebAssembly version)\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to define as a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Arm64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"InstructionCode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\nvoid VisitRR(InstructionSelectorT* selector, InstructionCode opcode,\n             OpIndex node) {\n  Arm64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitSimdShiftRRR\",\n            \"about\": \"Emits a SIMD shift RRR instruction for WebAssembly.\",\n            \"logic\": \"Emits the instruction with the given opcode, defining the node as a register and using the two inputs and shift as registers or immediates.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to define as a register.\"\n                },\n                {\n                    \"name\": \"width\",\n                    \"type\": \"int\",\n                    \"purpose\": \"shift bit width\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Arm64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ArchOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitSimdShiftRRR(InstructionSelectorT* selector, ArchOpcode opcode,\n                       OpIndex node, int width) {\n  Arm64OperandGeneratorT g(selector);\n  int64_t constant;\n  if (selector->MatchSignedIntegralConstant(selector->input_at(node, 1),\n                                            &constant)) {\n    if (constant % width == 0) {\n      selector->EmitIdentity(node);\n    } else {\n      selector->Emit(opcode, g.DefineAsRegister(node),\n                     g.UseRegister(selector->input_at(node, 0)),\n                     g.UseImmediate(selector->input_at(node, 1)));\n    }\n  } else {\n    selector->Emit(opcode, g.DefineAsRegister(node),\n                   g.UseRegister(selector->input_at(node, 0)),\n                   g.UseRegister(selector->input_at(node, 1)));\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRI\",\n            \"about\": \"Emits a RRI instruction for WebAssembly.\",\n            \"logic\": \"Emits the instruction with the given opcode, defining the node as a register and using the input register and immediate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to define as a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Arm64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"InstructionCode\",\n                \"Simd128ExtractLaneOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRRI(InstructionSelectorT* selector, InstructionCode opcode,\n              OpIndex node) {\n  Arm64OperandGeneratorT g(selector);\n  const Operation& op = selector->Get(node);\n  int imm = op.template Cast<Simd128ExtractLaneOp>().lane;\n  selector->Emit(opcode, g.DefineAsRegister(node), g.UseRegister(op.input(0)),\n                 g.UseImmediate(imm));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRIR\",\n            \"about\": \"Emits a RRIR instruction for WebAssembly.\",\n            \"logic\": \"Emits the instruction with the given opcode, defining the node as a register and using the input register, immediate, and second input register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to define as a register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Arm64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"InstructionCode\",\n                \"Simd128ReplaceLaneOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRRIR(InstructionSelectorT* selector, InstructionCode opcode,\n               OpIndex node) {\n  const Simd128ReplaceLaneOp& op =\n      selector->Get(node).template Cast<Simd128ReplaceLaneOp>();\n  Arm64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node), g.UseRegister(op.input(0)),\n                 g.UseImmediate(op.lane), g.UseUniqueRegister(op.input(1)));\n}\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRO\",\n            \"about\": \"Emits a RRO instruction.\",\n            \"logic\": \"Emits the instruction with the given opcode, defining the node as a register and using the input register and operand.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode of the instruction.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to define as a register.\"\n                },\n                {\n                    \"name\": \"operand_mode\",\n                    \"type\": \"ImmediateMode\",\n                    \"purpose\": \"The immediate mode of the operand.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Arm64OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ArchOpcode\",\n                \"ImmediateMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRRO(InstructionSelectorT* selector, ArchOpcode opcode, OpIndex node,\n              ImmediateMode operand_mode) {\n  Arm64OperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)),\n                 g.UseOperand(selector->input_at(node, 1), operand_mode));\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ExtendingLoadMatcher\",\n            \"about\": \"Matches extending load patterns.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"ShiftOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct ExtendingLoadMatcher {\n  ExtendingLoadMatcher(OpIndex node, InstructionSelectorT* selector)\n      : matches_(false), selector_(selector), immediate_(0) {\n    Initialize(node);\n  }\n\n  bool Matches() const { return matches_; }\n\n  OpIndex base() const {\n    DCHECK(Matches());\n    return base_;\n  }\n  int64_t immediate() const {\n    DCHECK(Matches());\n    return immediate_;\n  }\n  ArchOpcode opcode() const {\n    DCHECK(Matches());\n    return opcode_;\n  }\n\n private:\n  bool matches_;\n  InstructionSelectorT* selector_;\n  OpIndex base_{};\n  int64_t immediate_;\n  ArchOpcode opcode_;\n\n  void Initialize(OpIndex node) {\n    const ShiftOp& shift = selector_->Get(node).template Cast<ShiftOp>();\n    DCHECK(shift.kind == ShiftOp::Kind::kShiftRightArithmetic ||\n           shift.kind == ShiftOp::Kind::kShiftRightArithmeticShiftOutZeros);\n    // When loading a 64-bit value and shifting by 32, we should\n    // just load and sign-extend the interesting 4 bytes instead.\n    // This happens, for example, when we're loading and untagging SMIs.\n    const Operation& lhs = selector_->Get(shift.left());\n    int64_t constant_rhs;\n\n    if (lhs.Is<LoadOp>() &&\n        selector_->MatchIntegralWord64Constant(shift.right(), &constant_rhs) &&\n        constant_rhs == 32 && selector_->CanCover(node, shift.left())) {\n      Arm64OperandGeneratorT g(selector_);\n      const LoadOp& load = lhs.Cast<LoadOp>();\n      base_ = load.base();\n      opcode_ = kArm64Ldrsw;\n      if (load.index().has_value()) {\n        int64_t index_constant;\n        if (selector_->MatchIntegralWord64Constant(load.index().value(),\n                                                   &index_constant)) {\n          DCHECK_EQ(load.element_size_log2, 0);\n          immediate_ = index_constant + 4;\n          matches_ = g.CanBeImmediate(immediate_, kLoadStoreImm32);\n        }\n      } else {\n        immediate_ = load.offset + 4;\n        matches_ = g.CanBeImmediate(immediate_, kLoadStoreImm32);\n      }\n    }\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchExtendingLoad\",\n            \"about\": \"Tries to match an extending load pattern.\",\n            \"logic\": \"Creates an ExtendingLoadMatcher and returns whether it matches.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to match.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Whether the extending load pattern matches.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ExtendingLoadMatcher\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TryMatchExtendingLoad(InstructionSelectorT* selector, OpIndex node) {\n  ExtendingLoadMatcher m(node, selector);\n  return m.Matches();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryEmitExtendingLoad\",\n            \"about\": \"Tries to emit an extending load instruction.\",\n            \"logic\": \"Creates an ExtendingLoadMatcher and emits the instruction if it matches.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to emit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Whether the extending load instruction was emitted.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ExtendingLoadMatcher\",\n                \"Arm64OperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TryEmitExtendingLoad(InstructionSelectorT* selector, OpIndex node) {\n  ExtendingLoadMatcher m(node, selector);\n  Arm64OperandGeneratorT g(selector);\n  if (m.Matches()) {\n    InstructionOperand inputs[2];\n    inputs[0] = g.UseRegister(m.base());\n    InstructionCode opcode =\n        m.opcode() | AddressingModeField::encode(kMode_MRI);\n    DCHECK(is_int32(m.immediate()));\n    inputs[1] = g.TempImmediate(static_cast<int32_t>(m.immediate()));\n    InstructionOperand outputs[] = {g.DefineAsRegister(node)};\n    selector->Emit(opcode, arraysize(outputs), outputs, arraysize(inputs),\n                   inputs);\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchAnyShift\",\n            \"about\": \"Tries to match any shift operation.\",\n            \"logic\": \"Checks if the given node is a shift operation and sets the opcode accordingly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to match.\"\n                },\n                {\n                    \"name\": \"input_node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The input node.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"The instruction code.\"\n                },\n                {\n                    \"name\": \"try_ror\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether to try matching rotate right.\"\n                },\n                {\n                    \"name\": \"rep\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The register representation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Whether the shift operation was matched.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"InstructionCode\",\n                \"RegisterRepresentation\",\n                \"Arm64OperandGeneratorT\",\n                \"TryMatchExtendingLoad\",\n                \"ShiftOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TryMatchAnyShift(InstructionSelectorT* selector, OpIndex node,\n                      OpIndex input_node, InstructionCode* opcode, bool try_ror,\n                      RegisterRepresentation rep) {\n  Arm64OperandGeneratorT g(selector);\n\n  if (!selector->CanCover(node, input_node)) return false;\n  if (const ShiftOp* shift = selector->Get(input_node).TryCast<ShiftOp>()) {\n    // Differently to Turbofan, the representation should always match.\n    DCHECK_EQ(shift->rep, rep);\n    if (shift->rep != rep) return false;\n    if (!g.IsIntegerConstant(shift->right())) return false;\n\n    switch (shift->kind) {\n      case ShiftOp::Kind::kShiftLeft:\n        *opcode |= AddressingModeField::encode(kMode_Operand2_R_LSL_I);\n        return true;\n      case ShiftOp::Kind::kShiftRightLogical:\n        *opcode |= AddressingModeField::encode(kMode_Operand2_R_LSR_I);\n        return true;\n      case ShiftOp::Kind::kShiftRightArithmetic:\n      case ShiftOp::Kind::kShiftRightArithmeticShiftOutZeros:\n        if (rep == WordRepresentation::Word64() &&\n            TryMatchExtendingLoad(selector, input_node)) {\n          return false;\n        }\n        *opcode |= AddressingModeField::encode(kMode_Operand2_R_ASR_I);\n        return true;\n      case ShiftOp::Kind::kRotateRight:\n        if (try_ror) {\n          *opcode |= AddressingModeField::encode(kMode_Operand2_R_ROR_I);\n          return true;\n        }\n        return false;\n      case ShiftOp::Kind::kRotateLeft:\n        return false;\n    }\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchBitwiseAndSmallMask\",\n            \"about\": \"Tries to match a bitwise AND operation with a small mask.\",\n            \"logic\": \"Checks if the given node is a bitwise AND operation with a small constant mask (0xFF or 0xFFFF).\",\n            \"parameters\": [\n                {\n                    \"name\": \"matcher\",\n                    \"type\": \"OperationMatcher&\",\n                    \"purpose\": \"The operation matcher.\"\n                },\n                {\n                    \"name\": \"op\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to match.\"\n                },\n                {\n                    \"name\": \"left\",\n                    \"type\": \"OpIndex*\",\n                    \"purpose\": \"The left input of the AND operation.\"\n                },\n                {\n                    \"name\": \"mask\",\n                    \"type\": \"int32_t*\",\n                    \"purpose\": \"The mask value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Whether the bitwise AND with a small mask was matched.\"\n            },\n            \"dependencies\": [\n                \"OpIndex\",\n                \"ChangeOp\",\n                \"WordBinopOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TryMatchBitwiseAndSmallMask(OperationMatcher& matcher, OpIndex op,\n                                 OpIndex* left, int32_t* mask) {\n  if (const ChangeOp* change_op =\n          matcher.TryCast<Opmask::kChangeInt32ToInt64>(op)) {\n    return TryMatchBitwiseAndSmallMask(matcher, change_op->input(), left, mask);\n  }\n  if (const WordBinopOp* bitwise_and =\n          matcher.TryCast<Opmask::kWord32BitwiseAnd>(op)) {\n    if (matcher.MatchIntegralWord32Constant(bitwise_and->right(), mask) &&\n        (*mask == 0xFF || *mask == 0xFFFF)) {\n      *left = bitwise_and->left();\n      return true;\n    }\n    if (matcher.MatchIntegralWord32Constant(bitwise_and->left(), mask) &&\n        (*mask == 0xFF || *mask == 0xFFFF)) {\n      *left = bitwise_and->right();\n      return true;\n    }\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchSignExtendShift\",\n            \"about\": \"Tries to match a sign-extend shift operation.\",\n            \"logic\": \"Checks if the given node is a sign-extend shift operation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"op\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to match.\"\n                },\n                {\n                    \"name\": \"left\",\n                    \"type\": \"OpIndex*\",\n                    \"purpose\": \"The left input of the shift operation.\"\n                },\n                {\n                    \"name\": \"shift_by\",\n                    \"type\": \"int32_t*\",\n                    \"purpose\": \"The shift value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Whether the sign-extend shift operation was matched.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"ChangeOp\",\n                \"ShiftOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool TryMatchSignExtendShift(InstructionSelectorT* selector, OpIndex op,\n                             OpIndex* left, int32_t* shift_by) {\n  if (const ChangeOp* change_op =\n          selector->TryCast<Opmask::kChangeInt32ToInt64>(op)) {\n    return TryMatchSignExtendShift(selector, change_op->input(), left,\n                                   shift_by);\n  }\n\n  if (const ShiftOp* sar =\n          selector->TryCast<Opmask::kWord32ShiftRightArithmetic>(op)) {\n    const Operation& sar_lhs = selector->Get(sar->left());\n    if (sar_lhs.Is<Opmask::kWord32ShiftLeft>() &&\n        selector->CanCover(op,"
}