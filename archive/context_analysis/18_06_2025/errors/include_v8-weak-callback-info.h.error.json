{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-weak-callback-info.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 125, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-weak-callback-info.h\",\n            \"file_name\": \"v8-weak-callback-info.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the WeakCallbackInfo template class and related types for handling weak references and callbacks in V8.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Provides standard C string functions like memcpy\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cstring>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Provides conditional stack allocation functionality\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"cppgc/internal/conditional-stack-allocated.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Provides V8 configuration macros\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"v8config.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class Isolate;\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"InternalFieldOutOfBounds\",\n                \"parent\": \"api_internal\",\n                \"about\": \"A function in the api_internal namespace, likely used for error handling related to internal field access.\",\n                \"logic\": \"Presumably throws an error or triggers a debug break when an invalid internal field index is accessed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the internal field being accessed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value (likely terminates execution or throws an exception).\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace api_internal {\n            V8_EXPORT void InternalFieldOutOfBounds(int index);\n            }  // namespace api_internal\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WeakCallbackInfo\",\n                \"about\": \"Provides information about a weak callback invocation, including the isolate, parameter, and embedder fields.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The V8 isolate associated with the callback.\"\n                    },\n                    {\n                        \"name\": \"parameter_\",\n                        \"type\": \"T*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A user-provided parameter passed to the callback.\"\n                    },\n                    {\n                        \"name\": \"callback_\",\n                        \"type\": \"Callback*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the callback function to call for the second pass.\"\n                    },\n                    {\n                        \"name\": \"embedder_fields_\",\n                        \"type\": \"void* [kEmbedderFieldsInWeakCallback]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of void pointers for embedder-specific data.\"\n                    }\n                ],\n                \"extends\": \"cppgc::internal::ConditionalStackAllocatedBase<T>\",\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"cppgc::internal::ConditionalStackAllocatedBase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class WeakCallbackInfo\n                : public cppgc::internal::ConditionalStackAllocatedBase<T> {\n             public:\n              using Callback = void (*)(const WeakCallbackInfo<T>& data);\n\n              WeakCallbackInfo(Isolate* isolate, T* parameter,\n                               void* embedder_fields[kEmbedderFieldsInWeakCallback],\n                               Callback* callback)\n                  : isolate_(isolate), parameter_(parameter), callback_(callback) {\n                memcpy(embedder_fields_, embedder_fields,\n                       sizeof(embedder_fields[0]) * kEmbedderFieldsInWeakCallback);\n              }\n\n              V8_INLINE Isolate* GetIsolate() const { return isolate_; }\n              V8_INLINE T* GetParameter() const { return parameter_; }\n              V8_INLINE void* GetInternalField(int index) const;\n\n              /**\n               * When a weak callback is first invoked the embedders _must_ Reset() the\n               * handle which triggered the callback. The handle itself is unusable for\n               * anything else. No other V8 API calls may be called in the first callback.\n               * Additional work requires scheduling a second invocation via\n               * `SetSecondPassCallback()` which will be called some time after all the\n               * initial callbacks are processed.\n               *\n               * The second pass callback is prohibited from executing JavaScript. Embedders\n               * should schedule another callback in case this is required.\n               */\n              void SetSecondPassCallback(Callback callback) const { *callback_ = callback; }\n\n             private:\n              Isolate* isolate_;\n              T* parameter_;\n              Callback* callback_;\n              void* embedder_fields_[kEmbedderFieldsInWeakCallback];\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetInternalField\",\n                \"parent\": \"WeakCallbackInfo\",\n                \"about\": \"Retrieves an internal field from the embedder_fields array.\",\n                \"logic\": \"Performs a bounds check on the index before accessing the array to prevent out-of-bounds access.  Uses `api_internal::InternalFieldOutOfBounds` to handle out-of-bounds conditions.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The index of the internal field to retrieve.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void*\",\n                    \"description\": \"The value of the internal field at the specified index.\"\n                },\n                \"dependencies\": [\n                    \"api_internal::InternalFieldOutOfBounds\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            void* WeakCallbackInfo<T>::GetInternalField(int index) const {\n            #ifdef V8_ENABLE_CHECKS\n              if (index < 0 || index >= kEmbedderFieldsInWeakCallback) {\n                api_internal::InternalFieldOutOfBounds(index);\n              }\n            #endif\n              return embedder_fields_[index];\n            }\n        ]]></code>\n    </func>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"WeakCallbackType\",\n                \"about\": \"Defines the different types of weak callbacks supported.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Weakness type for weak handles.\n             */\n            enum class WeakCallbackType {\n              /**\n               * Passes a user-defined void* parameter back to the callback.\n               */\n              kParameter,\n              /**\n               * Passes the first two internal fields of the object back to the callback.\n               */\n              kInternalFields,\n            };\n        ]]></code>\n    </enum>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ConditionalStackAllocatedBase\",\n                \"about\": \"Base class for conditional stack allocation.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    namespace internal {\n                        template <typename T>\n                        class ConditionalStackAllocatedBase {};\n                    } // namespace internal\n                } // namespace cppgc\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}