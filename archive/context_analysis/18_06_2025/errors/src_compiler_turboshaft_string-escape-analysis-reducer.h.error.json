{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/string-escape-analysis-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 39, column 41",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/string-escape-analysis-reducer.h\",\n        \"file_name\": \"string-escape-analysis-reducer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines a Turboshaft reducer that performs string escape analysis to optimize string concatenations.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for escape analysis, turboshaft graph manipulation, operations, and data structures.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/escape-analysis-reducer.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/sidetable.h\"\n#include \"src/compiler/turboshaft/snapshot-table.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StringEscapeAnalyzer\",\n            \"about\": \"Analyzes the Turboshaft graph to identify string concatenations that do not escape and can be elided.\",\n            \"attributes\": [\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"const Graph&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Reference to the Turboshaft graph being analyzed.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory zone for allocating data structures.\"\n                },\n                {\n                    \"name\": \"escaping_operations_and_frame_states_to_reconstruct_\",\n                    \"type\": \"FixedOpIndexSidetable<bool>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Sidetable to track escaping operations and FrameStates that need reconstruction.\"\n                },\n                {\n                    \"name\": \"maybe_non_escaping_string_concats_\",\n                    \"type\": \"ZoneVector<V<String>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector to temporarily store potentially non-escaping string concatenations for later processing.\"\n                },\n                {\n                    \"name\": \"maybe_to_reconstruct_frame_states_\",\n                    \"type\": \"ZoneVector<V<FrameState>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector to temporarily store frame states which may need to be reconstructed\"\n                },\n                {\n                    \"name\": \"max_frame_state_input_count_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maximum number of inputs for frame states.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Graph\",\n                \"Zone\",\n                \"FixedOpIndexSidetable\",\n                \"ZoneVector\",\n                \"V<String>\",\n                \"V<FrameState>\",\n                \"Operation\",\n                \"StringConcatOp\",\n                \"FrameStateOp\",\n                \"FrameStateData\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass StringEscapeAnalyzer {\n public:\n  StringEscapeAnalyzer(const Graph& graph, Zone* phase_zone)\n      : graph_(graph),\n        zone_(phase_zone),\n        escaping_operations_and_frame_states_to_reconstruct_(\n            graph.op_id_count(), false, zone_, &graph),\n        maybe_non_escaping_string_concats_(phase_zone),\n        maybe_to_reconstruct_frame_states_(phase_zone) {}\n  void Run();\n\n  bool IsEscaping(OpIndex idx) const {\n    DCHECK(!graph_.Get(idx).Is<FrameStateOp>());\n    return escaping_operations_and_frame_states_to_reconstruct_[idx];\n  }\n\n  bool ShouldReconstructFrameState(V<FrameState> idx) {\n    return escaping_operations_and_frame_states_to_reconstruct_[idx];\n  }\n\n private:\n  const Graph& graph_;\n  Zone* zone_;\n\n  void ProcessBlock(const Block& block);\n  void ProcessFrameState(V<FrameState> index, const FrameStateOp& framestate);\n  void MarkNextFrameStateInputAsEscaping(FrameStateData::Iterator* it);\n  void MarkAllInputsAsEscaping(const Operation& op);\n  void RecursivelyMarkAllStringConcatInputsAsEscaping(\n      const StringConcatOp* concat);\n  void ReprocessStringConcats();\n  void ComputeFrameStatesToReconstruct();\n\n  void MarkAsEscaping(OpIndex index) {\n    DCHECK(!graph_.Get(index).Is<FrameStateOp>());\n    escaping_operations_and_frame_states_to_reconstruct_[index] = true;\n  }\n\n  void RecursiveMarkAsShouldReconstruct(V<FrameState> idx) {\n    escaping_operations_and_frame_states_to_reconstruct_[idx] = true;\n    const FrameStateOp* frame_state = &graph_.Get(idx).Cast<FrameStateOp>();\n    while (frame_state->inlined) {\n      V<FrameState> parent = frame_state->parent_frame_state();\n      escaping_operations_and_frame_states_to_reconstruct_[parent] = true;\n      frame_state = &graph_.Get(parent).Cast<FrameStateOp>();\n    }\n  }\n\n  // {escaping_operations_and_frame_states_to_recreate_} is used for 2 things:\n  //   - For FrameState OpIndex, if the stored value is `true`, then the reducer\n  //     should later reconstruct this FrameState (because it either contains an\n  //     elided StringConcat, or because it's the parent of such a FrameState).\n  //   - For other OpIndex, if the value stored is `true`, then the value is\n  //     definitely escaping, and should not be elided (and its inputs shouldn't\n  //     be elided either, etc.).\n  // This could easily be split in 2 variables, but it saves space to use a\n  // single variable for this.\n  FixedOpIndexSidetable<bool>\n      escaping_operations_and_frame_states_to_reconstruct_;\n\n  // When we visit a StringConcat for the first time and it's not already in\n  // {escaping_operations_}, we can't know for sure yet that it will never be\n  // escaping, because of loop phis. So, we store it in\n  // {maybe_non_escaping_string_concats_}, which we revisit after having visited\n  // the whole graph, and only after this revisit do we know for sure that\n  // StringConcat that are not in {escaping_operations_} do not indeed escape.\n  ZoneVector<V<String>> maybe_non_escaping_string_concats_;\n\n  ZoneVector<V<FrameState>> maybe_to_reconstruct_frame_states_;\n\n  uint32_t max_frame_state_input_count_ = 0;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StringEscapeAnalysisReducer\",\n            \"extends\": \"Next\",\n            \"about\": \"Turboshaft reducer that uses StringEscapeAnalyzer to elide string concatenations that do not escape.\",\n            \"attributes\": [\n                {\n                    \"name\": \"analyzer_\",\n                    \"type\": \"StringEscapeAnalyzer\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Instance of the string escape analyzer.\"\n                },\n                {\n                    \"name\": \"elided_strings_\",\n                    \"type\": \"ZoneAbslFlatHashMap<V<String>, std::pair<ElidedStringPart, ElidedStringPart>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map from input OpIndex of elided strings to their left and right concatenation parts.\"\n                },\n                {\n                    \"name\": \"deduplicators_\",\n                    \"type\": \"SparseOpIndexSideTable<Deduplicator*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mapping from input-graph FrameState to the corresponding deduplicator.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Next\",\n                \"StringEscapeAnalyzer\",\n                \"StringConcatOp\",\n                \"FrameStateOp\",\n                \"StringLengthOp\",\n                \"V<String>\",\n                \"V<FrameState>\",\n                \"ElidedStringPart\",\n                \"ZoneAbslFlatHashMap\",\n                \"SparseOpIndexSideTable\",\n                \"FrameStateInfo\",\n                \"FrameStateData\",\n                \"MachineType\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass StringEscapeAnalysisReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(StringEscapeAnalysis)\n\n  // ElidedStringPart is an input of a StringConcat that is getting elided. It\n  // could be either a regular String that appears in the output graph\n  // (kNotElided), or another StringConcat that got elided as well (kElided).\n  struct ElidedStringPart {\n    enum class Kind : uint8_t { kNotElided, kElided };\n    union {\n      V<String> og_index;\n      V<String> ig_index;\n    } data;\n\n    Kind kind;\n\n    static ElidedStringPart Elided(V<String> ig_index) {\n      return ElidedStringPart(Kind::kElided, ig_index);\n    }\n    static ElidedStringPart NotElided(V<String> og_index) {\n      return ElidedStringPart(Kind::kNotElided, og_index);\n    }\n\n    bool is_elided() const { return kind == Kind::kElided; }\n\n    V<String> og_index() const {\n      DCHECK_EQ(kind, Kind::kNotElided);\n      return data.og_index;\n    }\n    V<String> ig_index() const {\n      DCHECK_EQ(kind, Kind::kElided);\n      return data.ig_index;\n    }\n\n    bool operator==(const ElidedStringPart& other) const {\n      if (kind != other.kind) return false;\n      switch (kind) {\n        case Kind::kElided:\n          return ig_index() == other.ig_index();\n        case Kind::kNotElided:\n          return og_index() == other.og_index();\n      }\n    }\n\n    static ElidedStringPart Invalid() {\n      return ElidedStringPart(Kind::kNotElided, V<String>::Invalid());\n    }\n\n   private:\n    ElidedStringPart(Kind kind, V<String> index) : data(index), kind(kind) {}\n  };\n\n  void Analyze() {\n    if (v8_flags.turboshaft_string_concat_escape_analysis) {\n      analyzer_.Run();\n    }\n    Next::Analyze();\n  }\n\n  V<String> REDUCE_INPUT_GRAPH(StringConcat)(V<String> ig_index,\n                                             const StringConcatOp& op) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphStringConcat(ig_index, op);\n    }\n    if (!v8_flags.turboshaft_string_concat_escape_analysis) goto no_change;\n    if (analyzer_.IsEscaping(ig_index)) goto no_change;\n\n    // We're eliding this StringConcat.\n    ElidedStringPart left = GetElidedStringInput(op.left());\n    ElidedStringPart right = GetElidedStringInput(op.right());\n    elided_strings_.insert({ig_index, std::pair{left, right}});\n    return V<String>::Invalid();\n  }\n\n  V<FrameState> REDUCE_INPUT_GRAPH(FrameState)(\n      V<FrameState> ig_index, const FrameStateOp& frame_state) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphFrameState(ig_index, frame_state);\n    }\n    if (!v8_flags.turboshaft_string_concat_escape_analysis) goto no_change;\n\n    if (!analyzer_.ShouldReconstructFrameState(ig_index)) goto no_change;\n\n    return BuildFrameState(frame_state, ig_index);\n  }\n\n  V<Word32> REDUCE_INPUT_GRAPH(StringLength)(V<Word32> ig_index,\n                                             const StringLengthOp& op) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphStringLength(ig_index, op);\n    }\n    if (!v8_flags.turboshaft_string_concat_escape_analysis) goto no_change;\n\n    V<String> input_index = op.string();\n    if (const StringConcatOp* input = __ input_graph()\n                                          .Get(input_index)\n                                          .template TryCast<StringConcatOp>();\n        input && !analyzer_.IsEscaping(input_index)) {\n      return __ UntagSmi(__ MapToNewGraph(input->length()));\n    } else {\n      goto no_change;\n    }\n  }\n\n private:\n  class Deduplicator {\n   public:\n    explicit Deduplicator(Zone* zone) : string_ids_(zone) {}\n\n    struct DuplicatedId {\n      uint32_t id;\n      bool duplicated;\n    };\n    DuplicatedId GetDuplicatedIdForElidedString(ElidedStringPart index) {\n      // TODO(dmercadier): do better than a linear search here.\n      for (uint32_t id = 0; id < string_ids_.size(); id++) {\n        if (string_ids_[id] == index) {\n          return {id, true};\n        }\n      }\n      uint32_t new_id = static_cast<uint32_t>(string_ids_.size());\n      string_ids_.push_back(index);\n      return {new_id, false};\n    }\n\n    Deduplicator* clone(Zone* zone) const {\n      return zone->New<Deduplicator>(string_ids_);\n    }\n\n   private:\n    explicit Deduplicator(const ZoneVector<ElidedStringPart>& string_ids)\n        : string_ids_(string_ids) {}\n\n    // TODO(dmercadier): consider using a linked list for {string_ids_} so that\n    // we don't ever need to clone it.\n    ZoneVector<ElidedStringPart> string_ids_;\n\n    friend class i::Zone;  // For access to private constructor.\n  };\n\n  V<FrameState> BuildFrameState(const FrameStateOp& input_frame_state,\n                                OpIndex ig_index) {\n    DCHECK(v8_flags.turboshaft_string_concat_escape_analysis);\n\n    const FrameStateInfo& info = input_frame_state.data->frame_state_info;\n\n    FrameStateData::Builder builder;\n    auto it =\n        input_frame_state.data->iterator(input_frame_state.state_values());\n\n    Deduplicator* deduplicator;\n    if (input_frame_state.inlined) {\n      V<FrameState> parent_ig_index = input_frame_state.parent_frame_state();\n      builder.AddParentFrameState(__ MapToNewGraph(parent_ig_index));\n\n      // The parent FrameState could contain dematerialized objects, and the\n      // current FrameState could reference those. Also, new IDs created for the\n      // current FrameState should not conflict with IDs in the parent frame\n      // state. Thus, we need to initialize the current Deduplicator with the\n      // one from the parent FrameState.\n      DCHECK(analyzer_.ShouldReconstructFrameState(parent_ig_index));\n      deduplicator = deduplicators_[parent_ig_index]->clone(__ phase_zone());\n    } else {\n      deduplicator =\n          __ phase_zone() -> template New<Deduplicator>(__ phase_zone());\n    }\n    deduplicators_[ig_index] = deduplicator;\n\n    // Closure\n    BuildFrameStateInput(&builder, &it, deduplicator);\n\n    // Parameters\n    for (int i = 0; i < info.parameter_count(); i++) {\n      BuildFrameStateInput(&builder, &it, deduplicator);\n    }\n\n    // Context\n    BuildFrameStateInput(&builder, &it, deduplicator);\n\n    // Registers/locals\n    for (int i = 0; i < info.local_count(); i++) {\n      BuildFrameStateInput(&builder, &it, deduplicator);\n    }\n\n    // Accumulator\n    for (int i = 0; i < info.stack_count(); i++) {\n      BuildFrameStateInput(&builder, &it, deduplicator);\n    }\n\n    return __ FrameState(builder.Inputs(), builder.inlined(),\n                         builder.AllocateFrameStateData(info, __ graph_zone()));\n  }\n\n  void BuildFrameStateInput(FrameStateData::Builder* builder,\n                            FrameStateData::Iterator* it,\n                            Deduplicator* deduplicator) {\n    switch (it->current_instr()) {\n      using Instr = FrameStateData::Instr;\n      case Instr::kInput: {\n        MachineType type;\n        OpIndex input;\n        it->ConsumeInput(&type, &input);\n        if (elided_strings_.contains(input)) {\n          DCHECK(type.IsTagged());\n          BuildMaybeElidedString(builder, ElidedStringPart::Elided(input),\n                                 deduplicator);\n        } else {\n          builder->AddInput(type, __ MapToNewGraph(input));\n        }\n        break;\n      }\n      case Instr::kDematerializedObject: {\n        uint32_t old_id;\n        uint32_t field_count;\n        it->ConsumeDematerializedObject(&old_id, &field_count);\n        builder->AddDematerializedObject(old_id, field_count);\n        for (uint32_t i = 0; i < field_count; ++i) {\n          BuildFrameStateInput(builder, it, deduplicator);\n        }\n        break;\n      }\n      case Instr::kDematerializedObjectReference: {\n        uint32_t old_id;\n        it->ConsumeDematerializedObjectReference(&old_id);\n        builder->AddDematerializedObjectReference(old_id);\n        break;\n      }\n      case Instr::kArgumentsElements: {\n        CreateArgumentsType type;\n        it->ConsumeArgumentsElements(&type);\n        builder->AddArgumentsElements(type);\n        break;\n      }\n      case Instr::kArgumentsLength:\n        it->ConsumeArgumentsLength();\n        builder->AddArgumentsLength();\n        break;\n      case Instr::kRestLength:\n        it->ConsumeRestLength();\n        builder->AddRestLength();\n        break;\n      case Instr::kUnusedRegister:\n        it->ConsumeUnusedRegister();\n        builder->AddUnusedRegister();\n        break;\n      case FrameStateData::Instr::kDematerializedStringConcat:\n      case FrameStateData::Instr::kDematerializedStringConcatReference:\n        // StringConcat should not have been escaped before this point.\n        UNREACHABLE();\n    }\n  }\n\n  void BuildMaybeElidedString(FrameStateData::Builder* builder,\n                              ElidedStringPart maybe_elided,\n                              Deduplicator* deduplicator) {\n    if (maybe_elided.is_elided()) {\n      typename Deduplicator::DuplicatedId dup_id =\n          deduplicator->GetDuplicatedIdForElidedString(maybe_elided);\n      if (dup_id.duplicated) {\n        // For performance reasons, we de-duplicate repeated StringConcat inputs\n        // in the FrameState. Unlike for elided objects, deduplication has no\n        // impact on correctness.\n        builder->AddDematerializedStringConcatReference(dup_id.id);\n        return;\n      }\n      builder->AddDematerializedStringConcat(dup_id.id);\n      std::pair<ElidedStringPart, ElidedStringPart> inputs =\n          elided_strings_.at(maybe_elided.ig_index());\n      BuildMaybeElidedString(builder, inputs.first, deduplicator);\n      BuildMaybeElidedString(builder, inputs.second, deduplicator);\n    } else {\n      builder->AddInput(MachineType::AnyTagged(), maybe_elided.og_index());\n    }\n  }\n\n  ElidedStringPart GetElidedStringInput(V<String> ig_index) {\n    if (elided_strings_.contains(ig_index)) {\n      return ElidedStringPart::Elided(ig_index);\n    } else {\n      return ElidedStringPart::NotElided(__ MapToNewGraph(ig_index));\n    }\n  }\n\n  StringEscapeAnalyzer analyzer_{Asm().input_graph(), Asm().phase_zone()};\n  // Map from input OpIndex of elided strings to the pair of output OpIndex\n  // that are their left and right sides of the concatenation.\n  ZoneAbslFlatHashMap<V<String>, std::pair<ElidedStringPart, ElidedStringPart>>\n      elided_strings_{Asm().phase_zone()};\n\n  // Mapping from input-graph FrameState to the corresponding deduplicator.\n  SparseOpIndexSideTable<Deduplicator*> deduplicators_{Asm().phase_zone(),\n                                                       &Asm().input_graph()};\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ElidedStringPart\",\n            \"about\": \"Represents a part of a string concatenation that is being elided, indicating whether it's a regular string or another elided concatenation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"enum class Kind : uint8_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates whether the string part is elided or not.\"\n                },\n                {\n                    \"name\": \"data\",\n                    \"type\": \"union\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Stores either the original graph index or the input graph index of the string part.\"\n                }\n            ],\n            \"dependencies\": [\n                \"V<String>\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  // ElidedStringPart is an input of a StringConcat that is getting elided. It\n  // could be either a regular String that appears in the output graph\n  // (kNotElided), or another StringConcat that got elided as well (kElided).\n  struct ElidedStringPart {\n    enum class Kind : uint8_t { kNotElided, kElided };\n    union {\n      V<String> og_index;\n      V<String> ig_index;\n    } data;\n\n    Kind kind;\n\n    static ElidedStringPart Elided(V<String> ig_index) {\n      return ElidedStringPart(Kind::kElided, ig_index);\n    }\n    static ElidedStringPart NotElided(V<String> og_index) {\n      return ElidedStringPart(Kind::kNotElided, og_index);\n    }\n\n    bool is_elided() const { return kind == Kind::kElided; }\n\n    V<String> og_index() const {\n      DCHECK_EQ(kind, Kind::kNotElided);\n      return data.og_index;\n    }\n    V<String> ig_index() const {\n      DCHECK_EQ(kind, Kind::kElided);\n      return data.ig_index;\n    }\n\n    bool operator==(const ElidedStringPart& other) const {\n      if (kind != other.kind) return false;\n      switch (kind) {\n        case Kind::kElided:\n          return ig_index() == other.ig_index();\n        case Kind::kNotElided:\n          return og_index() == other.og_index();\n      }\n    }\n\n    static ElidedStringPart Invalid() {\n      return ElidedStringPart(Kind::kNotElided, V<String>::Invalid());\n    }\n\n   private:\n    ElidedStringPart(Kind kind, V<String> index) : data(index), kind(kind) {}\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Deduplicator\",\n            \"about\": \"Deduplicates elided string parts within frame states to improve performance.\",\n            \"attributes\": [\n                {\n                    \"name\": \"string_ids_\",\n                    \"type\": \"ZoneVector<ElidedStringPart>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector storing the unique ElidedStringParts seen so far.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"ZoneVector\",\n                \"ElidedStringPart\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class Deduplicator {\n   public:\n    explicit Deduplicator(Zone* zone) : string_ids_(zone) {}\n\n    struct DuplicatedId {\n      uint32_t id;\n      bool duplicated;\n    };\n    DuplicatedId GetDuplicatedIdForElidedString(ElidedStringPart index) {\n      // TODO(dmercadier): do better than a linear search here.\n      for (uint32_t id = 0; id < string_ids_.size(); id++) {\n        if (string_ids_[id] == index) {\n          return {id, true};\n        }\n      }\n      uint32_t new_id = static_cast<uint32_t>(string_ids_.size());\n      string_ids_.push_back(index);\n      return {new_id, false};\n    }\n\n    Deduplicator* clone(Zone* zone) const {\n      return zone->New<Deduplicator>(string_ids_);\n    }\n\n   private:\n    explicit Deduplicator(const ZoneVector<ElidedStringPart>& string_ids)\n        : string_ids_(string_ids) {}\n\n    // TODO(dmercadier): consider using a linked list for {string_ids_} so that\n    // we don't ever need to clone it.\n    ZoneVector<ElidedStringPart> string_ids_;\n\n    friend class i::Zone;  // For access to private constructor.\n  };\n        ]]></code>\n    </class>\n</file>\n```"
}