{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/linkage.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 388, column 30",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/linkage.h\",\n        \"file_name\": \"linkage.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the linkage for a compilation in V8, including calling conventions for parameters, return values, and outgoing calls.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/compiler-specific.h\"\n#include \"src/base/flags.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/codegen/linkage-location.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/codegen/register.h\"\n#include \"src/codegen/reglist.h\"\n#include \"src/codegen/signature.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/frame.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/operator.h\"\n#include \"src/execution/encoded-c-signature.h\"\n#include \"src/runtime/runtime.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CallDescriptor\",\n            \"extends\": \"ZoneObject\",\n            \"about\": \"Describes a call to various parts of the compiler, including target, parameters and return values.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"LinkageLocation\",\n                \"LocationSignature\",\n                \"MachineType\",\n                \"Operator\",\n                \"RegList\",\n                \"DoubleRegList\",\n                \"StackArgumentOrder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE CallDescriptor final\n    : public NON_EXPORTED_BASE(ZoneObject) {\n public:\n  // Describes the kind of this call, which determines the target.\n  enum Kind {\n    kCallCodeObject,         // target is a Code object\n    kCallJSFunction,         // target is a JSFunction object\n    kCallAddress,            // target is a machine pointer\n#if V8_ENABLE_WEBASSEMBLY    // \u2193 WebAssembly only\n    kCallWasmCapiFunction,   // target is a Wasm C API function\n    kCallWasmFunction,       // target is a wasm function\n    kCallWasmFunctionIndirect,  // target is a wasm function that will be called\n                                // indirectly\n    kCallWasmImportWrapper,     // target is a wasm import wrapper\n#endif                       // \u2191 WebAssembly only\n    kCallBuiltinPointer,     // target is a builtin pointer\n  };\n\n  // NOTE: The lowest 10 bits of the Flags field are encoded in InstructionCode\n  // (for use in the code generator). All higher bits are lost.\n  static constexpr int kFlagsBitsEncodedInInstructionCode = 10;\n  enum Flag {\n    kNoFlags = 0u,\n    kNeedsFrameState = 1u << 0,\n    kHasExceptionHandler = 1u << 1,\n    kCanUseRoots = 1u << 2,\n    // Causes the code generator to initialize the root register.\n    kInitializeRootRegister = 1u << 3,\n    // Does not ever try to allocate space on our heap.\n    kNoAllocate = 1u << 4,\n    // Use the kJavaScriptCallCodeStartRegister (fixed) register for the\n    // indirect target address when calling.\n    kFixedTargetRegister = 1u << 5,\n    kCallerSavedRegisters = 1u << 6,\n    // The kCallerSavedFPRegisters only matters (and set) when the more general\n    // flag for kCallerSavedRegisters above is also set.\n    kCallerSavedFPRegisters = 1u << 7,\n    // Tail calls for tier up are special (in fact they are different enough\n    // from normal tail calls to warrant a dedicated opcode; but they also have\n    // enough similar aspects that reusing the TailCall opcode is pragmatic).\n    // Specifically:\n    //\n    // 1. Caller and callee are both JS-linkage Code objects.\n    // 2. JS runtime arguments are passed unchanged from caller to callee.\n    // 3. JS runtime arguments are not attached as inputs to the TailCall node.\n    // 4. Prior to the tail call, frame and register state is torn down to just\n    //    before the caller frame was constructed.\n    // 5. Unlike normal tail calls, inlined arguments frames (if present) are\n    //    *not* torn down.\n    //\n    // In other words, behavior is identical to a jmp instruction prior caller\n    // frame construction.\n    kIsTailCallForTierUp = 1u << 8,\n\n    // AIX has a function descriptor by default but it can be disabled for a\n    // certain CFunction call (only used for Kind::kCallAddress).\n    kNoFunctionDescriptor = 1u << 9,\n\n    // Flags past here are *not* encoded in InstructionCode and are thus not\n    // accessible from the code generator. See also\n    // kFlagsBitsEncodedInInstructionCode.\n  };\n  using Flags = base::Flags<Flag>;\n\n  CallDescriptor(Kind kind, CodeEntrypointTag tag, MachineType target_type,\n                 LinkageLocation target_loc, LocationSignature* location_sig,\n                 size_t param_slot_count, Operator::Properties properties,\n                 RegList callee_saved_registers,\n                 DoubleRegList callee_saved_fp_registers, Flags flags,\n                 const char* debug_name = \"\",\n                 StackArgumentOrder stack_order = StackArgumentOrder::kDefault,\n                 const RegList allocatable_registers = {},\n                 size_t return_slot_count = 0,\n                 uint64_t signature_hash = kInvalidWasmSignatureHash)\n      : kind_(kind),\n        tag_(tag),\n        target_type_(target_type),\n        target_loc_(target_loc),\n        location_sig_(location_sig),\n        param_slot_count_(param_slot_count),\n        return_slot_count_(return_slot_count),\n        properties_(properties),\n        callee_saved_registers_(callee_saved_registers),\n        callee_saved_fp_registers_(callee_saved_fp_registers),\n        allocatable_registers_(allocatable_registers),\n        flags_(flags),\n        stack_order_(stack_order),\n        debug_name_(debug_name),\n        signature_hash_(signature_hash) {\n#ifdef V8_ENABLE_WEBASSEMBLY\n    if (kind == Kind::kCallWasmFunctionIndirect) {\n      CHECK_NE(signature_hash, kInvalidWasmSignatureHash);\n    }\n#endif\n  }\n\n  CallDescriptor(const CallDescriptor&) = delete;\n  CallDescriptor& operator=(const CallDescriptor&) = delete;\n\n  // Returns the kind of this call.\n  Kind kind() const { return kind_; }\n\n  // Returns the entrypoint tag for this call.\n  CodeEntrypointTag tag() const { return tag_; }\n\n  uint64_t signature_hash() const;\n\n  // Returns the entrypoint tag for this call, shifted to the right by\n  // kCodeEntrypointTagShift so that it fits into a 32-bit immediate.\n  uint32_t shifted_tag() const {\n    static_assert(kCodeEntrypointTagShift >= 32);\n    return tag_ >> kCodeEntrypointTagShift;\n  }\n\n  // Returns {true} if this descriptor is a call to a Code object.\n  bool IsCodeObjectCall() const { return kind_ == kCallCodeObject; }\n\n  // Returns {true} if this descriptor is a call to a C function.\n  bool IsCFunctionCall() const { return kind_ == kCallAddress; }\n\n  // Returns {true} if this descriptor is a call to a JSFunction.\n  bool IsJSFunctionCall() const { return kind_ == kCallJSFunction; }\n\n#if V8_ENABLE_WEBASSEMBLY\n  // Returns {true} if this descriptor is a direct call to a WebAssembly\n  // function.\n  bool IsDirectWasmFunctionCall() const { return kind_ == kCallWasmFunction; }\n\n  // Returns {true} if this descriptor is a indirect call to a WebAssembly\n  // function.\n  bool IsIndirectWasmFunctionCall() const {\n    return kind_ == kCallWasmFunctionIndirect;\n  }\n\n  // Returns {true} if this descriptor is either a direct or an indirect call to\n  // a WebAssembly function.\n  bool IsAnyWasmFunctionCall() const {\n    return IsDirectWasmFunctionCall() || IsIndirectWasmFunctionCall();\n  }\n\n  // Returns {true} if this descriptor is a call to a WebAssembly function.\n  bool IsWasmImportWrapper() const { return kind_ == kCallWasmImportWrapper; }\n\n  // Returns {true} if this descriptor is a call to a Wasm C API function.\n  bool IsWasmCapiFunction() const { return kind_ == kCallWasmCapiFunction; }\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n  bool IsBuiltinPointerCall() const { return kind_ == kCallBuiltinPointer; }\n\n  bool RequiresFrameAsIncoming() const {\n    if (IsCFunctionCall() || IsJSFunctionCall()) return true;\n#if V8_ENABLE_WEBASSEMBLY\n    if (IsAnyWasmFunctionCall()) return true;\n#endif  // V8_ENABLE_WEBASSEMBLY\n    if (CalleeSavedRegisters() != kNoCalleeSaved) return true;\n    return false;\n  }\n\n  bool RequiresEntrypointTagForCall() const { return IsCodeObjectCall(); }\n\n  // The number of return values from this call.\n  size_t ReturnCount() const { return location_sig_->return_count(); }\n\n  // The number of C parameters to this call. The following invariant\n  // should hold true:\n  // ParameterCount() == GPParameterCount() + FPParameterCount()\n  size_t ParameterCount() const { return location_sig_->parameter_count(); }\n\n  // The number of general purpose C parameters to this call.\n  size_t GPParameterCount() const {\n    if (!gp_param_count_) {\n      ComputeParamCounts();\n    }\n    return gp_param_count_.value();\n  }\n\n  // The number of floating point C parameters to this call.\n  size_t FPParameterCount() const {\n    if (!fp_param_count_) {\n      ComputeParamCounts();\n    }\n    return fp_param_count_.value();\n  }\n\n  // The number of stack parameter slots to the call.\n  size_t ParameterSlotCount() const { return param_slot_count_; }\n\n  // The number of stack return value slots from the call.\n  size_t ReturnSlotCount() const { return return_slot_count_; }\n\n  // The number of parameters to the JS function call.\n  size_t JSParameterCount() const {\n    DCHECK(IsJSFunctionCall());\n    return param_slot_count_;\n  }\n\n  int GetStackIndexFromSlot(int slot_index) const {\n    switch (GetStackArgumentOrder()) {\n      case StackArgumentOrder::kDefault:\n        return -slot_index - 1;\n      case StackArgumentOrder::kJS:\n        return slot_index + static_cast<int>(ParameterSlotCount());\n    }\n  }\n\n  // The total number of inputs to this call, which includes the target,\n  // receiver, context, etc.\n  // TODO(titzer): this should input the framestate input too.\n  size_t InputCount() const { return 1 + location_sig_->parameter_count(); }\n\n  size_t FrameStateCount() const { return NeedsFrameState() ? 1 : 0; }\n\n  Flags flags() const { return flags_; }\n\n  bool NeedsFrameState() const { return flags() & kNeedsFrameState; }\n  bool InitializeRootRegister() const {\n    return flags() & kInitializeRootRegister;\n  }\n  bool NeedsCallerSavedRegisters() const {\n    return flags() & kCallerSavedRegisters;\n  }\n  bool NeedsCallerSavedFPRegisters() const {\n    return flags() & kCallerSavedFPRegisters;\n  }\n  bool IsTailCallForTierUp() const { return flags() & kIsTailCallForTierUp; }\n  bool NoFunctionDescriptor() const { return flags() & kNoFunctionDescriptor; }\n\n  LinkageLocation GetReturnLocation(size_t index) const {\n    return location_sig_->GetReturn(index);\n  }\n\n  LinkageLocation GetInputLocation(size_t index) const {\n    if (index == 0) return target_loc_;\n    return location_sig_->GetParam(index - 1);\n  }\n\n  MachineSignature* GetMachineSignature(Zone* zone) const;\n\n  MachineType GetReturnType(size_t index) const {\n    return location_sig_->GetReturn(index).GetType();\n  }\n\n  MachineType GetInputType(size_t index) const {\n    if (index == 0) return target_type_;\n    return location_sig_->GetParam(index - 1).GetType();\n  }\n\n  MachineType GetParameterType(size_t index) const {\n    return location_sig_->GetParam(index).GetType();\n  }\n\n  StackArgumentOrder GetStackArgumentOrder() const { return stack_order_; }\n\n  // Operator properties describe how this call can be optimized, if at all.\n  Operator::Properties properties() const { return properties_; }\n\n  // Get the callee-saved registers, if any, across this call.\n  RegList CalleeSavedRegisters() const { return callee_saved_registers_; }\n\n  // Get the callee-saved FP registers, if any, across this call.\n  DoubleRegList CalleeSavedFPRegisters() const {\n    return callee_saved_fp_registers_;\n  }\n\n  const char* debug_name() const { return debug_name_; }\n\n  // Difference between the number of parameter slots of *this* and\n  // *tail_caller* (callee minus caller).\n  int GetStackParameterDelta(const CallDescriptor* tail_caller) const;\n\n  // Returns the offset to the area below the parameter slots on the stack,\n  // relative to callee slot 0, the return address. If there are no parameter\n  // slots, returns +1.\n  int GetOffsetToFirstUnusedStackSlot() const;\n\n  // Returns the offset to the area above the return slots on the stack,\n  // relative to callee slot 0, the return address. If there are no return\n  // slots, returns the offset to the lowest slot of the parameter area.\n  // If there are no parameter slots, returns 0.\n  int GetOffsetToReturns() const;\n\n  // Returns two 16-bit numbers packed together: (first slot << 16) | num_slots.\n  uint32_t GetTaggedParameterSlots() const;\n\n  bool CanTailCall(const CallDescriptor* callee) const;\n\n  int CalculateFixedFrameSize(CodeKind code_kind) const;\n\n  RegList AllocatableRegisters() const { return allocatable_registers_; }\n\n  bool HasRestrictedAllocatableRegisters() const {\n    return !allocatable_registers_.is_empty();\n  }\n\n  EncodedCSignature ToEncodedCSignature() const;\n\n private:\n  void ComputeParamCounts() const;\n\n  friend class Linkage;\n\n  const Kind kind_;\n  const CodeEntrypointTag tag_;\n  const MachineType target_type_;\n  const LinkageLocation target_loc_;\n  const LocationSignature* const location_sig_;\n  const size_t param_slot_count_;\n  const size_t return_slot_count_;\n  const Operator::Properties properties_;\n  const RegList callee_saved_registers_;\n  const DoubleRegList callee_saved_fp_registers_;\n  // Non-zero value means restricting the set of allocatable registers for\n  // register allocator to use.\n  const RegList allocatable_registers_;\n  const Flags flags_;\n  const StackArgumentOrder stack_order_;\n  const char* const debug_name_;\n\n  uint64_t signature_hash_;\n\n  mutable std::optional<size_t> gp_param_count_;\n  mutable std::optional<size_t> fp_param_count_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for CallDescriptor to allow for printing a CallDescriptor object to an output stream.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"A reference to the output stream.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const CallDescriptor& d);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for CallDescriptor::Kind to allow printing to an output stream.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"A reference to the output stream.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nV8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os,\n                                           const CallDescriptor::Kind& k);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetI32WasmCallDescriptor\",\n            \"about\": \"Lowers a wasm CallDescriptor for 32 bit platforms by replacing i64 parameters and returns with two i32s each.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"CallDescriptor*\",\n                \"description\": \"A pointer to CallDescriptor.\"\n            },\n            \"dependencies\": [\n                \"CallDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\n// Lowers a wasm CallDescriptor for 32 bit platforms by replacing i64 parameters\n// and returns with two i32s each.\nV8_EXPORT_PRIVATE CallDescriptor* GetI32WasmCallDescriptor(\n    Zone* zone, const CallDescriptor* call_descriptor);\n#endif\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Linkage\",\n            \"extends\": \"ZoneObject\",\n            \"about\": \"Defines the linkage for a compilation, including calling conventions for parameters and return values.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CallDescriptor\",\n                \"OptimizedCompilationInfo\",\n                \"CallInterfaceDescriptor\",\n                \"Runtime\",\n                \"MachineSignature\",\n                \"LazyDeoptOnThrow\",\n                \"StubCallMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Defines the linkage for a compilation, including the calling conventions\n// for incoming parameters and return value(s) as well as the outgoing calling\n// convention for any kind of call. Linkage is generally architecture-specific.\n//\n// Can be used to translate {arg_index} (i.e. index of the call node input) as\n// well as {param_index} (i.e. as stored in parameter nodes) into an operator\n// representing the architecture-specific location. The following call node\n// layouts are supported (where {n} is the number of value inputs):\n//\n//                        #0          #1     #2     [...]             #n\n// Call[CodeStub]         code,       arg 1, arg 2, [...],            context\n// Call[JSFunction]       function,   rcvr,  arg 1, [...], new, #arg, context\n// Call[Runtime]          CEntry,     arg 1, arg 2, [...], fun, #arg, context\n// Call[BytecodeDispatch] address,    arg 1, arg 2, [...]\nclass V8_EXPORT_PRIVATE Linkage : public NON_EXPORTED_BASE(ZoneObject) {\n public:\n  explicit Linkage(CallDescriptor* incoming) : incoming_(incoming) {}\n  Linkage(const Linkage&) = delete;\n  Linkage& operator=(const Linkage&) = delete;\n\n  static CallDescriptor* ComputeIncoming(Zone* zone,\n                                         OptimizedCompilationInfo* info);\n\n  // The call descriptor for this compilation unit describes the locations\n  // of incoming parameters and the outgoing return value(s).\n  CallDescriptor* GetIncomingDescriptor() const { return incoming_; }\n  // Calls to JSFunctions should never overwrite the {properties}, but calls to\n  // known builtins might.\n  static CallDescriptor* GetJSCallDescriptor(\n      Zone* zone, bool is_osr, int parameter_count, CallDescriptor::Flags flags,\n      Operator::Properties properties =\n          Operator::kNoProperties /* use with care! */);\n\n  static CallDescriptor* GetRuntimeCallDescriptor(\n      Zone* zone, Runtime::FunctionId function, int js_parameter_count,\n      Operator::Properties properties, CallDescriptor::Flags flags,\n      LazyDeoptOnThrow lazy_deopt_on_throw = LazyDeoptOnThrow::kNo);\n\n  static CallDescriptor* GetCEntryStubCallDescriptor(\n      Zone* zone, int return_count, int js_parameter_count,\n      const char* debug_name, Operator::Properties properties,\n      CallDescriptor::Flags flags,\n      StackArgumentOrder stack_order = StackArgumentOrder::kDefault);\n\n  static CallDescriptor* GetStubCallDescriptor(\n      Zone* zone, const CallInterfaceDescriptor& descriptor,\n      int stack_parameter_count, CallDescriptor::Flags flags,\n      Operator::Properties properties = Operator::kNoProperties,\n      StubCallMode stub_mode = StubCallMode::kCallCodeObject);\n\n  static CallDescriptor* GetBytecodeDispatchCallDescriptor(\n      Zone* zone, const CallInterfaceDescriptor& descriptor,\n      int stack_parameter_count);\n\n  // Creates a call descriptor for simplified C calls that is appropriate\n  // for the host platform. This simplified calling convention only supports\n  // integers and pointers of one word size each, i.e. no floating point,\n  // structs, pointers to members, etc.\n  static CallDescriptor* GetSimplifiedCDescriptor(\n      Zone* zone, const MachineSignature* sig,\n      CallDescriptor::Flags flags = CallDescriptor::kNoFlags,\n      Operator::Properties properties = Operator::kNoThrow);\n\n  // Get the location of an (incoming) parameter to this function.\n  LinkageLocation GetParameterLocation(int index) const {\n    return incoming_->GetInputLocation(index + 1);  // + 1 to skip target.\n  }\n\n  // Get the machine type of an (incoming) parameter to this function.\n  MachineType GetParameterType(int index) const {\n    return incoming_->GetInputType(index + 1);  // + 1 to skip target.\n  }\n\n  // Get the location where this function should place its return value.\n  LinkageLocation GetReturnLocation(size_t index = 0) const {\n    return incoming_->GetReturnLocation(index);\n  }\n\n  // Get the machine type of this function's return value.\n  MachineType GetReturnType(size_t index = 0) const {\n    return incoming_->GetReturnType(index);\n  }\n\n  bool ParameterHasSecondaryLocation(int index) const;\n  LinkageLocation GetParameterSecondaryLocation(int index) const;\n\n  static bool NeedsFrameStateInput(Runtime::FunctionId function);\n\n  // Get the location where an incoming OSR value is stored.\n  LinkageLocation GetOsrValueLocation(int index) const;\n\n  // A special {Parameter} index for Stub Calls that represents context.\n  static int GetStubCallContextParamIndex(int parameter_count) {\n    return parameter_count + 0;\n  }\n\n  // A special {Parameter} index for JSCalls that represents the new target.\n  static constexpr int GetJSCallNewTargetParamIndex(int parameter_count) {\n    return parameter_count + 0;\n  }\n\n  // A special {Parameter} index for JSCalls that represents the argument count.\n  static constexpr int GetJSCallArgCountParamIndex(int parameter_count) {\n    return GetJSCallNewTargetParamIndex(parameter_count) + 1;\n  }\n\n#ifdef V8_JS_LINKAGE_INCLUDES_DISPATCH_HANDLE\n  // A special {Parameter} index for JSCalls that represents the dispatch\n  // handle.\n  static constexpr int GetJSCallDispatchHandleParamIndex(int parameter_count) {\n    return GetJSCallArgCountParamIndex(parameter_count) + 1;\n  }\n#endif\n\n  // A special {Parameter} index for JSCalls that represents the context.\n  static constexpr int GetJSCallContextParamIndex(int parameter_count) {\n#ifdef V8_JS_LINKAGE_INCLUDES_DISPATCH_HANDLE\n    return GetJSCallDispatchHandleParamIndex(parameter_count) + 1;\n#else\n    return GetJSCallArgCountParamIndex(parameter_count) + 1;\n#endif\n  }\n\n  // A special {Parameter} index for JSCalls that represents the closure.\n  static constexpr int kJSCallClosureParamIndex = kJSCallClosureParameterIndex;\n  static_assert(kJSCallClosureParamIndex == -1);\n\n  // A special {OsrValue} index to indicate the context spill slot.\n  static const int kOsrContextSpillSlotIndex = -1;\n\n  // A special {OsrValue} index to indicate the accumulator register.\n  static const int kOsrAccumulatorRegisterIndex = -1;\n\n private:\n  CallDescriptor* const incoming_;\n};\n        ]]></code>\n    </class>\n</file>\n```"
}