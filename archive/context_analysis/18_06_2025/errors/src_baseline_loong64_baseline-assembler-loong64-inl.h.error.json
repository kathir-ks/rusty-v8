{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/loong64/baseline-assembler-loong64-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/loong64/baseline-assembler-loong64-inl.h\",\n            \"file_name\": \"baseline-assembler-loong64-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides inline implementations for the BaselineAssembler class on the loong64 architecture. This class is used for generating baseline code for the V8 JavaScript engine.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for baseline code assembly, interface descriptors, Loong64 assembler functionalities, and literal objects.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/baseline/baseline-assembler.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/codegen/loong64/assembler-loong64-inl.h\"\n#include \"src/objects/literal-objects-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BaselineAssembler::ScratchRegisterScope\",\n                \"about\": \"Manages the allocation and deallocation of scratch registers within a BaselineAssembler. Ensures registers are available for temporary computations and are released properly.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"assembler_\",\n                        \"type\": \"BaselineAssembler*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the associated BaselineAssembler instance.\"\n                    },\n                    {\n                        \"name\": \"prev_scope_\",\n                        \"type\": \"ScratchRegisterScope*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the previous ScratchRegisterScope in a stack-like structure, enabling nested scopes.\"\n                    },\n                    {\n                        \"name\": \"wrapped_scope_\",\n                        \"type\": \"UseScratchRegisterScope\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An instance of UseScratchRegisterScope that handles the actual register allocation using the assembler's masm (MacroAssembler).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BaselineAssembler\",\n                    \"UseScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass BaselineAssembler::ScratchRegisterScope {\n public:\n  explicit ScratchRegisterScope(BaselineAssembler* assembler)\n      : assembler_(assembler),\n        prev_scope_(assembler->scratch_register_scope_),\n        wrapped_scope_(assembler->masm()) {\n    if (!assembler_->scratch_register_scope_) {\n      // If we haven't opened a scratch scope yet, for the first one add a\n      // couple of extra registers.\n      wrapped_scope_.Include({t0, t1, t2, t3});\n    }\n    assembler_->scratch_register_scope_ = this;\n  }\n  ~ScratchRegisterScope() { assembler_->scratch_register_scope_ = prev_scope_; }\n\n  Register AcquireScratch() { return wrapped_scope_.Acquire(); }\n\n private:\n  BaselineAssembler* assembler_;\n  ScratchRegisterScope* prev_scope_;\n  UseScratchRegisterScope wrapped_scope_;\n};\n        ]]></code>\n    </class>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"detail\",\n                \"about\": \"Contains helper functions for the BaselineAssembler implementation.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace detail {\n\n#ifdef DEBUG\ninline bool Clobbers(Register target, MemOperand op) {\n  return op.base() == target || op.index() == target;\n}\n#endif\n\n}  // namespace detail\n        ]]></code>\n    </namespace>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RegisterFrameOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the MemOperand for accessing a register within the interpreter's register frame.\",\n                \"logic\": \"Multiplies the interpreter register's operand index by the kSystemPointerSize to obtain the correct offset within the frame.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interpreter_register\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The interpreter register to access.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"A MemOperand representing the memory location of the register within the frame.\"\n                },\n                \"dependencies\": [\n                    \"interpreter::Register\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::RegisterFrameOperand(\n    interpreter::Register interpreter_register) {\n  return MemOperand(fp, interpreter_register.ToOperand() * kSystemPointerSize);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RegisterFrameAddress\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the memory address of a register in the interpreter frame and stores it in a scratch register.\",\n                \"logic\": \"Computes the address by adding the frame pointer (fp) with the offset derived from the interpreter register and stores the result in the provided scratch register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interpreter_register\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The interpreter register whose address is to be computed.\"\n                    },\n                    {\n                        \"name\": \"rscratch\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"A scratch register to store the computed memory address.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"interpreter::Register\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::RegisterFrameAddress(\n    interpreter::Register interpreter_register, Register rscratch) {\n  return __ Add_d(rscratch, fp,\n                  interpreter_register.ToOperand() * kSystemPointerSize);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FeedbackVectorOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Returns a MemOperand for accessing the feedback vector within the baseline frame.\",\n                \"logic\": \"Uses the BaselineFrameConstants::kFeedbackVectorFromFp offset from the frame pointer (fp).\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"A MemOperand representing the memory location of the feedback vector.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackVectorOperand() {\n  return MemOperand(fp, BaselineFrameConstants::kFeedbackVectorFromFp);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FeedbackCellOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Returns a MemOperand for accessing the feedback cell within the baseline frame.\",\n                \"logic\": \"Uses the BaselineFrameConstants::kFeedbackCellFromFp offset from the frame pointer (fp).\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"A MemOperand representing the memory location of the feedback cell.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackCellOperand() {\n  return MemOperand(fp, BaselineFrameConstants::kFeedbackCellFromFp);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Bind\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Binds a label to the current code position.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"label\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to bind.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::Bind(Label* label) { __ bind(label); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpTarget\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Placeholder for a jump target.  Currently a no-op.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpTarget() {\n  // NOP.\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Jump\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Unconditional jump to a target label.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target (e.g., near or far). Not used in this implementation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::Jump(Label* target, Label::Distance distance) {\n  __ Branch(target);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfRoot\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump if a register value is equal to a specific root value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the value to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"RootIndex\",\n                        \"purpose\": \"The index of the root value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target. Not used in this implementation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfRoot(Register value, RootIndex index,\n                                   Label* target, Label::Distance) {\n  __ JumpIfRoot(value, index, target);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfNotRoot\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump if a register value is not equal to a specific root value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the value to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"RootIndex\",\n                        \"purpose\": \"The index of the root value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target. Not used in this implementation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotRoot(Register value, RootIndex index,\n                                      Label* target, Label::Distance) {\n  __ JumpIfNotRoot(value, index, target);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump if a register value is a Smi (Small Integer).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the value to check.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the value is a Smi.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target. Not used in this implementation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Register value, Label* target,\n                                  Label::Distance) {\n  __ JumpIfSmi(value, target);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfNotSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump if a register value is not a Smi (Small Integer).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the value to check.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the value is not a Smi.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target. Not used in this implementation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotSmi(Register value, Label* target,\n                                     Label::Distance) {\n  __ JumpIfNotSmi(value, target);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfImmediate\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump based on a comparison between a register and an immediate value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., equal, not equal, less than).\"\n                    },\n                    {\n                        \"name\": \"left\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the value to compare.\"\n                    },\n                    {\n                        \"name\": \"right\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The immediate value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target. Not used in this implementation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfImmediate(Condition cc, Register left, int right,\n                                        Label* target,\n                                        Label::Distance distance) {\n  JumpIf(cc, left, Operand(right), target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"TestAndBranch\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Performs a bitwise AND operation and jumps based on the result.\",\n                \"logic\": \"Performs a bitwise AND between the register value and the mask. Jumps to the target if the result matches the specified condition when compared to zero.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the value to test.\"\n                    },\n                    {\n                        \"name\": \"mask\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The mask to use for the bitwise AND operation.\"\n                    },\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., equal, not equal).\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target. Not used in this implementation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::TestAndBranch(Register value, int mask, Condition cc,\n                                      Label* target, Label::Distance) {\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  __ And(scratch, value, Operand(mask));\n  __ Branch(target, cc, scratch, Operand(zero_reg));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIf\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump based on a comparison between a register and an operand.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., equal, not equal, less than).\"\n                    },\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the left-hand side value to compare.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"const Operand&\",\n                        \"purpose\": \"The right-hand side operand to compare against.  Can be a register or an immediate value.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target. Not used in this implementation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIf(Condition cc, Register lhs, const Operand& rhs,\n                               Label* target, Label::Distance) {\n  __ Branch(target, cc, lhs, Operand(rhs));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfJSAnyIsPrimitive\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump if a JSAny value (heap object) is a primitive.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"heap_object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the JSAny value (which is assumed to be a heap object).\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the value is a primitive.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_STATIC_ROOTS_BOOL\nvoid BaselineAssembler::JumpIfJSAnyIsPrimitive(Register heap_object,\n                                               Label* target,\n                                               Label::Distance distance) {\n  __ AssertNotSmi(heap_object);\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  __ JumpIfJSAnyIsPrimitive(heap_object, scratch, target, distance);\n}\n#endif  // V8_STATIC_ROOTS_BOOL\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfObjectTypeFast\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditionally jumps based on the InstanceType of a HeapObject. Uses a scratch register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the HeapObject.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The InstanceType to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectTypeFast(Condition cc, Register object,\n                                             InstanceType instance_type,\n                                             Label* target,\n                                             Label::Distance distance) {\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  if (cc == eq || cc == ne) {\n    __ JumpIfObjectType(target, cc, object, instance_type, scratch);\n    return;\n  }\n  JumpIfObjectType(cc, object, instance_type, scratch, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfObjectType\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditionally jumps based on the InstanceType of a HeapObject. Uses provided map register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the HeapObject.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The InstanceType to compare against.\"\n                    },\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the map of the object.  This is used as a scratch register in this implementation.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectType(Condition cc, Register object,\n                                         InstanceType instance_type,\n                                         Register map, Label* target,\n                                         Label::Distance) {\n  ScratchRegisterScope temps(this);\n  Register type = temps.AcquireScratch();\n  __ GetObjectType(object, map, type);\n  __ Branch(target, cc, type, Operand(instance_type));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfInstanceType\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump based on the InstanceType of a Map object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the Map object.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The InstanceType to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfInstanceType(Condition cc, Register map,\n                                           InstanceType instance_type,\n                                           Label* target, Label::Distance) {\n  ScratchRegisterScope temps(this);\n  Register type = temps.AcquireScratch();\n  if (v8_flags.debug_code) {\n    __ AssertNotSmi(map);\n    __ GetObjectType(map, type, type);\n    __ Assert(eq, AbortReason::kUnexpectedValue, type, Operand(MAP_TYPE));\n  }\n  __ Ld_hu(type, FieldMemOperand(map, Map::kInstanceTypeOffset));\n  __ Branch(target, cc, type, Operand(instance_type));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump if a register value is equal to a specific Smi value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne).\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the value to check.\"\n                    },\n                    {\n                        \"name\": \"smi\",\n                        \"type\": \"Tagged<Smi>\",\n                        \"purpose\": \"The Smi value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Condition cc, Register value, Tagged<Smi> smi,\n                                  Label* target, Label::Distance) {\n  __ CompareTaggedAndBranch(target, cc, value, Operand(smi));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump if two registers both contain Smi values, based on a given condition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne, lt).\"\n                    },\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the left-hand side Smi value.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the right-hand side Smi value.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Condition cc, Register lhs, Register rhs,\n                                  Label* target, Label::Distance) {\n  __ AssertSmi(lhs);\n  __ AssertSmi(rhs);\n  __ CompareTaggedAndBranch(target, cc, lhs, Operand(rhs));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfTagged\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Conditional jump based on comparing the value in a register with a tagged value loaded from memory.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition to check (e.g., eq, ne, lt).\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the tagged value to compare.\"\n                    },\n                    {\n                        \"name\": \"operand\",\n                        \"type\": \"MemOperand\",\n                        \"purpose\": \"The MemOperand representing the memory location of the other tagged value.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Hint about the distance to the target.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfTagged(Condition cc, Register value,\n                                     MemOperand operand, Label* target,\n                                     Label::Distance) {\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  __ Ld_d(scratch, operand);\n  __ CompareTaggedAndBranch(target, cc, value, Operand(scratch));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"JumpIfTagged\",\n                \"parent\": \"BaselineAssembler\",\n                "
}