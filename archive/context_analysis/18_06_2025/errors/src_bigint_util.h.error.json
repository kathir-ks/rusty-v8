{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/bigint/util.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 44, column 83",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/bigint/util.h\",\n      \"file_name\": \"util.h\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Provides generic helper functions used in BigInt implementation, such as counting leading/trailing zeros, rounding, and checking for power of two.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes standard headers for integer types and type traits.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include <stdint.h>\n\n#include <type_traits>\n    ]]></code>\n  </imports>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes intrinsic functions for bit manipulation on Windows using MSVC.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#ifdef _MSC_VER\n#include <intrin.h>  // For _BitScanReverse.\n#endif\n    ]]></code>\n  </imports>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"RoundUp\",\n        \"parent\": null,\n        \"about\": \"Rounds up an integer to the nearest multiple of another integer.\",\n        \"logic\": \"Uses bitwise operations for efficient rounding up. `(x + y - 1) & -y` calculates the smallest multiple of `y` that is greater than or equal to `x`.\",\n        \"parameters\": [\n          {\n            \"name\": \"x\",\n            \"type\": \"int\",\n            \"purpose\": \"The integer to be rounded up.\"\n          },\n          {\n            \"name\": \"y\",\n            \"type\": \"int\",\n            \"purpose\": \"The multiple to round up to.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"int\",\n          \"description\": \"The rounded-up integer.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\ninline constexpr int RoundUp(int x, int y) { return (x + y - 1) & -y; }\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"CountLeadingZeros\",\n        \"parent\": null,\n        \"about\": \"Counts the number of leading zero bits in a 64-bit unsigned integer.\",\n        \"logic\": \"Uses compiler-specific intrinsics (`__builtin_clzll` for GCC/Clang and `_BitScanReverse64` for MSVC) for optimized counting. Handles the case where the input value is 0.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"T\",\n            \"purpose\": \"The 64-bit unsigned integer to count leading zeros in.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"int\",\n          \"description\": \"The number of leading zero bits.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\ntemplate <typename T>\nconstexpr int CountLeadingZeros(T value)\n  requires(std::is_unsigned<T>::value && sizeof(T) == 8)\n{\n#if __GNUC__ || __clang__\n  return value == 0 ? 64 : __builtin_clzll(value);\n#elif _MSC_VER\n  unsigned long index = 0;  // NOLINT(runtime/int). MSVC insists.\n  return _BitScanReverse64(&index, value) ? 63 - index : 64;\n#else\n#error Unsupported compiler.\n#endif\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"CountLeadingZeros\",\n        \"parent\": null,\n        \"about\": \"Counts the number of leading zero bits in a 32-bit unsigned integer.\",\n        \"logic\": \"Uses compiler-specific intrinsics (`__builtin_clz` for GCC/Clang and `_BitScanReverse` for MSVC) for optimized counting. Handles the case where the input value is 0.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"uint32_t\",\n            \"purpose\": \"The 32-bit unsigned integer to count leading zeros in.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"int\",\n          \"description\": \"The number of leading zero bits.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nconstexpr int CountLeadingZeros(uint32_t value) {\n#if __GNUC__ || __clang__\n  return value == 0 ? 32 : __builtin_clz(value);\n#elif _MSC_VER\n  unsigned long index = 0;  // NOLINT(runtime/int). MSVC insists.\n  return _BitScanReverse(&index, value) ? 31 - index : 32;\n#else\n#error Unsupported compiler.\n#endif\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"CountTrailingZeros\",\n        \"parent\": null,\n        \"about\": \"Counts the number of trailing zero bits in a 32-bit unsigned integer.\",\n        \"logic\": \"Uses compiler-specific intrinsics (`__builtin_ctz` for GCC/Clang and `_BitScanForward` for MSVC) for optimized counting. Handles the case where the input value is 0.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"uint32_t\",\n            \"purpose\": \"The 32-bit unsigned integer to count trailing zeros in.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"int\",\n          \"description\": \"The number of trailing zero bits.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\ninline constexpr int CountTrailingZeros(uint32_t value) {\n#if __GNUC__ || __clang__\n  return value == 0 ? 32 : __builtin_ctz(value);\n#elif _MSC_VER\n  unsigned long index = 0;  // NOLINT(runtime/int).\n  return _BitScanForward(&index, value) ? index : 32;\n#else\n#error Unsupported compiler.\n#endif\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"BitLength\",\n        \"parent\": null,\n        \"about\": \"Calculates the number of bits required to represent an integer.\",\n        \"logic\": \"Calculates the bit length by subtracting the number of leading zeros from 32.  It first casts the signed int to an unsigned int to avoid sign extension issues during the leading zero count.\",\n        \"parameters\": [\n          {\n            \"name\": \"n\",\n            \"type\": \"int\",\n            \"purpose\": \"The integer to calculate the bit length of.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"int\",\n          \"description\": \"The bit length of the integer.\"\n        },\n        \"dependencies\": [\n          \"CountLeadingZeros\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\ninline constexpr int BitLength(int n) {\n  return 32 - CountLeadingZeros(static_cast<uint32_t>(n));\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"IsPowerOfTwo\",\n        \"parent\": null,\n        \"about\": \"Checks if an integer is a power of two.\",\n        \"logic\": \"Uses a bitwise AND operation to check if the number is a power of two.  A power of two has only one bit set to 1. If `value & (value - 1)` is 0, then `value` is a power of two (or zero).  The function also ensures that the value is greater than zero.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"int\",\n            \"purpose\": \"The integer to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the integer is a power of two, false otherwise.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\ninline constexpr bool IsPowerOfTwo(int value) {\n  return value > 0 && (value & (value - 1)) == 0;\n}\n    ]]></code>\n  </func>\n</file>\n```"
}