{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/roots/roots-inl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 53, column 30",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/roots/roots-inl.h\",\n            \"file_name\": \"roots-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Inline implementations for accessing roots in the V8 heap, providing efficient access to commonly used objects and values.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for pointer compression, isolate management, handle management, heap metadata, read-only heap access, object definitions, root definitions, and WebAssembly support.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/common/ptr-compr-inl.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/execution/local-isolate.h\"\n#include \"src/handles/handles.h\"\n#include \"src/heap/page-metadata-inl.h\"\n#include \"src/heap/read-only-heap-inl.h\"\n#include \"src/objects/api-callbacks.h\"\n#include \"src/objects/cell.h\"\n#include \"src/objects/descriptor-array.h\"\n#include \"src/objects/feedback-vector.h\"\n#include \"src/objects/heap-number.h\"\n#include \"src/objects/hole.h\"\n#include \"src/objects/literal-objects.h\"\n#include \"src/objects/map.h\"\n#include \"src/objects/oddball.h\"\n#include \"src/objects/property-array.h\"\n#include \"src/objects/property-cell.h\"\n#include \"src/objects/scope-info.h\"\n#include \"src/objects/slots.h\"\n#include \"src/objects/string.h\"\n#include \"src/objects/swiss-name-dictionary.h\"\n#include \"src/objects/tagged.h\"\n#include \"src/roots/roots.h\"\n#include \"src/roots/static-roots.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-objects.h\"\n#endif\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<\",\n            \"about\": \"Defines a less-than operator for RootIndex enums.\",\n            \"logic\": \"Compares two RootIndex enum values by casting them to their underlying integer type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The left-hand side RootIndex.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The right-hand side RootIndex.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if lhs is less than rhs, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE constexpr bool operator<(RootIndex lhs, RootIndex rhs) {\n  using type = typename std::underlying_type<RootIndex>::type;\n  return static_cast<type>(lhs) < static_cast<type>(rhs);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator++\",\n            \"about\": \"Defines a pre-increment operator for RootIndex enums.\",\n            \"logic\": \"Increments a RootIndex enum value by casting it to its underlying integer type, adding 1, and casting back to RootIndex.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex&\",\n                    \"purpose\": \"The RootIndex to increment.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"RootIndex\",\n                \"description\": \"The incremented RootIndex.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE RootIndex operator++(RootIndex& index) {\n  using type = typename std::underlying_type<RootIndex>::type;\n  index = static_cast<RootIndex>(static_cast<type>(index) + 1);\n  return index;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsRootHandleLocation\",\n            \"parent\": \"RootsTable\",\n            \"about\": \"Checks if a given address is a valid root handle location within the RootsTable.\",\n            \"logic\": \"Determines if the provided handle_location falls within the address range of the roots_ array.  It calculates the RootIndex by subtracting the starting address of the roots_ array from the handle_location if the location is within the valid range.\",\n            \"parameters\": [\n                {\n                    \"name\": \"handle_location\",\n                    \"type\": \"Address*\",\n                    \"purpose\": \"The address to check if it's a root handle location.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex*\",\n                    \"purpose\": \"Output parameter to store the RootIndex if the address is a root handle location.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the address is a root handle location, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool RootsTable::IsRootHandleLocation(Address* handle_location,\n                                      RootIndex* index) const {\n  FullObjectSlot location(handle_location);\n  FullObjectSlot first_root(&roots_[0]);\n  FullObjectSlot last_root(&roots_[kEntriesCount]);\n  if (location >= last_root) return false;\n  if (location < first_root) return false;\n  *index = static_cast<RootIndex>(location - first_root);\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsRootHandle\",\n            \"parent\": \"RootsTable\",\n            \"about\": \"Checks if a given handle is a root handle within the RootsTable.\",\n            \"logic\": \"Calls IsRootHandleLocation using the address of the provided handle to determine if it represents a root.\",\n            \"parameters\": [\n                {\n                    \"name\": \"handle\",\n                    \"type\": \"IndirectHandle<T>\",\n                    \"purpose\": \"The handle to check if it's a root handle.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex*\",\n                    \"purpose\": \"Output parameter to store the RootIndex if the handle is a root handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the handle is a root handle, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"IsRootHandleLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nbool RootsTable::IsRootHandle(IndirectHandle<T> handle,\n                              RootIndex* index) const {\n  // This can't use handle.location() because it is called from places\n  // where handle dereferencing is disallowed. Comparing the handle's\n  // location against the root handle list is safe though.\n  Address* handle_location = reinterpret_cast<Address*>(handle.address());\n  return IsRootHandleLocation(handle_location, index);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"ROOT_ACCESSOR\",\n            \"about\": \"Defines accessor methods for root handles in the RootsTable class. This macro is used to generate getter methods for each root defined in ROOT_LIST.\",\n            \"logic\": \"The macro takes a Type, a name, and a CamelName as input.  It generates a method named 'name' that returns an IndirectHandle<Type> pointing to the root handle location associated with the RootIndex::kCamelName.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Type\",\n                    \"type\": \"typename\",\n                    \"purpose\": \"The type of the root handle.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"string\",\n                    \"purpose\": \"The name of the accessor method.\"\n                },\n                {\n                    \"name\": \"CamelName\",\n                    \"type\": \"string\",\n                    \"purpose\": \"The CamelCase version of the name, used for the RootIndex enum.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"IndirectHandle<Type>\",\n                \"description\": \"Returns an IndirectHandle of the specified type.\"\n            },\n            \"dependencies\": [\n                \"handle_at\",\n                \"ROOT_LIST\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define ROOT_ACCESSOR(Type, name, CamelName)            \\\n  IndirectHandle<Type> RootsTable::name() {             \\\n    return IndirectHandle<Type>(                        \\\n        handle_at(RootIndex::k##CamelName).location()); \\\n  }\nROOT_LIST(ROOT_ACCESSOR)\n#undef ROOT_ACCESSOR\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"handle_at\",\n            \"parent\": \"RootsTable\",\n            \"about\": \"Returns an IndirectHandle to the object at the given RootIndex in the RootsTable.\",\n            \"logic\": \"Creates an IndirectHandle for the Object stored at the specified index in the roots_ array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The index of the root to access.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"IndirectHandle<Object>\",\n                \"description\": \"An IndirectHandle to the object at the given RootIndex.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nIndirectHandle<Object> RootsTable::handle_at(RootIndex index) {\n  return IndirectHandle<Object>(&(*this)[index]);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetReadOnlyRoots\",\n            \"about\": \"Retrieves the ReadOnlyRoots object associated with the current isolate.\",\n            \"logic\": \"Obtains the ReadOnlyHeap from the current IsolateGroup and returns a ReadOnlyRoots object initialized with the read-only roots from the heap.  Includes a DCHECK to ensure the shared read-only heap is initialized.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"ReadOnlyRoots\",\n                \"description\": \"The ReadOnlyRoots object for the current isolate.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReadOnlyRoots GetReadOnlyRoots() {\n  ReadOnlyHeap* shared_ro_heap =\n      IsolateGroup::current()->shared_read_only_heap();\n  // If this check fails in code that runs during initialization use\n  // EarlyGetReadOnlyRoots instead.\n  DCHECK(shared_ro_heap && shared_ro_heap->roots_init_complete());\n  return ReadOnlyRoots(shared_ro_heap->read_only_roots_);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"ReadOnlyRoots\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Constructor for ReadOnlyRoots, initializing from a Heap pointer.\",\n            \"logic\": \"Initializes the ReadOnlyRoots object by extracting the Isolate from the Heap and calling the Isolate-based constructor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"heap\",\n                    \"type\": \"Heap*\",\n                    \"purpose\": \"The heap to extract the isolate from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReadOnlyRoots::ReadOnlyRoots(Heap* heap)\n    : ReadOnlyRoots(Isolate::FromHeap(heap)) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"ReadOnlyRoots\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Constructor for ReadOnlyRoots, initializing from an Isolate pointer.\",\n            \"logic\": \"Initializes the ReadOnlyRoots object by storing the address of the read-only roots from the provided Isolate's roots table.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"const Isolate*\",\n                    \"purpose\": \"The isolate to retrieve the read-only roots from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReadOnlyRoots::ReadOnlyRoots(const Isolate* isolate)\n    : read_only_roots_(reinterpret_cast<Address*>(\n          isolate->roots_table().read_only_roots_begin().address())) {}\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"ReadOnlyRoots\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Constructor for ReadOnlyRoots, initializing from a LocalIsolate pointer.\",\n            \"logic\": \"Initializes the ReadOnlyRoots object by retrieving the factory from the LocalIsolate and calling the factory-based ReadOnlyRoots constructor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"LocalIsolate*\",\n                    \"purpose\": \"The local isolate to retrieve the read-only roots from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nReadOnlyRoots::ReadOnlyRoots(LocalIsolate* isolate)\n    : ReadOnlyRoots(isolate->factory()->read_only_roots()) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"ROOT_ACCESSOR\",\n            \"about\": \"Defines accessor methods for read-only root objects in the ReadOnlyRoots class. This macro is used to generate getter methods for each root defined in READ_ONLY_ROOT_LIST.\",\n            \"logic\": \"The macro takes a Type, a name, and a CamelName as input.  It generates a method named 'name' that returns a Tagged<Type> by calling the unchecked_name() method. It also generates a method named 'unchecked_name' that performs an unchecked cast from the object at the RootIndex::kCamelName.\",\n            \"parameters\": [\n                {\n                    \"name\": \"Type\",\n                    \"type\": \"typename\",\n                    \"purpose\": \"The type of the root object.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"string\",\n                    \"purpose\": \"The name of the accessor method.\"\n                },\n                {\n                    \"name\": \"CamelName\",\n                    \"type\": \"string\",\n                    \"purpose\": \"The CamelCase version of the name, used for the RootIndex enum.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Type>\",\n                \"description\": \"Returns a Tagged object of the specified type.\"\n            },\n            \"dependencies\": [\n                \"object_at\",\n                \"READ_ONLY_ROOT_LIST\",\n                \"UncheckedCast\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define ROOT_ACCESSOR(Type, name, CamelName)                        \\\n  Tagged<Type> ReadOnlyRoots::name() const {                        \\\n    return unchecked_##name();                                      \\\n  }                                                                 \\\n  Tagged<Type> ReadOnlyRoots::unchecked_##name() const {            \\\n    return UncheckedCast<Type>(object_at(RootIndex::k##CamelName)); \\\n  }\nREAD_ONLY_ROOT_LIST(ROOT_ACCESSOR)\n#undef ROOT_ACCESSOR\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"boolean_value\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Returns the Tagged<Boolean> representation of a boolean value.\",\n            \"logic\": \"Returns either the true_value or false_value root object based on the input boolean.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"The boolean value to represent.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Boolean>\",\n                \"description\": \"The Tagged<Boolean> representation of the input value.\"\n            },\n            \"dependencies\": [\n                \"true_value\",\n                \"false_value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTagged<Boolean> ReadOnlyRoots::boolean_value(bool value) const {\n  return value ? Tagged<Boolean>(true_value()) : Tagged<Boolean>(false_value());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"first_name_for_protector\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Returns the address of the first name used for protector invalidation.\",\n            \"logic\": \"Accesses the address at the kFirstNameForProtector RootIndex.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Address\",\n                \"description\": \"The address of the first name for protector invalidation.\"\n            },\n            \"dependencies\": [\n                \"address_at\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nAddress ReadOnlyRoots::first_name_for_protector() const {\n  return address_at(RootIndex::kFirstNameForProtector);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"last_name_for_protector\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Returns the address of the last name used for protector invalidation.\",\n            \"logic\": \"Accesses the address at the kLastNameForProtector RootIndex.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Address\",\n                \"description\": \"The address of the last name for protector invalidation.\"\n            },\n            \"dependencies\": [\n                \"address_at\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nAddress ReadOnlyRoots::last_name_for_protector() const {\n  return address_at(RootIndex::kLastNameForProtector);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsNameForProtector\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Checks if a HeapObject is a name that can cause protector invalidation.\",\n            \"logic\": \"Checks if the object's address falls within the range defined by first_name_for_protector and last_name_for_protector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Tagged<HeapObject>\",\n                    \"purpose\": \"The object to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the object is a name for protector invalidation, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"first_name_for_protector\",\n                \"last_name_for_protector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool ReadOnlyRoots::IsNameForProtector(Tagged<HeapObject> object) const {\n  return base::IsInRange(object.ptr(), first_name_for_protector(),\n                         last_name_for_protector());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VerifyNameForProtectorsPages\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Verifies that the names used for protector invalidation reside on the same memory page.\",\n            \"logic\": \"Asserts that the PageMetadata objects returned by FromAddress for first_name_for_protector and last_name_for_protector are the same. This ensures that a fast range check can be used for protector invalidation.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"first_name_for_protector\",\n                \"last_name_for_protector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ReadOnlyRoots::VerifyNameForProtectorsPages() const {\n  // The symbols and strings that can cause protector invalidation should\n  // reside on the same page so we can do a fast range check.\n  CHECK_EQ(PageMetadata::FromAddress(first_name_for_protector()),\n           PageMetadata::FromAddress(last_name_for_protector()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"object_at\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Returns the Tagged<Object> at the given RootIndex.\",\n            \"logic\": \"Retrieves the address at the given root index and creates a Tagged<Object> from it.\",\n            \"parameters\": [\n                {\n                    \"name\": \"root_index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The index of the root to retrieve.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Object>\",\n                \"description\": \"The Tagged<Object> at the given RootIndex.\"\n            },\n            \"dependencies\": [\n                \"address_at\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTagged<Object> ReadOnlyRoots::object_at(RootIndex root_index) const {\n  return Tagged<Object>(address_at(root_index));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"address_at\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Returns the address at the given RootIndex.\",\n            \"logic\": \"If V8_STATIC_ROOTS_BOOL is defined, it decompresses the tagged pointer using V8HeapCompressionScheme. Otherwise, it accesses the address directly from the read_only_roots_ array. Includes a DCHECK to ensure the index is within bounds and an IMPLIES check for kFreeSpaceMap during bootstrapping.\",\n            \"parameters\": [\n                {\n                    \"name\": \"root_index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The index of the root to retrieve.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Address\",\n                \"description\": \"The address at the given RootIndex.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nAddress ReadOnlyRoots::address_at(RootIndex root_index) const {\n#if V8_STATIC_ROOTS_BOOL\n  return V8HeapCompressionScheme::DecompressTagged(\n      V8HeapCompressionScheme::base(),\n      StaticReadOnlyRootsPointerTable[static_cast<int>(root_index)]);\n#else\n  size_t index = static_cast<size_t>(root_index);\n  DCHECK_LT(index, kEntriesCount);\n  // Filler objects must be created before the free space map is initialized.\n  // Bootstrapping is able to handle kNullAddress being returned here.\n  DCHECK_IMPLIES(read_only_roots_[index] == kNullAddress,\n                 root_index == RootIndex::kFreeSpaceMap);\n  return read_only_roots_[index];\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"is_initialized\",\n            \"parent\": \"ReadOnlyRoots\",\n            \"about\": \"Checks if the root at the given RootIndex is initialized.\",\n            \"logic\": \"Checks if the address at the given index in the read_only_roots_ array is not equal to kNullAddress.\",\n            \"parameters\": [\n                {\n                    \"name\": \"root_index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The index of the root to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the root is initialized, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool ReadOnlyRoots::is_initialized(RootIndex root_index) const {\n  size_t index = static_cast<size_t>(root_index);\n  DCHECK_LT(index, kEntriesCount);\n  return read_only_roots_[index] != kNullAddress;\n}\n        ]]></code>\n    </func>\n</file>\n```"
}