{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/memory-lowering.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 34, column 58",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/memory-lowering.h\",\n        \"file_name\": \"memory-lowering.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the MemoryLowering class, which lowers simplified memory access and allocation nodes to machine operators.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides graph manipulation utilities for the compiler.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/graph-assembler.h\"\n#include \"src/compiler/graph-reducer.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MemoryLowering\",\n            \"extends\": \"Reducer\",\n            \"about\": \"Lowers simplified memory access and allocation nodes to machine operators.\",\n            \"attributes\": [\n                {\n                    \"name\": \"allocate_operator_\",\n                    \"type\": \"SetOncePointer<const Operator>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the allocate operator.\"\n                },\n                {\n                    \"name\": \"wasm_instance_node_\",\n                    \"type\": \"SetOncePointer<Node>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the WASM instance node.\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Points to the Isolate object.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Points to the Zone object for memory management.\"\n                },\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"TFGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Points to the TurboFan graph.\"\n                },\n                {\n                    \"name\": \"common_\",\n                    \"type\": \"CommonOperatorBuilder*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides common operators.\"\n                },\n                {\n                    \"name\": \"machine_\",\n                    \"type\": \"MachineOperatorBuilder*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides machine-specific operators.\"\n                },\n                {\n                    \"name\": \"graph_assembler_\",\n                    \"type\": \"JSGraphAssembler*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides utilities for building the graph.\"\n                },\n                {\n                    \"name\": \"is_wasm_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the compilation is for WASM.\"\n                },\n                {\n                    \"name\": \"allocation_folding_\",\n                    \"type\": \"AllocationFolding\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether allocation folding is enabled.\"\n                },\n                {\n                    \"name\": \"write_barrier_assert_failed_\",\n                    \"type\": \"WriteBarrierAssertFailedCallback\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Callback function for write barrier assertion failures.\"\n                },\n                {\n                    \"name\": \"function_debug_name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The debug name of the function being compiled.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Reducer\",\n                \"JSGraph\",\n                \"Zone\",\n                \"CommonOperatorBuilder\",\n                \"MachineOperatorBuilder\",\n                \"Node\",\n                \"Operator\",\n                \"AllocationState\",\n                \"AllocationGroup\",\n                \"JSGraphAssembler\",\n                \"ElementAccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass MemoryLowering final : public Reducer {\n public:\n  enum class AllocationFolding { kDoAllocationFolding, kDontAllocationFolding };\n  class AllocationGroup;\n\n  // An allocation state is propagated on the effect paths through the graph.\n  class AllocationState final : public ZoneObject {\n   public:\n    AllocationState(const AllocationState&) = delete;\n    AllocationState& operator=(const AllocationState&) = delete;\n\n    static AllocationState const* Empty(Zone* zone) {\n      return zone->New<AllocationState>();\n    }\n    static AllocationState const* Closed(AllocationGroup* group, Node* effect,\n                                         Zone* zone) {\n      return zone->New<AllocationState>(group, effect);\n    }\n    static AllocationState const* Open(AllocationGroup* group, intptr_t size,\n                                       Node* top, Node* effect, Zone* zone) {\n      return zone->New<AllocationState>(group, size, top, effect);\n    }\n\n    bool IsYoungGenerationAllocation() const;\n\n    AllocationGroup* group() const { return group_; }\n    Node* top() const { return top_; }\n    Node* effect() const { return effect_; }\n    intptr_t size() const { return size_; }\n\n   private:\n    friend Zone;\n\n    AllocationState();\n    explicit AllocationState(AllocationGroup* group, Node* effect);\n    AllocationState(AllocationGroup* group, intptr_t size, Node* top,\n                    Node* effect);\n\n    AllocationGroup* const group_;\n    // The upper bound of the combined allocated object size on the current path\n    // (max int if allocation folding is impossible on this path).\n    intptr_t const size_;\n    Node* const top_;\n    Node* const effect_;\n  };\n\n  using WriteBarrierAssertFailedCallback = std::function<void(\n      Node* node, Node* object, const char* name, Zone* temp_zone)>;\n\n  MemoryLowering(\n      JSGraph* jsgraph, Zone* zone, JSGraphAssembler* graph_assembler,\n      bool is_wasm,\n      AllocationFolding allocation_folding =\n          AllocationFolding::kDontAllocationFolding,\n      WriteBarrierAssertFailedCallback callback = [](Node*, Node*, const char*,\n                                                     Zone*) { UNREACHABLE(); },\n      const char* function_debug_name = nullptr);\n\n  const char* reducer_name() const override { return \"MemoryReducer\"; }\n\n  // Perform memory lowering reduction on the given Node.\n  Reduction Reduce(Node* node) override;\n\n  // Specific reducers for each optype to enable keeping track of\n  // AllocationState by the MemoryOptimizer.\n  Reduction ReduceAllocateRaw(Node* node, AllocationType allocation_type,\n                              AllocationState const** state);\n  Reduction ReduceLoadFromObject(Node* node);\n  Reduction ReduceLoadElement(Node* node);\n  Reduction ReduceLoadField(Node* node);\n  Reduction ReduceStoreToObject(Node* node,\n                                AllocationState const* state = nullptr);\n  Reduction ReduceStoreElement(Node* node,\n                               AllocationState const* state = nullptr);\n  Reduction ReduceStoreField(Node* node,\n                             AllocationState const* state = nullptr);\n  Reduction ReduceStore(Node* node, AllocationState const* state = nullptr);\n\n private:\n  Reduction ReduceAllocateRaw(Node* node);\n  WriteBarrierKind ComputeWriteBarrierKind(Node* node, Node* object,\n                                           Node* value,\n                                           AllocationState const* state,\n                                           WriteBarrierKind);\n  Reduction ReduceLoadExternalPointerField(Node* node);\n  Reduction ReduceLoadBoundedSize(Node* node);\n  Reduction ReduceLoadMap(Node* node);\n  Node* ComputeIndex(ElementAccess const& access, Node* node);\n  void EnsureAllocateOperator();\n  Node* GetWasmInstanceNode();\n\n  // Align the value to kObjectAlignment8GbHeap if V8_COMPRESS_POINTERS_8GB is\n  // defined.\n  Node* AlignToAllocationAlignment(Node* address);\n\n  TFGraph* graph() const { return graph_; }\n  Isolate* isolate() const { return isolate_; }\n  Zone* zone() const { return zone_; }\n  inline Zone* graph_zone() const;\n  CommonOperatorBuilder* common() const { return common_; }\n  MachineOperatorBuilder* machine() const { return machine_; }\n  JSGraphAssembler* gasm() const { return graph_assembler_; }\n\n  SetOncePointer<const Operator> allocate_operator_;\n  SetOncePointer<Node> wasm_instance_node_;\n  Isolate* isolate_;\n  Zone* zone_;\n  TFGraph* graph_;\n  CommonOperatorBuilder* common_;\n  MachineOperatorBuilder* machine_;\n  JSGraphAssembler* graph_assembler_;\n  bool is_wasm_;\n  AllocationFolding allocation_folding_;\n  WriteBarrierAssertFailedCallback write_barrier_assert_failed_;\n  const char* function_debug_name_;\n\n  DISALLOW_IMPLICIT_CONSTRUCTORS(MemoryLowering);\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AllocationState\",\n            \"about\": \"Represents the allocation state, propagated on the effect paths.\",\n            \"attributes\": [\n                {\n                    \"name\": \"group_\",\n                    \"type\": \"AllocationGroup* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The allocation group.\"\n                },\n                {\n                    \"name\": \"size_\",\n                    \"type\": \"intptr_t const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Upper bound of combined allocated object size on the current path.\"\n                },\n                {\n                    \"name\": \"top_\",\n                    \"type\": \"Node* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The top node of the allocation.\"\n                },\n                {\n                    \"name\": \"effect_\",\n                    \"type\": \"Node* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The effect node.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"AllocationGroup\",\n                \"Node\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class AllocationState final : public ZoneObject {\n   public:\n    AllocationState(const AllocationState&) = delete;\n    AllocationState& operator=(const AllocationState&) = delete;\n\n    static AllocationState const* Empty(Zone* zone) {\n      return zone->New<AllocationState>();\n    }\n    static AllocationState const* Closed(AllocationGroup* group, Node* effect,\n                                         Zone* zone) {\n      return zone->New<AllocationState>(group, effect);\n    }\n    static AllocationState const* Open(AllocationGroup* group, intptr_t size,\n                                       Node* top, Node* effect, Zone* zone) {\n      return zone->New<AllocationState>(group, size, top, effect);\n    }\n\n    bool IsYoungGenerationAllocation() const;\n\n    AllocationGroup* group() const { return group_; }\n    Node* top() const { return top_; }\n    Node* effect() const { return effect_; }\n    intptr_t size() const { return size_; }\n\n   private:\n    friend Zone;\n\n    AllocationState();\n    explicit AllocationState(AllocationGroup* group, Node* effect);\n    AllocationState(AllocationGroup* group, intptr_t size, Node* top,\n                    Node* effect);\n\n    AllocationGroup* const group_;\n    // The upper bound of the combined allocated object size on the current path\n    // (max int if allocation folding is impossible on this path).\n    intptr_t const size_;\n    Node* const top_;\n    Node* const effect_;\n  };\n        ]]></code>\n    </class>\n</file>\n```"
}