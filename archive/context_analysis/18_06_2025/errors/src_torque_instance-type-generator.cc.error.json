{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/instance-type-generator.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/instance-type-generator.cc\",\n        \"file_name\": \"instance-type-generator.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Generates instance types for Torque-defined classes in V8\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for optional types, Torque implementation visitor, and standard template library\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/torque/implementation-visitor.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"InstanceTypeTree\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents a node in the instance type inheritance tree, storing instance type information for a class and its subclasses.\",\n            \"attributes\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"const ClassType*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The ClassType associated with this node.\"\n                },\n                {\n                    \"name\": \"children\",\n                    \"type\": \"std::vector<std::unique_ptr<InstanceTypeTree>>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Child nodes representing subclasses.\"\n                },\n                {\n                    \"name\": \"start\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Start of the instance type range for this class and its subclasses.\"\n                },\n                {\n                    \"name\": \"end\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"End of the instance type range for this class and its subclasses.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The assigned instance type value for this class.\"\n                },\n                {\n                    \"name\": \"num_values\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The number of instance type values used by this class and its subclasses.\"\n                },\n                {\n                    \"name\": \"num_own_values\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The number of instance type values used exclusively by this class (excluding subclasses).\"\n                }\n            ],\n            \"dependencies\": [\n                \"ClassType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct InstanceTypeTree {\n  explicit InstanceTypeTree(const ClassType* type)\n      : type(type),\n        start(INT_MAX),\n        end(INT_MIN),\n        value(-1),\n        num_values(0),\n        num_own_values(0) {}\n  const ClassType* type;\n  std::vector<std::unique_ptr<InstanceTypeTree>> children;\n  int start;  // Start of range for this and subclasses, or INT_MAX.\n  int end;    // End of range for this and subclasses, or INT_MIN.\n  int value;  // Assigned value for this class itself, or -1 when unassigned.\n  int num_values;      // Number of values assigned for this and subclasses.\n  int num_own_values;  // How many values this needs (not including subclasses).\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"BuildInstanceTypeTree\",\n            \"parent\": null,\n            \"about\": \"Builds a tree representation of the class inheritance hierarchy for instance type assignment.\",\n            \"logic\": \"Iterates through all declarables, identifying ClassType aliases. It creates InstanceTypeTree nodes for each class and organizes them into a tree structure based on inheritance relationships.  The root of the tree represents the base class.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::unique_ptr<InstanceTypeTree>\",\n                \"description\": \"A unique pointer to the root of the InstanceTypeTree, or nullptr if no class types are found.\"\n            },\n            \"dependencies\": [\n                \"ClassType\",\n                \"TypeAlias\",\n                \"GlobalContext\",\n                \"InstanceTypeTree\",\n                \"Error\",\n                \"Type\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<InstanceTypeTree> BuildInstanceTypeTree() {\n  // First, build InstanceTypeTree instances for every class but don't try to\n  // attach them to their subclasses yet.\n  std::unordered_map<const ClassType*, InstanceTypeTree*> map_by_type;\n  std::vector<std::unique_ptr<InstanceTypeTree>> unparented_types;\n  for (auto& p : GlobalContext::AllDeclarables()) {\n    if (const TypeAlias* alias = TypeAlias::DynamicCast(p.get())) {\n      const Type* type = alias->type();\n      const ClassType* class_type = ClassType::DynamicCast(type);\n      if (class_type == nullptr) {\n        continue;\n      }\n      auto& map_slot = map_by_type[class_type];\n      if (map_slot != nullptr) {\n        continue;  // We already encountered this type.\n      }\n      std::unique_ptr<InstanceTypeTree> type_tree =\n          std::make_unique<InstanceTypeTree>(class_type);\n      map_slot = type_tree.get();\n      unparented_types.push_back(std::move(type_tree));\n    }\n  }\n\n  // Second, assemble them all into a tree following the inheritance hierarchy.\n  std::unique_ptr<InstanceTypeTree> root;\n  for (auto& type_tree : unparented_types) {\n    const ClassType* parent = type_tree->type->GetSuperClass();\n    if (parent == nullptr) {\n      if (root != nullptr)\n        Error(\"Expected only one root class type. Found: \", root->type->name(),\n              \" and \", type_tree->type->name())\n            .Position(type_tree->type->GetPosition());\n      root = std::move(type_tree);\n    } else {\n      map_by_type[parent]->children.push_back(std::move(type_tree));\n    }\n  }\n  return root;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PropagateInstanceTypeConstraints\",\n            \"parent\": null,\n            \"about\": \"Propagates instance type constraints from child nodes to parent nodes in the InstanceTypeTree.\",\n            \"logic\": \"Recursively traverses the InstanceTypeTree, propagating the `start`, `end`, and `num_values` from children to their parents. It also handles specific constraints defined in `InstanceTypeConstraints` for each class, such as fixed values or number of flag bits.\",\n            \"parameters\": [\n                {\n                    \"name\": \"root\",\n                    \"type\": \"InstanceTypeTree*\",\n                    \"purpose\": \"The root of the InstanceTypeTree to process.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstanceTypeTree\",\n                \"ClassType\",\n                \"InstanceTypeConstraints\",\n                \"Error\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid PropagateInstanceTypeConstraints(InstanceTypeTree* root) {\n  for (auto& child : root->children) {\n    PropagateInstanceTypeConstraints(child.get());\n    if (child->start < root->start) root->start = child->start;\n    if (child->end > root->end) root->end = child->end;\n    root->num_values += child->num_values;\n  }\n  const InstanceTypeConstraints& constraints =\n      root->type->GetInstanceTypeConstraints();\n  if (!root->type->IsAbstract() && !root->type->HasSameInstanceTypeAsParent()) {\n    root->num_own_values = 1;\n  }\n  root->num_values += root->num_own_values;\n  if (constraints.num_flags_bits != -1) {\n    // Children won't get any types assigned; must be done manually in C++.\n    root->children.clear();\n    root->num_values = 1 << constraints.num_flags_bits;\n    root->num_own_values = root->num_values;\n    root->start = 0;\n    root->end = root->num_values - 1;\n  }\n  if (constraints.value != -1) {\n    if (root->num_own_values != 1) {\n      Error(\"Instance type value requested for abstract class \",\n            root->type->name())\n          .Position(root->type->GetPosition());\n    }\n    root->value = constraints.value;\n    if (constraints.value < root->start) root->start = constraints.value;\n    if (constraints.value > root->end) root->end = constraints.value;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SelectOwnValues\",\n            \"parent\": null,\n            \"about\": \"Assigns a specific instance type value to a class, ensuring it's within the allowed range.\",\n            \"logic\": \"Assigns the `start_value` to the `value` field of the `root` node if the value is unassigned (-1) or if the assigned value is less than the start value.  Returns the next available value after assigning the current node its required number of values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"root\",\n                    \"type\": \"InstanceTypeTree*\",\n                    \"purpose\": \"The InstanceTypeTree node to assign a value to.\"\n                },\n                {\n                    \"name\": \"start_value\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The starting value to assign.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The next available instance type value.\"\n            },\n            \"dependencies\": [\n                \"InstanceTypeTree\",\n                \"ClassType\",\n                \"Error\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint SelectOwnValues(InstanceTypeTree* root, int start_value) {\n  if (root->value == -1) {\n    root->value = start_value;\n  } else if (root->value < start_value) {\n    Error(\"Failed to assign instance type \", root->value, \" to \",\n          root->type->name())\n        .Position(root->type->GetPosition());\n  }\n  return root->value + root->num_own_values;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"CompareUnconstrainedTypes\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A comparator used to sort InstanceTypeTree nodes without specific value constraints.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"InstanceTypeTree\",\n                \"ClassType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct CompareUnconstrainedTypes {\n  constexpr bool operator()(const InstanceTypeTree* a,\n                            const InstanceTypeTree* b) const {\n    return (a->num_values > b->num_values)\n               ? true\n               : (a->num_values < b->num_values)\n                     ? false\n                     : std::less<std::string>()(a->type->name(),\n                                                b->type->name());\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SolveInstanceTypeConstraints\",\n            \"parent\": null,\n            \"about\": \"Assigns concrete instance type values and sorts children, solving the instance type constraints.\",\n            \"logic\": \"Recursively traverses the InstanceTypeTree, assigning instance type values to each class based on its constraints and inheritance hierarchy. Children are sorted into constrained and unconstrained groups, and values are assigned in a specific order to satisfy constraints. Assigns values to nodes in the tree in a way that respects the requested lowest and highest instance types, along with explicit start/end ranges.\",\n            \"parameters\": [\n                {\n                    \"name\": \"root\",\n                    \"type\": \"std::unique_ptr<InstanceTypeTree>\",\n                    \"purpose\": \"The root of the InstanceTypeTree to process.\"\n                },\n                {\n                    \"name\": \"start_value\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The starting value for instance type assignment.\"\n                },\n                {\n                    \"name\": \"destination\",\n                    \"type\": \"std::vector<std::unique_ptr<InstanceTypeTree>>*\",\n                    \"purpose\": \"A vector to store the processed InstanceTypeTree nodes.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The first unassigned instance type value after processing the tree.\"\n            },\n            \"dependencies\": [\n                \"InstanceTypeTree\",\n                \"ClassType\",\n                \"Error\",\n                \"CompareUnconstrainedTypes\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint SolveInstanceTypeConstraints(\n    std::unique_ptr<InstanceTypeTree> root, int start_value,\n    std::vector<std::unique_ptr<InstanceTypeTree>>* destination) {\n  if (root->start < start_value) {\n    Error(\"Failed to assign instance type \", root->start, \" to \",\n          root->type->name())\n        .Position(root->type->GetPosition());\n  }\n\n  // First, separate the children into four groups:\n  // - The one child that must go first, if it exists;\n  // - Children with specific value requirements (\"constrained\");\n  // - Children without specific value requirements (\"unconstrained\");\n  // - The one child that must go last, if it exists.\n  std::unique_ptr<InstanceTypeTree> lowest_child;\n  std::unique_ptr<InstanceTypeTree> highest_child;\n  std::multimap<int, std::unique_ptr<InstanceTypeTree>>\n      constrained_children_by_start;\n  // Using std::map because you can't std::move out of a std::set until C++17.\n  std::map<InstanceTypeTree*, std::unique_ptr<InstanceTypeTree>,\n           CompareUnconstrainedTypes>\n      unconstrained_children_by_size;\n  for (auto& child : root->children) {\n    if (child->type->IsHighestInstanceTypeWithinParent()) {\n      if (highest_child) {\n        Error(\"Two classes requested to be the highest instance type: \",\n              highest_child->type->name(), \" and \", child->type->name(),\n              \" within range for parent class \", root->type->name())\n            .Position(child->type->GetPosition());\n      }\n      if (child->type->IsLowestInstanceTypeWithinParent()) {\n        Error(\n            \"Class requested to be both highest and lowest instance type \"\n            \"within its parent range: \",\n            child->type->name())\n            .Position(child->type->GetPosition());\n      }\n      highest_child = std::move(child);\n    } else if (child->type->IsLowestInstanceTypeWithinParent()) {\n      if (lowest_child) {\n        Error(\"Two classes requested to be the lowest instance type: \",\n              lowest_child->type->name(), \" and \", child->type->name(),\n              \" within range for parent class \", root->type->name())\n            .Position(child->type->GetPosition());\n      }\n      lowest_child = std::move(child);\n    } else if (child->start > child->end) {\n      unconstrained_children_by_size.insert(\n          std::make_pair(child.get(), std::move(child)));\n    } else {\n      constrained_children_by_start.insert(\n          std::make_pair(child->start, std::move(child)));\n    }\n  }\n  root->children.clear();\n\n  bool own_type_pending = root->num_own_values > 0;\n\n  // Second, iterate and place the children in ascending order.\n  if (lowest_child != nullptr) {\n    start_value = SolveInstanceTypeConstraints(std::move(lowest_child),\n                                               start_value, &root->children);\n  }\n  for (auto& constrained_child_pair : constrained_children_by_start) {\n    // Select the next constrained child type in ascending order.\n    std::unique_ptr<InstanceTypeTree> constrained_child =\n        std::move(constrained_child_pair.second);\n\n    // Try to place the root type before the constrained child type if it fits.\n    if (own_type_pending) {\n      if ((root->value != -1 && root->value < constrained_child->start) ||\n          (root->value == -1 &&\n           start_value + root->num_own_values <= constrained_child->start)) {\n        start_value = SelectOwnValues(root.get(), start_value);\n        own_type_pending = false;\n      }\n    }\n\n    // Try to find any unconstrained children that fit before the constrained\n    // one. This simple greedy algorithm just puts the biggest unconstrained\n    // children in first, which might not fill the space as efficiently as\n    // possible but is good enough for our needs.\n    for (auto it = unconstrained_children_by_size.begin();\n         it != unconstrained_children_by_size.end();) {\n      if (it->second->num_values + start_value <= constrained_child->start) {\n        start_value = SolveInstanceTypeConstraints(\n            std::move(it->second), start_value, &root->children);\n        it = unconstrained_children_by_size.erase(it);\n      } else {\n        ++it;\n      }\n    }\n\n    // Place the constrained child type.\n    start_value = SolveInstanceTypeConstraints(std::move(constrained_child),\n                                               start_value, &root->children);\n  }\n  if (own_type_pending) {\n    start_value = SelectOwnValues(root.get(), start_value);\n    own_type_pending = false;\n  }\n  for (auto& child_pair : unconstrained_children_by_size) {\n    start_value = SolveInstanceTypeConstraints(std::move(child_pair.second),\n                                               start_value, &root->children);\n  }\n  if (highest_child != nullptr) {\n    start_value = SolveInstanceTypeConstraints(std::move(highest_child),\n                                               start_value, &root->children);\n  }\n\n  // Finally, set the range for this class to include all placed subclasses.\n  root->end = start_value - 1;\n  root->start =\n      root->children.empty() ? start_value : root->children.front()->start;\n  if (root->value != -1 && root->value < root->start) {\n    root->start = root->value;\n  }\n  root->num_values = root->end - root->start + 1;\n  root->type->InitializeInstanceTypes(\n      root->value == -1 ? std::optional<int>{} : root->value,\n      std::make_pair(root->start, root->end));\n\n  if (root->num_values > 0) {\n    destination->push_back(std::move(root));\n  }\n  return start_value;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SolveInstanceTypeConstraints\",\n            \"parent\": null,\n            \"about\": \"A wrapper function to solve instance type constraints using the main SolveInstanceTypeConstraints function.\",\n            \"logic\": \"This overload of `SolveInstanceTypeConstraints` takes a `unique_ptr` to the root of the `InstanceTypeTree` and processes it by delegating the work to the other `SolveInstanceTypeConstraints` function, making sure the result is either `nullptr` if the destination vector is empty, or returns the first element of the vector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"root\",\n                    \"type\": \"std::unique_ptr<InstanceTypeTree>\",\n                    \"purpose\": \"The root of the InstanceTypeTree to process.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<InstanceTypeTree>\",\n                \"description\": \"A unique pointer to the root of the solved InstanceTypeTree, or nullptr if the tree is empty.\"\n            },\n            \"dependencies\": [\n                \"InstanceTypeTree\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<InstanceTypeTree> SolveInstanceTypeConstraints(\n    std::unique_ptr<InstanceTypeTree> root) {\n  std::vector<std::unique_ptr<InstanceTypeTree>> destination;\n  SolveInstanceTypeConstraints(std::move(root), 0, &destination);\n  return destination.empty() ? nullptr : std::move(destination.front());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AssignInstanceTypes\",\n            \"parent\": null,\n            \"about\": \"Assigns instance types to all classes in the Torque type system.\",\n            \"logic\": \"Builds the instance type tree, propagates constraints, and then solves the constraints to assign concrete values.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"std::unique_ptr<InstanceTypeTree>\",\n                \"description\": \"A unique pointer to the root of the InstanceTypeTree with assigned instance types, or nullptr if no class types are found.\"\n            },\n            \"dependencies\": [\n                \"BuildInstanceTypeTree\",\n                \"PropagateInstanceTypeConstraints\",\n                \"SolveInstanceTypeConstraints\",\n                \"InstanceTypeTree\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<InstanceTypeTree> AssignInstanceTypes() {\n  std::unique_ptr<InstanceTypeTree> root = BuildInstanceTypeTree();\n  if (root != nullptr) {\n    PropagateInstanceTypeConstraints(root.get());\n    root = SolveInstanceTypeConstraints(std::move(root));\n  }\n  return root;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PrintInstanceTypes\",\n            \"parent\": null,\n            \"about\": \"Prints various lists of instance types and related information for a given class and its descendants.\",\n            \"logic\": \"Recursively traverses the InstanceTypeTree, generating output strings formatted as C preprocessor macro definitions. These definitions are used to define instance type values, create lists of class-to-instance-type mappings for type checking, and generate lists of Torque-defined classes. The output is separated into different streams based on whether the classes have defined layouts in Torque and whether they have subclasses.\",\n            \"parameters\": [\n                {\n                    \"name\": \"root\",\n                    \"type\": \"InstanceTypeTree*\",\n                    \"purpose\": \"The root of the InstanceTypeTree to print.\"\n                },\n                {\n                    \"name\": \"definitions\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for instance type definitions.\"\n                },\n                {\n                    \"name\": \"values\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for instance type value list.\"\n                },\n                {\n                    \"name\": \"fully_defined_single_instance_types\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for fully defined single instance types.\"\n                },\n                {\n                    \"name\": \"fully_defined_multiple_instance_types\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for fully defined multiple instance types.\"\n                },\n                {\n                    \"name\": \"only_declared_single_instance_types\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for only declared single instance types.\"\n                },\n                {\n                    \"name\": \"only_declared_multiple_instance_types\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for only declared multiple instance types.\"\n                },\n                {\n                    \"name\": \"fully_defined_range_instance_types\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for fully defined range instance types.\"\n                },\n                {\n                    \"name\": \"only_declared_range_instance_types\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream for only declared range instance types.\"\n                },\n                {\n                    \"name\": \"indent\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"Indentation string for formatting.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"InstanceTypeTree\",\n                \"ClassType\",\n                \"CapifyStringWithUnderscores\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid PrintInstanceTypes(InstanceTypeTree* root, std::ostream& definitions,\n                        std::ostream& values,\n                        std::ostream& fully_defined_single_instance_types,\n                        std::ostream& fully_defined_multiple_instance_types,\n                        std::ostream& only_declared_single_instance_types,\n                        std::ostream& only_declared_multiple_instance_types,\n                        std::ostream& fully_defined_range_instance_types,\n                        std::ostream& only_declared_range_instance_types,\n                        const std::string& indent) {\n  std::string type_name =\n      CapifyStringWithUnderscores(root->type->name()) + \"_TYPE\";\n  std::string inner_indent = indent;\n\n  if (root->num_values > 1) {\n    definitions << indent << \"V(FIRST_\" << type_name << \", \" << root->start\n                << \") \\\\\\n\";\n    inner_indent += \"  \";\n  }\n  if (root->num_own_values == 1) {\n    definitions << inner_indent << \"V(\" << type_name << \", \" << root->value\n                << \") /* \" << root->type->GetPosition() << \" */\\\\\\n\";\n    values << \"  V(\" << type_name << \") /* \" << root->type->GetPosition()\n           << \" */\\\\\\n\";\n    std::ostream& type_checker_list =\n        root->type->HasUndefinedLayout()\n            ? (root->num_values == 1 ? only_declared_single_instance_types\n                                     : only_declared_multiple_instance_types)\n            : (root->num_values == 1 ? fully_defined_single_instance_types\n                                     : fully_defined_multiple_instance_types);\n    type_checker_list << \"  V(\" << root->type->name() << \", \" << type_name\n                      << \") /* \" << root->type->GetPosition() << \" */ \\\\\\n\";\n  }\n  for (auto& child : root->children) {\n    PrintInstanceTypes(child.get(), definitions, values,\n                       fully_defined_single_instance_types,\n                       fully_defined_multiple_instance_types,\n                       only_declared_single_instance_types,\n                       only_declared_multiple_instance_types,\n                       fully_defined_range_instance_types,\n                       only_declared_range_instance_types, inner_indent);\n  }\n  if (root->num_values > 1) {\n    // We can't emit LAST_STRING_TYPE because it's not a valid flags\n    // combination. So if the class type has multiple own values, which only\n    // happens when using ANNOTATION_RESERVE_BITS_IN_INSTANCE_TYPE, then omit\n    // the end marker.\n    if (root->num_own_values <= 1) {\n      definitions << indent << \"V(LAST_\" << type_name << \", \" << root->end\n                  << \") \\\\\\n\";\n    }\n\n    // Only output the instance type range for things other than the root type.\n    if (root->type->GetSuperClass() != nullptr) {\n      std::ostream& range_instance_types =\n          root->type->HasUndefinedLayout() ? only_declared_range_instance_types\n                                           : fully_defined_range_instance_types;\n      range_instance_types << \"  V(\" << root->type->name() << \", FIRST_\"\n                           << type_name << \", LAST_\" << type_name << \") \\\\\\n\";\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GenerateInstanceTypes\",\n            \"parent\": \"ImplementationVisitor\",\n            \"about\": \"Generates the instance types header file.\",\n            \"logic\": \"Calls AssignInstanceTypes to perform the actual instance type assignment and then formats the output into a header file, writing it to the specified directory.  It generates various macro definitions, including lists of instance types, class-to-instance-type mappings, and Torque-defined classes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"output_directory\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The directory to write the generated header file to.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"AssignInstanceTypes\",\n                \"PrintInstanceTypes\",\n                \"IncludeGuardScope\",\n                \"WriteFile\",\n                \"GlobalContext\",\n                \"TypeOracle\",\n                \"SnakeifyString\",\n                \"CapifyStringWithUnderscores\",\n                \"ClassType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ImplementationVisitor::GenerateInstanceTypes(\n    const std::string& output_directory) {\n  std::stringstream header;\n  std::string file_name = \"instance-types.h\";\n  {\n    IncludeGuardScope guard(header, file_name);\n\n    header << \"// Instance types for all classes except for those that use \"\n              \"InstanceType as flags.\\n\";\n    header << \"#define TORQUE_ASSIGNED_INSTANCE_TYPES(V) \\\\\\n\";\n    std::unique_ptr<InstanceTypeTree> instance_types = AssignInstanceTypes();\n    std::stringstream values_list;\n    std::stringstream fully_defined_single_instance_types;\n    std::stringstream fully_defined_multiple_instance_types;\n    std::stringstream only_declared_single_instance_types;\n    std::stringstream only_declared_multiple_instance_types;\n    std::stringstream fully_defined_range_instance_types;\n    std::stringstream only_declared_range_instance_types;\n    if (instance_types != nullptr) {\n      PrintInstanceTypes(instance_types.get(), header, values_list,\n                         fully_defined_single_instance_types,\n                         fully_defined_multiple_instance_types,\n                         only_declared_single_instance_types,\n                         only_declared_multiple_instance_types,\n                         fully_defined_range_instance_types,\n                         only_declared_range_instance_types, \"  \");\n    }\n    header << \"\\n\";\n\n    header << \"// Instance types for all classes except for those that use\\n\";\n    header << \"// InstanceType as flags.\\n\";\n    header << \"#define TORQUE_ASSIGNED_INSTANCE_TYPE_LIST(V) \\\\\\n\";\n    header << values_list.str();\n    header << \"\\n\";\n\n    header << \"// Pairs of (ClassName, INSTANCE_TYPE) for classes that have\\n\";\n    header << \"// full Torque definitions.\\n\";\n    header << \"#define TORQUE_INSTANCE_CHECKERS_SINGLE_FULLY_DEFINED(V) \\\\\\n\";\n    header << fully_defined_single_instance_types.str();\n    header << \"\\n\";\n\n    header << \"// Pairs of (ClassName, INSTANCE_TYPE) for classes that have\\n\";\n    header << \"// full Torque definitions and subclasses.\\n\";\n    header << \"#define TORQUE_INSTANCE_CHECKERS_MULTIPLE_FULLY_DEFINED(V) \\\\\\n\";\n    header << fully_defined_multiple_instance_types.str();\n    header << \"\\n\";\n\n    header << \"// Pairs of (ClassName, INSTANCE_TYPE) for classes that are\\n\";\n    header << \"// declared but not defined in Torque. These classes may\\n\";\n    header << \"// correspond with actual C++ classes, but they are not\\n\";\n    header << \"// guaranteed to.\\n\";\n    header << \"#define TORQUE_INSTANCE_CHECKERS_SINGLE_ONLY_DECLARED(V) \\\\\\n\";\n    header << only_declared_single_instance_types.str();\n    header << \"\\n\";\n\n    header << \"// Pairs of (ClassName, INSTANCE_TYPE) for classes that are\\n\";\n    header << \"// declared but not defined in Torque, and have subclasses.\\n\";\n    header << \"// These classes may correspond with actual C++ classes, but\\n\";\n    header << \"// they are not guaranteed to.\\n\";\n    header << \"#define TORQUE_INSTANCE_CHECKERS_MULTIPLE_ONLY_DECLARED(V) \\\\\\n\";\n    header << only_declared_multiple_instance_types.str();\n    header << \"\\n\";\n\n    header << \"// Triples of (ClassName, FIRST_TYPE, LAST_TYPE) for classes\\n\";\n    header << \"// that have full Torque definitions.\\n\";\n    header << \"#define TORQUE_INSTANCE_CHECKERS_RANGE_FULLY_DEFINED(V) \\\\\\n\";\n    header << fully_defined_range_instance_types.str();\n    header << \"\\n\";\n\n    header << \"// Triples of (ClassName, FIRST_TYPE, LAST_TYPE) for classes\\n\";\n    header << \"// that"
}