{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/strings/uri.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/strings/uri.cc\",\n        \"file_name\": \"uri.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements URI encoding and decoding functions for V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for string manipulation, data structures, and V8 internals.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/strings/uri.h\"\n\n#include <vector>\n\n#include \"src/execution/isolate-inl.h\"\n#include \"src/strings/char-predicates-inl.h\"\n#include \"src/strings/string-search.h\"\n#include \"src/strings/unicode-inl.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsReservedPredicate\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Checks if a character is a reserved character in URIs.\",\n            \"logic\": \"Uses a switch statement to check against a list of reserved characters.\",\n            \"parameters\": [\n                {\n                    \"name\": \"c\",\n                    \"type\": \"base::uc16\",\n                    \"purpose\": \"The character to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the character is reserved, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsReservedPredicate(base::uc16 c) {\n  switch (c) {\n    case '#':\n    case '$':\n    case '&':\n    case '+':\n    case ',':\n    case '/':\n    case ':':\n    case ';':\n    case '=':\n    case '?':\n    case '@':\n      return true;\n    default:\n      return false;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsReplacementCharacter\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Checks if a sequence of bytes represents the Unicode replacement character (U+FFFD).\",\n            \"logic\": \"Checks if the byte sequence is exactly 0xEF 0xBF 0xBD.\",\n            \"parameters\": [\n                {\n                    \"name\": \"octets\",\n                    \"type\": \"const uint8_t*\",\n                    \"purpose\": \"The byte sequence to check.\"\n                },\n                {\n                    \"name\": \"length\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The length of the byte sequence.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the byte sequence represents the replacement character, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsReplacementCharacter(const uint8_t* octets, int length) {\n  // The replacement character is at codepoint U+FFFD in the Unicode Specials\n  // table. Its UTF-8 encoding is 0xEF 0xBF 0xBD.\n  if (length != 3 || octets[0] != 0xEF || octets[1] != 0xBF ||\n      octets[2] != 0xBD) {\n    return false;\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DecodeOctets\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Decodes a UTF-8 sequence of octets into a Unicode code point.\",\n            \"logic\": \"Uses unibrow::Utf8::ValueOf to decode the octets. Handles surrogate pairs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"octets\",\n                    \"type\": \"const uint8_t*\",\n                    \"purpose\": \"The UTF-8 octets to decode.\"\n                },\n                {\n                    \"name\": \"length\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The length of the octets sequence.\"\n                },\n                {\n                    \"name\": \"buffer\",\n                    \"type\": \"std::vector<base::uc16>*\",\n                    \"purpose\": \"The buffer to store the decoded Unicode code point.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if decoding was successful, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"unibrow::Utf8::ValueOf\",\n                \"unibrow::Utf16::LeadSurrogate\",\n                \"unibrow::Utf16::TrailSurrogate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool DecodeOctets(const uint8_t* octets, int length,\n                  std::vector<base::uc16>* buffer) {\n  size_t cursor = 0;\n  base::uc32 value = unibrow::Utf8::ValueOf(octets, length, &cursor);\n  if (value == unibrow::Utf8::kBadChar &&\n      !IsReplacementCharacter(octets, length)) {\n    return false;\n  }\n\n  if (value <=\n      static_cast<base::uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {\n    buffer->push_back(value);\n  } else {\n    buffer->push_back(unibrow::Utf16::LeadSurrogate(value));\n    buffer->push_back(unibrow::Utf16::TrailSurrogate(value));\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TwoDigitHex\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Converts two hexadecimal characters to an integer value.\",\n            \"logic\": \"Uses base::HexValue to convert each character and combines the results.\",\n            \"parameters\": [\n                {\n                    \"name\": \"character1\",\n                    \"type\": \"base::uc16\",\n                    \"purpose\": \"The first hexadecimal character.\"\n                },\n                {\n                    \"name\": \"character2\",\n                    \"type\": \"base::uc16\",\n                    \"purpose\": \"The second hexadecimal character.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The integer value, or -1 if the characters are not valid hexadecimal digits.\"\n            },\n            \"dependencies\": [\n                \"base::HexValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint TwoDigitHex(base::uc16 character1, base::uc16 character2) {\n  if (character1 > 'f') return -1;\n  int high = base::HexValue(character1);\n  if (high == -1) return -1;\n  if (character2 > 'f') return -1;\n  int low = base::HexValue(character2);\n  if (low == -1) return -1;\n  return (high << 4) + low;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AddToBuffer\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Adds a decoded character to a buffer, encoding reserved characters if necessary.\",\n            \"logic\": \"If is_uri is true and the character is reserved, it adds the percent-encoded version to the buffer. Otherwise, it adds the character directly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"decoded\",\n                    \"type\": \"base::uc16\",\n                    \"purpose\": \"The decoded character to add.\"\n                },\n                {\n                    \"name\": \"uri_content\",\n                    \"type\": \"String::FlatContent*\",\n                    \"purpose\": \"Pointer to the flat string content\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the character within the original encoded string\"\n                },\n                {\n                    \"name\": \"is_uri\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates if URI encoding rules should be applied\"\n                },\n                {\n                    \"name\": \"buffer\",\n                    \"type\": \"std::vector<T>*\",\n                    \"purpose\": \"The buffer to which the character (or its encoded form) will be appended.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"IsReservedPredicate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nvoid AddToBuffer(base::uc16 decoded, String::FlatContent* uri_content,\n                 int index, bool is_uri, std::vector<T>* buffer) {\n  if (is_uri && IsReservedPredicate(decoded)) {\n    buffer->push_back('%');\n    base::uc16 first = uri_content->Get(index + 1);\n    base::uc16 second = uri_content->Get(index + 2);\n    DCHECK_GT(std::numeric_limits<T>::max(), first);\n    DCHECK_GT(std::numeric_limits<T>::max(), second);\n\n    buffer->push_back(first);\n    buffer->push_back(second);\n  } else {\n    buffer->push_back(decoded);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IntoTwoByte\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Decodes a URI string into a two-byte character buffer.\",\n            \"logic\": \"Iterates through the URI string, decoding percent-encoded characters. Handles multi-byte UTF-8 sequences.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The starting index in the string.\"\n                },\n                {\n                    \"name\": \"is_uri\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates if URI encoding rules should be applied.\"\n                },\n                {\n                    \"name\": \"uri_length\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The length of the URI string.\"\n                },\n                {\n                    \"name\": \"uri_content\",\n                    \"type\": \"String::FlatContent*\",\n                    \"purpose\": \"A pointer to the flat content of the string.\"\n                },\n                {\n                    \"name\": \"buffer\",\n                    \"type\": \"std::vector<base::uc16>*\",\n                    \"purpose\": \"The buffer to store the decoded two-byte characters.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if decoding was successful, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"TwoDigitHex\",\n                \"DecodeOctets\",\n                \"AddToBuffer\",\n                \"unibrow::Utf8::kMaxOneByteChar\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool IntoTwoByte(int index, bool is_uri, int uri_length,\n                 String::FlatContent* uri_content,\n                 std::vector<base::uc16>* buffer) {\n  for (int k = index; k < uri_length; k++) {\n    base::uc16 code = uri_content->Get(k);\n    if (code == '%') {\n      int two_digits;\n      if (k + 2 >= uri_length ||\n          (two_digits = TwoDigitHex(uri_content->Get(k + 1),\n                                    uri_content->Get(k + 2))) < 0) {\n        return false;\n      }\n      k += 2;\n      base::uc16 decoded = static_cast<base::uc16>(two_digits);\n      if (decoded > unibrow::Utf8::kMaxOneByteChar) {\n        uint8_t octets[unibrow::Utf8::kMaxEncodedSize];\n        octets[0] = decoded;\n\n        int number_of_continuation_bytes = 0;\n        while ((decoded << ++number_of_continuation_bytes) & 0x80) {\n          if (number_of_continuation_bytes > 3 || k + 3 >= uri_length) {\n            return false;\n          }\n          if (uri_content->Get(++k) != '%' ||\n              (two_digits = TwoDigitHex(uri_content->Get(k + 1),\n                                        uri_content->Get(k + 2))) < 0) {\n            return false;\n          }\n          k += 2;\n          base::uc16 continuation_byte = static_cast<base::uc16>(two_digits);\n          octets[number_of_continuation_bytes] = continuation_byte;\n        }\n\n        if (!DecodeOctets(octets, number_of_continuation_bytes, buffer)) {\n          return false;\n        }\n      } else {\n        AddToBuffer(decoded, uri_content, k - 2, is_uri, buffer);\n      }\n    } else {\n      buffer->push_back(code);\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IntoOneAndTwoByte\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Decodes a URI string into separate one-byte and two-byte character buffers.\",\n            \"logic\": \"Iterates through the URI string, separating one-byte and two-byte characters into different buffers.  Delegates to IntoTwoByte when necessary.\",\n            \"parameters\": [\n                {\n                    \"name\": \"uri\",\n                    \"type\": \"DirectHandle<String>\",\n                    \"purpose\": \"The URI string to decode.\"\n                },\n                {\n                    \"name\": \"is_uri\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates if URI encoding rules should be applied.\"\n                },\n                {\n                    \"name\": \"one_byte_buffer\",\n                    \"type\": \"std::vector<uint8_t>*\",\n                    \"purpose\": \"The buffer to store one-byte characters.\"\n                },\n                {\n                    \"name\": \"two_byte_buffer\",\n                    \"type\": \"std::vector<base::uc16>*\",\n                    \"purpose\": \"The buffer to store two-byte characters.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if decoding was successful, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"String::FlatContent\",\n                \"TwoDigitHex\",\n                \"IntoTwoByte\",\n                \"AddToBuffer\",\n                \"unibrow::Utf8::kMaxOneByteChar\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool IntoOneAndTwoByte(DirectHandle<String> uri, bool is_uri,\n                       std::vector<uint8_t>* one_byte_buffer,\n                       std::vector<base::uc16>* two_byte_buffer) {\n  DisallowGarbageCollection no_gc;\n  String::FlatContent uri_content = uri->GetFlatContent(no_gc);\n\n  int uri_length = uri->length();\n  for (int k = 0; k < uri_length; k++) {\n    base::uc16 code = uri_content.Get(k);\n    if (code == '%') {\n      int two_digits;\n      if (k + 2 >= uri_length ||\n          (two_digits = TwoDigitHex(uri_content.Get(k + 1),\n                                    uri_content.Get(k + 2))) < 0) {\n        return false;\n      }\n\n      base::uc16 decoded = static_cast<base::uc16>(two_digits);\n      if (decoded > unibrow::Utf8::kMaxOneByteChar) {\n        return IntoTwoByte(k, is_uri, uri_length, &uri_content,\n                           two_byte_buffer);\n      }\n\n      AddToBuffer(decoded, &uri_content, k, is_uri, one_byte_buffer);\n      k += 2;\n    } else {\n      if (code > unibrow::Utf8::kMaxOneByteChar) {\n        return IntoTwoByte(k, is_uri, uri_length, &uri_content,\n                           two_byte_buffer);\n      }\n      one_byte_buffer->push_back(code);\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Decode\",\n            \"parent\": \"Uri\",\n            \"about\": \"Decodes a URI string.\",\n            \"logic\": \"Flattens the string, then decodes it into one-byte and two-byte buffers using IntoOneAndTwoByte.  Creates a new string from the buffers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"uri\",\n                    \"type\": \"DirectHandle<String>\",\n                    \"purpose\": \"The URI string to decode.\"\n                },\n                {\n                    \"name\": \"is_uri\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates if URI encoding rules should be applied.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MaybeDirectHandle<String>\",\n                \"description\": \"The decoded URI string, or an empty handle if an error occurred.\"\n            },\n            \"dependencies\": [\n                \"String::Flatten\",\n                \"IntoOneAndTwoByte\",\n                \"NewURIError\",\n                \"isolate->factory()->NewStringFromOneByte\",\n                \"isolate->factory()->NewRawTwoByteString\",\n                \"CopyChars\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMaybeDirectHandle<String> Uri::Decode(Isolate* isolate,\n                                      DirectHandle<String> uri, bool is_uri) {\n  uri = String::Flatten(isolate, uri);\n  std::vector<uint8_t> one_byte_buffer;\n  std::vector<base::uc16> two_byte_buffer;\n\n  if (!IntoOneAndTwoByte(uri, is_uri, &one_byte_buffer, &two_byte_buffer)) {\n    THROW_NEW_ERROR(isolate, NewURIError());\n  }\n\n  if (two_byte_buffer.empty()) {\n    return isolate->factory()->NewStringFromOneByte(base::Vector<const uint8_t>(\n        one_byte_buffer.data(), static_cast<int>(one_byte_buffer.size())));\n  }\n\n  DirectHandle<SeqTwoByteString> result;\n  int result_length =\n      static_cast<int>(one_byte_buffer.size() + two_byte_buffer.size());\n  ASSIGN_RETURN_ON_EXCEPTION(\n      isolate, result, isolate->factory()->NewRawTwoByteString(result_length));\n\n  DisallowGarbageCollection no_gc;\n  base::uc16* chars = result->GetChars(no_gc);\n  if (!one_byte_buffer.empty()) {\n    CopyChars(chars, one_byte_buffer.data(), one_byte_buffer.size());\n    chars += one_byte_buffer.size();\n  }\n  if (!two_byte_buffer.empty()) {\n    CopyChars(chars, two_byte_buffer.data(), two_byte_buffer.size());\n  }\n\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsUnescapePredicateInUriComponent\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Checks if a character should not be escaped in a URI component.\",\n            \"logic\": \"Checks if the character is alphanumeric or one of a specific set of characters.\",\n            \"parameters\": [\n                {\n                    \"name\": \"c\",\n                    \"type\": \"base::uc16\",\n                    \"purpose\": \"The character to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the character should not be escaped, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"IsAlphaNumeric\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsUnescapePredicateInUriComponent(base::uc16 c) {\n  if (IsAlphaNumeric(c)) {\n    return true;\n  }\n\n  switch (c) {\n    case '!':\n    case '\\'':\n    case '(':\n    case ')':\n    case '*':\n    case '-':\n    case '.':\n    case '_':\n    case '~':\n      return true;\n    default:\n      return false;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsUriSeparator\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Checks if a character is a URI separator.\",\n            \"logic\": \"Uses a switch statement to check against a list of URI separator characters.\",\n            \"parameters\": [\n                {\n                    \"name\": \"c\",\n                    \"type\": \"base::uc16\",\n                    \"purpose\": \"The character to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the character is a URI separator, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsUriSeparator(base::uc16 c) {\n  switch (c) {\n    case '#':\n    case ':':\n    case ';':\n    case '/':\n    case '?':\n    case '$':\n    case '&':\n    case '+':\n    case ',':\n    case '@':\n    case '=':\n      return true;\n    default:\n      return false;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AddEncodedOctetToBuffer\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Adds a percent-encoded octet to a buffer.\",\n            \"logic\": \"Converts the octet to its hexadecimal representation and adds it to the buffer, prefixed with '%'.\",\n            \"parameters\": [\n                {\n                    \"name\": \"octet\",\n                    \"type\": \"uint8_t\",\n                    \"purpose\": \"The octet to encode.\"\n                },\n                {\n                    \"name\": \"buffer\",\n                    \"type\": \"std::vector<uint8_t>*\",\n                    \"purpose\": \"The buffer to store the encoded octet.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"base::HexCharOfValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AddEncodedOctetToBuffer(uint8_t octet, std::vector<uint8_t>* buffer) {\n  buffer->push_back('%');\n  buffer->push_back(base::HexCharOfValue(octet >> 4));\n  buffer->push_back(base::HexCharOfValue(octet & 0x0F));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"EncodeSingle\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Encodes a single Unicode character into a UTF-8 byte sequence and adds it to a buffer.\",\n            \"logic\": \"Uses unibrow::Utf8::Encode to encode the character and then adds the percent encoded bytes to the buffer\",\n            \"parameters\": [\n                {\n                    \"name\": \"c\",\n                    \"type\": \"base::uc16\",\n                    \"purpose\": \"The character to encode.\"\n                },\n                {\n                    \"name\": \"buffer\",\n                    \"type\": \"std::vector<uint8_t>*\",\n                    \"purpose\": \"The buffer to store the encoded bytes.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"unibrow::Utf8::Encode\",\n                \"unibrow::Utf16::kNoPreviousCharacter\",\n                \"AddEncodedOctetToBuffer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid EncodeSingle(base::uc16 c, std::vector<uint8_t>* buffer) {\n  char s[4] = {};\n  int number_of_bytes;\n  number_of_bytes =\n      unibrow::Utf8::Encode(s, c, unibrow::Utf16::kNoPreviousCharacter, false);\n  for (int k = 0; k < number_of_bytes; k++) {\n    AddEncodedOctetToBuffer(s[k], buffer);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"EncodePair\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Encodes a Unicode surrogate pair into a UTF-8 byte sequence and adds it to a buffer.\",\n            \"logic\": \"Combines the surrogate pair, uses unibrow::Utf8::Encode to encode it, and adds the percent encoded bytes to the buffer\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc1\",\n                    \"type\": \"base::uc16\",\n                    \"purpose\": \"The first character of the surrogate pair.\"\n                },\n                {\n                    \"name\": \"cc2\",\n                    \"type\": \"base::uc16\",\n                    \"purpose\": \"The second character of the surrogate pair.\"\n                },\n                {\n                    \"name\": \"buffer\",\n                    \"type\": \"std::vector<uint8_t>*\",\n                    \"purpose\": \"The buffer to store the encoded bytes.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"unibrow::Utf8::Encode\",\n                \"unibrow::Utf16::CombineSurrogatePair\",\n                \"unibrow::Utf16::kNoPreviousCharacter\",\n                \"AddEncodedOctetToBuffer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid EncodePair(base::uc16 cc1, base::uc16 cc2, std::vector<uint8_t>* buffer) {\n  char s[4] = {};\n  int number_of_bytes =\n      unibrow::Utf8::Encode(s, unibrow::Utf16::CombineSurrogatePair(cc1, cc2),\n                            unibrow::Utf16::kNoPreviousCharacter, false);\n  for (int k = 0; k < number_of_bytes; k++) {\n    AddEncodedOctetToBuffer(s[k], buffer);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Encode\",\n            \"parent\": \"Uri\",\n            \"about\": \"Encodes a URI string.\",\n            \"logic\": \"Flattens the string, then encodes it by iterating through the characters and encoding those that need to be escaped.  Handles surrogate pairs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"uri\",\n                    \"type\": \"DirectHandle<String>\",\n                    \"purpose\": \"The URI string to encode.\"\n                },\n                {\n                    \"name\": \"is_uri\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates if URI encoding rules should be applied.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MaybeDirectHandle<String>\",\n                \"description\": \"The encoded URI string, or an empty handle if an error occurred.\"\n            },\n            \"dependencies\": [\n                \"String::Flatten\",\n                \"IsUnescapePredicateInUriComponent\",\n                \"IsUriSeparator\",\n                \"EncodeSingle\",\n                \"EncodePair\",\n                \"NewURIError\",\n                \"isolate->factory()->NewStringFromOneByte\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMaybeDirectHandle<String> Uri::Encode(Isolate* isolate,\n                                      DirectHandle<String> uri, bool is_uri) {\n  uri = String::Flatten(isolate, uri);\n  int uri_length = uri->length();\n  std::vector<uint8_t> buffer;\n  buffer.reserve(uri_length);\n\n  bool throw_error = false;\n  {\n    DisallowGarbageCollection no_gc;\n    String::FlatContent uri_content = uri->GetFlatContent(no_gc);\n\n    for (int k = 0; k < uri_length; k++) {\n      base::uc16 cc1 = uri_content.Get(k);\n      if (unibrow::Utf16::IsLeadSurrogate(cc1)) {\n        k++;\n        if (k < uri_length) {\n          base::uc16 cc2 = uri->Get(k);\n          if (unibrow::Utf16::IsTrailSurrogate(cc2)) {\n            EncodePair(cc1, cc2, &buffer);\n            continue;\n          }\n        }\n      } else if (!unibrow::Utf16::IsTrailSurrogate(cc1)) {\n        if (IsUnescapePredicateInUriComponent(cc1) ||\n            (is_uri && IsUriSeparator(cc1))) {\n          buffer.push_back(cc1);\n        } else {\n          EncodeSingle(cc1, &buffer);\n        }\n        continue;\n      }\n\n      // String::FlatContent DCHECKs its contents did not change during its\n      // lifetime. Throwing the error inside the loop may cause GC and move the\n      // string contents.\n      throw_error = true;\n      break;\n    }\n  }\n\n  if (throw_error) THROW_NEW_ERROR(isolate, NewURIError());\n  return isolate->factory()->NewStringFromOneByte(base::VectorOf(buffer));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"UnescapeChar\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Unescapes a single character or a percent-encoded sequence.\",\n            \"logic\": \"If the character is '%' checks if it is followed by a 'u' or by two hex digits and converts accordingly. Otherwise, returns the original character.\",\n            \"parameters\": [\n                {\n                    \"name\": \"vector\",\n                    \"type\": \"base::Vector<const Char>\",\n                    \"purpose\": \"The string to unescape represented as a vector of characters.\"\n                },\n                {\n                    \"name\": \"i\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The current index in the string.\"\n                },\n                {\n                    \"name\": \"length\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The total length of the string.\"\n                },\n                {\n                    \"name\": \"step\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"A pointer to an integer that will store the number of characters to advance after this unescaping.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The unescaped character value.\"\n            },\n            \"dependencies\": [\n                \"TwoDigitHex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Char>\nint UnescapeChar(base::Vector<const Char> vector, int i, int length,\n                 int* step) {\n  uint16_t character = vector[i];\n  int32_t hi = 0;\n  int32_t lo = 0;\n  if (character == '%' && i <= length - 6 && vector[i + 1] == 'u' &&\n      (hi = TwoDigitHex(vector[i + 2], vector[i + 3])) > -1 &&\n      (lo = TwoDigitHex(vector[i + 4], vector[i + 5])) > -1) {\n    *step = 6;\n    return (hi << 8) + lo;\n  } else if (character == '%' && i <= length - 3 &&\n             (lo = TwoDigitHex(vector[i + 1], vector[i + 2])) > -1) {\n    *step = 3;\n    return lo;\n  } else {\n    *step = 1;\n    return character;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"UnescapeSlow\",\n            \"parent\": \"anonymous namespace\",\n            \"about\": \"Unescapes a string by replacing escaped characters with their unescaped equivalents.\",\n            \"logic\": \"Iterates through the string from the"
}