{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/internal/pointer-policies.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 383, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/internal/pointer-policies.h\",\n            \"file_name\": \"pointer-policies.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines policies for pointer handling in cppgc, including write barriers, checking, and location tracking.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and cppgc headers for type traits, member storage, write barriers, sentinel pointers, source locations, and V8 configuration.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cstdint>\n            #include <type_traits>\n\n            #include \"cppgc/internal/member-storage.h\"\n            #include \"cppgc/internal/write-barrier.h\"\n            #include \"cppgc/sentinel-pointer.h\"\n            #include \"cppgc/source-location.h\"\n            #include \"cppgc/type-traits.h\"\n            #include \"v8config.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"HeapBase\",\n                \"about\": \"Forward declaration for HeapBase.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class HeapBase;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PersistentRegion\",\n                \"about\": \"Forward declaration for PersistentRegion.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class PersistentRegion;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CrossThreadPersistentRegion\",\n                \"about\": \"Forward declaration for CrossThreadPersistentRegion.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class CrossThreadPersistentRegion;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StrongMemberTag\",\n                \"about\": \"Tags to distinguish between strong and weak member types.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class StrongMemberTag;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WeakMemberTag\",\n                \"about\": \"Tags to distinguish between strong and weak member types.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class WeakMemberTag;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UntracedMemberTag\",\n                \"about\": \"Tags to distinguish between strong and weak member types.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class UntracedMemberTag;\n        ]]></code>\n    </class>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"DijkstraWriteBarrierPolicy\",\n                \"about\": \"Policy defining write barriers based on Dijkstra's algorithm for garbage collection.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"WriteBarrier\",\n                    \"RawPointer\",\n                    \"CompressedPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct DijkstraWriteBarrierPolicy {\n                // Since in initializing writes the source object is always white, having no\n                // barrier doesn't break the tri-color invariant.\n                V8_INLINE static void InitializingBarrier(const void*, const void*) {}\n                V8_INLINE static void InitializingBarrier(const void*, RawPointer storage) {\n                }\n            #if defined(CPPGC_POINTER_COMPRESSION)\n                V8_INLINE static void InitializingBarrier(const void*,\n                                                          CompressedPointer storage) {}\n            #endif\n\n                template <WriteBarrierSlotType SlotType>\n                V8_INLINE static void AssigningBarrier(const void* slot,\n                                                       const void* value) {\n            #ifdef CPPGC_SLIM_WRITE_BARRIER\n                if (V8_UNLIKELY(WriteBarrier::IsEnabled()))\n                  WriteBarrier::CombinedWriteBarrierSlow<SlotType>(slot);\n            #else   // !CPPGC_SLIM_WRITE_BARRIER\n                WriteBarrier::Params params;\n                const WriteBarrier::Type type =\n                    WriteBarrier::GetWriteBarrierType(slot, value, params);\n                WriteBarrier(type, params, slot, value);\n            #endif  // !CPPGC_SLIM_WRITE_BARRIER\n                }\n\n              template <WriteBarrierSlotType SlotType>\n              V8_INLINE static void AssigningBarrier(const void* slot, RawPointer storage) {\n                static_assert(\n                    SlotType == WriteBarrierSlotType::kUncompressed,\n                    \"Assigning storages of Member and UncompressedMember is not supported\");\n            #ifdef CPPGC_SLIM_WRITE_BARRIER\n                if (V8_UNLIKELY(WriteBarrier::IsEnabled()))\n                  WriteBarrier::CombinedWriteBarrierSlow<SlotType>(slot);\n            #else   // !CPPGC_SLIM_WRITE_BARRIER\n                WriteBarrier::Params params;\n                const WriteBarrier::Type type =\n                    WriteBarrier::GetWriteBarrierType(slot, storage, params);\n                WriteBarrier(type, params, slot, storage.Load());\n            #endif  // !CPPGC_SLIM_WRITE_BARRIER\n              }\n\n            #if defined(CPPGC_POINTER_COMPRESSION)\n              template <WriteBarrierSlotType SlotType>\n              V8_INLINE static void AssigningBarrier(const void* slot,\n                                                     CompressedPointer storage) {\n                static_assert(\n                    SlotType == WriteBarrierSlotType::kCompressed,\n                    \"Assigning storages of Member and UncompressedMember is not supported\");\n            #ifdef CPPGC_SLIM_WRITE_BARRIER\n                if (V8_UNLIKELY(WriteBarrier::IsEnabled()))\n                  WriteBarrier::CombinedWriteBarrierSlow<SlotType>(slot);\n            #else   // !CPPGC_SLIM_WRITE_BARRIER\n                WriteBarrier::Params params;\n                const WriteBarrier::Type type =\n                    WriteBarrier::GetWriteBarrierType(slot, storage, params);\n                WriteBarrier(type, params, slot, storage.Load());\n            #endif  // !CPPGC_SLIM_WRITE_BARRIER\n              }\n            #endif  // defined(CPPGC_POINTER_COMPRESSION)\n\n             private:\n              V8_INLINE static void WriteBarrier(WriteBarrier::Type type,\n                                                 const WriteBarrier::Params& params,\n                                                 const void* slot, const void* value) {\n                switch (type) {\n                  case WriteBarrier::Type::kGenerational:\n                    WriteBarrier::GenerationalBarrier<\n                        WriteBarrier::GenerationalBarrierType::kPreciseSlot>(params, slot);\n                    break;\n                  case WriteBarrier::Type::kMarking:\n                    WriteBarrier::DijkstraMarkingBarrier(params, value);\n                    break;\n                  case WriteBarrier::Type::kNone:\n                    break;\n                }\n              }\n            };\n        ]]></code>\n    </struct>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"NoWriteBarrierPolicy\",\n                \"about\": \"Policy that disables write barriers.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"RawPointer\",\n                    \"CompressedPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct NoWriteBarrierPolicy {\n              V8_INLINE static void InitializingBarrier(const void*, const void*) {}\n              V8_INLINE static void InitializingBarrier(const void*, RawPointer storage) {}\n            #if defined(CPPGC_POINTER_COMPRESSION)\n              V8_INLINE static void InitializingBarrier(const void*,\n                                                        CompressedPointer storage) {}\n            #endif\n              template <WriteBarrierSlotType>\n              V8_INLINE static void AssigningBarrier(const void*, const void*) {}\n              template <WriteBarrierSlotType, typename MemberStorage>\n              V8_INLINE static void AssigningBarrier(const void*, MemberStorage) {}\n            };\n        ]]></code>\n    </struct>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SameThreadEnabledCheckingPolicyBase\",\n                \"about\": \"Base class for policies that check pointer validity within the same thread.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"heap_\",\n                        \"type\": \"const HeapBase*\",\n                        \"access\": \"protected\",\n                        \"purpose\": \"Pointer to the heap.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"HeapBase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT SameThreadEnabledCheckingPolicyBase {\n             protected:\n              void CheckPointerImpl(const void* ptr, bool points_to_payload,\n                                    bool check_off_heap_assignments);\n\n              const HeapBase* heap_ = nullptr;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SameThreadEnabledCheckingPolicy\",\n                \"extends\": \"SameThreadEnabledCheckingPolicyBase\",\n                \"about\": \"Policy that checks pointer validity within the same thread with option to check off-heap assignments.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"SameThreadEnabledCheckingPolicyBase\",\n                    \"RawPointer\",\n                    \"CompressedPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <bool kCheckOffHeapAssignments>\n            class V8_EXPORT SameThreadEnabledCheckingPolicy\n                : private SameThreadEnabledCheckingPolicyBase {\n             protected:\n              template <typename T>\n              V8_INLINE void CheckPointer(RawPointer raw_pointer) {\n                if (raw_pointer.IsCleared() || raw_pointer.IsSentinel()) {\n                  return;\n                }\n                CheckPointersImplTrampoline<T>::Call(\n                    this, static_cast<const T*>(raw_pointer.Load()));\n              }\n            #if defined(CPPGC_POINTER_COMPRESSION)\n              template <typename T>\n              V8_INLINE void CheckPointer(CompressedPointer compressed_pointer) {\n                if (compressed_pointer.IsCleared() || compressed_pointer.IsSentinel()) {\n                  return;\n                }\n                CheckPointersImplTrampoline<T>::Call(\n                    this, static_cast<const T*>(compressed_pointer.Load()));\n              }\n            #endif\n              template <typename T>\n              void CheckPointer(const T* ptr) {\n                if (!ptr || (kSentinelPointer == ptr)) {\n                  return;\n                }\n                CheckPointersImplTrampoline<T>::Call(this, ptr);\n              }\n\n             private:\n              template <typename T, bool = IsCompleteV<T>>\n              struct CheckPointersImplTrampoline {\n                static void Call(SameThreadEnabledCheckingPolicy* policy, const T* ptr) {\n                  policy->CheckPointerImpl(ptr, false, kCheckOffHeapAssignments);\n                }\n              };\n\n              template <typename T>\n              struct CheckPointersImplTrampoline<T, true> {\n                static void Call(SameThreadEnabledCheckingPolicy* policy, const T* ptr) {\n                  policy->CheckPointerImpl(ptr, IsGarbageCollectedTypeV<T>,\n                                           kCheckOffHeapAssignments);\n                }\n              };\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DisabledCheckingPolicy\",\n                \"about\": \"Policy that disables pointer validity checks.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"RawPointer\",\n                    \"CompressedPointer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class DisabledCheckingPolicy {\n             protected:\n              template <typename T>\n              V8_INLINE void CheckPointer(T*) {}\n              template <typename T>\n              V8_INLINE void CheckPointer(RawPointer) {}\n            #if defined(CPPGC_POINTER_COMPRESSION)\n              template <typename T>\n              V8_INLINE void CheckPointer(CompressedPointer) {}\n            #endif\n            };\n        ]]></code>\n    </class>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"DefaultMemberCheckingPolicy\",\n                \"type\": \"SameThreadEnabledCheckingPolicy<false>\",\n                \"about\": \"Default checking policy for members (no off-heap assignment checks).\",\n                \"dependencies\": [\n                    \"SameThreadEnabledCheckingPolicy\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            #ifdef CPPGC_ENABLE_SLOW_API_CHECKS\n            // Off heap members are not connected to object graph and thus cannot ressurect\n            // dead objects.\n            using DefaultMemberCheckingPolicy =\n                SameThreadEnabledCheckingPolicy<false /* kCheckOffHeapAssignments*/>;\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"DefaultPersistentCheckingPolicy\",\n                \"type\": \"SameThreadEnabledCheckingPolicy<true>\",\n                \"about\": \"Default checking policy for persistent handles (with off-heap assignment checks).\",\n                \"dependencies\": [\n                    \"SameThreadEnabledCheckingPolicy\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using DefaultPersistentCheckingPolicy =\n                SameThreadEnabledCheckingPolicy<true /* kCheckOffHeapAssignments*/>;\n        ]]></code>\n    </typedef>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"DefaultCrossThreadPersistentCheckingPolicy\",\n                \"type\": \"DisabledCheckingPolicy\",\n                \"about\": \"Default checking policy for cross-thread persistent handles (disabled).\",\n                \"dependencies\": [\n                    \"DisabledCheckingPolicy\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n        #else   // !CPPGC_ENABLE_SLOW_API_CHECKS\n        using DefaultMemberCheckingPolicy = DisabledCheckingPolicy;\n        using DefaultPersistentCheckingPolicy = DisabledCheckingPolicy;\n        #endif  // !CPPGC_ENABLE_SLOW_API_CHECKS\n        // For CT(W)P neither marking information (for value), nor objectstart bitmap\n        // (for slot) are guaranteed to be present because there's no synchronization\n        // between heaps after marking.\n        using DefaultCrossThreadPersistentCheckingPolicy = DisabledCheckingPolicy;\n        ]]></code>\n    </typedef>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"KeepLocationPolicy\",\n                \"about\": \"Policy that keeps track of the source location.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"location_\",\n                        \"type\": \"SourceLocation\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the source location.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"SourceLocation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class KeepLocationPolicy {\n             public:\n              constexpr const SourceLocation& Location() const { return location_; }\n\n             protected:\n              constexpr KeepLocationPolicy() = default;\n              constexpr explicit KeepLocationPolicy(const SourceLocation& location)\n                  : location_(location) {}\n\n              // KeepLocationPolicy must not copy underlying source locations.\n              KeepLocationPolicy(const KeepLocationPolicy&) = delete;\n              KeepLocationPolicy& operator=(const KeepLocationPolicy&) = delete;\n\n              // Location of the original moved from object should be preserved.\n              KeepLocationPolicy(KeepLocationPolicy&&) = default;\n              KeepLocationPolicy& operator=(KeepLocationPolicy&&) = default;\n\n             private:\n              SourceLocation location_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"IgnoreLocationPolicy\",\n                \"about\": \"Policy that ignores the source location.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"SourceLocation\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class IgnoreLocationPolicy {\n             public:\n              constexpr SourceLocation Location() const { return {}; }\n\n             protected:\n              constexpr IgnoreLocationPolicy() = default;\n              constexpr explicit IgnoreLocationPolicy(const SourceLocation&) {}\n            };\n        ]]></code>\n    </class>\n\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"DefaultLocationPolicy\",\n                \"type\": \"KeepLocationPolicy or IgnoreLocationPolicy\",\n                \"about\": \"Default location policy, defined based on CPPGC_SUPPORTS_OBJECT_NAMES.\",\n                \"dependencies\": [\n                    \"KeepLocationPolicy\",\n                    \"IgnoreLocationPolicy\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            #if CPPGC_SUPPORTS_OBJECT_NAMES\n            using DefaultLocationPolicy = KeepLocationPolicy;\n            #else\n            using DefaultLocationPolicy = IgnoreLocationPolicy;\n            #endif\n        ]]></code>\n    </typedef>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"StrongPersistentPolicy\",\n                \"about\": \"Policy for strong persistent handles.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"PersistentRegion\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct StrongPersistentPolicy {\n              using IsStrongPersistent = std::true_type;\n              static V8_EXPORT PersistentRegion& GetPersistentRegion(const void* object);\n            };\n        ]]></code>\n    </struct>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"WeakPersistentPolicy\",\n                \"about\": \"Policy for weak persistent handles.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"PersistentRegion\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct WeakPersistentPolicy {\n              using IsStrongPersistent = std::false_type;\n              static V8_EXPORT PersistentRegion& GetPersistentRegion(const void* object);\n            };\n        ]]></code>\n    </struct>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"StrongCrossThreadPersistentPolicy\",\n                \"about\": \"Policy for strong cross-thread persistent handles.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"CrossThreadPersistentRegion\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct StrongCrossThreadPersistentPolicy {\n              using IsStrongPersistent = std::true_type;\n              static V8_EXPORT CrossThreadPersistentRegion& GetPersistentRegion(\n                  const void* object);\n            };\n        ]]></code>\n    </struct>\n\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"WeakCrossThreadPersistentPolicy\",\n                \"about\": \"Policy for weak cross-thread persistent handles.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"CrossThreadPersistentRegion\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct WeakCrossThreadPersistentPolicy {\n              using IsStrongPersistent = std::false_type;\n              static V8_EXPORT CrossThreadPersistentRegion& GetPersistentRegion(\n                  const void* object);\n            };\n        ]]></code>\n    </struct>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BasicCrossThreadPersistent\",\n                \"about\": \"Forward declaration for BasicCrossThreadPersistent.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            // Forward declarations setting up the default policies.\n            template <typename T, typename WeaknessPolicy,\n                      typename LocationPolicy = DefaultLocationPolicy,\n                      typename CheckingPolicy = DefaultCrossThreadPersistentCheckingPolicy>\n            class BasicCrossThreadPersistent;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BasicPersistent\",\n                \"about\": \"Forward declaration for BasicPersistent.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessPolicy,\n                      typename LocationPolicy = DefaultLocationPolicy,\n                      typename CheckingPolicy = DefaultPersistentCheckingPolicy>\n            class BasicPersistent;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BasicMember\",\n                \"about\": \"Forward declaration for BasicMember.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                      typename CheckingPolicy = DefaultMemberCheckingPolicy,\n                      typename StorageType = DefaultMemberStorage>\n            class BasicMember;\n        ]]></code>\n    </class>\n</file>\n```"
}