{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/bytecode-offset-iterator.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 111, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/bytecode-offset-iterator.h\",\n        \"file_name\": \"bytecode-offset-iterator.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides an iterator to map bytecode offsets to PC offsets in a BytecodeArray, using a TrustedByteArray for the mapping table.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library and V8 headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/vlq.h\"\n#include \"src/common/globals.h\"\n#include \"src/interpreter/bytecode-array-iterator.h\"\n#include \"src/objects/bytecode-array.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BytecodeOffsetIterator\",\n            \"about\": \"Iterates through bytecode offsets and their corresponding PC offsets.\",\n            \"attributes\": [\n                {\n                    \"name\": \"mapping_table_\",\n                    \"type\": \"Handle<TrustedByteArray>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Handle to the TrustedByteArray containing the offset mapping.\"\n                },\n                {\n                    \"name\": \"data_start_address_\",\n                    \"type\": \"uint8_t*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the start of the data within the TrustedByteArray.\"\n                },\n                {\n                    \"name\": \"data_length_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Length of the data in the TrustedByteArray.\"\n                },\n                {\n                    \"name\": \"current_index_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Current index within the data.\"\n                },\n                {\n                    \"name\": \"current_pc_start_offset_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The PC offset where current bytecode starts.\"\n                },\n                {\n                    \"name\": \"current_pc_end_offset_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The PC offset where current bytecode ends.\"\n                },\n                {\n                    \"name\": \"current_bytecode_offset_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Current bytecode offset.\"\n                },\n                {\n                    \"name\": \"bytecode_handle_storage_\",\n                    \"type\": \"Tagged<BytecodeArray>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the bytecode array.\"\n                },\n                {\n                    \"name\": \"bytecode_iterator_\",\n                    \"type\": \"interpreter::BytecodeArrayIterator\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Iterator for traversing the BytecodeArray.\"\n                },\n                 {\n                    \"name\": \"local_heap_\",\n                    \"type\": \"LocalHeap*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Local heap for GC.\"\n                },\n                 {\n                    \"name\": \"no_gc_\",\n                    \"type\": \"std::optional<DisallowGarbageCollection>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Disallows garbage collection.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TrustedByteArray\",\n                \"BytecodeArray\",\n                \"interpreter::BytecodeArrayIterator\",\n                \"base::VLQDecodeUnsigned\",\n                \"Address\",\n                \"LocalHeap\",\n                \"DisallowGarbageCollection\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE BytecodeOffsetIterator {\n public:\n  explicit BytecodeOffsetIterator(Handle<TrustedByteArray> mapping_table,\n                                  Handle<BytecodeArray> bytecodes);\n  // Non-handlified version for use when no GC can happen.\n  explicit BytecodeOffsetIterator(Tagged<TrustedByteArray> mapping_table,\n                                  Tagged<BytecodeArray> bytecodes);\n  ~BytecodeOffsetIterator();\n\n  inline void Advance() {\n    DCHECK(!done());\n    current_pc_start_offset_ = current_pc_end_offset_;\n    current_pc_end_offset_ += ReadPosition();\n    current_bytecode_offset_ = bytecode_iterator_.current_offset();\n    bytecode_iterator_.Advance();\n  }\n\n  inline void AdvanceToBytecodeOffset(int bytecode_offset) {\n    while (current_bytecode_offset() < bytecode_offset) {\n      Advance();\n    }\n    DCHECK_EQ(bytecode_offset, current_bytecode_offset());\n  }\n\n  inline void AdvanceToPCOffset(Address pc_offset) {\n    while (current_pc_end_offset() < pc_offset) {\n      Advance();\n    }\n    DCHECK_GT(pc_offset, current_pc_start_offset());\n    DCHECK_LE(pc_offset, current_pc_end_offset());\n  }\n\n  // For this iterator, done() means that it is not safe to Advance().\n  // Values are cached, so reads are always allowed.\n  inline bool done() const { return current_index_ >= data_length_; }\n\n  inline Address current_pc_start_offset() const {\n    return current_pc_start_offset_;\n  }\n\n  inline Address current_pc_end_offset() const {\n    return current_pc_end_offset_;\n  }\n\n  inline int current_bytecode_offset() const {\n    return current_bytecode_offset_;\n  }\n\n  static void UpdatePointersCallback(void* iterator) {\n    reinterpret_cast<BytecodeOffsetIterator*>(iterator)->UpdatePointers();\n  }\n\n  void UpdatePointers();\n\n private:\n  void Initialize();\n  inline int ReadPosition() {\n    return base::VLQDecodeUnsigned(data_start_address_, &current_index_);\n  }\n\n  Handle<TrustedByteArray> mapping_table_;\n  uint8_t* data_start_address_;\n  int data_length_;\n  int current_index_;\n  Address current_pc_start_offset_;\n  Address current_pc_end_offset_;\n  int current_bytecode_offset_;\n  Tagged<BytecodeArray> bytecode_handle_storage_;\n  interpreter::BytecodeArrayIterator bytecode_iterator_;\n  LocalHeap* local_heap_;\n  std::optional<DisallowGarbageCollection> no_gc_;\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TrustedByteArray\",\n                \"about\": \"Represents an array of bytes that the VM trusts to be valid.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TrustedByteArray {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BytecodeArray\",\n                \"about\": \"An array containing bytecode instructions.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class BytecodeArray {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"interpreter::BytecodeArrayIterator\",\n                \"about\": \"Iterator for traversing a BytecodeArray.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace interpreter {\n                    class BytecodeArrayIterator {\n                    public:\n                        void Advance();\n                        int current_offset() const;\n                    };\n                }\n            ]]></code>\n        </class>\n         <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"base::VLQDecodeUnsigned\",\n                \"about\": \"Decodes a variable-length quantity (VLQ).\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"Decoded unsigned integer.\"\n                }\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base {\n                    int VLQDecodeUnsigned(uint8_t* data, int* index);\n                }\n            ]]></code>\n        </func>\n         <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalHeap\",\n                \"about\": \"Local heap to help with GC.\"\n            }\n            </metadata>\n            <code><![CDATA[\n               class LocalHeap {};\n            ]]></code>\n        </class>\n         <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DisallowGarbageCollection\",\n                \"about\": \"Helper class to disallow garbage collection during its lifetime.\"\n            }\n            </metadata>\n            <code><![CDATA[\n               class DisallowGarbageCollection {};\n            ]]></code>\n        </class>\n        <typedef>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"Address\",\n                \"about\": \"Represents a memory address.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                typedef uintptr_t Address;\n            ]]></code>\n        </typedef>\n    </dependencies>\n</file>\n```"
}