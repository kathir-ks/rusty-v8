{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8-test.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8-test.cc\",\n        \"file_name\": \"d8-test.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Exposes a d8.test.fast_c_api object for testing fast API calls in mjsunit tests.  It supports querying fast/slow call counts and resetting them.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for d8 functionality, fast API calls, templates, and general V8 API.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/d8/d8.h\"\n\n#include \"include/v8-fast-api-calls.h\"\n#include \"include/v8-template.h\"\n#include \"src/api/api-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FastCApiObject\",\n            \"about\": \"Provides testing facilities for fast API calls, including counting fast/slow calls and throwing exceptions.\",\n            \"attributes\": [\n                {\n                    \"name\": \"fast_call_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Counts the number of fast calls made to this object.\"\n                },\n                {\n                    \"name\": \"slow_call_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Counts the number of slow calls made to this object.\"\n                },\n                {\n                    \"name\": \"attribute_value_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores a test attribute value, settable and gettable via fast/slow API calls.\"\n                },\n                {\n                    \"name\": \"supports_fp_params_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the system supports floating-point parameters in C linkage.\"\n                }\n            ],\n            \"dependencies\": [\n                \"v8::Isolate\",\n                \"v8::Local\",\n                \"v8::Object\",\n                \"v8::FunctionCallbackInfo\",\n                \"v8::Value\",\n                \"v8::Context\",\n                \"v8::HandleScope\",\n                \"v8::Number\",\n                \"v8::Uint8Array\",\n                \"v8::FastOneByteString\",\n                \"v8::FastApiCallbackOptions\",\n                \"v8::TypedArray\",\n                \"v8::Array\",\n                \"v8::WasmMemoryObject\",\n                \"v8::String\",\n                \"v8::External\",\n                \"v8::BigInt\",\n                \"base::IsValueInRangeForNumericType\",\n                \"base::IsInRange\",\n                \"i::ValidateCallbackInfo\",\n                \"i::Internals\",\n                \"internal::ValueHelper\",\n                \"i::v8_flags\",\n                \"CTypeInfoBuilder\",\n                \"CFunction\",\n                \"Shell::CreateTestFastCApiTemplate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass FastCApiObject {\n public:\n  static FastCApiObject& instance();\n\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static AnyCType ThrowNoFallbackFastCallbackPatch(AnyCType receiver) {\n    AnyCType ret;\n    ThrowNoFallbackFastCallback(receiver.object_value);\n    return ret;\n  }\n\n#endif  //  V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n\n  static int ThrowNoFallbackFastCallback(Local<Object> receiver) {\n    FastCApiObject* self = UnwrapObject(receiver);\n    if (!self) {\n      self = &FastCApiObject::instance();\n    }\n    self->fast_call_count_++;\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    v8::HandleScope scope(isolate);\n    v8::Local<v8::Context> context = isolate->GetCurrentContext();\n    v8::Context::Scope context_scope(context);\n    isolate->ThrowError(\"Exception from fast callback\");\n    return 0;\n  }\n\n  static void ThrowFallbackSlowCallback(\n      const FunctionCallbackInfo<Value>& info) {\n    DCHECK(i::ValidateCallbackInfo(info));\n    FastCApiObject* self = UnwrapObject(info.This());\n    CHECK_SELF_OR_THROW_SLOW();\n    self->slow_call_count_++;\n\n    info.GetIsolate()->ThrowError(\"Exception from slow callback\");\n  }\n\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static AnyCType CopyStringFastCallbackPatch(AnyCType receiver,\n                                              AnyCType source, AnyCType out,\n                                              AnyCType options) {\n    AnyCType ret;\n    CopyStringFastCallback(receiver.object_value, *source.string_value,\n                           out.object_value, *options.options_value);\n    return ret;\n  }\n\n#endif  //  V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static void CopyStringFastCallback(Local<Object> receiver,\n                                     const FastOneByteString& source,\n                                     Local<Object> out,\n                                     FastApiCallbackOptions& options) {\n    FastCApiObject* self = UnwrapObject(receiver);\n    self->fast_call_count_++;\n\n    HandleScope handle_scope(options.isolate);\n    if (!out->IsUint8Array()) {\n      options.isolate->ThrowError(\n          \"Invalid parameter, the second parameter has to be a a Uint8Array.\");\n      return;\n    }\n    Local<Uint8Array> array = out.As<Uint8Array>();\n    if (array->Length() < source.length) {\n      options.isolate->ThrowError(\n          \"Invalid parameter, destination array is too small.\");\n      return;\n    }\n    uint8_t* memory =\n        reinterpret_cast<uint8_t*>(out.As<Uint8Array>()->Buffer()->Data());\n    memcpy(memory, source.data, source.length);\n  }\n\n  static void CopyStringSlowCallback(const FunctionCallbackInfo<Value>& info) {\n    FastCApiObject* self = UnwrapObject(info.This());\n    CHECK_SELF_OR_THROW_SLOW();\n    self->slow_call_count_++;\n  }\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static AnyCType AddAllFastCallbackPatch(AnyCType receiver,\n                                          AnyCType arg_i32, AnyCType arg_u32,\n                                          AnyCType arg_i64, AnyCType arg_u64,\n                                          AnyCType arg_f32, AnyCType arg_f64,\n                                          AnyCType options) {\n    AnyCType ret;\n    ret.double_value = AddAllFastCallback(\n        receiver.object_value, arg_i32.int32_value, arg_u32.uint32_value,\n        arg_i64.int64_value, arg_u64.uint64_value, arg_f32.float_value,\n        arg_f64.double_value, *options.options_value);\n    return ret;\n  }\n\n#endif  //  V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static double AddAllFastCallback(Local<Object> receiver, int32_t arg_i32,\n                                   uint32_t arg_u32, int64_t arg_i64,\n                                   uint64_t arg_u64, float arg_f32,\n                                   double arg_f64,\n                                   FastApiCallbackOptions& options) {\n    FastCApiObject* self = UnwrapObject(receiver);\n    CHECK_SELF_OR_THROW_FAST_OPTIONS(0);\n    self->fast_call_count_++;\n\n    return static_cast<double>(arg_i32) + static_cast<double>(arg_u32) +\n           static_cast<double>(arg_i64) + static_cast<double>(arg_u64) +\n           static_cast<double>(arg_f32) + arg_f64;\n  }\n\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static AnyCType AddAllFastCallbackNoOptionsPatch(\n      AnyCType receiver, AnyCType arg_i32, AnyCType arg_u32, AnyCType arg_i64,\n      AnyCType arg_u64, AnyCType arg_f32, AnyCType arg_f64) {\n    AnyCType ret;\n    ret.double_value = AddAllFastCallbackNoOptions(\n        receiver.object_value, arg_i32.int32_value, arg_u32.uint32_value,\n        arg_i64.int64_value, arg_u64.uint64_value, arg_f32.float_value,\n        arg_f64.double_value);\n    return ret;\n  }\n#endif  //  V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static double AddAllFastCallbackNoOptions(Local<Object> receiver,\n                                            int32_t arg_i32, uint32_t arg_u32,\n                                            int64_t arg_i64, uint64_t arg_u64,\n                                            float arg_f32, double arg_f64) {\n    FastCApiObject* self = UnwrapObject(receiver);\n    if (!self) {\n      self = &FastCApiObject::instance();\n    }\n    self->fast_call_count_++;\n\n    return static_cast<double>(arg_i32) + static_cast<double>(arg_u32) +\n           static_cast<double>(arg_i64) + static_cast<double>(arg_u64) +\n           static_cast<double>(arg_f32) + arg_f64;\n  }\n\n  static void AddAllSlowCallback(const FunctionCallbackInfo<Value>& info) {\n    Isolate* isolate = info.GetIsolate();\n\n    FastCApiObject* self = UnwrapObject(info.This());\n    CHECK_SELF_OR_THROW_SLOW();\n    self->slow_call_count_++;\n\n    HandleScope handle_scope(isolate);\n\n    double sum = 0;\n    if (info.Length() > 0 && info[0]->IsNumber()) {\n      sum += info[0]->Int32Value(isolate->GetCurrentContext()).FromJust();\n    }\n    if (info.Length() > 1 && info[1]->IsNumber()) {\n      sum += info[1]->Uint32Value(isolate->GetCurrentContext()).FromJust();\n    }\n    if (info.Length() > 2 && info[2]->IsNumber()) {\n      sum += info[2]->IntegerValue(isolate->GetCurrentContext()).FromJust();\n    }\n    if (info.Length() > 3 && info[3]->IsNumber()) {\n      sum += info[3]->IntegerValue(isolate->GetCurrentContext()).FromJust();\n    }\n    if (info.Length() > 4 && info[4]->IsNumber()) {\n      sum += info[4]->NumberValue(isolate->GetCurrentContext()).FromJust();\n    } else {\n      sum += std::numeric_limits<double>::quiet_NaN();\n    }\n    if (info.Length() > 5 && info[5]->IsNumber()) {\n      sum += info[5]->NumberValue(isolate->GetCurrentContext()).FromJust();\n    } else {\n      sum += std::numeric_limits<double>::quiet_NaN();\n    }\n\n    info.GetReturnValue().Set(Number::New(isolate, sum));\n  }\n\n#ifdef V8_ENABLE_FP_PARAMS_IN_C_LINKAGE\n  typedef double Type;\n#else\n  typedef int32_t Type;\n#endif  // V8_ENABLE_FP_PARAMS_IN_C_LINKAGE\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static AnyCType AddAllSequenceFastCallbackPatch(AnyCType receiver,\n                                                  AnyCType seq_arg,\n                                                  AnyCType options) {\n    AnyCType ret;\n#ifdef V8_ENABLE_FP_PARAMS_IN_C_LINKAGE\n    ret.double_value = AddAllSequenceFastCallback(\n        receiver.object_value, seq_arg.sequence_value, *options.options_value);\n#else\n    ret.int32_value = AddAllSequenceFastCallback(\n        receiver.object_value, seq_arg.sequence_value, *options.options_value);\n#endif  // V8_ENABLE_FP_PARAMS_IN_C_LINKAGE\n    return ret;\n  }\n#endif  //  V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n\n  static Type AddAllSequenceJSArrayHelper(v8::Isolate* isolate,\n                                          Local<Array> seq_arg) {\n    Type sum = 0;\n    uint32_t length = seq_arg->Length();\n    if (length > 1024) {\n      isolate->ThrowError(\n          \"Invalid length of array, must be between 0 and 1024.\");\n      return sum;\n    }\n\n    for (uint32_t i = 0; i < length; ++i) {\n      v8::MaybeLocal<v8::Value> maybe_element =\n          seq_arg->Get(isolate->GetCurrentContext(),\n                       v8::Integer::NewFromUnsigned(isolate, i));\n      if (maybe_element.IsEmpty()) return sum;\n\n      v8::Local<v8::Value> element = maybe_element.ToLocalChecked();\n      if (element->IsNumber()) {\n        double value = element->ToNumber(isolate->GetCurrentContext())\n                           .ToLocalChecked()\n                           ->Value();\n        sum += value;\n      } else if (element->IsUndefined()) {\n        // Hole: ignore the element.\n      } else {\n        isolate->ThrowError(\"unexpected element type in JSArray\");\n        return sum;\n      }\n    }\n    return sum;\n  }\n\n  static Type AddAllSequenceFastCallback(Local<Object> receiver,\n                                         Local<Object> seq_arg,\n                                         FastApiCallbackOptions& options) {\n    if (seq_arg->IsUint32Array()) {\n      return AddAllTypedArrayFastCallback<uint32_t>(receiver, seq_arg, options);\n    }\n\n    FastCApiObject* self = UnwrapObject(receiver);\n    CHECK_SELF_OR_THROW_FAST_OPTIONS(0);\n    self->fast_call_count_++;\n\n    HandleScope handle_scope(options.isolate);\n    if (!seq_arg->IsArray()) {\n      options.isolate->ThrowError(\n          \"This method expects an array as a first argument.\");\n      return 0;\n    }\n    Local<Array> array = seq_arg.As<Array>();\n    uint32_t length = array->Length();\n    if (length > 1024) {\n      receiver->GetIsolate()->ThrowError(\n          \"Invalid length of array, must be between 0 and 1024.\");\n      return 0;\n    }\n\n    Type buffer[1024];\n    bool result = TryToCopyAndConvertArrayToCppBuffer<\n        CTypeInfoBuilder<Type>::Build().GetId(), Type>(array, buffer, 1024);\n    if (!result) {\n      return AddAllSequenceJSArrayHelper(receiver->GetIsolate(), array);\n    }\n    DCHECK_EQ(array->Length(), length);\n\n    Type sum = 0;\n    for (uint32_t i = 0; i < length; ++i) {\n      sum += buffer[i];\n    }\n\n    return sum;\n  }\n\n  static void AddAllSequenceSlowCallback(\n      const FunctionCallbackInfo<Value>& info) {\n    DCHECK(i::ValidateCallbackInfo(info));\n    Isolate* isolate = info.GetIsolate();\n\n    FastCApiObject* self = UnwrapObject(info.This());\n    CHECK_SELF_OR_THROW_SLOW();\n\n    HandleScope handle_scope(isolate);\n\n    if (info.Length() < 1) {\n      self->slow_call_count_++;\n      isolate->ThrowError(\"This method expects at least 1 arguments.\");\n      return;\n    }\n    if (info[0]->IsTypedArray()) {\n      AddAllTypedArraySlowCallback(info);\n      return;\n    }\n    if (info[0]->IsNumber()) {\n      AddAllSlowCallback(info);\n      return;\n    }\n    self->slow_call_count_++;\n    if (info[0]->IsUndefined()) {\n      Type dummy_result = 0;\n      info.GetReturnValue().Set(Number::New(isolate, dummy_result));\n      return;\n    }\n    if (!info[0]->IsArray()) {\n      isolate->ThrowError(\"This method expects an array as a first argument.\");\n      return;\n    }\n    Local<Array> seq_arg = info[0].As<Array>();\n    Type sum = AddAllSequenceJSArrayHelper(isolate, seq_arg);\n\n    info.GetReturnValue().Set(Number::New(isolate, sum));\n  }\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n\n  template <typename T>\n  static AnyCType AddAllTypedArrayFastCallbackPatch(AnyCType receiver,\n                                                    AnyCType typed_array_arg,\n                                                    AnyCType options) {\n    AnyCType ret;\n#ifdef V8_ENABLE_FP_PARAMS_IN_C_LINKAGE\n    ret.double_value = AddAllTypedArrayFastCallback<T>(\n        receiver.object_value, typed_array_arg.object_value,\n        *options.options_value);\n#else\n    ret.int32_value = AddAllTypedArrayFastCallback<T>(\n        receiver.object_value, typed_array_arg.object_value,\n        *options.options_value);\n#endif  // V8_ENABLE_FP_PARAMS_IN_C_LINKAGE\n    return ret;\n  }\n#endif  //  V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  template <typename T>\n  static Type AddAllTypedArrayFastCallback(Local<Object> receiver,\n                                           Local<Value> typed_array_arg,\n                                           FastApiCallbackOptions& options) {\n    FastCApiObject* self = UnwrapObject(receiver);\n    CHECK_SELF_OR_THROW_FAST_OPTIONS(0);\n    self->fast_call_count_++;\n\n    HandleScope handle_scope(options.isolate);\n    if (!typed_array_arg->IsTypedArray()) {\n      options.isolate->ThrowError(\n          \"This method expects a TypedArray as a first argument.\");\n      return 0;\n    }\n    T* memory = reinterpret_cast<T*>(\n        typed_array_arg.As<TypedArray>()->Buffer()->Data());\n    size_t length = typed_array_arg.As<TypedArray>()->ByteLength() / sizeof(T);\n    double sum = 0;\n    for (size_t i = 0; i < length; ++i) {\n      sum += static_cast<double>(memory[i]);\n    }\n    return static_cast<Type>(sum);\n  }\n\n  static void AddAllTypedArraySlowCallback(\n      const FunctionCallbackInfo<Value>& info) {\n    DCHECK(i::ValidateCallbackInfo(info));\n    Isolate* isolate = info.GetIsolate();\n\n    FastCApiObject* self = UnwrapObject(info.This());\n    CHECK_SELF_OR_THROW_SLOW();\n    self->slow_call_count_++;\n\n    HandleScope handle_scope(isolate);\n\n    if (info.Length() < 1) {\n      isolate->ThrowError(\"This method expects at least 1 arguments.\");\n      return;\n    }\n    if (!info[0]->IsTypedArray()) {\n      isolate->ThrowError(\n          \"This method expects a TypedArray as a second argument.\");\n      return;\n    }\n\n    Local<TypedArray> typed_array_arg = info[0].As<TypedArray>();\n    size_t length = typed_array_arg->Length();\n\n    void* data = typed_array_arg->Buffer()->GetBackingStore()->Data();\n    if (typed_array_arg->IsUint8Array() || typed_array_arg->IsInt32Array() ||\n        typed_array_arg->IsUint32Array() ||\n        typed_array_arg->IsBigInt64Array() ||\n        typed_array_arg->IsBigUint64Array()) {\n      int64_t sum = 0;\n      for (unsigned i = 0; i < length; ++i) {\n        if (typed_array_arg->IsUint8Array()) {\n          sum += static_cast<uint8_t*>(data)[i];\n        } else if (typed_array_arg->IsInt32Array()) {\n          sum += static_cast<int32_t*>(data)[i];\n        } else if (typed_array_arg->IsUint32Array()) {\n          sum += static_cast<uint32_t*>(data)[i];\n        } else if (typed_array_arg->IsBigInt64Array()) {\n          sum += static_cast<int64_t*>(data)[i];\n        } else if (typed_array_arg->IsBigUint64Array()) {\n          sum += static_cast<uint64_t*>(data)[i];\n        }\n      }\n      info.GetReturnValue().Set(Number::New(isolate, sum));\n    } else if (typed_array_arg->IsFloat32Array() ||\n               typed_array_arg->IsFloat64Array()) {\n      double sum = 0;\n      for (unsigned i = 0; i < length; ++i) {\n        if (typed_array_arg->IsFloat32Array()) {\n          sum += static_cast<float*>(data)[i];\n        } else if (typed_array_arg->IsFloat64Array()) {\n          sum += static_cast<double*>(data)[i];\n        }\n      }\n      info.GetReturnValue().Set(Number::New(isolate, sum));\n    } else {\n      isolate->ThrowError(\"TypedArray type is not supported.\");\n      return;\n    }\n  }\n\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static AnyCType Add32BitIntFastCallbackPatch(AnyCType receiver,\n                                               AnyCType arg_i32,\n                                               AnyCType arg_u32,\n                                               AnyCType options) {\n    AnyCType ret;\n    ret.int32_value =\n        Add32BitIntFastCallback(receiver.object_value, arg_i32.int32_value,\n                                arg_u32.uint32_value, *options.options_value);\n    return ret;\n  }\n#endif  //  V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n\n  static int Add32BitIntFastCallback(v8::Local<v8::Object> receiver,\n                                     int32_t arg_i32, uint32_t arg_u32,\n                                     FastApiCallbackOptions& options) {\n    FastCApiObject* self = UnwrapObject(receiver);\n    CHECK_SELF_OR_THROW_FAST_OPTIONS(0);\n    self->fast_call_count_++;\n\n    return arg_i32 + arg_u32;\n  }\n  static void Add32BitIntSlowCallback(const FunctionCallbackInfo<Value>& info) {\n    DCHECK(i::ValidateCallbackInfo(info));\n    Isolate* isolate = info.GetIsolate();\n\n    FastCApiObject* self = UnwrapObject(info.This());\n    CHECK_SELF_OR_THROW_SLOW();\n    self->slow_call_count_++;\n\n    HandleScope handle_scope(isolate);\n\n    double sum = 0;\n    if (info.Length() > 0 && info[0]->IsNumber()) {\n      sum += info[0]->Int32Value(isolate->GetCurrentContext()).FromJust();\n    }\n    if (info.Length() > 1 && info[1]->IsNumber()) {\n      sum += info[1]->Uint32Value(isolate->GetCurrentContext()).FromJust();\n    }\n\n    info.GetReturnValue().Set(Number::New(isolate, sum));\n  }\n\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  static AnyCType AddAll32BitIntFastCallback_8ArgsPatch(\n      AnyCType receiver, AnyCType arg1_i32, AnyCType arg2_i32,\n      AnyCType arg3_i32, AnyCType arg4_u32, AnyCType arg5_u32,\n      AnyCType arg6_u32, AnyCType arg7_u32, AnyCType arg8_u32,\n      AnyCType options) {\n    AnyCType ret;\n    ret.int32_value = AddAll32BitIntFastCallback_8Args(\n        receiver.object_value, arg1_i32.int32_value, arg2_i32.int32_value,\n        arg3_i32.int32_value, arg4_u32.uint32_value, arg5_u32.uint32_value,\n        arg6_u32.uint32_value, arg7_u32.uint32_value, arg8_u32.uint32_value,\n        *options.options_value);\n    return ret;\n  }\n  static AnyCType AddAll32BitIntFastCallback_6ArgsPatch(\n      AnyCType receiver, AnyCType arg1_i32, AnyCType arg2_i32,\n      AnyCType arg3_i32, AnyCType arg4_u32, AnyCType arg5_u32,\n      AnyCType arg6_u32, AnyCType options) {\n    AnyCType ret;\n    ret.int32_value = AddAll32BitIntFastCallback_6Args(\n        receiver.object_value, arg1_i32.int32_value, arg2_i32.int32_value,\n        arg3_i32.int32_value, arg4_u32.uint32_value, arg5_u32.uint32_value,\n        arg6_u32.uint32_value, *options.options_value);\n    return ret;\n  }\n  static AnyCType AddAll32BitIntFastCallback_5ArgsPatch(\n      AnyCType receiver, AnyCType arg1_i32, AnyCType arg2_i32,\n      AnyCType arg3_i32, AnyCType arg4_u32, AnyCType arg5_u32,\n      AnyCType options) {\n    AnyCType arg6;\n    arg6.uint32_value = 0;\n    return AddAll32BitIntFastCallback_6ArgsPatch(receiver, arg1_i32, arg2_i32,\n                                                 arg3_i32, arg4_u32, arg5_u32,\n                                                 arg6, options);\n  }\n#endif  //  V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n\n  static int AddAll32BitIntFastCallback_8Args(\n      Local<Object> receiver, int32_t arg1_i32, int32_t arg2_i32,\n      int32_t arg3_i32, uint32_t arg4_u32, uint32_t arg5_u32, uint32_t arg6_u32,\n      uint32_t arg7_u32, uint32_t arg8_u32, FastApiCallbackOptions& options) {\n    FastCApiObject* self = UnwrapObject(receiver);\n    CHECK_SELF_OR_THROW_FAST_OPTIONS(0);\n    self->fast_call_count_++;\n\n    int64_t result = static_cast<int64_t>(arg1_i32) + arg2_i32 + arg3_i32 +\n                     arg4_u32 + arg5_u32 + arg6_u32 + arg7_u32 + arg8_u32;\n    if (result > INT_MAX) return INT_MAX;\n    if (result < INT_MIN) return INT_MIN;\n    return static_cast<int>(result);\n  }\n  static int AddAll32BitIntFastCallback_6Args(\n      Local<Object> receiver, int32_t arg1_i32, int32_t arg2_i32,\n      int32_t arg3_i32, uint32_t arg4_u32, uint32_t arg5_u32, uint32_t arg6_u32,\n      FastApiCallbackOptions& options) {\n    FastCApiObject* self = UnwrapObject(receiver);\n    CHECK_SELF_OR_THROW_FAST_OPTIONS(0);\n    self->fast_call_count_++;\n\n    int64_t result = static_cast<int64_t>(arg1_i32) + arg2_i32 + arg3_i32 +\n                     arg4_u32 + arg5_u32 + arg6_u32;\n    if (result > INT_MAX) return INT_MAX;\n    if (result < INT_MIN) return INT_MIN;\n    return static_cast<int>(result);\n  }\n  static int AddAll32BitIntFastCallback_5Args(\n      Local<Object> receiver, int32_t arg1_i32, int32_t arg2_i32,\n      int32_t arg3_i32, uint32_t arg4_u32, uint32_t arg5_u32,\n      FastApiCallbackOptions& options) {\n    return AddAll32BitIntFastCallback_6Args(\n        receiver, arg1_i32, arg2_i32, arg3_i32, arg4_u32, arg5_u32, 0, options);\n  }\n  static void AddAll32BitIntSlowCallback(\n      const FunctionCallbackInfo<Value>& info) {\n    DCHECK(i::ValidateCallbackInfo(info));\n    Isolate* isolate = info.GetIsolate();\n\n    FastCApiObject* self = UnwrapObject(info.This());\n    CHECK_SELF_OR_THROW_SLOW();\n    self->slow_call_count_++;\n\n    HandleScope handle_scope(isolate);\n\n    Local<Context> context = isolate->GetCurrentContext();\n    double sum = 0;\n    if (info.Length() > 0 && info[0]->IsNumber()) {\n      sum += info[0]->Int32Value(context).FromJust();\n    }\n    if (info.Length() > 1 && info[1]->IsNumber()) {\n      sum += info[1]->Int32Value(context).FromJust();\n    }\n    if (info.Length() > 2 && info[2]->IsNumber()) {\n      sum += info[2]->Int32Value(context).FromJust();\n    }\n    if (info.Length() > 3 && info[3]->IsNumber()) {\n      sum += info[3]->Uint32Value(context).FromJust();\n    }\n    if (info.Length() > 4 && info[4]->IsNumber()) {\n      sum += info[4]->Uint32Value(context).FromJust();\n    }\n    if (info.Length() > 5 && info[5]->IsNumber()) {\n      sum += info[5]->Uint32Value(context).FromJust();\n    }\n    if (info.Length() > 7 && info[6]->IsNumber() && info[7]->IsNumber()) {\n      // info[6] and info[7] only get handled together, because we want to\n      // have functions in the list of overloads with 6 parameters and with 8\n      // parameters, but not with 7 parameters.\n      sum += info[6]->Uint32Value(context).FromJust();\n      sum += info[7]->Uint32Value(context).FromJust();\n    }\n\n    info.GetReturnValue().Set(Number::New(isolate, sum));\n  }\n\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  template <v8::CTypeInfo::Flags flags>\n  static AnyCType AddAllAnnotateFastCallbackPatch(\n      AnyCType receiver, AnyCType arg_i32, AnyCType arg_u32, AnyCType arg_i64,\n      AnyCType arg_u64, AnyCType options) {\n    AnyCType ret;\n    ret.double_value = AddAllAnnotateFastCallback<flags>(\n        receiver.object_value, arg_i32.int32_value, arg_u32.uint32_value,\n        arg_i64.int64_value, arg_u64.uint64_value, *options.options_value);\n    return ret;\n  }\n#endif  //  V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n\n  template <v8::CTypeInfo::Flags flags>\n  static double AddAllAnnotateFastCallback(Local<Object> receiver,\n                                           int32_t arg_i32, uint32_t arg_u32,\n                                           int64_t arg_i64, uint64_t arg_u6"
}