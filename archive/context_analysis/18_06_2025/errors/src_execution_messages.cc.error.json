{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/messages.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/messages.cc\",\n        \"file_name\": \"messages.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Handles JavaScript error messages, formatting, and stack traces within the V8 engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for various V8 functionalities such as API, AST, execution, handles, logging, objects, parsing, roots, and strings.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/messages.h\"\n\n#include <memory>\n\n#include \"src/api/api-inl.h\"\n#include \"src/ast/ast.h\"\n#include \"src/ast/prettyprinter.h\"\n#include \"src/execution/execution.h\"\n#include \"src/execution/frames-inl.h\"\n#include \"src/execution/frames.h\"\n#include \"src/execution/isolate-inl.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/handles/maybe-handles.h\"\n#include \"src/logging/runtime-call-stats-scope.h\"\n#include \"src/objects/call-site-info-inl.h\"\n#include \"src/objects/foreign-inl.h\"\n#include \"src/objects/js-array-inl.h\"\n#include \"src/objects/property-descriptor.h\"\n#include \"src/objects/struct-inl.h\"\n#include \"src/parsing/parse-info.h\"\n#include \"src/parsing/parsing.h\"\n#include \"src/roots/roots.h\"\n#include \"src/strings/string-builder-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MessageLocation\",\n            \"about\": \"Represents the location of a message within a script.\",\n            \"attributes\": [\n                {\n                    \"name\": \"script_\",\n                    \"type\": \"Handle<Script>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The script where the message originated.\"\n                },\n                {\n                    \"name\": \"start_pos_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The starting position of the message in the script.\"\n                },\n                {\n                    \"name\": \"end_pos_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The ending position of the message in the script.\"\n                },\n                {\n                    \"name\": \"bytecode_offset_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The bytecode offset of the message, if applicable.\"\n                },\n                {\n                    \"name\": \"shared_\",\n                    \"type\": \"Handle<SharedFunctionInfo>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Shared function info associated with the location.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Script\",\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMessageLocation::MessageLocation(Handle<Script> script, int start_pos,\n                                 int end_pos)\n    : script_(script),\n      start_pos_(start_pos),\n      end_pos_(end_pos),\n      bytecode_offset_(-1) {}\n\nMessageLocation::MessageLocation(Handle<Script> script, int start_pos,\n                                 int end_pos, Handle<SharedFunctionInfo> shared)\n    : script_(script),\n      start_pos_(start_pos),\n      end_pos_(end_pos),\n      bytecode_offset_(-1),\n      shared_(shared) {}\n\nMessageLocation::MessageLocation(Handle<Script> script,\n                                 Handle<SharedFunctionInfo> shared,\n                                 int bytecode_offset)\n    : script_(script),\n      start_pos_(-1),\n      end_pos_(-1),\n      bytecode_offset_(bytecode_offset),\n      shared_(shared) {}\n\nMessageLocation::MessageLocation()\n    : start_pos_(-1), end_pos_(-1), bytecode_offset_(-1) {}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DefaultMessageReport\",\n            \"parent\": \"MessageHandler\",\n            \"about\": \"The default message reporting function called when no message listeners are registered.\",\n            \"logic\": \"Prints the localized message to the console, including script name and position if available.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"loc\",\n                    \"type\": \"const MessageLocation*\",\n                    \"purpose\": \"The location of the message.\"\n                },\n                {\n                    \"name\": \"message_obj\",\n                    \"type\": \"DirectHandle<Object>\",\n                    \"purpose\": \"The message object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"GetLocalizedMessage\",\n                \"PrintF\",\n                \"IsString\",\n                \"Cast\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MessageHandler::DefaultMessageReport(Isolate* isolate,\n                                          const MessageLocation* loc,\n                                          DirectHandle<Object> message_obj) {\n  std::unique_ptr<char[]> str = GetLocalizedMessage(isolate, message_obj);\n  if (loc == nullptr) {\n    PrintF(\"%s\\n\", str.get());\n  } else {\n    HandleScope scope(isolate);\n    DirectHandle<Object> data(loc->script()->name(), isolate);\n    std::unique_ptr<char[]> data_str;\n    if (IsString(*data)) data_str = Cast<String>(data)->ToCString();\n    PrintF(\"%s:%i: %s\\n\", data_str ? data_str.get() : \"<unknown>\",\n           loc->start_pos(), str.get());\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MakeMessageObject\",\n            \"parent\": \"MessageHandler\",\n            \"about\": \"Creates a JSMessageObject for a given message template and location.\",\n            \"logic\": \"Constructs a JSMessageObject with information about the message, its location in the script, and the stack trace.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"message\",\n                    \"type\": \"MessageTemplate\",\n                    \"purpose\": \"The message template.\"\n                },\n                {\n                    \"name\": \"location\",\n                    \"type\": \"const MessageLocation*\",\n                    \"purpose\": \"The location of the message.\"\n                },\n                {\n                    \"name\": \"argument\",\n                    \"type\": \"DirectHandle<Object>\",\n                    \"purpose\": \"The argument associated with the message.\"\n                },\n                {\n                    \"name\": \"stack_trace\",\n                    \"type\": \"DirectHandle<StackTraceInfo>\",\n                    \"purpose\": \"The stack trace associated with the message.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Handle<JSMessageObject>\",\n                \"description\": \"The newly created JSMessageObject.\"\n            },\n            \"dependencies\": [\n                \"isolate->factory()->NewJSMessageObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nHandle<JSMessageObject> MessageHandler::MakeMessageObject(\n    Isolate* isolate, MessageTemplate message, const MessageLocation* location,\n    DirectHandle<Object> argument, DirectHandle<StackTraceInfo> stack_trace) {\n  int start = -1;\n  int end = -1;\n  int bytecode_offset = -1;\n  DirectHandle<Script> script_handle = isolate->factory()->empty_script();\n  DirectHandle<SharedFunctionInfo> shared_info;\n  if (location != nullptr && !v8_flags.correctness_fuzzer_suppressions) {\n    start = location->start_pos();\n    end = location->end_pos();\n    script_handle = location->script();\n    bytecode_offset = location->bytecode_offset();\n    shared_info = location->shared();\n  }\n\n  return isolate->factory()->NewJSMessageObject(message, argument, start, end,\n                                                shared_info, bytecode_offset,\n                                                script_handle, stack_trace);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReportMessage\",\n            \"parent\": \"MessageHandler\",\n            \"about\": \"Reports a message to registered listeners, handling exceptions and object stringification.\",\n            \"logic\": \"Converts the message to a v8::Message object and calls registered message listeners.  Handles exceptions thrown by listeners and converts object arguments to strings for reporting.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"loc\",\n                    \"type\": \"const MessageLocation*\",\n                    \"purpose\": \"The location of the message.\"\n                },\n                {\n                    \"name\": \"message\",\n                    \"type\": \"DirectHandle<JSMessageObject>\",\n                    \"purpose\": \"The message object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8::Utils::MessageToLocal\",\n                \"ReportMessageNoExceptions\",\n                \"isolate->has_exception\",\n                \"IsJSObject\",\n                \"Object::ToString\",\n                \"Object::NoSideEffectsToString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MessageHandler::ReportMessage(Isolate* isolate, const MessageLocation* loc,\n                                   DirectHandle<JSMessageObject> message) {\n  v8::Local<v8::Message> api_message_obj = v8::Utils::MessageToLocal(message);\n\n  if (api_message_obj->ErrorLevel() != v8::Isolate::kMessageError) {\n    ReportMessageNoExceptions(isolate, loc, message, v8::Local<v8::Value>());\n    return;\n  }\n\n  // We are calling into embedder's code which can throw exceptions.\n  // Thus we need to save current exception state, reset it to the clean one\n  // and ignore scheduled exceptions callbacks can throw.\n\n  // We pass the exception object into the message handler callback though.\n  DirectHandle<Object> exception = isolate->factory()->undefined_value();\n  if (isolate->has_exception()) {\n    exception = direct_handle(isolate->exception(), isolate);\n  }\n\n  Isolate::ExceptionScope exception_scope(isolate);\n  isolate->clear_pending_message();\n\n  // Turn the exception on the message into a string if it is an object.\n  if (IsJSObject(message->argument())) {\n    HandleScope scope(isolate);\n    DirectHandle<Object> argument(message->argument(), isolate);\n\n    MaybeDirectHandle<Object> maybe_stringified;\n    DirectHandle<Object> stringified;\n    // Make sure we don't leak uncaught internally generated Error objects.\n    if (IsJSError(*argument)) {\n      maybe_stringified = Object::NoSideEffectsToString(isolate, argument);\n    } else {\n      v8::TryCatch catcher(reinterpret_cast<v8::Isolate*>(isolate));\n      catcher.SetVerbose(false);\n      catcher.SetCaptureMessage(false);\n\n      maybe_stringified = Object::ToString(isolate, argument);\n    }\n\n    if (!maybe_stringified.ToHandle(&stringified)) {\n      isolate->clear_pending_message();\n      stringified = isolate->factory()->exception_string();\n    }\n    message->set_argument(*stringified);\n  }\n\n  v8::Local<v8::Value> api_exception_obj = v8::Utils::ToLocal(exception);\n  ReportMessageNoExceptions(isolate, loc, message, api_exception_obj);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReportMessageNoExceptions\",\n            \"parent\": \"MessageHandler\",\n            \"about\": \"Reports a message to registered listeners without handling exceptions in this function.\",\n            \"logic\": \"Iterates through registered message listeners and calls their callbacks. It handles the case where no listeners are registered by calling DefaultMessageReport.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"loc\",\n                    \"type\": \"const MessageLocation*\",\n                    \"purpose\": \"The location of the message.\"\n                },\n                {\n                    \"name\": \"message\",\n                    \"type\": \"DirectHandle<Object>\",\n                    \"purpose\": \"The message object.\"\n                },\n                {\n                    \"name\": \"api_exception_obj\",\n                    \"type\": \"v8::Local<v8::Value>\",\n                    \"purpose\": \"The exception object to pass to the listener.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8::Utils::MessageToLocal\",\n                \"DefaultMessageReport\",\n                \"IsUndefined\",\n                \"FUNCTION_CAST\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MessageHandler::ReportMessageNoExceptions(\n    Isolate* isolate, const MessageLocation* loc, DirectHandle<Object> message,\n    v8::Local<v8::Value> api_exception_obj) {\n  v8::Local<v8::Message> api_message_obj = v8::Utils::MessageToLocal(message);\n  int error_level = api_message_obj->ErrorLevel();\n\n  DirectHandle<ArrayList> global_listeners =\n      isolate->factory()->message_listeners();\n  int global_length = global_listeners->length();\n  if (global_length == 0) {\n    DefaultMessageReport(isolate, loc, message);\n  } else {\n    for (int i = 0; i < global_length; i++) {\n      HandleScope scope(isolate);\n      if (IsUndefined(global_listeners->get(i), isolate)) continue;\n      Tagged<FixedArray> listener = Cast<FixedArray>(global_listeners->get(i));\n      Tagged<Foreign> callback_obj = Cast<Foreign>(listener->get(0));\n      int32_t message_levels =\n          static_cast<int32_t>(Smi::ToInt(listener->get(2)));\n      if (!(message_levels & error_level)) {\n        continue;\n      }\n      v8::MessageCallback callback = FUNCTION_CAST<v8::MessageCallback>(\n          callback_obj->foreign_address<kMessageListenerTag>());\n      DirectHandle<Object> callback_data(listener->get(1), isolate);\n      {\n        RCS_SCOPE(isolate, RuntimeCallCounterId::kMessageListenerCallback);\n        // Do not allow exceptions to propagate.\n        v8::TryCatch try_catch(reinterpret_cast<v8::Isolate*>(isolate));\n        callback(api_message_obj, IsUndefined(*callback_data, isolate)\n                                      ? api_exception_obj\n                                      : v8::Utils::ToLocal(callback_data));\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetMessage\",\n            \"parent\": \"MessageHandler\",\n            \"about\": \"Retrieves the message string from a JSMessageObject.\",\n            \"logic\": \"Extracts the argument from the JSMessageObject and formats the message using MessageFormatter::Format.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"data\",\n                    \"type\": \"DirectHandle<Object>\",\n                    \"purpose\": \"The JSMessageObject.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DirectHandle<String>\",\n                \"description\": \"The formatted message string.\"\n            },\n            \"dependencies\": [\n                \"Cast<JSMessageObject>\",\n                \"MessageFormatter::Format\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<String> MessageHandler::GetMessage(Isolate* isolate,\n                                                DirectHandle<Object> data) {\n  DirectHandle<JSMessageObject> message = Cast<JSMessageObject>(data);\n  DirectHandle<Object> arg{message->argument(), isolate};\n  return MessageFormatter::Format(isolate, message->type(),\n                                  base::VectorOf({arg}));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetLocalizedMessage\",\n            \"parent\": \"MessageHandler\",\n            \"about\": \"Retrieves the localized message string from a JSMessageObject as a C-style string.\",\n            \"logic\": \"Calls GetMessage to get the message string and then converts it to a C-style string.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"data\",\n                    \"type\": \"DirectHandle<Object>\",\n                    \"purpose\": \"The JSMessageObject.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<char[]>\",\n                \"description\": \"The localized message string as a C-style string.\"\n            },\n            \"dependencies\": [\n                \"GetMessage\",\n                \"ToCString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<char[]> MessageHandler::GetLocalizedMessage(\n    Isolate* isolate, DirectHandle<Object> data) {\n  HandleScope scope(isolate);\n  return GetMessage(isolate, data)->ToCString();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetStackFrames\",\n            \"about\": \"Converts raw stack frames into a JSArray of JSCallSite objects.\",\n            \"logic\": \"Iterates through raw stack frames, creates JSCallSite objects for each frame, and returns them as a JSArray.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"frames\",\n                    \"type\": \"DirectHandle<FixedArray>\",\n                    \"purpose\": \"The raw stack frames.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MaybeDirectHandle<JSArray>\",\n                \"description\": \"A JSArray of JSCallSite objects, or an empty MaybeDirectHandle on exception.\"\n            },\n            \"dependencies\": [\n                \"isolate->callsite_function()\",\n                \"isolate->factory()->NewFixedArray\",\n                \"JSObject::New\",\n                \"JSObject::SetOwnPropertyIgnoreAttributes\",\n                \"isolate->factory()->call_site_info_symbol()\",\n                \"isolate->factory()->NewJSArrayWithElements\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMaybeDirectHandle<JSArray> GetStackFrames(Isolate* isolate,\n                                          DirectHandle<FixedArray> frames) {\n  int frame_count = frames->length();\n  DirectHandle<JSFunction> constructor = isolate->callsite_function();\n  DirectHandle<FixedArray> sites =\n      isolate->factory()->NewFixedArray(frame_count);\n  for (int i = 0; i < frame_count; ++i) {\n    DirectHandle<CallSiteInfo> frame(Cast<CallSiteInfo>(frames->get(i)),\n                                     isolate);\n    DirectHandle<JSObject> site;\n    ASSIGN_RETURN_ON_EXCEPTION(isolate, site,\n                               JSObject::New(constructor, constructor,\n                                             Handle<AllocationSite>::null()));\n    RETURN_ON_EXCEPTION(\n        isolate, JSObject::SetOwnPropertyIgnoreAttributes(\n                     site, isolate->factory()->call_site_info_symbol(), frame,\n                     DONT_ENUM));\n    sites->set(i, *site);\n  }\n\n  return isolate->factory()->NewJSArrayWithElements(sites);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AppendErrorString\",\n            \"about\": \"Appends the string representation of an error object to a string builder.\",\n            \"logic\": \"Tries to convert the error object to a string using ErrorUtils::ToString. If that fails, it attempts to convert the thrown exception to a string. If both fail, it appends '<error>' to the builder.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"error\",\n                    \"type\": \"DirectHandle<Object>\",\n                    \"purpose\": \"The error object.\"\n                },\n                {\n                    \"name\": \"builder\",\n                    \"type\": \"IncrementalStringBuilder*\",\n                    \"purpose\": \"The string builder to append to.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MaybeDirectHandle<Object>\",\n                \"description\": \"The original error object, or an empty MaybeDirectHandle on exception.\"\n            },\n            \"dependencies\": [\n                \"ErrorUtils::ToString\",\n                \"isolate->has_exception()\",\n                \"IncrementalStringBuilder::AppendCStringLiteral\",\n                \"IncrementalStringBuilder::AppendString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMaybeDirectHandle<Object> AppendErrorString(Isolate* isolate,\n                                            DirectHandle<Object> error,\n                                            IncrementalStringBuilder* builder) {\n  v8::TryCatch try_catch(reinterpret_cast<v8::Isolate*>(isolate));\n  try_catch.SetVerbose(false);\n  try_catch.SetCaptureMessage(false);\n  MaybeDirectHandle<String> err_str = ErrorUtils::ToString(\n      isolate, Cast<Object>(error),\n      ErrorUtils::ToStringMessageSource::kPreferOriginalMessage);\n  if (err_str.is_null()) {\n    // Error.toString threw. Try to return a string representation of the thrown\n    // exception instead.\n\n    DCHECK(isolate->has_exception());\n    if (isolate->is_execution_terminating()) {\n      return {};\n    }\n    DirectHandle<Object> exception(isolate->exception(), isolate);\n    try_catch.Reset();\n\n    err_str = ErrorUtils::ToString(\n        isolate, exception,\n        ErrorUtils::ToStringMessageSource::kPreferOriginalMessage);\n    if (err_str.is_null()) {\n      // Formatting the thrown exception threw again, give up.\n      DCHECK(isolate->has_exception());\n      if (isolate->is_execution_terminating()) return {};\n      builder->AppendCStringLiteral(\"<error>\");\n    } else {\n      // Formatted thrown exception successfully, append it.\n      builder->AppendCStringLiteral(\"<error: \");\n      builder->AppendString(err_str.ToHandleChecked());\n      builder->AppendCharacter('>');\n    }\n  } else {\n    builder->AppendString(err_str.ToHandleChecked());\n  }\n\n  return error;\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PrepareStackTraceScope\",\n            \"about\": \"A helper class to ensure that isolate's formatting_stack_trace flag is set correctly.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The V8 isolate.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_NODISCARD PrepareStackTraceScope {\n public:\n  explicit PrepareStackTraceScope(Isolate* isolate) : isolate_(isolate) {\n    DCHECK(!isolate_->formatting_stack_trace());\n    isolate_->set_formatting_stack_trace(true);\n  }\n\n  ~PrepareStackTraceScope() { isolate_->set_formatting_stack_trace(false); }\n\n  PrepareStackTraceScope(const PrepareStackTraceScope&) = delete;\n  PrepareStackTraceScope& operator=(const PrepareStackTraceScope&) = delete;\n\n private:\n  Isolate* isolate_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FormatStackTrace\",\n            \"parent\": \"ErrorUtils\",\n            \"about\": \"Formats a stack trace for an error object.\",\n            \"logic\": \"If a `prepareStackTrace` callback is present, calls it to format the stack trace. Otherwise, it uses internal formatting logic, including AppendErrorString for the message, and serializing the call site information for each frame.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"error\",\n                    \"type\": \"DirectHandle<JSObject>\",\n                    \"purpose\": \"The error object.\"\n                },\n                {\n                    \"name\": \"raw_stack\",\n                    \"type\": \"DirectHandle<Object>\",\n                    \"purpose\": \"The raw stack trace as a FixedArray.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MaybeDirectHandle<Object>\",\n                \"description\": \"The formatted stack trace as a string or an object, or an empty MaybeDirectHandle on exception.\"\n            },\n            \"dependencies\": [\n                \"v8_flags.correctness_fuzzer_suppressions\",\n                \"i::StackLimitCheck\",\n                \"error->GetCreationContext()\",\n                \"isolate->HasPrepareStackTraceCallback()\",\n                \"GetStackFrames\",\n                \"isolate->RunPrepareStackTraceCallback\",\n                \"JSFunction::GetProperty\",\n                \"Execution::Call\",\n                \"AppendErrorString\",\n                \"SerializeCallSiteInfo\",\n                \"ErrorUtils::ToString\",\n                \"IncrementalStringBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMaybeDirectHandle<Object> ErrorUtils::FormatStackTrace(\n    Isolate* isolate, DirectHandle<JSObject> error,\n    DirectHandle<Object> raw_stack) {\n  if (v8_flags.correctness_fuzzer_suppressions) {\n    return isolate->factory()->empty_string();\n  }\n  DCHECK(IsFixedArray(*raw_stack));\n  auto elems = Cast<FixedArray>(raw_stack);\n\n  const bool in_recursion = isolate->formatting_stack_trace();\n  const bool has_overflowed = i::StackLimitCheck{isolate}.HasOverflowed();\n  DirectHandle<NativeContext> error_context;\n  if (!in_recursion && !has_overflowed &&\n      error->GetCreationContext(isolate).ToHandle(&error_context)) {\n    if (isolate->HasPrepareStackTraceCallback()) {\n      PrepareStackTraceScope scope(isolate);\n\n      DirectHandle<JSArray> sites;\n      ASSIGN_RETURN_ON_EXCEPTION(isolate, sites,\n                                 GetStackFrames(isolate, elems));\n\n      DirectHandle<Object> result;\n      ASSIGN_RETURN_ON_EXCEPTION(\n          isolate, result,\n          isolate->RunPrepareStackTraceCallback(error_context, error, sites));\n      return result;\n    } else {\n      DirectHandle<JSFunction> global_error(error_context->error_function(),\n                                            isolate);\n\n      // If there's a user-specified \"prepareStackTrace\" function, call it on\n      // the frames and use its result.\n\n      DirectHandle<Object> prepare_stack_trace;\n      ASSIGN_RETURN_ON_EXCEPTION(\n          isolate, prepare_stack_trace,\n          JSFunction::GetProperty(isolate, global_error, \"prepareStackTrace\"));\n\n      if (IsJSFunction(*prepare_stack_trace)) {\n        PrepareStackTraceScope scope(isolate);\n\n        isolate->CountUsage(v8::Isolate::kErrorPrepareStackTrace);\n\n        DirectHandle<JSArray> sites;\n        ASSIGN_RETURN_ON_EXCEPTION(isolate, sites,\n                                   GetStackFrames(isolate, elems));\n\n        constexpr int argc = 2;\n        std::array<DirectHandle<Object>, argc> args;\n        if (V8_UNLIKELY(IsJSGlobalObject(*error))) {\n          // Pass global proxy instead of global object.\n          args[0] = direct_handle(Cast<JSGlobalObject>(*error)->global_proxy(),\n                                  isolate);\n        } else {\n          args[0] = error;\n        }\n        args[1] = sites;\n\n        DirectHandle<Object> result;\n\n        ASSIGN_RETURN_ON_EXCEPTION(\n            isolate, result,\n            Execution::Call(isolate, prepare_stack_trace, global_error,\n                            base::VectorOf(args)));\n        return result;\n      }\n    }\n  }\n\n  // Otherwise, run our internal formatting logic.\n  IncrementalStringBuilder builder(isolate);\n\n  RETURN_ON_EXCEPTION(isolate, AppendErrorString(isolate, error, &builder));\n\n  for (int i = 0; i < elems->length(); ++i) {\n    builder.AppendCStringLiteral(\"\\n    at \");\n\n    DirectHandle<CallSiteInfo> frame(Cast<CallSiteInfo>(elems->get(i)),\n                                     isolate);\n\n    v8::TryCatch try_catch(reinterpret_cast<v8::Isolate*>(isolate));\n    SerializeCallSiteInfo(isolate, frame, &builder);\n\n    if (isolate->has_exception()) {\n      // CallSite.toString threw. Parts of the current frame might have been\n      // stringified already regardless. Still, try to append a string\n      // representation of the thrown exception.\n\n      DirectHandle<Object> exception(isolate->exception(), isolate);\n      try_catch.Reset();\n\n      MaybeDirectHandle<String> exception_string =\n          ErrorUtils::ToString(isolate, exception);\n      if (exception_string.is_null()) {\n        // Formatting the thrown exception threw again, give up.\n\n        builder.AppendCStringLiteral(\"<error>\");\n      } else {\n        // Formatted thrown exception successfully, append it.\n        builder.AppendCStringLiteral(\"<error: \");\n        builder.AppendString(exception_string.ToHandleChecked());\n        builder.AppendCStringLiteral(\"<error>\");\n      }\n    }\n  }\n\n  return builder.Finish();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Format\",\n            \"parent\": \"MessageFormatter\",\n            \"about\": \"Formats a message based on a message template and arguments.\",\n            \"logic\": \"Replaces placeholders in the message template with the provided arguments. Flattens the resulting string to improve efficiency.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"MessageTemplate\",\n                    \"purpose\": \"The message template index.\"\n                },\n                {\n                    \"name\": \"args\",\n                    \"type\": \"base::Vector<const DirectHandle<Object>>\",\n                    \"purpose\": \"The arguments to insert into the template.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DirectHandle<String>\",\n                \"description\": \"The formatted message string.\"\n            },\n            \"dependencies\": [\n                \"Object::NoSideEffectsToString\",\n                \"MessageFormatter::TryFormat\",\n                \"String::Flatten\",\n                \"isolate->factory()->InternalizeString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<String> MessageFormatter::Format(\n    Isolate* isolate, MessageTemplate index,\n    base::Vector<const DirectHandle<Object>> args) {\n  constexpr size_t kMaxArgs = 3;\n  DirectHandle<String> arg_strings[kMaxArgs];\n  DCHECK_LE(args.size(), kMaxArgs);\n  for (size_t i = 0; i < args.size(); ++i) {\n    DCHECK(!args[i].is_null());\n    arg_strings[i] = Object::NoSideEffectsToString(isolate, args[i]);\n  }\n  v8::TryCatch try_catch(reinterpret_cast<v8::Isolate*>(isolate));\n  try_catch.SetVerbose(false);\n  try_catch.SetCaptureMessage(false);\n  MaybeHandle<String> maybe_result_string = MessageFormatter::TryFormat(\n      isolate, index, base::VectorOf(arg_strings, args.size()));\n  Handle<String> result_string;\n  if (!maybe_result_string.ToHandle(&result_string)) {\n    DCHECK(isolate->has_exception());\n    return isolate->factory()->InternalizeString(\n        base::StaticCharVector(\"<error>\"));\n  }\n  // A string that has been obtained from JS code in this way is\n  // likely to be a complicated ConsString of some sort.  We flatten it\n  // here to improve the efficiency of converting it to a C string and\n  // other operations that are likely to take place (see GetLocalizedMessage\n  // for example).\n  return String::Flatten(isolate, result_string);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TemplateString\",\n            \"parent\": \"MessageFormatter\","
}