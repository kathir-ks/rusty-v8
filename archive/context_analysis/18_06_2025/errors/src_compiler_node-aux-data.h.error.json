{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-aux-data.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 49, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-aux-data.h\",\n            \"file_name\": \"node-aux-data.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines auxiliary data structures for nodes in the compiler graph.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for node representation and zone containers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/node.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NodeAuxData\",\n            \"about\": \"Associates auxiliary data of type T with Node objects using a ZoneVector.  Provides efficient storage and retrieval of node-specific information during compilation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The zone used for memory allocation.\"\n                },\n                {\n                    \"name\": \"aux_data_\",\n                    \"type\": \"ZoneVector<T>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The vector storing the auxiliary data, indexed by NodeId.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\",\n                \"Zone\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, T def(Zone*) = DefaultConstruct<T>>\nclass NodeAuxData {\n public:\n  explicit NodeAuxData(Zone* zone) : zone_(zone), aux_data_(zone) {}\n  explicit NodeAuxData(size_t initial_size, Zone* zone)\n      : zone_(zone), aux_data_(initial_size, def(zone), zone) {}\n\n  // Update entry. Returns true iff entry was changed.\n  bool Set(Node* node, T const& data) {\n    NodeId const id = node->id();\n    return Set(id, data);\n  }\n\n  bool Set(NodeId id, T const& data) {\n    if (id >= aux_data_.size()) aux_data_.resize(id + 1, def(zone_));\n    if (aux_data_[id] != data) {\n      aux_data_[id] = data;\n      return true;\n    }\n    return false;\n  }\n\n  T Get(Node* node) const { return Get(node->id()); }\n\n  T Get(NodeId id) const {\n    return (id < aux_data_.size()) ? aux_data_[id] : def(zone_);\n  }\n\n  class const_iterator;\n  friend class const_iterator;\n\n  const_iterator begin() const;\n  const_iterator end() const;\n\n private:\n  Zone* zone_;\n  ZoneVector<T> aux_data_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NodeAuxData<T, def>::const_iterator\",\n            \"about\": \"Iterator for the NodeAuxData class, allowing traversal of the associated data.\",\n            \"attributes\": [\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"const ZoneVector<T>*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the underlying ZoneVector.\"\n                },\n                {\n                    \"name\": \"current_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current index in the ZoneVector.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, T def(Zone*)>\nclass NodeAuxData<T, def>::const_iterator {\n public:\n  using iterator_category = std::forward_iterator_tag;\n  using difference_type = int;\n  using value_type = std::pair<size_t, T>;\n  using pointer = value_type*;\n  using reference = value_type&;\n\n  const_iterator(const ZoneVector<T>* data, size_t current)\n      : data_(data), current_(current) {}\n  const_iterator(const const_iterator& other)\n      : data_(other.data_), current_(other.current_) {}\n\n  value_type operator*() const {\n    return std::make_pair(current_, (*data_)[current_]);\n  }\n  bool operator==(const const_iterator& other) const {\n    return current_ == other.current_ && data_ == other.data_;\n  }\n  bool operator!=(const const_iterator& other) const {\n    return !(*this == other);\n  }\n  const_iterator& operator++() {\n    ++current_;\n    return *this;\n  }\n  const_iterator operator++(int);\n\n private:\n  const ZoneVector<T>* data_;\n  size_t current_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"begin\",\n            \"parent\": \"NodeAuxData\",\n            \"about\": \"Returns an iterator to the beginning of the NodeAuxData.\",\n            \"logic\": \"Creates and returns a const_iterator pointing to the beginning of the aux_data_ ZoneVector.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"typename NodeAuxData<T, def>::const_iterator\",\n                \"description\": \"An iterator to the beginning of the NodeAuxData.\"\n            },\n            \"dependencies\": [\n                \"NodeAuxData::const_iterator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, T def(Zone*)>\ntypename NodeAuxData<T, def>::const_iterator NodeAuxData<T, def>::begin()\n    const {\n  return typename NodeAuxData<T, def>::const_iterator(&aux_data_, 0);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"end\",\n            \"parent\": \"NodeAuxData\",\n            \"about\": \"Returns an iterator to the end of the NodeAuxData.\",\n            \"logic\": \"Creates and returns a const_iterator pointing to the end of the aux_data_ ZoneVector.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"typename NodeAuxData<T, def>::const_iterator\",\n                \"description\": \"An iterator to the end of the NodeAuxData.\"\n            },\n            \"dependencies\": [\n                \"NodeAuxData::const_iterator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, T def(Zone*)>\ntypename NodeAuxData<T, def>::const_iterator NodeAuxData<T, def>::end() const {\n  return typename NodeAuxData<T, def>::const_iterator(&aux_data_,\n                                                      aux_data_.size());\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NodeAuxDataMap\",\n            \"about\": \"Associates auxiliary data of type T with NodeId using a ZoneUnorderedMap. Provides fast lookups for auxiliary node information when a sparse storage is needed.\",\n            \"attributes\": [\n                {\n                    \"name\": \"map_\",\n                    \"type\": \"ZoneUnorderedMap<NodeId, T>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The unordered map storing the auxiliary data.\"\n                }\n            ],\n            \"dependencies\": [\n                \"NodeId\",\n                \"ZoneUnorderedMap\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, T kNonExistent>\nclass NodeAuxDataMap {\n public:\n  explicit NodeAuxDataMap(Zone* zone) : map_(zone) {}\n\n  void Put(NodeId key, T value) { map_[key] = value; }\n\n  T Get(NodeId key) const {\n    auto entry = map_.find(key);\n    if (entry == map_.end()) return kNonExistent;\n    return entry->second;\n  }\n\n  void Reserve(size_t count) {\n    size_t new_capacity = map_.size() + count;\n    map_.reserve(new_capacity);\n  }\n\n private:\n  ZoneUnorderedMap<NodeId, T> map_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DefaultConstruct\",\n            \"about\": \"Default constructs an object of type T\",\n            \"logic\": \"Simply calls the default constructor of T.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone for allocation (unused in this default implementation).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T\",\n                \"description\": \"A default constructed object of type T.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nT DefaultConstruct(Zone* zone) {\n  return T();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ZoneConstruct\",\n            \"about\": \"Constructs an object of type T using the provided zone, assuming T has a constructor that takes a Zone*.\",\n            \"logic\": \"Calls the constructor of T, passing the zone pointer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone for allocation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T\",\n                \"description\": \"A zone-allocated object of type T.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nT ZoneConstruct(Zone* zone) {\n  return T(zone);\n}\n        ]]></code>\n    </func>\n</file>\n```"
}