{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-microtask-queue.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 44, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-microtask-queue.h\",\n        \"file_name\": \"v8-microtask-queue.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the MicrotaskQueue class and related classes/enums for managing microtasks in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers and V8-specific headers for memory management, microtask handling, and configuration.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stddef.h>\n            #include <memory>\n            #include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n            #include \"v8-microtask.h\"     // NOLINT(build/include_directory)\n            #include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MicrotaskQueue\",\n            \"about\": \"Represents the microtask queue, responsible for storing and processing microtasks.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Function\",\n                \"MicrotaskCallback\",\n                \"MicrotasksCompletedCallbackWithData\",\n                \"MicrotasksPolicy\",\n                \"Local<Function>\",\n                \"Context\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT MicrotaskQueue {\n            public:\n                /**\n                * Creates an empty MicrotaskQueue instance.\n                */\n                static std::unique_ptr<MicrotaskQueue> New(\n                    Isolate* isolate, MicrotasksPolicy policy = MicrotasksPolicy::kAuto);\n\n                virtual ~MicrotaskQueue() = default;\n\n                /**\n                * Enqueues the callback to the queue.\n                */\n                virtual void EnqueueMicrotask(Isolate* isolate,\n                                                Local<Function> microtask) = 0;\n\n                /**\n                * Enqueues the callback to the queue.\n                */\n                virtual void EnqueueMicrotask(v8::Isolate* isolate,\n                                                MicrotaskCallback callback,\n                                                void* data = nullptr) = 0;\n\n                /**\n                * Adds a callback to notify the embedder after microtasks were run. The\n                * callback is triggered by explicit RunMicrotasks call or automatic\n                * microtasks execution (see Isolate::SetMicrotasksPolicy).\n                *\n                * Callback will trigger even if microtasks were attempted to run,\n                * but the microtasks queue was empty and no single microtask was actually\n                * executed.\n                *\n                * Executing scripts inside the callback will not re-trigger microtasks and\n                * the callback.\n                */\n                virtual void AddMicrotasksCompletedCallback(\n                    MicrotasksCompletedCallbackWithData callback, void* data = nullptr) = 0;\n\n                /**\n                * Removes callback that was installed by AddMicrotasksCompletedCallback.\n                */\n                virtual void RemoveMicrotasksCompletedCallback(\n                    MicrotasksCompletedCallbackWithData callback, void* data = nullptr) = 0;\n\n                /**\n                * Runs microtasks if no microtask is running on this MicrotaskQueue instance.\n                */\n                virtual void PerformCheckpoint(Isolate* isolate) = 0;\n\n                /**\n                * Returns true if a microtask is running on this MicrotaskQueue instance.\n                */\n                virtual bool IsRunningMicrotasks() const = 0;\n\n                /**\n                * Returns the current depth of nested MicrotasksScope that has\n                * kRunMicrotasks.\n                */\n                virtual int GetMicrotasksScopeDepth() const = 0;\n\n                MicrotaskQueue(const MicrotaskQueue&) = delete;\n                MicrotaskQueue& operator=(const MicrotaskQueue&) = delete;\n\n            private:\n                friend class internal::MicrotaskQueue;\n                MicrotaskQueue() = default;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MicrotasksScope\",\n            \"about\": \"Controls microtask execution based on the MicrotasksPolicy::kScoped setting on the Isolate.\",\n            \"attributes\": [\n                {\n                    \"name\": \"i_isolate_\",\n                    \"type\": \"internal::Isolate* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the internal Isolate.\"\n                },\n                {\n                    \"name\": \"microtask_queue_\",\n                    \"type\": \"internal::MicrotaskQueue* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the internal MicrotaskQueue.\"\n                },\n                {\n                    \"name\": \"run_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether microtasks should be run when the scope exits.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"MicrotaskQueue\",\n                \"Local<Context>\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8_NODISCARD MicrotasksScope {\n            public:\n                enum Type { kRunMicrotasks, kDoNotRunMicrotasks };\n\n                MicrotasksScope(Local<Context> context, Type type);\n                MicrotasksScope(Isolate* isolate, MicrotaskQueue* microtask_queue, Type type);\n                ~MicrotasksScope();\n\n                /**\n                * Runs microtasks if no kRunMicrotasks scope is currently active.\n                */\n                static void PerformCheckpoint(Isolate* isolate);\n\n                /**\n                * Returns current depth of nested kRunMicrotasks scopes.\n                */\n                static int GetCurrentDepth(Isolate* isolate);\n\n                /**\n                * Returns true while microtasks are being executed.\n                */\n                static bool IsRunningMicrotasks(Isolate* isolate);\n\n                // Prevent copying.\n                MicrotasksScope(const MicrotasksScope&) = delete;\n                MicrotasksScope& operator=(const MicrotasksScope&) = delete;\n\n            private:\n                internal::Isolate* const i_isolate_;\n                internal::MicrotaskQueue* const microtask_queue_;\n                bool run_;\n            };\n        ]]></code>\n    </class>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Function\",\n                \"about\": \"Represents a JavaScript function.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Function;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Local\",\n                \"about\": \"A handle to a V8 object.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> class Local {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Context\",\n                \"about\": \"A JavaScript execution context.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Context;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MicrotasksPolicy\",\n                \"about\": \"Enum that specifies when microtasks are executed.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                enum class MicrotasksPolicy { kAuto };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"MicrotaskCallback\",\n                \"about\": \"Type definition for microtask callback function.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                typedef void (*MicrotaskCallback)(void* data);\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"MicrotasksCompletedCallbackWithData\",\n                \"about\": \"Type definition for the microtasks completed callback function.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                typedef void (*MicrotasksCompletedCallbackWithData)(void* data);\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"internal::Isolate\",\n                \"about\": \"Internal Isolate class.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace internal { class Isolate; }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"internal::MicrotaskQueue\",\n                \"about\": \"Internal MicrotaskQueue class.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace internal { class MicrotaskQueue; }\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}