{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/register-allocator-verifier.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/register-allocator-verifier.cc\",\n        \"file_name\": \"register-allocator-verifier.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Verification of the register allocation process in the V8 compiler backend\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for register allocator verification, instruction manipulation, and utility functions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/backend/register-allocator-verifier.h\"\n\n            #include <optional>\n\n            #include \"src/compiler/backend/instruction.h\"\n            #include \"src/utils/bit-vector.h\"\n            #include \"src/utils/ostreams.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"OperandCount\",\n            \"parent\": null,\n            \"about\": \"Calculates the total number of operands (inputs, outputs, and temporaries) in an instruction.\",\n            \"logic\": \"Sums the input, output, and temporary operand counts of the given instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"const Instruction*\",\n                    \"purpose\": \"The instruction to analyze.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The total number of operands.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            size_t OperandCount(const Instruction* instr) {\n            return instr->InputCount() + instr->OutputCount() + instr->TempCount();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VerifyEmptyGaps\",\n            \"parent\": null,\n            \"about\": \"Verifies that all gap positions within an instruction are empty (i.e., no parallel moves are assigned).\",\n            \"logic\": \"Iterates through each possible gap position of the instruction and asserts that no parallel move exists at that position.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"const Instruction*\",\n                    \"purpose\": \"The instruction to verify.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void VerifyEmptyGaps(const Instruction* instr) {\n            for (int i = Instruction::FIRST_GAP_POSITION;\n                 i <= Instruction::LAST_GAP_POSITION; i++) {\n              Instruction::GapPosition inner_pos =\n                  static_cast<Instruction::GapPosition>(i);\n              CHECK_NULL(instr->GetParallelMove(inner_pos));\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VerifyAllocatedGaps\",\n            \"parent\": null,\n            \"about\": \"Verifies that all non-redundant moves within parallel moves at gap positions in the instruction are allocated.\",\n            \"logic\": \"Iterates through parallel moves at each gap, skipping redundant moves. Asserts source operand is either allocated or constant and the destination is allocated\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"const Instruction*\",\n                    \"purpose\": \"The instruction to verify.\"\n                },\n                {\n                    \"name\": \"caller_info\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"Information about the caller to be included in error messages.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void VerifyAllocatedGaps(const Instruction* instr, const char* caller_info) {\n            for (int i = Instruction::FIRST_GAP_POSITION;\n                 i <= Instruction::LAST_GAP_POSITION; i++) {\n              Instruction::GapPosition inner_pos =\n                  static_cast<Instruction::GapPosition>(i);\n              const ParallelMove* moves = instr->GetParallelMove(inner_pos);\n              if (moves == nullptr) continue;\n              for (const MoveOperands* move : *moves) {\n                if (move->IsRedundant()) continue;\n                CHECK_WITH_MSG(\n                    move->source().IsAllocated() || move->source().IsConstant(),\n                    caller_info);\n                CHECK_WITH_MSG(move->destination().IsAllocated(), caller_info);\n              }\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetValue\",\n            \"parent\": null,\n            \"about\": \"Retrieves the integer value from an ImmediateOperand based on its type.\",\n            \"logic\": \"A switch statement determines how to extract integer value. If INLINE_INT64, the value is cast to `int`.\",\n            \"parameters\": [\n                {\n                    \"name\": \"imm\",\n                    \"type\": \"const ImmediateOperand*\",\n                    \"purpose\": \"The immediate operand to retrieve the value from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The integer value of the immediate operand.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            int GetValue(const ImmediateOperand* imm) {\n              switch (imm->type()) {\n                case ImmediateOperand::INLINE_INT32:\n                  return imm->inline_int32_value();\n                case ImmediateOperand::INLINE_INT64:\n                  return static_cast<int>(imm->inline_int64_value());\n                case ImmediateOperand::INDEXED_RPO:\n                case ImmediateOperand::INDEXED_IMM:\n                  return imm->indexed_value();\n              }\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RegisterAllocatorVerifier\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A class responsible for verifying the correctness of the register allocation process.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory zone for allocating data structures.\"\n                },\n                {\n                    \"name\": \"config_\",\n                    \"type\": \"const RegisterConfiguration*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The register configuration used during allocation.\"\n                },\n                {\n                    \"name\": \"sequence_\",\n                    \"type\": \"const InstructionSequence*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The sequence of instructions being verified.\"\n                },\n                {\n                    \"name\": \"constraints_\",\n                    \"type\": \"ZoneVector<InstructionConstraint>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of instruction constraints.\"\n                },\n                {\n                    \"name\": \"assessments_\",\n                    \"type\": \"ZoneMap<RpoNumber, BlockAssessments*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of assessments for each block.\"\n                },\n                {\n                    \"name\": \"outstanding_assessments_\",\n                    \"type\": \"ZoneMap<RpoNumber, DelayedAssessments*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of delayed assessments.\"\n                },\n                {\n                    \"name\": \"spill_slot_delta_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The difference between the total frame slot count and the spill slot count.\"\n                },\n                {\n                    \"name\": \"caller_info_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Information about the caller function, used in CHECK_WITH_MSG.\"\n                }\n            ],\n            \"dependencies\": [\n                \"RegisterConfiguration\",\n                \"InstructionSequence\",\n                \"Frame\",\n                \"Zone\",\n                \"Instruction\",\n                \"InstructionOperand\",\n                \"ConstantOperand\",\n                \"ImmediateOperand\",\n                \"UnallocatedOperand\",\n                \"LocationOperand\",\n                \"AllocatedOperand\",\n                \"ParallelMove\",\n                \"MoveOperands\",\n                \"BlockAssessments\",\n                \"ReferenceMap\",\n                \"InstructionBlock\",\n                \"RpoNumber\",\n                \"PhiInstruction\",\n                \"Assessment\",\n                \"PendingAssessment\",\n                \"FinalAssessment\",\n                \"DelayedAssessments\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class RegisterAllocatorVerifier {\n            public:\n                RegisterAllocatorVerifier(\n                    Zone* zone, const RegisterConfiguration* config,\n                    const InstructionSequence* sequence, const Frame* frame);\n\n                void VerifyInput(const OperandConstraint& constraint);\n                void VerifyTemp(const OperandConstraint& constraint);\n                void VerifyOutput(const OperandConstraint& constraint);\n                void VerifyAssignment(const char* caller_info);\n                void BuildConstraint(const InstructionOperand* op,\n                                                    OperandConstraint* constraint);\n                void CheckConstraint(\n                    const InstructionOperand* op, const OperandConstraint* constraint);\n                void VerifyGapMoves();\n\n            private:\n                Zone* zone_;\n                const RegisterConfiguration* config_;\n                const InstructionSequence* sequence_;\n                ZoneVector<InstructionConstraint> constraints_;\n                ZoneMap<RpoNumber, BlockAssessments*> assessments_;\n                ZoneMap<RpoNumber, DelayedAssessments*> outstanding_assessments_;\n                int spill_slot_delta_;\n                const char* caller_info_;\n\n                BlockAssessments* CreateForBlock(\n                    const InstructionBlock* block);\n\n                void ValidatePendingAssessment(\n                    RpoNumber block_id, InstructionOperand op,\n                    const BlockAssessments* current_assessments,\n                    PendingAssessment* const assessment, int virtual_register);\n\n                void ValidateUse(\n                    RpoNumber block_id, BlockAssessments* current_assessments,\n                    InstructionOperand op, int virtual_register);\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterAllocatorVerifier\",\n            \"parent\": \"RegisterAllocatorVerifier\",\n            \"about\": \"Constructor for the RegisterAllocatorVerifier class. Initializes the verifier with necessary data structures and initial constraints.\",\n            \"logic\": \"The constructor iterates through each instruction, building constraints for each operand and eliminating kSameAsInput constraints. Also verifies that gaps are initially unallocated.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"Memory zone for allocating data structures.\"\n                },\n                {\n                    \"name\": \"config\",\n                    \"type\": \"const RegisterConfiguration*\",\n                    \"purpose\": \"The register configuration used during allocation.\"\n                },\n                {\n                    \"name\": \"sequence\",\n                    \"type\": \"const InstructionSequence*\",\n                    \"purpose\": \"The sequence of instructions being verified.\"\n                },\n                {\n                    \"name\": \"frame\",\n                    \"type\": \"const Frame*\",\n                    \"purpose\": \"The frame being used for allocation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"OperandCount\",\n                \"VerifyEmptyGaps\",\n                \"BuildConstraint\",\n                \"VerifyInput\",\n                \"VerifyTemp\",\n                \"VerifyOutput\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            RegisterAllocatorVerifier::RegisterAllocatorVerifier(\n                Zone* zone, const RegisterConfiguration* config,\n                const InstructionSequence* sequence, const Frame* frame)\n                : zone_(zone),\n                  config_(config),\n                  sequence_(sequence),\n                  constraints_(zone),\n                  assessments_(zone),\n                  outstanding_assessments_(zone),\n                  spill_slot_delta_(frame->GetTotalFrameSlotCount() -\n                                    frame->GetSpillSlotCount()) {\n              constraints_.reserve(sequence->instructions().size());\n              // TODO(dcarney): model unique constraints.\n              // Construct OperandConstraints for all InstructionOperands, eliminating\n              // kSameAsInput along the way.\n              for (const Instruction* instr : sequence->instructions()) {\n                // All gaps should be totally unallocated at this point.\n                VerifyEmptyGaps(instr);\n                const size_t operand_count = OperandCount(instr);\n                OperandConstraint* op_constraints =\n                    zone->AllocateArray<OperandConstraint>(operand_count);\n                size_t count = 0;\n                for (size_t i = 0; i < instr->InputCount(); ++i, ++count) {\n                  BuildConstraint(instr->InputAt(i), &op_constraints[count]);\n                  VerifyInput(op_constraints[count]);\n                }\n                for (size_t i = 0; i < instr->TempCount(); ++i, ++count) {\n                  BuildConstraint(instr->TempAt(i), &op_constraints[count]);\n                  VerifyTemp(op_constraints[count]);\n                }\n                for (size_t i = 0; i < instr->OutputCount(); ++i, ++count) {\n                  BuildConstraint(instr->OutputAt(i), &op_constraints[count]);\n                  if (op_constraints[count].type_ == kSameAsInput) {\n                    int input_index = op_constraints[count].value_;\n                    CHECK_LT(input_index, instr->InputCount());\n                    op_constraints[count].type_ = op_constraints[input_index].type_;\n                    op_constraints[count].value_ = op_constraints[input_index].value_;\n                  }\n                  VerifyOutput(op_constraints[count]);\n                }\n                InstructionConstraint instr_constraint = {instr, operand_count,\n                                                          op_constraints};\n                constraints()->push_back(instr_constraint);\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VerifyInput\",\n            \"parent\": \"RegisterAllocatorVerifier\",\n            \"about\": \"Verifies the constraint for an input operand.\",\n            \"logic\": \"Checks that input operands are not kSameAsInput and that their virtual register is valid (if not an immediate).\",\n            \"parameters\": [\n                {\n                    \"name\": \"constraint\",\n                    \"type\": \"const OperandConstraint&\",\n                    \"purpose\": \"The operand constraint to verify.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void RegisterAllocatorVerifier::VerifyInput(\n                const OperandConstraint& constraint) {\n              CHECK_NE(kSameAsInput, constraint.type_);\n              if (constraint.type_ != kImmediate) {\n                CHECK_NE(InstructionOperand::kInvalidVirtualRegister,\n                         constraint.virtual_register_);\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VerifyTemp\",\n            \"parent\": \"RegisterAllocatorVerifier\",\n            \"about\": \"Verifies the constraint for a temporary operand.\",\n            \"logic\": \"Checks that temporary operands are not kSameAsInput, kImmediate, or kConstant.\",\n            \"parameters\": [\n                {\n                    \"name\": \"constraint\",\n                    \"type\": \"const OperandConstraint&\",\n                    \"purpose\": \"The operand constraint to verify.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void RegisterAllocatorVerifier::VerifyTemp(\n                const OperandConstraint& constraint) {\n              CHECK_NE(kSameAsInput, constraint.type_);\n              CHECK_NE(kImmediate, constraint.type_);\n              CHECK_NE(kConstant, constraint.type_);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VerifyOutput\",\n            \"parent\": \"RegisterAllocatorVerifier\",\n            \"about\": \"Verifies the constraint for an output operand.\",\n            \"logic\": \"Checks that output operands are not kImmediate and that their virtual register is valid.\",\n            \"parameters\": [\n                {\n                    \"name\": \"constraint\",\n                    \"type\": \"const OperandConstraint&\",\n                    \"purpose\": \"The operand constraint to verify.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void RegisterAllocatorVerifier::VerifyOutput(\n                const OperandConstraint& constraint) {\n              CHECK_NE(kImmediate, constraint.type_);\n              CHECK_NE(InstructionOperand::kInvalidVirtualRegister,\n                       constraint.virtual_register_);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VerifyAssignment\",\n            \"parent\": \"RegisterAllocatorVerifier\",\n            \"about\": \"Verifies the register assignment for all instructions in the sequence.\",\n            \"logic\": \"Iterates through each instruction and its associated constraints, checking that the assigned operands satisfy the constraints.  Also verifies that all gaps are totally allocated.\",\n            \"parameters\": [\n                {\n                    \"name\": \"caller_info\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"Information about the caller to be included in error messages.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"OperandCount\",\n                \"CheckConstraint\",\n                \"VerifyAllocatedGaps\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void RegisterAllocatorVerifier::VerifyAssignment(const char* caller_info) {\n              caller_info_ = caller_info;\n              CHECK(sequence()->instructions().size() == constraints()->size());\n              auto instr_it = sequence()->begin();\n              for (const auto& instr_constraint : *constraints()) {\n                const Instruction* instr = instr_constraint.instruction_;\n                // All gaps should be totally allocated at this point.\n                VerifyAllocatedGaps(instr, caller_info_);\n                const size_t operand_count = instr_constraint.operand_constaints_size_;\n                const OperandConstraint* op_constraints =\n                    instr_constraint.operand_constraints_;\n                CHECK_EQ(instr, *instr_it);\n                CHECK(operand_count == OperandCount(instr));\n                size_t count = 0;\n                for (size_t i = 0; i < instr->InputCount(); ++i, ++count) {\n                  CheckConstraint(instr->InputAt(i), &op_constraints[count]);\n                }\n                for (size_t i = 0; i < instr->TempCount(); ++i, ++count) {\n                  CheckConstraint(instr->TempAt(i), &op_constraints[count]);\n                }\n                for (size_t i = 0; i < instr->OutputCount(); ++i, ++count) {\n                  CheckConstraint(instr->OutputAt(i), &op_constraints[count]);\n                }\n                ++instr_it;\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BuildConstraint\",\n            \"parent\": \"RegisterAllocatorVerifier\",\n            \"about\": \"Builds an OperandConstraint object for a given InstructionOperand.\",\n            \"logic\": \"Determines the type of operand and creates an appropriate constraint based on its properties (constant, immediate, unallocated, etc.).\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const InstructionOperand*\",\n                    \"purpose\": \"The operand to build a constraint for.\"\n                },\n                {\n                    \"name\": \"constraint\",\n                    \"type\": \"OperandConstraint*\",\n                    \"purpose\": \"The OperandConstraint object to populate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"GetValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void RegisterAllocatorVerifier::BuildConstraint(const InstructionOperand* op,\n                                                        OperandConstraint* constraint) {\n              constraint->value_ = kMinInt;\n              constraint->virtual_register_ = InstructionOperand::kInvalidVirtualRegister;\n              if (op->IsConstant()) {\n                constraint->type_ = kConstant;\n                constraint->value_ = ConstantOperand::cast(op)->virtual_register();\n                constraint->virtual_register_ = constraint->value_;\n              } else if (op->IsImmediate()) {\n                const ImmediateOperand* imm = ImmediateOperand::cast(op);\n                constraint->type_ = kImmediate;\n                constraint->value_ = GetValue(imm);\n              } else {\n                CHECK(op->IsUnallocated());\n                const UnallocatedOperand* unallocated = UnallocatedOperand::cast(op);\n                int vreg = unallocated->virtual_register();\n                constraint->virtual_register_ = vreg;\n                if (unallocated->basic_policy() == UnallocatedOperand::FIXED_SLOT) {\n                  constraint->type_ = kFixedSlot;\n                  constraint->value_ = unallocated->fixed_slot_index();\n                } else {\n                  switch (unallocated->extended_policy()) {\n                    case UnallocatedOperand::REGISTER_OR_SLOT:\n                    case UnallocatedOperand::NONE:\n                      if (sequence()->IsFP(vreg)) {\n                        constraint->type_ = kRegisterOrSlotFP;\n                      } else {\n                        constraint->type_ = kRegisterOrSlot;\n                      }\n                      break;\n                    case UnallocatedOperand::REGISTER_OR_SLOT_OR_CONSTANT:\n                      DCHECK(!sequence()->IsFP(vreg));\n                      constraint->type_ = kRegisterOrSlotOrConstant;\n                      break;\n                    case UnallocatedOperand::FIXED_REGISTER:\n                      if (unallocated->HasSecondaryStorage()) {\n                        constraint->type_ = kRegisterAndSlot;\n                        constraint->spilled_slot_ = unallocated->GetSecondaryStorage();\n                      } else {\n                        constraint->type_ = kFixedRegister;\n                      }\n                      constraint->value_ = unallocated->fixed_register_index();\n                      break;\n                    case UnallocatedOperand::FIXED_FP_REGISTER:\n                      constraint->type_ = kFixedFPRegister;\n                      constraint->value_ = unallocated->fixed_register_index();\n                      break;\n                    case UnallocatedOperand::MUST_HAVE_REGISTER:\n                      if (sequence()->IsFP(vreg)) {\n                        constraint->type_ = kFPRegister;\n                      } else {\n                        constraint->type_ = kRegister;\n                      }\n                      break;\n                    case UnallocatedOperand::MUST_HAVE_SLOT:\n                      constraint->type_ = kSlot;\n                      constraint->value_ =\n                          ElementSizeLog2Of(sequence()->GetRepresentation(vreg));\n                      break;\n                    case UnallocatedOperand::SAME_AS_INPUT:\n                      constraint->type_ = kSameAsInput;\n                      constraint->value_ = unallocated->input_index();\n                      break;\n                  }\n                }\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CheckConstraint\",\n            \"parent\": \"RegisterAllocatorVerifier\",\n            \"about\": \"Checks if a given InstructionOperand satisfies a given OperandConstraint.\",\n            \"logic\": \"Uses a switch statement based on the constraint type to perform specific checks.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const InstructionOperand*\",\n                    \"purpose\": \"The operand to check.\"\n                },\n                {\n                    \"name\": \"constraint\",\n                    \"type\": \"const OperandConstraint*\",\n                    \"purpose\": \"The constraint to check against.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"GetValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void RegisterAllocatorVerifier::CheckConstraint(\n                const InstructionOperand* op, const OperandConstraint* constraint) {\n              switch (constraint->type_) {\n                case kConstant:\n                  CHECK_WITH_MSG(op->IsConstant(), caller_info_);\n                  CHECK_EQ(ConstantOperand::cast(op)->virtual_register(),\n                           constraint->value_);\n                  return;\n                case kImmediate: {\n                  CHECK_WITH_MSG(op->IsImmediate(), caller_info_);\n                  const ImmediateOperand* imm = ImmediateOperand::cast(op);\n                  int value = GetValue(imm);\n                  CHECK_EQ(value, constraint->value_);\n                  return;\n                }\n                case kRegister:\n                  CHECK_WITH_MSG(op->IsRegister(), caller_info_);\n                  return;\n                case kFPRegister:\n                  CHECK_WITH_MSG(op->IsFPRegister(), caller_info_);\n                  return;\n                case kFixedRegister:\n                case kRegisterAndSlot:\n                  CHECK_WITH_MSG(op->IsRegister(), caller_info_);\n                  CHECK_EQ(LocationOperand::cast(op)->register_code(), constraint->value_);\n                  return;\n                case kFixedFPRegister:\n                  CHECK_WITH_MSG(op->IsFPRegister(), caller_info_);\n                  CHECK_EQ(LocationOperand::cast(op)->register_code(), constraint->value_);\n                  return;\n                case kFixedSlot:\n                  CHECK_WITH_MSG(op->IsStackSlot() || op->IsFPStackSlot(), caller_info_);\n                  CHECK_EQ(LocationOperand::cast(op)->index(), constraint->value_);\n                  return;\n                case kSlot:\n                  CHECK_WITH_MSG(op->IsStackSlot() || op->IsFPStackSlot(), caller_info_);\n                  CHECK_EQ(ElementSizeLog2Of(LocationOperand::cast(op)->representation()),\n                           constraint->value_);\n                  return;\n                case kRegisterOrSlot:\n                  CHECK_WITH_MSG(op->IsRegister() || op->IsStackSlot(), caller_info_);\n                  return;\n                case kRegisterOrSlotFP:\n                  CHECK_WITH_MSG(op->IsFPRegister() || op->IsFPStackSlot(), caller_info_);\n                  return;\n                case kRegisterOrSlotOrConstant:\n                  CHECK_WITH_MSG(op->IsRegister() || op->IsStackSlot() || op->IsConstant(),\n                                 caller_info_);\n                  return;\n                case kSameAsInput:\n                  CHECK_WITH_MSG(false, caller_info_);\n                  return;\n              }\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BlockAssessments\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A class for managing and assessing register and stack slot assignments within a basic block.\",\n            \"attributes\": [\n                {\n                    \"name\": \"map_\",\n                    \"type\": \"ZoneMap<InstructionOperand, Assessment>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps InstructionOperands to their respective Assessments.\"\n                },\n                {\n                    \"name\": \"map_for_moves_\",\n                    \"type\": \"ZoneMap<InstructionOperand, Assessment>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Temporary map used during parallel move operations.\"\n                },\n                {\n                    \"name\": \"stale_ref_stack_slots_\",\n                    \"type\": \"ZoneSet<InstructionOperand>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A set of stack slots holding stale references.\"\n                },\n                {\n                    \"name\": \"spill_slot_delta_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Delta between total frame slots and spill slots.\"\n                },\n                {\n                    \"name\": \"sequence_\",\n                    \"type\": \"const InstructionSequence*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The instruction sequence.\"\n                }\n            ],\n            \"dependencies\": [\n                \"InstructionOperand\",\n                \"Assessment\",\n                \"ParallelMove\",\n                \"MoveOperands\",\n                \"ReferenceMap\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class BlockAssessments {\n            public:\n              BlockAssessments(Zone* zone, int spill_slot_delta,\n                               const InstructionSequence* sequence)\n                  : map_(zone),\n                    map_for_moves_(zone),\n                    stale_ref_stack_slots_(zone),\n                    spill_slot_delta_(spill_slot_delta),\n                    sequence_(sequence) {}\n\n              void PerformMoves(const Instruction* instruction);\n              void PerformParallelMoves(const ParallelMove* moves);\n              void DropRegisters();\n              void CheckReferenceMap(const ReferenceMap* reference_map);\n              bool IsStaleReferenceStackSlot(InstructionOperand op,\n                                                   std::optional<int> vreg = {});\n\n              ZoneMap<InstructionOperand, Assessment>& map() { return map_; }\n              const ZoneMap<InstructionOperand, Assessment>& map() const {\n                return map_;\n              }\n\n              ZoneSet<InstructionOperand>& stale_ref_stack_slots() {\n                return stale_ref_stack_slots_;\n              }\n\n              const ZoneSet<InstructionOperand>& stale_ref_stack_slots() const {\n                return stale_ref_stack_slots_;\n              }\n\n              int spill_slot_delta() const { return spill_slot_delta_; }\n\n              void Print() const;\n\n              void Drop(InstructionOperand op) { map().erase(op); }\n              void AddDefinition(InstructionOperand op, int virtual_register) {\n                map()[op] = sequence_->IsReference(virtual_register)\n                                 ? (Assessment*)new (zone()) FinalAssessment(\n                                       virtual_register)\n                                 : (Assessment*)new (zone()) FinalAssessment(\n                                       virtual_register);\n              }\n\n              void CopyFrom(const BlockAssessments* other) {\n                map_ = other->map_;\n                stale_ref_stack_slots_ = other->stale_ref_stack_slots_;\n              }\n\n            private:\n              ZoneMap<InstructionOperand, Assessment> map_;\n              ZoneMap<InstructionOperand, Assessment> map_for_moves_;\n              ZoneSet<InstructionOperand> stale_ref_stack_slots_;\n              const int spill_slot_delta_;\n              const InstructionSequence* sequence_;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PerformMoves\",\n            \"parent\": \"BlockAssessments\",\n            \"about\": \"Performs the parallel moves associated with an instruction, both at the start and end gaps.\",\n            \"logic\": \"Retrieves parallel moves from the start and end gap positions of the instruction and calls PerformParallelMoves for each.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const Instruction*\",\n                    \"purpose\": \"The instruction for which to perform moves.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PerformParallelMoves\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BlockAssessments::PerformMoves(const Instruction* instruction) {\n              const ParallelMove* first =\n                  instruction->GetParallelMove(Instruction::GapPosition::START);\n              PerformParallelMoves(first);\n              const ParallelMove* last =\n                  instruction->GetParallelMove(Instruction::GapPosition::END);\n              PerformParallelMoves(last);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PerformParallelMoves\",\n            \"parent\": \"BlockAssessments\",\n            \"about\": \"Performs a parallel move operation, updating the assessments of operands involved in the move.\",\n            \"logic\": \"Iterates through the moves in a ParallelMove, skipping eliminated or redundant moves. Updates the assessment map to reflect the moves, ensuring the RHS has been assessed and isn't a stale stack slot.\",\n            \"parameters\": [\n                {\n                    \"name\": \"moves\",\n                    \"type\": \"const ParallelMove*\",\n                    \"purpose\": \"The ParallelMove to perform.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"IsStaleReferenceStackSlot\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BlockAssessments::PerformParallelMoves(const ParallelMove* moves) {\n              if (moves == nullptr) return;\n\n              CHECK(map_for_moves_.empty());\n              for (MoveOperands* move : *moves) {\n                if (move->IsEliminated() || move->IsRedundant()) continue;\n                auto it = map_.find(move->source());\n                // The RHS of a parallel move should have been already assessed.\n                CHECK(it != map_.end());\n                // The LHS of a parallel move should not have been assigned in this\n                // parallel move.\n                CHECK(map_for_moves_.find(move->destination()) == map_for_moves_.end());\n                // The RHS of a parallel move should not be a stale reference.\n                CHECK(!IsStaleReferenceStackSlot(move->source()));\n                // Copy the assessment to the destination.\n                map_for_moves_[move->destination()] = it->second;\n              }\n              for (auto"
}