{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm/instruction-selector-arm.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm/instruction-selector-arm.cc\",\n        \"file_name\": \"instruction-selector-arm.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"ARM-specific instruction selector implementation for the V8 compiler backend.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for base functionalities, code generation, machine types, compiler backend components, turboshaft operations and opmasks.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <optional>\n\n            #include \"src/base/bits.h\"\n            #include \"src/base/enum-set.h\"\n            #include \"src/base/iterator.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/codegen/arm/assembler-arm.h\"\n            #include \"src/codegen/machine-type.h\"\n            #include \"src/compiler/backend/instruction-selector-adapter.h\"\n            #include \"src/compiler/backend/instruction-selector-impl.h\"\n            #include \"src/compiler/backend/instruction-selector.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/opmasks.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ArmOperandGeneratorT\",\n            \"extends\": \"OperandGeneratorT\",\n            \"about\": \"Adds Arm-specific methods for generating InstructionOperands.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"Assembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ArmOperandGeneratorT : public OperandGeneratorT {\n            public:\n            explicit ArmOperandGeneratorT(InstructionSelectorT* selector)\n                : OperandGeneratorT(selector) {}\n\n            bool CanBeImmediate(int32_t value) const {\n                return internal::Assembler::ImmediateFitsAddrMode1Instruction(value);\n            }\n\n            bool CanBeImmediate(uint32_t value) const {\n                return CanBeImmediate(base::bit_cast<int32_t>(value));\n            }\n\n            bool CanBeImmediate(OpIndex node, InstructionCode opcode) {\n                int64_t value64;\n                if (!selector()->MatchSignedIntegralConstant(node, &value64)) return false;\n                DCHECK(base::IsInRange(value64, std::numeric_limits<int32_t>::min(),\n                                    std::numeric_limits<int32_t>::max()));\n                int32_t value = static_cast<int32_t>(value64);\n                switch (ArchOpcodeField::decode(opcode)) {\n                case kArmAnd:\n                case kArmMov:\n                case kArmMvn:\n                case kArmBic:\n                    return CanBeImmediate(value) || CanBeImmediate(~value);\n\n                case kArmAdd:\n                case kArmSub:\n                case kArmCmp:\n                case kArmCmn:\n                    return CanBeImmediate(value) || CanBeImmediate(-value);\n\n                case kArmTst:\n                case kArmTeq:\n                case kArmOrr:\n                case kArmEor:\n                case kArmRsb:\n                    return CanBeImmediate(value);\n\n                case kArmVldrF32:\n                case kArmVstrF32:\n                case kArmVldrF64:\n                case kArmVstrF64:\n                    return value >= -1020 && value <= 1020 && (value % 4) == 0;\n\n                case kArmLdrb:\n                case kArmLdrsb:\n                case kArmStrb:\n                case kArmLdr:\n                case kArmStr:\n                    return value >= -4095 && value <= 4095;\n\n                case kArmLdrh:\n                case kArmLdrsh:\n                case kArmStrh:\n                    return value >= -255 && value <= 255;\n\n                default:\n                    break;\n                }\n                return false;\n            }\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRR\",\n            \"about\": \"Emits an instruction with two register operands.\",\n            \"logic\": \"Creates an ArmOperandGenerator, defines the output as a register, and uses the first input as a register. Emits the instruction with the specified opcode and operands.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ArmOperandGeneratorT\",\n                \"InstructionSelectorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void VisitRR(InstructionSelectorT* selector, InstructionCode opcode,\n                OpIndex node) {\n            ArmOperandGeneratorT g(selector);\n            selector->Emit(opcode, g.DefineAsRegister(node),\n                            g.UseRegister(selector->input_at(node, 0)));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRR\",\n            \"about\": \"Emits an instruction with three register operands.\",\n            \"logic\": \"Creates an ArmOperandGenerator, defines the output as a register, and uses the first two inputs as registers. Emits the instruction with the specified opcode and operands.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ArmOperandGeneratorT\",\n                \"InstructionSelectorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void VisitRRR(InstructionSelectorT* selector, InstructionCode opcode,\n                OpIndex node) {\n            ArmOperandGeneratorT g(selector);\n            selector->Emit(opcode, g.DefineAsRegister(node),\n                            g.UseRegister(selector->input_at(node, 0)),\n                            g.UseRegister(selector->input_at(node, 1)));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitSimdShiftRRR\",\n            \"about\": \"Handles SIMD shift operations, optimizing for constant shifts.\",\n            \"logic\": \"If the shift amount is a constant multiple of the width, it emits an identity. Otherwise, it emits a shift instruction with either an immediate or a register shift amount.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"width\",\n                    \"type\": \"int\",\n                    \"purpose\": \"SIMD lane width.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ArmOperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"Simd128ShiftOp\",\n                \"Operation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #if V8_ENABLE_WEBASSEMBLY\n            void VisitSimdShiftRRR(InstructionSelectorT* selector, ArchOpcode opcode,\n                                OpIndex node, int width) {\n            ArmOperandGeneratorT g(selector);\n            const Simd128ShiftOp& op = selector->Get(node).Cast<Simd128ShiftOp>();\n            int32_t shift_by;\n            if (selector->MatchIntegralWord32Constant(op.shift(), &shift_by)) {\n                if (shift_by % width == 0) {\n                selector->EmitIdentity(node);\n                } else {\n                selector->Emit(opcode, g.DefineAsRegister(node),\n                                g.UseRegister(op.input()), g.UseImmediate(op.shift()));\n                }\n            } else {\n                VisitRRR(selector, opcode, node);\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRRShuffle\",\n            \"about\": \"Handles SIMD shuffle operations.\",\n            \"logic\": \"Swaps inputs for certain opcodes to potentially save an instruction. Emits the SIMD shuffle instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"input0\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The first input node.\"\n                },\n                {\n                    \"name\": \"input1\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The second input node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ArmOperandGeneratorT\",\n                \"InstructionSelectorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void VisitRRRShuffle(InstructionSelectorT* selector, ArchOpcode opcode,\n                                OpIndex node, OpIndex input0, OpIndex input1) {\n            ArmOperandGeneratorT g(selector);\n            // Swap inputs to save an instruction in the CodeGenerator for High ops.\n            if (opcode == kArmS32x4ZipRight || opcode == kArmS32x4UnzipRight ||\n                opcode == kArmS32x4TransposeRight || opcode == kArmS16x8ZipRight ||\n                opcode == kArmS16x8UnzipRight || opcode == kArmS16x8TransposeRight ||\n                opcode == kArmS8x16ZipRight || opcode == kArmS8x16UnzipRight ||\n                opcode == kArmS8x16TransposeRight) {\n                std::swap(input0, input1);\n            }\n            // Use DefineSameAsFirst for binary ops that clobber their inputs, e.g. the\n            // NEON vzip, vuzp, and vtrn instructions.\n            selector->Emit(opcode, g.DefineSameAsFirst(node), g.UseRegister(input0),\n                            g.UseRegister(input1));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRI\",\n            \"about\": \"Handles SIMD extract lane operations.\",\n            \"logic\": \"Emits an instruction with two register operands and an immediate operand representing the lane index.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ArmOperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"Operation\",\n                \"Simd128ExtractLaneOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void VisitRRI(InstructionSelectorT* selector, ArchOpcode opcode, OpIndex node) {\n            ArmOperandGeneratorT g(selector);\n            const Operation& op = selector->Get(node);\n            int imm = op.template Cast<Simd128ExtractLaneOp>().lane;\n            selector->Emit(opcode, g.DefineAsRegister(node), g.UseRegister(op.input(0)),\n                            g.UseImmediate(imm));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRIR\",\n            \"about\": \"Handles SIMD replace lane operations.\",\n            \"logic\": \"Emits an instruction with two register operands, an immediate operand representing the lane index, and another register operand representing the new lane value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ArmOperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"Simd128ReplaceLaneOp\",\n                \"Operation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void VisitRRIR(InstructionSelectorT* selector, ArchOpcode opcode,\n                OpIndex node) {\n            ArmOperandGeneratorT g(selector);\n            const Simd128ReplaceLaneOp& op =\n                selector->Get(node).template Cast<Simd128ReplaceLaneOp>();\n            selector->Emit(opcode, g.DefineAsRegister(node), g.UseRegister(op.into()),\n                            g.UseImmediate(op.lane), g.UseUniqueRegister(op.new_lane()));\n            }\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchShift\",\n            \"about\": \"Tries to match a shift operation and generate appropriate instruction operands and addressing modes.\",\n            \"logic\": \"Checks if the given node is a shift operation. If so, it checks if the shift amount can be represented as an immediate. If it can, it sets the addressing mode to immediate. Otherwise, it sets the addressing mode to register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the instruction opcode to be modified.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"value_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the value.\"\n                },\n                {\n                    \"name\": \"shift_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the shift amount.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a shift operation was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ArmOperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpmaskT\",\n                \"ShiftOp\",\n                \"Operation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename OpmaskT, int kImmMin, int kImmMax, AddressingMode kImmMode,\n                    AddressingMode kRegMode>\n            bool TryMatchShift(InstructionSelectorT* selector,\n                            InstructionCode* opcode_return, OpIndex node,\n                            InstructionOperand* value_return,\n                            InstructionOperand* shift_return) {\n            ArmOperandGeneratorT g(selector);\n            const Operation& op = selector->Get(node);\n            if (op.Is<OpmaskT>()) {\n                const ShiftOp& shift = op.Cast<ShiftOp>();\n                *value_return = g.UseRegister(shift.left());\n                int32_t shift_by;\n                if (selector->MatchIntegralWord32Constant(shift.right(), &shift_by) &&\n                    base::IsInRange(shift_by, kImmMin, kImmMax)) {\n                *opcode_return |= AddressingModeField::encode(kImmMode);\n                *shift_return = g.UseImmediate(shift.right());\n                } else {\n                *opcode_return |= AddressingModeField::encode(kRegMode);\n                *shift_return = g.UseRegister(shift.right());\n                }\n                return true;\n            }\n            return false;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchShiftImmediate\",\n            \"about\": \"Tries to match a shift operation with an immediate shift amount and generate appropriate instruction operands and addressing modes.\",\n            \"logic\": \"Checks if the given node is a shift operation and if the shift amount can be represented as an immediate. If it can, it sets the addressing mode to immediate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the instruction opcode to be modified.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"value_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the value.\"\n                },\n                {\n                    \"name\": \"shift_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the shift amount.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a shift operation with an immediate shift amount was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ArmOperandGeneratorT\",\n                \"InstructionSelectorT\",\n                \"OpmaskT\",\n                \"ShiftOp\",\n                \"Operation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename OpmaskT, int kImmMin, int kImmMax, AddressingMode kImmMode>\n            bool TryMatchShiftImmediate(InstructionSelectorT* selector,\n                                    InstructionCode* opcode_return, OpIndex node,\n                                    InstructionOperand* value_return,\n                                    InstructionOperand* shift_return) {\n            ArmOperandGeneratorT g(selector);\n            const Operation& op = selector->Get(node);\n            if (op.Is<OpmaskT>()) {\n                const ShiftOp& shift = op.Cast<ShiftOp>();\n                int32_t shift_by;\n                if (selector->MatchIntegralWord32Constant(shift.right(), &shift_by) &&\n                    base::IsInRange(shift_by, kImmMin, kImmMax)) {\n                *opcode_return |= AddressingModeField::encode(kImmMode);\n                *value_return = g.UseRegister(shift.left());\n                *shift_return = g.UseImmediate(shift.right());\n                return true;\n                }\n            }\n            return false;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchROR\",\n            \"about\": \"Tries to match a Rotate Right operation.\",\n            \"logic\": \"Calls TryMatchShift with specific parameters for Rotate Right.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the instruction opcode to be modified.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"value_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the value.\"\n                },\n                {\n                    \"name\": \"shift_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the shift amount.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a Rotate Right operation was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"TryMatchShift\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool TryMatchROR(InstructionSelectorT* selector, InstructionCode* opcode_return,\n                    OpIndex node, InstructionOperand* value_return,\n                    InstructionOperand* shift_return) {\n            return TryMatchShift<Opmask::kWord32RotateRight, 1, 31,\n                                kMode_Operand2_R_ROR_I, kMode_Operand2_R_ROR_R>(\n                selector, opcode_return, node, value_return, shift_return);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchASR\",\n            \"about\": \"Tries to match an Arithmetic Shift Right operation.\",\n            \"logic\": \"Calls TryMatchShift with specific parameters for Arithmetic Shift Right.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the instruction opcode to be modified.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"value_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the value.\"\n                },\n                {\n                    \"name\": \"shift_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the shift amount.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if an Arithmetic Shift Right operation was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"TryMatchShift\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool TryMatchASR(InstructionSelectorT* selector, InstructionCode* opcode_return,\n                    OpIndex node, InstructionOperand* value_return,\n                    InstructionOperand* shift_return) {\n            return TryMatchShift<Opmask::kWord32ShiftRightArithmetic, 1, 32,\n                                kMode_Operand2_R_ASR_I, kMode_Operand2_R_ASR_R>(\n                    selector, opcode_return, node, value_return, shift_return) ||\n                TryMatchShift<Opmask::kWord32ShiftRightArithmeticShiftOutZeros, 1, 32,\n                                kMode_Operand2_R_ASR_I, kMode_Operand2_R_ASR_R>(\n                    selector, opcode_return, node, value_return, shift_return);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchLSL\",\n            \"about\": \"Tries to match a Logical Shift Left operation.\",\n            \"logic\": \"Calls TryMatchShift with specific parameters for Logical Shift Left.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the instruction opcode to be modified.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"value_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the value.\"\n                },\n                {\n                    \"name\": \"shift_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the shift amount.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a Logical Shift Left operation was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"TryMatchShift\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool TryMatchLSL(InstructionSelectorT* selector, InstructionCode* opcode_return,\n                    OpIndex node, InstructionOperand* value_return,\n                    InstructionOperand* shift_return) {\n            return TryMatchShift<Opmask::kWord32ShiftLeft, 0, 31, kMode_Operand2_R_LSL_I,\n                                kMode_Operand2_R_LSL_R>(selector, opcode_return, node,\n                                                        value_return, shift_return);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchLSLImmediate\",\n            \"about\": \"Tries to match a Logical Shift Left operation with immediate.\",\n            \"logic\": \"Calls TryMatchShiftImmediate with specific parameters for Logical Shift Left.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the instruction opcode to be modified.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"value_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the value.\"\n                },\n                {\n                    \"name\": \"shift_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the shift amount.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a Logical Shift Left operation with immediate was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"TryMatchShiftImmediate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool TryMatchLSLImmediate(InstructionSelectorT* selector,\n                                    InstructionCode* opcode_return, OpIndex node,\n                                    InstructionOperand* value_return,\n                                    InstructionOperand* shift_return) {\n            return TryMatchShiftImmediate<Opmask::kWord32ShiftLeft, 0, 31,\n                                        kMode_Operand2_R_LSL_I>(\n                selector, opcode_return, node, value_return, shift_return);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchLSR\",\n            \"about\": \"Tries to match a Logical Shift Right operation.\",\n            \"logic\": \"Calls TryMatchShift with specific parameters for Logical Shift Right.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the instruction opcode to be modified.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"value_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the value.\"\n                },\n                {\n                    \"name\": \"shift_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the shift amount.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a Logical Shift Right operation was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"TryMatchShift\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool TryMatchLSR(InstructionSelectorT* selector, InstructionCode* opcode_return,\n                    OpIndex node, InstructionOperand* value_return,\n                    InstructionOperand* shift_return) {\n            return TryMatchShift<Opmask::kWord32ShiftRightLogical, 1, 32,\n                                kMode_Operand2_R_LSR_I, kMode_Operand2_R_LSR_R>(\n                selector, opcode_return, node, value_return, shift_return);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchShift\",\n            \"about\": \"Tries to match any shift operation (ASR, LSL, LSR, ROR).\",\n            \"logic\": \"Calls TryMatchASR, TryMatchLSL, TryMatchLSR, and TryMatchROR in sequence.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode_return\",\n                    \"type\": \"InstructionCode*\",\n                    \"purpose\": \"Pointer to the instruction opcode to be modified.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"value_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the value.\"\n                },\n                {\n                    \"name\": \"shift_return\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"Pointer to the instruction operand for the shift amount.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if any shift operation was matched, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"TryMatchASR\",\n                \"TryMatchLSL\",\n                \"TryMatchLSR\",\n                \"TryMatchROR\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool TryMatchShift(InstructionSelectorT* selector,\n                    InstructionCode* opcode_return, OpIndex node,\n                    InstructionOperand* value_return,\n                    InstructionOperand* shift_return) {\n            return (\n                TryMatchASR(selector, opcode_return, node, value_return, shift_return) ||\n                TryMatchLSL(selector, opcode_return, node, value_return, shift_return) ||\n                TryMatchLSR(selector, opcode_return, node, value_return, shift_return) ||\n                TryMatchROR(selector, opcode_return, node, value_return, shift_return));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchImmediateOrShift\",\n            \"about\": \"Tries to match either an immediate or a shift operation.\",\n            \"logic\": \"First checks if the node can be"
}