{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/x64/baseline-assembler-x64-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/x64/baseline-assembler-x64-inl.h\",\n            \"file_name\": \"baseline-assembler-x64-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"This file defines inline methods and a helper class for the BaselineAssembler on the x64 architecture. It provides an interface for generating machine code for the baseline compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for macros, the base BaselineAssembler class, x64 register definitions, feedback vector objects, and literal objects.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/macros.h\"\n#include \"src/baseline/baseline-assembler.h\"\n#include \"src/codegen/x64/register-x64.h\"\n#include \"src/objects/feedback-vector.h\"\n#include \"src/objects/literal-objects-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BaselineAssembler::ScratchRegisterScope\",\n                \"about\": \"Manages the allocation and deallocation of scratch registers within a limited scope.  It ensures that registers are not accidentally clobbered and provides a mechanism to acquire and release them.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"assembler_\",\n                        \"type\": \"BaselineAssembler*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the BaselineAssembler instance.\"\n                    },\n                    {\n                        \"name\": \"prev_scope_\",\n                        \"type\": \"ScratchRegisterScope*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the previous ScratchRegisterScope (for nesting).\"\n                    },\n                    {\n                        \"name\": \"registers_used_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of how many scratch registers have been acquired in this scope.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BaselineAssembler\",\n                    \"Register\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass BaselineAssembler::ScratchRegisterScope {\n public:\n  explicit ScratchRegisterScope(BaselineAssembler* assembler)\n      : assembler_(assembler),\n        prev_scope_(assembler->scratch_register_scope_),\n        registers_used_(prev_scope_ == nullptr ? 0\n                                               : prev_scope_->registers_used_) {\n    assembler_->scratch_register_scope_ = this;\n  }\n  ~ScratchRegisterScope() { assembler_->scratch_register_scope_ = prev_scope_; }\n\n  Register AcquireScratch() {\n    DCHECK_LT(registers_used_, detail::kNumScratchRegisters);\n    return detail::kScratchRegisters[registers_used_++];\n  }\n\n private:\n  BaselineAssembler* assembler_;\n  ScratchRegisterScope* prev_scope_;\n  int registers_used_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RegisterFrameOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the memory operand for an interpreter register within the current stack frame.\",\n                \"logic\": \"Multiplies the register number by the system pointer size and adds it to the base pointer (rbp).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interpreter_register\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The interpreter register to access.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"The memory operand representing the register's location on the stack.\"\n                },\n                \"dependencies\": [\n                    \"kSystemPointerSize\",\n                    \"rbp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::RegisterFrameOperand(\n    interpreter::Register interpreter_register) {\n  return MemOperand(rbp, interpreter_register.ToOperand() * kSystemPointerSize);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RegisterFrameAddress\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Loads the address of an interpreter register within the current stack frame into a scratch register.\",\n                \"logic\": \"Calculates the address by multiplying the register number by the system pointer size and adding it to the base pointer (rbp), then uses `leaq` to load the address into the specified register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"interpreter_register\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The interpreter register to access.\"\n                    },\n                    {\n                        \"name\": \"rscratch\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The scratch register to load the address into.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"kSystemPointerSize\",\n                    \"rbp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::RegisterFrameAddress(\n    interpreter::Register interpreter_register, Register rscratch) {\n  return __ leaq(rscratch, MemOperand(rbp, interpreter_register.ToOperand() *\n                                               kSystemPointerSize));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"FeedbackVectorOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the memory operand for accessing the feedback vector within the current stack frame.\",\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"The memory operand representing the feedback vector's location on the stack.\"\n                },\n                \"dependencies\": [\n                    \"BaselineFrameConstants::kFeedbackVectorFromFp\",\n                    \"rbp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackVectorOperand() {\n  return MemOperand(rbp, BaselineFrameConstants::kFeedbackVectorFromFp);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"FeedbackCellOperand\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Calculates the memory operand for accessing the feedback cell within the current stack frame.\",\n                \"return\": {\n                    \"type\": \"MemOperand\",\n                    \"description\": \"The memory operand representing the feedback cell's location on the stack.\"\n                },\n                \"dependencies\": [\n                    \"BaselineFrameConstants::kFeedbackCellFromFp\",\n                    \"rbp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackCellOperand() {\n  return MemOperand(rbp, BaselineFrameConstants::kFeedbackCellFromFp);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Bind\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Binds a label to the current code generation point.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"label\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to bind.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::Bind(Label* label) { __ bind(label); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpTarget\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Emits an endbr64 instruction, marking the current location as a valid jump target (for control-flow enforcement technology).\",\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpTarget() {\n  __ endbr64();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Jump\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Emits an unconditional jump to the specified label.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::Jump(Label* target, Label::Distance distance) {\n  __ jmp(target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfRoot\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Emits a conditional jump to the specified label if the given register contains the specified root value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"RootIndex\",\n                        \"purpose\": \"The root index to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfRoot(Register value, RootIndex index,\n                                   Label* target, Label::Distance distance) {\n  __ JumpIfRoot(value, index, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfNotRoot\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Emits a conditional jump to the specified label if the given register does not contain the specified root value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to check.\"\n                    },\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"RootIndex\",\n                        \"purpose\": \"The root index to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotRoot(Register value, RootIndex index,\n                                      Label* target, Label::Distance distance) {\n  __ JumpIfNotRoot(value, index, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Emits a conditional jump to the specified label if the given register contains a Smi (small integer).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to check.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Register value, Label* target,\n                                  Label::Distance distance) {\n  __ JumpIfSmi(value, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfNotSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Emits a conditional jump to the specified label if the given register does not contain a Smi (small integer).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to check.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotSmi(Register value, Label* target,\n                                     Label::Distance distance) {\n  __ JumpIfNotSmi(value, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TestAndBranch\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Performs a bitwise AND operation between a register and a mask, and then jumps to the target label based on the specified condition code.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to test.\"\n                    },\n                    {\n                        \"name\": \"mask\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The mask to apply.\"\n                    },\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code to check.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::TestAndBranch(Register value, int mask, Condition cc,\n                                      Label* target, Label::Distance distance) {\n  if ((mask & 0xff) == mask) {\n    __ testb(value, Immediate(mask));\n  } else {\n    __ testl(value, Immediate(mask));\n  }\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIf\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Compares a register with an operand and jumps to the target label if the specified condition code is met.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code to check.\"\n                    },\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The left-hand side of the comparison (a register).\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"const Operand&\",\n                        \"purpose\": \"The right-hand side of the comparison (an operand).\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIf(Condition cc, Register lhs, const Operand& rhs,\n                               Label* target, Label::Distance distance) {\n  __ cmpq(lhs, rhs);\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfJSAnyIsPrimitive\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Checks if a JSAny value is a primitive and jumps to the target label if it is.  This function makes use of a scratch register.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"heap_object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the JSAny value to check.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the value is a primitive.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_STATIC_ROOTS_BOOL\nvoid BaselineAssembler::JumpIfJSAnyIsPrimitive(Register heap_object,\n                                               Label* target,\n                                               Label::Distance distance) {\n  __ AssertNotSmi(heap_object);\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  __ JumpIfJSAnyIsPrimitive(heap_object, scratch, target, distance);\n}\n#endif  // V8_STATIC_ROOTS_BOOL\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfObjectTypeFast\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Checks the object type of a heap object (fast version using IsObjectType or CmpObjectType) and jumps to the target label based on the condition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code to check.\"\n                    },\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the object to check.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The instance type to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ScratchRegisterScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectTypeFast(Condition cc, Register object,\n                                             InstanceType instance_type,\n                                             Label* target,\n                                             Label::Distance distance) {\n  __ AssertNotSmi(object);\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  if (cc == Condition::kEqual || cc == Condition::kNotEqual) {\n    __ IsObjectType(object, instance_type, scratch);\n  } else {\n    __ CmpObjectType(object, instance_type, scratch);\n  }\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfObjectType\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Checks the object type of a heap object and jumps to the target label based on the condition.  This version takes a register containing the map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code to check.\"\n                    },\n                    {\n                        \"name\": \"object\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the object to check.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The instance type to compare against.\"\n                    },\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the map of the object.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectType(Condition cc, Register object,\n                                         InstanceType instance_type,\n                                         Register map, Label* target,\n                                         Label::Distance distance) {\n  __ AssertNotSmi(object);\n  __ CmpObjectType(object, instance_type, map);\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfInstanceType\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Checks the instance type of a map object and jumps to the target label based on the condition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code to check.\"\n                    },\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the map object.\"\n                    },\n                    {\n                        \"name\": \"instance_type\",\n                        \"type\": \"InstanceType\",\n                        \"purpose\": \"The instance type to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfInstanceType(Condition cc, Register map,\n                                           InstanceType instance_type,\n                                           Label* target,\n                                           Label::Distance distance) {\n  if (v8_flags.debug_code) {\n    __ AssertNotSmi(map);\n    __ CmpObjectType(map, MAP_TYPE, kScratchRegister);\n    __ Assert(equal, AbortReason::kUnexpectedValue);\n  }\n  __ CmpInstanceType(map, instance_type);\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfPointer\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Compares a register with a memory operand and jumps to the target label if the specified condition code is met. Used for pointer comparisons.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code to check.\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare.\"\n                    },\n                    {\n                        \"name\": \"operand\",\n                        \"type\": \"MemOperand\",\n                        \"purpose\": \"The memory operand to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfPointer(Condition cc, Register value,\n                                      MemOperand operand, Label* target,\n                                      Label::Distance distance) {\n  __ cmpq(value, operand);\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Compares a register with a Smi (small integer) and jumps to the target label based on the condition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code to check.\"\n                    },\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register containing the value to compare.\"\n                    },\n                    {\n                        \"name\": \"smi\",\n                        \"type\": \"Tagged<Smi>\",\n                        \"purpose\": \"The Smi value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Condition cc, Register lhs, Tagged<Smi> smi,\n                                  Label* target, Label::Distance distance) {\n  __ SmiCompare(lhs, smi);\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfSmi\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Compares two registers for Smi equality and jumps based on the condition\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code for the jump.\"\n                    },\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare (left hand side).\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare (right hand side).\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"Distance to the target label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Condition cc, Register lhs, Register rhs,\n                                  Label* target, Label::Distance distance) {\n  __ SmiCompare(lhs, rhs);\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfImmediate\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Compares a register to an immediate value and jumps based on the condition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code to check.\"\n                    },\n                    {\n                        \"name\": \"left\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"The register to compare.\"\n                    },\n                    {\n                        \"name\": \"right\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The immediate value to compare against.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The label to jump to if the condition is met.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The expected distance to the target label (for optimization).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfImmediate(Condition cc, Register left, int right,\n                                        Label* target,\n                                        Label::Distance distance) {\n  __ cmpq(left, Immediate(right));\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"JumpIfTagged\",\n                \"parent\": \"BaselineAssembler\",\n                \"about\": \"Compares a tagged value in a register with a memory operand and jumps if the condition is met.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cc\",\n                        \"type\": \"Condition\",\n                        \"purpose\": \"The condition code to check.\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Register\",\n                        \"purpose\": \"Register to compare.\"\n                    },\n                    {\n                        \"name\": \"operand\",\n                        \"type\": \"MemOperand\",\n                        \"purpose\": \"Memory operand to compare.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"Label*\",\n                        \"purpose\": \"The target label to jump to.\"\n                    },\n                    {\n                        \"name\": \"distance\",\n                        \"type\": \"Label::Distance\",\n                        \"purpose\": \"The jump distance hint.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n// cmp_tagged\nvoid BaselineAssembler::JumpIfTagged(Condition cc, Register value,\n                                     MemOperand operand, Label* target,\n                                     Label::Distance distance) {\n  __ cmp_tagged(value, operand);\n  __ j(cc, target, distance);\n}\n        ]]></code>\n    "
}