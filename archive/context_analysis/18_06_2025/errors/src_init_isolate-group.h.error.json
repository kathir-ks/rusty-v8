{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/init/isolate-group.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 50, column 54",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/init/isolate-group.h\",\n            \"file_name\": \"isolate-group.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the IsolateGroup class, which manages isolates that share a pointer cage, especially when pointer compression is enabled.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library and V8-specific headers for memory management, concurrency, code generation, and other core functionalities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <memory>\n\n#include \"include/v8-memory-span.h\"\n#include \"src/base/once.h\"\n#include \"src/base/page-allocator.h\"\n#include \"src/base/platform/mutex.h\"\n#include \"src/codegen/external-reference-table.h\"\n#include \"src/common/globals.h\"\n#include \"src/flags/flags.h\"\n#include \"src/heap/memory-chunk-constants.h\"\n#include \"src/sandbox/code-pointer-table.h\"\n#include \"src/utils/allocation.h\"\n\n#ifdef V8_ENABLE_LEAPTIERING\n#include \"src/sandbox/js-dispatch-table.h\"\n#endif  // V8_ENABLE_LEAPTIERING\n\n#ifdef V8_ENABLE_SANDBOX\n#include \"src/base/region-allocator.h\"\n#endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SandboxedArrayBufferAllocator\",\n                \"about\": \"Allocates memory for ArrayBuffers inside a sandbox, using a region allocator.  This class aims to avoid address space exhaustion inside the sandbox by using a single region of virtual address space.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"region_alloc_\",\n                        \"type\": \"std::unique_ptr<base::RegionAllocator>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The region allocator used to allocate memory chunks.\"\n                    },\n                    {\n                        \"name\": \"end_of_accessible_region_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracks the end of the accessible region within the allocated memory.\"\n                    },\n                    {\n                        \"name\": \"sandbox_\",\n                        \"type\": \"Sandbox*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Sandbox instance this allocator belongs to.\"\n                    },\n                    {\n                        \"name\": \"mutex_\",\n                        \"type\": \"base::Mutex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mutex to protect access to the region allocator and other internal state.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Sandbox\",\n                    \"v8::PageAllocator\",\n                    \"base::RegionAllocator\",\n                    \"base::Mutex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#ifdef V8_ENABLE_SANDBOX\nclass MemoryChunkMetadata;\nclass Sandbox;\n\n// Backend allocator shared by all ArrayBufferAllocator instances inside one\n// sandbox. This way, there is a single region of virtual address space\n// reserved inside a sandbox from which all ArrayBufferAllocators allocate\n// their memory, instead of each allocator creating their own region, which\n// may cause address space exhaustion inside the sandbox.\n// TODO(chromium:1340224): replace this with a more efficient allocator.\nclass SandboxedArrayBufferAllocator {\n public:\n  SandboxedArrayBufferAllocator() = default;\n  SandboxedArrayBufferAllocator(const SandboxedArrayBufferAllocator&) = delete;\n  SandboxedArrayBufferAllocator& operator=(\n      const SandboxedArrayBufferAllocator&) = delete;\n\n  void LazyInitialize(Sandbox* sandbox);\n\n  bool is_initialized() const { return !!sandbox_; }\n\n  // Returns page allocator that's supposed to be used for allocating pages\n  // for V8 heap. In case pointer compression is enabled it allocates pages\n  // within the pointer compression cage.\n  v8::PageAllocator* page_allocator();\n\n  ~SandboxedArrayBufferAllocator();\n\n  void* Allocate(size_t length);\n\n  void Free(void* data);\n\n private:\n  // Use a region allocator with a \"page size\" of 128 bytes as a reasonable\n  // compromise between the number of regions it has to manage and the amount\n  // of memory wasted due to rounding allocation sizes up to the page size.\n  static constexpr size_t kAllocationGranularity = 128;\n  // The backing memory's accessible region is grown in chunks of this size.\n  static constexpr size_t kChunkSize = 1 * MB;\n\n  std::unique_ptr<base::RegionAllocator> region_alloc_;\n  size_t end_of_accessible_region_ = 0;\n  Sandbox* sandbox_ = nullptr;\n  base::Mutex mutex_;\n};\n#endif\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"IsolateGroup\",\n                \"about\": \"Manages a group of isolates that share a pointer cage. This is particularly important when pointer compression is enabled to avoid the 4GB limit of a single shared cage.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"default_isolate_group_\",\n                        \"type\": \"IsolateGroup*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Static member that holds the default isolate group.\"\n                    },\n                    {\n                        \"name\": \"reference_count_\",\n                        \"type\": \"std::atomic<int>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Atomic counter tracking the number of references to this group.\"\n                    },\n                    {\n                        \"name\": \"isolate_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of isolates belonging to this group.\"\n                    },\n                    {\n                        \"name\": \"page_allocator_\",\n                        \"type\": \"v8::PageAllocator*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Page allocator for allocating memory within this group.\"\n                    },\n                    {\n                        \"name\": \"trusted_pointer_compression_cage_\",\n                        \"type\": \"VirtualMemoryCage*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The trusted virtual memory cage used for pointer compression (if enabled).\"\n                    },\n                    {\n                        \"name\": \"pointer_compression_cage_\",\n                        \"type\": \"VirtualMemoryCage*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The virtual memory cage used for pointer compression (if enabled).\"\n                    },\n                    {\n                        \"name\": \"reservation_\",\n                        \"type\": \"VirtualMemoryCage\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Virtual memory reservation.\"\n                    },\n                    {\n                        \"name\": \"current_\",\n                        \"type\": \"thread_local static IsolateGroup*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Thread-local storage for the current isolate group (used in multi-cage configurations).\"\n                    },\n                    {\n                        \"name\": \"init_code_range_\",\n                        \"type\": \"base::OnceType\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Ensures the code range is initialized only once.\"\n                    },\n                    {\n                        \"name\": \"code_range_\",\n                        \"type\": \"std::unique_ptr<CodeRange>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Manages the code range for generated code.\"\n                    },\n                    {\n                        \"name\": \"external_ref_table_\",\n                        \"type\": \"Address[ExternalReferenceTable::kSizeIsolateIndependent]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Table of external references.\"\n                    },\n                    {\n                        \"name\": \"process_wide_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if this is the process-wide isolate group.\"\n                    },\n                    {\n                        \"name\": \"mutex_\",\n                        \"type\": \"base::Mutex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mutex for synchronizing access to the group.\"\n                    },\n                    {\n                        \"name\": \"read_only_artifacts_\",\n                        \"type\": \"std::unique_ptr<ReadOnlyArtifacts>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Manages read-only artifacts shared by isolates in the group.\"\n                    },\n                    {\n                        \"name\": \"shared_read_only_heap_\",\n                        \"type\": \"ReadOnlyHeap*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Shared read-only heap for isolates in the group.\"\n                    },\n                    {\n                        \"name\": \"shared_space_isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An isolate that holds the shared space objects.\"\n                    },\n                    {\n                        \"name\": \"optimizing_compile_task_executor_\",\n                        \"type\": \"std::unique_ptr<OptimizingCompileTaskExecutor>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Executor for optimizing compile tasks.\"\n                    },\n                    {\n                        \"name\": \"sandbox_\",\n                        \"type\": \"Sandbox*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Sandbox instance (if sandbox is enabled).\"\n                    },\n                    {\n                        \"name\": \"code_pointer_table_\",\n                        \"type\": \"CodePointerTable\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Table of code pointers (if sandbox is enabled).\"\n                    },\n                    {\n                        \"name\": \"metadata_pointer_table_\",\n                        \"type\": \"MemoryChunkMetadata*[MemoryChunkConstants::kMetadataPointerTableSize]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Table of memory chunk metadata pointers (if sandbox is enabled).\"\n                    },\n                    {\n                        \"name\": \"backend_allocator_\",\n                        \"type\": \"SandboxedArrayBufferAllocator\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Allocator for ArrayBuffer backing stores when sandboxing is enabled.\"\n                    },\n                    {\n                        \"name\": \"js_dispatch_table_\",\n                        \"type\": \"JSDispatchTable\",\n                        \"access\": \"private\",\n                        \"purpose\": \"JS dispatch table for leap-tiering (if enabled).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"v8::PageAllocator\",\n                    \"VirtualMemoryCage\",\n                    \"CodeRange\",\n                    \"ExternalReferenceTable\",\n                    \"ReadOnlyArtifacts\",\n                    \"ReadOnlyHeap\",\n                    \"Isolate\",\n                    \"OptimizingCompileTaskExecutor\",\n                    \"Sandbox\",\n                    \"CodePointerTable\",\n                    \"MemoryChunkMetadata\",\n                    \"SandboxedArrayBufferAllocator\",\n                    \"JSDispatchTable\",\n                    \"base::LeakyObject\",\n                    \"PoolTest\",\n                    \"base::OnceType\",\n                    \"base::Mutex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass CodeRange;\nclass Isolate;\nclass OptimizingCompileTaskExecutor;\nclass ReadOnlyHeap;\nclass ReadOnlyArtifacts;\nclass SnapshotData;\n\n// An IsolateGroup allows an API user to control which isolates get allocated\n// together in a shared pointer cage.\n//\n// The standard configuration of V8 is to enable pointer compression and to\n// allocate all isolates in a single shared pointer cage\n// (V8_COMPRESS_POINTERS_IN_SHARED_CAGE).  This also enables the sandbox\n// (V8_ENABLE_SANDBOX), of which there can currently be only one per process, as\n// it requires a large part of the virtual address space.\n//\n// The standard configuration comes with a limitation, in that the total size of\n// the compressed pointer cage is limited to 4 GB.  Some API users would like\n// pointer compression but also want to avoid the 4 GB limit of the shared\n// pointer cage.  Isolate groups allow users to declare which isolates should be\n// co-located in a single pointer cage.\n//\n// Isolate groups are useful only if pointer compression is enabled.  Otherwise,\n// the isolate could just allocate pages from the global system allocator;\n// there's no need to stay within any particular address range.  If pointer\n// compression is disabled, there is just one global isolate group.\n//\n// Note that JavaScript objects can only be passed between isolates of the same\n// group.  Ensuring this invariant is the responsibility of the API user.\nclass V8_EXPORT_PRIVATE IsolateGroup final {\n public:\n  // InitializeOncePerProcess should be called early on to initialize the\n  // process-wide group.\n  static IsolateGroup* AcquireDefault() { return GetDefault()->Acquire(); }\n\n  // Return true if we can create additional isolate groups: only the case if\n  // multiple pointer cages were configured in at build-time.\n  static constexpr bool CanCreateNewGroups() {\n    return COMPRESS_POINTERS_IN_MULTIPLE_CAGES_BOOL;\n  }\n\n  // Create a new isolate group, allocating a fresh pointer cage if pointer\n  // compression is enabled.  If new groups cannot be created in this build\n  // configuration, abort.\n  //\n  // The pointer cage for isolates in this group will be released when the\n  // group's refcount drops to zero.  The group's initial refcount is 1.\n  static IsolateGroup* New();\n\n  static void InitializeOncePerProcess();\n  static void TearDownOncePerProcess();\n\n  // Obtain a fresh reference on the isolate group.\n  IsolateGroup* Acquire() {\n    DCHECK_LT(0, reference_count_.load());\n    reference_count_++;\n    return this;\n  }\n\n  // Release a reference on an isolate group, possibly freeing any shared memory\n  // resources.\n  void Release();\n\n  v8::PageAllocator* page_allocator() const { return page_allocator_; }\n\n#ifdef V8_COMPRESS_POINTERS\n  VirtualMemoryCage* GetPtrComprCage() const {\n    return pointer_compression_cage_;\n  }\n  VirtualMemoryCage* GetTrustedPtrComprCage() const {\n    return trusted_pointer_compression_cage_;\n  }\n  Address GetPtrComprCageBase() const { return GetPtrComprCage()->base(); }\n  Address GetTrustedPtrComprCageBase() const {\n    return GetTrustedPtrComprCage()->base();\n  }\n#endif  // V8_COMPRESS_POINTERS\n\n  CodeRange* EnsureCodeRange(size_t requested_size);\n  CodeRange* GetCodeRange() const { return code_range_.get(); }\n\n#ifdef V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n#ifdef USING_V8_SHARED_PRIVATE\n  static IsolateGroup* current() { return current_non_inlined(); }\n  static void set_current(IsolateGroup* group) {\n    set_current_non_inlined(group);\n  }\n#else   // !USING_V8_SHARED_PRIVATE\n  static IsolateGroup* current() { return current_; }\n  static void set_current(IsolateGroup* group) { current_ = group; }\n#endif  // USING_V8_SHARED_PRIVATE\n#else   // !V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n  static IsolateGroup* current() { return GetDefault(); }\n#endif  // V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n\n  MemorySpan<Address> external_ref_table() { return external_ref_table_; }\n\n  bool has_shared_space_isolate() const {\n    return shared_space_isolate_ != nullptr;\n  }\n\n  Isolate* shared_space_isolate() const {\n    return shared_space_isolate_;\n  }\n\n  void init_shared_space_isolate(Isolate* isolate) {\n    DCHECK(!has_shared_space_isolate());\n    shared_space_isolate_ = isolate;\n  }\n\n  OptimizingCompileTaskExecutor* optimizing_compile_task_executor();\n\n  ReadOnlyHeap* shared_read_only_heap() const { return shared_read_only_heap_; }\n  void set_shared_read_only_heap(ReadOnlyHeap* heap) {\n    shared_read_only_heap_ = heap;\n  }\n\n  base::Mutex* mutex() { return &mutex_; }\n\n  ReadOnlyArtifacts* read_only_artifacts() {\n    return read_only_artifacts_.get();\n  }\n\n  ReadOnlyArtifacts* InitializeReadOnlyArtifacts();\n\n  // Unlike page_allocator() this one is supposed to be used for allocation\n  // of memory for array backing stores or Wasm memory. When pointer compression\n  // is enabled it allocates memory outside of the pointer compression\n  // cage. When sandbox is enabled, it allocates memory within the sandbox.\n  PageAllocator* GetBackingStorePageAllocator();\n\n#ifdef V8_ENABLE_SANDBOX\n  Sandbox* sandbox() { return sandbox_; }\n\n  CodePointerTable* code_pointer_table() { return &code_pointer_table_; }\n\n  MemoryChunkMetadata** metadata_pointer_table() {\n    return metadata_pointer_table_;\n  }\n\n  SandboxedArrayBufferAllocator* GetSandboxedArrayBufferAllocator();\n#endif  // V8_ENABLE_SANDBOX\n\n#ifdef V8_ENABLE_LEAPTIERING\n  JSDispatchTable* js_dispatch_table() { return &js_dispatch_table_; }\n#endif  // V8_ENABLE_LEAPTIERING\n\n  void SetupReadOnlyHeap(Isolate* isolate,\n                         SnapshotData* read_only_snapshot_data,\n                         bool can_rehash);\n  void AddIsolate(Isolate* isolate);\n  void RemoveIsolate(Isolate* isolate);\n\n  V8_INLINE static IsolateGroup* GetDefault() { return default_isolate_group_; }\n\n private:\n  friend class base::LeakyObject<IsolateGroup>;\n  friend class PoolTest;\n\n  // Unless you manually create a new isolate group, all isolates in a process\n  // are in the same isolate group and share process-wide resources from\n  // that default group.\n  static IsolateGroup* default_isolate_group_;\n\n  IsolateGroup() = default;\n  ~IsolateGroup();\n  IsolateGroup(const IsolateGroup&) = delete;\n  IsolateGroup& operator=(const IsolateGroup&) = delete;\n\n  // Only used for testing.\n  static void ReleaseDefault();\n\n#ifdef V8_ENABLE_SANDBOX\n  void Initialize(bool process_wide, Sandbox* sandbox);\n#else   // V8_ENABLE_SANDBOX\n  void Initialize(bool process_wide);\n#endif  // V8_ENABLE_SANDBOX\n\n#ifdef V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n  static IsolateGroup* current_non_inlined();\n  static void set_current_non_inlined(IsolateGroup* group);\n#endif\n\n  std::atomic<int> reference_count_{1};\n  int isolate_count_{0};\n  v8::PageAllocator* page_allocator_ = nullptr;\n\n#ifdef V8_COMPRESS_POINTERS\n  VirtualMemoryCage* trusted_pointer_compression_cage_ = nullptr;\n  VirtualMemoryCage* pointer_compression_cage_ = nullptr;\n  VirtualMemoryCage reservation_;\n#endif  // V8_COMPRESS_POINTERS\n\n#ifdef V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n  thread_local static IsolateGroup* current_;\n#endif  // V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES\n\n  base::OnceType init_code_range_ = V8_ONCE_INIT;\n  std::unique_ptr<CodeRange> code_range_;\n  Address external_ref_table_[ExternalReferenceTable::kSizeIsolateIndependent] =\n      {0};\n\n  bool process_wide_;\n\n  // Mutex used to synchronize adding and removing of isolates to this group. It\n  // is also used to ensure that ReadOnlyArtifacts creation is only done once.\n  base::Mutex mutex_;\n  std::unique_ptr<ReadOnlyArtifacts> read_only_artifacts_;\n  ReadOnlyHeap* shared_read_only_heap_ = nullptr;\n  Isolate* shared_space_isolate_ = nullptr;\n  std::unique_ptr<OptimizingCompileTaskExecutor>\n      optimizing_compile_task_executor_;\n\n#ifdef V8_ENABLE_SANDBOX\n  Sandbox* sandbox_ = nullptr;\n  CodePointerTable code_pointer_table_;\n  MemoryChunkMetadata*\n      metadata_pointer_table_[MemoryChunkConstants::kMetadataPointerTableSize] =\n          {nullptr};\n  SandboxedArrayBufferAllocator backend_allocator_;\n#endif  // V8_ENABLE_SANDBOX\n\n#ifdef V8_ENABLE_LEAPTIERING\n  JSDispatchTable js_dispatch_table_;\n#endif  // V8_ENABLE_LEAPTIERING\n};\n        ]]></code>\n    </class>\n</file>\n```"
}