{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/structural-optimization-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 89, column 48",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/structural-optimization-reducer.h\",\n            \"file_name\": \"structural-optimization-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines a reducer that transforms if-else cascades into switch statements in the Turboshaft compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard C++ library for input/output operations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cstdio>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for Turboshaft assembler, index, opmasks, and zone management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/turboshaft/assembler.h\"\n            #include \"src/compiler/turboshaft/index.h\"\n            #include \"src/compiler/turboshaft/opmasks.h\"\n            #include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StructuralOptimizationReducer\",\n                \"about\": \"A reducer that transforms if-else cascades into switch statements in the Turboshaft compiler.\",\n                \"dependencies\": [\n                    \"Next\",\n                    \"SwitchOp\",\n                    \"Block\",\n                    \"BranchOp\",\n                    \"ComparisonOp\",\n                    \"ConstantOp\",\n                    \"Graph\",\n                    \"OpIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <class Next>\n            class StructuralOptimizationReducer : public Next {\n            public:\n            TURBOSHAFT_REDUCER_BOILERPLATE(StructuralOptimization)\n\n            OpIndex ReduceInputGraphBranch(OpIndex input_index, const BranchOp& branch);\n\n            private:\n            static bool ContainsOnlyPureOps(const Block* block, const Graph& graph);\n            void InlineAllOperationsWithoutLast(const Block* input_block);\n            V<None> EmitSwitch(OpIndex switch_var,\n                                base::SmallVector<SwitchOp::Case, 16>& cases,\n                                base::SmallVector<const Block*, 16>& false_blocks,\n                                Block* current_if_false, BranchHint next_hint);\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceInputGraphBranch\",\n                \"parent\": \"StructuralOptimizationReducer\",\n                \"about\": \"Reduces a branch operation in the input graph by potentially transforming an if-else cascade into a switch statement.\",\n                \"logic\": \"This function attempts to identify a chain of if-else statements that all compare the same variable to different constant values. If such a chain is found, it is transformed into a switch statement. The function handles cases where the comparison is an equality check (x == constant) or a simple truthiness check (if(x)). It also considers branch hints to optimize the generated switch statement.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"input_index\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The index of the input operation in the graph.\"\n                    },\n                    {\n                        \"name\": \"branch\",\n                        \"type\": \"const BranchOp&\",\n                        \"purpose\": \"The branch operation to be reduced.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The index of the new operation (switch statement) or the original input index if no reduction was performed.\"\n                },\n                \"dependencies\": [\n                    \"Next::ReduceInputGraphBranch\",\n                    \"SwitchOp\",\n                    \"Block\",\n                    \"BranchOp\",\n                    \"ComparisonOp\",\n                    \"ConstantOp\",\n                    \"Asm().input_graph()\",\n                    \"Asm().MapToNewGraph\",\n                    \"EmitSwitch\",\n                    \"ContainsOnlyPureOps\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            OpIndex StructuralOptimizationReducer::ReduceInputGraphBranch(OpIndex input_index, const BranchOp& branch) {\n            LABEL_BLOCK(no_change) {\n                return Next::ReduceInputGraphBranch(input_index, branch);\n            }\n            if (ShouldSkipOptimizationStep()) goto no_change;\n\n            TRACE(\"[structural] Calling ReduceInputGraphBranch for index: %u\\n\",\n                    static_cast<unsigned int>(input_index.id()));\n\n            base::SmallVector<SwitchOp::Case, 16> cases;\n            base::SmallVector<const Block*, 16> false_blocks;\n\n            Block* current_if_true;\n            Block* current_if_false;\n            const BranchOp* current_branch = &branch;\n            BranchHint current_branch_hint;\n            BranchHint next_hint = BranchHint::kNone;\n\n            OpIndex switch_var = OpIndex::Invalid();\n            uint32_t value;\n            while (true) {\n                // If we encounter a condition that is not equality, we can't turn it\n                // into a switch case.\n                const Operation& cond =\n                    Asm().input_graph().Get(current_branch->condition());\n\n                if (!cond.template Is<ComparisonOp>()) {\n                    // 'if(x==0)' may be optimized to 'if(x)', we should take this into\n                    // consideration.\n\n                    // The \"false\" destination will be inlined before the switch is emitted,\n                    // so it should only contain pure operations.\n                    if (!ContainsOnlyPureOps(current_branch->if_true,\n                                            Asm().input_graph())) {\n                    TRACE(\"\\t [break] End of only-pure-ops cascade reached.\\n\");\n                    break;\n                    }\n\n                    OpIndex current_var = current_branch->condition();\n                    if (!switch_var.valid()) {\n                    switch_var = current_var;\n                    } else if (switch_var != current_var) {\n                    TRACE(\"\\t [bailout] Not all branches compare the same variable.\\n\");\n                    break;\n                    }\n                    value = 0;\n                    // The true/false of 'if(x)' is reversed from 'if(x==0)'\n                    current_if_true = current_branch->if_false;\n                    current_if_false = current_branch->if_true;\n                    const BranchHint hint = current_branch->hint;\n                    current_branch_hint = hint == BranchHint::kNone   ? BranchHint::kNone\n                                        : hint == BranchHint::kTrue ? BranchHint::kFalse\n                                                            : BranchHint::kTrue;\n                } else {\n                    const ComparisonOp* equal =\n                        cond.template TryCast<Opmask::kWord32Equal>();\n                    if (!equal) {\n                    TRACE(\n                        \"\\t [bailout] Branch with different condition than Word32 \"\n                        \"Equal.\\n\");\n                    break;\n                    }\n                    // MachineOptimizationReducer should normalize equality to put constants\n                    // right.\n                    const Operation& right_op = Asm().input_graph().Get(equal->right());\n                    if (!right_op.Is<Opmask::kWord32Constant>()) {\n                    TRACE(\n                        \"\\t [bailout] No Word32 constant on the right side of Equal.\\n\");\n                    break;\n                    }\n\n                    // The \"false\" destination will be inlined before the switch is emitted,\n                    // so it should only contain pure operations.\n                    if (!ContainsOnlyPureOps(current_branch->if_false,\n                                            Asm().input_graph())) {\n                    TRACE(\"\\t [break] End of only-pure-ops cascade reached.\\n\");\n                    break;\n                    }\n                    const ConstantOp& const_op = right_op.Cast<ConstantOp>();\n                    value = const_op.word32();\n\n                    // If we encounter equal to a different value, we can't introduce\n                    // a switch.\n                    OpIndex current_var = equal->left();\n                    if (!switch_var.valid()) {\n                    switch_var = current_var;\n                    } else if (switch_var != current_var) {\n                    TRACE(\"\\t [bailout] Not all branches compare the same variable.\\n\");\n                    break;\n                    }\n\n                    current_if_true = current_branch->if_true;\n                    current_if_false = current_branch->if_false;\n                    current_branch_hint = current_branch->hint;\n                }\n\n                DCHECK(current_if_true && current_if_false);\n\n                // We can't just use `current_branch->hint` for every case. Consider:\n                //\n                //     if (a) { }\n                //     else if (b) { }\n                //     else if (likely(c)) { }\n                //     else if (d) { }\n                //     else { }\n                //\n                // The fact that `c` is Likely doesn't tell anything about the likelyness\n                // of `a` and `b` compared to `c`, which means that `c` shouldn't have the\n                // Likely hint in the switch. However, since `c` is likely here, it means\n                // that `d` and \"default\" are both unlikely, even in the switch.\n                //\n                // So, for the 1st case, we use `current_branch->hint`.\n                // Then, when we encounter a Likely hint, we mark all of the subsequent\n                // cases are Unlikely, but don't mark the current one as Likely. This is\n                // done with the `next_hint` variable, which is initially kNone, but\n                // because kFalse when we encounter a Likely branch.\n                // We never set `next_hint` as kTrue as it would only apply to subsequent\n                // cases and not to already-emitted cases. The only case that could thus\n                // have a kTrue annotation is the 1st one.\n                DCHECK_NE(next_hint, BranchHint::kTrue);\n                BranchHint hint = next_hint;\n                if (cases.size() == 0) {\n                    // The 1st case gets its original hint.\n                    hint = current_branch_hint;\n                } else if (current_branch_hint == BranchHint::kFalse) {\n                    // For other cases, if the branch has a kFalse hint, we do use it,\n                    // regardless of `next_hint`.\n                    hint = BranchHint::kNone;\n                }\n                if (current_branch_hint == BranchHint::kTrue) {\n                    // This branch is likely true, which means that all subsequent cases are\n                    // unlikely.\n                    next_hint = BranchHint::kFalse;\n                }\n\n                // The current_if_true block becomes the corresponding switch case block.\n                cases.emplace_back(value, Asm().MapToNewGraph(current_if_true), hint);\n\n                // All pure ops from the if_false block should be executed before\n                // the switch, except the last Branch operation (which we drop).\n                false_blocks.push_back(current_if_false);\n\n                // If we encounter a if_false block that doesn't end with a Branch,\n                // this means we've reached the end of the cascade.\n                const Operation& maybe_branch =\n                    current_if_false->LastOperation(Asm().input_graph());\n                if (!maybe_branch.Is<BranchOp>()) {\n                    TRACE(\"\\t [break] Reached end of the if-else cascade.\\n\");\n                    break;\n                }\n\n                // Iterate to the next if_false block in the cascade.\n                current_branch = &maybe_branch.template Cast<BranchOp>();\n            }\n\n            // Probably better to keep short if-else cascades as they are.\n            if (cases.size() <= 2) {\n                TRACE(\"\\t [bailout] Cascade with less than 2 levels of nesting.\\n\");\n                goto no_change;\n            }\n            CHECK_EQ(cases.size(), false_blocks.size());\n\n            // Sorting the cases because it will help figure out if there is a duplicate\n            // case (in which case we bailout, since this is not well handled by the\n            // code generator).\n            // Note that this isn't wasted work: there is a good chance that the\n            // instruction selector will emit a binary search for this switch, which\n            // will require the cases to be sorted.\n            std::stable_sort(\n                cases.begin(), cases.end(),\n                [](SwitchOp::Case a, SwitchOp::Case b) { return a.value < b.value; });\n            auto it = std::adjacent_find(\n                cases.begin(), cases.end(),\n                [](SwitchOp::Case a, SwitchOp::Case b) { return a.value == b.value; });\n            if (it != cases.end()) {\n                TRACE(\"\\t [bailout] Multiple cases with the value %d.\\n\", (*it).value);\n                goto no_change;\n            }\n\n            TRACE(\"[reduce] Successfully emit a Switch with %zu cases.\\n\",\n                cases.size());\n            return EmitSwitch(switch_var, cases, false_blocks, current_if_false,\n                            next_hint);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ContainsOnlyPureOps\",\n                \"parent\": \"StructuralOptimizationReducer\",\n                \"about\": \"Checks if a block contains only pure operations.\",\n                \"logic\": \"Iterates through the operations of the block (excluding the last operation) and checks if each operation's effects allow it to be hoisted before a branch.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"const Block*\",\n                        \"purpose\": \"The block to check.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const Graph&\",\n                        \"purpose\": \"The graph containing the block.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the block contains only pure operations, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Graph\",\n                    \"Block\",\n                    \"op.Effects().hoistable_before_a_branch()\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            static bool StructuralOptimizationReducer::ContainsOnlyPureOps(const Block* block, const Graph& graph) {\n                for (const auto& op : base::IterateWithoutLast(graph.operations(*block))) {\n                // We are moving the block content to before the switch, effectively\n                // moving it before the previously existing branches.\n                if (!op.Effects().hoistable_before_a_branch()) {\n                    return false;\n                }\n                }\n                return true;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InlineAllOperationsWithoutLast\",\n                \"parent\": \"StructuralOptimizationReducer\",\n                \"about\": \"Inlines all operations in a block except for the last one.\",\n                \"logic\": \"Iterates through the operations in the input block (except the last one) and inlines each operation using the Asm().InlineOp method.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"input_block\",\n                        \"type\": \"const Block*\",\n                        \"purpose\": \"The block whose operations are to be inlined.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Asm().input_graph()\",\n                    \"Asm().InlineOp\",\n                    \"Block\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void StructuralOptimizationReducer::InlineAllOperationsWithoutLast(const Block* input_block) {\n                base::iterator_range<Graph::OpIndexIterator> all_ops =\n                    Asm().input_graph().OperationIndices(*input_block);\n\n                for (OpIndex op : base::IterateWithoutLast(all_ops)) {\n                Asm().InlineOp(op, input_block);\n                }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EmitSwitch\",\n                \"parent\": \"StructuralOptimizationReducer\",\n                \"about\": \"Emits a switch statement based on the provided cases and default block.\",\n                \"logic\": \"This function constructs a switch statement by first inlining operations from the false blocks (except the last one), and then creating a Switch operation using the provided switch variable, cases, default block, and branch hint.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"switch_var\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The variable to switch on.\"\n                    },\n                    {\n                        \"name\": \"cases\",\n                        \"type\": \"base::SmallVector<SwitchOp::Case, 16>&\",\n                        \"purpose\": \"The cases for the switch statement.\"\n                    },\n                    {\n                        \"name\": \"false_blocks\",\n                        \"type\": \"base::SmallVector<const Block*, 16>&\",\n                        \"purpose\": \"The blocks corresponding to the false branches of the if-else cascade.\"\n                    },\n                    {\n                        \"name\": \"current_if_false\",\n                        \"type\": \"Block*\",\n                        \"purpose\": \"The default block for the switch statement.\"\n                    },\n                    {\n                        \"name\": \"next_hint\",\n                        \"type\": \"BranchHint\",\n                        \"purpose\": \"The branch hint for the switch statement.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"V<None>\",\n                    \"description\": \"Returns OpIndex::Invalid()\"\n                },\n                \"dependencies\": [\n                    \"InlineAllOperationsWithoutLast\",\n                    \"Asm().MapToNewGraph\",\n                    \"Asm().output_graph().graph_zone()->CloneVector\",\n                    \"Asm().Switch\",\n                    \"Block\",\n                    \"SwitchOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            V<None> StructuralOptimizationReducer::EmitSwitch(OpIndex switch_var,\n                                base::SmallVector<SwitchOp::Case, 16>& cases,\n                                base::SmallVector<const Block*, 16>& false_blocks,\n                                Block* current_if_false, BranchHint next_hint) {\n                // We're skipping the last false block, as it becomes the default block.\n                for (size_t i = 0; i < false_blocks.size() - 1; ++i) {\n                    const Block* block = false_blocks[i];\n                    InlineAllOperationsWithoutLast(block);\n                }\n\n                // The last current_if_true block that ends the cascade becomes the default\n                // case.\n                Block* default_block = current_if_false;\n                Asm().Switch(\n                    Asm().MapToNewGraph(switch_var),\n                    Asm().output_graph().graph_zone()->CloneVector(base::VectorOf(cases)),\n                    Asm().MapToNewGraph(default_block), next_hint);\n                return OpIndex::Invalid();\n            }\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Next\",\n                    \"about\": \"Base class for the reducer.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Next {\n                public:\n                    OpIndex ReduceInputGraphBranch(OpIndex input_index, const BranchOp& branch) { return OpIndex::Invalid(); }\n                    bool ShouldSkipOptimizationStep() { return false; }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Assembler\",\n                    \"about\": \"Assembles the Turboshaft graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Assembler {\n                public:\n                    Graph& input_graph() { /* return input graph */ }\n                    Graph& output_graph() { /* return output graph */ }\n                    OpIndex MapToNewGraph(OpIndex index) { return index; }\n                    Block* MapToNewGraph(Block* block) { return block; }\n                    void Switch(OpIndex switch_var,\n                        base::Vector<SwitchOp::Case> cases,\n                        Block* default_block, BranchHint next_hint) {}\n\n                    void InlineOp(OpIndex op, Block* block) {}\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SwitchOp\",\n                    \"about\": \"Represents a switch operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class SwitchOp {\n                public:\n                    struct Case {\n                        uint32_t value;\n                        Block* block;\n                        BranchHint hint;\n                    };\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Block\",\n                    \"about\": \"Represents a basic block in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Block {\n                public:\n                    Operation& LastOperation(Graph& graph) const;\n                    Graph::OperationIndices all_operations() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"BranchOp\",\n                    \"about\": \"Represents a branch operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class BranchOp {\n                public:\n                    OpIndex condition() const;\n                    Block* if_true;\n                    Block* if_false;\n                    BranchHint hint;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ComparisonOp\",\n                    \"about\": \"Represents a comparison operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ComparisonOp {\n                public:\n                    OpIndex left() const;\n                    OpIndex right() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ConstantOp\",\n                    \"about\": \"Represents a constant operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ConstantOp {\n                public:\n                    uint32_t word32() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Graph\",\n                    \"about\": \"Represents the Turboshaft graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Graph {\n                public:\n                    const Operation& Get(OpIndex index) const;\n                    base::iterator_range<Graph::OpIndexIterator> operations(const Block* block) const;\n                    class OpIndexIterator {};\n                    Zone* graph_zone() { return nullptr; }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"OpIndex\",\n                    \"about\": \"Represents an index to an operation in the graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class OpIndex {\n                public:\n                    unsigned int id() const { return 0; }\n                    bool valid() const { return false; }\n                    static OpIndex Invalid() { return OpIndex{}; }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"enum\",\n                    \"name\": \"BranchHint\",\n                    \"about\": \"Represents a hint for branch prediction.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                enum class BranchHint {\n                    kNone,\n                    kTrue,\n                    kFalse\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Operation\",\n                    \"about\": \"Represents an operation in the Turboshaft graph.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Operation {\n                public:\n                    template <typename T>\n                    bool Is() const { return false; }\n                    template <typename T>\n                    const T* TryCast() const { return nullptr; }\n                    const Effects& Effects() const;\n                    template <typename T>\n                    const T& Cast() const;\n\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Effects\",\n                    \"about\": \"Represents the effects of an operation.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Effects {\n                public:\n                    bool hoistable_before_a_branch() const { return false; }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Zone\",\n                    \"about\": \"Memory allocation zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Zone {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"template\",\n                    \"name\": \"V\",\n                    \"about\": \"Return type.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class V {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}