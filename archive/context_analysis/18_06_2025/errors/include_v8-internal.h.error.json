{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-internal.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-internal.h\",\n        \"file_name\": \"v8-internal.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Internal header file for the V8 JavaScript engine, defining internal data structures, constants, and utility functions used within V8. This file is not part of the public V8 API.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard C++ headers for basic types, memory management, atomics, and other utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stddef.h>\n            #include <stdint.h>\n            #include <string.h>\n\n            #include <atomic>\n            #include <iterator>\n            #include <limits>\n            #include <memory>\n            #include <optional>\n            #include <type_traits>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"V8 configuration settings.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"v8config.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Support for three-way comparison (spaceship operator) if available.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #if __has_include(<version>)\n            #include <version>\n            #endif\n            #if defined(__cpp_lib_three_way_comparison) &&   \\\n                __cpp_lib_three_way_comparison >= 201711L && \\\n                defined(__cpp_lib_concepts) && __cpp_lib_concepts >= 202002L\n            #include <compare>\n            #include <concepts>\n\n            #define V8_HAVE_SPACESHIP_OPERATOR 1\n            #else\n            #define V8_HAVE_SPACESHIP_OPERATOR 0\n            #endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Array\",\n            \"about\": \"Forward declaration of the Array class.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            class Array;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Context\",\n            \"about\": \"Forward declaration of the Context class.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            class Context;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Data\",\n            \"about\": \"Forward declaration of the Data class.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            class Data;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Isolate\",\n            \"about\": \"Forward declaration of the Isolate class.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            class Isolate;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Heap\",\n            \"parent\": \"None\",\n            \"about\": \"Forward declaration of the Heap class.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        class Heap;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LocalHeap\",\n            \"parent\": \"None\",\n            \"about\": \"Forward declaration of the LocalHeap class.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        class LocalHeap;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Isolate\",\n            \"parent\": \"None\",\n            \"about\": \"Forward declaration of the Isolate class in internal namespace.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        class Isolate;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IsolateGroup\",\n            \"parent\": \"None\",\n            \"about\": \"Forward declaration of the IsolateGroup class.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        class IsolateGroup;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LocalIsolate\",\n            \"parent\": \"None\",\n            \"about\": \"Forward declaration of the LocalIsolate class.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        class LocalIsolate;\n        ]]></code>\n    </class>\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"Address\",\n            \"about\": \"Defines an alias for uintptr_t, used to represent memory addresses.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            typedef uintptr_t Address;\n        ]]></code>\n    </typedef>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kNullAddress\",\n            \"about\": \"Defines a constant for the null address.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            static constexpr Address kNullAddress = 0;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"KB\",\n            \"about\": \"Defines a constant for Kilobyte size.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr int KB = 1024;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"MB\",\n            \"about\": \"Defines a constant for Megabyte size.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr int MB = KB * 1024;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"GB\",\n            \"about\": \"Defines a constant for Gigabyte size.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr int GB = MB * 1024;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"TB\",\n            \"about\": \"Defines a constant for Terabyte size.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_TARGET_ARCH_X64\n            constexpr size_t TB = size_t{GB} * 1024;\n            #endif\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kApiSystemPointerSize\",\n            \"about\": \"Size of a system pointer.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kApiSystemPointerSize = sizeof(void*);\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kApiDoubleSize\",\n            \"about\": \"Size of a double.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kApiDoubleSize = sizeof(double);\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kApiInt32Size\",\n            \"about\": \"Size of an int32_t.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kApiInt32Size = sizeof(int32_t);\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kApiInt64Size\",\n            \"about\": \"Size of an int64_t.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kApiInt64Size = sizeof(int64_t);\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kApiSizetSize\",\n            \"about\": \"Size of a size_t.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kApiSizetSize = sizeof(size_t);\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kHeapObjectTag\",\n            \"about\": \"Tag for HeapObject.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kHeapObjectTag = 1;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kWeakHeapObjectTag\",\n            \"about\": \"Tag for WeakHeapObject.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kWeakHeapObjectTag = 3;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kHeapObjectTagSize\",\n            \"about\": \"Size of HeapObject tag.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kHeapObjectTagSize = 2;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kHeapObjectTagMask\",\n            \"about\": \"Mask for HeapObject tag.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const intptr_t kHeapObjectTagMask = (1 << kHeapObjectTagSize) - 1;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kHeapObjectReferenceTagMask\",\n            \"about\": \"Mask for HeapObject reference tag.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const intptr_t kHeapObjectReferenceTagMask = 1 << (kHeapObjectTagSize - 1);\n        ]]></code>\n    </constant>\n        <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kForwardingTag\",\n            \"about\": \"Tag for forwarding pointers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n        const int kForwardingTag = 0;\n        ]]></code>\n    </constant>\n        <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kForwardingTagSize\",\n            \"about\": \"Size for forwarding pointers tag.\"\n        }\n        </metadata>\n        <code><![CDATA[\n        const int kForwardingTagSize = 2;\n        ]]></code>\n    </constant>\n        <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kForwardingTagMask\",\n            \"about\": \"Mask for forwarding pointers tag.\"\n        }\n        </metadata>\n        <code><![CDATA[\n        const intptr_t kForwardingTagMask = (1 << kForwardingTagSize) - 1;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSmiTag\",\n            \"about\": \"Tag for Smi (small integer).\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kSmiTag = 0;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSmiTagSize\",\n            \"about\": \"Size of Smi tag.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kSmiTagSize = 1;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSmiTagMask\",\n            \"about\": \"Mask for Smi tag.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            const intptr_t kSmiTagMask = (1 << kSmiTagSize) - 1;\n        ]]></code>\n    </constant>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SmiTagging\",\n            \"about\": \"Template struct for Smi tagging based on tagged pointer size.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <size_t tagged_ptr_size>\n            struct SmiTagging;\n        ]]></code>\n    </class>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kIntptrAllBitsSet\",\n            \"about\": \"Constant where all bits are set in intptr_t.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr intptr_t kIntptrAllBitsSet = intptr_t{-1};\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kUintptrAllBitsSet\",\n            \"about\": \"Constant where all bits are set in uintptr_t.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr uintptr_t kUintptrAllBitsSet =\n                static_cast<uintptr_t>(kIntptrAllBitsSet);\n        ]]></code>\n    </constant>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SmiTagging<4>\",\n            \"about\": \"Specialization of SmiTagging for 32-bit tagged pointers.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct SmiTagging<4> {\n              enum { kSmiShiftSize = 0, kSmiValueSize = 31 };\n\n              static constexpr intptr_t kSmiMinValue =\n                  static_cast<intptr_t>(kUintptrAllBitsSet << (kSmiValueSize - 1));\n              static constexpr intptr_t kSmiMaxValue = -(kSmiMinValue + 1);\n\n              V8_INLINE static constexpr int SmiToInt(Address value) {\n                int shift_bits = kSmiTagSize + kSmiShiftSize;\n                // Truncate and shift down (requires >> to be sign extending).\n                return static_cast<int32_t>(static_cast<uint32_t>(value)) >> shift_bits;\n              }\n\n              template <class T, typename std::enable_if_t<std::is_integral_v<T> &&\n                                                           std::is_signed_v<T>>* = nullptr>\n              V8_INLINE static constexpr bool IsValidSmi(T value) {\n                // Is value in range [kSmiMinValue, kSmiMaxValue].\n                // Use unsigned operations in order to avoid undefined behaviour in case of\n                // signed integer overflow.\n                return (static_cast<uintptr_t>(value) -\n                        static_cast<uintptr_t>(kSmiMinValue)) <=\n                       (static_cast<uintptr_t>(kSmiMaxValue) -\n                        static_cast<uintptr_t>(kSmiMinValue));\n              }\n\n              template <class T,\n                        typename std::enable_if_t<std::is_integral_v<T> &&\n                                                  std::is_unsigned_v<T>>* = nullptr>\n              V8_INLINE static constexpr bool IsValidSmi(T value) {\n                static_assert(kSmiMaxValue <= std::numeric_limits<uintptr_t>::max());\n                return value <= static_cast<uintptr_t>(kSmiMaxValue);\n              }\n\n              // Same as the `intptr_t` version but works with int64_t on 32-bit builds\n              // without slowing down anything else.\n              V8_INLINE static constexpr bool IsValidSmi(int64_t value) {\n                return (static_cast<uint64_t>(value) -\n                        static_cast<uint64_t>(kSmiMinValue)) <=\n                       (static_cast<uint64_t>(kSmiMaxValue) -\n                        static_cast<uint64_t>(kSmiMinValue));\n              }\n\n              V8_INLINE static constexpr bool IsValidSmi(uint64_t value) {\n                static_assert(kSmiMaxValue <= std::numeric_limits<uint64_t>::max());\n                return value <= static_cast<uint64_t>(kSmiMaxValue);\n              }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"SmiTagging<8>\",\n            \"about\": \"Specialization of SmiTagging for 64-bit tagged pointers.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            struct SmiTagging<8> {\n              enum { kSmiShiftSize = 31, kSmiValueSize = 32 };\n\n              static constexpr intptr_t kSmiMinValue =\n                  static_cast<intptr_t>(kUintptrAllBitsSet << (kSmiValueSize - 1));\n              static constexpr intptr_t kSmiMaxValue = -(kSmiMinValue + 1);\n\n              V8_INLINE static constexpr int SmiToInt(Address value) {\n                int shift_bits = kSmiTagSize + kSmiShiftSize;\n                // Shift down and throw away top 32 bits.\n                return static_cast<int>(static_cast<intptr_t>(value) >> shift_bits);\n              }\n\n              template <class T, typename std::enable_if_t<std::is_integral_v<T> &&\n                                                           std::is_signed_v<T>>* = nullptr>\n              V8_INLINE static constexpr bool IsValidSmi(T value) {\n                // To be representable as a long smi, the value must be a 32-bit integer.\n                return std::numeric_limits<int32_t>::min() <= value &&\n                       value <= std::numeric_limits<int32_t>::max();\n              }\n\n              template <class T,\n                        typename std::enable_if_t<std::is_integral_v<T> &&\n                                                  std::is_unsigned_v<T>>* = nullptr>\n              V8_INLINE static constexpr bool IsValidSmi(T value) {\n                return value <= std::numeric_limits<int32_t>::max();\n              }\n            };\n        ]]></code>\n    </class>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kPtrComprCageReservationSize\",\n            \"about\": \"Size of the pointer compression cage reservation.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_COMPRESS_POINTERS\n            // See v8:7703 or src/common/ptr-compr-inl.h for details about pointer\n            // compression.\n            constexpr size_t kPtrComprCageReservationSize = size_t{1} << 32;\n            #endif\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kPtrComprCageBaseAlignment\",\n            \"about\": \"Alignment of the pointer compression cage base.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_COMPRESS_POINTERS\n            constexpr size_t kPtrComprCageBaseAlignment = size_t{1} << 32;\n            #endif\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kApiTaggedSize\",\n            \"about\": \"Size of tagged values (with pointer compression enabled or disabled).\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_COMPRESS_POINTERS\n            static_assert(\n                kApiSystemPointerSize == kApiInt64Size,\n                \"Pointer compression can be enabled only for 64-bit architectures\");\n            const int kApiTaggedSize = kApiInt32Size;\n            #else\n            const int kApiTaggedSize = kApiSystemPointerSize;\n            #endif\n        ]]></code>\n    </constant>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PointerCompressionIsEnabled\",\n            \"about\": \"Determines if pointer compression is enabled.\",\n            \"logic\": \"Compares the size of a tagged value with the size of a system pointer.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if pointer compression is enabled, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr bool PointerCompressionIsEnabled() {\n              return kApiTaggedSize != kApiSystemPointerSize;\n            }\n        ]]></code>\n    </func>\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"PlatformSmiTagging\",\n            \"about\": \"Selects the correct SmiTagging struct based on the architecture.\",\n            \"dependencies\": [\n                \"SmiTagging\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_31BIT_SMIS_ON_64BIT_ARCH\n            using PlatformSmiTagging = SmiTagging<kApiInt32Size>;\n            #else\n            using PlatformSmiTagging = SmiTagging<kApiTaggedSize>;\n            #endif\n        ]]></code>\n    </typedef>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSmiShiftSize\",\n            \"about\": \"Shift size for Smi values.\",\n            \"dependencies\": [\n                \"PlatformSmiTagging\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kSmiShiftSize = PlatformSmiTagging::kSmiShiftSize;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSmiValueSize\",\n            \"about\": \"Size of Smi values.\",\n            \"dependencies\": [\n                \"PlatformSmiTagging\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kSmiValueSize = PlatformSmiTagging::kSmiValueSize;\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSmiMinValue\",\n            \"about\": \"Minimum Smi value.\",\n            \"dependencies\": [\n                \"PlatformSmiTagging\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kSmiMinValue = static_cast<int>(PlatformSmiTagging::kSmiMinValue);\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSmiMaxValue\",\n            \"about\": \"Maximum Smi value.\",\n            \"dependencies\": [\n                \"PlatformSmiTagging\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            const int kSmiMaxValue = static_cast<int>(PlatformSmiTagging::kSmiMaxValue);\n        ]]></code>\n    </constant>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SmiValuesAre31Bits\",\n            \"about\": \"Checks if Smi values are 31 bits.\",\n            \"logic\": \"Checks the kSmiValueSize.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if Smi values are 31 bits, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr bool SmiValuesAre31Bits() { return kSmiValueSize == 31; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SmiValuesAre32Bits\",\n            \"about\": \"Checks if Smi values are 32 bits.\",\n            \"logic\": \"Checks the kSmiValueSize.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if Smi values are 32 bits, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr bool SmiValuesAre32Bits() { return kSmiValueSize == 32; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Is64\",\n            \"about\": \"Checks if the architecture is 64-bit.\",\n            \"logic\": \"Compares the size of a system pointer with the size of an int64_t.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the architecture is 64-bit, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr bool Is64() { return kApiSystemPointerSize == sizeof(int64_t); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IntToSmi\",\n            \"about\": \"Converts an integer to a Smi.\",\n            \"logic\": \"Shifts the integer and applies the Smi tag.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The integer value to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Address\",\n                \"description\": \"The Smi representation of the integer.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE static constexpr Address IntToSmi(int value) {\n              return (static_cast<Address>(value) << (kSmiTagSize + kSmiShiftSize)) |\n                     kSmiTag;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SandboxIsEnabled\",\n            \"about\": \"Checks if the V8 sandbox is enabled.\",\n            \"logic\": \"Uses a preprocessor definition to determine if the sandbox is enabled.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the sandbox is enabled, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            constexpr bool SandboxIsEnabled() {\n            #ifdef V8_ENABLE_SANDBOX\n              return true;\n            #else\n              return false;\n            #endif\n            }\n        ]]></code>\n    </func>\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"SandboxedPointer_t\",\n            \"about\": \"Type definition for sandboxed pointers.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            using SandboxedPointer_t = Address;\n        ]]></code>\n    </typedef>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSandboxSizeLog2\",\n            \"about\": \"Log2 of the sandbox size.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_ENABLE_SANDBOX\n            #if defined(V8_TARGET_OS_ANDROID)\n            constexpr size_t kSandboxSizeLog2 = 37;  // 128 GB\n            #else\n            constexpr size_t kSandboxSizeLog2 = 40;  // 1 TB\n            #endif  // V8_TARGET_OS_ANDROID\n            #endif\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSandboxSize\",\n            \"about\": \"Size of the sandbox.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_ENABLE_SANDBOX\n            constexpr size_t kSandboxSize = 1ULL << kSandboxSizeLog2;\n            #endif\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSandboxAlignment\",\n            \"about\": \"Alignment requirement for the sandbox.\",\n            \"dependencies\": [\n                \"kPtrComprCageBaseAlignment\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_ENABLE_SANDBOX\n            constexpr size_t kSandboxAlignment = kPtrComprCageBaseAlignment;\n            #endif\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSandboxedPointerShift\",\n            \"about\": \"Shift amount for sandboxed pointers.\",\n            \"dependencies\": [\n                \"kSandboxSizeLog2\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_ENABLE_SANDBOX\n            constexpr uint64_t kSandboxedPointerShift = 64 - kSandboxSizeLog2;\n            #endif\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSandboxGuardRegionSize\",\n            \"about\": \"Size of the guard region around the sandbox.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_ENABLE_SANDBOX\n            constexpr size_t kSandboxGuardRegionSize = 32ULL * GB + 4ULL * GB;\n            #endif\n        ]]></code>\n    </constant>\n    <constant>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constant\",\n            \"name\": \"kSandboxMinimumReservationSize\",\n            \"about\": \"Minimum reservation size for the sandbox.\",\n            \""
}