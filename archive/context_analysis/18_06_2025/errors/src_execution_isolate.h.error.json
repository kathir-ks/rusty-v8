{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/isolate.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/isolate.h\",\n            \"file_name\": \"isolate.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the Isolate class, the central context in which JavaScript code executes within V8.  It manages the heap, execution state, and other resources.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard C++ headers for data structures, memory management, and concurrency\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <atomic>\n            #include <cstddef>\n            #include <functional>\n            #include <list>\n            #include <memory>\n            #include <optional>\n            #include <queue>\n            #include <unordered_map>\n            #include <vector>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 public API headers for interacting with the engine\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"include/v8-context.h\"\n            #include \"include/v8-internal.h\"\n            #include \"include/v8-isolate.h\"\n            #include \"include/v8-metrics.h\"\n            #include \"include/v8-snapshot.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 internal headers for various components like base utilities, builtins, common data structures, debugging, execution, handles, heap management, initialization, objects, runtime functions, sandbox, and utilities\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/macros.h\"\n            #include \"src/base/platform/mutex.h\"\n            #include \"src/base/platform/platform-posix.h\"\n            #include \"src/builtins/builtins.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/common/thread-local-storage.h\"\n            #include \"src/debug/interface-types.h\"\n            #include \"src/execution/execution.h\"\n            #include \"src/execution/futex-emulation.h\"\n            #include \"src/execution/isolate-data.h\"\n            #include \"src/execution/messages.h\"\n            #include \"src/execution/mutex-guard-if-off-thread.h\"\n            #include \"src/execution/stack-guard.h\"\n            #include \"src/handles/handles.h\"\n            #include \"src/handles/traced-handles.h\"\n            #include \"src/heap/factory.h\"\n            #include \"src/heap/heap.h\"\n            #include \"src/heap/read-only-heap.h\"\n            #include \"src/init/isolate-group.h\"\n            #include \"src/objects/code.h\"\n            #include \"src/objects/contexts.h\"\n            #include \"src/objects/debug-objects.h\"\n            #include \"src/objects/js-objects.h\"\n            #include \"src/objects/tagged.h\"\n            #include \"src/runtime/runtime.h\"\n            #include \"src/sandbox/code-pointer-table.h\"\n            #include \"src/sandbox/external-pointer-table.h\"\n            #include \"src/sandbox/trusted-pointer-table.h\"\n            #include \"src/utils/allocation.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Debug-related imports, only included when DEBUG is defined\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #ifdef DEBUG\n            #include \"src/runtime/runtime-utils.h\"\n            #endif\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"WebAssembly support imports, only included when V8_ENABLE_WEBASSEMBLY is defined\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/wasm/stacks.h\"\n            #endif\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"ICU internationalization library support, only included when V8_INTL_SUPPORT is defined\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_INTL_SUPPORT\n            #include \"unicode/uversion.h\"  // Define U_ICU_NAMESPACE.\n            namespace U_ICU_NAMESPACE {\n            class UMemory;\n            }  // namespace U_ICU_NAMESPACE\n            #endif  // V8_INTL_SUPPORT\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Simulator support for testing on different architectures, only included when USE_SIMULATOR is defined\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #if USE_SIMULATOR\n            #include \"src/execution/encoded-c-signature.h\"\n            namespace v8 {\n            namespace internal {\n            class SimulatorData;\n            }\n            }  // namespace v8\n            #endif\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 Inspector integration\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8_inspector {\n            class V8Inspector;\n            }  // namespace v8_inspector\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Forward declarations of V8 API classes\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n\n            class EmbedderState;\n\n            namespace base {\n            class RandomNumberGenerator;\n            }  // namespace base\n\n            namespace bigint {\n            class Processor;\n            }\n\n            namespace debug {\n            class ConsoleDelegate;\n            class AsyncEventDelegate;\n            }  // namespace debug\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Forward declarations of V8 internal classes and namespaces\"\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n\n            void DefaultWasmAsyncResolvePromiseCallback(\n                v8::Isolate* isolate, v8::Local<v8::Context> context,\n                v8::Local<v8::Promise::Resolver> resolver,\n                v8::Local<v8::Value> compilation_result, WasmAsyncSuccess success);\n\n            namespace heap {\n            class HeapTester;\n            }  // namespace heap\n\n            namespace maglev {\n            class MaglevConcurrentDispatcher;\n            }  // namespace maglev\n\n            class AddressToIndexHashMap;\n            class AstStringConstants;\n            class Bootstrapper;\n            class BuiltinsConstantsTableBuilder;\n            class CancelableTaskManager;\n            class Logger;\n            class CodeTracer;\n            class CommonFrame;\n            class CompilationCache;\n            class CompilationStatistics;\n            class Counters;\n            class Debug;\n            class Deoptimizer;\n            class DescriptorLookupCache;\n            class EmbeddedFileWriterInterface;\n            class EternalHandles;\n            class GlobalHandles;\n            class GlobalSafepoint;\n            class HandleScopeImplementer;\n            class HeapObjectToIndexHashMap;\n            class HeapProfiler;\n            class InnerPointerToCodeCache;\n            class LazyCompileDispatcher;\n            class LocalIsolate;\n            class V8FileLogger;\n            class MaterializedObjectStore;\n            class Microtask;\n            class MicrotaskQueue;\n            class OptimizingCompileDispatcher;\n            class OptimizingCompileTaskExecutor;\n            class PersistentHandles;\n            class PersistentHandlesList;\n            class ReadOnlyArtifacts;\n            class RegExpStack;\n            class RootVisitor;\n            class SetupIsolateDelegate;\n            class SharedStructTypeRegistry;\n            class Simulator;\n            class SnapshotData;\n            class StackFrame;\n            class StringForwardingTable;\n            class StringTable;\n            class StubCache;\n            class ThreadManager;\n            class ThreadState;\n            class ThreadVisitor;  // Defined in v8threads.h\n            class TieringManager;\n            class TracingCpuProfilerImpl;\n            class UnicodeCache;\n            struct ManagedPtrDestructor;\n\n            template <StateTag Tag>\n            class VMState;\n\n            namespace baseline {\n            class BaselineBatchCompiler;\n            }  // namespace baseline\n\n            namespace interpreter {\n            class Interpreter;\n            }  // namespace interpreter\n\n            namespace compiler {\n            class NodeObserver;\n            class PerIsolateCompilerCache;\n            namespace turboshaft {\n            class WasmRevecVerifier;\n            }  // namespace turboshaft\n            }  // namespace compiler\n\n            namespace win64_unwindinfo {\n            class BuiltinUnwindInfo;\n            }  // namespace win64_unwindinfo\n\n            namespace metrics {\n            class Recorder;\n            }  // namespace metrics\n\n            namespace wasm {\n\n            #if V8_ENABLE_DRUMBRAKE\n            class WasmExecutionTimer;\n            #endif  // V8_ENABLE_DRUMBRAKE\n            class WasmCodeLookupCache;\n            class WasmOrphanedGlobalHandle;\n            }\n\n            namespace detail {\n            class WaiterQueueNode;\n            }  // namespace detail\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"extends\": \"HiddenFactory\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.  Contains the heap, compiler, and execution state.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"HiddenFactory\",\n                    \"IsolateGroup\",\n                    \"Heap\",\n                    \"ReadOnlyHeap\",\n                    \"StringTable\",\n                    \"StringForwardingTable\",\n                    \"Bootstrapper\",\n                    \"TieringManager\",\n                    \"CompilationCache\",\n                    \"Counters\",\n                    \"V8FileLogger\",\n                    \"StubCache\",\n                    \"Deoptimizer\",\n                    \"MaterializedObjectStore\",\n                    \"DescriptorLookupCache\",\n                    \"HandleScopeImplementer\",\n                    \"UnicodeCache\",\n                    \"GlobalHandles\",\n                    \"EternalHandles\",\n                    \"ThreadManager\",\n                    \"RegExpStack\",\n                    \"Debug\",\n                    \"Logger\",\n                    \"Factory\",\n                    \"ExternalCallbackScope\",\n                    \"StateTag\",\n                    \"EmbedderState\",\n                    \"IsolateData\",\n                    \"RootsTable\",\n                    \"ExternalReferenceTable\",\n                    \"Builtins\",\n                    \"ThreadLocalTop\",\n                    \"DateCache\",\n                    \"interpreter::Interpreter\",\n                    \"compiler::PerIsolateCompilerCache\",\n                    \"AccountingAllocator\",\n                    \"LazyCompileDispatcher\",\n                    \"BuiltinsConstantsTableBuilder\",\n                    \"CancelableTaskManager\",\n                    \"AstStringConstants\",\n                    \"FutexWaitListNode\",\n                    \"LocalIsolate\",\n                    \"compiler::turboshaft::WasmRevecVerifier\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {\n              // These forward declarations are required to make the friend declarations in\n              // PerIsolateThreadData work on some older versions of gcc.\n              class ThreadDataTable;\n              class EntryStackItem;\n\n             public:\n              Isolate(const Isolate&) = delete;\n              Isolate& operator=(const Isolate&) = delete;\n\n              using HandleScopeType = HandleScope;\n              void* operator new(size_t) = delete;\n              void operator delete(void*) = delete;\n\n              // A thread has a PerIsolateThreadData instance for each isolate that it has\n              // entered. That instance is allocated when the isolate is initially entered\n              // and reused on subsequent entries.\n              class PerIsolateThreadData {\n               public:\n                PerIsolateThreadData(Isolate* isolate, ThreadId thread_id)\n                    : isolate_(isolate),\n                      thread_id_(thread_id),\n                      stack_limit_(0),\n                      thread_state_(nullptr)\n            #if USE_SIMULATOR\n                      ,\n                      simulator_(nullptr)\n            #endif\n                {\n                }\n                ~PerIsolateThreadData();\n                PerIsolateThreadData(const PerIsolateThreadData&) = delete;\n                PerIsolateThreadData& operator=(const PerIsolateThreadData&) = delete;\n                Isolate* isolate() const { return isolate_; }\n                ThreadId thread_id() const { return thread_id_; }\n\n                FIELD_ACCESSOR(uintptr_t, stack_limit)\n                FIELD_ACCESSOR(ThreadState*, thread_state)\n            #if USE_SIMULATOR\n                FIELD_ACCESSOR(Simulator*, simulator)\n            #endif\n\n                bool Matches(Isolate* isolate, ThreadId thread_id) const {\n                  return isolate_ == isolate && thread_id_ == thread_id;\n                }\n\n               private:\n                Isolate* isolate_;\n                ThreadId thread_id_;\n                uintptr_t stack_limit_;\n                ThreadState* thread_state_;\n\n            #if USE_SIMULATOR\n                Simulator* simulator_;\n            #endif\n\n                friend class Isolate;\n                friend class ThreadDataTable;\n                friend class EntryStackItem;\n              };\n\n              // Used for walking the promise tree for catch prediction.\n              struct PromiseHandler {\n                Tagged<SharedFunctionInfo> function_info;\n                bool async;\n              };\n\n              static void InitializeOncePerProcess();\n\n              // Creates Isolate object. Must be used instead of constructing Isolate with\n              // new operator.\n              static Isolate* New();\n              static Isolate* New(IsolateGroup* isolate_group);\n\n              // Deletes Isolate object. Must be used instead of delete operator.\n              // Destroys the non-default isolates.\n              // Sets default isolate into \"has_been_disposed\" state rather then destroying,\n              // for legacy API reasons.\n              static void Delete(Isolate* isolate);\n\n              void SetUpFromReadOnlyArtifacts(ReadOnlyArtifacts* artifacts);\n              void set_read_only_heap(ReadOnlyHeap* ro_heap) { read_only_heap_ = ro_heap; }\n\n              // Page allocator that must be used for allocating V8 heap pages.\n              v8::PageAllocator* page_allocator() const;\n\n              // Returns the PerIsolateThreadData for the current thread (or nullptr if one\n              // is not currently set).\n              V8_INLINE static PerIsolateThreadData* CurrentPerIsolateThreadData();\n\n              // Returns the isolate inside which the current thread is running or nullptr.\n              V8_TLS_DECLARE_GETTER(TryGetCurrent, Isolate*, g_current_isolate_)\n\n              // Returns the isolate inside which the current thread is running.\n              V8_INLINE static Isolate* Current();\n              static void SetCurrent(Isolate* isolate);\n\n              inline bool IsCurrent() const;\n\n              // Usually called by Init(), but can be called early e.g. to allow\n              // testing components that require logging but not the whole\n              // isolate.\n              //\n              // Safe to call more than once.\n              void InitializeLoggingAndCounters();\n              bool InitializeCounters();  // Returns false if already initialized.\n\n              bool InitWithoutSnapshot();\n              bool InitWithSnapshot(SnapshotData* startup_snapshot_data,\n                                    SnapshotData* read_only_snapshot_data,\n                                    SnapshotData* shared_heap_snapshot_data,\n                                    bool can_rehash);\n\n              // True if at least one thread Enter'ed this isolate.\n              bool IsInUse() { return entry_stack_ != nullptr; }\n\n              void ReleaseSharedPtrs();\n\n              void ClearSerializerData();\n\n              void UpdateLogObjectRelocation();\n\n              // Initializes the current thread to run this Isolate.\n              // Not thread-safe. Multiple threads should not Enter/Exit the same isolate\n              // at the same time, this should be prevented using external locking.\n              void Enter();\n\n              // Exits the current thread. The previously entered Isolate is restored\n              // for the thread.\n              // Not thread-safe. Multiple threads should not Enter/Exit the same isolate\n              // at the same time, this should be prevented using external locking.\n              void Exit();\n\n              // Find the PerThread for this particular (isolate, thread) combination.\n              // If one does not yet exist, allocate a new one.\n              PerIsolateThreadData* FindOrAllocatePerThreadDataForThisThread();\n\n              // Find the PerThread for this particular (isolate, thread) combination\n              // If one does not yet exist, return null.\n              PerIsolateThreadData* FindPerThreadDataForThisThread();\n\n              // Find the PerThread for given (isolate, thread) combination\n              // If one does not yet exist, return null.\n              PerIsolateThreadData* FindPerThreadDataForThread(ThreadId thread_id);\n\n              // Discard the PerThread for this particular (isolate, thread) combination\n              // If one does not yet exist, no-op.\n              void DiscardPerThreadDataForThisThread();\n\n              // Mutex for serializing access to break control structures.\n              base::RecursiveMutex* break_access() { return &break_access_; }\n\n              // Shared mutex for allowing thread-safe concurrent reads of FeedbackVectors.\n              base::Mutex* feedback_vector_access() { return &feedback_vector_access_; }\n\n              // Shared mutex for allowing thread-safe concurrent reads of\n              // InternalizedStrings.\n              base::Mutex* internalized_string_access() {\n                return &internalized_string_access_;\n              }\n\n              // Shared mutex for allowing thread-safe concurrent reads of TransitionArrays\n              // of kind kFullTransitionArray.\n              base::Mutex* full_transition_array_access() {\n                return &full_transition_array_access_;\n              }\n\n              // Shared mutex for allowing thread-safe concurrent reads of\n              // SharedFunctionInfos.\n              base::Mutex* shared_function_info_access() {\n                return &shared_function_info_access_;\n              }\n\n              // Protects (most) map update operations, see also MapUpdater.\n              base::Mutex* map_updater_access() { return &map_updater_access_; }\n\n              // Protects JSObject boilerplate migrations (i.e. calls to MigrateInstance on\n              // boilerplate objects; elements kind transitions are *not* protected).\n              // Note this lock interacts with `map_updater_access` as follows\n              //\n              // - boilerplate migrations may trigger map updates.\n              // - if so, `boilerplate_migration_access` is locked before\n              //   `map_updater_access`.\n              // - backgrounds threads must use the same lock order to avoid deadlocks.\n              base::Mutex* boilerplate_migration_access() {\n                return &boilerplate_migration_access_;\n              }\n\n              ReadOnlyArtifacts* read_only_artifacts() const {\n                ReadOnlyArtifacts* artifacts = isolate_group()->read_only_artifacts();\n                DCHECK_NOT_NULL(artifacts);\n                return artifacts;\n              }\n\n              // The isolate's string table.\n              StringTable* string_table() const {\n                return OwnsStringTables() ? string_table_.get()\n                                          : shared_space_isolate()->string_table_.get();\n              }\n              StringForwardingTable* string_forwarding_table() const {\n                return OwnsStringTables()\n                           ? string_forwarding_table_.get()\n                           : shared_space_isolate()->string_forwarding_table_.get();\n              }\n\n              SharedStructTypeRegistry* shared_struct_type_registry() const {\n                return is_shared_space_isolate()\n                           ? shared_struct_type_registry_.get()\n                           : shared_space_isolate()->shared_struct_type_registry_.get();\n              }\n\n              Address get_address_from_id(IsolateAddressId id);\n\n              // Access to top context (where the current function object was created).\n              Tagged<Context> context() const { return thread_local_top()->context_; }\n              inline void set_context(Tagged<Context> context);\n              Tagged<Context>* context_address() { return &thread_local_top()->context_; }\n\n              // The \"topmost script-having execution context\" from the Web IDL spec\n              // (i.e. the context of the topmost user JavaScript code, see\n              // https://html.spec.whatwg.org/multipage/webappapis.html#topmost-script-having-execution-context)\n              // if known or Context::kNoContext otherwise.\n              Tagged<Context> topmost_script_having_context() const {\n                return thread_local_top()->topmost_script_having_context_;\n              }\n              inline void set_topmost_script_having_context(Tagged<Context> context);\n              inline void clear_topmost_script_having_context();\n              Tagged<Context>* topmost_script_having_context_address() {\n                return &thread_local_top()->topmost_script_having_context_;\n              }\n\n              // Access to current thread id.\n              inline void set_thread_id(ThreadId id) {\n                thread_local_top()->thread_id_.store(id, std::memory_order_relaxed);\n              }\n              inline ThreadId thread_id() const {\n                return thread_local_top()->thread_id_.load(std::memory_order_relaxed);\n              }\n\n              void InstallConditionalFeatures(DirectHandle<NativeContext> context);\n\n            #if V8_ENABLE_WEBASSEMBLY\n              void WasmInitJSPIFeature();\n            #endif\n\n              bool IsSharedArrayBufferConstructorEnabled(\n                  DirectHandle<NativeContext> context);\n\n              bool IsWasmStringRefEnabled(DirectHandle<NativeContext> context);\n              bool IsWasmImportedStringsEnabled(DirectHandle<NativeContext> context);\n              // Has the JSPI flag been requested?\n              // Used only during initialization of contexts.\n              bool IsWasmJSPIRequested(DirectHandle<NativeContext> context);\n              // Has JSPI been enabled successfully?\n              bool IsWasmJSPIEnabled(DirectHandle<NativeContext> context);\n              bool IsCompileHintsMagicEnabled(Handle<NativeContext> context);\n\n              THREAD_LOCAL_TOP_ADDRESS(Tagged<Context>, pending_handler_context)\n              THREAD_LOCAL_TOP_ADDRESS(Address, pending_handler_entrypoint)\n              THREAD_LOCAL_TOP_ADDRESS(Address, pending_handler_constant_pool)\n              THREAD_LOCAL_TOP_ADDRESS(Address, pending_handler_fp)\n              THREAD_LOCAL_TOP_ADDRESS(Address, pending_handler_sp)\n              THREAD_LOCAL_TOP_ADDRESS(uintptr_t, num_frames_above_pending_handler)\n\n              v8::TryCatch* try_catch_handler() {\n                return thread_local_top()->try_catch_handler_;\n              }\n\n              // Interface to exception.\n              THREAD_LOCAL_TOP_ADDRESS(Tagged<Object>, exception)\n              inline Tagged<Object> exception();\n              inline void set_exception(Tagged<Object> exception_obj);\n              // Clear thrown exception from V8 and a possible TryCatch.\n              inline void clear_exception();\n\n              // Clear the exception only from V8, not from a possible external try-catch.\n              inline void clear_internal_exception();\n              inline bool has_exception();\n\n              THREAD_LOCAL_TOP_ADDRESS(Tagged<Object>, pending_message)\n              inline void clear_pending_message();\n              inline Tagged<Object> pending_message();\n              inline bool has_pending_message();\n              inline void set_pending_message(Tagged<Object> message_obj);\n\n            #ifdef DEBUG\n              inline Tagged<Object> VerifyBuiltinsResult(Tagged<Object> result);\n              inline ObjectPair VerifyBuiltinsResult(ObjectPair pair);\n            #endif\n\n              enum class ExceptionHandlerType {\n                kJavaScriptHandler,\n                kExternalTryCatch,\n                kNone\n              };\n\n              ExceptionHandlerType TopExceptionHandlerType(Tagged<Object> exception);\n\n              inline bool is_catchable_by_javascript(Tagged<Object> exception);\n              inline bool is_catchable_by_wasm(Tagged<Object> exception);\n              inline bool is_execution_terminating();\n\n              // JS execution stack (see frames.h).\n              static Address c_entry_fp(ThreadLocalTop* thread) {\n                return thread->c_entry_fp_;\n              }\n              static Address handler(ThreadLocalTop* thread) { return thread->handler_; }\n              Address c_function() { return thread_local_top()->c_function_; }\n\n              inline Address* c_entry_fp_address() {\n                return &thread_local_top()->c_entry_fp_;\n              }\n              static uint32_t c_entry_fp_offset() {\n                return static_cast<uint32_t>(OFFSET_OF(Isolate, isolate_data_) +\n                                             OFFSET_OF(IsolateData, thread_local_top_) +\n                                             OFFSET_OF(ThreadLocalTop, c_entry_fp_) -\n                                             isolate_root_bias());\n              }\n              inline Address* handler_address() { return &thread_local_top()->handler_; }\n              inline Address* c_function_address() {\n                return &thread_local_top()->c_function_;\n              }\n\n            #if defined(DEBUG) || defined(VERIFY_HEAP)\n              // Count the number of active deserializers, so that the heap verifier knows\n              // whether there is currently an active deserialization happening.\n              //\n              // This is needed as the verifier currently doesn't support verifying objects\n              // which are partially deserialized.\n              //\n              // TODO(leszeks): Make the verifier a bit more deserialization compatible.\n              void RegisterDeserializerStarted() { ++num_active_deserializers_; }\n              void RegisterDeserializerFinished() {\n                CHECK_GE(--num_active_deserializers_, 0);\n              }\n              bool has_active_deserializer() const {\n                return num_active_deserializers_.load(std::memory_order_acquire) > 0;\n              }\n            #else\n              void RegisterDeserializerStarted() {}\n              void RegisterDeserializerFinished() {}\n              bool has_active_deserializer() const { UNREACHABLE(); }\n            #endif\n\n              // Bottom JS entry.\n              Address js_entry_sp() { return thread_local_top()->js_entry_sp_; }\n              inline Address* js_entry_sp_address() {\n                return &thread_local_top()->js_entry_sp_;\n              }\n\n              std::vector<MemoryRange>* GetCodePages() const;\n\n              void SetCodePages(std::vector<MemoryRange>* new_code_pages);\n\n              // Returns the global object of the current context. It could be\n              // a builtin object, or a JS global object.\n              inline Handle<JSGlobalObject> global_object();\n\n              // Returns the global proxy object of the current context.\n              inline Handle<JSGlobalProxy> global_proxy();\n\n              static int ArchiveSpacePerThread() { return sizeof(ThreadLocalTop); }\n              void FreeThreadResources() { thread_local_top()->Free(); }\n\n              // Walks the call stack and promise tree and calls a callback on every\n              // function an exception is likely to hit. Used in catch prediction.\n              // Returns true if the exception is expected to be caught.\n              bool WalkCallStackAndPromiseTree(\n                  MaybeDirectHandle<JSPromise> rejected_promise,\n                  const std::function<void(PromiseHandler)>& callback);\n\n              class V8_NODISCARD ExceptionScope {\n               public:\n                // Scope currently can only be used for regular exceptions,\n                // not termination exception.\n                inline explicit ExceptionScope(Isolate* isolate);\n                inline ~ExceptionScope();\n\n               private:\n                Isolate* isolate_;\n                Handle<Object> exception_;\n              };\n\n              void SetCaptureStackTraceForUncaughtExceptions(\n                  bool capture, int frame_limit, StackTrace::StackTraceOptions options);\n              bool get_capture_stack_trace_for_uncaught_exceptions() const;\n\n              void SetAbortOnUncaughtExceptionCallback(\n                  v8::Isolate::AbortOnUncaughtExceptionCallback callback);\n\n              enum PrintStackMode { kPrintStackConcise, kPrintStackVerbose };\n              void PrintCurrentStackTrace(std::ostream& out,\n                                          PrintCurrentStackTraceFilterCallback\n                                              should_include_frame_callback = nullptr);\n              void PrintStack(StringStream* accumulator,\n                              PrintStackMode mode = kPrintStackVerbose);\n              void PrintStack(FILE* out, PrintStackMode mode = kPrintStackVerbose);\n              DirectHandle<String> StackTraceString();\n              // Stores a stack trace in a stack-allocated temporary buffer which will\n              // end up in the minidump for debugging purposes.\n              V8_NOINLINE void PushStackTraceAndDie(\n                  void* ptr1 = nullptr, void* ptr2 = nullptr, void* ptr3 = nullptr,\n                  void* ptr4 = nullptr, void* ptr5 = nullptr, void* ptr6 = nullptr);\n              // Similar to the above but without collecting the stack trace.\n              V8_NOINLINE void PushParamsAndDie(void* ptr1 = nullptr, void* ptr2 = nullptr,\n                                                void* ptr3 = nullptr, void* ptr4 = nullptr,\n                                                void* ptr5 = nullptr, void* ptr6 = nullptr);\n              // Like PushStackTraceAndDie but uses DumpWithoutCrashing to continue\n              // execution.\n              V8_NOINLINE void PushStackTraceAndContinue(\n                  void* ptr1 = nullptr, void* ptr2 = nullptr, void* ptr3 = nullptr,\n                  void* ptr4 = nullptr, void* ptr5 = nullptr, void* ptr6 = nullptr);\n              // Like PushParamsAndDie but uses DumpWithoutCrashing to continue\n              // execution.\n              V8_NOINLINE void PushParamsAndContinue(\n                  void* ptr1 = nullptr, void* ptr2 = nullptr, void* ptr3 = nullptr,\n                  void* ptr4 = nullptr, void* ptr5 = nullptr, void* ptr6 = nullptr);\n              DirectHandle<StackTraceInfo> CaptureDetailedStackTrace(\n                  int limit, StackTrace::StackTraceOptions options);\n              MaybeDirectHandle<JSObject> CaptureAndSetErrorStack(\n                  DirectHandle<JSObject> error_object, FrameSkipMode mode,\n                  Handle<Object> caller);\n              Handle<StackTraceInfo> GetDetailedStackTrace(\n                  DirectHandle<JSReceiver> error_object);\n              Handle<FixedArray> GetSimpleStackTrace(DirectHandle<JSReceiver> error_object);\n              // Walks the JS stack to find the first frame with a script name or\n              // source URL. The inspected frames are the same as for the detailed stack\n              // trace.\n              DirectHandle<String> CurrentScriptNameOrSourceURL();\n              MaybeDirectHandle<Script> CurrentReferrerScript();\n              bool GetStackTraceLimit(Isolate* isolate, int* result);\n\n              Address GetAbstractPC(int* line, int* column);\n\n              // Returns if the given context may access the given global object. If\n              // the result is false, the exception is guaranteed to be\n              // set.\n              bool MayAccess(DirectHandle<NativeContext> accessing_context,\n                             DirectHandle<JSObject> receiver);\n\n              void SetFailedAccessCheckCallback(v8::FailedAccessCheckCallback callback);\n              V8_WARN_UNUSED_RESULT MaybeDirectHandle<Object> ReportFailedAccessCheck(\n                  DirectHandle<JSObject> receiver);\n\n              // Exception throwing support. The caller should use the result of Throw() as\n              // its return value. Returns the Exception sentinel.\n              Tagged<Object> Throw(Tagged<Object> exception,\n                                   MessageLocation* location = nullptr);\n              Tagged<Object> ThrowAt(DirectHandle<JSObject> exception,\n                                     MessageLocation* location);\n              Tagged<Object> ThrowIllegalOperation();\n\n              void FatalProcessOutOfHeapMemory(const char* location) {\n                heap()->FatalProcessOutOfMemory(location);\n              }\n\n              void set_console_delegate(debug::ConsoleDelegate* delegate) {\n                console_delegate_ = delegate;\n              }\n              debug::ConsoleDelegate* console_delegate() { return console_delegate_; }\n\n              void set_async_event_delegate(debug::AsyncEventDelegate* delegate) {\n                async_event_delegate_ = delegate;\n                PromiseHookStateUpdated();\n              }\n\n              // Async function and promise instrumentation support.\n              void OnAsyncFunctionSuspended(DirectHandle<JSPromise> promise,\n                                            DirectHandle<JSPromise> parent);\n              void OnPromiseThen(DirectHandle<JSPromise> promise);\n              void OnPromiseBefore(DirectHandle<JSPromise> promise);\n              void OnPromiseAfter(DirectHandle<JSPromise> promise);\n              void OnStackTraceCaptured(DirectHandle<StackTraceInfo> stack_trace);\n              void OnTerminationDuringRunMicrotasks();\n\n              // Re-throw an exception.  This involves no error reporting since error\n              // reporting was handled when the exception was thrown originally.\n              // The first overload doesn't set the corresponding pending message, which\n              // has to be set separately or be guaranteed to not have changed.\n              Tagged<Object> ReThrow(Tagged<Object> exception);\n              Tagged<Object> ReThrow(Tagged<Object> exception, Tagged<Object> message);\n\n              // Find the correct handler for the current exception. This also\n              // clears and returns the current exception.\n              Tagged<Object> UnwindAndFindHandler();\n\n              // Tries to predict whether an exception will be caught. Note that this can\n              // only produce an estimate, because it is undecidable whether a finally\n              // clause will consume or re-throw an exception.\n              enum CatchType {\n                NOT_CAUGHT,\n                CAUGHT_BY_JAVASCRIPT,\n                CAUGHT_BY_EXTERNAL,\n                CAUGHT_BY_PROMISE,\n                CAUGHT_BY_ASYNC_AWAIT,\n              };\n              CatchType PredictExceptionCatcher();\n\n              void ReportPendingMessages(bool report = true);\n\n              // Attempts to compute the current source location, storing the\n              // result in the target out parameter. The source location is attached to a\n              // Message object as the location which should be shown to the user. It's\n              // typically the top-most meaningful location on the stack.\n              bool ComputeLocation(MessageLocation* target);\n              bool ComputeLocationFromException(MessageLocation* target,\n                                                DirectHandle<Object> exception);\n              bool ComputeLocationFromSimpleStackTrace(MessageLocation* target,\n                                                       DirectHandle<Object> exception);\n              bool ComputeLocationFromDetailedStackTrace(MessageLocation* target,\n                                                         DirectHandle<Object> exception);\n\n              Handle<JSMessageObject> CreateMessage(DirectHandle<Object> exception,\n                               "
}