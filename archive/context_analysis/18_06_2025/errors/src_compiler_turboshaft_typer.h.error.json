{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/typer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/typer.h\",\n            \"file_name\": \"typer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the Typer class and related utilities for Turboshaft, which performs type inference and propagation within the compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for various functionalities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <limits>\n\n            #include \"src/base/logging.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n            #include \"src/compiler/turboshaft/types.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"array_min\",\n                \"about\": \"Returns the minimum value in a std::array, ignoring NaN values. Converts -0 to 0.\",\n                \"logic\": \"Iterates through the array, comparing each non-NaN element with the current minimum.  Handles -0 to 0 conversion. Assumes at least one non-NaN element.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"const std::array<T, N>&\",\n                        \"purpose\": \"The array to find the minimum in\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"T\",\n                    \"description\": \"The minimum non-NaN value in the array.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, size_t N>\n            T array_min(const std::array<T, N>& a) {\n              DCHECK_NE(0, N);\n              T x = +std::numeric_limits<T>::infinity();\n              for (size_t i = 0; i < N; ++i) {\n                if (!std::isnan(a[i])) {\n                  x = std::min(a[i], x);\n                }\n              }\n              DCHECK(!std::isnan(x));\n              return x == T{0} ? T{0} : x;  // -0 -> 0\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"array_max\",\n                \"about\": \"Returns the maximum value in a std::array, ignoring NaN values. Converts -0 to 0.\",\n                \"logic\": \"Iterates through the array, comparing each non-NaN element with the current maximum. Handles -0 to 0 conversion. Assumes at least one non-NaN element.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"const std::array<T, N>&\",\n                        \"purpose\": \"The array to find the maximum in\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"T\",\n                    \"description\": \"The maximum non-NaN value in the array.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, size_t N>\n            T array_max(const std::array<T, N>& a) {\n              DCHECK_NE(0, N);\n              T x = -std::numeric_limits<T>::infinity();\n              for (size_t i = 0; i < N; ++i) {\n                if (!std::isnan(a[i])) {\n                  x = std::max(a[i], x);\n                }\n              }\n              DCHECK(!std::isnan(x));\n              return x == T{0} ? T{0} : x;  // -0 -> 0\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"WordOperationTyper\",\n                \"about\": \"Provides static methods for performing type inference on word operations (addition, subtraction) for both 32-bit and 64-bit words.  Uses ranges and sets to represent possible values.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"base::sort\",\n                    \"base::unique\",\n                    \"base::all_of\",\n                    \"uint_type\",\n                    \"WordType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <size_t Bits>\n            struct WordOperationTyper {\n              static_assert(Bits == 32 || Bits == 64);\n              using word_t = uint_type<Bits>;\n              using type_t = WordType<Bits>;\n              using ElementsVector = base::SmallVector<word_t, type_t::kMaxSetSize * 2>;\n              static constexpr word_t max = std::numeric_limits<word_t>::max();\n\n              static type_t FromElements(ElementsVector elements, Zone* zone) {\n                base::sort(elements);\n                auto it = std::unique(elements.begin(), elements.end());\n                elements.pop_back(std::distance(it, elements.end()));\n                DCHECK(!elements.empty());\n                if (elements.size() <= type_t::kMaxSetSize) {\n                  return type_t::Set(elements, zone);\n                }\n\n                auto range = MakeRange(base::VectorOf(elements));\n                auto result = type_t::Range(range.first, range.second, zone);\n                DCHECK(\n                    base::all_of(elements, [&](word_t e) { return result.Contains(e); }));\n                return result;\n              }\n\n              static std::pair<word_t, word_t> MakeRange(const type_t& t) {\n                if (t.is_range()) return t.range();\n                DCHECK(t.is_set());\n                return MakeRange(t.set_elements());\n              }\n\n              // This function tries to find a somewhat reasonable range for a given set of\n              // values. If the elements span no more than half of the range, we just\n              // construct the range from min(elements) to max(elements) Otherwise, we\n              // consider a wrapping range because it is likely that there is a larger gap\n              // in the middle of the elements. For that, we start with a wrapping range\n              // from max(elements) to min(elements) and then incrementally add another\n              // element either by increasing the 'to' or decreasing the 'from' of the\n              // range, whichever leads to a smaller range.\n              static std::pair<word_t, word_t> MakeRange(\n                  base::Vector<const word_t> elements) {\n                DCHECK(!elements.empty());\n                DCHECK(detail::is_unique_and_sorted(elements));\n                if (elements[elements.size() - 1] - elements[0] <= max / 2) {\n                  // Construct a non-wrapping range.\n                  return {elements[0], elements[elements.size() - 1]};\n                }\n                // Construct a wrapping range.\n                size_t from_index = elements.size() - 1;\n                size_t to_index = 0;\n                while (to_index + 1 < from_index) {\n                  if ((elements[to_index + 1] - elements[to_index]) <\n                      (elements[from_index] - elements[from_index - 1])) {\n                    ++to_index;\n                  } else {\n                    --from_index;\n                  }\n                }\n                return {elements[from_index], elements[to_index]};\n              }\n\n              static word_t distance(const std::pair<word_t, word_t>& range) {\n                return distance(range.first, range.second);\n              }\n              static word_t distance(word_t from, word_t to) {\n                return is_wrapping(from, to) ? (max - from + to) : to - from;\n              }\n\n              static bool is_wrapping(const std::pair<word_t, word_t>& range) {\n                return is_wrapping(range.first, range.second);\n              }\n              static bool is_wrapping(word_t from, word_t to) { return from > to; }\n\n              static type_t Add(const type_t& lhs, const type_t& rhs, Zone* zone) {\n                if (lhs.is_any() || rhs.is_any()) return type_t::Any();\n\n                // If both sides are decently small sets, we produce the product set (which\n                // we convert to a range if it exceeds the set limit).\n                if (lhs.is_set() && rhs.is_set()) {\n                  ElementsVector result_elements;\n                  for (int i = 0; i < lhs.set_size(); ++i) {\n                    for (int j = 0; j < rhs.set_size(); ++j) {\n                      result_elements.push_back(lhs.set_element(i) + rhs.set_element(j));\n                    }\n                  }\n                  return FromElements(std::move(result_elements), zone);\n                }\n\n                // Otherwise just construct a range.\n                std::pair<word_t, word_t> x = MakeRange(lhs);\n                std::pair<word_t, word_t> y = MakeRange(rhs);\n\n                // If the result would not be a complete range, we compute it.\n                // Check: (lhs.to - lhs.from + 1) + rhs.to - rhs.from < max\n                // =====> (lhs.to - lhs.from + 1) < max - rhs.to + rhs.from\n                // =====> (lhs.to - lhs.from + 1) < max - (rhs.to - rhs.from)\n                if (distance(x) + 1 < max - distance(y)) {\n                  return type_t::Range(x.first + y.first, x.second + y.second, zone);\n                }\n\n                return type_t::Any();\n              }\n\n              static type_t Subtract(const type_t& lhs, const type_t& rhs, Zone* zone) {\n                if (lhs.is_any() || rhs.is_any()) return type_t::Any();\n\n                // If both sides are decently small sets, we produce the product set (which\n                // we convert to a range if it exceeds the set limit).\n                if (lhs.is_set() && rhs.is_set()) {\n                  ElementsVector result_elements;\n                  for (int i = 0; i < lhs.set_size(); ++i) {\n                    for (int j = 0; j < rhs.set_size(); ++j) {\n                      result_elements.push_back(lhs.set_element(i) - rhs.set_element(j));\n                    }\n                  }\n                  return FromElements(std::move(result_elements), zone);\n                }\n\n                // Otherwise just construct a range.\n                std::pair<word_t, word_t> x = MakeRange(lhs);\n                std::pair<word_t, word_t> y = MakeRange(rhs);\n\n                if (!is_wrapping(x) && !is_wrapping(y)) {\n                  // If the result would not be a complete range, we compute it.\n                  // Check: (lhs.to - lhs.from + 1) + rhs.to - rhs.from < max\n                  // =====> (lhs.to - lhs.from + 1) < max - rhs.to + rhs.from\n                  // =====> (lhs.to - lhs.from + 1) < max - (rhs.to - rhs.from)\n                  if (distance(x) + 1 < max - distance(y)) {\n                    return type_t::Range(x.first - y.second, x.second - y.first, zone);\n                  }\n                }\n\n                // TODO(nicohartmann@): Improve the wrapping cases.\n                return type_t::Any();\n              }\n\n              static Word32Type UnsignedLessThan(const type_t& lhs, const type_t& rhs,\n                                                 Zone* zone) {\n                bool can_be_true = lhs.unsigned_min() < rhs.unsigned_max();\n                bool can_be_false = lhs.unsigned_max() >= rhs.unsigned_min();\n\n                if (!can_be_true) return Word32Type::Constant(0);\n                if (!can_be_false) return Word32Type::Constant(1);\n                return Word32Type::Set({0, 1}, zone);\n              }\n\n              static Word32Type UnsignedLessThanOrEqual(const type_t& lhs,\n                                                        const type_t& rhs, Zone* zone) {\n                bool can_be_true = lhs.unsigned_min() <= rhs.unsigned_max();\n                bool can_be_false = lhs.unsigned_max() > rhs.unsigned_min();\n\n                if (!can_be_true) return Word32Type::Constant(0);\n                if (!can_be_false) return Word32Type::Constant(1);\n                return Word32Type::Set({0, 1}, zone);\n              }\n\n              // Computes the ranges to which the sides of the unsigned comparison (lhs <\n              // rhs) can be restricted when the comparison is true. When the comparison is\n              // true, we learn: lhs cannot be >= rhs.max and rhs cannot be <= lhs.min.\n              static std::pair<Type, Type> RestrictionForUnsignedLessThan_True(\n                  const type_t& lhs, const type_t& rhs, Zone* zone) {\n                Type restrict_lhs;\n                if (rhs.unsigned_max() == 0) {\n                  // There is no value for lhs that could make (lhs < 0) true.\n                  restrict_lhs = Type::None();\n                } else {\n                  restrict_lhs = type_t::Range(0, next_smaller(rhs.unsigned_max()), zone);\n                }\n\n                Type restrict_rhs;\n                if (lhs.unsigned_min() == max) {\n                  // There is no value for rhs that could make (max < rhs) true.\n                  restrict_rhs = Type::None();\n                } else {\n                  restrict_rhs = type_t::Range(next_larger(lhs.unsigned_min()), max, zone);\n                }\n\n                return {restrict_lhs, restrict_rhs};\n              }\n\n              // Computes the ranges to which the sides of the unsigned comparison (lhs <\n              // rhs) can be restricted when the comparison is false. When the comparison is\n              // false, we learn: lhs cannot be < rhs.min and rhs cannot be > lhs.max.\n              static std::pair<Type, Type> RestrictionForUnsignedLessThan_False(\n                  const type_t& lhs, const type_t& rhs, Zone* zone) {\n                return {type_t::Range(rhs.unsigned_min(), max, zone),\n                        type_t::Range(0, lhs.unsigned_max(), zone)};\n              }\n\n              // Computes the ranges to which the sides of the unsigned comparison (lhs <=\n              // rhs) can be restricted when the comparison is true. When the comparison is\n              // true, we learn: lhs cannot be > rhs.max and rhs cannot be < lhs.min.\n              static std::pair<Type, Type> RestrictionForUnsignedLessThanOrEqual_True(\n                  const type_t& lhs, const type_t& rhs, Zone* zone) {\n                return {type_t::Range(0, rhs.unsigned_max(), zone),\n                        type_t::Range(lhs.unsigned_min(), max, zone)};\n              }\n\n              // Computes the ranges to which the sides of the unsigned comparison (lhs <=\n              // rhs) can be restricted when the comparison is false. When the comparison is\n              // false, we learn: lhs cannot be <= rhs.min and rhs cannot be >= lhs.max.\n              static std::pair<Type, Type> RestrictionForUnsignedLessThanOrEqual_False(\n                  const type_t& lhs, const type_t& rhs, Zone* zone) {\n                Type restrict_lhs;\n                if (rhs.unsigned_min() == max) {\n                  // There is no value for lhs that could make (lhs <= max) false.\n                  restrict_lhs = Type::None();\n                } else {\n                  restrict_lhs = type_t::Range(next_larger(rhs.unsigned_min()), max, zone);\n                }\n\n                Type restrict_rhs;\n                if (lhs.unsigned_max() == 0) {\n                  // There is no value for rhs that could make (0 <= rhs) false.\n                  restrict_rhs = Type::None();\n                } else {\n                  restrict_rhs = type_t::Range(0, next_smaller(lhs.unsigned_max()), zone);\n                }\n\n                return {restrict_lhs, restrict_rhs};\n              }\n\n              // WidenMaximal widens one of the boundary to the extreme immediately.\n              static type_t WidenMaximal(const type_t& old_type, const type_t& new_type,\n                                         Zone* zone) {\n                if (new_type.is_any()) return new_type;\n                if (old_type.is_wrapping() || new_type.is_wrapping()) return type_t::Any();\n\n                word_t result_from = new_type.unsigned_min();\n                if (result_from < old_type.unsigned_min()) result_from = 0;\n                word_t result_to = new_type.unsigned_max();\n                if (result_to > old_type.unsigned_max()) {\n                  result_to = std::numeric_limits<word_t>::max();\n                }\n                return type_t::Range(result_from, result_to, zone);\n              }\n\n              // Performs exponential widening, which means that the number of values\n              // described by the resulting type is at least doubled with respect to the\n              // {old_type}. If {new_type} is already twice the size of {old_type},\n              // {new_type} may be returned directly.\n              static type_t WidenExponential(const type_t& old_type, type_t new_type,\n                                              Zone* zone) {\n                if (new_type.is_any()) return new_type;\n                word_t old_from, old_to, new_from, new_to;\n                if (old_type.is_set()) {\n                  const word_t old_size = old_type.set_size();\n                  if (new_type.is_set()) {\n                    const word_t new_size = new_type.set_size();\n                    if (new_size >= 2 * old_size) return new_type;\n                    std::tie(new_from, new_to) = MakeRange(new_type);\n                  } else {\n                    DCHECK(new_type.is_range());\n                    std::tie(new_from, new_to) = new_type.range();\n                  }\n                  if (distance(new_from, new_to) >= 2 * old_size) {\n                    return type_t::Range(new_from, new_to, zone);\n                  }\n                  std::tie(old_from, old_to) = MakeRange(old_type);\n                } else {\n                  DCHECK(old_type.is_range());\n                  std::tie(old_from, old_to) = old_type.range();\n                  if (new_type.is_set()) {\n                    std::tie(new_from, new_to) = MakeRange(new_type);\n                  } else {\n                    DCHECK(new_type.is_range());\n                    std::tie(new_from, new_to) = new_type.range();\n                  }\n                }\n\n                // If the old type is already quite large, we go to full range.\n                if (distance(old_from, old_to) >= std::numeric_limits<word_t>::max() / 4) {\n                  return type_t::Any();\n                }\n\n                const word_t min_size = 2 * (distance(old_from, old_to) + 1);\n                if (distance(new_from, new_to) >= min_size) {\n                  return type_t::Range(new_from, new_to, zone);\n                }\n\n                // If old is wrapping (and so is new).\n                if (is_wrapping(old_from, old_to)) {\n                  DCHECK(is_wrapping(new_from, new_to));\n                  if (new_from < old_from) {\n                    DCHECK_LE(old_to, new_to);\n                    // We widen the `from` (although `to` might have grown, too).\n                    DCHECK_LT(new_to, min_size);\n                    word_t result_from =\n                        std::numeric_limits<word_t>::max() - (min_size - new_to);\n                    DCHECK_LT(result_from, new_from);\n                    DCHECK_LE(min_size, distance(result_from, new_to));\n                    return type_t::Range(result_from, new_to, zone);\n                  } else {\n                    DCHECK_EQ(old_from, new_from);\n                    // We widen the `to`.\n                    DCHECK_LT(std::numeric_limits<word_t>::max() - new_from, min_size);\n                    word_t result_to =\n                        min_size - (std::numeric_limits<word_t>::max() - new_from);\n                    DCHECK_GT(result_to, new_to);\n                    DCHECK_LE(min_size, distance(new_from, result_to));\n                    return type_t::Range(new_from, result_to, zone);\n                  }\n                }\n\n                // If old is not wrapping, but new is.\n                if (is_wrapping(new_from, new_to)) {\n                  if (new_to < old_to) {\n                    // If wrapping was caused by to growing over max, grow `to` further\n                    // (although `from` might have grown, too).\n                    DCHECK_LT(std::numeric_limits<word_t>::max() - new_from, min_size);\n                    word_t result_to =\n                        min_size - (std::numeric_limits<word_t>::max() - new_from);\n                    DCHECK_LT(new_to, result_to);\n                    return type_t::Range(new_from, result_to, zone);\n                  } else {\n                    DCHECK_LT(old_from, new_from);\n                    // If wrapping was caused by `from` growing below 0, grow `from`\n                    // further.\n                    DCHECK_LT(new_to, min_size);\n                    word_t result_from =\n                        std::numeric_limits<word_t>::max() - (min_size - new_to);\n                    DCHECK_LT(result_from, new_from);\n                    return type_t::Range(result_from, new_to, zone);\n                  }\n                }\n\n                // Neither old nor new is wrapping.\n                if (new_from < old_from) {\n                  DCHECK_LE(old_to, new_to);\n                  // Check if we can widen the `from`.\n                  if (new_to >= min_size) {\n                    // We can decrease `from` without going below 0.\n                    word_t result_from = new_to - min_size;\n                    DCHECK_LT(result_from, new_from);\n                    return type_t::Range(result_from, new_to, zone);\n                  } else {\n                    // We cannot grow `from` enough, so we also have to grow `to`.\n                    return type_t::Range(0, min_size, zone);\n                  }\n                } else {\n                  DCHECK_EQ(old_from, new_from);\n                  // Check if we can widen the `to`.\n                  if (new_from <= std::numeric_limits<word_t>::max() - min_size) {\n                    // We can increase `to` without going above max.\n                    word_t result_to = new_from + min_size;\n                    DCHECK_GT(result_to, new_to);\n                    return type_t::Range(new_from, result_to, zone);\n                  } else {\n                    // We cannot grow `to` enough, so we also have to grow `from`.\n                    return type_t::Range(std::numeric_limits<word_t>::max() - min_size,\n                                         std::numeric_limits<word_t>::max(), zone);\n                  }\n                }\n              }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"FloatOperationTyper\",\n                \"about\": \"Provides static methods for performing type inference on floating-point operations (addition, subtraction, multiplication, division, etc.) for both 32-bit and 64-bit floats. Considers special values like NaN and -0.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"base::sort\",\n                    \"base::unique\",\n                    \"base::erase_if\",\n                    \"std::conditional_t\",\n                    \"std::isnan\",\n                    \"std::modf\",\n                    \"array_min\",\n                    \"array_max\",\n                    \"IsMinusZero\",\n                    \"FloatType\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <size_t Bits>\n            struct FloatOperationTyper {\n              static_assert(Bits == 32 || Bits == 64);\n              using float_t = std::conditional_t<Bits == 32, float, double>;\n              using type_t = FloatType<Bits>;\n              static constexpr float_t inf = std::numeric_limits<float_t>::infinity();\n              static constexpr int kSetThreshold = type_t::kMaxSetSize;\n\n              static type_t Range(float_t min, float_t max, uint32_t special_values,\n                                  Zone* zone) {\n                DCHECK_LE(min, max);\n                DCHECK_IMPLIES(detail::is_minus_zero(min),\n                               (special_values & type_t::kMinusZero));\n                DCHECK_IMPLIES(detail::is_minus_zero(max),\n                               (special_values & type_t::kMinusZero));\n                if (min == max) return Set({min + float_t{0}}, special_values, zone);\n                return type_t::Range(min, max, special_values, zone);\n              }\n\n              static type_t Set(std::vector<float_t> elements, uint32_t special_values,\n                                Zone* zone) {\n                base::sort(elements);\n                elements.erase(std::unique(elements.begin(), elements.end()),\n                               elements.end());\n                if (base::erase_if(elements, [](float_t v) { return std::isnan(v); }) > 0) {\n                  special_values |= type_t::kNaN;\n                }\n                if (base::erase_if(elements, [](float_t v) { return IsMinusZero(v); }) >\n                    0) {\n                  special_values |= type_t::kMinusZero;\n                }\n                if (elements.empty()) {\n                  DCHECK_NE(0, special_values);\n                  return type_t::OnlySpecialValues(special_values);\n                }\n                return type_t::Set(elements, special_values, zone);\n              }\n\n              // Check if the elements in the set are all integers. This ignores special\n              // values (NaN, -0)!\n              static bool IsIntegerSet(const type_t& t) {\n                if (!t.is_set()) return false;\n                int size = t.set_size();\n                DCHECK_LT(0, size);\n\n                float_t unused_ipart;\n                float_t min = t.set_element(0);\n                if (std::modf(min, &unused_ipart) != 0.0) return false;\n                if (min == -inf) return false;\n                float_t max = t.set_element(size - 1);\n                if (std::modf(max, &unused_ipart) != 0.0) return false;\n                if (max == inf) return false;\n\n                for (int i = 1; i < size - 1; ++i) {\n                  if (std::modf(t.set_element(i), &unused_ipart) != 0.0) return false;\n                }\n                return true;\n              }\n\n              static bool IsZeroish(const type_t& l) {\n                return l.has_nan() || l.has_minus_zero() || l.Contains(0);\n              }\n\n              // Tries to construct the product of two sets where values are generated using\n              // {combine}. Returns Type::Invalid() if a set cannot be constructed (e.g.\n              // because the result exceeds the maximal number of set elements).\n              static Type ProductSet(const type_t& l, const type_t& r,\n                                     uint32_t special_values, Zone* zone,\n                                     std::function<float_t(float_t, float_t)> combine) {\n                DCHECK(l.is_set());\n                DCHECK(r.is_set());\n\n                std::vector<float_t> results;\n                auto CombineWithLeft = [&](float_t left) {\n                  for (int j = 0; j < r.set_size(); ++j) {\n                    results.push_back(combine(left, r.set_element(j)));\n                  }\n                  if (r.has_minus_zero()) results.push_back(combine(left, -0.0));\n                  if (r.has_nan()) results.push_back(combine(left, nan_v<Bits>));\n                };\n\n                for (int i = 0; i < l.set_size(); ++i) {\n                  CombineWithLeft(l.set_element(i));\n                }\n                if (l.has_minus_zero()) CombineWithLeft(-0.0);\n                if (l.has_nan()) CombineWithLeft(nan_v<Bits>);\n\n                if (base::erase_if(results, [](float_t v) { return std::isnan(v); }) > 0) {\n                  special_values |= type_t::kNaN;\n                }\n                if (base::erase_if(results, [](float_t v) { return IsMinusZero(v); }) > 0) {\n                  special_values |= type_t::kMinusZero;\n                }\n                base::sort(results);\n                auto it = std::unique(results.begin(), results.end());\n                if (std::distance(results.begin(), it) > kSetThreshold)\n                  return Type::Invalid();\n                results.erase(it, results.end());\n                if (results.empty()) return type_t::OnlySpecialValues(special_values);\n                return Set(std::move(results), special_values, zone);\n              }\n\n              static Type Add(type_t l, type_t r, Zone* zone) {\n                // Addition can return NaN if either input can be NaN or we try to compute\n                // the sum of two infinities of opposite sign.\n                if (l.is_only_nan() || r.is_only_nan()) return type_t::NaN();\n                bool maybe_nan = l.has_nan() || r.has_nan();\n\n                // Addition can yield minus zero only if both inputs can be minus zero.\n                bool maybe_minuszero = true;\n                if (l.has_minus_zero()) {\n                  l = type_t::LeastUpperBound(l, type_t::Constant(0), zone);\n                } else {\n                  maybe_minuszero = false;\n                }\n                if (r.has_minus_zero()) {\n                  r = type_t::LeastUpperBound(r, type_t::Constant(0), zone);\n                } else {\n                  maybe_minuszero = false;\n                }\n\n                uint32_t special_values = (maybe_nan ? type_t::kNaN : 0) |\n                                          (maybe_minuszero ? type_t::kMinusZero : 0);\n                // If both sides are decently small sets, we produce the product set.\n                auto combine = [](float_t a, float_t b) { return a + b; };\n                if (l.is_set() && r.is_set()) {\n                  auto result = ProductSet(l, r, special_values, zone, combine);\n                  if (!result.IsInvalid()) return result;\n                }\n\n                // Otherwise just construct a range.\n                auto [l_min, l_max] = l.minmax();\n                auto [r_min, r_max] = r.minmax();\n\n                std::array<float_t, 4> results;\n                results[0] = l_min + r_min;\n                results[1] = l_min + r_max;\n                results[2] = l_max + r_min;\n                results[3] = l_max + r_max;\n\n                int nans = 0;\n                for (int i = 0; i < 4; ++i) {\n                  if (std::isnan(results[i])) ++nans;\n                }\n                if (nans > 0) {\n                  special_values |= type_t::kNaN;\n                  if (nans >= 4) {\n                    // All combinations of inputs produce NaN.\n                    return type_t::OnlySpecialValues(special_values);\n                  }\n                }\n                const float_t result_min = array_min(results);\n                const float_t result_max = array_max(results);\n                return Range(result_min, result_max, special_values, zone);\n              }\n\n              static Type Subtract(type_t l, type_t r, Zone* zone) {\n                // Subtraction can return NaN if either input can be NaN or we try to\n                // compute the sum of two infinities of opposite sign.\n                if (l.is_only_nan() || r"
}