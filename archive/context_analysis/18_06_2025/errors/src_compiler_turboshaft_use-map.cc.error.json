{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/use-map.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 45, column 50",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/use-map.cc\",\n        \"file_name\": \"use-map.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the UseMap class for tracking uses of operations within a Turboshaft graph.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for UseMap implementation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/use-map.h\"\n\n#include \"src/compiler/turboshaft/graph.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"UseMap\",\n            \"about\": \"A data structure that maps each operation in a graph to its uses (i.e., the operations that consume its result).\",\n            \"attributes\": [\n                {\n                    \"name\": \"table_\",\n                    \"type\": \"ZoneVector<TableEntry>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A table mapping OpIndex to an offset and count, used to locate uses in the uses_ or saturated_uses_ vectors.\"\n                },\n                {\n                    \"name\": \"uses_\",\n                    \"type\": \"ZoneVector<OpIndex>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector storing OpIndex values representing the use of an operation when the use count is low enough to fit in a uint8_t.\"\n                },\n                {\n                    \"name\": \"saturated_uses_\",\n                    \"type\": \"ZoneVector<ZoneVector<OpIndex>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector of vectors, storing OpIndex values when an operation has too many uses to store compactly (use count > uint8_t).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Graph\",\n                \"Zone\",\n                \"Operation\",\n                \"OpIndex\",\n                \"Block\",\n                \"BlockIndex\",\n                \"PhiOp\",\n                \"FunctionType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::compiler::turboshaft {\n\nclass UseMap {\n public:\n  UseMap(const Graph& graph, Zone* zone, FunctionType filter);\n\n  base::Vector<const OpIndex> uses(OpIndex index) const;\n\n private:\n  void AddUse(const Graph* graph, OpIndex node, OpIndex use);\n\n  struct TableEntry {\n    int32_t offset = 0;\n    uint32_t count = 0;\n  };\n\n  ZoneVector<TableEntry> table_;\n  ZoneVector<OpIndex> uses_;\n  ZoneVector<ZoneVector<OpIndex>> saturated_uses_;\n};\n\n}  // namespace v8::internal::compiler::turboshaft\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UseMap\",\n            \"parent\": \"UseMap\",\n            \"about\": \"Constructor for the UseMap class.\",\n            \"logic\": \"Iterates through each block and operation in the graph to build the use map.  It allocates space in `uses_` or `saturated_uses_` based on the operation's `saturated_use_count`. It skips adding uses for operations if the provided `filter` function returns true. Loop phi uses are delayed to handle loop backedges correctly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"const Graph&\",\n                    \"purpose\": \"The Turboshaft graph to analyze.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone to allocate data structures in.\"\n                },\n                {\n                    \"name\": \"filter\",\n                    \"type\": \"FunctionType\",\n                    \"purpose\": \"A filter function to exclude certain operations from use tracking.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value (constructor).\"\n            },\n            \"dependencies\": [\n                \"Graph\",\n                \"Zone\",\n                \"Operation\",\n                \"OpIndex\",\n                \"Block\",\n                \"BlockIndex\",\n                \"PhiOp\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nUseMap::UseMap(const Graph& graph, Zone* zone, FunctionType filter)\n    : table_(graph.op_id_count(), zone, &graph),\n      uses_(zone),\n      saturated_uses_(zone) {\n  ZoneVector<std::pair<OpIndex, OpIndex>> delayed_phi_uses(zone);\n\n  // We preallocate for 2 uses per operation.\n  uses_.reserve(graph.op_id_count() * 2);\n\n  // We skip {offset:0} to use {offset == 0} as uninitialized.\n  uint32_t offset = 1;\n  for (uint32_t index = 0; index < graph.block_count(); ++index) {\n    BlockIndex block_index(index);\n    const Block& block = graph.Get(block_index);\n\n    auto block_ops = graph.OperationIndices(block);\n    for (OpIndex op_index : block_ops) {\n      const Operation& op = graph.Get(op_index);\n      // When we see a definition, we allocate space in the {uses_}.\n      DCHECK_EQ(table_[op_index].offset, 0);\n      DCHECK_EQ(table_[op_index].count, 0);\n\n      if (op.saturated_use_count.IsSaturated()) {\n        table_[op_index].offset =\n            -static_cast<int32_t>(saturated_uses_.size()) - 1;\n        saturated_uses_.emplace_back(zone);\n        saturated_uses_.back().reserve(std::numeric_limits<uint8_t>::max());\n      } else {\n        table_[op_index].offset = offset;\n        offset += op.saturated_use_count.Get();\n        uses_.resize(offset);\n      }\n\n      if (filter(op, zone)) continue;\n\n      if (block.IsLoop()) {\n        if (op.Is<PhiOp>()) {\n          DCHECK_EQ(op.input_count, 2);\n          DCHECK_EQ(PhiOp::kLoopPhiBackEdgeIndex, 1);\n          AddUse(&graph, op.input(0), op_index);\n          // Delay back edge of loop Phis.\n          delayed_phi_uses.emplace_back(op.input(1), op_index);\n          continue;\n        }\n      }\n\n      // Add uses.\n      for (OpIndex input_index : op.inputs()) {\n        AddUse(&graph, input_index, op_index);\n      }\n    }\n  }\n\n  for (auto [input_index, op_index] : delayed_phi_uses) {\n    AddUse(&graph, input_index, op_index);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"uses\",\n            \"parent\": \"UseMap\",\n            \"about\": \"Retrieves the uses of a given operation.\",\n            \"logic\": \"Looks up the offset and count in the `table_` for the given `OpIndex`. Based on the offset being positive or negative, it retrieves the uses either from the `uses_` vector or the `saturated_uses_` vector.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the operation whose uses are to be retrieved.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"base::Vector<const OpIndex>\",\n                \"description\": \"A vector containing the indices of the operations that use the specified operation.\"\n            },\n            \"dependencies\": [\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbase::Vector<const OpIndex> UseMap::uses(OpIndex index) const {\n  DCHECK(index.valid());\n  int32_t offset = table_[index].offset;\n  uint32_t count = table_[index].count;\n  DCHECK_NE(offset, 0);\n  if (V8_LIKELY(offset > 0)) {\n    return base::Vector<const OpIndex>(uses_.data() + offset, count);\n  } else {\n    DCHECK_EQ(count, saturated_uses_[-offset - 1].size());\n    return base::Vector<const OpIndex>(saturated_uses_[-offset - 1].data(),\n                                       count);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddUse\",\n            \"parent\": \"UseMap\",\n            \"about\": \"Adds a use to the use map.\",\n            \"logic\": \"Looks up the offset and count in the `table_` for the given node.  If the offset is positive (use count not saturated), it adds the `use` to the `uses_` vector at the appropriate offset. If the offset is negative (use count saturated), it adds the `use` to the `saturated_uses_` vector.  It increments the use count in both cases.\",\n            \"parameters\": [\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"const Graph*\",\n                    \"purpose\": \"The Turboshaft graph.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the node (operation) that is being used.\"\n                },\n                {\n                    \"name\": \"use\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The index of the operation that is using the node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Graph\",\n                \"OpIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid UseMap::AddUse(const Graph* graph, OpIndex node, OpIndex use) {\n  int32_t input_offset = table_[node].offset;\n  uint32_t& input_count = table_[node].count;\n  DCHECK_NE(input_offset, 0);\n  if (V8_LIKELY(input_offset > 0)) {\n    DCHECK_LT(input_count, graph->Get(node).saturated_use_count.Get());\n    DCHECK(!uses_[input_offset + input_count].valid());\n    uses_[input_offset + input_count] = use;\n  } else {\n    ZoneVector<OpIndex>& uses = saturated_uses_[-input_offset - 1];\n    DCHECK_EQ(uses.size(), input_count);\n    uses.emplace_back(use);\n  }\n  ++input_count;\n}\n        ]]></code>\n    </func>\n</file>\n```"
}