{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-exception.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 165, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-exception.h\",\n            \"file_name\": \"v8-exception.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the V8 exception handling API, including classes for creating and handling exceptions, capturing stack traces, and using try-catch blocks.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for basic types, handles, objects, and configurations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <stddef.h>\n\n#include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n#include \"v8-object.h\"        // NOLINT(build/include_directory)\n#include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Exception\",\n                \"about\": \"Provides static methods for creating standard JavaScript error objects (RangeError, ReferenceError, etc.) and related functionalities like creating exception messages and capturing stack traces.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"String\",\n                    \"Value\",\n                    \"Message\",\n                    \"StackTrace\",\n                    \"Isolate\",\n                    \"Context\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT Exception {\n public:\n  static Local<Value> RangeError(Local<String> message,\n                                 Local<Value> options = {});\n  static Local<Value> ReferenceError(Local<String> message,\n                                     Local<Value> options = {});\n  static Local<Value> SyntaxError(Local<String> message,\n                                  Local<Value> options = {});\n  static Local<Value> TypeError(Local<String> message,\n                                Local<Value> options = {});\n  static Local<Value> WasmCompileError(Local<String> message,\n                                       Local<Value> options = {});\n  static Local<Value> WasmLinkError(Local<String> message,\n                                    Local<Value> options = {});\n  static Local<Value> WasmRuntimeError(Local<String> message,\n                                       Local<Value> options = {});\n  static Local<Value> WasmSuspendError(Local<String> message,\n                                       Local<Value> options = {});\n  static Local<Value> Error(Local<String> message, Local<Value> options = {});\n\n  /**\n   * Creates an error message for the given exception.\n   * Will try to reconstruct the original stack trace from the exception value,\n   * or capture the current stack trace if not available.\n   */\n  static Local<Message> CreateMessage(Isolate* isolate, Local<Value> exception);\n\n  /**\n   * Returns the original stack trace that was captured at the creation time\n   * of a given exception, or an empty handle if not available.\n   */\n  static Local<StackTrace> GetStackTrace(Local<Value> exception);\n\n  /**\n   * Captures the current stack trace and attaches it to the given object in the\n   * form of `stack` property.\n   */\n  static Maybe<bool> CaptureStackTrace(Local<Context> context,\n                                       Local<Object> object);\n};\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"ExceptionContext\",\n                \"about\": \"Defines the context in which an exception occurred, used in the experimental ExceptionPropagationMessage API.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class ExceptionContext : uint32_t {\n  kUnknown,\n  kConstructor,\n  kOperation,\n  kAttributeGet,\n  kAttributeSet,\n  kIndexedQuery,\n  kIndexedGetter,\n  kIndexedDescriptor,\n  kIndexedSetter,\n  kIndexedDefiner,\n  kIndexedDeleter,\n  kNamedQuery,\n  kNamedGetter,\n  kNamedDescriptor,\n  kNamedSetter,\n  kNamedDefiner,\n  kNamedDeleter,\n  kNamedEnumerator\n};\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ExceptionPropagationMessage\",\n                \"about\": \"Represents a message related to exception propagation, part of an experimental API.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The isolate associated with the exception.\"\n                    },\n                    {\n                        \"name\": \"exception_\",\n                        \"type\": \"Local<Object>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The exception object.\"\n                    },\n                    {\n                        \"name\": \"interface_name_\",\n                        \"type\": \"Local<String>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The name of the interface where the exception occurred.\"\n                    },\n                    {\n                        \"name\": \"property_name_\",\n                        \"type\": \"Local<String>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The name of the property where the exception occurred.\"\n                    },\n                    {\n                        \"name\": \"exception_context_\",\n                        \"type\": \"ExceptionContext\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The context in which the exception occurred.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Object\",\n                    \"String\",\n                    \"ExceptionContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass ExceptionPropagationMessage {\n public:\n  ExceptionPropagationMessage(v8::Isolate* isolate, Local<Object> exception,\n                              Local<String> interface_name,\n                              Local<String> property_name,\n                              ExceptionContext exception_context)\n      : isolate_(isolate),\n        exception_(exception),\n        interface_name_(interface_name),\n        property_name_(property_name),\n        exception_context_(exception_context) {}\n\n  V8_INLINE Isolate* GetIsolate() const { return isolate_; }\n  V8_INLINE Local<Object> GetException() const { return exception_; }\n  V8_INLINE Local<String> GetInterfaceName() const { return interface_name_; }\n  V8_INLINE Local<String> GetPropertyName() const { return property_name_; }\n  V8_INLINE ExceptionContext GetExceptionContext() const {\n    return exception_context_;\n  }\n\n private:\n  Isolate* isolate_;\n  Local<Object> exception_;\n  Local<String> interface_name_;\n  Local<String> property_name_;\n  ExceptionContext exception_context_;\n};\n        ]]></code>\n    </class>\n    <typedef>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"ExceptionPropagationCallback\",\n                \"about\": \"Defines a callback function type for handling exception propagation messages.\",\n                \"dependencies\": [\n                    \"ExceptionPropagationMessage\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nusing ExceptionPropagationCallback =\n    void (*)(ExceptionPropagationMessage message);\n        ]]></code>\n    </typedef>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TryCatch\",\n                \"about\": \"Provides a mechanism for catching exceptions thrown during JavaScript execution within C++ code.  It allows checking for exceptions, retrieving the exception and its message, and re-throwing the exception.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"i_isolate_\",\n                        \"type\": \"internal::Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the internal isolate.\"\n                    },\n                    {\n                        \"name\": \"next_\",\n                        \"type\": \"TryCatch*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the next TryCatch block.\"\n                    },\n                    {\n                        \"name\": \"exception_\",\n                        \"type\": \"void*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the caught exception.\"\n                    },\n                    {\n                        \"name\": \"message_obj_\",\n                        \"type\": \"void*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the message object associated with the exception.\"\n                    },\n                    {\n                        \"name\": \"js_stack_comparable_address_\",\n                        \"type\": \"internal::Address\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Address comparable with JS stack addresses.\"\n                    },\n                    {\n                        \"name\": \"is_verbose_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether verbosity is enabled.\"\n                    },\n                    {\n                        \"name\": \"can_continue_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether execution can continue after the exception.\"\n                    },\n                    {\n                        \"name\": \"capture_message_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether to capture a message object.\"\n                    },\n                    {\n                        \"name\": \"rethrow_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating if the exception should be rethrown\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Value\",\n                    \"Message\",\n                    \"Context\",\n                    \"internal::Isolate\",\n                    \"internal::ThreadLocalTop\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT TryCatch {\n public:\n  /**\n   * Creates a new try/catch block and registers it with v8.  Note that\n   * all TryCatch blocks should be stack allocated because the memory\n   * location itself is compared against JavaScript try/catch blocks.\n   */\n  explicit TryCatch(Isolate* isolate);\n\n  /**\n   * Unregisters and deletes this try/catch block.\n   */\n  ~TryCatch();\n\n  /**\n   * Returns true if an exception has been caught by this try/catch block.\n   */\n  bool HasCaught() const;\n\n  /**\n   * For certain types of exceptions, it makes no sense to continue execution.\n   *\n   * If CanContinue returns false, the correct action is to perform any C++\n   * cleanup needed and then return.  If CanContinue returns false and\n   * HasTerminated returns true, it is possible to call\n   * CancelTerminateExecution in order to continue calling into the engine.\n   */\n  bool CanContinue() const;\n\n  /**\n   * Returns true if an exception has been caught due to script execution\n   * being terminated.\n   *\n   * There is no JavaScript representation of an execution termination\n   * exception.  Such exceptions are thrown when the TerminateExecution\n   * methods are called to terminate a long-running script.\n   *\n   * If such an exception has been thrown, HasTerminated will return true,\n   * indicating that it is possible to call CancelTerminateExecution in order\n   * to continue calling into the engine.\n   */\n  bool HasTerminated() const;\n\n  /**\n   * Throws the exception caught by this TryCatch in a way that avoids\n   * it being caught again by this same TryCatch.  As with ThrowException\n   * it is illegal to execute any JavaScript operations after calling\n   * ReThrow; the caller must return immediately to where the exception\n   * is caught.\n   */\n  Local<Value> ReThrow();\n\n  /**\n   * Returns the exception caught by this try/catch block.  If no exception has\n   * been caught an empty handle is returned.\n   */\n  Local<Value> Exception() const;\n\n  /**\n   * Returns the .stack property of an object.  If no .stack\n   * property is present an empty handle is returned.\n   */\n  V8_WARN_UNUSED_RESULT static MaybeLocal<Value> StackTrace(\n      Local<Context> context, Local<Value> exception);\n\n  /**\n   * Returns the .stack property of the thrown object.  If no .stack property is\n   * present or if this try/catch block has not caught an exception, an empty\n   * handle is returned.\n   */\n  V8_WARN_UNUSED_RESULT MaybeLocal<Value> StackTrace(\n      Local<Context> context) const;\n\n  /**\n   * Returns the message associated with this exception.  If there is\n   * no message associated an empty handle is returned.\n   */\n  Local<v8::Message> Message() const;\n\n  /**\n   * Clears any exceptions that may have been caught by this try/catch block.\n   * After this method has been called, HasCaught() will return false. Cancels\n   * the scheduled exception if it is caught and ReThrow() is not called before.\n   *\n   * It is not necessary to clear a try/catch block before using it again; if\n   * another exception is thrown the previously caught exception will just be\n   * overwritten.  However, it is often a good idea since it makes it easier\n   * to determine which operation threw a given exception.\n   */\n  void Reset();\n\n  /**\n   * Set verbosity of the external exception handler.\n   *\n   * By default, exceptions that are caught by an external exception\n   * handler are not reported.  Call SetVerbose with true on an\n   * external exception handler to have exceptions caught by the\n   * handler reported as if they were not caught.\n   */\n  void SetVerbose(bool value);\n\n  /**\n   * Returns true if verbosity is enabled.\n   */\n  bool IsVerbose() const;\n\n  /**\n   * Set whether or not this TryCatch should capture a Message object\n   * which holds source information about where the exception\n   * occurred.  True by default.\n   */\n  void SetCaptureMessage(bool value);\n\n  TryCatch(const TryCatch&) = delete;\n  void operator=(const TryCatch&) = delete;\n\n private:\n  // Declaring operator new and delete as deleted is not spec compliant.\n  // Therefore declare them private instead to disable dynamic alloc\n  void* operator new(size_t size);\n  void* operator new[](size_t size);\n  void* operator delete(void*, size_t);\n  void* operator delete[](void*, size_t);\n\n  /**\n   * There are cases when the raw address of C++ TryCatch object cannot be\n   * used for comparisons with addresses into the JS stack. The cases are:\n   * 1) ARM, ARM64 and MIPS simulators which have separate JS stack.\n   * 2) Address sanitizer allocates local C++ object in the heap when\n   *    UseAfterReturn mode is enabled.\n   * This method returns address that can be used for comparisons with\n   * addresses into the JS stack. When neither simulator nor ASAN's\n   * UseAfterReturn is enabled, then the address returned will be the address\n   * of the C++ try catch handler itself.\n   */\n  internal::Address JSStackComparableAddressPrivate() {\n    return js_stack_comparable_address_;\n  }\n\n  void ResetInternal();\n\n  internal::Isolate* i_isolate_;\n  TryCatch* next_;\n  void* exception_;\n  void* message_obj_;\n  internal::Address js_stack_comparable_address_;\n  bool is_verbose_ : 1;\n  bool can_continue_ : 1;\n  bool capture_message_ : 1;\n  bool rethrow_ : 1;\n\n  friend class internal::Isolate;\n  friend class internal::ThreadLocalTop;\n};\n        ]]></code>\n    </class>\n</file>\n```"
}