{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/cfg.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 61, column 48",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/cfg.h\",\n        \"file_name\": \"cfg.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Control Flow Graph (CFG) data structures and associated assembler for the Torque language.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers for data structures, memory management, and optional values.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <list>\n            #include <memory>\n            #include <optional>\n            #include <unordered_map>\n            #include <vector>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes Torque-specific headers for AST nodes, instructions, source positions, and type system.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/torque/ast.h\"\n            #include \"src/torque/instructions.h\"\n            #include \"src/torque/source-positions.h\"\n            #include \"src/torque/types.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Block\",\n            \"about\": \"Represents a basic block in the control flow graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"cfg_\",\n                    \"type\": \"ControlFlowGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the parent control flow graph.\"\n                },\n                {\n                    \"name\": \"instructions_\",\n                    \"type\": \"std::vector<Instruction>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of instructions in the block.\"\n                },\n                {\n                    \"name\": \"input_types_\",\n                    \"type\": \"std::optional<Stack<const Type*>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Optional stack of input types for the block.\"\n                },\n                {\n                    \"name\": \"input_definitions_\",\n                    \"type\": \"std::optional<Stack<DefinitionLocation>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Optional stack of definition locations for the block's inputs.\"\n                },\n                {\n                    \"name\": \"id_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Unique identifier for the block.\"\n                },\n                {\n                    \"name\": \"is_deferred_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the block is deferred (e.g., for exception handling).\"\n                }\n            ],\n            \"dependencies\": [\n                \"ControlFlowGraph\",\n                \"Instruction\",\n                \"Type\",\n                \"Stack\",\n                \"DefinitionLocation\",\n                \"BottomOffset\",\n                \"Worklist\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Block {\n            public:\n              explicit Block(ControlFlowGraph* cfg, size_t id,\n                             std::optional<Stack<const Type*>> input_types,\n                             bool is_deferred)\n                  : cfg_(cfg),\n                    input_types_(std::move(input_types)),\n                    id_(id),\n                    is_deferred_(is_deferred) {}\n              void Add(Instruction instruction) {\n                DCHECK(!IsComplete());\n                instructions_.push_back(std::move(instruction));\n              }\n\n              bool HasInputTypes() const { return input_types_ != std::nullopt; }\n              const Stack<const Type*>& InputTypes() const { return *input_types_; }\n              void SetInputTypes(const Stack<const Type*>& input_types);\n              void Retype() {\n                Stack<const Type*> current_stack = InputTypes();\n                for (const Instruction& instruction : instructions()) {\n                  instruction.TypeInstruction(&current_stack, cfg_);\n                }\n              }\n\n              std::vector<Instruction>& instructions() { return instructions_; }\n              const std::vector<Instruction>& instructions() const { return instructions_; }\n              bool IsComplete() const {\n                return !instructions_.empty() && instructions_.back()->IsBlockTerminator();\n              }\n              size_t id() const { return id_; }\n              bool IsDeferred() const { return is_deferred_; }\n\n              void MergeInputDefinitions(const Stack<DefinitionLocation>& input_definitions,\n                                         Worklist<Block*>* worklist) {\n                if (!input_definitions_) {\n                  input_definitions_ = input_definitions;\n                  if (worklist) worklist->Enqueue(this);\n                  return;\n                }\n\n                DCHECK_EQ(input_definitions_->Size(), input_definitions.Size());\n                bool changed = false;\n                for (BottomOffset i = {0}; i < input_definitions.AboveTop(); ++i) {\n                  auto& current = input_definitions_->Peek(i);\n                  auto& input = input_definitions.Peek(i);\n                  if (current == input) continue;\n                  if (current == DefinitionLocation::Phi(this, i.offset)) continue;\n                  input_definitions_->Poke(i, DefinitionLocation::Phi(this, i.offset));\n                  changed = true;\n                }\n\n                if (changed && worklist) worklist->Enqueue(this);\n              }\n              bool HasInputDefinitions() const {\n                return input_definitions_ != std::nullopt;\n              }\n              const Stack<DefinitionLocation>& InputDefinitions() const {\n                DCHECK(HasInputDefinitions());\n                return *input_definitions_;\n              }\n\n              bool IsDead() const { return !HasInputDefinitions(); }\n\n             private:\n              ControlFlowGraph* cfg_;\n              std::vector<Instruction> instructions_;\n              std::optional<Stack<const Type*>> input_types_;\n              std::optional<Stack<DefinitionLocation>> input_definitions_;\n              const size_t id_;\n              bool is_deferred_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ControlFlowGraph\",\n            \"about\": \"Represents the control flow graph of a Torque function.\",\n            \"attributes\": [\n                {\n                    \"name\": \"blocks_\",\n                    \"type\": \"std::list<Block>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"List of basic blocks in the graph.\"\n                },\n                {\n                    \"name\": \"start_\",\n                    \"type\": \"Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the starting block of the graph.\"\n                },\n                {\n                    \"name\": \"placed_blocks_\",\n                    \"type\": \"std::vector<Block*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of blocks that have been placed in the graph.\"\n                },\n                {\n                    \"name\": \"end_\",\n                    \"type\": \"std::optional<Block*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Optional pointer to the ending block of the graph.\"\n                },\n                {\n                    \"name\": \"return_type_\",\n                    \"type\": \"std::optional<TypeVector>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Optional return type of the function represented by the graph.\"\n                },\n                {\n                    \"name\": \"next_block_id_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Counter for assigning unique IDs to blocks.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Block\",\n                \"Type\",\n                \"Stack\",\n                \"TypeVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ControlFlowGraph {\n            public:\n              explicit ControlFlowGraph(Stack<const Type*> input_types) {\n                start_ = NewBlock(std::move(input_types), false);\n                PlaceBlock(start_);\n              }\n\n              Block* NewBlock(std::optional<Stack<const Type*>> input_types,\n                              bool is_deferred) {\n                blocks_.emplace_back(this, next_block_id_++, std::move(input_types),\n                                     is_deferred);\n                return &blocks_.back();\n              }\n              void PlaceBlock(Block* block) { placed_blocks_.push_back(block); }\n              template <typename UnaryPredicate>\n              void UnplaceBlockIf(UnaryPredicate&& predicate) {\n                auto newEnd = std::remove_if(placed_blocks_.begin(), placed_blocks_.end(),\n                                             std::forward<UnaryPredicate>(predicate));\n                placed_blocks_.erase(newEnd, placed_blocks_.end());\n              }\n              Block* start() const { return start_; }\n              std::optional<Block*> end() const { return end_; }\n              void set_end(Block* end) { end_ = end; }\n              void SetReturnType(TypeVector t) {\n                if (!return_type_) {\n                  return_type_ = t;\n                  return;\n                }\n                if (t != *return_type_) {\n                  std::stringstream message;\n                  message << \"expected return type \";\n                  PrintCommaSeparatedList(message, *return_type_);\n                  message << \" instead of \";\n                  PrintCommaSeparatedList(message, t);\n                  ReportError(message.str());\n                }\n              }\n              const std::vector<Block*>& blocks() const { return placed_blocks_; }\n              size_t NumberOfBlockIds() const { return next_block_id_; }\n              std::size_t ParameterCount() const {\n                return start_ ? start_->InputTypes().Size() : 0;\n              }\n\n             private:\n              std::list<Block> blocks_;\n              Block* start_;\n              std::vector<Block*> placed_blocks_;\n              std::optional<Block*> end_;\n              std::optional<TypeVector> return_type_;\n              size_t next_block_id_ = 0;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CfgAssembler\",\n            \"about\": \"Provides an assembler interface for constructing a ControlFlowGraph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"current_stack_\",\n                    \"type\": \"Stack<const Type*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current stack state during CFG construction.\"\n                },\n                {\n                    \"name\": \"cfg_\",\n                    \"type\": \"ControlFlowGraph\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The ControlFlowGraph being assembled.\"\n                },\n                {\n                    \"name\": \"current_block_\",\n                    \"type\": \"Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current Block being modified.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ControlFlowGraph\",\n                \"Block\",\n                \"Instruction\",\n                \"Type\",\n                \"Stack\",\n                \"StackRange\",\n                \"BottomOffset\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CfgAssembler {\n            public:\n              explicit CfgAssembler(Stack<const Type*> input_types)\n                  : current_stack_(std::move(input_types)), cfg_(current_stack_) {}\n\n              const ControlFlowGraph& Result() {\n                if (!CurrentBlockIsComplete()) {\n                  cfg_.set_end(current_block_);\n                }\n                OptimizeCfg();\n                DCHECK(CfgIsComplete());\n                ComputeInputDefinitions();\n                return cfg_;\n              }\n\n              Block* NewBlock(std::optional<Stack<const Type*>> input_types = std::nullopt,\n                              bool is_deferred = false) {\n                return cfg_.NewBlock(std::move(input_types), is_deferred);\n              }\n\n              bool CurrentBlockIsComplete() const { return current_block_->IsComplete(); }\n              bool CfgIsComplete() const {\n                return std::all_of(\n                    cfg_.blocks().begin(), cfg_.blocks().end(), [this](Block* block) {\n                      return (cfg_.end() && *cfg_.end() == block) || block->IsComplete();\n                    });\n              }\n\n              void Emit(Instruction instruction) {\n                instruction.TypeInstruction(&current_stack_, &cfg_);\n                current_block_->Add(std::move(instruction));\n              }\n\n              const Stack<const Type*>& CurrentStack() const { return current_stack_; }\n\n              StackRange TopRange(size_t slot_count) const {\n                return CurrentStack().TopRange(slot_count);\n              }\n\n              void Bind(Block* block);\n              void Goto(Block* block);\n              // Goto block while keeping {preserved_slots} many slots on the top and\n              // deleting additional the slots below these to match the input type of the\n              // target block.\n              // Returns the StackRange of the preserved slots in the target block.\n              StackRange Goto(Block* block, size_t preserved_slots);\n              // The condition must be of type bool and on the top of stack. It is removed\n              // from the stack before branching.\n              void Branch(Block* if_true, Block* if_false);\n              // Delete the specified range of slots, moving upper slots to fill the gap.\n              void DeleteRange(StackRange range);\n              void DropTo(BottomOffset new_level);\n              StackRange Peek(StackRange range, std::optional<const Type*> type);\n              void Poke(StackRange destination, StackRange origin,\n                        std::optional<const Type*> type);\n              void Print(std::string s);\n              void AssertionFailure(std::string message);\n              void Unreachable();\n              void DebugBreak();\n\n              void PrintCurrentStack(std::ostream& s) { s << \"stack: \" << current_stack_; }\n              void OptimizeCfg();\n              void ComputeInputDefinitions();\n\n             private:\n              friend class CfgAssemblerScopedTemporaryBlock;\n              Stack<const Type*> current_stack_;\n              ControlFlowGraph cfg_;\n              Block* current_block_ = cfg_.start();\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CfgAssemblerScopedTemporaryBlock\",\n            \"about\": \"A helper class that simplifies the creation of temporary blocks within a CfgAssembler.\",\n            \"attributes\": [\n                {\n                    \"name\": \"assembler_\",\n                    \"type\": \"CfgAssembler*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the CfgAssembler instance.\"\n                },\n                {\n                    \"name\": \"saved_stack_\",\n                    \"type\": \"Stack<const Type*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The stack state before entering the temporary block.\"\n                },\n                {\n                    \"name\": \"saved_block_\",\n                    \"type\": \"Block*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current block before entering the temporary block.\"\n                }\n            ],\n            \"dependencies\": [\n                \"CfgAssembler\",\n                \"Block\",\n                \"Type\",\n                \"Stack\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_NODISCARD CfgAssemblerScopedTemporaryBlock {\n            public:\n              CfgAssemblerScopedTemporaryBlock(CfgAssembler* assembler, Block* block)\n                  : assembler_(assembler), saved_block_(block) {\n                saved_stack_ = block->InputTypes();\n                DCHECK(!assembler->CurrentBlockIsComplete());\n                std::swap(saved_block_, assembler->current_block_);\n                std::swap(saved_stack_, assembler->current_stack_);\n                assembler->cfg_.PlaceBlock(block);\n              }\n\n              ~CfgAssemblerScopedTemporaryBlock() {\n                DCHECK(assembler_->CurrentBlockIsComplete());\n                std::swap(saved_block_, assembler_->current_block_);\n                std::swap(saved_stack_, assembler_->current_stack_);\n              }\n\n             private:\n              CfgAssembler* assembler_;\n              Stack<const Type*> saved_stack_;\n              Block* saved_block_;\n            };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Stack\",\n                \"about\": \"Represents a stack of types.  Defined elsewhere in the Torque codebase.\",\n                \"dependencies\": [\n                    \"Type\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class Stack {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Instruction\",\n                \"about\": \"Represents a single instruction in the Torque language. Defined elsewhere in the Torque codebase.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Instruction {\n                public:\n                    bool IsBlockTerminator() const { return false; }\n                    void TypeInstruction(Stack<const Type*>* current_stack, ControlFlowGraph* cfg) const {}\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Type\",\n                \"about\": \"Represents a type in the Torque language. Defined elsewhere in the Torque codebase.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Type {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StackRange\",\n                \"about\": \"Represents a range of slots on the stack. Defined elsewhere in the Torque codebase.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class StackRange {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BottomOffset\",\n                \"about\": \"Represents an offset from the bottom of the stack. Defined elsewhere in the Torque codebase.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class BottomOffset {\n                 public:\n                  int offset;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DefinitionLocation\",\n                \"about\": \"Represents the location where a value is defined. Defined elsewhere in the Torque codebase.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class DefinitionLocation {\n                 public:\n                  static DefinitionLocation Phi(Block* b, int offset) {\n                    return DefinitionLocation();\n                  }\n\n                  bool operator==(const DefinitionLocation& other) const {\n                    return true;\n                  }\n                };\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Worklist\",\n                \"about\": \"A simple worklist used for iterative algorithms. Defined elsewhere in the Torque codebase.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class Worklist {\n                 public:\n                  void Enqueue(T item) {}\n                };\n            ]]></code>\n        </class>\n                        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TypeVector\",\n                \"about\": \"Represents a vector of types. Defined elsewhere in the Torque codebase.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TypeVector {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}