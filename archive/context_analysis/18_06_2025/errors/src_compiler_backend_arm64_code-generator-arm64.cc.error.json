{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm64/code-generator-arm64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm64/code-generator-arm64.cc\",\n        \"file_name\": \"code-generator-arm64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Arm64-specific code generator for the V8 compiler backend.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for code generation, assembler, constants, interface descriptors, machine types, optimized compilation info, code generator, gap resolution, instruction codes, node matchers, osr, frame constants, mutable page metadata, wasm support.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/codegen/arm64/assembler-arm64-inl.h\"\n#include \"src/codegen/arm64/constants-arm64.h\"\n#include \"src/codegen/arm64/macro-assembler-arm64-inl.h\"\n#include \"src/codegen/interface-descriptors-inl.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/backend/code-generator-impl.h\"\n#include \"src/compiler/backend/code-generator.h\"\n#include \"src/compiler/backend/gap-resolver.h\"\n#include \"src/compiler/backend/instruction-codes.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/osr.h\"\n#include \"src/execution/frame-constants.h\"\n#include \"src/heap/mutable-page-metadata.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-linkage.h\"\n#include \"src/wasm/wasm-objects.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Arm64OperandConverter\",\n            \"extends\": \"InstructionOperandConverter\",\n            \"about\": \"Adds Arm64-specific methods to convert InstructionOperands.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass Arm64OperandConverter final : public InstructionOperandConverter {\n public:\n  Arm64OperandConverter(CodeGenerator* gen, Instruction* instr)\n      : InstructionOperandConverter(gen, instr) {}\n\n  DoubleRegister InputFloat32Register(size_t index) {\n    return InputDoubleRegister(index).S();\n  }\n\n  DoubleRegister InputFloat64Register(size_t index) {\n    return InputDoubleRegister(index);\n  }\n\n  DoubleRegister InputSimd128Register(size_t index) {\n    return InputDoubleRegister(index).Q();\n  }\n\n  CPURegister InputFloat32OrZeroRegister(size_t index) {\n    if (instr_->InputAt(index)->IsImmediate()) {\n      DCHECK_EQ(0, base::bit_cast<int32_t>(InputFloat32(index)));\n      return wzr;\n    }\n    DCHECK(instr_->InputAt(index)->IsFPRegister());\n    return InputDoubleRegister(index).S();\n  }\n\n  DoubleRegister InputFloat32OrFPZeroRegister(size_t index) {\n    if (instr_->InputAt(index)->IsImmediate()) {\n      DCHECK_EQ(0, base::bit_cast<int32_t>(InputFloat32(index)));\n      return fp_zero.S();\n    }\n    DCHECK(instr_->InputAt(index)->IsFPRegister());\n    return InputDoubleRegister(index).S();\n  }\n\n  CPURegister InputFloat64OrZeroRegister(size_t index) {\n    if (instr_->InputAt(index)->IsImmediate()) {\n      DCHECK_EQ(0, base::bit_cast<int64_t>(InputDouble(index)));\n      return xzr;\n    }\n    DCHECK(instr_->InputAt(index)->IsDoubleRegister());\n    return InputDoubleRegister(index);\n  }\n\n  DoubleRegister InputFloat64OrFPZeroRegister(size_t index) {\n    if (instr_->InputAt(index)->IsImmediate()) {\n      DCHECK_EQ(0, base::bit_cast<int64_t>(InputDouble(index)));\n      return fp_zero;\n    }\n    DCHECK(instr_->InputAt(index)->IsDoubleRegister());\n    return InputDoubleRegister(index);\n  }\n\n  size_t OutputCount() { return instr_->OutputCount(); }\n\n  DoubleRegister OutputFloat32Register(size_t index = 0) {\n    return OutputDoubleRegister(index).S();\n  }\n\n  DoubleRegister OutputFloat64Register(size_t index = 0) {\n    return OutputDoubleRegister(index);\n  }\n\n  DoubleRegister OutputSimd128Register() { return OutputDoubleRegister().Q(); }\n\n  Register InputRegister32(size_t index) {\n    return ToRegister(instr_->InputAt(index)).W();\n  }\n\n  Register InputOrZeroRegister32(size_t index) {\n    DCHECK(instr_->InputAt(index)->IsRegister() ||\n           (instr_->InputAt(index)->IsImmediate() && (InputInt32(index) == 0)));\n    if (instr_->InputAt(index)->IsImmediate()) {\n      return wzr;\n    }\n    return InputRegister32(index);\n  }\n\n  Register InputRegister64(size_t index) { return InputRegister(index); }\n\n  Register InputOrZeroRegister64(size_t index) {\n    DCHECK(instr_->InputAt(index)->IsRegister() ||\n           (instr_->InputAt(index)->IsImmediate() && (InputInt64(index) == 0)));\n    if (instr_->InputAt(index)->IsImmediate()) {\n      return xzr;\n    }\n    return InputRegister64(index);\n  }\n\n  Operand InputOperand(size_t index) {\n    return ToOperand(instr_->InputAt(index));\n  }\n\n  Operand InputOperand64(size_t index) { return InputOperand(index); }\n\n  Operand InputOperand32(size_t index) {\n    return ToOperand32(instr_->InputAt(index));\n  }\n\n  Register OutputRegister64(size_t index = 0) { return OutputRegister(index); }\n\n  Register OutputRegister32(size_t index = 0) {\n    return OutputRegister(index).W();\n  }\n\n  Register TempRegister32(size_t index) {\n    return ToRegister(instr_->TempAt(index)).W();\n  }\n\n  Operand InputOperand2_32(size_t index) {\n    switch (AddressingModeField::decode(instr_->opcode())) {\n      case kMode_None:\n        return InputOperand32(index);\n      case kMode_Operand2_R_LSL_I:\n        return Operand(InputRegister32(index), LSL, InputInt5(index + 1));\n      case kMode_Operand2_R_LSR_I:\n        return Operand(InputRegister32(index), LSR, InputInt5(index + 1));\n      case kMode_Operand2_R_ASR_I:\n        return Operand(InputRegister32(index), ASR, InputInt5(index + 1));\n      case kMode_Operand2_R_ROR_I:\n        return Operand(InputRegister32(index), ROR, InputInt5(index + 1));\n      case kMode_Operand2_R_UXTB:\n        return Operand(InputRegister32(index), UXTB);\n      case kMode_Operand2_R_UXTH:\n        return Operand(InputRegister32(index), UXTH);\n      case kMode_Operand2_R_SXTB:\n        return Operand(InputRegister32(index), SXTB);\n      case kMode_Operand2_R_SXTH:\n        return Operand(InputRegister32(index), SXTH);\n      case kMode_Operand2_R_SXTW:\n        return Operand(InputRegister32(index), SXTW);\n      case kMode_MRI:\n      case kMode_MRR:\n      case kMode_Root:\n        break;\n    }\n    UNREACHABLE();\n  }\n\n  Operand InputOperand2_64(size_t index) {\n    switch (AddressingModeField::decode(instr_->opcode())) {\n      case kMode_None:\n        return InputOperand64(index);\n      case kMode_Operand2_R_LSL_I:\n        return Operand(InputRegister64(index), LSL, InputInt6(index + 1));\n      case kMode_Operand2_R_LSR_I:\n        return Operand(InputRegister64(index), LSR, InputInt6(index + 1));\n      case kMode_Operand2_R_ASR_I:\n        return Operand(InputRegister64(index), ASR, InputInt6(index + 1));\n      case kMode_Operand2_R_ROR_I:\n        return Operand(InputRegister64(index), ROR, InputInt6(index + 1));\n      case kMode_Operand2_R_UXTB:\n        return Operand(InputRegister64(index), UXTB);\n      case kMode_Operand2_R_UXTH:\n        return Operand(InputRegister64(index), UXTH);\n      case kMode_Operand2_R_SXTB:\n        return Operand(InputRegister64(index), SXTB);\n      case kMode_Operand2_R_SXTH:\n        return Operand(InputRegister64(index), SXTH);\n      case kMode_Operand2_R_SXTW:\n        return Operand(InputRegister64(index), SXTW);\n      case kMode_MRI:\n      case kMode_MRR:\n      case kMode_Root:\n        break;\n    }\n    UNREACHABLE();\n  }\n\n  MemOperand MemoryOperand(size_t index = 0) {\n    switch (AddressingModeField::decode(instr_->opcode())) {\n      case kMode_None:\n      case kMode_Operand2_R_LSR_I:\n      case kMode_Operand2_R_ASR_I:\n      case kMode_Operand2_R_ROR_I:\n      case kMode_Operand2_R_UXTB:\n      case kMode_Operand2_R_UXTH:\n      case kMode_Operand2_R_SXTB:\n      case kMode_Operand2_R_SXTH:\n      case kMode_Operand2_R_SXTW:\n        break;\n      case kMode_Root:\n        return MemOperand(kRootRegister, InputInt64(index));\n      case kMode_Operand2_R_LSL_I:\n        return MemOperand(InputRegister(index + 0), InputRegister(index + 1),\n                          LSL, InputInt32(index + 2));\n      case kMode_MRI:\n        return MemOperand(InputRegister(index + 0), InputInt32(index + 1));\n      case kMode_MRR:\n        return MemOperand(InputRegister(index + 0), InputRegister(index + 1));\n    }\n    UNREACHABLE();\n  }\n\n  Operand ToOperand(InstructionOperand* op) {\n    if (op->IsRegister()) {\n      return Operand(ToRegister(op));\n    }\n    return ToImmediate(op);\n  }\n\n  Operand ToOperand32(InstructionOperand* op) {\n    if (op->IsRegister()) {\n      return Operand(ToRegister(op).W());\n    }\n    return ToImmediate(op);\n  }\n\n  Operand ToImmediate(InstructionOperand* operand) {\n    Constant constant = ToConstant(operand);\n    switch (constant.type()) {\n      case Constant::kInt32:\n        return Operand(constant.ToInt32(), constant.rmode());\n      case Constant::kInt64:\n        return Operand(constant.ToInt64(), constant.rmode());\n      case Constant::kFloat32:\n        return Operand::EmbeddedNumber(constant.ToFloat32());\n      case Constant::kFloat64:\n        return Operand::EmbeddedNumber(constant.ToFloat64().value());\n      case Constant::kExternalReference:\n        return Operand(constant.ToExternalReference());\n      case Constant::kCompressedHeapObject: {\n        RootIndex root_index;\n        if (gen_->isolate()->roots_table().IsRootHandle(constant.ToHeapObject(),\n                                                        &root_index)) {\n          CHECK(COMPRESS_POINTERS_BOOL);\n          CHECK(V8_STATIC_ROOTS_BOOL || !gen_->isolate()->bootstrapper());\n          Tagged_t ptr =\n              MacroAssemblerBase::ReadOnlyRootPtr(root_index, gen_->isolate());\n          CHECK(Assembler::IsImmAddSub(ptr));\n          return Immediate(ptr);\n        }\n\n        return Operand(constant.ToHeapObject());\n      }\n      case Constant::kHeapObject:\n        return Operand(constant.ToHeapObject());\n      case Constant::kRpoNumber:\n        UNREACHABLE();  // TODO(dcarney): RPO immediates on arm64.\n    }\n    UNREACHABLE();\n  }\n\n  MemOperand ToMemOperand(InstructionOperand* op, MacroAssembler* masm) const {\n    DCHECK_NOT_NULL(op);\n    DCHECK(op->IsStackSlot() || op->IsFPStackSlot());\n    return SlotToMemOperand(AllocatedOperand::cast(op)->index(), masm);\n  }\n\n  MemOperand SlotToMemOperand(int slot, MacroAssembler* masm) const {\n    FrameOffset offset = frame_access_state()->GetFrameOffset(slot);\n    if (offset.from_frame_pointer()) {\n      int from_sp = offset.offset() + frame_access_state()->GetSPToFPOffset();\n      // Convert FP-offsets to SP-offsets if it results in better code.\n      if (!frame_access_state()->FPRelativeOnly() &&\n          (Assembler::IsImmLSUnscaled(from_sp) ||\n           Assembler::IsImmLSScaled(from_sp, 3))) {\n        offset = FrameOffset::FromStackPointer(from_sp);\n      }\n    }\n    // Access below the stack pointer is not expected in arm64 and is actively\n    // prevented at run time in the simulator.\n    DCHECK_IMPLIES(offset.from_stack_pointer(), offset.offset() >= 0);\n    return MemOperand(offset.from_stack_pointer() ? sp : fp, offset.offset());\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineRecordWrite\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"Handles out-of-line record write operations, including write barriers.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass OutOfLineRecordWrite final : public OutOfLineCode {\n public:\n  OutOfLineRecordWrite(\n      CodeGenerator* gen, Register object, Operand offset, Register value,\n      RecordWriteMode mode, StubCallMode stub_mode,\n      UnwindingInfoWriter* unwinding_info_writer,\n      IndirectPointerTag indirect_pointer_tag = kIndirectPointerNullTag)\n      : OutOfLineCode(gen),\n        object_(object),\n        offset_(offset),\n        value_(value),\n        mode_(mode),\n#if V8_ENABLE_WEBASSEMBLY\n        stub_mode_(stub_mode),\n#endif  // V8_ENABLE_WEBASSEMBLY\n        must_save_lr_(!gen->frame_access_state()->has_frame()),\n        unwinding_info_writer_(unwinding_info_writer),\n        zone_(gen->zone()),\n        indirect_pointer_tag_(indirect_pointer_tag) {\n  }\n\n  void Generate() final {\n    // When storing an indirect pointer, the value will always be a\n    // full/decompressed pointer.\n    if (COMPRESS_POINTERS_BOOL &&\n        mode_ != RecordWriteMode::kValueIsIndirectPointer) {\n      __ DecompressTagged(value_, value_);\n    }\n\n    // No need to check value page flags with the indirect pointer write barrier\n    // because the value is always an ExposedTrustedObject.\n    if (mode_ != RecordWriteMode::kValueIsIndirectPointer) {\n      __ CheckPageFlag(value_, MemoryChunk::kPointersToHereAreInterestingMask,\n                       eq, exit());\n    }\n\n    SaveFPRegsMode const save_fp_mode = frame()->DidAllocateDoubleRegisters()\n                                            ? SaveFPRegsMode::kSave\n                                            : SaveFPRegsMode::kIgnore;\n    if (must_save_lr_) {\n      // We need to save and restore lr if the frame was elided.\n      __ Push<MacroAssembler::kSignLR>(lr, padreg);\n      unwinding_info_writer_->MarkLinkRegisterOnTopOfStack(__ pc_offset(), sp);\n    }\n    if (mode_ == RecordWriteMode::kValueIsEphemeronKey) {\n      __ CallEphemeronKeyBarrier(object_, offset_, save_fp_mode);\n    } else if (mode_ == RecordWriteMode::kValueIsIndirectPointer) {\n      // We must have a valid indirect pointer tag here. Otherwise, we risk not\n      // invoking the correct write barrier, which may lead to subtle issues.\n      CHECK(IsValidIndirectPointerTag(indirect_pointer_tag_));\n      __ CallIndirectPointerBarrier(object_, offset_, save_fp_mode,\n                                    indirect_pointer_tag_);\n#if V8_ENABLE_WEBASSEMBLY\n    } else if (stub_mode_ == StubCallMode::kCallWasmRuntimeStub) {\n      // A direct call to a wasm runtime stub defined in this module.\n      // Just encode the stub index. This will be patched when the code\n      // is added to the native module and copied into wasm code space.\n      __ CallRecordWriteStubSaveRegisters(object_, offset_, save_fp_mode,\n                                          StubCallMode::kCallWasmRuntimeStub);\n#endif  // V8_ENABLE_WEBASSEMBLY\n    } else {\n      __ CallRecordWriteStubSaveRegisters(object_, offset_, save_fp_mode);\n    }\n    if (must_save_lr_) {\n      __ Pop<MacroAssembler::kAuthLR>(padreg, lr);\n      unwinding_info_writer_->MarkPopLinkRegisterFromTopOfStack(__ pc_offset());\n    }\n  }\n\n private:\n  Register const object_;\n  Operand const offset_;\n  Register const value_;\n  RecordWriteMode const mode_;\n#if V8_ENABLE_WEBASSEMBLY\n  StubCallMode const stub_mode_;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  bool must_save_lr_;\n  UnwindingInfoWriter* const unwinding_info_writer_;\n  Zone* zone_;\n  IndirectPointerTag indirect_pointer_tag_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FlagsConditionToCondition\",\n            \"about\": \"Converts FlagsCondition enum to the corresponding Condition enum for Arm64 assembly.\",\n            \"logic\": \"Uses a switch statement to map each FlagsCondition to its corresponding Condition. Handles float conditions, NaN checks, overflow, positive/zero, and negative cases.\",\n            \"parameters\": [\n                {\n                    \"name\": \"condition\",\n                    \"type\": \"FlagsCondition\",\n                    \"purpose\": \"The condition to be converted.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Condition\",\n                \"description\": \"The equivalent Arm64 Condition.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nCondition FlagsConditionToCondition(FlagsCondition condition) {\n  switch (condition) {\n    case kEqual:\n      return eq;\n    case kNotEqual:\n      return ne;\n    case kSignedLessThan:\n      return lt;\n    case kSignedGreaterThanOrEqual:\n      return ge;\n    case kSignedLessThanOrEqual:\n      return le;\n    case kSignedGreaterThan:\n      return gt;\n    case kUnsignedLessThan:\n      return lo;\n    case kUnsignedGreaterThanOrEqual:\n      return hs;\n    case kUnsignedLessThanOrEqual:\n      return ls;\n    case kUnsignedGreaterThan:\n      return hi;\n    case kFloatLessThanOrUnordered:\n      return lt;\n    case kFloatGreaterThanOrEqual:\n      return ge;\n    case kFloatLessThanOrEqual:\n      return ls;\n    case kFloatGreaterThanOrUnordered:\n      return hi;\n    case kFloatLessThan:\n      return lo;\n    case kFloatGreaterThanOrEqualOrUnordered:\n      return hs;\n    case kFloatLessThanOrEqualOrUnordered:\n      return le;\n    case kFloatGreaterThan:\n      return gt;\n    case kOverflow:\n      return vs;\n    case kNotOverflow:\n      return vc;\n    case kUnorderedEqual:\n    case kUnorderedNotEqual:\n    case kIsNaN:\n    case kIsNotNaN:\n      break;\n    case kPositiveOrZero:\n      return pl;\n    case kNegative:\n      return mi;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmOutOfLineTrap\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"Handles out-of-line traps for WebAssembly.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\nclass WasmOutOfLineTrap : public OutOfLineCode {\n public:\n  WasmOutOfLineTrap(CodeGenerator* gen, Instruction* instr)\n      : OutOfLineCode(gen), gen_(gen), instr_(instr) {}\n  void Generate() override {\n    Arm64OperandConverter i(gen_, instr_);\n    TrapId trap_id =\n        static_cast<TrapId>(i.InputInt32(instr_->InputCount() - 1));\n    GenerateCallToTrap(trap_id);\n  }\n\n protected:\n  CodeGenerator* gen_;\n\n  void GenerateWithTrapId(TrapId trap_id) { GenerateCallToTrap(trap_id); }\n\n private:\n  void GenerateCallToTrap(TrapId trap_id) {\n    gen_->AssembleSourcePosition(instr_);\n    __ Call(static_cast<Address>(trap_id), RelocInfo::WASM_STUB_CALL);\n    ReferenceMap* reference_map = gen_->zone()->New<ReferenceMap>(gen_->zone());\n    gen_->RecordSafepoint(reference_map);\n    __ AssertUnreachable(AbortReason::kUnexpectedReturnFromWasmTrap);\n  }\n\n  Instruction* instr_;\n};\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"RecordTrapInfoIfNeeded\",\n            \"about\": \"Records trap information if needed, based on memory access mode.\",\n            \"logic\": \"Checks the memory access mode and calls RecordProtectedInstruction if the mode indicates protected memory access.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone.\"\n                },\n                {\n                    \"name\": \"codegen\",\n                    \"type\": \"CodeGenerator*\",\n                    \"purpose\": \"The code generator instance.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction code.\"\n                },\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction.\"\n                },\n                {\n                    \"name\": \"pc\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The program counter offset.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\nvoid RecordTrapInfoIfNeeded(Zone* zone, CodeGenerator* codegen,\n                            InstructionCode opcode, Instruction* instr,\n                            int pc) {\n  const MemoryAccessMode access_mode = AccessModeField::decode(opcode);\n  if (access_mode == kMemoryAccessProtectedMemOutOfBounds ||\n      access_mode == kMemoryAccessProtectedNullDereference) {\n    codegen->RecordProtectedInstruction(pc);\n  }\n}\n#else\nvoid RecordTrapInfoIfNeeded(Zone* zone, CodeGenerator* codegen,\n                            InstructionCode opcode, Instruction* instr,\n                            int pc) {\n  DCHECK_EQ(kMemoryAccessDirect, AccessModeField::decode(opcode));\n}\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"EmitFpOrNeonUnop\",\n            \"about\": \"Handles unary ops that work for float (scalar), double (scalar), or NEON (SIMD).\",\n            \"logic\": \"Determines the vector format based on whether the input is a SIMD128 register and then calls the given function pointer with the correct input and output VRegisters.\",\n            \"parameters\": [\n                {\n                    \"name\": \"masm\",\n                    \"type\": \"MacroAssembler*\",\n                    \"purpose\": \"The macro assembler.\"\n                },\n                {\n                    \"name\": \"fn\",\n                    \"type\": \"Fn\",\n                    \"purpose\": \"A pointer to the member function of MacroAssembler to call. Ex: &MacroAssembler::Frintm\"\n                },\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction.\"\n                },\n                {\n                    \"name\": \"i\",\n                    \"type\": \"Arm64OperandConverter\",\n                    \"purpose\": \"The operand converter.\"\n                },\n                {\n                    \"name\": \"scalar\",\n                    \"type\": \"VectorFormat\",\n                    \"purpose\": \"The scalar vector format\"\n                },\n                {\n                    \"name\": \"vector\",\n                    \"type\": \"VectorFormat\",\n                    \"purpose\": \"The vector format\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Fn>\nvoid EmitFpOrNeonUnop(MacroAssembler* masm, Fn fn, Instruction* instr,\n                      Arm64OperandConverter i, VectorFormat scalar,\n                      VectorFormat vector) {\n  VectorFormat f = instr->InputAt(0)->IsSimd128Register() ? vector : scalar;\n\n  VRegister output = VRegister::Create(i.OutputDoubleRegister().code(), f);\n  VRegister input = VRegister::Create(i.InputDoubleRegister(0).code(), f);\n  (masm->*fn)(output, input);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AssembleDeconstructFrame\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles code to deconstruct a stack frame.\",\n            \"logic\": \"Moves the stack pointer to the frame pointer and pops the frame pointer and link register.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleDeconstructFrame() {\n  __ Mov(sp, fp);\n  __ Pop<MacroAssembler::kAuthLR>(fp, lr);\n\n  unwinding_info_writer_.MarkFrameDeconstructed(__ pc_offset());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AssemblePrepareTailCall\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Prepares for a tail call.\",\n            \"logic\": \"Restores the frame pointer and link register if a frame exists, then sets the frame access to SP.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssemblePrepareTailCall() {\n  if (frame_access_state()->has_frame()) {\n    __ RestoreFPAndLR();\n  }\n  frame_access_state()->SetFrameAccessToSP();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AdjustStackPointerForTailCall\",\n            \"about\": \"Adjusts the stack pointer for a tail call to ensure proper stack alignment and space.\",\n            \"logic\": \"Calculates the difference between the current stack slot above SP and the new required slot. Claims or drops stack slots accordingly to adjust the stack pointer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"masm\",\n                    \"type\": \"MacroAssembler*\",\n                    \"purpose\": \"The macro assembler.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"FrameAccessState*\",\n                    \"purpose\": \"The frame access state.\"\n                },\n                {\n                    \"name\": \"new_slot_above_sp\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The desired number of stack slots above the stack pointer.\"\n                },\n                {\n                    \"name\": \"allow_shrinkage\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether stack shrinkage is allowed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AdjustStackPointerForTailCall(MacroAssembler* masm,\n                                   FrameAccessState* state,\n                                   int new_slot_above_sp,\n                                   bool allow_shrinkage = true) {\n  int current_sp_offset = state->GetSPToFPSlotCount() +\n                          StandardFrameConstants::kFixedSlotCountAboveFp;\n  int stack_slot_delta = new_slot_above_sp - current_sp_offset;\n  DCHECK_EQ(stack_slot_delta % 2, 0);\n  if (stack_slot_delta > 0) {\n    masm->Claim(stack_slot_delta);\n    state->IncreaseSPDelta(stack_slot_delta);\n  } else if (allow_shrinkage && stack_slot_delta < 0) {\n    masm->Drop(-stack_slot_delta);\n    state->IncreaseSPDelta(stack_slot_delta);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AssembleTailCallBeforeGap\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the tail call setup before a gap (potential deoptimization point).\",\n            \"logic\": \"Adjusts the stack pointer to the first unused slot offset.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction.\"\n                },\n                {\n                    \"name\": \"first_unused_slot_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The offset of the first unused stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleTailCallBeforeGap(Instruction* instr,\n                                              int first_unused_slot_offset) {\n  AdjustStackPointerForTailCall(masm(), frame_access_state(),\n                                first_unused_slot_offset, false);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AssembleTailCallAfterGap\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the tail call setup after a gap (potential deoptimization point).\",\n            \"logic\": \"Adjusts the stack pointer to the first unused slot offset and potentially adds padding if specified.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction.\"\n                },\n                {\n                    \"name\": \"first_unused_slot_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The offset of the first unused stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleTailCallAfterGap(Instruction* instr,\n                                             int first_unused_slot_offset) {\n  DCHECK_EQ(first_unused_slot_offset % 2, 0);\n  AdjustStackPointerForTailCall(masm(), frame_access_state(),\n                                first_unused_slot_offset);\n  DCHECK(instr->IsTailCall());\n  InstructionOperandConverter g(this, instr);\n  int"
}