{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/value-numbering-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 111, column 49",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/value-numbering-reducer.h\",\n            \"file_name\": \"value-numbering-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the ValueNumberingReducer class for removing redundant nodes from the Turboshaft graph.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for logging, vectors, assembler, hashing, graph operations, reducer traits, utilities, and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/logging.h\"\n#include \"src/base/vector.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/fast-hash.h\"\n#include \"src/compiler/turboshaft/graph.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/reducer-traits.h\"\n#include \"src/utils/utils.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ScopeCounter\",\n                \"about\": \"Counts scopes. Used to determine if value numbering is active.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"scopes_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of the number of active scopes.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass ScopeCounter {\n public:\n  void enter() { scopes_++; }\n  void leave() { scopes_--; }\n  bool is_active() { return scopes_ > 0; }\n\n private:\n  int scopes_{0};\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DisableValueNumbering\",\n                \"about\": \"Disables value numbering within a specific scope.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"scopes_\",\n                        \"type\": \"ScopeCounter*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the ScopeCounter, used to manage disabling value numbering.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ScopeCounter\",\n                    \"ValueNumberingReducer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass DisableValueNumbering {\n public:\n  template <class Reducer>\n  explicit DisableValueNumbering(Reducer* reducer) {\n    if constexpr (reducer_list_contains<typename Reducer::ReducerList,\n                                        ValueNumberingReducer>::value) {\n      scopes_ = reducer->gvn_disabled_scope();\n      scopes_->enter();\n    }\n  }\n\n  ~DisableValueNumbering() {\n    if (scopes_ != nullptr) scopes_->leave();\n  }\n\n private:\n  ScopeCounter* scopes_{nullptr};\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ValueNumberingReducer\",\n                \"about\": \"The main class that performs value numbering to remove redundant nodes in the graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"dominator_path_\",\n                        \"type\": \"ZoneVector<Block*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the dominator path to the current block.\"\n                    },\n                    {\n                        \"name\": \"table_\",\n                        \"type\": \"base::Vector<Entry>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The hash table used to store value numbers.\"\n                    },\n                    {\n                        \"name\": \"mask_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mask used for hash table indexing.\"\n                    },\n                    {\n                        \"name\": \"entry_count_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of entries in the hash table.\"\n                    },\n                    {\n                        \"name\": \"depths_heads_\",\n                        \"type\": \"ZoneVector<Entry*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Heads of linked lists for each dominator tree depth.\"\n                    },\n                    {\n                        \"name\": \"disabled_scope_\",\n                        \"type\": \"ScopeCounter\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Scope counter to disable value numbering.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Next\",\n                    \"TURBOSHAFT_REDUCER_BOILERPLATE\",\n                    \"CanBeGVNed\",\n                    \"Reduce##Name\",\n                    \"AddOrFind\",\n                    \"Block\",\n                    \"ResetToBlock\",\n                    \"Op\",\n                    \"Entry\",\n                    \"Find\",\n                    \"IsEmpty\",\n                    \"Operation\",\n                    \"EqualsForGVN\",\n                    \"ClearCurrentDepthEntries\",\n                    \"RehashIfNeeded\",\n                    \"ComputeHash\",\n                    \"is_disabled\",\n                    \"ZoneVector\",\n                    \"base::Vector\",\n                    \"ScopeCounter\",\n                    \"TypeInferenceReducer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass ValueNumberingReducer : public Next {\n#if defined(__clang__)\n  static_assert(next_is_bottom_of_assembler_stack<Next>::value ||\n                next_reducer_is<Next, TypeInferenceReducer>::value);\n#endif\n\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(ValueNumbering)\n\n  template <typename Op>\n  static constexpr bool CanBeGVNed() {\n    constexpr Opcode opcode = operation_to_opcode_v<Op>;\n    /* Throwing operations have a non-trivial lowering, so they don't work\n     * with value numbering. */\n    if constexpr (MayThrow(opcode)) return false;\n    if constexpr (opcode == Opcode::kCatchBlockBegin) {\n      /* CatchBlockBegin are never interesting to GVN, but additionally\n       * split-edge can transform CatchBlockBeginOp into PhiOp, which means\n       * that there is no guarantee here than {result} is indeed a\n       * CatchBlockBegin. */\n      return false;\n    }\n    if constexpr (opcode == Opcode::kComment) {\n      /* We don't want to GVN comments. */\n      return false;\n    }\n    return true;\n  }\n\n#define EMIT_OP(Name)                                                 \\\n  template <class... Args>                                            \\\n  OpIndex Reduce##Name(Args... args) {                                \\\n    OpIndex next_index = Asm().output_graph().next_operation_index(); \\\n    USE(next_index);                                                  \\\n    OpIndex result = Next::Reduce##Name(args...);                     \\\n    if (ShouldSkipOptimizationStep()) return result;                  \\\n    if constexpr (!CanBeGVNed<Name##Op>()) return result;             \\\n    DCHECK_EQ(next_index, result);                                    \\\n    return AddOrFind<Name##Op>(result);                               \\\n  }\n  TURBOSHAFT_OPERATION_LIST(EMIT_OP)\n#undef EMIT_OP\n\n  void Bind(Block* block) {\n    Next::Bind(block);\n    ResetToBlock(block);\n    dominator_path_.push_back(block);\n    depths_heads_.push_back(nullptr);\n  }\n\n  // Resets {table_} up to the first dominator of {block} that it contains.\n  void ResetToBlock(Block* block) {\n    Block* target = block->GetDominator();\n    while (!dominator_path_.empty() && target != nullptr &&\n           dominator_path_.back() != target) {\n      if (dominator_path_.back()->Depth() > target->Depth()) {\n        ClearCurrentDepthEntries();\n      } else if (dominator_path_.back()->Depth() < target->Depth()) {\n        target = target->GetDominator();\n      } else {\n        // {target} and {dominator_path.back} have the same depth but are not\n        // equal, so we go one level up for both.\n        ClearCurrentDepthEntries();\n        target = target->GetDominator();\n      }\n    }\n  }\n\n  template <class Op>\n  bool WillGVNOp(const Op& op) {\n    Entry* entry = Find(op);\n    return !entry->IsEmpty();\n  }\n\n  ScopeCounter* gvn_disabled_scope() { return &disabled_scope_; }\n\n private:\n  // TODO(dmercadier): Once the mapping from Operations to Blocks has been added\n  // to turboshaft, remove the `block` field from the `Entry` structure.\n  struct Entry {\n    OpIndex value;\n    BlockIndex block;\n    size_t hash = 0;\n    Entry* depth_neighboring_entry = nullptr;\n\n    bool IsEmpty() const { return hash == 0; }\n  };\n\n  template <class Op>\n  OpIndex AddOrFind(OpIndex op_idx) {\n    if (is_disabled()) return op_idx;\n\n    const Op& op = Asm().output_graph().Get(op_idx).template Cast<Op>();\n    if (std::is_same_v<Op, PendingLoopPhiOp> || op.IsBlockTerminator() ||\n        (!op.Effects().repetition_is_eliminatable() &&\n         !std::is_same_v<Op, DeoptimizeIfOp>)) {\n      // GVNing DeoptimizeIf is safe, despite its lack of\n      // repetition_is_eliminatable.\n      return op_idx;\n    }\n    RehashIfNeeded();\n\n    size_t hash;\n    Entry* entry = Find(op, &hash);\n    if (entry->IsEmpty()) {\n      // {op} is not present in the state, inserting it.\n      *entry = Entry{op_idx, Asm().current_block()->index(), hash,\n                     depths_heads_.back()};\n      depths_heads_.back() = entry;\n      ++entry_count_;\n      return op_idx;\n    } else {\n      // {op} is already present, removing it from the graph and returning the\n      // previous one.\n      Next::RemoveLast(op_idx);\n      return entry->value;\n    }\n  }\n\n  template <class Op>\n  Entry* Find(const Op& op, size_t* hash_ret = nullptr) {\n    constexpr bool same_block_only = std::is_same<Op, PhiOp>::value;\n    size_t hash = ComputeHash<same_block_only>(op);\n    size_t start_index = hash & mask_;\n    for (size_t i = start_index;; i = NextEntryIndex(i)) {\n      Entry& entry = table_[i];\n      if (entry.IsEmpty()) {\n        // We didn't find {op} in {table_}. Returning where it could be\n        // inserted.\n        if (hash_ret) *hash_ret = hash;\n        return &entry;\n      }\n      if (entry.hash == hash) {\n        const Operation& entry_op = Asm().output_graph().Get(entry.value);\n        if (entry_op.Is<Op>() &&\n            (!same_block_only ||\n             entry.block == Asm().current_block()->index()) &&\n            entry_op.Cast<Op>().EqualsForGVN(op)) {\n          return &entry;\n        }\n      }\n      // Making sure that we don't have an infinite loop.\n      DCHECK_NE(start_index, NextEntryIndex(i));\n    }\n  }\n\n  // Remove all of the Entries of the current depth.\n  void ClearCurrentDepthEntries() {\n    for (Entry* entry = depths_heads_.back(); entry != nullptr;) {\n      entry->hash = 0;\n      Entry* next_entry = entry->depth_neighboring_entry;\n      entry->depth_neighboring_entry = nullptr;\n      entry = next_entry;\n      --entry_count_;\n    }\n    depths_heads_.pop_back();\n    dominator_path_.pop_back();\n  }\n\n  // If the table is too full, double its size and re-insert the old entries.\n  void RehashIfNeeded() {\n    if (V8_LIKELY(table_.size() - (table_.size() / 4) > entry_count_)) return;\n    base::Vector<Entry> new_table = table_ =\n        Asm().phase_zone()->template NewVector<Entry>(table_.size() * 2);\n    size_t mask = mask_ = table_.size() - 1;\n\n    for (size_t depth_idx = 0; depth_idx < depths_heads_.size(); depth_idx++) {\n      // It's important to fill the new hash by inserting data in increasing\n      // depth order, in order to avoid holes when later calling\n      // ClearCurrentDepthEntries. Consider for instance:\n      //\n      //  ---+------+------+------+----\n      //     |  a1  |  a2  |  a3  |\n      //  ---+------+------+------+----\n      //\n      // Where a1, a2 and a3 have the same hash. By construction, we know that\n      // depth(a1) <= depth(a2) <= depth(a3). If, when re-hashing, we were to\n      // insert them in another order, say:\n      //\n      //  ---+------+------+------+----\n      //     |  a3  |  a1  |  a2  |\n      //  ---+------+------+------+----\n      //\n      // Then, when we'll call ClearCurrentDepthEntries to remove entries from\n      // a3's depth, we'll get this:\n      //\n      //  ---+------+------+------+----\n      //     | null |  a1  |  a2  |\n      //  ---+------+------+------+----\n      //\n      // And, when looking if a1 is in the hash, we'd find a \"null\" where we\n      // expect it, and assume that it's not present. If, instead, we always\n      // conserve the increasing depth order, then when removing a3, we'd get:\n      //\n      //  ---+------+------+------+----\n      //     |  a1  |  a2  | null |\n      //  ---+------+------+------+----\n      //\n      // Where we can still find a1 and a2.\n      Entry* entry = depths_heads_[depth_idx];\n      depths_heads_[depth_idx] = nullptr;\n\n      while (entry != nullptr) {\n        for (size_t i = entry->hash & mask;; i = NextEntryIndex(i)) {\n          if (new_table[i].hash == 0) {\n            new_table[i] = *entry;\n            Entry* next_entry = entry->depth_neighboring_entry;\n            new_table[i].depth_neighboring_entry = depths_heads_[depth_idx];\n            depths_heads_[depth_idx] = &new_table[i];\n            entry = next_entry;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  template <bool same_block_only, class Op>\n  size_t ComputeHash(const Op& op) {\n    size_t hash = op.hash_value();\n    if (same_block_only) {\n      hash = fast_hash_combine(Asm().current_block()->index(), hash);\n    }\n    if (V8_UNLIKELY(hash == 0)) return 1;\n    return hash;\n  }\n\n  size_t NextEntryIndex(size_t index) { return (index + 1) & mask_; }\n  Entry* NextEntry(Entry* entry) {\n    return V8_LIKELY(entry + 1 < table_.end()) ? entry + 1 : &table_[0];\n  }\n  Entry* PrevEntry(Entry* entry) {\n    return V8_LIKELY(entry > table_.begin()) ? entry - 1 : table_.end() - 1;\n  }\n\n  bool is_disabled() { return disabled_scope_.is_active(); }\n\n  ZoneVector<Block*> dominator_path_{Asm().phase_zone()};\n  base::Vector<Entry> table_ = Asm().phase_zone()->template NewVector<Entry>(\n      base::bits::RoundUpToPowerOfTwo(\n          std::max<size_t>(128, Asm().input_graph().op_id_capacity() / 2)));\n  size_t mask_ = table_.size() - 1;\n  size_t entry_count_ = 0;\n  ZoneVector<Entry*> depths_heads_{Asm().phase_zone()};\n  ScopeCounter disabled_scope_;\n};\n        ]]></code>\n    </class>\n</file>\n```"
}