{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/string-builder-optimizer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 62, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/string-builder-optimizer.h\",\n        \"file_name\": \"string-builder-optimizer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the StringBuilderOptimizer class, which analyzes the compiler graph to identify and optimize string building loops by replacing ConsString operations with mutable string buffers.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ libraries and V8-specific headers for data structures, compiler components, and memory management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <cstdint>\n#include <optional>\n#include <unordered_map>\n#include <vector>\n\n#include \"src/base/macros.h\"\n#include \"src/compiler/graph-assembler.h\"\n#include \"src/compiler/graph-reducer.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node-marker.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/schedule.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OneOrTwoByteAnalysis\",\n            \"about\": \"This class is used to determine statically whether a string constant or StringFromSingleCharCode is a 1-byte or a 2-byte string. This information can be used to optimize the generated code by removing 1-byte/2-byte checks.\",\n            \"attributes\": [\n                {\n                    \"name\": \"states_\",\n                    \"type\": \"ZoneVector<State>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the analysis state for each node in the graph.\"\n                },\n                {\n                    \"name\": \"broker_\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the JS heap for inspecting string constants.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TFGraph\",\n                \"Zone\",\n                \"JSHeapBroker\",\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass OneOrTwoByteAnalysis final {\n  // The class OneOrTwoByteAnalysis is used to try to statically determine\n  // whether a string constant or StringFromSingleCharCode is a 1-byte or a\n  // 2-byte string.\n  // If we succeed to do this analysis for all of the nodes in a string builder,\n  // then we know statically whether this string builder is building a 1-byte or\n  // a 2-byte string, and we can optimize the generated code to remove all\n  // 1-byte/2-byte checks.\n public:\n  OneOrTwoByteAnalysis(TFGraph* graph, Zone* zone, JSHeapBroker* broker)\n      : states_(graph->NodeCount(), State::kUnknown, zone), broker_(broker) {}\n\n  enum class State : uint8_t {\n    kUnknown,  // Not yet determined if the string is 1 or 2-bytes\n    kOneByte,  // Only 1-byte strings in the string builder\n    kTwoByte,  // At least one 2-byte string in the string builder\n    kCantKnow  // Cannot determine statically if the string will be 1 or 2-bytes\n\n    // Lattice of possible transitions:\n    //\n    //      kUnknown\n    //      /     | \\\n    //     /      |  \\\n    //    v       |   \\\n    //  kOneByte  |    |\n    //  |   |     |    |\n    //  |   |     v    |\n    //  |   v     kTwoByte   |\n    //  |      |      /\n    //   \\     |     /\n    //    v    v    v\n    //     kCantKnow\n    //\n    // Which means that for instance it's possible to realize that a kUnknown\n    // string builder will produce a 1-byte string, and we can later realize\n    // that it will instead be a 2-byte string. Or, we could be in kOneByte\n    // state, and then realize that the string may or may not end up being\n    // 2-byte, so we'll move to kCantKnow state.\n  };\n\n  // Computes and returns a State reflecting whether {node} is a 1-byte or\n  // 2-byte string.\n  State OneOrTwoByte(Node* node);\n\n  // Computes whether the string builder will be on 1-byte or 2-byte if it\n  // contains two nodes that have states {a} and {b}. For instance, if both {a}\n  // and {b} are kOneByte, ConcatResultIsOneOrTwoByte returns kOneByte.\n  static State ConcatResultIsOneOrTwoByte(State a, State b);\n\n private:\n  // Returns the positive integral range that {node} can take. If {node} can be\n  // negative or is not a number, returns nullopt. If the range exceeds 2**32,\n  // returns nullopt as well. The analysis of TryGetRange is not complete (some\n  // operators are ignored), so if {node} isn't handled, then nullopt is\n  // returned. If this function returns a range between 0 and 255, then we\n  // assume that calling StringFromSingleCharCode on {node} will produce a\n  // 1-byte string. The analysis is sound (it doesn't make mistake), but is not\n  // complete (it bails out (returns nullopt) on operators that are not\n  // handled).\n  std::optional<std::pair<int64_t, int64_t>> TryGetRange(Node* node);\n\n  JSHeapBroker* broker() { return broker_; }\n\n  ZoneVector<State> states_;\n  JSHeapBroker* broker_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StringBuilderOptimizer\",\n            \"about\": \"This class analyzes the compiler graph to identify and optimize string building loops by replacing ConsString operations with mutable string buffers.\",\n            \"attributes\": [\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the JavaScript graph.\"\n                },\n                {\n                    \"name\": \"schedule_\",\n                    \"type\": \"Schedule*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides information about the scheduling of nodes in the graph.\"\n                },\n                {\n                    \"name\": \"temp_zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A temporary memory zone for allocating data structures during optimization.\"\n                },\n                {\n                    \"name\": \"broker_\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the JS heap for inspecting string constants.\"\n                },\n                {\n                    \"name\": \"string_builder_count_\",\n                    \"type\": \"unsigned int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A counter for assigning unique IDs to string builders.\"\n                },\n                {\n                    \"name\": \"blocks_to_trimmings_map_\",\n                    \"type\": \"ZoneVector<std::optional<ZoneVector<Node*>>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Maps basic block IDs to loop phi nodes that end string builders.  Used for inserting trimming code.\"\n                },\n                {\n                    \"name\": \"status_\",\n                    \"type\": \"ZoneVector<Status>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the optimization status of each node in the graph.\"\n                },\n                {\n                    \"name\": \"string_builders_\",\n                    \"type\": \"ZoneVector<StringBuilder>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores information about the identified string builders.\"\n                },\n                {\n                    \"name\": \"loop_headers_\",\n                    \"type\": \"ZoneVector<BasicBlock*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Keeps track of loop headers during graph traversal.\"\n                }\n            ],\n            \"dependencies\": [\n                \"JSGraph\",\n                \"Schedule\",\n                \"Zone\",\n                \"JSHeapBroker\",\n                \"Node\",\n                \"BasicBlock\",\n                \"OneOrTwoByteAnalysis\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE StringBuilderOptimizer final {\n public:\n  StringBuilderOptimizer(JSGraph* jsgraph, Schedule* schedule, Zone* temp_zone,\n                         JSHeapBroker* broker);\n\n  // Returns true if some trimming code should be inserted at the beginning of\n  // {block} to finalize some string builders.\n  bool BlockShouldFinalizeStringBuilders(BasicBlock* block);\n  // Returns which nodes should be trimmed at the beginning of {block} to\n  // finalize some string builders.\n  ZoneVector<Node*> GetStringBuildersToFinalize(BasicBlock* block);\n\n  // Returns true if {node} is the last node of a StringBuilder (which means\n  // that trimming code should be inserted after {node}).\n  // Note that string builders cannot end in the middle of a loop (unless it was\n  // started in the same loop). The way it's enforced is that when we first\n  // visit a loop Phi that could be part of a String Builder, we set its status\n  // to State::kPendingPhi. Only once we've visited the whole loop and the\n  // backedge and that the use chain following the loop phi up to and including\n  // the backedge are valid as part of a String Builder, then the loop phi\n  // status is siwtched to State::kInStringBuilder. Then, in the final step\n  // where we switch the status to State::kConfirmedInStringBuilder, we ignore\n  // nodes that have a status that isn't kInStringBuilder, which means that we\n  // ignore loop phis that still have the kPendingPhi status (and their\n  // successors). The String Builders thus cannot end inside loops.\n  bool IsStringBuilderEnd(Node* node);\n  // Returns true if {node} is a the last node of a StringBuilder and is not a\n  // loop phi. The \"loop phi\" distinction matters, because trimming for loop\n  // phis is trickier (because we don't want to trim at every iteration of the\n  // loop, but only once after the loop).\n  bool IsNonLoopPhiStringBuilderEnd(Node* node);\n  // Returns true if {node} is the input of a concatenation that is part of a\n  // StringBuilder.\n  bool IsStringBuilderConcatInput(Node* node);\n  // Returns true if {node} is part of a StringBuilder.\n  bool ConcatIsInStringBuilder(Node* node);\n  // Returns true if {node} is the 1st node of a StringBuilder (which means that\n  // when lowering {node}, we should allocate and initialize everything for this\n  // particular StringBuilder).\n  bool IsFirstConcatInStringBuilder(Node* node);\n\n  // Returns an OneOrTwoByteAnalysis::State representing whether the\n  // StringBuilder that contains {node} is building a 1-byte or a 2-byte.\n  OneOrTwoByteAnalysis::State GetOneOrTwoByte(Node* node);\n\n  void Run();\n\n  JSGraph* jsgraph() const { return jsgraph_; }\n  TFGraph* graph() const { return jsgraph_->graph(); }\n  Schedule* schedule() const { return schedule_; }\n  Zone* temp_zone() const { return temp_zone_; }\n  JSHeapBroker* broker() const { return broker_; }\n\n private:\n  enum class State : uint8_t {\n    kUnvisited = 0,\n    kBeginStringBuilder,        // A (potential) beginning of a StringBuilder\n    kInStringBuilder,           // A node that could be in a StringBuilder\n    kPendingPhi,                // A phi that could be in a StringBuilder\n    kConfirmedInStringBuilder,  // A node that is definitely in a StringBuilder\n    kEndStringBuilder,  // A node that ends definitely a StringBuilder, and that\n                        // can be trimmed right away\n    kEndStringBuilderLoopPhi,  // A phi that ends a StringBuilder, and whose\n                               // trimming need to be done at the beginning of\n                               // the following blocks.\n    kInvalid,  // A node that we visited and that we can't optimize.\n    kNumberOfState\n  };\n\n  struct Status {\n    int id;       // The id of the StringBuilder that the node belongs to (or\n                  // kInvalidId).\n    State state;  // The state of the node.\n  };\n  static constexpr int kInvalidId = -1;\n\n  Status GetStatus(Node* node) const {\n    if (node->id() > status_.size()) {\n      return Status{kInvalidId, State::kInvalid};\n    } else {\n      return status_[node->id()];\n    }\n  }\n  void SetStatus(Node* node, State state, int id = kInvalidId) {\n    DCHECK_NE(state, State::kUnvisited);\n    DCHECK_IMPLIES(id != kInvalidId, state != State::kInvalid);\n    if (node->id() >= status_.size()) {\n      // We should really not allocate too many new nodes: the only new nodes we\n      // allocate are constant inputs of nodes in the string builder that have\n      // multiple uses. Thus, we use a slow exponential growth for {status_}.\n      constexpr double growth_factor = 1.1;\n      status_.resize(node->id() * growth_factor,\n                     Status{kInvalidId, State::kUnvisited});\n    }\n    status_[node->id()] = Status{id, state};\n  }\n  void UpdateStatus(Node* node, State state) {\n    int id = state == State::kInvalid ? kInvalidId : GetStatus(node).id;\n    status_[node->id()] = Status{id, state};\n  }\n\n  struct StringBuilder {\n    Node* start;\n    int id;\n    bool has_loop_phi;\n    OneOrTwoByteAnalysis::State one_or_two_bytes;\n  };\n  const StringBuilder kInvalidStringBuilder = {\n      nullptr, kInvalidId, false, OneOrTwoByteAnalysis::State::kUnknown};\n\n#ifdef DEBUG\n  bool StringBuilderIsValid(StringBuilder string_builder) {\n    return string_builder.start != nullptr && string_builder.id != kInvalidId &&\n           string_builder.has_loop_phi;\n  }\n#endif\n\n  bool IsLoopPhi(Node* node) const {\n    return node->opcode() == IrOpcode::kPhi &&\n           schedule()->block(node)->IsLoopHeader();\n  }\n  bool LoopContains(Node* loop_phi, Node* node) {\n    DCHECK(IsLoopPhi(loop_phi));\n    return schedule()->block(loop_phi)->LoopContains(schedule()->block(node));\n  }\n\n  int GetStringBuilderIdForConcat(Node* node);\n  void ReplaceConcatInputIfNeeded(Node* node, int input_idx);\n  bool CheckNodeUses(Node* node, Node* concat_child, Status status);\n  bool CheckPreviousNodeUses(Node* child, Status status,\n                             int input_if_loop_phi = 0);\n  int GetPhiPredecessorsCommonId(Node* node);\n\n  void FinalizeStringBuilders();\n  void VisitNode(Node* node, BasicBlock* block);\n  void VisitGraph();\n\n  static constexpr bool kAllowAnyStringOnTheRhs = false;\n\n  JSGraph* jsgraph_;\n  Schedule* schedule_;\n  Zone* temp_zone_;\n  JSHeapBroker* broker_;\n  unsigned int string_builder_count_ = 0;\n  // {blocks_to_trimmings_map_} is a map from block IDs to loop phi nodes that\n  // end string builders. For each such node, a trimming should be inserted at\n  // the beginning of the block (in EffectControlLinearizer) in order to\n  // properly finish the string builder (well, most things will work if the\n  // trimming is omitted, but adding this trimming save memory and removes the\n  // SlicedString indirection; the only thing that would be an issue is that the\n  // rest of the VM could have access to a SlicedString that is less than\n  // SlicedString::kMinLength characters, which may or may not break things).\n  ZoneVector<std::optional<ZoneVector<Node*>>> blocks_to_trimmings_map_;\n  ZoneVector<Status> status_;\n  ZoneVector<StringBuilder> string_builders_;\n  // {loop_headers_} is used to keep track ot the start of each loop that the\n  // block currently being visited is part of.\n  ZoneVector<BasicBlock*> loop_headers_;\n};\n        ]]></code>\n    </class>\n</file>\n```"
}