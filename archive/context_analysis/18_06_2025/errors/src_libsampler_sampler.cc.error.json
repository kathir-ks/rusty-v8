{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/libsampler/sampler.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/libsampler/sampler.cc\",\n      \"file_name\": \"sampler.cc\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Implements the sampler for profiling JavaScript code execution in V8.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes necessary headers for sampler implementation including V8 API, platform abstraction, signal handling, and standard library components.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/libsampler/sampler.h\"\n\n#include \"include/v8-isolate.h\"\n#include \"include/v8-platform.h\"\n#include \"include/v8-unwinder.h\"\n\n#ifdef USE_SIGNALS\n\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <sys/time.h>\n#include <atomic>\n\n#if !V8_OS_QNX && !V8_OS_AIX && !V8_OS_ZOS\n#include <sys/syscall.h>\n#endif\n\n#if V8_OS_AIX || V8_TARGET_ARCH_S390X\n\n#include \"src/base/platform/time.h\"\n\n#elif V8_OS_DARWIN\n#include <mach/mach.h>\n// OpenBSD doesn't have <ucontext.h>. ucontext_t lives in <signal.h>\n// and is a typedef for struct sigcontext. There is no uc_mcontext.\n#elif !V8_OS_OPENBSD\n#include <ucontext.h>\n#endif\n\n#include <unistd.h>\n\n#elif V8_OS_WIN || V8_OS_CYGWIN\n\n#include <windows.h>\n\n#elif V8_OS_FUCHSIA\n\n#include <zircon/process.h>\n#include <zircon/syscalls.h>\n#include <zircon/syscalls/debug.h>\n#include <zircon/types.h>\n\n// TODO(wez): Remove this once the Fuchsia SDK has rolled.\n#if defined(ZX_THREAD_STATE_REGSET0)\n#define ZX_THREAD_STATE_GENERAL_REGS ZX_THREAD_STATE_REGSET0\nzx_status_t zx_thread_read_state(zx_handle_t h, uint32_t k, void* b, size_t l) {\n  uint32_t dummy_out_len = 0;\n  return zx_thread_read_state(h, k, b, static_cast<uint32_t>(l),\n                              &dummy_out_len);\n}\n#if defined(__x86_64__)\nusing zx_thread_state_general_regs_t = zx_x86_64_general_regs_t;\n#else\nusing zx_thread_state_general_regs_t = zx_arm64_general_regs_t;\n#endif\n#endif  // !defined(ZX_THREAD_STATE_GENERAL_REGS)\n\n#endif\n\n#include <algorithm>\n#include <vector>\n\n#include \"src/base/atomic-utils.h\"\n#include \"src/base/platform/mutex.h\"\n#include \"src/base/platform/platform.h\"\n\n#if V8_OS_ZOS\n// Header from zoslib, for __mcontext_t_:\n#include \"edcwccwi.h\"\n#endif\n\n#if V8_OS_ANDROID && !defined(__BIONIC_HAVE_UCONTEXT_T)\n\n// Not all versions of Android's C library provide ucontext_t.\n// Detect this and provide custom but compatible definitions. Note that these\n// follow the GLibc naming convention to access register values from\n// mcontext_t.\n//\n// See http://code.google.com/p/android/issues/detail?id=34784\n\n#if defined(__arm__)\n\nusing mcontext_t = struct sigcontext;\n\nstruct ucontext_t {\n  uint32_t uc_flags;\n  struct ucontext* uc_link;\n  stack_t uc_stack;\n  mcontext_t uc_mcontext;\n  // Other fields are not used by V8, don't define them here.\n};\n\n#elif defined(__aarch64__)\n\nusing mcontext_t = struct sigcontext;\n\nstruct ucontext_t {\n  uint64_t uc_flags;\n  struct ucontext* uc_link;\n  stack_t uc_stack;\n  mcontext_t uc_mcontext;\n  // Other fields are not used by V8, don't define them here.\n};\n\n#elif defined(__mips__)\n// MIPS version of sigcontext, for Android bionic.\nstruct mcontext_t {\n  uint32_t regmask;\n  uint32_t status;\n  uint64_t pc;\n  uint64_t gregs[32];\n  uint64_t fpregs[32];\n  uint32_t acx;\n  uint32_t fpc_csr;\n  uint32_t fpc_eir;\n  uint32_t used_math;\n  uint32_t dsp;\n  uint64_t mdhi;\n  uint64_t mdlo;\n  uint32_t hi1;\n  uint32_t lo1;\n  uint32_t hi2;\n  uint32_t lo2;\n  uint32_t hi3;\n  uint32_t lo3;\n};\n\nstruct ucontext_t {\n  uint32_t uc_flags;\n  struct ucontext* uc_link;\n  stack_t uc_stack;\n  mcontext_t uc_mcontext;\n  // Other fields are not used by V8, don't define them here.\n};\n\n#elif defined(__i386__)\n// x86 version for Android.\nstruct mcontext_t {\n  uint32_t gregs[19];\n  void* fpregs;\n  uint32_t oldmask;\n  uint32_t cr2;\n};\n\nusing kernel_sigset_t = uint32_t[2];  // x86 kernel uses 64-bit signal masks\nstruct ucontext_t {\n  uint32_t uc_flags;\n  struct ucontext* uc_link;\n  stack_t uc_stack;\n  mcontext_t uc_mcontext;\n  // Other fields are not used by V8, don't define them here.\n};\nenum { REG_EBP = 6, REG_ESP = 7, REG_EIP = 14 };\n\n#elif defined(__x86_64__)\n// x64 version for Android.\nstruct mcontext_t {\n  uint64_t gregs[23];\n  void* fpregs;\n  uint64_t __reserved1[8];\n};\n\nstruct ucontext_t {\n  uint64_t uc_flags;\n  struct ucontext* uc_link;\n  stack_t uc_stack;\n  mcontext_t uc_mcontext;\n  // Other fields are not used by V8, don't define them here.\n};\nenum { REG_RBP = 10, REG_RSP = 15, REG_RIP = 16 };\n#endif\n\n#endif  // V8_OS_ANDROID && !defined(__BIONIC_HAVE_UCONTEXT_T)\n]]></code>\n  </imports>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"AtomicGuard\",\n        \"about\": \"A class to manage atomic mutex locks, ensuring mutual exclusion across threads.\",\n        \"attributes\": [\n          {\n            \"name\": \"atomic_\",\n            \"type\": \"AtomicMutex*\",\n            \"access\": \"private\",\n            \"purpose\": \"Pointer to the atomic mutex being guarded.\"\n          },\n          {\n            \"name\": \"is_success_\",\n            \"type\": \"bool\",\n            \"access\": \"private\",\n            \"purpose\": \"Indicates whether the atomic lock was successfully acquired.\"\n          }\n        ],\n        \"dependencies\": [\n          \"AtomicMutex\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nclass AtomicGuard {\n public:\n  AtomicGuard(AtomicMutex* atomic, bool is_blocking);\n  ~AtomicGuard();\n\n  bool is_success() const { return is_success_; }\n\n private:\n  AtomicMutex* atomic_;\n  bool is_success_;\n};\n]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"constructor\",\n        \"name\": \"AtomicGuard\",\n        \"parent\": \"AtomicGuard\",\n        \"about\": \"Constructor for AtomicGuard. Attempts to acquire the atomic lock.\",\n        \"logic\": \"Uses compare_exchange_strong to acquire the lock. If is_blocking is true, it retries until the lock is acquired. If false, it attempts only once.\",\n        \"parameters\": [\n          {\n            \"name\": \"atomic\",\n            \"type\": \"AtomicMutex*\",\n            \"purpose\": \"Pointer to the atomic mutex.\"\n          },\n          {\n            \"name\": \"is_blocking\",\n            \"type\": \"bool\",\n            \"purpose\": \"Indicates whether the constructor should block until the lock is acquired.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"AtomicMutex\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nAtomicGuard::AtomicGuard(AtomicMutex* atomic, bool is_blocking)\n    : atomic_(atomic), is_success_(false) {\n  do {\n    bool expected = false;\n    // We have to use the strong version here for the case where is_blocking\n    // is false, and we will only attempt the exchange once.\n    is_success_ = atomic->compare_exchange_strong(expected, true);\n  } while (is_blocking && !is_success_);\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"destructor\",\n        \"name\": \"~AtomicGuard\",\n        \"parent\": \"AtomicGuard\",\n        \"about\": \"Destructor for AtomicGuard. Releases the atomic lock if it was acquired.\",\n        \"logic\": \"Releases the lock only if it was successfully acquired in the constructor.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"AtomicMutex\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nAtomicGuard::~AtomicGuard() {\n  if (!is_success_) return;\n  atomic_->store(false);\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"is_success\",\n        \"parent\": \"AtomicGuard\",\n        \"about\": \"Returns whether the AtomicGuard successfully acquired the lock.\",\n        \"logic\": \"Returns the value of the is_success_ member.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the lock was acquired, false otherwise.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nbool AtomicGuard::is_success() const { return is_success_; }\n]]></code>\n  </func>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"Sampler::PlatformData\",\n        \"about\": \"Stores platform-specific data needed by the sampler.\",\n        \"attributes\": [\n          {\n            \"name\": \"vm_tid_\",\n            \"type\": \"int\",\n            \"access\": \"private\",\n            \"purpose\": \"Stores the thread ID of the V8 VM.\"\n          },\n          {\n            \"name\": \"vm_tself_\",\n            \"type\": \"pthread_t\",\n            \"access\": \"private\",\n            \"purpose\": \"Stores the pthread ID of the V8 VM.\"\n          }\n        ],\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nclass Sampler::PlatformData {\n public:\n  PlatformData()\n      : vm_tid_(base::OS::GetCurrentThreadId()), vm_tself_(pthread_self()) {}\n  int vm_tid() const { return vm_tid_; }\n  pthread_t vm_tself() const { return vm_tself_; }\n\n private:\n  int vm_tid_;\n  pthread_t vm_tself_;\n};\n]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"constructor\",\n        \"name\": \"PlatformData\",\n        \"parent\": \"Sampler::PlatformData\",\n        \"about\": \"Constructor for PlatformData. Initializes the thread ID and pthread ID.\",\n        \"logic\": \"Gets the current thread ID and pthread ID and stores them in the member variables.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"base::OS::GetCurrentThreadId\",\n          \"pthread_self\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nPlatformData::PlatformData()\n      : vm_tid_(base::OS::GetCurrentThreadId()), vm_tself_(pthread_self()) {}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"vm_tid\",\n        \"parent\": \"Sampler::PlatformData\",\n        \"about\": \"Returns the thread ID of the V8 VM.\",\n        \"logic\": \"Returns the value of the vm_tid_ member.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"int\",\n          \"description\": \"The thread ID.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nint PlatformData::vm_tid() const { return vm_tid_; }\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"vm_tself\",\n        \"parent\": \"Sampler::PlatformData\",\n        \"about\": \"Returns the pthread ID of the V8 VM.\",\n        \"logic\": \"Returns the value of the vm_tself_ member.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"pthread_t\",\n          \"description\": \"The pthread ID.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\npthread_t PlatformData::vm_tself() const { return vm_tself_; }\n]]></code>\n  </func>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"SamplerManager\",\n        \"about\": \"Manages a collection of Sampler objects, associating them with their respective threads. Handles adding and removing samplers, and triggering samples.\",\n        \"attributes\": [\n          {\n            \"name\": \"sampler_map_\",\n            \"type\": \"std::unordered_map<int, SamplerList>\",\n            \"access\": \"private\",\n            \"purpose\": \"Maps thread IDs to lists of samplers active on that thread.\"\n          },\n          {\n            \"name\": \"samplers_access_counter_\",\n            \"type\": \"AtomicMutex\",\n            \"access\": \"private\",\n            \"purpose\": \"An atomic mutex to protect access to the sampler_map_.\"\n          }\n        ],\n        \"dependencies\": [\n          \"Sampler\",\n          \"SamplerList\",\n          \"AtomicMutex\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nclass SamplerManager {\n public:\n  void AddSampler(Sampler* sampler);\n  void RemoveSampler(Sampler* sampler);\n  void DoSample(const v8::RegisterState& state);\n\n  static SamplerManager* instance();\n\n private:\n  using SamplerList = std::vector<Sampler*>;\n  std::unordered_map<int, SamplerList> sampler_map_;\n  AtomicMutex samplers_access_counter_;\n};\n]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"AddSampler\",\n        \"parent\": \"SamplerManager\",\n        \"about\": \"Adds a sampler to the sampler map, associating it with its thread ID.\",\n        \"logic\": \"Acquires a lock on the samplers_access_counter_ to protect the sampler_map_.  Finds the SamplerList associated with the thread_id (via vm_tid). Creates a new list if one doesn't exist.  Adds the sampler to that list.\",\n        \"parameters\": [\n          {\n            \"name\": \"sampler\",\n            \"type\": \"Sampler*\",\n            \"purpose\": \"The sampler to add.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"Sampler\",\n          \"SamplerList\",\n          \"AtomicGuard\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid SamplerManager::AddSampler(Sampler* sampler) {\n  AtomicGuard atomic_guard(&samplers_access_counter_);\n  DCHECK(sampler->IsActive());\n  int thread_id = sampler->platform_data()->vm_tid();\n  auto it = sampler_map_.find(thread_id);\n  if (it == sampler_map_.end()) {\n    SamplerList samplers;\n    samplers.push_back(sampler);\n    sampler_map_.emplace(thread_id, std::move(samplers));\n  } else {\n    SamplerList& samplers = it->second;\n    auto sampler_it = std::find(samplers.begin(), samplers.end(), sampler);\n    if (sampler_it == samplers.end()) samplers.push_back(sampler);\n  }\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"RemoveSampler\",\n        \"parent\": \"SamplerManager\",\n        \"about\": \"Removes a sampler from the sampler map.\",\n        \"logic\": \"Acquires a lock on samplers_access_counter_.  Finds the SamplerList associated with the thread id.  Removes the sampler from that list.  If the list becomes empty, it is removed from the map.\",\n        \"parameters\": [\n          {\n            \"name\": \"sampler\",\n            \"type\": \"Sampler*\",\n            \"purpose\": \"The sampler to remove.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"Sampler\",\n          \"SamplerList\",\n          \"AtomicGuard\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid SamplerManager::RemoveSampler(Sampler* sampler) {\n  AtomicGuard atomic_guard(&samplers_access_counter_);\n  DCHECK(sampler->IsActive());\n  int thread_id = sampler->platform_data()->vm_tid();\n  auto it = sampler_map_.find(thread_id);\n  DCHECK_NE(it, sampler_map_.end());\n  SamplerList& samplers = it->second;\n  samplers.erase(std::remove(samplers.begin(), samplers.end(), sampler),\n                 samplers.end());\n  if (samplers.empty()) {\n    sampler_map_.erase(it);\n  }\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"DoSample\",\n        \"parent\": \"SamplerManager\",\n        \"about\": \"Iterates through the samplers associated with the current thread and triggers a sample if conditions are met.\",\n        \"logic\": \"Acquires a non-blocking lock on samplers_access_counter_.  If successful, it finds the SamplerList associated with the current thread id.  For each sampler in the list, checks if it ShouldRecordSample.  If so, checks the isolate and samples the stack.\",\n        \"parameters\": [\n          {\n            \"name\": \"state\",\n            \"type\": \"const v8::RegisterState&\",\n            \"purpose\": \"The register state to be used for sampling.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"Sampler\",\n          \"SamplerList\",\n          \"AtomicGuard\",\n          \"v8::Isolate\",\n          \"v8::RegisterState\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid SamplerManager::DoSample(const v8::RegisterState& state) {\n  AtomicGuard atomic_guard(&samplers_access_counter_, false);\n  // TODO(petermarshall): Add stat counters for the bailouts here.\n  if (!atomic_guard.is_success()) return;\n  int thread_id = base::OS::GetCurrentThreadId();\n  auto it = sampler_map_.find(thread_id);\n  if (it == sampler_map_.end()) return;\n  SamplerList& samplers = it->second;\n\n  for (Sampler* sampler : samplers) {\n    if (!sampler->ShouldRecordSample()) continue;\n    Isolate* isolate = sampler->isolate();\n    // We require a fully initialized and entered isolate.\n    if (isolate == nullptr || !isolate->IsInUse()) continue;\n    sampler->SampleStack(state);\n  }\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"instance\",\n        \"parent\": \"SamplerManager\",\n        \"about\": \"Returns a singleton instance of the SamplerManager.\",\n        \"logic\": \"Uses a leaky object to ensure only one instance exists.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"SamplerManager*\",\n          \"description\": \"The singleton instance.\"\n        },\n        \"dependencies\": [\n          \"base::LeakyObject\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nSamplerManager* SamplerManager::instance() {\n  static base::LeakyObject<SamplerManager> instance;\n  return instance.get();\n}\n]]></code>\n  </func>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"SignalHandler\",\n        \"about\": \"Handles the SIGPROF signal for sampling. Installs and restores the signal handler.\",\n        \"attributes\": [\n          {\n            \"name\": \"mutex_\",\n            \"type\": \"base::LazyRecursiveMutex\",\n            \"access\": \"private\",\n            \"purpose\": \"Protects process wide state.\"\n          },\n          {\n            \"name\": \"client_count_\",\n            \"type\": \"int\",\n            \"access\": \"private\",\n            \"purpose\": \"Counts the number of clients using the signal handler.\"\n          },\n          {\n            \"name\": \"signal_handler_installed_\",\n            \"type\": \"bool\",\n            \"access\": \"private\",\n            \"purpose\": \"Indicates whether the signal handler is currently installed.\"\n          },\n          {\n            \"name\": \"old_signal_handler_\",\n            \"type\": \"struct sigaction\",\n            \"access\": \"private\",\n            \"purpose\": \"Stores the previous signal handler.\"\n          }\n        ],\n        \"dependencies\": [\n          \"base::RecursiveMutex\",\n          \"base::LazyRecursiveMutex\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nclass SignalHandler {\n public:\n  static void IncreaseSamplerCount() {\n    base::RecursiveMutexGuard lock_guard(mutex_.Pointer());\n    if (++client_count_ == 1) Install();\n  }\n\n  static void DecreaseSamplerCount() {\n    base::RecursiveMutexGuard lock_guard(mutex_.Pointer());\n    if (--client_count_ == 0) Restore();\n  }\n\n  static bool Installed() {\n    // mutex_ will also be used in Sampler::DoSample to guard the state below.\n    base::RecursiveMutexGuard lock_guard(mutex_.Pointer());\n    return signal_handler_installed_;\n  }\n\n  static v8::base::RecursiveMutex* mutex() { return mutex_.Pointer(); }\n\n private:\n  static void Install() {\n    struct sigaction sa;\n    sa.sa_sigaction = &HandleProfilerSignal;\n    sigemptyset(&sa.sa_mask);\n#if V8_OS_QNX\n    sa.sa_flags = SA_SIGINFO | SA_ONSTACK;\n#else\n    sa.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;\n#endif\n    signal_handler_installed_ =\n        (sigaction(SIGPROF, &sa, &old_signal_handler_) == 0);\n  }\n\n  static void Restore() {\n    if (signal_handler_installed_) {\n      signal_handler_installed_ = false;\n#if V8_OS_AIX || V8_TARGET_ARCH_S390X\n      // On Aix, IBMi & zLinux SIGPROF can sometimes arrive after the\n      // default signal handler is restored, resulting in intermittent test\n      // failure when profiling is enabled (https://crbug.com/v8/12952)\n      base::OS::Sleep(base::TimeDelta::FromMicroseconds(10));\n#endif\n      sigaction(SIGPROF, &old_signal_handler_, nullptr);\n    }\n  }\n\n  static void FillRegisterState(void* context, RegisterState* regs);\n  static void HandleProfilerSignal(int signal, siginfo_t* info, void* context);\n\n  // Protects the process wide state below.\n  static base::LazyRecursiveMutex mutex_;\n  static int client_count_;\n  static bool signal_handler_installed_;\n  static struct sigaction old_signal_handler_;\n};\n]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"IncreaseSamplerCount\",\n        \"parent\": \"SignalHandler\",\n        \"about\": \"Increases the sampler count and installs the signal handler if it's the first client.\",\n        \"logic\": \"Acquires a recursive mutex. If the client count becomes 1, installs the signal handler.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"base::RecursiveMutexGuard\",\n          \"Install\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstatic void IncreaseSamplerCount() {\n    base::RecursiveMutexGuard lock_guard(mutex_.Pointer());\n    if (++client_count_ == 1) Install();\n  }\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"DecreaseSamplerCount\",\n        \"parent\": \"SignalHandler\",\n        \"about\": \"Decreases the sampler count and restores the signal handler if it's the last client.\",\n        \"logic\": \"Acquires a recursive mutex. If the client count becomes 0, restores the signal handler.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"base::RecursiveMutexGuard\",\n          \"Restore\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstatic void DecreaseSamplerCount() {\n    base::RecursiveMutexGuard lock_guard(mutex_.Pointer());\n    if (--client_count_ == 0) Restore();\n  }\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Installed\",\n        \"parent\": \"SignalHandler\",\n        \"about\": \"Returns whether the signal handler is currently installed.\",\n        \"logic\": \"Acquires a recursive mutex and returns the value of the signal_handler_installed_ member.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the signal handler is installed, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"base::RecursiveMutexGuard\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstatic bool Installed() {\n    // mutex_ will also be used in Sampler::DoSample to guard the state below.\n    base::RecursiveMutexGuard lock_guard(mutex_.Pointer());\n    return signal_handler_installed_;\n  }\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"mutex\",\n        \"parent\": \"SignalHandler\",\n        \"about\": \"Returns a pointer to the recursive mutex used for protecting signal handler state.\",\n        \"logic\": \"Returns the pointer to the lazy initialized recursive mutex.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"v8::base::RecursiveMutex*\",\n          \"description\": \"The mutex pointer.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nstatic v8::base::RecursiveMutex* mutex() { return mutex_.Pointer(); }\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Install\",\n        \"parent\": \"SignalHandler\",\n        \"about\": \"Installs the SIGPROF signal handler.\",\n        \"logic\": \"Sets up the sigaction struct with the HandleProfilerSignal function, clears the signal mask, sets the flags (SA_RESTART, SA_SIGINFO, SA_ONSTACK), and then uses sigaction to install the handler for SIGPROF.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"HandleProfilerSignal\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstatic void Install() {\n    struct sigaction sa;\n    sa.sa_sigaction = &HandleProfilerSignal;\n    sigemptyset(&sa.sa_mask);\n#if V8_OS_QNX\n    sa.sa_flags = SA_SIGINFO | SA_ONSTACK;\n#else\n    sa.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;\n#endif\n    signal_handler_installed_ =\n        (sigaction(SIGPROF, &sa, &old_signal_handler_) == 0);\n  }\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Restore\",\n        \"parent\": \"SignalHandler\",\n        \"about\": \"Restores the previous signal handler for SIGPROF.\",\n        \"logic\": \"If the signal handler is installed, it sets signal_handler_installed_ to false, and then uses sigaction to restore the old signal handler.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nstatic void Restore() {\n    if (signal_handler_installed_) {\n      signal_handler_installed_ = false;\n#if V8_OS_AIX || V8_TARGET_ARCH_S390X\n      // On Aix, IBMi & zLinux SIGPROF can sometimes arrive after the\n      // default signal handler is restored, resulting in intermittent test\n      // failure when profiling is enabled (https://crbug.com/v8/12952)\n      base::OS::Sleep(base::TimeDelta::FromMicroseconds(10));\n#endif\n      sigaction(SIGPROF, &old_signal_handler_, nullptr);\n    }\n  }\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"FillRegisterState\",\n        \"parent\": \"SignalHandler\",\n        \"about\": \"Fills the RegisterState struct with data extracted from the signal handler context.\",\n        \"logic\": \"The extraction process is highly platform dependent and involves accessing specific fields within the ucontext_t or mcontext_t structs based on the operating system and architecture. This function is responsible for mapping the platform's register representation to a unified RegisterState representation used by the sampler.\",\n        \"parameters\": [\n          {\n            \"name\": \"context\",\n            \"type\": \"void*\",\n            \"purpose\": \"The signal handler context (ucontext_t*).\"\n          },\n          {\n            \"name\": \"regs\",\n            \"type\": \"RegisterState*\",\n            \"purpose\": \"The RegisterState struct to be filled.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"None\"\n        },\n        \"dependencies\": [\n          \"RegisterState\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nstatic void FillRegisterState(void* context, RegisterState* regs);\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"HandleProfilerSignal\",\n        \"parent\": \"SignalHandler\",\n        \"about\": \"The signal handler function for SIGPROF.\",\n        \"logic\": \"Sets the default permissions for signal handler memory. Checks if the signal is SIGPROF. If it is, it creates a RegisterState struct, fills it using"
}