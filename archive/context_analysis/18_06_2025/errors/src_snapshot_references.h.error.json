{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/references.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 174, column 64",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/references.h\",\n            \"file_name\": \"references.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines classes for handling references during snapshot serialization in V8.\",\n            \"note\": \"This header file defines structures for managing different kinds of references that arise during snapshotting, which is crucial for V8's fast startup.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for bit field manipulation, hash map implementation, isolate access, and identity map functionalities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/bit-field.h\"\n#include \"src/base/hashmap.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/utils/identity-map.h\"\n        ]]></code>\n    </imports>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"SnapshotSpace\",\n                \"about\": \"Defines the different memory spaces where snapshot objects can reside.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class SnapshotSpace : uint8_t {\n  kReadOnlyHeap = 0,\n  kOld = 1,\n  kCode = 2,\n  kTrusted = 3,\n};\n        ]]></code>\n    </enum>\n    <variable>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"kNumberOfSnapshotSpaces\",\n                \"about\": \"Defines the number of spaces snapshot has\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstatic constexpr int kNumberOfSnapshotSpaces = 4;\n        ]]></code>\n    </variable>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SerializerReference\",\n                \"about\": \"Represents a reference to an object within the snapshot.  It can be a back-reference, attached reference, off-heap backing store reference, or a built-in reference.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"bit_field_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the type and index of the reference in a bit field.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nclass SerializerReference {\n private:\n  enum SpecialValueType {\n    kBackReference,\n    kAttachedReference,\n    kOffHeapBackingStore,\n    kBuiltinReference,\n  };\n\n  SerializerReference(SpecialValueType type, uint32_t value)\n      : bit_field_(TypeBits::encode(type) | ValueBits::encode(value)) {}\n\n public:\n  static SerializerReference BackReference(uint32_t index) {\n    return SerializerReference(kBackReference, index);\n  }\n\n  static SerializerReference OffHeapBackingStoreReference(uint32_t index) {\n    return SerializerReference(kOffHeapBackingStore, index);\n  }\n\n  static SerializerReference AttachedReference(uint32_t index) {\n    return SerializerReference(kAttachedReference, index);\n  }\n\n  static SerializerReference BuiltinReference(uint32_t index) {\n    return SerializerReference(kBuiltinReference, index);\n  }\n\n  bool is_back_reference() const {\n    return TypeBits::decode(bit_field_) == kBackReference;\n  }\n\n  uint32_t back_ref_index() const {\n    DCHECK(is_back_reference());\n    return ValueBits::decode(bit_field_);\n  }\n\n  bool is_off_heap_backing_store_reference() const {\n    return TypeBits::decode(bit_field_) == kOffHeapBackingStore;\n  }\n\n  uint32_t off_heap_backing_store_index() const {\n    DCHECK(is_off_heap_backing_store_reference());\n    return ValueBits::decode(bit_field_);\n  }\n\n  bool is_attached_reference() const {\n    return TypeBits::decode(bit_field_) == kAttachedReference;\n  }\n\n  uint32_t attached_reference_index() const {\n    DCHECK(is_attached_reference());\n    return ValueBits::decode(bit_field_);\n  }\n\n  bool is_builtin_reference() const {\n    return TypeBits::decode(bit_field_) == kBuiltinReference;\n  }\n\n  uint32_t builtin_index() const {\n    DCHECK(is_builtin_reference());\n    return ValueBits::decode(bit_field_);\n  }\n\n private:\n  using TypeBits = base::BitField<SpecialValueType, 0, 2>;\n  using ValueBits = TypeBits::Next<uint32_t, 32 - TypeBits::kSize>;\n\n  uint32_t bit_field_;\n\n  friend class SerializerReferenceMap;\n};\n        ]]></code>\n    </class>\n    <static_assert>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"about\": \"Checks the size of SerializerReference. This ensures that the `SerializerReference` class can be stored efficiently in the `IdentityMap` used by the serializer.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstatic_assert(sizeof(SerializerReference) <= sizeof(void*));\n        ]]></code>\n    </static_assert>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SerializerReferenceMap\",\n                \"about\": \"Manages a map of HeapObjects to SerializerReferences.  Used during serialization to track references and avoid duplicates.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"map_\",\n                        \"type\": \"IdentityMap<SerializerReference, base::DefaultAllocationPolicy>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps HeapObjects to their corresponding SerializerReference.\"\n                    },\n                    {\n                        \"name\": \"backing_store_map_\",\n                        \"type\": \"std::unordered_map<void*, SerializerReference>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps backing stores to their corresponding SerializerReference.\"\n                    },\n                    {\n                        \"name\": \"attached_reference_index_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of the index for attached references.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"IdentityMap\",\n                    \"SerializerReference\",\n                    \"Isolate\",\n                    \"HeapObject\",\n                    \"DirectHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass SerializerReferenceMap {\n public:\n  explicit SerializerReferenceMap(Isolate* isolate)\n      : map_(isolate->heap()), attached_reference_index_(0) {}\n\n  const SerializerReference* LookupReference(Tagged<HeapObject> object) const {\n    return map_.Find(object);\n  }\n\n  const SerializerReference* LookupReference(\n      DirectHandle<HeapObject> object) const {\n    return map_.Find(object);\n  }\n\n  const SerializerReference* LookupBackingStore(void* backing_store) const {\n    auto it = backing_store_map_.find(backing_store);\n    if (it == backing_store_map_.end()) return nullptr;\n    return &it->second;\n  }\n\n  void Add(Tagged<HeapObject> object, SerializerReference reference) {\n    DCHECK_NULL(LookupReference(object));\n    map_.Insert(object, reference);\n  }\n\n  void AddBackingStore(void* backing_store, SerializerReference reference) {\n    DCHECK(backing_store_map_.find(backing_store) == backing_store_map_.end());\n    backing_store_map_.emplace(backing_store, reference);\n  }\n\n  SerializerReference AddAttachedReference(Tagged<HeapObject> object) {\n    SerializerReference reference =\n        SerializerReference::AttachedReference(attached_reference_index_++);\n    map_.Insert(object, reference);\n    return reference;\n  }\n\n private:\n  IdentityMap<SerializerReference, base::DefaultAllocationPolicy> map_;\n  std::unordered_map<void*, SerializerReference> backing_store_map_;\n  int attached_reference_index_;\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Isolate\",\n                    \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\",\n                    \"details\": \"The `Isolate` class in V8 is a fundamental concept. It represents an independent instance of the V8 engine. Each `Isolate` has its own heap and garbage collector, allowing multiple independent JavaScript executions within the same process.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {\n                public:\n                    class Heap { };\n                    Heap* heap() { return nullptr; }\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"HeapObject\",\n                    \"about\": \"Base class for all objects allocated on the V8 heap.\",\n                    \"details\": \"Represents an object allocated on the V8 heap.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class HeapObject {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"DirectHandle\",\n                    \"about\": \"Represents a direct handle to a heap object.\",\n                    \"details\": \"Provides a direct, untraced reference to a heap object.  Care must be taken to ensure that the object remains alive.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                class DirectHandle {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"IdentityMap\",\n                    \"about\": \"A map that uses object identity for keys.\",\n                    \"details\": \"Used to store and retrieve objects based on their memory address (identity) rather than their content.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename V, typename A>\n                class IdentityMap {\n                public:\n                    const V* Find(void* key) const { return nullptr; }\n                    void Insert(void* key, const V& value) {}\n                };\n            ]]></code>\n        </class>\n        <namespace>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"namespace\",\n                    \"name\": \"base\",\n                    \"about\": \"Base utilities and data structures\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace base {\n                    class DefaultAllocationPolicy {};\n                }\n            ]]></code>\n        </namespace>\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"macro\",\n                    \"name\": \"DCHECK_NULL\",\n                    \"about\": \"Assertion that value is null\"\n                }\n            </metadata>\n            <code><![CDATA[\n                #define CHECK_NULL(x)\n            ]]></code>\n        </macro>\n        <macro>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"macro\",\n                    \"name\": \"DCHECK\",\n                    \"about\": \"Assertion\"\n                }\n            </metadata>\n            <code><![CDATA[\n                #define CHECK(x)\n            ]]></code>\n        </macro>\n    </dependencies>\n</file>\n```"
}