{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/translated-state.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/translated-state.cc\",\n      \"file_name\": \"translated-state.cc\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Provides functionality for translating the state of an optimized function frame during deoptimization, allowing the construction of a compatible unoptimized frame.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes standard library headers and V8-specific headers necessary for deoptimization, object manipulation, and frame management.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/deoptimizer/translated-state.h\"\n\n#include <inttypes.h>\n\n#include <iomanip>\n#include <optional>\n\n#include \"src/base/memory.h\"\n#include \"src/common/assert-scope.h\"\n#include \"src/deoptimizer/deoptimizer.h\"\n#include \"src/deoptimizer/materialized-object-store.h\"\n#include \"src/deoptimizer/translation-opcode.h\"\n#include \"src/diagnostics/disasm.h\"\n#include \"src/execution/frames.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/heap/heap.h\"\n#include \"src/numbers/conversions.h\"\n#include \"src/objects/arguments.h\"\n#include \"src/objects/deoptimization-data.h\"\n#include \"src/objects/heap-number-inl.h\"\n#include \"src/objects/heap-object.h\"\n#include \"src/objects/oddball.h\"\n\n// Has to be the last include (doesn't have include guards)\n#include \"src/objects/object-macros.h\"\n#include \"src/objects/string.h\"\n    ]]></code>\n  </imports>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"DeoptimizationFrameTranslationPrintSingleOpcode\",\n        \"parent\": null,\n        \"about\": \"Prints a single deoptimization frame translation opcode to the given output stream.\",\n        \"logic\": \"The function takes a translation opcode and an iterator over the operands, retrieves necessary information from literal arrays based on the opcode, and prints a human-readable description of the opcode and its operands to the output stream. It handles different opcodes by switching on the opcode value and extracting relevant operands accordingly.\",\n        \"parameters\": [\n          {\n            \"name\": \"os\",\n            \"type\": \"std::ostream&\",\n            \"purpose\": \"The output stream to print the opcode description to.\"\n          },\n          {\n            \"name\": \"opcode\",\n            \"type\": \"TranslationOpcode\",\n            \"purpose\": \"The translation opcode to print.\"\n          },\n          {\n            \"name\": \"iterator\",\n            \"type\": \"DeoptimizationFrameTranslation::Iterator&\",\n            \"purpose\": \"An iterator over the operands of the translation opcode.\"\n          },\n          {\n            \"name\": \"protected_literal_array\",\n            \"type\": \"Tagged<ProtectedDeoptimizationLiteralArray>\",\n            \"purpose\": \"A protected literal array used to access literals during deoptimization.\"\n          },\n          {\n            \"name\": \"literal_array\",\n            \"type\": \"Tagged<DeoptimizationLiteralArray>\",\n            \"purpose\": \"A literal array used to access literals during deoptimization.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"This function does not return a value.\"\n        },\n        \"dependencies\": [\n          \"TranslationOpcode\",\n          \"DeoptimizationFrameTranslation::Iterator\",\n          \"ProtectedDeoptimizationLiteralArray\",\n          \"DeoptimizationLiteralArray\",\n          \"disasm::NameConverter\",\n          \"SharedFunctionInfo\",\n          \"Brief\",\n          \"Object\",\n          \"Cast\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid DeoptimizationFrameTranslationPrintSingleOpcode(\n    std::ostream& os, TranslationOpcode opcode,\n    DeoptimizationFrameTranslation::Iterator& iterator,\n    Tagged<ProtectedDeoptimizationLiteralArray> protected_literal_array,\n    Tagged<DeoptimizationLiteralArray> literal_array) {\n  disasm::NameConverter converter;\n  switch (opcode) {\n    case TranslationOpcode::BEGIN_WITH_FEEDBACK:\n    case TranslationOpcode::BEGIN_WITHOUT_FEEDBACK:\n    case TranslationOpcode::MATCH_PREVIOUS_TRANSLATION: {\n      iterator.NextOperand();  // Skip the lookback distance.\n      int frame_count = iterator.NextOperand();\n      int jsframe_count = iterator.NextOperand();\n      os << \"{frame count=\" << frame_count\n         << \", js frame count=\" << jsframe_count << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::INTERPRETED_FRAME_WITH_RETURN:\n    case TranslationOpcode::INTERPRETED_FRAME_WITHOUT_RETURN: {\n      int bytecode_offset = iterator.NextOperand();\n      int shared_info_id = iterator.NextOperand();\n      int bytecode_array_id = iterator.NextOperand();\n      unsigned height = iterator.NextOperand();\n      int return_value_offset = 0;\n      int return_value_count = 0;\n      if (opcode == TranslationOpcode::INTERPRETED_FRAME_WITH_RETURN) {\n        DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 5);\n        return_value_offset = iterator.NextOperand();\n        return_value_count = iterator.NextOperand();\n      } else {\n        DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 3);\n      }\n      Tagged<Object> shared_info = literal_array->get(shared_info_id);\n      Tagged<Object> bytecode_array =\n          protected_literal_array->get(bytecode_array_id);\n      os << \"{bytecode_offset=\" << bytecode_offset << \", function=\"\n         << Cast<SharedFunctionInfo>(shared_info)->DebugNameCStr().get()\n         << \", bytecode=\" << Brief(bytecode_array) << \", height=\" << height\n         << \", retval=@\" << return_value_offset << \"(#\" << return_value_count\n         << \")}\";\n      break;\n    }\n\n#if V8_ENABLE_WEBASSEMBLY\n    case TranslationOpcode::WASM_INLINED_INTO_JS_FRAME: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 3);\n      int bailout_id = iterator.NextOperand();\n      int shared_info_id = iterator.NextOperand();\n      Tagged<Object> shared_info = literal_array->get(shared_info_id);\n      unsigned height = iterator.NextOperand();\n      os << \"{bailout_id=\" << bailout_id << \", function=\"\n         << Cast<SharedFunctionInfo>(shared_info)->DebugNameCStr().get()\n         << \", height=\" << height << \"}\";\n      break;\n    }\n#endif\n    case TranslationOpcode::CONSTRUCT_CREATE_STUB_FRAME: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 2);\n      int shared_info_id = iterator.NextOperand();\n      Tagged<Object> shared_info = literal_array->get(shared_info_id);\n      unsigned height = iterator.NextOperand();\n      os << \"{construct create stub, function=\"\n         << Cast<SharedFunctionInfo>(shared_info)->DebugNameCStr().get()\n         << \", height=\" << height << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::CONSTRUCT_INVOKE_STUB_FRAME: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int shared_info_id = iterator.NextOperand();\n      Tagged<Object> shared_info = literal_array->get(shared_info_id);\n      os << \"{construct invoke stub, function=\"\n         << Cast<SharedFunctionInfo>(shared_info)->DebugNameCStr().get() << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::BUILTIN_CONTINUATION_FRAME:\n    case TranslationOpcode::JAVASCRIPT_BUILTIN_CONTINUATION_FRAME:\n    case TranslationOpcode::JAVASCRIPT_BUILTIN_CONTINUATION_WITH_CATCH_FRAME: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 3);\n      int bailout_id = iterator.NextOperand();\n      int shared_info_id = iterator.NextOperand();\n      Tagged<Object> shared_info = literal_array->get(shared_info_id);\n      unsigned height = iterator.NextOperand();\n      os << \"{bailout_id=\" << bailout_id << \", function=\"\n         << Cast<SharedFunctionInfo>(shared_info)->DebugNameCStr().get()\n         << \", height=\" << height << \"}\";\n      break;\n    }\n\n#if V8_ENABLE_WEBASSEMBLY\n    case TranslationOpcode::JS_TO_WASM_BUILTIN_CONTINUATION_FRAME: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 4);\n      int bailout_id = iterator.NextOperand();\n      int shared_info_id = iterator.NextOperand();\n      Tagged<Object> shared_info = literal_array->get(shared_info_id);\n      unsigned height = iterator.NextOperand();\n      int wasm_return_type = iterator.NextOperand();\n      os << \"{bailout_id=\" << bailout_id << \", function=\"\n         << Cast<SharedFunctionInfo>(shared_info)->DebugNameCStr().get()\n         << \", height=\" << height << \", wasm_return_type=\" << wasm_return_type\n         << \"}\";\n      break;\n    }\n\n    case v8::internal::TranslationOpcode::LIFTOFF_FRAME: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 3);\n      int bailout_id = iterator.NextOperand();\n      unsigned height = iterator.NextOperand();\n      unsigned function_id = iterator.NextOperand();\n      os << \"{bailout_id=\" << bailout_id << \", height=\" << height\n         << \", function_id=\" << function_id << \"}\";\n      break;\n    }\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n    case TranslationOpcode::INLINED_EXTRA_ARGUMENTS: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 2);\n      int shared_info_id = iterator.NextOperand();\n      Tagged<Object> shared_info = literal_array->get(shared_info_id);\n      unsigned height = iterator.NextOperand();\n      os << \"{function=\"\n         << Cast<SharedFunctionInfo>(shared_info)->DebugNameCStr().get()\n         << \", height=\" << height << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << converter.NameOfCPURegister(reg_code) << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::INT32_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << converter.NameOfCPURegister(reg_code) << \" (int32)}\";\n      break;\n    }\n\n    case TranslationOpcode::INT64_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << converter.NameOfCPURegister(reg_code) << \" (int64)}\";\n      break;\n    }\n\n    case TranslationOpcode::SIGNED_BIGINT64_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << converter.NameOfCPURegister(reg_code)\n         << \" (signed bigint64)}\";\n      break;\n    }\n\n    case TranslationOpcode::UNSIGNED_BIGINT64_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << converter.NameOfCPURegister(reg_code)\n         << \" (unsigned bigint64)}\";\n      break;\n    }\n\n    case TranslationOpcode::UINT32_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << converter.NameOfCPURegister(reg_code) << \" (uint32)}\";\n      break;\n    }\n\n    case TranslationOpcode::BOOL_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << converter.NameOfCPURegister(reg_code) << \" (bool)}\";\n      break;\n    }\n\n    case TranslationOpcode::FLOAT_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << FloatRegister::from_code(reg_code) << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::DOUBLE_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << DoubleRegister::from_code(reg_code) << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::HOLEY_DOUBLE_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << DoubleRegister::from_code(reg_code) << \" (holey)}\";\n      break;\n    }\n\n    case TranslationOpcode::SIMD128_REGISTER: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int reg_code = iterator.NextOperandUnsigned();\n      os << \"{input=\" << Simd128Register::from_code(reg_code) << \" (Simd128)}\";\n      break;\n    }\n\n    case TranslationOpcode::TAGGED_STACK_SLOT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int input_slot_index = iterator.NextOperand();\n      os << \"{input=\" << input_slot_index << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::INT32_STACK_SLOT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int input_slot_index = iterator.NextOperand();\n      os << \"{input=\" << input_slot_index << \" (int32)}\";\n      break;\n    }\n\n    case TranslationOpcode::INT64_STACK_SLOT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int input_slot_index = iterator.NextOperand();\n      os << \"{input=\" << input_slot_index << \" (int64)}\";\n      break;\n    }\n\n    case TranslationOpcode::SIGNED_BIGINT64_STACK_SLOT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int input_slot_index = iterator.NextOperand();\n      os << \"{input=\" << input_slot_index << \" (signed bigint64)}\";\n      break;\n    }\n\n    case TranslationOpcode::UNSIGNED_BIGINT64_STACK_SLOT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int input_slot_index = iterator.NextOperand();\n      os << \"{input=\" << input_slot_index << \" (unsigned bigint64)}\";\n      break;\n    }\n\n    case TranslationOpcode::UINT32_STACK_SLOT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int input_slot_index = iterator.NextOperand();\n      os << \"{input=\" << input_slot_index << \" (uint32)}\";\n      break;\n    }\n\n    case TranslationOpcode::BOOL_STACK_SLOT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int input_slot_index = iterator.NextOperand();\n      os << \"{input=\" << input_slot_index << \" (bool)}\";\n      break;\n    }\n\n    case TranslationOpcode::FLOAT_STACK_SLOT:\n    case TranslationOpcode::DOUBLE_STACK_SLOT:\n    case TranslationOpcode::SIMD128_STACK_SLOT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int input_slot_index = iterator.NextOperand();\n      os << \"{input=\" << input_slot_index << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::HOLEY_DOUBLE_STACK_SLOT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int input_slot_index = iterator.NextOperand();\n      os << \"{input=\" << input_slot_index << \" (holey)}\";\n      break;\n    }\n\n    case TranslationOpcode::OPTIMIZED_OUT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 0);\n      os << \"{optimized_out}}\";\n      break;\n    }\n\n    case TranslationOpcode::LITERAL: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int literal_index = iterator.NextOperand();\n      Tagged<Object> literal_value = literal_array->get(literal_index);\n      os << \"{literal_id=\" << literal_index << \" (\" << Brief(literal_value)\n         << \")}\";\n      break;\n    }\n\n    case TranslationOpcode::DUPLICATED_OBJECT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int object_index = iterator.NextOperand();\n      os << \"{object_index=\" << object_index << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::ARGUMENTS_ELEMENTS: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      CreateArgumentsType arguments_type =\n          static_cast<CreateArgumentsType>(iterator.NextOperand());\n      os << \"{arguments_type=\" << arguments_type << \"}\";\n      break;\n    }\n    case TranslationOpcode::ARGUMENTS_LENGTH: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 0);\n      os << \"{arguments_length}\";\n      break;\n    }\n    case TranslationOpcode::REST_LENGTH: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 0);\n      os << \"{rest_length}\";\n      break;\n    }\n\n    case TranslationOpcode::CAPTURED_OBJECT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 1);\n      int args_length = iterator.NextOperand();\n      os << \"{length=\" << args_length << \"}\";\n      break;\n    }\n\n    case TranslationOpcode::STRING_CONCAT: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 0);\n      os << \"{string_concat}\";\n      break;\n    }\n\n    case TranslationOpcode::UPDATE_FEEDBACK: {\n      DCHECK_EQ(TranslationOpcodeOperandCount(opcode), 2);\n      int literal_index = iterator.NextOperand();\n      FeedbackSlot slot(iterator.NextOperand());\n      os << \"{feedback={vector_index=\" << literal_index << \", slot=\" << slot\n         << \"}}\";\n      break;\n    }\n  }\n  os << \"\\n\";\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewDeferredObject\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a deferred object materialization.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kCapturedObject and sets its materialization_info_ to store the object_index and length, deferring the actual materialization until later.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"length\",\n            \"type\": \"int\",\n            \"purpose\": \"The length of the object.\"\n          },\n          {\n            \"name\": \"object_index\",\n            \"type\": \"int\",\n            \"purpose\": \"The index of the object in the object positions array.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewDeferredObject(TranslatedState* container,\n                                                   int length,\n                                                   int object_index) {\n  TranslatedValue slot(container, kCapturedObject);\n  slot.materialization_info_ = {object_index, length};\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewDuplicateObject\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a duplicated object.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kDuplicatedObject and sets its materialization_info_ to store the ID of the original object. The actual materialization is deferred.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"id\",\n            \"type\": \"int\",\n            \"purpose\": \"The ID of the duplicated object.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewDuplicateObject(TranslatedState* container,\n                                                    int id) {\n  TranslatedValue slot(container, kDuplicatedObject);\n  slot.materialization_info_ = {id, -1};\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewStringConcat\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a string concatenation.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kCapturedStringConcat and sets its materialization_info_ to store the ID of the string concatenation. Materialization is deferred.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"id\",\n            \"type\": \"int\",\n            \"purpose\": \"The ID of the string concatenation.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewStringConcat(TranslatedState* container,\n                                                 int id) {\n  TranslatedValue slot(container, kCapturedStringConcat);\n  slot.materialization_info_ = {id, -1};\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewFloat\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a float value.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kFloat and sets its float_value_ to the given value.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"Float32\",\n            \"purpose\": \"The float value to store.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\",\n          \"Float32\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewFloat(TranslatedState* container,\n                                          Float32 value) {\n  TranslatedValue slot(container, kFloat);\n  slot.float_value_ = value;\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewDouble\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a double value.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kDouble and sets its double_value_ to the given value.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"Float64\",\n            \"purpose\": \"The double value to store.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\",\n          \"Float64\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewDouble(TranslatedState* container,\n                                           Float64 value) {\n  TranslatedValue slot(container, kDouble);\n  slot.double_value_ = value;\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewHoleyDouble\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a holey double value.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kHoleyDouble and sets its double_value_ to the given value.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"Float64\",\n            \"purpose\": \"The holey double value to store.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\",\n          \"Float64\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewHoleyDouble(TranslatedState* container,\n                                                Float64 value) {\n  TranslatedValue slot(container, kHoleyDouble);\n  slot.double_value_ = value;\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewSimd128\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a SIMD128 value.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kSimd128 and sets its simd128_value_ to the given value.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"Simd128\",\n            \"purpose\": \"The SIMD128 value to store.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\",\n          \"Simd128\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewSimd128(TranslatedState* container,\n                                            Simd128 value) {\n  TranslatedValue slot(container, kSimd128);\n  slot.simd128_value_ = value;\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewInt32\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a 32-bit integer value.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kInt32 and sets its int32_value_ to the given value.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"int32_t\",\n            \"purpose\": \"The 32-bit integer value to store.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewInt32(TranslatedState* container,\n                                          int32_t value) {\n  TranslatedValue slot(container, kInt32);\n  slot.int32_value_ = value;\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewInt64\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a 64-bit integer value.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kInt64 and sets its int64_value_ to the given value.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"int64_t\",\n            \"purpose\": \"The 64-bit integer value to store.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewInt64(TranslatedState* container,\n                                          int64_t value) {\n  TranslatedValue slot(container, kInt64);\n  slot.int64_value_ = value;\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewInt64ToBigInt\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing a 64-bit integer value to be converted to a BigInt.\",\n        \"logic\": \"This function creates a TranslatedValue of kind kInt64ToBigInt and sets its int64_value_ to the given value.\",\n        \"parameters\": [\n          {\n            \"name\": \"container\",\n            \"type\": \"TranslatedState*\",\n            \"purpose\": \"The TranslatedState to which the value belongs.\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"int64_t\",\n            \"purpose\": \"The 64-bit integer value to store.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"TranslatedValue\",\n          \"description\": \"The newly created TranslatedValue.\"\n        },\n        \"dependencies\": [\n          \"TranslatedValue\",\n          \"TranslatedState\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// static\nTranslatedValue TranslatedValue::NewInt64ToBigInt(TranslatedState* container,\n                                                  int64_t value) {\n  TranslatedValue slot(container, kInt64ToBigInt);\n  slot.int64_value_ = value;\n  return slot;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"NewUint64ToBigInt\",\n        \"parent\": \"TranslatedValue\",\n        \"about\": \"Creates a new TranslatedValue representing an unsigned 64-bit integer value to be converted to a BigInt.\",\n        \"logic\": \"This function creates a TranslatedValue of kind"
}