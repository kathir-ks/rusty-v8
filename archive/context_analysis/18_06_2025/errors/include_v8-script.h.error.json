{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-script.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-script.h\",\n            \"file_name\": \"v8-script.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the V8 API for compiling and running JavaScript scripts and modules.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard C++ headers for memory management, data structures, and type definitions.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <stddef.h>\n            #include <stdint.h>\n\n            #include <memory>\n            #include <tuple>\n            #include <vector>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8-specific headers for callbacks, data types, handles, and configuration.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"v8-callbacks.h\"     // NOLINT(build/include_directory)\n            #include \"v8-data.h\"          // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n            #include \"v8-maybe.h\"         // NOLINT(build/include_directory)\n            #include \"v8-memory-span.h\"   // NOLINT(build/include_directory)\n            #include \"v8-message.h\"       // NOLINT(build/include_directory)\n            #include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ScriptOrModule\",\n                \"about\": \"Container for module loading metadata.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Local<Value>\",\n                    \"Local<Data>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT ScriptOrModule {\n        public:\n            /**\n             * The name that was passed by the embedder as ResourceName to the\n             * ScriptOrigin. This can be either a v8::String or v8::Undefined.\n             */\n            Local<Value> GetResourceName();\n\n            /**\n             * The options that were passed by the embedder as HostDefinedOptions to\n             * the ScriptOrigin.\n             */\n            Local<Data> HostDefinedOptions();\n        };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UnboundScript\",\n                \"extends\": \"Data\",\n                \"about\": \"A compiled JavaScript script, not yet tied to a Context.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Data\",\n                    \"Local<Script>\",\n                    \"Local<Value>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT UnboundScript : public Data {\n        public:\n            /**\n             * Binds the script to the currently entered context.\n             */\n            Local<Script> BindToCurrentContext();\n\n            int GetId() const;\n            Local<Value> GetScriptName();\n\n            /**\n             * Data read from magic sourceURL comments.\n             */\n            Local<Value> GetSourceURL();\n            /**\n             * Data read from magic sourceMappingURL comments.\n             */\n            Local<Value> GetSourceMappingURL();\n\n            /**\n             * Returns zero based line number of the code_pos location in the script.\n             * -1 will be returned if no information available.\n             */\n            int GetLineNumber(int code_pos = 0);\n\n            /**\n             * Returns zero based column number of the code_pos location in the script.\n             * -1 will be returned if no information available.\n             */\n            int GetColumnNumber(int code_pos = 0);\n\n            static const int kNoScriptId = 0;\n        };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UnboundModuleScript\",\n                \"extends\": \"Data\",\n                \"about\": \"A compiled JavaScript module, not yet tied to a Context.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Data\",\n                    \"Local<Value>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT UnboundModuleScript : public Data {\n        public:\n            /**\n             * Data read from magic sourceURL comments.\n             */\n            Local<Value> GetSourceURL();\n            /**\n             * Data read from magic sourceMappingURL comments.\n             */\n            Local<Value> GetSourceMappingURL();\n        };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Location\",\n                \"about\": \"Represents a location in JavaScript source.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"line_number_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Line number in the source code.\"\n                    },\n                    {\n                        \"name\": \"column_number_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Column number in the source code.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT Location {\n        public:\n            int GetLineNumber() { return line_number_; }\n            int GetColumnNumber() { return column_number_; }\n\n            Location(int line_number, int column_number)\n                : line_number_(line_number), column_number_(column_number) {}\n\n        private:\n            int line_number_;\n            int column_number_;\n        };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ModuleRequest\",\n                \"extends\": \"Data\",\n                \"about\": \"Represents a module import request.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Data\",\n                    \"Local<String>\",\n                    \"ModuleImportPhase\",\n                    \"Local<FixedArray>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT ModuleRequest : public Data {\n        public:\n            /**\n             * Returns the module specifier for this ModuleRequest.\n             */\n            Local<String> GetSpecifier() const;\n\n            /**\n             * Returns the module import phase for this ModuleRequest.\n             */\n            ModuleImportPhase GetPhase() const;\n\n            /**\n             * Returns the source code offset of this module request.\n             * Use Module::SourceOffsetToLocation to convert this to line/column numbers.\n             */\n            int GetSourceOffset() const;\n\n            /**\n             * Contains the import attributes for this request in the form:\n             * [key1, value1, source_offset1, key2, value2, source_offset2, ...].\n             * The keys and values are of type v8::String, and the source offsets are of\n             * type Int32. Use Module::SourceOffsetToLocation to convert the source\n             * offsets to Locations with line/column numbers.\n             *\n             * All attributes present in the module request will be supplied in this\n             * list, regardless of whether they are supported by the host. Per\n             * https://tc39.es/proposal-import-attributes/#sec-hostgetsupportedimportattributes,\n             * hosts are expected to throw for attributes that they do not support (as\n             * opposed to, for example, ignoring them).\n             */\n            Local<FixedArray> GetImportAttributes() const;\n\n            V8_DEPRECATED(\"Use GetImportAttributes instead\")\n            Local<FixedArray> GetImportAssertions() const {\n                return GetImportAttributes();\n            }\n\n            V8_INLINE static ModuleRequest* Cast(Data* data);\n\n        private:\n            static void CheckCast(Data* obj);\n        };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Module\",\n                \"extends\": \"Data\",\n                \"about\": \"Represents a compiled JavaScript module.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Data\",\n                    \"Local<Value>\",\n                    \"Local<FixedArray>\",\n                    \"Location\",\n                    \"Local<Context>\",\n                    \"Local<String>\",\n                    \"Module\",\n                    \"Local<UnboundModuleScript>\",\n                    \"MemorySpan\",\n                    \"Isolate\",\n                    \"LocalVector\",\n                    \"Message\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT Module : public Data {\n        public:\n            /**\n             * The different states a module can be in.\n             *\n             * This corresponds to the states used in ECMAScript except that \"evaluated\"\n             * is split into kEvaluated and kErrored, indicating success and failure,\n             * respectively.\n             */\n            enum Status {\n                kUninstantiated,\n                kInstantiating,\n                kInstantiated,\n                kEvaluating,\n                kEvaluated,\n                kErrored\n            };\n\n            /**\n             * Returns the module's current status.\n             */\n            Status GetStatus() const;\n\n            /**\n             * For a module in kErrored status, this returns the corresponding exception.\n             */\n            Local<Value> GetException() const;\n\n            /**\n             * Returns the ModuleRequests for this module.\n             */\n            Local<FixedArray> GetModuleRequests() const;\n\n            /**\n             * For the given source text offset in this module, returns the corresponding\n             * Location with line and column numbers.\n             */\n            Location SourceOffsetToLocation(int offset) const;\n\n            /**\n             * Returns the identity hash for this object.\n             */\n            int GetIdentityHash() const;\n\n            using ResolveModuleCallback = MaybeLocal<Module> (*)(\n                Local<Context> context, Local<String> specifier,\n                Local<FixedArray> import_attributes, Local<Module> referrer);\n            using ResolveSourceCallback = MaybeLocal<Object> (*)(\n                Local<Context> context, Local<String> specifier,\n                Local<FixedArray> import_attributes, Local<Module> referrer);\n\n            /**\n             * Instantiates the module and its dependencies.\n             *\n             * Returns an empty Maybe<bool> if an exception occurred during\n             * instantiation. (In the case where the callback throws an exception, that\n             * exception is propagated.)\n             */\n            V8_WARN_UNUSED_RESULT Maybe<bool> InstantiateModule(\n                Local<Context> context, ResolveModuleCallback module_callback,\n                ResolveSourceCallback source_callback = nullptr);\n\n            /**\n             * Evaluates the module and its dependencies.\n             *\n             * If status is kInstantiated, run the module's code and return a Promise\n             * object. On success, set status to kEvaluated and resolve the Promise with\n             * the completion value; on failure, set status to kErrored and reject the\n             * Promise with the error.\n             *\n             * If IsGraphAsync() is false, the returned Promise is settled.\n             */\n            V8_WARN_UNUSED_RESULT MaybeLocal<Value> Evaluate(Local<Context> context);\n\n            /**\n             * Returns the namespace object of this module.\n             *\n             * The module's status must be at least kInstantiated.\n             */\n            Local<Value> GetModuleNamespace();\n\n            /**\n             * Returns the corresponding context-unbound module script.\n             *\n             * The module must be unevaluated, i.e. its status must not be kEvaluating,\n             * kEvaluated or kErrored.\n             */\n            Local<UnboundModuleScript> GetUnboundModuleScript();\n\n            /**\n             * Returns the underlying script's id.\n             *\n             * The module must be a SourceTextModule and must not have a kErrored status.\n             */\n            int ScriptId() const;\n\n            /**\n             * Returns whether this module or any of its requested modules is async,\n             * i.e. contains top-level await.\n             *\n             * The module's status must be at least kInstantiated.\n             */\n            bool IsGraphAsync() const;\n\n            /**\n             * Returns whether this module is individually asynchronous (for example,\n             * if it's a Source Text Module Record containing a top-level await).\n             * See [[HasTLA]] in https://tc39.es/ecma262/#sec-cyclic-module-records\n             */\n            bool HasTopLevelAwait() const;\n\n            /**\n             * Returns whether the module is a SourceTextModule.\n             */\n            bool IsSourceTextModule() const;\n\n            /**\n             * Returns whether the module is a SyntheticModule.\n             */\n            bool IsSyntheticModule() const;\n\n            /*\n             * Callback defined in the embedder.  This is responsible for setting\n             * the module's exported values with calls to SetSyntheticModuleExport().\n             * The callback must return a resolved Promise to indicate success (where no\n             * exception was thrown) and return an empy MaybeLocal to indicate falure\n             * (where an exception was thrown).\n             */\n            using SyntheticModuleEvaluationSteps =\n                MaybeLocal<Value> (*)(Local<Context> context, Local<Module> module);\n\n            /**\n             * Creates a new SyntheticModule with the specified export names, where\n             * evaluation_steps will be executed upon module evaluation.\n             * export_names must not contain duplicates.\n             * module_name is used solely for logging/debugging and doesn't affect module\n             * behavior.\n             */\n            static Local<Module> CreateSyntheticModule(\n                Isolate* isolate, Local<String> module_name,\n                const MemorySpan<const Local<String>>& export_names,\n                SyntheticModuleEvaluationSteps evaluation_steps);\n\n            /**\n             * Set this module's exported value for the name export_name to the specified\n             * export_value. This method must be called only on Modules created via\n             * CreateSyntheticModule.  An error will be thrown if export_name is not one\n             * of the export_names that were passed in that CreateSyntheticModule call.\n             * Returns Just(true) on success, Nothing<bool>() if an error was thrown.\n             */\n            V8_WARN_UNUSED_RESULT Maybe<bool> SetSyntheticModuleExport(\n                Isolate* isolate, Local<String> export_name, Local<Value> export_value);\n\n            /**\n             * Search the modules requested directly or indirectly by the module for\n             * any top-level await that has not yet resolved. If there is any, the\n             * returned pair of vectors (of equal size) contain the unresolved module\n             * and corresponding message with the pending top-level await.\n             * An embedder may call this before exiting to improve error messages.\n             */\n            std::pair<LocalVector<Module>, LocalVector<Message>>\n            GetStalledTopLevelAwaitMessages(Isolate* isolate);\n\n            V8_INLINE static Module* Cast(Data* data);\n\n        private:\n            static void CheckCast(Data* obj);\n        };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CompileHintsCollector\",\n                \"extends\": \"Data\",\n                \"about\": \"Collects compile hints from script execution.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Data\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT CompileHintsCollector : public Data {\n        public:\n            /**\n             * Returns the positions of lazy functions which were compiled and executed.\n             */\n            std::vector<int> GetCompileHints(Isolate* isolate) const;\n        };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Script\",\n                \"extends\": \"Data\",\n                \"about\": \"Represents a compiled JavaScript script, tied to a context.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Data\",\n                    \"Local<Context>\",\n                    \"Local<String>\",\n                    \"ScriptOrigin\",\n                    \"Local<Value>\",\n                    \"Local<UnboundScript>\",\n                    \"Local<Data>\",\n                    \"CompileHintsCollector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT Script : public Data {\n        public:\n            /**\n             * A shorthand for ScriptCompiler::Compile().\n             */\n            static V8_WARN_UNUSED_RESULT MaybeLocal<Script> Compile(\n                Local<Context> context, Local<String> source,\n                ScriptOrigin* origin = nullptr);\n\n            /**\n             * Runs the script returning the resulting value. It will be run in the\n             * context in which it was created (ScriptCompiler::CompileBound or\n             * UnboundScript::BindToCurrentContext()).\n             */\n            V8_WARN_UNUSED_RESULT MaybeLocal<Value> Run(Local<Context> context);\n            V8_WARN_UNUSED_RESULT MaybeLocal<Value> Run(Local<Context> context,\n                                                        Local<Data> host_defined_options);\n\n            /**\n             * Returns the corresponding context-unbound script.\n             */\n            Local<UnboundScript> GetUnboundScript();\n\n            /**\n             * The name that was passed by the embedder as ResourceName to the\n             * ScriptOrigin. This can be either a v8::String or v8::Undefined.\n             */\n            Local<Value> GetResourceName();\n\n            /**\n             * If the script was compiled, returns the positions of lazy functions which\n             * were eventually compiled and executed.\n             */\n            V8_DEPRECATE_SOON(\"Use GetCompileHintsCollector instead\")\n            std::vector<int> GetProducedCompileHints() const;\n\n            /**\n             * Get a compile hints collector object which we can use later for retrieving\n             * compile hints (= positions of lazy functions which were compiled and\n             * executed).\n             */\n            Local<CompileHintsCollector> GetCompileHintsCollector() const;\n        };\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"ScriptType\",\n                \"about\": \"Enum for script types: classic or module.\",\n                \"values\": [\n                    \"kClassic\",\n                    \"kModule\"\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n        enum class ScriptType { kClassic, kModule };\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ScriptCompiler\",\n                \"about\": \"Provides methods for compiling JavaScript source code.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"CachedData\",\n                    \"Source\",\n                    \"Local<UnboundScript>\",\n                    \"Local<Context>\",\n                    \"ScriptData\",\n                    \"Local<Script>\",\n                    \"StreamedSource\",\n                    \"Isolate\",\n                    \"Local<String>\",\n                    \"ScriptOrigin\",\n                    \"ScriptStreamingTask\",\n                    \"ScriptType\",\n                    \"Local<Module>\",\n                    \"Local<Function>\",\n                    \"ScriptOrModule\",\n                    \"Local<Object>\",\n                    \"ConsumeCodeCacheTask\",\n                    \"std::unique_ptr\",\n                    \"internal::BackgroundDeserializeTask\",\n                    \"Local<UnboundModuleScript>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT ScriptCompiler {\n        public:\n            class ConsumeCodeCacheTask;\n\n            /**\n             * Compilation data that the embedder can cache and pass back to speed up\n             * future compilations. The data is produced if the CompilerOptions passed to\n             * the compilation functions in ScriptCompiler contains produce_data_to_cache\n             * = true. The data to cache can then can be retrieved from\n             * UnboundScript.\n             */\n            struct V8_EXPORT CachedData {\n                enum BufferPolicy { BufferNotOwned, BufferOwned };\n\n                CachedData()\n                    : data(nullptr),\n                      length(0),\n                      rejected(false),\n                      buffer_policy(BufferNotOwned) {}\n\n                // If buffer_policy is BufferNotOwned, the caller keeps the ownership of\n                // data and guarantees that it stays alive until the CachedData object is\n                // destroyed. If the policy is BufferOwned, the given data will be deleted\n                // (with delete[]) when the CachedData object is destroyed.\n                CachedData(const uint8_t* data, int length,\n                           BufferPolicy buffer_policy = BufferNotOwned);\n                ~CachedData();\n\n                enum CompatibilityCheckResult {\n                  // Don't change order/existing values of this enum since it keys into the\n                  // `code_cache_reject_reason` histogram. Append-only!\n                  kSuccess = 0,\n                  kMagicNumberMismatch = 1,\n                  kVersionMismatch = 2,\n                  kSourceMismatch = 3,\n                  kFlagsMismatch = 5,\n                  kChecksumMismatch = 6,\n                  kInvalidHeader = 7,\n                  kLengthMismatch = 8,\n                  kReadOnlySnapshotChecksumMismatch = 9,\n\n                  // This should always point at the last real enum value.\n                  kLast = kReadOnlySnapshotChecksumMismatch\n                };\n\n                // Check if the CachedData can be loaded in the given isolate.\n                CompatibilityCheckResult CompatibilityCheck(Isolate* isolate);\n\n                // TODO(marja): Async compilation; add constructors which take a callback\n                // which will be called when V8 no longer needs the data.\n                const uint8_t* data;\n                int length;\n                bool rejected;\n                BufferPolicy buffer_policy;\n\n                // Prevent copying.\n                CachedData(const CachedData&) = delete;\n                CachedData& operator=(const CachedData&) = delete;\n            };\n\n            enum class InMemoryCacheResult {\n              // V8 did not attempt to find this script in its in-memory cache.\n              kNotAttempted,\n\n              // V8 found a previously compiled copy of this script in its in-memory\n              // cache. Any data generated by a streaming compilation or background\n              // deserialization was abandoned.\n              kHit,\n\n              // V8 didn't have any previously compiled data for this script.\n              kMiss,\n\n              // V8 had some previously compiled data for an identical script, but the\n              // data was incomplete.\n              kPartial,\n            };\n\n            // Details about what happened during a compilation.\n            struct CompilationDetails {\n                InMemoryCacheResult in_memory_cache_result =\n                    InMemoryCacheResult::kNotAttempted;\n\n                static constexpr int64_t kTimeNotMeasured = -1;\n                int64_t foreground_time_in_microseconds = kTimeNotMeasured;\n                int64_t background_time_in_microseconds = kTimeNotMeasured;\n            };\n\n            /**\n             * Source code which can be then compiled to a UnboundScript or Script.\n             */\n            class Source {\n             public:\n                // Source takes ownership of both CachedData and CodeCacheConsumeTask.\n                // The caller *must* ensure that the cached data is from a trusted source.\n                V8_INLINE Source(Local<String> source_string, const ScriptOrigin& origin,\n                                 CachedData* cached_data = nullptr,\n                                 ConsumeCodeCacheTask* consume_cache_task = nullptr);\n                // Source takes ownership of both CachedData and CodeCacheConsumeTask.\n                V8_INLINE explicit Source(\n                    Local<String> source_string, CachedData* cached_data = nullptr,\n                    ConsumeCodeCacheTask* consume_cache_task = nullptr);\n                V8_INLINE Source(Local<String> source_string, const ScriptOrigin& origin,\n                                 CompileHintCallback callback, void* callback_data);\n                V8_INLINE ~Source() = default;\n\n                // Ownership of the CachedData or its buffers is *not* transferred to the\n                // caller. The CachedData object is alive as long as the Source object is\n                // alive.\n                V8_INLINE const CachedData* GetCachedData() const;\n\n                V8_INLINE const ScriptOriginOptions& GetResourceOptions() const;\n\n                V8_INLINE const CompilationDetails& GetCompilationDetails() const;\n\n             private:\n                friend class ScriptCompiler;\n\n                Local<String> source_string;\n\n                // Origin information\n                Local<Value> resource_name;\n                int resource_line_offset = -1;\n                int resource_column_offset = -1;\n                ScriptOriginOptions resource_options;\n                Local<Value> source_map_url;\n                Local<Data> host_defined_options;\n\n                // Cached data from previous compilation (if a kConsume*Cache flag is\n                // set), or hold newly generated cache data (kProduce*Cache flags) are\n                // set when calling a compile method.\n                std::unique_ptr<CachedData> cached_data;\n                std::unique_ptr<ConsumeCodeCacheTask> consume_cache_task;\n\n                // For requesting compile hints from the embedder.\n                CompileHintCallback compile_hint_callback = nullptr;\n                void* compile_hint_callback_data = nullptr;\n\n                // V8 writes this data and never reads it. It exists only to be informative\n                // to the embedder.\n                CompilationDetails compilation_details;\n            };\n\n            /**\n             * For streaming incomplete script data to V8. The embedder should implement a\n             * subclass of this class.\n             */\n            class V8_EXPORT ExternalSourceStream {\n             public:\n                virtual ~ExternalSourceStream() = default;\n\n                /**\n                 * V8 calls this to request the next chunk of data from the embedder. This\n                 * function will be called on a background thread, so it's OK to block and\n                 * wait for the data, if the embedder doesn't have data yet. Returns the\n                 * length of the data returned. When the data ends, GetMoreData should\n                 * return 0. Caller takes ownership of the data.\n                 *\n                 * When streaming UTF-8 data, V8 handles multi-byte characters split between\n                 * two data chunks, but doesn't handle multi-byte characters split between\n                 * more than two data chunks. The embedder can avoid this problem by always\n                 * returning at least 2 bytes of data.\n                 *\n                 * When streaming UTF-16 data, V8 does not handle characters split between\n                 * two data chunks. The embedder has to make sure that chunks have an even\n                 * length.\n                 *\n                 * If the embedder wants to cancel the streaming, they should make the next\n                 * GetMoreData call return 0. V8 will interpret it as end of data (and most\n                 * probably, parsing will fail). The streaming task will return as soon as\n                 * V8 has parsed the data it received so far.\n                 */\n                virtual size_t GetMoreData(const uint8_t** src) = 0;\n            };\n\n            /**\n             * Source code which can be streamed into V8 in pieces. It will be parsed\n             * while streaming and compiled after parsing has completed. StreamedSource\n             * must be kept alive while the streaming task is run (see ScriptStreamingTask\n             * below).\n             */\n            class V8_EXPORT StreamedSource {\n             public:\n                enum Encoding { ONE_BYTE, TWO_BYTE, UTF8, WINDOWS_1252 };\n\n                StreamedSource(std::unique_ptr<ExternalSourceStream> source_stream,\n                               Encoding encoding);\n                ~StreamedSource();\n\n                internal::ScriptStreamingData* impl() const { return impl_.get(); }\n\n                // Prevent copying.\n                StreamedSource(const StreamedSource&) = delete;\n                StreamedSource& operator=(const StreamedSource&) = delete;\n\n                CompilationDetails& compilation_details() { return compilation_details_; }\n\n             private:\n                std::unique_ptr<internal::ScriptStreamingData> impl_;\n\n                // V8 writes this data and never reads it. It exists only to be informative\n                // to the embedder.\n                CompilationDetails compilation_details_;\n            };\n\n            /**\n             * A streaming task which the embedder must run on a background thread to\n             * stream scripts into V8. Returned by ScriptCompiler::StartStreaming.\n             */\n            class V8_EXPORT ScriptStreamingTask final {\n             public:\n                void Run();\n\n             private:\n                friend class ScriptCompiler;\n\n                explicit ScriptStreamingTask(internal::ScriptStreamingData* data)\n                    : data_(data) {}\n\n                internal::ScriptStreamingData* data_;\n            };\n\n            /**\n             * A task which the embedder must run on a background thread to\n             * consume a V8 code cache. Returned by\n             * ScriptCompiler::StartConsumingCodeCache.\n             */\n            class V8_EXPORT ConsumeCodeCacheTask final {\n             public:\n                ~ConsumeCodeCacheTask();\n\n                void Run();\n\n                /**\n                 * Provides the source text string and origin information to the consumption\n                 * task. May be called before, during, or after Run(). This step checks\n                 * whether the script matches an existing script in the Isolate's\n                 * compilation cache. To check whether such a script was found, call\n                 * ShouldMergeWithExistingScript.\n                 *\n                 * The Isolate provided must be the same one used during\n                 * StartConsumingCodeCache and must be currently entered on the thread that\n                 * calls this function. The source text and origin provided in this step\n                 * must precisely match those used later in the ScriptCompiler::Source that\n                 * will contain this ConsumeCodeCacheTask.\n                 */\n                void SourceTextAvailable(Isolate* isolate, Local<String> source_text,\n                                         const ScriptOrigin& origin);\n\n                /**\n                 * Returns whether the embedder should call MergeWithExistingScript. This\n                 * function may be called from any thread, any number of times, but its\n                 * return value is only meaningful after SourceTextAvailable has completed.\n                 */\n                bool ShouldMergeWithExistingScript() const;\n\n                /**\n                 * Merges newly deserialized data into an existing script which was found\n                 * during SourceTextAvailable. May be called only after Run() has completed.\n                 * Can execute on any thread, like Run().\n                 */\n                void MergeWithExistingScript();\n\n             private:\n                friend class ScriptCompiler;\n\n                explicit ConsumeCodeCacheTask(\n                    std::unique_ptr<internal::BackgroundDeserializeTask> impl);\n\n                std::unique_ptr<internal::BackgroundDeserializeTask> impl_;\n            };\n\n            enum CompileOptions {\n                kNoCompileOptions = 0,\n                kConsumeCodeCache = 1 << 0,\n                kEagerCompile = 1 << 1,\n                kProduceCompileHints = 1 << 2,\n                kConsumeCompileHints = 1 << 3,\n                kFollowCompileHintsMagicComment = 1 << 4,\n                kFollowCompileHintsPerFunctionMagicComment = 1 << 5,\n            };\n\n            static inline bool CompileOptionsIsValid(CompileOptions compile_options) {\n                // kConsumeCodeCache is mutually exclusive with all other flag bits.\n                if ((compile_options & kConsumeCodeCache) &&\n                    compile_options != kConsumeCodeCache) {\n                  return false;\n                }\n                // kEagerCompile is mutually exclusive with all other flag bits.\n                if ((compile_options & kEagerCompile) && compile_options != kEagerCompile) {\n                  return false;\n                }\n                // We don't currently support producing and consuming compile hints at the\n                // same time.\n                constexpr int produce_and_consume = CompileOptions::kProduceCompileHints |\n                                                    CompileOptions::kConsumeCompileHints;\n                if ((compile_options & produce_and_consume) == produce_and_consume) {\n                  return false;\n                }\n                return true;\n            }\n\n            /**\n             * The reason for which we are not requesting or providing a code cache.\n             */\n            enum NoCacheReason {\n                kNoCacheNoReason = 0,\n                kNoCacheBecauseCachingDisabled,\n                kNoCacheBecauseNoResource,\n                kNoCacheBecauseInlineScript,\n                kNoCacheBecauseModule,\n                kNoCacheBecauseStreamingSource,\n                kNoCacheBecauseInspector,\n                kNoCacheBecauseScriptTooSmall,\n                kNoCacheBecauseCacheTooCold,\n                kNoCacheBecauseV8Extension,\n                kNoCacheBecauseExtensionModule,\n                kNoCacheBecausePacScript,\n                kNoCacheBecauseInDocumentWrite,\n                kNoCacheBecauseResourceWithNoCacheHandler,\n                kNoCacheBecauseDeferredProduceCodeCache,\n                kNoCacheBecauseStaticCodeCache,\n            };\n\n            /**\n             * Compiles the specified script (context-independent).\n             * Cached data as part of the source object can be optionally produced to be\n             * consumed later to speed up compilation of identical source scripts.\n             *\n             * Note that when producing cached data, the source must point to NULL for\n             * cached data. When consuming cached data, the cached data must have been\n             * produced by the same version of V8, and the embedder needs to ensure the\n             * cached data is the correct one for the given script.\n             *\n             * \\param source Script source code.\n             * \\return Compiled script object (context independent; for running it must be\n             *   bound to a context).\n             */\n            static V8_WARN_UNUSED_RESULT MaybeLocal<UnboundScript> CompileUnboundScript(\n                Isolate* isolate, Source* source,\n                CompileOptions options = kNoCompileOptions,\n                NoCacheReason no_cache_reason = kNoCacheNoReason);\n\n            /**\n             * Compiles the specified script (bound to current context).\n             *\n             * \\param source Script source code.\n             * \\param pre_data Pre-parsing data, as obtained by ScriptData::PreCompile()\n             *   using pre_data speeds compilation if it's done multiple times.\n             *   Owned by caller, no references are kept when this function returns.\n             * \\return Compiled script object, bound to the context that was active\n             *   when this function was called. When run it will always use this\n             *   context.\n             */\n            static V8_WARN_UNUSED_RESULT MaybeLocal<Script> Compile(\n                Local<Context> context, Source* source,\n                CompileOptions options = kNoCompileOptions,\n                NoCacheReason no_cache_reason = kNoCacheNoReason);\n\n            /**\n             *"
}