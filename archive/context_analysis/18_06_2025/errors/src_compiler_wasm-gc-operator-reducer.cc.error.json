{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-gc-operator-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-gc-operator-reducer.cc\",\n        \"file_name\": \"wasm-gc-operator-reducer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"This file implements the WasmGCOperatorReducer class, which performs optimization and reduction of WebAssembly Garbage Collection (GC) related operators in the V8 compiler's intermediate representation (IR).\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for compiler, node properties, simplified operators, wasm compilation definitions, and wasm subtyping.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/wasm-gc-operator-reducer.h\"\n\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/wasm-compiler-definitions.h\"\n#include \"src/wasm/wasm-subtyping.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmGCOperatorReducer\",\n            \"extends\": \"AdvancedReducerWithControlPathState\",\n            \"about\": \"This class performs optimization and reduction of WebAssembly GC related operators.\",\n            \"attributes\": [\n                {\n                    \"name\": \"mcgraph_\",\n                    \"type\": \"MachineGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the machine graph.\"\n                },\n                {\n                    \"name\": \"gasm_\",\n                    \"type\": \"GraphAndSimplified\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Helper class for graph manipulation and simplified operator creation.\"\n                },\n                {\n                    \"name\": \"module_\",\n                    \"type\": \"const wasm::WasmModule*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the WebAssembly module.\"\n                },\n                {\n                    \"name\": \"source_position_table_\",\n                    \"type\": \"SourcePositionTable*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the source position table for debugging information.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Editor\",\n                \"Zone\",\n                \"MachineGraph\",\n                \"wasm::WasmModule\",\n                \"SourcePositionTable\",\n                \"AdvancedReducerWithControlPathState\",\n                \"GraphAndSimplified\",\n                \"ControlPathTypes\",\n                \"NodeWithType\",\n                \"OpParameter\",\n                \"WasmFieldInfo\",\n                \"WasmTypeCheckConfig\",\n                \"Type\",\n                \"wasm::ValueType\",\n                \"wasm::TypeInModule\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass WasmGCOperatorReducer : public AdvancedReducerWithControlPathState {\n public:\n  WasmGCOperatorReducer(\n      Editor* editor, Zone* temp_zone_, MachineGraph* mcgraph,\n      const wasm::WasmModule* module, SourcePositionTable* source_position_table);\n\n  Reduction Reduce(Node* node) override;\n\n private:\n  MachineGraph* mcgraph_;\n  GraphAndSimplified gasm_;\n  const wasm::WasmModule* module_;\n  SourcePositionTable* source_position_table_;\n\n  Reduction ReduceStart(Node* node);\n  Reduction ReduceWasmStructOperation(Node* node);\n  Reduction ReduceWasmArrayLength(Node* node);\n  Reduction ReduceAssertNotNull(Node* node);\n  Reduction ReduceCheckNull(Node* node);\n  Reduction ReduceWasmTypeCheck(Node* node);\n  Reduction ReduceWasmTypeCheckAbstract(Node* node);\n  Reduction ReduceWasmTypeCast(Node* node);\n  Reduction ReduceWasmTypeCastAbstract(Node* node);\n  Reduction ReduceTypeGuard(Node* node);\n  Reduction ReduceWasmAnyConvertExtern(Node* node);\n  Reduction ReduceMerge(Node* node);\n  Reduction ReduceIf(Node* node, bool condition);\n\n  Node* SetType(Node* node, wasm::ValueType type);\n  Reduction UpdateNodeAndAliasesTypes(Node* state_owner,\n                                        ControlPathTypes parent_state, Node* node,\n                                        wasm::TypeInModule type, bool in_new_block);\n  wasm::TypeInModule ObjectTypeFromContext(Node* object, Node* control,\n                                              bool allow_non_wasm = false);\n  void UpdateSourcePosition(Node* new_node, Node* old_node);\n};\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WasmGCOperatorReducer\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Constructor for the WasmGCOperatorReducer class.\",\n            \"parameters\": [\n                {\n                    \"name\": \"editor\",\n                    \"type\": \"Editor*\",\n                    \"purpose\": \"The editor used for graph modifications.\"\n                },\n                {\n                    \"name\": \"temp_zone_\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"A temporary zone for allocations.\"\n                },\n                {\n                    \"name\": \"mcgraph\",\n                    \"type\": \"MachineGraph*\",\n                    \"purpose\": \"The machine graph being reduced.\"\n                },\n                {\n                    \"name\": \"module\",\n                    \"type\": \"const wasm::WasmModule*\",\n                    \"purpose\": \"The WebAssembly module being compiled.\"\n                },\n                {\n                    \"name\": \"source_position_table\",\n                    \"type\": \"SourcePositionTable*\",\n                    \"purpose\": \"The source position table for debugging information.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"AdvancedReducerWithControlPathState\",\n                \"GraphAndSimplified\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nWasmGCOperatorReducer::WasmGCOperatorReducer(\n    Editor* editor, Zone* temp_zone_, MachineGraph* mcgraph,\n    const wasm::WasmModule* module, SourcePositionTable* source_position_table)\n    : AdvancedReducerWithControlPathState(editor, temp_zone_, mcgraph->graph()),\n      mcgraph_(mcgraph),\n      gasm_(mcgraph, mcgraph->zone()),\n      module_(module),\n      source_position_table_(source_position_table) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces a given node based on its opcode.\",\n            \"logic\": \"This function contains a switch statement that handles different opcodes. It dispatches to specific reduction functions for each opcode. If the opcode has control outputs it takes states from the first control input, and does nothing otherwise.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"ReduceStart\",\n                \"ReduceWasmStructOperation\",\n                \"ReduceWasmArrayLength\",\n                \"ReduceAssertNotNull\",\n                \"ReduceCheckNull\",\n                \"ReduceWasmTypeCheck\",\n                \"ReduceWasmTypeCheckAbstract\",\n                \"ReduceWasmTypeCast\",\n                \"ReduceWasmTypeCastAbstract\",\n                \"ReduceTypeGuard\",\n                \"ReduceWasmAnyConvertExtern\",\n                \"ReduceMerge\",\n                \"ReduceIf\",\n                \"TakeStatesFromFirstControl\",\n                \"NoChange\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kStart:\n      return ReduceStart(node);\n    case IrOpcode::kWasmStructGet:\n    case IrOpcode::kWasmStructSet:\n      return ReduceWasmStructOperation(node);\n    case IrOpcode::kWasmArrayLength:\n      return ReduceWasmArrayLength(node);\n    case IrOpcode::kAssertNotNull:\n      return ReduceAssertNotNull(node);\n    case IrOpcode::kIsNull:\n    case IrOpcode::kIsNotNull:\n      return ReduceCheckNull(node);\n    case IrOpcode::kWasmTypeCheck:\n      return ReduceWasmTypeCheck(node);\n    case IrOpcode::kWasmTypeCheckAbstract:\n      return ReduceWasmTypeCheckAbstract(node);\n    case IrOpcode::kWasmTypeCast:\n      return ReduceWasmTypeCast(node);\n    case IrOpcode::kWasmTypeCastAbstract:\n      return ReduceWasmTypeCastAbstract(node);\n    case IrOpcode::kTypeGuard:\n      return ReduceTypeGuard(node);\n    case IrOpcode::kWasmAnyConvertExtern:\n      return ReduceWasmAnyConvertExtern(node);\n    case IrOpcode::kMerge:\n      return ReduceMerge(node);\n    case IrOpcode::kIfTrue:\n      return ReduceIf(node, true);\n    case IrOpcode::kIfFalse:\n      return ReduceIf(node, false);\n    case IrOpcode::kDead:\n      return NoChange();\n    case IrOpcode::kLoop:\n      return TakeStatesFromFirstControl(node);\n    default:\n      if (node->op()->ControlOutputCount() > 0) {\n        DCHECK_EQ(1, node->op()->ControlInputCount());\n        return TakeStatesFromFirstControl(node);\n      } else {\n        return NoChange();\n      }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceStart\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces a start node by updating the states.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The start node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"UpdateStates\",\n                \"ControlPathTypes\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::ReduceStart(Node* node) {\n  return UpdateStates(node, ControlPathTypes(zone()));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ObjectTypeFromContext\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Retrieves the object type from the current context.\",\n            \"logic\": \"This function retrieves the object type from the current context by looking up the type information associated with the object in the current control path state. It also handles TypeGuard aliases.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The object node.\"\n                },\n                {\n                    \"name\": \"control\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The control node representing the current control path.\"\n                },\n                {\n                    \"name\": \"allow_non_wasm\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"If true, non-wasm types are allowed\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"wasm::TypeInModule\",\n                \"description\": \"The object type from the context.\"\n            },\n            \"dependencies\": [\n                \"IsReduced\",\n                \"NodeProperties::IsTyped\",\n                \"NodeProperties::GetType\",\n                \"Type::IsWasm\",\n                \"Type::AsWasm\",\n                \"GetState\",\n                \"ControlPathTypes::LookupState\",\n                \"NodeProperties::GetValueInput\",\n                \"wasm::Intersection\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nwasm::TypeInModule WasmGCOperatorReducer::ObjectTypeFromContext(\n    Node* object, Node* control, bool allow_non_wasm) {\n  if (object->opcode() == IrOpcode::kDead ||\n      object->opcode() == IrOpcode::kDeadValue) {\n    return {};\n  }\n  if (!IsReduced(control)) return {};\n  if (allow_non_wasm && !NodeProperties::IsTyped(object)) return {};\n  Type raw_type = NodeProperties::GetType(object);\n  if (allow_non_wasm && !raw_type.IsWasm()) return {};\n  wasm::TypeInModule type_from_node = raw_type.AsWasm();\n  ControlPathTypes state = GetState(control);\n  NodeWithType type_from_state = state.LookupState(object);\n  // We manually resolve TypeGuard aliases in the state.\n  while (object->opcode() == IrOpcode::kTypeGuard && !type_from_state.IsSet()) {\n    object = NodeProperties::GetValueInput(object, 0);\n    type_from_state = state.LookupState(object);\n  }\n  if (!type_from_state.IsSet()) return type_from_node;\n  return wasm::Intersection(type_from_node, type_from_state.type);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceWasmStructOperation\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces Wasm struct get and set operations.\",\n            \"logic\": \"If the object is known to be non-nullable in the context, the null check is removed. It also updates the types of nodes and aliases.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The struct get or set node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"IsReduced\",\n                \"NodeProperties::GetControlInput\",\n                \"NodeProperties::GetValueInput\",\n                \"ObjectTypeFromContext\",\n                \"OpParameter\",\n                \"WasmFieldInfo\",\n                \"simplified::WasmStructGet\",\n                \"simplified::WasmStructSet\",\n                \"NodeProperties::ChangeOp\",\n                \"UpdateNodeAndAliasesTypes\",\n                \"GetState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::ReduceWasmStructOperation(Node* node) {\n  DCHECK(node->opcode() == IrOpcode::kWasmStructGet ||\n         node->opcode() == IrOpcode::kWasmStructSet);\n  Node* control = NodeProperties::GetControlInput(node);\n  if (!IsReduced(control)) return NoChange();\n  Node* object = NodeProperties::GetValueInput(node, 0);\n\n  wasm::TypeInModule object_type = ObjectTypeFromContext(object, control);\n  if (object_type.type.is_uninhabited()) return NoChange();\n\n  if (object_type.type.is_non_nullable()) {\n    // If the object is known to be non-nullable in the context, remove the null\n    // check.\n    auto op_params = OpParameter<WasmFieldInfo>(node->op());\n    const Operator* new_op =\n        node->opcode() == IrOpcode::kWasmStructGet\n            ? simplified()->WasmStructGet(op_params.type, op_params.field_index,\n                                          op_params.is_signed,\n                                          kWithoutNullCheck)\n            : simplified()->WasmStructSet(op_params.type, op_params.field_index,\n                                          kWithoutNullCheck);\n    NodeProperties::ChangeOp(node, new_op);\n  }\n\n  object_type.type = object_type.type.AsNonNull();\n\n  return UpdateNodeAndAliasesTypes(node, GetState(control), object, object_type,\n                                   false);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceWasmArrayLength\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces Wasm array length operations.\",\n            \"logic\": \"If the object is known to be non-nullable in the context, the null check is removed. It also updates the types of nodes and aliases.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The array length node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"IsReduced\",\n                \"NodeProperties::GetControlInput\",\n                \"NodeProperties::GetValueInput\",\n                \"ObjectTypeFromContext\",\n                \"simplified::WasmArrayLength\",\n                \"NodeProperties::ChangeOp\",\n                \"UpdateNodeAndAliasesTypes\",\n                \"GetState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::ReduceWasmArrayLength(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kWasmArrayLength);\n  Node* control = NodeProperties::GetControlInput(node);\n  if (!IsReduced(control)) return NoChange();\n  Node* object = NodeProperties::GetValueInput(node, 0);\n\n  wasm::TypeInModule object_type = ObjectTypeFromContext(object, control);\n  if (object_type.type.is_uninhabited()) return NoChange();\n\n  if (object_type.type.is_non_nullable()) {\n    // If the object is known to be non-nullable in the context, remove the null\n    // check.\n    const Operator* new_op = simplified()->WasmArrayLength(kWithoutNullCheck);\n    NodeProperties::ChangeOp(node, new_op);\n  }\n\n  object_type.type = object_type.type.AsNonNull();\n\n  return UpdateNodeAndAliasesTypes(node, GetState(control), object, object_type,\n                                   false);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceIf\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces IfTrue and IfFalse nodes.\",\n            \"logic\": \"Adds type information to the path state if the branch condition is a type check or null check.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The IfTrue or IfFalse node.\"\n                },\n                {\n                    \"name\": \"condition\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"True if it's IfTrue, false if it's IfFalse.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"IsReduced\",\n                \"NodeProperties::GetControlInput\",\n                \"GetState\",\n                \"NodeProperties::GetValueInput\",\n                \"ObjectTypeFromContext\",\n                \"OpParameter\",\n                \"WasmTypeCheckConfig\",\n                \"wasm::Intersection\",\n                \"UpdateNodeAndAliasesTypes\",\n                \"wasm::ToNullSentinel\",\n                \"TakeStatesFromFirstControl\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::ReduceIf(Node* node, bool condition) {\n  DCHECK(node->opcode() == IrOpcode::kIfTrue ||\n         node->opcode() == IrOpcode::kIfFalse);\n  Node* branch = NodeProperties::GetControlInput(node);\n  if (branch->opcode() == IrOpcode::kDead) return NoChange();\n  DCHECK_EQ(branch->opcode(), IrOpcode::kBranch);\n  if (!IsReduced(branch)) return NoChange();\n  ControlPathTypes parent_state = GetState(branch);\n  Node* condition_node = NodeProperties::GetValueInput(branch, 0);\n  switch (condition_node->opcode()) {\n    case IrOpcode::kWasmTypeCheck:\n    case IrOpcode::kWasmTypeCheckAbstract: {\n      if (!condition) break;\n      Node* object = NodeProperties::GetValueInput(condition_node, 0);\n      wasm::TypeInModule object_type = ObjectTypeFromContext(object, branch);\n      if (object_type.type.is_uninhabited()) return NoChange();\n\n      wasm::ValueType to_type =\n          OpParameter<WasmTypeCheckConfig>(condition_node->op()).to;\n\n      // TODO(12166): Think about {module_} below if we have cross-module\n      // inlining.\n      wasm::TypeInModule new_type =\n          wasm::Intersection(object_type, {to_type, module_});\n      return UpdateNodeAndAliasesTypes(node, parent_state, object, new_type,\n                                       true);\n    }\n    case IrOpcode::kIsNull:\n    case IrOpcode::kIsNotNull: {\n      Node* object = NodeProperties::GetValueInput(condition_node, 0);\n      Node* control = NodeProperties::GetControlInput(condition_node);\n      wasm::TypeInModule object_type = ObjectTypeFromContext(object, control);\n      if (object_type.type.is_uninhabited()) return NoChange();\n      // If the checked value is null, narrow the type to the corresponding\n      // null type, otherwise to a non-null reference.\n      bool is_null =\n          condition == (condition_node->opcode() == IrOpcode::kIsNull);\n      object_type.type = is_null ? wasm::ToNullSentinel(object_type)\n                                 : object_type.type.AsNonNull();\n      return UpdateNodeAndAliasesTypes(node, parent_state, object, object_type,\n                                       true);\n    }\n    default:\n      break;\n  }\n  return TakeStatesFromFirstControl(node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceMerge\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces a merge node.\",\n            \"logic\": \"Computes the common ancestor of control path types from different inputs to the merge node. This allows for propagating type information across control flow merges.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The merge node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"IsReduced\",\n                \"GetState\",\n                \"ControlPathTypes::ResetToCommonAncestor\",\n                \"UpdateStates\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::ReduceMerge(Node* node) {\n  // Shortcut for the case when we do not know anything about some\n  // input.\n  Node::Inputs inputs = node->inputs();\n  for (Node* input : inputs) {\n    if (!IsReduced(input)) return NoChange();\n  }\n\n  auto input_it = inputs.begin();\n\n  DCHECK_GT(inputs.count(), 0);\n\n  ControlPathTypes types = GetState(*input_it);\n  ++input_it;\n\n  auto input_end = inputs.end();\n  for (; input_it != input_end; ++input_it) {\n    // Change the current type block list to a longest common prefix of this\n    // state list and the other list. (The common prefix should correspond to\n    // the state of the common dominator.)\n    // TODO(manoskouk): Consider computing unions for some types.\n    types.ResetToCommonAncestor(GetState(*input_it));\n  }\n  return UpdateStates(node, types);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceAssertNotNull\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces an AssertNotNull node.\",\n            \"logic\": \"If the argument is known to be non-null, the check is optimized away, and a TypeGuard node is used.  If not known to be non-null, the type is updated to be non-nullable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The AssertNotNull node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties::GetValueInput\",\n                \"NodeProperties::GetControlInput\",\n                \"ObjectTypeFromContext\",\n                \"ReplaceWithValue\",\n                \"common::TypeGuard\",\n                \"NodeProperties::ChangeOp\",\n                \"Changed\",\n                \"UpdateNodeAndAliasesTypes\",\n                \"GetState\",\n                \"NodeProperties::GetType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::ReduceAssertNotNull(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kAssertNotNull);\n  Node* object = NodeProperties::GetValueInput(node, 0);\n  Node* control = NodeProperties::GetControlInput(node);\n\n  wasm::TypeInModule object_type = ObjectTypeFromContext(object, control);\n  if (object_type.type.is_uninhabited()) return NoChange();\n\n  // Optimize the check away if the argument is known to be non-null.\n  if (object_type.type.is_non_nullable()) {\n    // First, relax control.\n    ReplaceWithValue(node, node, node, control);\n    // Use a TypeGuard node to not lose any type information.\n    NodeProperties::ChangeOp(\n        node, common()->TypeGuard(NodeProperties::GetType(node)));\n    return Changed(node);\n  }\n\n  object_type.type = object_type.type.AsNonNull();\n  return UpdateNodeAndAliasesTypes(node, GetState(control), node, object_type,\n                                   false);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceCheckNull\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces an IsNull or IsNotNull node.\",\n            \"logic\": \"If the argument is known to be non-null or null, the check is optimized away.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The IsNull or IsNotNull node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties::GetValueInput\",\n                \"NodeProperties::GetControlInput\",\n                \"ObjectTypeFromContext\",\n                \"ReplaceWithValue\",\n                \"SetType\",\n                \"gasm_.Int32Constant\",\n                \"wasm::kWasmI32\",\n                \"node->Kill\",\n                \"Replace\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::ReduceCheckNull(Node* node) {\n  DCHECK(node->opcode() == IrOpcode::kIsNull ||\n         node->opcode() == IrOpcode::kIsNotNull);\n  Node* object = NodeProperties::GetValueInput(node, 0);\n  Node* control = NodeProperties::GetControlInput(node);\n\n  wasm::TypeInModule object_type = ObjectTypeFromContext(object, control);\n  if (object_type.type.is_uninhabited()) return NoChange();\n\n  // Optimize the check away if the argument is known to be non-null.\n  if (object_type.type.is_non_nullable()) {\n    ReplaceWithValue(node,\n                     SetType(gasm_.Int32Constant(\n                                 node->opcode() == IrOpcode::kIsNull ? 0 : 1),\n                             wasm::kWasmI32));\n    node->Kill();\n    return Replace(object);  // Irrelevant replacement.\n  }\n\n  // Optimize the check away if the argument is known to be null.\n  if (object->opcode() == IrOpcode::kNull) {\n    ReplaceWithValue(node,\n                     SetType(gasm_.Int32Constant(\n                                 node->opcode() == IrOpcode::kIsNull ? 1 : 0),\n                             wasm::kWasmI32));\n    node->Kill();\n    return Replace(object);  // Irrelevant replacement.\n  }\n\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceWasmAnyConvertExtern\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces a WasmAnyConvertExtern node.\",\n            \"logic\": \"Removes redundant any.convert_extern(extern.convert_any(...)) pattern.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The WasmAnyConvertExtern node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties::GetValueInput\",\n                \"ReplaceWithValue\",\n                \"node->Kill\",\n                \"Replace\",\n                \"TakeStatesFromFirstControl\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::ReduceWasmAnyConvertExtern(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kWasmAnyConvertExtern);\n  // Remove redundant any.convert_extern(extern.convert_any(...)) pattern.\n  Node* input = NodeProperties::GetValueInput(node, 0);\n  while (input->opcode() == IrOpcode::kTypeGuard) {\n    input = NodeProperties::GetValueInput(input, 0);\n  }\n  if (input->opcode() == IrOpcode::kDead ||\n      input->opcode() == IrOpcode::kDeadValue) {\n    return NoChange();\n  }\n  if (input->opcode() == IrOpcode::kWasmExternConvertAny) {\n    // \"Skip\" the extern.convert_any which doesn't have an effect on the value.\n    input = NodeProperties::GetValueInput(input, 0);\n    ReplaceWithValue(node, input);\n    node->Kill();\n    return Replace(input);\n  }\n  return TakeStatesFromFirstControl(node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceTypeGuard\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces a TypeGuard node.\",\n            \"logic\": \"Intersects the object type with the guarded type, updating the node's type information.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The TypeGuard node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties::GetControlInput\",\n                \"NodeProperties::GetValueInput\",\n                \"ObjectTypeFromContext\",\n                \"TypeGuardTypeOf\",\n                \"UpdateNodeAndAliasesTypes\",\n                \"GetState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction WasmGCOperatorReducer::ReduceTypeGuard(Node* node) {\n  DCHECK_EQ(node->opcode(), IrOpcode::kTypeGuard);\n  Node* control = NodeProperties::GetControlInput(node);\n  Node* object = NodeProperties::GetValueInput(node, 0);\n\n  // Since TypeGuards can be generated for JavaScript, and this phase is run\n  // for wasm-into-JS inlining, we cannot assume the object has a wasm type.\n  wasm::TypeInModule object_type =\n      ObjectTypeFromContext(object, control, /* allow_non_wasm = */ true);\n  if (object_type.type.is_uninhabited()) return NoChange();\n  Type guarded_type = TypeGuardTypeOf(node->op());\n  if (!guarded_type.IsWasm()) return NoChange();\n\n  wasm::TypeInModule new_type =\n      wasm::Intersection(object_type, guarded_type.AsWasm());\n\n  return UpdateNodeAndAliasesTypes(node, GetState(control), node, new_type,\n                                   false);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceWasmTypeCast\",\n            \"parent\": \"WasmGCOperatorReducer\",\n            \"about\": \"Reduces a W"
}