{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-gc-typed-optimization-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 42, column 39",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-gc-typed-optimization-reducer.h\",\n            \"file_name\": \"wasm-gc-typed-optimization-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the WasmGCTypedOptimizationReducer and WasmGCTypeAnalyzer classes, which infer type information for WebAssembly garbage collection (GC) and reduce type checks and casts based on that information.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for compiler, turboshaft, wasm graph assembler and wasm subtyping functionalities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/snapshot-table-opindex.h\"\n#include \"src/compiler/wasm-graph-assembler.h\"\n#include \"src/wasm/wasm-subtyping.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmGCTypeAnalyzer\",\n                \"about\": \"Infers the types of operations in a WebAssembly GC graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"data_\",\n                        \"type\": \"PipelineData*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the pipeline data.\"\n                    },\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"Graph&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to the Turboshaft graph.\"\n                    },\n                    {\n                        \"name\": \"phase_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for this phase.\"\n                    },\n                    {\n                        \"name\": \"module_\",\n                        \"type\": \"const wasm::WasmModule*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the WebAssembly module.\"\n                    },\n                    {\n                        \"name\": \"signature_\",\n                        \"type\": \"const wasm::FunctionSig*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Signature of the WebAssembly function.\"\n                    },\n                    {\n                        \"name\": \"types_table_\",\n                        \"type\": \"TypeSnapshotTable\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores type snapshots for each block in the CFG.\"\n                    },\n                    {\n                        \"name\": \"block_to_snapshot_\",\n                        \"type\": \"FixedBlockSidetable<MaybeSnapshot>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps block IDs to snapshots.\"\n                    },\n                    {\n                        \"name\": \"block_is_unreachable_\",\n                        \"type\": \"BitVector\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracks reachability of blocks.\"\n                    },\n                    {\n                        \"name\": \"current_block_\",\n                        \"type\": \"const Block*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the currently processed block.\"\n                    },\n                    {\n                        \"name\": \"input_type_map_\",\n                        \"type\": \"ZoneUnorderedMap<OpIndex, wasm::ValueType>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps operations to their inferred input types.\"\n                    },\n                    {\n                        \"name\": \"is_first_loop_header_evaluation_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Marker whether it is the first time visiting a loop header.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"PipelineData\",\n                    \"Graph\",\n                    \"Zone\",\n                    \"wasm::WasmModule\",\n                    \"wasm::FunctionSig\",\n                    \"TypeSnapshotTable\",\n                    \"FixedBlockSidetable\",\n                    \"MaybeSnapshot\",\n                    \"BitVector\",\n                    \"Block\",\n                    \"ZoneUnorderedMap\",\n                    \"OpIndex\",\n                    \"wasm::ValueType\",\n                    \"Block\",\n                    \"BranchOp\",\n                    \"WasmTypeCastOp\",\n                    \"WasmTypeCheckOp\",\n                    \"AssertNotNullOp\",\n                    \"NullOp\",\n                    \"IsNullOp\",\n                    \"ParameterOp\",\n                    \"StructGetOp\",\n                    \"StructSetOp\",\n                    \"ArrayGetOp\",\n                    \"ArrayLengthOp\",\n                    \"GlobalGetOp\",\n                    \"WasmRefFuncOp\",\n                    \"WasmAllocateArrayOp\",\n                    \"WasmAllocateStructOp\",\n                    \"PhiOp\",\n                    \"WasmTypeAnnotationOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass WasmGCTypeAnalyzer {\n public:\n  WasmGCTypeAnalyzer(PipelineData* data, Graph& graph, Zone* zone)\n      : data_(data), graph_(graph), phase_zone_(zone) {\n    // If we ever want to run this analyzer for Wasm wrappers, we'll need\n    // to make it handle their {CanonicalSig} signatures.\n    DCHECK_NOT_NULL(signature_);\n  }\n\n  void Run();\n\n  // Returns the input type for the operation or bottom if the operation shall\n  // always trap.\n  wasm::ValueType GetInputTypeOrSentinelType(OpIndex op) const {\n    auto iter = input_type_map_.find(op);\n    DCHECK_NE(iter, input_type_map_.end());\n    return iter->second;\n  }\n\n private:\n  using TypeSnapshotTable = SparseOpIndexSnapshotTable<wasm::ValueType>;\n  using Snapshot = TypeSnapshotTable::Snapshot;\n  using MaybeSnapshot = TypeSnapshotTable::MaybeSnapshot;\n\n  void StartNewSnapshotFor(const Block& block);\n  void ProcessOperations(const Block& block);\n  void ProcessBlock(const Block& block);\n  void ProcessBranchOnTarget(const BranchOp& branch, const Block& target);\n\n  void ProcessTypeCast(const WasmTypeCastOp& type_cast);\n  void ProcessTypeCheck(const WasmTypeCheckOp& type_check);\n  void ProcessAssertNotNull(const AssertNotNullOp& type_cast);\n  void ProcessNull(const NullOp& null);\n  void ProcessIsNull(const IsNullOp& is_null);\n  void ProcessParameter(const ParameterOp& parameter);\n  void ProcessStructGet(const StructGetOp& struct_get);\n  void ProcessStructSet(const StructSetOp& struct_set);\n  void ProcessArrayGet(const ArrayGetOp& array_get);\n  void ProcessArrayLength(const ArrayLengthOp& array_length);\n  void ProcessGlobalGet(const GlobalGetOp& global_get);\n  void ProcessRefFunc(const WasmRefFuncOp& ref_func);\n  void ProcessAllocateArray(const WasmAllocateArrayOp& allocate_array);\n  void ProcessAllocateStruct(const WasmAllocateStructOp& allocate_struct);\n  void ProcessPhi(const PhiOp& phi);\n  void ProcessTypeAnnotation(const WasmTypeAnnotationOp& type_annotation);\n\n  wasm::ValueType GetTypeForPhiInput(const PhiOp& phi, int input_index);\n\n  void CreateMergeSnapshot(const Block& block);\n  bool CreateMergeSnapshot(base::Vector<const Snapshot> predecessors,\n                           base::Vector<const bool> reachable);\n\n  // Updates the knowledge in the side table about the type of {object},\n  // returning the previous known type. Returns bottom if the refined type is\n  // uninhabited. In this case the operation shall always trap.\n  wasm::ValueType RefineTypeKnowledge(OpIndex object, wasm::ValueType new_type,\n                                      const Operation& op);\n  // Updates the knowledge in the side table to be a non-nullable type for\n  // {object}, returning the previous known type. Returns bottom if the refined\n  // type is uninhabited. In this case the operation shall always trap.\n  wasm::ValueType RefineTypeKnowledgeNotNull(OpIndex object,\n                                             const Operation& op);\n\n  OpIndex ResolveAliases(OpIndex object) const;\n  wasm::ValueType GetResolvedType(OpIndex object) const;\n\n  // Returns the reachability status of a block. For any predecessor, this marks\n  // whether the *end* of the block is reachable, for the current block it marks\n  // whether the current instruction is reachable. (For successors the\n  // reachability is unknown.)\n  bool IsReachable(const Block& block) const;\n\n  PipelineData* data_;\n  Graph& graph_;\n  Zone* phase_zone_;\n  const wasm::WasmModule* module_ = data_->wasm_module();\n  const wasm::FunctionSig* signature_ = data_->wasm_module_sig();\n  // Contains the snapshots for all blocks in the CFG.\n  TypeSnapshotTable types_table_{phase_zone_};\n  // Maps the block id to a snapshot in the table defining the type knowledge\n  // at the end of the block.\n  FixedBlockSidetable<MaybeSnapshot> block_to_snapshot_{graph_.block_count(),\n                                                        phase_zone_};\n\n  // Tracks reachability of blocks throughout the analysis. Marking a block as\n  // unreachable means that the block in question is unreachable from the\n  // current \"point of view\" of the analysis, e.g. marking the current block as\n  // \"unreachable\" means that from \"now on\" all succeeding statements can treat\n  // it as unreachable, not that the beginning of the block was unreachable.\n  BitVector block_is_unreachable_{static_cast<int>(graph_.block_count()),\n                                  phase_zone_};\n\n  const Block* current_block_ = nullptr;\n  // For any operation that could potentially refined, this map stores an entry\n  // to the inferred input type based on the analysis.\n  ZoneUnorderedMap<OpIndex, wasm::ValueType> input_type_map_{phase_zone_};\n  // Marker wheteher it is the first time visiting a loop header. In that case,\n  // loop phis can only use type information based on the forward edge of the\n  // loop. The value is false outside of loop headers.\n  bool is_first_loop_header_evaluation_ = false;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmGCTypedOptimizationReducer\",\n                \"extends\": \"Next\",\n                \"about\": \"Reduces type checks and casts in a WebAssembly GC graph based on type information inferred by WasmGCTypeAnalyzer.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"Graph&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to the Turboshaft graph.\"\n                    },\n                    {\n                        \"name\": \"module_\",\n                        \"type\": \"const wasm::WasmModule*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the WebAssembly module.\"\n                    },\n                    {\n                        \"name\": \"analyzer_\",\n                        \"type\": \"WasmGCTypeAnalyzer\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Instance of the WasmGCTypeAnalyzer class.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Next\",\n                    \"Graph\",\n                    \"wasm::WasmModule\",\n                    \"WasmGCTypeAnalyzer\",\n                    \"wasm::ValueType\",\n                    \"WasmTypeCastOp\",\n                    \"WasmTypeCheckOp\",\n                    \"AssertNotNullOp\",\n                    \"IsNullOp\",\n                    \"WasmTypeAnnotationOp\",\n                    \"StructGetOp\",\n                    \"StructSetOp\",\n                    \"ArrayLengthOp\",\n                    \"ExternConvertAnyOp\",\n                    \"TrapId\",\n                    \"WasmTypeCheckConfig\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass WasmGCTypedOptimizationReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(WasmGCTypedOptimization)\n\n  void Analyze() {\n    analyzer_.Run();\n    Next::Analyze();\n  }\n\n  V<Object> REDUCE_INPUT_GRAPH(WasmTypeCast)(V<Object> op_idx,\n                                             const WasmTypeCastOp& cast_op) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphWasmTypeCast(op_idx, cast_op);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    wasm::ValueType type = analyzer_.GetInputTypeOrSentinelType(op_idx);\n    if (type.is_uninhabited()) {\n      // We are either already in unreachable code (then this instruction isn't\n      // even emitted) or the type analyzer inferred that this instruction will\n      // always trap. In either case emitting an unconditional trap to increase\n      // the chances of logic errors just leading to wrong behaviors but not\n      // resulting in security issues.\n      __ TrapIf(1, TrapId::kTrapIllegalCast);\n      __ Unreachable();\n      return OpIndex::Invalid();\n    }\n    if (type != wasm::ValueType()) {\n      CHECK(!type.is_uninhabited());\n      CHECK(wasm::IsSameTypeHierarchy(type.heap_type(),\n                                      cast_op.config.to.heap_type(), module_));\n      bool to_nullable = cast_op.config.to.is_nullable();\n      if (wasm::IsHeapSubtypeOf(type.heap_type(), cast_op.config.to.heap_type(),\n                                module_, module_)) {\n        if (to_nullable || type.is_non_nullable()) {\n          // The inferred type is already as specific as the cast target, the\n          // cast is guaranteed to always succeed and can therefore be removed.\n          return __ MapToNewGraph(cast_op.object());\n        } else {\n          // The inferred heap type is already as specific as the cast target,\n          // but the source can be nullable and the target cannot be, so a null\n          // check is still required.\n          return __ AssertNotNull(__ MapToNewGraph(cast_op.object()), type,\n                                  TrapId::kTrapIllegalCast);\n        }\n      }\n      if (wasm::HeapTypesUnrelated(type.heap_type(),\n                                   cast_op.config.to.heap_type(), module_,\n                                   module_)) {\n        // A cast between unrelated types can only succeed if the argument is\n        // null. Otherwise, it always fails.\n        V<Word32> non_trapping_condition =\n            type.is_nullable() && to_nullable ? __ IsNull(__ MapToNewGraph(\n                                                              cast_op.object()),\n                                                          type)\n                                              : __ Word32Constant(0);\n        __ TrapIfNot(non_trapping_condition, TrapId::kTrapIllegalCast);\n        if (!to_nullable) {\n          __ Unreachable();\n        }\n        return __ MapToNewGraph(cast_op.object());\n      }\n\n      // If the cast resulted in an uninhabitable type, the analyzer should have\n      // returned a sentinel (bottom) type as {type}.\n      CHECK(!wasm::Intersection(type, cast_op.config.to, module_, module_)\n                 .type.is_uninhabited());\n\n      // The cast cannot be replaced. Still, we can refine the source type, so\n      // that the lowering could potentially skip null or smi checks.\n      wasm::ValueType from_type =\n          wasm::Intersection(type, cast_op.config.from, module_, module_).type;\n      DCHECK(!from_type.is_uninhabited());\n      WasmTypeCheckConfig config{from_type, cast_op.config.to};\n      return __ WasmTypeCast(__ MapToNewGraph(cast_op.object()),\n                             __ MapToNewGraph(cast_op.rtt()), config);\n    }\n    goto no_change;\n  }\n\n  V<Word32> REDUCE_INPUT_GRAPH(WasmTypeCheck)(\n      V<Word32> op_idx, const WasmTypeCheckOp& type_check) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphWasmTypeCheck(op_idx, type_check);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    wasm::ValueType type = analyzer_.GetInputTypeOrSentinelType(op_idx);\n    if (type.is_uninhabited()) {\n      __ Unreachable();\n      return OpIndex::Invalid();\n    }\n    if (type != wasm::ValueType()) {\n      CHECK(!type.is_uninhabited());\n      CHECK(wasm::IsSameTypeHierarchy(\n          type.heap_type(), type_check.config.to.heap_type(), module_));\n      bool to_nullable = type_check.config.to.is_nullable();\n      if (wasm::IsHeapSubtypeOf(type.heap_type(),\n                                type_check.config.to.heap_type(), module_,\n                                module_)) {\n        if (to_nullable || type.is_non_nullable()) {\n          // The inferred type is guaranteed to be a subtype of the checked\n          // type.\n          return __ Word32Constant(1);\n        } else {\n          // The inferred type is guaranteed to be a subtype of the checked\n          // type if it is not null.\n          return __ Word32Equal(\n              __ IsNull(__ MapToNewGraph(type_check.object()), type), 0);\n        }\n      }\n      if (wasm::HeapTypesUnrelated(type.heap_type(),\n                                   type_check.config.to.heap_type(), module_,\n                                   module_)) {\n        if (to_nullable && type.is_nullable()) {\n          return __ IsNull(__ MapToNewGraph(type_check.object()), type);\n        } else {\n          return __ Word32Constant(0);\n        }\n      }\n\n      // If there isn't a type that matches our known input type and the\n      // type_check.config.to type, the type check always fails.\n      wasm::ValueType true_type =\n          wasm::Intersection(type, type_check.config.to, module_, module_).type;\n      if (true_type.is_uninhabited()) {\n        return __ Word32Constant(0);\n      }\n\n      // The check cannot be replaced. Still, we can refine the source type, so\n      // that the lowering could potentially skip null or smi checks.\n      wasm::ValueType from_type =\n          wasm::Intersection(type, type_check.config.from, module_, module_)\n              .type;\n      DCHECK(!from_type.is_uninhabited());\n      WasmTypeCheckConfig config{from_type, type_check.config.to};\n      return __ WasmTypeCheck(__ MapToNewGraph(type_check.object()),\n                              __ MapToNewGraph(type_check.rtt()), config);\n    }\n    goto no_change;\n  }\n\n  V<Object> REDUCE_INPUT_GRAPH(AssertNotNull)(\n      V<Object> op_idx, const AssertNotNullOp& assert_not_null) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphAssertNotNull(op_idx, assert_not_null);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    wasm::ValueType type = analyzer_.GetInputTypeOrSentinelType(op_idx);\n    if (type.is_uninhabited()) {\n      // We are either already in unreachable code (then this instruction isn't\n      // even emitted) or the type analyzer inferred that this instruction will\n      // always trap. In either case emitting an unconditional trap to increase\n      // the chances of logic errors just leading to wrong behaviors but not\n      // resulting in security issues.\n      __ TrapIf(1, assert_not_null.trap_id);\n      __ Unreachable();\n      return OpIndex::Invalid();\n    }\n    if (type.is_non_nullable()) {\n      return __ MapToNewGraph(assert_not_null.object());\n    }\n    goto no_change;\n  }\n\n  V<Word32> REDUCE_INPUT_GRAPH(IsNull)(V<Word32> op_idx,\n                                       const IsNullOp& is_null) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphIsNull(op_idx, is_null);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    const wasm::ValueType type = analyzer_.GetInputTypeOrSentinelType(op_idx);\n    if (type.is_uninhabited()) {\n      __ Unreachable();\n      return OpIndex::Invalid();\n    }\n    if (type.is_non_nullable()) {\n      return __ Word32Constant(0);\n    }\n    if (type != wasm::ValueType() &&\n        wasm::ToNullSentinel({type, module_}) == type) {\n      return __ Word32Constant(1);\n    }\n    goto no_change;\n  }\n\n  V<Object> REDUCE_INPUT_GRAPH(WasmTypeAnnotation)(\n      V<Object> op_idx, const WasmTypeAnnotationOp& type_annotation) {\n    // Remove type annotation operations as they are not needed any more.\n    return __ MapToNewGraph(type_annotation.value());\n  }\n\n  V<Any> REDUCE_INPUT_GRAPH(StructGet)(V<Any> op_idx,\n                                       const StructGetOp& struct_get) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphStructGet(op_idx, struct_get);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    const wasm::ValueType type = analyzer_.GetInputTypeOrSentinelType(op_idx);\n    if (type.is_uninhabited()) {\n      // We are either already in unreachable code (then this instruction isn't\n      // even emitted) or the type analyzer inferred that this instruction will\n      // always trap. In either case emitting an unconditional trap to increase\n      // the chances of logic errors just leading to wrong behaviors but not\n      // resulting in security issues.\n      __ TrapIf(1, TrapId::kTrapNullDereference);\n      __ Unreachable();\n      return OpIndex::Invalid();\n    }\n    // Remove the null check if it is known to be not null.\n    if (struct_get.null_check == kWithNullCheck && type.is_non_nullable()) {\n      return __ StructGet(__ MapToNewGraph(struct_get.object()),\n                          struct_get.type, struct_get.type_index,\n                          struct_get.field_index, struct_get.is_signed,\n                          kWithoutNullCheck);\n    }\n    goto no_change;\n  }\n\n  V<None> REDUCE_INPUT_GRAPH(StructSet)(V<None> op_idx,\n                                        const StructSetOp& struct_set) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphStructSet(op_idx, struct_set);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    const wasm::ValueType type = analyzer_.GetInputTypeOrSentinelType(op_idx);\n    if (type.is_uninhabited()) {\n      // We are either already in unreachable code (then this instruction isn't\n      // even emitted) or the type analyzer inferred that this instruction will\n      // always trap. In either case emitting an unconditional trap to increase\n      // the chances of logic errors just leading to wrong behaviors but not\n      // resulting in security issues.\n      __ TrapIf(1, TrapId::kTrapNullDereference);\n      __ Unreachable();\n      return OpIndex::Invalid();\n    }\n    // Remove the null check if it is known to be not null.\n    if (struct_set.null_check == kWithNullCheck && type.is_non_nullable()) {\n      __ StructSet(__ MapToNewGraph(struct_set.object()),\n                   __ MapToNewGraph(struct_set.value()), struct_set.type,\n                   struct_set.type_index, struct_set.field_index,\n                   kWithoutNullCheck);\n      return OpIndex::Invalid();\n    }\n    goto no_change;\n  }\n\n  V<Word32> REDUCE_INPUT_GRAPH(ArrayLength)(V<Word32> op_idx,\n                                            const ArrayLengthOp& array_length) {\n    LABEL_BLOCK(no_change) {\n      return Next::ReduceInputGraphArrayLength(op_idx, array_length);\n    }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    const wasm::ValueType type = analyzer_.GetInputTypeOrSentinelType(op_idx);\n    // Remove the null check if it is known to be not null.\n    if (array_length.null_check == kWithNullCheck && type.is_non_nullable()) {\n      return __ ArrayLength(__ MapToNewGraph(array_length.array()),\n                            kWithoutNullCheck);\n    }\n    goto no_change;\n  }\n\n  // TODO(14108): This isn't a type optimization and doesn't fit well into this\n  // reducer.\n  V<Object> REDUCE(AnyConvertExtern)(V<Object> object) {\n    LABEL_BLOCK(no_change) { return Next::ReduceAnyConvertExtern(object); }\n    if (ShouldSkipOptimizationStep()) goto no_change;\n\n    if (object.valid()) {\n      const ExternConvertAnyOp* externalize =\n          __ output_graph().Get(object).template TryCast<ExternConvertAnyOp>();\n      if (externalize != nullptr) {\n        // Directly return the object as\n        // any.convert_extern(extern.convert_any(x)) == x.\n        return externalize->object();\n      }\n    }\n    goto no_change;\n  }\n\n private:\n  Graph& graph_ = __ modifiable_input_graph();\n  const wasm::WasmModule* module_ = __ data() -> wasm_module();\n  WasmGCTypeAnalyzer analyzer_{__ data(), graph_, __ phase_zone()};\n};\n        ]]></code>\n    </class>\n</file>\n```"
}