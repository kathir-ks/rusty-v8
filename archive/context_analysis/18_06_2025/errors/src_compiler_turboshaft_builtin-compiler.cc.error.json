{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/builtin-compiler.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 72, column 52",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/builtin-compiler.cc\",\n        \"file_name\": \"builtin-compiler.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Turboshaft compiler for builtins.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for builtin compilation, code generation, and compiler pipeline.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/builtin-compiler.h\"\n\n#include \"src/builtins/profile-data-reader.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/compiler/pipeline.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/pipelines.h\"\n#include \"src/compiler/turboshaft/zone-with-name.h\"\n#include \"src/compiler/zone-stats.h\"\n#include \"src/execution/isolate.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneWithName\",\n            \"about\": \"A zone with a specific name, used for memory management in V8.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            //Forward declaration for ZoneWithName\n            template <const char* kName>\n            class ZoneWithName;\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"BuildWithTurboshaftAssemblerImpl\",\n            \"about\": \"Builds a builtin using the Turboshaft assembler.\",\n            \"logic\": \"This function takes a TurboshaftAssemblerGenerator, a call descriptor builder, and other parameters to generate code for a builtin. It initializes the compiler pipeline, generates the code using the provided generator, and returns a handle to the generated code.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"builtin\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin to compile.\"\n                },\n                {\n                    \"name\": \"generator\",\n                    \"type\": \"TurboshaftAssemblerGenerator\",\n                    \"purpose\": \"A function that generates the code using the Turboshaft assembler.\"\n                },\n                {\n                    \"name\": \"call_descriptor_builder\",\n                    \"type\": \"std::function<compiler::CallDescriptor*(Zone*)>\",\n                    \"purpose\": \"A function that builds the call descriptor.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the builtin.\"\n                },\n                {\n                    \"name\": \"options\",\n                    \"type\": \"const AssemblerOptions&\",\n                    \"purpose\": \"Assembler options.\"\n                },\n                {\n                    \"name\": \"code_kind\",\n                    \"type\": \"CodeKind\",\n                    \"purpose\": \"The kind of code being generated.\"\n                },\n                {\n                    \"name\": \"bytecode_handler_data\",\n                    \"type\": \"std::optional<BytecodeHandlerData>\",\n                    \"purpose\": \"Optional bytecode handler data.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DirectHandle<Code>\",\n                \"description\": \"A direct handle to the generated code.\"\n            },\n            \"dependencies\": [\n                \"compiler::ZoneStats\",\n                \"ZoneWithName\",\n                \"OptimizedCompilationInfo\",\n                \"compiler::CallDescriptor\",\n                \"PipelineData\",\n                \"compiler::Pipeline\",\n                \"ProfileDataFromFile\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nDirectHandle<Code> BuildWithTurboshaftAssemblerImpl(\n    Isolate* isolate, Builtin builtin, TurboshaftAssemblerGenerator generator,\n    std::function<compiler::CallDescriptor*(Zone*)> call_descriptor_builder,\n    const char* name, const AssemblerOptions& options, CodeKind code_kind,\n    std::optional<BytecodeHandlerData> bytecode_handler_data) {\n  using namespace compiler::turboshaft;  // NOLINT(build/namespaces)\n  DCHECK_EQ(code_kind == CodeKind::BYTECODE_HANDLER,\n            bytecode_handler_data.has_value());\n\n  compiler::ZoneStats zone_stats(isolate->allocator());\n  ZoneWithName<kBuiltinCompilationZoneName> zone(&zone_stats,\n                                                 kBuiltinCompilationZoneName);\n  OptimizedCompilationInfo info(base::CStrVector(name), zone, code_kind,\n                                builtin);\n  compiler::CallDescriptor* call_descriptor = call_descriptor_builder(zone);\n\n  PipelineData data(&zone_stats, TurboshaftPipelineKind::kTSABuiltin, isolate,\n                    &info, options);\n  data.InitializeBuiltinComponent(call_descriptor,\n                                  std::move(bytecode_handler_data));\n  data.InitializeGraphComponent(nullptr);\n  ZoneWithName<kTempZoneName> temp_zone(&zone_stats, kTempZoneName);\n  generator(&data, isolate, data.graph(), temp_zone);\n\n  DirectHandle<Code> code =\n      compiler::Pipeline::GenerateCodeForTurboshaftBuiltin(\n          &data, call_descriptor, builtin, name,\n          ProfileDataFromFile::TryRead(name))\n          .ToHandleChecked();\n  return code;\n}\n        ]]></code>\n    </func>\n</file>\n```"
}