{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/simulator.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 319, column 100",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/simulator.h\",\n        \"file_name\": \"simulator.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the SimulatorStack class and GeneratedCode template class for simulating code execution on different architectures when a simulator is used. Also handles cases when running without a simulator on a native platform.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard V8 headers for global definitions and object manipulation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n            #include \"src/objects/code.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes headers for native platform support, isolate management, and utility functions, only when not using a simulator.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #if !defined(USE_SIMULATOR)\n            #include \"src/base/platform/platform.h\"\n            #include \"src/execution/isolate.h\"\n            #include \"src/utils/utils.h\"\n            #endif\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes simulator headers specific to different architectures when a simulator is used and the target architecture is one of ARM64, ARM, PPC64, MIPS64, LOONG64, S390X, or RISCV.  Otherwise, an error is raised.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64\n            // No simulator for ia32 or x64.\n            #elif V8_TARGET_ARCH_ARM64\n            #include \"src/execution/arm64/simulator-arm64.h\"\n            #elif V8_TARGET_ARCH_ARM\n            #include \"src/execution/arm/simulator-arm.h\"\n            #elif V8_TARGET_ARCH_PPC64\n            #include \"src/execution/ppc/simulator-ppc.h\"\n            #elif V8_TARGET_ARCH_MIPS64\n            #include \"src/execution/mips64/simulator-mips64.h\"\n            #elif V8_TARGET_ARCH_LOONG64\n            #include \"src/execution/loong64/simulator-loong64.h\"\n            #elif V8_TARGET_ARCH_S390X\n            #include \"src/execution/s390/simulator-s390.h\"\n            #elif V8_TARGET_ARCH_RISCV32 || V8_TARGET_ARCH_RISCV64\n            #include \"src/execution/riscv/simulator-riscv.h\"\n            #else\n            #error Unsupported target architecture.\n            #endif\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include header for StackVisitor class.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace heap::base {\n            class StackVisitor;\n            }\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimulatorStack\",\n            \"extends\": \"v8::internal::AllStatic\",\n            \"about\": \"Provides an abstraction for stack limit management when running with or without a simulator.  When using the simulator, it translates C stack limits to JS stack limits and provides stack views for WebAssembly.  When not using the simulator, it directly uses the C stack limit.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"v8::internal::Isolate\",\n                \"Simulator\",\n                \"base::Vector\",\n                \"heap::base::StackVisitor\",\n                \"base::Stack\",\n                \"wasm::StackMemory\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #if defined(USE_SIMULATOR)\n            // Running with a simulator.\n\n            // The simulator has its own stack. Thus it has a different stack limit from\n            // the C-based native code.  The JS-based limit normally points near the end of\n            // the simulator stack.  When the C-based limit is exhausted we reflect that by\n            // lowering the JS-based limit as well, to make stack checks trigger.\n            class SimulatorStack : public v8::internal::AllStatic {\n            public:\n            static inline uintptr_t JsLimitFromCLimit(v8::internal::Isolate* isolate,\n                                                        uintptr_t c_limit) {\n                return Simulator::current(isolate)->StackLimit(c_limit);\n            }\n\n            #if V8_ENABLE_WEBASSEMBLY\n            static inline base::Vector<uint8_t> GetCentralStackView(\n                v8::internal::Isolate* isolate) {\n                return Simulator::current(isolate)->GetCentralStackView();\n            }\n            #endif\n\n            // Iterates the simulator registers and stack for conservative stack scanning.\n            static void IterateRegistersAndStack(Isolate* isolate,\n                                                ::heap::base::StackVisitor* visitor) {\n                DCHECK_NOT_NULL(isolate);\n                Simulator::current(isolate)->IterateRegistersAndStack(visitor);\n            }\n\n            // When running on the simulator, we should leave the C stack limits alone\n            // when switching stacks for Wasm.\n            static inline bool ShouldSwitchCStackForWasmStackSwitching() { return false; }\n\n            // Returns the current stack address on the simulator stack frame.\n            // The returned address is comparable with JS stack address.\n            static inline uintptr_t RegisterJSStackComparableAddress(\n                v8::internal::Isolate* isolate) {\n                // The value of |kPlaceHolder| is actually not used.  It just occupies a\n                // single word on the stack frame of the simulator.\n                const uintptr_t kPlaceHolder = 0x4A535350u;  // \"JSSP\" in ASCII\n                return Simulator::current(isolate)->PushAddress(kPlaceHolder);\n            }\n\n            static inline void UnregisterJSStackComparableAddress(\n                v8::internal::Isolate* isolate) {\n                Simulator::current(isolate)->PopAddress();\n            }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimulatorStack\",\n            \"extends\": \"v8::internal::AllStatic\",\n            \"about\": \"Provides an abstraction for stack limit management when running with or without a simulator.  When using the simulator, it translates C stack limits to JS stack limits and provides stack views for WebAssembly.  When not using the simulator, it directly uses the C stack limit.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"v8::internal::Isolate\",\n                \"Simulator\",\n                \"base::Vector\",\n                \"heap::base::StackVisitor\",\n                \"base::Stack\",\n                \"wasm::StackMemory\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #else  // defined(USE_SIMULATOR)\n            // Running without a simulator on a native platform.\n\n            // The stack limit beyond which we will throw stack overflow errors in\n            // generated code. Because generated code uses the C stack, we just use\n            // the C stack limit.\n            class SimulatorStack : public v8::internal::AllStatic {\n            public:\n            static inline uintptr_t JsLimitFromCLimit(v8::internal::Isolate* isolate,\n                                                        uintptr_t c_limit) {\n                USE(isolate);\n                return c_limit;\n            }\n\n            #if V8_ENABLE_WEBASSEMBLY\n            static inline base::Vector<uint8_t> GetCentralStackView(\n                v8::internal::Isolate* isolate) {\n                uintptr_t upper_bound = base::Stack::GetStackStart();\n                size_t size =\n                    isolate->stack_size() + wasm::StackMemory::kJSLimitOffsetKB * KB;\n                uintptr_t lower_bound = upper_bound - size;\n                return base::VectorOf(reinterpret_cast<uint8_t*>(lower_bound), size);\n            }\n            #endif\n\n            static void IterateRegistersAndStack(Isolate* isolate,\n                                                ::heap::base::StackVisitor* visitor) {}\n\n            // When running on real hardware, we should also switch the C stack limit\n            // when switching stacks for Wasm.\n            static inline bool ShouldSwitchCStackForWasmStackSwitching() { return true; }\n\n            // Returns the current stack address on the native stack frame.\n            // The returned address is comparable with JS stack address.\n            static inline uintptr_t RegisterJSStackComparableAddress(\n                v8::internal::Isolate* isolate) {\n                USE(isolate);\n                return internal::GetCurrentStackPosition();\n            }\n\n            static inline void UnregisterJSStackComparableAddress(\n                v8::internal::Isolate* isolate) {\n                USE(isolate);\n            }\n            };\n            #endif  // defined(USE_SIMULATOR)\n        ]]></code>\n    </class>\n    <template>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GeneratedCode\",\n            \"about\": \"A template class that represents generated code. It allows calling generated code either through the simulator or directly on the native platform.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Address\",\n                \"Code\",\n                \"Simulator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // Use this class either as {GeneratedCode<ret, arg1, arg2>} or\n            // {GeneratedCode<ret(arg1, arg2)>} (see specialization below).\n            template <typename Return, typename... Args>\n            class GeneratedCode {\n            public:\n            using Signature = Return(Args...);\n\n            static GeneratedCode FromAddress(Isolate* isolate, Address addr) {\n                return GeneratedCode(isolate, reinterpret_cast<Signature*>(addr));\n            }\n\n            static GeneratedCode FromBuffer(Isolate* isolate, uint8_t* buffer) {\n                return GeneratedCode(isolate, reinterpret_cast<Signature*>(buffer));\n            }\n\n            static GeneratedCode FromCode(Isolate* isolate, Tagged<Code> code) {\n                return FromAddress(isolate, code->instruction_start());\n            }\n\n            #ifdef USE_SIMULATOR\n            // Defined in simulator-base.h.\n            Return Call(Args... args) {\n        // Starboard is a platform abstraction interface that also include Windows\n        // platforms like UWP.\n        #if defined(V8_TARGET_OS_WIN) && !defined(V8_OS_WIN) && \\\n            !defined(V8_OS_STARBOARD) && !defined(V8_TARGET_ARCH_ARM)\n            FATAL(\n                \"Generated code execution not possible during cross-compilation.\"\n                \"Also, generic C function calls are not implemented on 32-bit arm \"\n                \"yet.\");\n        #endif  // defined(V8_TARGET_OS_WIN) && !defined(V8_OS_WIN) &&\n                // !defined(V8_OS_STARBOARD) && !defined(V8_TARGET_ARCH_ARM)\n            return Simulator::current(isolate_)->template Call<Return>(\n                reinterpret_cast<Address>(fn_ptr_), args...);\n            }\n            #else\n\n            DISABLE_CFI_ICALL Return Call(Args... args) {\n                // When running without a simulator we call the entry directly.\n        // Starboard is a platform abstraction interface that also include Windows\n        // platforms like UWP.\n        #if defined(V8_TARGET_OS_WIN) && !defined(V8_OS_WIN) && \\\n            !defined(V8_OS_STARBOARD)\n            FATAL(\"Generated code execution not possible during cross-compilation.\");\n        #endif  // defined(V8_TARGET_OS_WIN) && !defined(V8_OS_WIN)\n        #if ABI_USES_FUNCTION_DESCRIPTORS\n        #if V8_OS_ZOS\n            // z/OS ABI requires function descriptors (FD). Artificially create a pseudo\n            // FD to ensure correct dispatch to generated code.\n            void* function_desc[2] = {0, reinterpret_cast<void*>(fn_ptr_)};\n            asm volatile(\" stg 5,%0 \" : \"=m\"(function_desc[0])::\"r5\");\n            Signature* fn = reinterpret_cast<Signature*>(function_desc);\n            return fn(args...);\n        #else\n            // AIX ABI requires function descriptors (FD).  Artificially create a pseudo\n            // FD to ensure correct dispatch to generated code.  The 'volatile'\n            // declaration is required to avoid the compiler from not observing the\n            // alias of the pseudo FD to the function pointer, and hence, optimizing the\n            // pseudo FD declaration/initialization away.\n            volatile Address function_desc[] = {reinterpret_cast<Address>(fn_ptr_), 0,\n                                                0};\n            Signature* fn = reinterpret_cast<Signature*>(function_desc);\n            return fn(args...);\n        #endif  // V8_OS_ZOS\n        #else\n            return fn_ptr_(args...);\n        #endif  // ABI_USES_FUNCTION_DESCRIPTORS\n            }\n            #endif  // USE_SIMULATOR\n\n            private:\n            friend class GeneratedCode<Return(Args...)>;\n            Isolate* isolate_;\n            Signature* fn_ptr_;\n            GeneratedCode(Isolate* isolate, Signature* fn_ptr)\n                : isolate_(isolate), fn_ptr_(fn_ptr) {}\n            };\n        ]]></code>\n    </template>\n    <template>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GeneratedCode\",\n            \"specialization\": true,\n            \"about\": \"Specialization of the GeneratedCode template to allow using {GeneratedCode<ret(arg1, arg2)>} instead of {GeneratedCode<ret, arg1, arg2>}.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"GeneratedCode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // Allow to use {GeneratedCode<ret(arg1, arg2)>} instead of\n            // {GeneratedCode<ret, arg1, arg2>}.\n            template <typename Return, typename... Args>\n            class GeneratedCode<Return(Args...)> : public GeneratedCode<Return, Args...> {\n            public:\n            // Automatically convert from {GeneratedCode<ret, arg1, arg2>} to\n            // {GeneratedCode<ret(arg1, arg2)>}.\n            GeneratedCode(GeneratedCode<Return, Args...> other)\n                : GeneratedCode<Return, Args...>(other.isolate_, other.fn_ptr_) {}\n            };\n        ]]></code>\n    </template>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AllStatic\",\n                \"namespace\": \"v8::internal\",\n                \"about\": \"Base class which disallows any instances of derived classes\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class AllStatic {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"namespace\": \"v8::internal\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {\n                public:\n                    size_t stack_size();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Simulator\",\n                \"about\": \"The base simulator class.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Simulator {\n                public:\n                    static Simulator* current(v8::internal::Isolate* isolate);\n                    uintptr_t StackLimit(uintptr_t c_limit);\n                    ::base::Vector<uint8_t> GetCentralStackView();\n                    void IterateRegistersAndStack(::heap::base::StackVisitor* visitor);\n                    uintptr_t PushAddress(uintptr_t address);\n                    void PopAddress();\n                    template <typename Return>\n                    Return Call(Address function, ...);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Code\",\n                \"namespace\": \"v8::internal\",\n                \"about\": \"Represents a compiled code object\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Code {\n                public:\n                    Address instruction_start();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Tagged\",\n                \"namespace\": \"v8::internal\",\n                \"about\": \"Tagged pointer\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> class Tagged {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Stack\",\n                \"namespace\": \"base\",\n                \"about\": \"Stack utility functions\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Stack {\n                public:\n                  static uintptr_t GetStackStart();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StackMemory\",\n                \"namespace\": \"wasm\",\n                \"about\": \"WebAssembly stack memory constants\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace wasm {\n                class StackMemory {\n                  public:\n                    static constexpr int kJSLimitOffsetKB = 10;\n                };\n                }  // namespace wasm\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}