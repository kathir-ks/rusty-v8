{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/context-deserializer.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 139, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/context-deserializer.cc\",\n            \"file_name\": \"context-deserializer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Deserializes a context snapshot, restoring a previously serialized execution context.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for context deserialization, API access, base utilities, assertions, logging, and serializer/deserializer functionality.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/context-deserializer.h\"\n\n#include \"src/api/api-inl.h\"\n#include \"src/base/logging.h\"\n#include \"src/common/assert-scope.h\"\n#include \"src/logging/counters-scopes.h\"\n#include \"src/snapshot/serializer-deserializer.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ContextDeserializer\",\n                \"about\": \"Deserializes a context snapshot.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"SnapshotData\",\n                    \"Context\",\n                    \"JSGlobalProxy\",\n                    \"DeserializeEmbedderFieldsCallback\",\n                    \"Object\",\n                    \"DirectHandle\",\n                    \"NativeContext\",\n                    \"HeapObject\",\n                    \"JSObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\n\nclass ContextDeserializer {\n public:\n  // static\n  MaybeDirectHandle<Context> ContextDeserializer::DeserializeContext(\n    Isolate* isolate, const SnapshotData* data, size_t context_index,\n    bool can_rehash, DirectHandle<JSGlobalProxy> global_proxy,\n    DeserializeEmbedderFieldsCallback embedder_fields_deserializer);\n\n  MaybeDirectHandle<Object> ContextDeserializer::Deserialize(\n    Isolate* isolate, DirectHandle<JSGlobalProxy> global_proxy,\n    DeserializeEmbedderFieldsCallback embedder_fields_deserializer);\n\n private:\n  void DeserializeEmbedderFields(\n    DirectHandle<NativeContext> context,\n    DeserializeEmbedderFieldsCallback embedder_fields_deserializer);\n\n  void DeserializeApiWrapperFields(\n    const v8::DeserializeAPIWrapperCallback& api_wrapper_callback);\n };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DeserializeContext\",\n                \"parent\": \"ContextDeserializer\",\n                \"about\": \"Static method to deserialize a context from a snapshot.\",\n                \"logic\": \"Creates a ContextDeserializer, deserializes the context, and returns a handle to the deserialized context. Measures deserialization time if profiling is enabled.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The isolate to deserialize into.\"\n                    },\n                    {\n                        \"name\": \"data\",\n                        \"type\": \"const SnapshotData*\",\n                        \"purpose\": \"The snapshot data to deserialize from.\"\n                    },\n                    {\n                        \"name\": \"context_index\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The index of the context in the snapshot.\"\n                    },\n                    {\n                        \"name\": \"can_rehash\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Whether rehashing is allowed during deserialization.\"\n                    },\n                    {\n                        \"name\": \"global_proxy\",\n                        \"type\": \"DirectHandle<JSGlobalProxy>\",\n                        \"purpose\": \"Handle to the global proxy object.\"\n                    },\n                    {\n                        \"name\": \"embedder_fields_deserializer\",\n                        \"type\": \"DeserializeEmbedderFieldsCallback\",\n                        \"purpose\": \"Callback to deserialize embedder fields.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"MaybeDirectHandle<Context>\",\n                    \"description\": \"A handle to the deserialized context, or an empty handle if deserialization fails.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"SnapshotData\",\n                    \"Context\",\n                    \"JSGlobalProxy\",\n                    \"DeserializeEmbedderFieldsCallback\",\n                    \"ContextDeserializer\",\n                    \"TRACE_EVENT0\",\n                    \"RCS_SCOPE\",\n                    \"base::ElapsedTimer\",\n                    \"v8_flags.profile_deserialization\",\n                    \"NestedTimedHistogramScope\",\n                    \"counters()->snapshot_deserialize_context()\",\n                    \"MaybeDirectHandle\",\n                    \"PrintF\",\n                    \"Cast\",\n                    \"DirectHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nMaybeDirectHandle<Context> ContextDeserializer::DeserializeContext(\n    Isolate* isolate, const SnapshotData* data, size_t context_index,\n    bool can_rehash, DirectHandle<JSGlobalProxy> global_proxy,\n    DeserializeEmbedderFieldsCallback embedder_fields_deserializer) {\n  TRACE_EVENT0(\"v8\", \"V8.DeserializeContext\");\n  RCS_SCOPE(isolate, RuntimeCallCounterId::kDeserializeContext);\n  base::ElapsedTimer timer;\n  if (V8_UNLIKELY(v8_flags.profile_deserialization)) timer.Start();\n  NestedTimedHistogramScope histogram_timer(\n      isolate->counters()->snapshot_deserialize_context());\n\n  ContextDeserializer d(isolate, data, can_rehash);\n  MaybeDirectHandle<Object> maybe_result =\n      d.Deserialize(isolate, global_proxy, embedder_fields_deserializer);\n\n  if (V8_UNLIKELY(v8_flags.profile_deserialization)) {\n    // ATTENTION: The Memory.json benchmark greps for this exact output. Do not\n    // change it without also updating Memory.json.\n    const int bytes = static_cast<int>(data->RawData().size());\n    const double ms = timer.Elapsed().InMillisecondsF();\n    PrintF(\"[Deserializing context #%zu (%d bytes) took %0.3f ms]\\n\",\n           context_index, bytes, ms);\n  }\n\n  DirectHandle<Object> result;\n  if (!maybe_result.ToHandle(&result)) return {};\n\n  return Cast<Context>(result);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Deserialize\",\n                \"parent\": \"ContextDeserializer\",\n                \"about\": \"Deserializes the context from the snapshot data.\",\n                \"logic\": \"Replaces serialized references to the global proxy and its map, then reads the objects, handles deferred objects, deserializes embedder fields, and rehashes if necessary.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"purpose\": \"The isolate to deserialize into.\"\n                    },\n                    {\n                        \"name\": \"global_proxy\",\n                        \"type\": \"DirectHandle<JSGlobalProxy>\",\n                        \"purpose\": \"Handle to the global proxy object.\"\n                    },\n                    {\n                        \"name\": \"embedder_fields_deserializer\",\n                        \"type\": \"DeserializeEmbedderFieldsCallback\",\n                        \"purpose\": \"Callback to deserialize embedder fields.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"MaybeDirectHandle<Object>\",\n                    \"description\": \"A handle to the deserialized context object, or an empty handle if deserialization fails.\"\n                },\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"JSGlobalProxy\",\n                    \"DeserializeEmbedderFieldsCallback\",\n                    \"AddAttachedObject\",\n                    \"direct_handle\",\n                    \"ReadObject\",\n                    \"DeserializeDeferredObjects\",\n                    \"DeserializeEmbedderFields\",\n                    \"Cast\",\n                    \"NativeContext\",\n                    \"DeserializeApiWrapperFields\",\n                    \"LogNewMapEvents\",\n                    \"WeakenDescriptorArrays\",\n                    \"should_rehash\",\n                    \"Rehash\",\n                    \"DisallowCodeAllocation\",\n                    \"DCHECK\",\n                    \"IsNativeContext\",\n                    \"DirectHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nMaybeDirectHandle<Object> ContextDeserializer::Deserialize(\n    Isolate* isolate, DirectHandle<JSGlobalProxy> global_proxy,\n    DeserializeEmbedderFieldsCallback embedder_fields_deserializer) {\n  // Replace serialized references to the global proxy and its map with the\n  // given global proxy and its map.\n  AddAttachedObject(global_proxy);\n  AddAttachedObject(direct_handle(global_proxy->map(), isolate));\n\n  DirectHandle<Object> result;\n  {\n    // There's no code deserialized here. If this assert fires then that's\n    // changed and logging should be added to notify the profiler et al. of\n    // the new code, which also has to be flushed from instruction cache.\n    DisallowCodeAllocation no_code_allocation;\n\n    result = ReadObject();\n    DCHECK(IsNativeContext(*result));\n    DeserializeDeferredObjects();\n    DeserializeEmbedderFields(Cast<NativeContext>(result),\n                              embedder_fields_deserializer);\n    DeserializeApiWrapperFields(\n        embedder_fields_deserializer.api_wrapper_callback);\n    LogNewMapEvents();\n    WeakenDescriptorArrays();\n  }\n\n  if (should_rehash()) Rehash();\n\n  return result;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PlainBuffer\",\n                \"about\": \"A simple buffer class that allocates a contiguous block of memory.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass PlainBuffer {\n public:\n  T* data() { return data_.get(); }\n\n  void EnsureCapacity(size_t new_capacity) {\n    if (new_capacity > capacity_) {\n      data_.reset(new T[new_capacity]);\n      capacity_ = new_capacity;\n    }\n  }\n\n private:\n  std::unique_ptr<T[]> data_;\n  size_t capacity_{0};\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DeserializeEmbedderFields\",\n                \"parent\": \"ContextDeserializer\",\n                \"about\": \"Deserializes embedder-specific fields associated with the context.\",\n                \"logic\": \"Reads embedder field data from the snapshot and calls the appropriate callback to deserialize the data into the corresponding heap object or context. Uses a PlainBuffer for temporary storage of the raw data.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"context\",\n                        \"type\": \"DirectHandle<NativeContext>\",\n                        \"purpose\": \"Handle to the native context.\"\n                    },\n                    {\n                        \"name\": \"embedder_fields_deserializer\",\n                        \"type\": \"DeserializeEmbedderFieldsCallback\",\n                        \"purpose\": \"Callback to deserialize embedder fields.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NativeContext\",\n                    \"DeserializeEmbedderFieldsCallback\",\n                    \"source()->HasMore\",\n                    \"source()->Peek\",\n                    \"source()->Get\",\n                    \"source()->GetUint30\",\n                    \"source()->CopyRaw\",\n                    \"GetBackReferencedObject\",\n                    \"IsJSObject\",\n                    \"Cast\",\n                    \"JSObject\",\n                    \"v8::Utils::ToLocal\",\n                    \"IsEmbedderDataArray\",\n                    \"DCHECK_NOT_NULL\",\n                    \"v8::DeserializeInternalFieldsCallback\",\n                    \"v8::DeserializeContextDataCallback\",\n                    \"HandleScope\",\n                    \"DisallowGarbageCollection\",\n                    \"DisallowJavascriptExecution\",\n                    \"DisallowCompilation\",\n                    \"PlainBuffer\",\n                    \"HeapObject\",\n                    \"JSObject\",\n                    \"DirectHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ContextDeserializer::DeserializeEmbedderFields(\n    DirectHandle<NativeContext> context,\n    DeserializeEmbedderFieldsCallback embedder_fields_deserializer) {\n  if (!source()->HasMore() || source()->Peek() != kEmbedderFieldsData) {\n    return;\n  }\n  // Consume `kEmbedderFieldsData`.\n  source()->Get();\n  DisallowGarbageCollection no_gc;\n  DisallowJavascriptExecution no_js(isolate());\n  DisallowCompilation no_compile(isolate());\n  // Buffer is reused across various deserializations. We always copy N bytes\n  // into the backing and pass that N bytes to the embedder via StartupData.\n  PlainBuffer<char> buffer;\n  for (int code = source()->Get(); code != kSynchronize;\n       code = source()->Get()) {\n    HandleScope scope(isolate());\n    DirectHandle<HeapObject> heap_object =\n        Cast<HeapObject>(GetBackReferencedObject());\n    const int index = source()->GetUint30();\n    const int size = source()->GetUint30();\n    buffer.EnsureCapacity(size);\n    source()->CopyRaw(buffer.data(), size);\n    if (IsJSObject(*heap_object)) {\n      DirectHandle<JSObject> obj = Cast<JSObject>(heap_object);\n      v8::DeserializeInternalFieldsCallback callback =\n          embedder_fields_deserializer.js_object_callback;\n      DCHECK_NOT_NULL(callback.callback);\n      callback.callback(v8::Utils::ToLocal(obj), index, {buffer.data(), size},\n                        callback.data);\n    } else {\n      DCHECK(IsEmbedderDataArray(*heap_object));\n      v8::DeserializeContextDataCallback callback =\n          embedder_fields_deserializer.context_callback;\n      DCHECK_NOT_NULL(callback.callback);\n      callback.callback(v8::Utils::ToLocal(context), index,\n                        {buffer.data(), size}, callback.data);\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DeserializeApiWrapperFields\",\n                \"parent\": \"ContextDeserializer\",\n                \"about\": \"Deserializes API wrapper fields associated with the context.\",\n                \"logic\": \"Reads API wrapper field data from the snapshot and calls the provided callback to deserialize the data into the corresponding JSObject. Uses a PlainBuffer for temporary storage of the raw data. Stops when it encounters a kSynchronize code.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"api_wrapper_callback\",\n                        \"type\": \"const v8::DeserializeAPIWrapperCallback&\",\n                        \"purpose\": \"Callback to deserialize API wrapper fields.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"v8::DeserializeAPIWrapperCallback\",\n                    \"source()->HasMore\",\n                    \"source()->Peek\",\n                    \"source()->Get\",\n                    \"source()->GetUint30\",\n                    \"source()->CopyRaw\",\n                    \"GetBackReferencedObject\",\n                    \"Cast\",\n                    \"JSObject\",\n                    \"v8::Utils::ToLocal\",\n                    \"DCHECK_NOT_NULL\",\n                    \"HandleScope\",\n                    \"DisallowGarbageCollection\",\n                    \"DisallowJavascriptExecution\",\n                    \"DisallowCompilation\",\n                    \"PlainBuffer\",\n                    \"JSObject\",\n                    \"DirectHandle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ContextDeserializer::DeserializeApiWrapperFields(\n    const v8::DeserializeAPIWrapperCallback& api_wrapper_callback) {\n  if (!source()->HasMore() || source()->Peek() != kApiWrapperFieldsData) {\n    return;\n  }\n  // Consume `kApiWrapperFieldsData`.\n  source()->Get();\n  DisallowGarbageCollection no_gc;\n  DisallowJavascriptExecution no_js(isolate());\n  DisallowCompilation no_compile(isolate());\n  // Buffer is reused across various deserializations. We always copy N bytes\n  // into the backing and pass that N bytes to the embedder via StartupData.\n  PlainBuffer<char> buffer;\n  // The block for `kApiWrapperFieldsData` consists of consecutive `kNewObject`\n  // blocks that are in the end terminated with a `kSynchronize`.\n  for (int code = source()->Get(); code != kSynchronize;\n       code = source()->Get()) {\n    HandleScope scope(isolate());\n    DirectHandle<JSObject> js_object =\n        Cast<JSObject>(GetBackReferencedObject());\n    const int size = source()->GetUint30();\n    buffer.EnsureCapacity(size);\n    source()->CopyRaw(buffer.data(), size);\n    DCHECK_NOT_NULL(api_wrapper_callback.callback);\n    api_wrapper_callback.callback(v8::Utils::ToLocal(js_object),\n                                  {buffer.data(), size},\n                                  api_wrapper_callback.data);\n  }\n}\n        ]]></code>\n    </func>\n</file>\n```"
}