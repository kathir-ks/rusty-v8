{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-matchers.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-matchers.h\",\n        \"file_name\": \"node-matchers.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines node matchers for simplifying and recognizing patterns in the compiler's intermediate representation (IR) graph.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for data structures, compiler intrinsics, and other utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <cmath>\n            #include <limits>\n\n            #include \"src/base/bounds.h\"\n            #include \"src/base/compiler-specific.h\"\n            #include \"src/base/numbers/double.h\"\n            #include \"src/codegen/external-reference.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/machine-operator.h\"\n            #include \"src/compiler/node.h\"\n            #include \"src/compiler/opcodes.h\"\n            #include \"src/compiler/operator.h\"\n            #include \"src/objects/heap-object.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NodeMatcher\",\n            \"about\": \"A base class for matching patterns in the compiler's IR graph. It provides basic functionality for accessing node properties and inputs.\",\n            \"attributes\": [\n                {\n                    \"name\": \"node_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The node being matched.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\",\n                \"Operator\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct NodeMatcher {\n            explicit NodeMatcher(Node* node) : node_(node) {}\n\n            Node* node() const { return node_; }\n            const Operator* op() const { return node()->op(); }\n            IrOpcode::Value opcode() const { return node()->opcode(); }\n\n            bool HasProperty(Operator::Property property) const {\n                return op()->HasProperty(property);\n            }\n            Node* InputAt(int index) const { return node()->InputAt(index); }\n\n            bool Equals(const Node* node) const { return node_ == node; }\n\n            bool IsComparison() const;\n\n        #define DEFINE_IS_OPCODE(Opcode, ...) \\\n            bool Is##Opcode() const { return opcode() == IrOpcode::k##Opcode; }\n            ALL_OP_LIST(DEFINE_IS_OPCODE)\n        #undef DEFINE_IS_OPCODE\n\n        private:\n            Node* node_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SkipValueIdentities\",\n            \"about\": \"Skips ValueIdentity nodes in the IR graph to get to the underlying value.\",\n            \"logic\": \"Iteratively follows ValueIdentity nodes until a non-ValueIdentity node is reached.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to start skipping from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The node after skipping ValueIdentity nodes.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"NodeProperties\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            inline Node* SkipValueIdentities(Node* node) {\n            while (NodeProperties::IsValueIdentity(node, &node)) {\n            }\n            DCHECK_NOT_NULL(node);\n            return node;\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueMatcher\",\n            \"about\": \"A template class for matching constant values of a specific type in the IR graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"resolved_value_\",\n                    \"type\": \"T\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The resolved constant value.\"\n                },\n                {\n                    \"name\": \"has_resolved_value_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether a constant value was successfully resolved.\"\n                }\n            ],\n            \"dependencies\": [\n                \"NodeMatcher\",\n                \"Node\",\n                \"Operator\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, IrOpcode::Value kOpcode>\n            struct ValueMatcher : public NodeMatcher {\n            // TODO(42203211): Although value matchers will work with if `T` is a direct\n            // handle type, the special instance for indirect handles uses handle location\n            // equality for performing the match. This is designed to work with canonical\n            // handles, used by the compiler. As of now, it is not clear if direct handles\n            // can replace such canonical handles, hence the following assertion.\n            static_assert(!is_direct_handle_v<T>);\n\n            using ValueType = T;\n\n            explicit ValueMatcher(Node* node)\n                : NodeMatcher(node), resolved_value_(), has_resolved_value_(false) {\n                node = SkipValueIdentities(node);\n                has_resolved_value_ = node->opcode() == kOpcode;\n                if (has_resolved_value_) {\n                resolved_value_ = OpParameter<T>(node->op());\n                }\n            }\n\n            bool HasResolvedValue() const { return has_resolved_value_; }\n            const T& ResolvedValue() const {\n                CHECK(HasResolvedValue());\n                return resolved_value_;\n            }\n\n            private:\n            T resolved_value_;\n            bool has_resolved_value_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueMatcher<uint32_t, IrOpcode::kInt32Constant>\",\n            \"about\": \"Specialization of ValueMatcher for uint32_t constants from Int32Constant nodes.\",\n            \"attributes\": [\n                {\n                    \"name\": \"resolved_value_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The resolved constant value.\"\n                },\n                {\n                    \"name\": \"has_resolved_value_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether a constant value was successfully resolved.\"\n                }\n            ],\n            \"dependencies\": [\n                \"NodeMatcher\",\n                \"Node\",\n                \"Operator\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            inline ValueMatcher<uint32_t, IrOpcode::kInt32Constant>::ValueMatcher(\n                Node* node)\n                : NodeMatcher(node), resolved_value_(), has_resolved_value_(false) {\n            node = SkipValueIdentities(node);\n            has_resolved_value_ = node->opcode() == IrOpcode::kInt32Constant;\n            if (has_resolved_value_) {\n                resolved_value_ = static_cast<uint32_t>(OpParameter<int32_t>(node->op()));\n            }\n            }\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueMatcher<int64_t, IrOpcode::kInt64Constant>\",\n            \"about\": \"Specialization of ValueMatcher for int64_t constants, handling both Int32Constant and Int64Constant nodes.\",\n            \"attributes\": [\n                {\n                    \"name\": \"resolved_value_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The resolved constant value.\"\n                },\n                {\n                    \"name\": \"has_resolved_value_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether a constant value was successfully resolved.\"\n                }\n            ],\n            \"dependencies\": [\n                \"NodeMatcher\",\n                \"Node\",\n                \"Operator\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            inline ValueMatcher<int64_t, IrOpcode::kInt64Constant>::ValueMatcher(Node* node)\n                : NodeMatcher(node), resolved_value_(), has_resolved_value_(false) {\n            node = SkipValueIdentities(node);\n            if (node->opcode() == IrOpcode::kInt32Constant) {\n                resolved_value_ = OpParameter<int32_t>(node->op());\n                has_resolved_value_ = true;\n            } else if (node->opcode() == IrOpcode::kInt64Constant) {\n                resolved_value_ = OpParameter<int64_t>(node->op());\n                has_resolved_value_ = true;\n            }\n            }\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueMatcher<uint64_t, IrOpcode::kInt64Constant>\",\n            \"about\": \"Specialization of ValueMatcher for uint64_t constants, handling both Int32Constant and Int64Constant nodes.\",\n            \"attributes\": [\n                {\n                    \"name\": \"resolved_value_\",\n                    \"type\": \"uint64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The resolved constant value.\"\n                },\n                {\n                    \"name\": \"has_resolved_value_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether a constant value was successfully resolved.\"\n                }\n            ],\n            \"dependencies\": [\n                \"NodeMatcher\",\n                \"Node\",\n                \"Operator\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            inline ValueMatcher<uint64_t, IrOpcode::kInt64Constant>::ValueMatcher(\n                Node* node)\n                : NodeMatcher(node), resolved_value_(), has_resolved_value_(false) {\n            node = SkipValueIdentities(node);\n            if (node->opcode() == IrOpcode::kInt32Constant) {\n                resolved_value_ = static_cast<uint32_t>(OpParameter<int32_t>(node->op()));\n                has_resolved_value_ = true;\n            } else if (node->opcode() == IrOpcode::kInt64Constant) {\n                resolved_value_ = static_cast<uint64_t>(OpParameter<int64_t>(node->op()));\n                has_resolved_value_ = true;\n            }\n            }\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IntMatcher\",\n            \"about\": \"A template class for matching integer constants in the IR graph.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ValueMatcher\",\n                \"Node\",\n                \"Operator\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, IrOpcode::Value kOpcode>\n            struct IntMatcher final : public ValueMatcher<T, kOpcode> {\n            explicit IntMatcher(Node* node) : ValueMatcher<T, kOpcode>(node) {}\n\n            bool Is(const T& value) const {\n                return this->HasResolvedValue() && this->ResolvedValue() == value;\n            }\n            bool IsInRange(const T& low, const T& high) const {\n                return this->HasResolvedValue() &&\n                base::IsInRange(this->ResolvedValue(), low, high);\n            }\n            bool IsMultipleOf(T n) const {\n                return this->HasResolvedValue() && (this->ResolvedValue() % n) == 0;\n            }\n            bool IsPowerOf2() const {\n                return this->HasResolvedValue() && this->ResolvedValue() > 0 &&\n                (this->ResolvedValue() & (this->ResolvedValue() - 1)) == 0;\n            }\n            bool IsNegativePowerOf2() const {\n                return this->HasResolvedValue() && this->ResolvedValue() < 0 &&\n                ((this->ResolvedValue() == std::numeric_limits<T>::min()) ||\n                    (-this->ResolvedValue() & (-this->ResolvedValue() - 1)) == 0);\n            }\n            bool IsNegative() const {\n                return this->HasResolvedValue() && this->ResolvedValue() < 0;\n            }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Int32Matcher\",\n            \"about\": \"Type alias for IntMatcher<int32_t, IrOpcode::kInt32Constant>.\",\n            \"dependencies\": [\n                \"IntMatcher\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Int32Matcher = IntMatcher<int32_t, IrOpcode::kInt32Constant>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Uint32Matcher\",\n            \"about\": \"Type alias for IntMatcher<uint32_t, IrOpcode::kInt32Constant>.\",\n            \"dependencies\": [\n                \"IntMatcher\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Uint32Matcher = IntMatcher<uint32_t, IrOpcode::kInt32Constant>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Int64Matcher\",\n            \"about\": \"Type alias for IntMatcher<int64_t, IrOpcode::kInt64Constant>.\",\n            \"dependencies\": [\n                \"IntMatcher\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Int64Matcher = IntMatcher<int64_t, IrOpcode::kInt64Constant>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Uint64Matcher\",\n            \"about\": \"Type alias for IntMatcher<uint64_t, IrOpcode::kInt64Constant>.\",\n            \"dependencies\": [\n                \"IntMatcher\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Uint64Matcher = IntMatcher<uint64_t, IrOpcode::kInt64Constant>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"V128ConstMatcher\",\n            \"about\": \"Type alias for ValueMatcher<S128ImmediateParameter, IrOpcode::kS128Const>.\",\n            \"dependencies\": [\n                \"ValueMatcher\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #if V8_ENABLE_WEBASSEMBLY\n            using V128ConstMatcher =\n                ValueMatcher<S128ImmediateParameter, IrOpcode::kS128Const>;\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IntPtrMatcher\",\n            \"about\": \"Type alias for Int32Matcher on 32-bit architectures, Int64Matcher on 64-bit architectures.\",\n            \"dependencies\": [\n                \"Int32Matcher\",\n                \"Int64Matcher\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #if V8_HOST_ARCH_32_BIT\n            using IntPtrMatcher = Int32Matcher;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"UintPtrMatcher\",\n            \"about\": \"Type alias for Uint32Matcher on 32-bit architectures, Uint64Matcher on 64-bit architectures.\",\n            \"dependencies\": [\n                \"Uint32Matcher\",\n                \"Uint64Matcher\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using UintPtrMatcher = Uint32Matcher;\n            #else\n            using IntPtrMatcher = Int64Matcher;\n            using UintPtrMatcher = Uint64Matcher;\n            #endif\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FloatMatcher\",\n            \"about\": \"A template class for matching floating point constants in the IR graph.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ValueMatcher\",\n                \"Node\",\n                \"Operator\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, IrOpcode::Value kOpcode>\n            struct FloatMatcher final : public ValueMatcher<T, kOpcode> {\n            explicit FloatMatcher(Node* node) : ValueMatcher<T, kOpcode>(node) {}\n\n            bool Is(const T& value) const {\n                return this->HasResolvedValue() && this->ResolvedValue() == value;\n            }\n            bool IsInRange(const T& low, const T& high) const {\n                return this->HasResolvedValue() && low <= this->ResolvedValue() &&\n                this->ResolvedValue() <= high;\n            }\n            bool IsMinusZero() const {\n                return this->Is(0.0) && std::signbit(this->ResolvedValue());\n            }\n            bool IsNegative() const {\n                return this->HasResolvedValue() && this->ResolvedValue() < 0.0;\n            }\n            bool IsNaN() const {\n                return this->HasResolvedValue() && std::isnan(this->ResolvedValue());\n            }\n            bool IsZero() const {\n                return this->Is(0.0) && !std::signbit(this->ResolvedValue());\n            }\n            bool IsNormal() const {\n                return this->HasResolvedValue() && std::isnormal(this->ResolvedValue());\n            }\n            bool IsInteger() const {\n                return this->HasResolvedValue() &&\n                std::nearbyint(this->ResolvedValue()) == this->ResolvedValue();\n            }\n            bool IsPositiveOrNegativePowerOf2() const {\n                if (!this->HasResolvedValue() || (this->ResolvedValue() == 0.0)) {\n                return false;\n                }\n                base::Double value = base::Double(this->ResolvedValue());\n                return !value.IsInfinite() && base::bits::IsPowerOfTwo(value.Significand());\n            }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Float32Matcher\",\n            \"about\": \"Type alias for FloatMatcher<float, IrOpcode::kFloat32Constant>.\",\n            \"dependencies\": [\n                \"FloatMatcher\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Float32Matcher = FloatMatcher<float, IrOpcode::kFloat32Constant>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Float64Matcher\",\n            \"about\": \"Type alias for FloatMatcher<double, IrOpcode::kFloat64Constant>.\",\n            \"dependencies\": [\n                \"FloatMatcher\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Float64Matcher = FloatMatcher<double, IrOpcode::kFloat64Constant>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NumberMatcher\",\n            \"about\": \"Type alias for FloatMatcher<double, IrOpcode::kNumberConstant>.\",\n            \"dependencies\": [\n                \"FloatMatcher\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using NumberMatcher = FloatMatcher<double, IrOpcode::kNumberConstant>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"HeapObjectMatcherImpl\",\n            \"about\": \"A template class for matching heap object constants in the IR graph.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ValueMatcher\",\n                \"Node\",\n                \"Operator\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <IrOpcode::Value kHeapConstantOpcode>\n            struct HeapObjectMatcherImpl final\n                : public ValueMatcher<IndirectHandle<HeapObject>, kHeapConstantOpcode> {\n            explicit HeapObjectMatcherImpl(Node* node)\n                : ValueMatcher<IndirectHandle<HeapObject>, kHeapConstantOpcode>(node) {}\n\n            bool Is(IndirectHandle<HeapObject> const& value) const {\n                return this->HasResolvedValue() &&\n                this->ResolvedValue().address() == value.address();\n            }\n\n            HeapObjectRef Ref(JSHeapBroker* broker) const {\n                // TODO(jgruber,chromium:1209798): Using kAssumeMemoryFence works around\n                // the fact that the graph stores handles (and not refs). The assumption is\n                // that any handle inserted into the graph is safe to read; but we don't\n                // preserve the reason why it is safe to read. Thus we must over-approximate\n                // here and assume the existence of a memory fence. In the future, we should\n                // consider having the graph store ObjectRefs or ObjectData pointer instead,\n                // which would make new ref construction here unnecessary.\n                return MakeRefAssumeMemoryFence(broker, this->ResolvedValue());\n            }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"HeapObjectMatcher\",\n            \"about\": \"Type alias for HeapObjectMatcherImpl<IrOpcode::kHeapConstant>.\",\n            \"dependencies\": [\n                \"HeapObjectMatcherImpl\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using HeapObjectMatcher = HeapObjectMatcherImpl<IrOpcode::kHeapConstant>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CompressedHeapObjectMatcher\",\n            \"about\": \"Type alias for HeapObjectMatcherImpl<IrOpcode::kCompressedHeapConstant>.\",\n            \"dependencies\": [\n                \"HeapObjectMatcherImpl\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using CompressedHeapObjectMatcher =\n                HeapObjectMatcherImpl<IrOpcode::kCompressedHeapConstant>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ExternalReferenceMatcher\",\n            \"about\": \"A class for matching external reference constants in the IR graph.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ValueMatcher\",\n                \"Node\",\n                \"Operator\",\n                \"IrOpcode\",\n                \"ExternalReference\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct ExternalReferenceMatcher final\n                : public ValueMatcher<ExternalReference, IrOpcode::kExternalConstant> {\n            explicit ExternalReferenceMatcher(Node* node)\n                : ValueMatcher<ExternalReference, IrOpcode::kExternalConstant>(node) {}\n            bool Is(const ExternalReference& value) const {\n                return this->HasResolvedValue() && this->ResolvedValue() == value;\n            }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LoadMatcher\",\n            \"about\": \"A template struct for matching the inputs to machine-level load operations.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"NodeMatcher\",\n                \"Node\",\n                \"IntPtrMatcher\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename Object>\n            struct LoadMatcher : public NodeMatcher {\n            explicit LoadMatcher(Node* node)\n                : NodeMatcher(node), object_(InputAt(0)), index_(InputAt(1)) {}\n\n            using ObjectMatcher = Object;\n\n            Object const& object() const { return object_; }\n            IntPtrMatcher const& index() const { return index_; }\n\n            private:\n            Object const object_;\n            IntPtrMatcher const index_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BinopMatcher\",\n            \"about\": \"A template struct for matching binary operations and handling constant placement.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"NodeMatcher\",\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename Left, typename Right, MachineRepresentation rep>\n            struct BinopMatcher : public NodeMatcher {\n            explicit BinopMatcher(Node* node)\n                : NodeMatcher(node), left_(InputAt(0)), right_(InputAt(1)) {\n                if (HasProperty(Operator::kCommutative)) PutConstantOnRight();\n            }\n            BinopMatcher(Node* node, bool allow_input_swap)\n                : NodeMatcher(node), left_(InputAt(0)), right_(InputAt(1)) {\n                if (allow_input_swap) PutConstantOnRight();\n            }\n\n            using LeftMatcher = Left;\n            using RightMatcher = Right;\n\n            static constexpr MachineRepresentation representation = rep;\n\n            const Left& left() const { return left_; }\n            const Right& right() const { return right_; }\n\n            bool IsFoldable() const {\n                return left().HasResolvedValue() && right().HasResolvedValue();\n            }\n            bool LeftEqualsRight() const { return left().node() == right().node(); }\n\n            bool OwnsInput(Node* input) {\n                for (Node* use : input->uses()) {\n                if (use != node()) {\n                    return false;\n                }\n                }\n                return true;\n            }\n\n            protected:\n            void SwapInputs() {\n                std::swap(left_, right_);\n                // TODO(turbofan): This modification should notify the reducers using\n                // BinopMatcher. Alternatively, all reducers (especially value numbering)\n                // could ignore the ordering for commutative binops.\n                node()->ReplaceInput(0, left().node());\n                node()->ReplaceInput(1, right().node());\n            }\n\n            private:\n            void PutConstantOnRight() {\n                if (left().HasResolvedValue() && !right().HasResolvedValue()) {\n                SwapInputs();\n                }\n            }\n\n            Left left_;\n            Right right_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Int32BinopMatcher\",\n            \"about\": \"Type alias for BinopMatcher<Int32Matcher, Int32Matcher, MachineRepresentation::kWord32>.\",\n            \"dependencies\": [\n                \"BinopMatcher\",\n                \"Int32Matcher\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Int32BinopMatcher =\n                BinopMatcher<Int32Matcher, Int32Matcher, MachineRepresentation::kWord32>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Uint32BinopMatcher\",\n            \"about\": \"Type alias for BinopMatcher<Uint32Matcher, Uint32Matcher, MachineRepresentation::kWord32>.\",\n            \"dependencies\": [\n                \"BinopMatcher\",\n                \"Uint32Matcher\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Uint32BinopMatcher =\n                BinopMatcher<Uint32Matcher, Uint32Matcher, MachineRepresentation::kWord32>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Int64BinopMatcher\",\n            \"about\": \"Type alias for BinopMatcher<Int64Matcher, Int64Matcher, MachineRepresentation::kWord64>.\",\n            \"dependencies\": [\n                \"BinopMatcher\",\n                \"Int64Matcher\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Int64BinopMatcher =\n                BinopMatcher<Int64Matcher, Int64Matcher, MachineRepresentation::kWord64>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Uint64BinopMatcher\",\n            \"about\": \"Type alias for BinopMatcher<Uint64Matcher, Uint64Matcher, MachineRepresentation::kWord64>.\",\n            \"dependencies\": [\n                \"BinopMatcher\",\n                \"Uint64Matcher\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Uint64BinopMatcher =\n                BinopMatcher<Uint64Matcher, Uint64Matcher, MachineRepresentation::kWord64>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IntPtrBinopMatcher\",\n            \"about\": \"Type alias for BinopMatcher<IntPtrMatcher, IntPtrMatcher, MachineType::PointerRepresentation()>.\",\n            \"dependencies\": [\n                \"BinopMatcher\",\n                \"IntPtrMatcher\",\n                \"MachineType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using IntPtrBinopMatcher = BinopMatcher<IntPtrMatcher, IntPtrMatcher,\n                                                MachineType::PointerRepresentation()>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"UintPtrBinopMatcher\",\n            \"about\": \"Type alias for BinopMatcher<UintPtrMatcher, UintPtrMatcher, MachineType::PointerRepresentation()>.\",\n            \"dependencies\": [\n                \"BinopMatcher\",\n                \"UintPtrMatcher\",\n                \"MachineType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using UintPtrBinopMatcher = BinopMatcher<UintPtrMatcher, UintPtrMatcher,\n                                                MachineType::PointerRepresentation()>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Float32BinopMatcher\",\n            \"about\": \"Type alias for BinopMatcher<Float32Matcher, Float32Matcher, MachineRepresentation::kFloat32>.\",\n            \"dependencies\": [\n                \"BinopMatcher\",\n                \"Float32Matcher\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Float32BinopMatcher = BinopMatcher<Float32Matcher, Float32Matcher,\n                                                MachineRepresentation::kFloat32>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Float64BinopMatcher\",\n            \"about\": \"Type alias for BinopMatcher<Float64Matcher, Float64Matcher, MachineRepresentation::kFloat64>.\",\n            \"dependencies\": [\n                \"BinopMatcher\",\n                \"Float64Matcher\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            using Float64BinopMatcher = BinopMatcher<Float64Matcher, Float64Matcher,\n                                                MachineRepresentation::"
}