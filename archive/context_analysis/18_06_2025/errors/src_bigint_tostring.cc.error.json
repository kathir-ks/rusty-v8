{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/bigint/tostring.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/bigint/tostring.cc\",\n        \"file_name\": \"tostring.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the conversion of BigInt objects to their string representation in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ libraries and V8-specific headers for BigInt manipulation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <cstring>\n            #include <limits>\n\n            #include \"src/bigint/bigint-internal.h\"\n            #include \"src/bigint/digit-arithmetic.h\"\n            #include \"src/bigint/div-helpers.h\"\n            #include \"src/bigint/util.h\"\n            #include \"src/bigint/vector-arithmetic.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RecursionLevel\",\n            \"about\": \"Manages recursion levels for fast string conversion of BigInts, precomputing divisors and inverses.\",\n            \"attributes\": [\n                {\n                    \"name\": \"leading_zero_shift_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the number of leading zeros in the divisor.\"\n                },\n                {\n                    \"name\": \"char_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of characters generated by each half of this level.\"\n                },\n                {\n                    \"name\": \"is_toplevel_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if this is the top-level recursion level.\"\n                },\n                {\n                    \"name\": \"next_\",\n                    \"type\": \"RecursionLevel*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the next (lower) recursion level.\"\n                },\n                {\n                    \"name\": \"divisor_\",\n                    \"type\": \"ScratchDigits\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The divisor used at this recursion level.\"\n                },\n                {\n                    \"name\": \"inverse_storage_\",\n                    \"type\": \"std::unique_ptr<Storage>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the inverse of the divisor.\"\n                },\n                {\n                    \"name\": \"inverse_\",\n                    \"type\": \"Digits\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The inverse of the divisor as a Digits object.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ScratchDigits\",\n                \"Digits\",\n                \"Storage\",\n                \"ProcessorImpl\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        class RecursionLevel {\n         public:\n          static RecursionLevel* CreateLevels(digit_t base_divisor, int base_char_count,\n                                              int target_bit_length,\n                                              ProcessorImpl* processor);\n          ~RecursionLevel() { delete next_; }\n\n          void ComputeInverse(ProcessorImpl* proc, int dividend_length = 0);\n          Digits GetInverse(int dividend_length);\n\n         private:\n          friend class ToStringFormatter;\n          RecursionLevel(digit_t base_divisor, int base_char_count)\n              : char_count_(base_char_count), divisor_(1) {\n            divisor_[0] = base_divisor;\n          }\n          explicit RecursionLevel(RecursionLevel* next)\n              : char_count_(next->char_count_ * 2),\n                next_(next),\n                divisor_(next->divisor_.len() * 2) {\n            next->is_toplevel_ = false;\n          }\n\n          void LeftShiftDivisor() {\n            leading_zero_shift_ = CountLeadingZeros(divisor_.msd());\n            LeftShift(divisor_, divisor_, leading_zero_shift_);\n          }\n\n          int leading_zero_shift_{0};\n          // The number of characters generated by *each half* of this level.\n          int char_count_;\n          bool is_toplevel_{true};\n          RecursionLevel* next_{nullptr};\n          ScratchDigits divisor_;\n          std::unique_ptr<Storage> inverse_storage_;\n          Digits inverse_;\n        };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CreateLevels\",\n            \"parent\": \"RecursionLevel\",\n            \"about\": \"Creates a linked list of RecursionLevel objects for divide-and-conquer BigInt string conversion.\",\n            \"logic\": \"Iteratively creates RecursionLevel objects, computing divisors as squares of the previous level's divisor until the divisor's bit length is sufficient. Also computes the inverse of each divisor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"base_divisor\",\n                    \"type\": \"digit_t\",\n                    \"purpose\": \"The base divisor for the initial recursion level.\"\n                },\n                {\n                    \"name\": \"base_char_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of characters represented by the base divisor.\"\n                },\n                {\n                    \"name\": \"target_bit_length\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The bit length of the BigInt to be converted.\"\n                },\n                {\n                    \"name\": \"processor\",\n                    \"type\": \"ProcessorImpl*\",\n                    \"purpose\": \"Pointer to the ProcessorImpl object to perform arithmetic operations.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"RecursionLevel*\",\n                \"description\": \"Pointer to the first RecursionLevel object in the linked list, or nullptr if terminated.\"\n            },\n            \"dependencies\": [\n                \"RecursionLevel\",\n                \"BitLength\",\n                \"ProcessorImpl\",\n                \"Multiply\",\n                \"Normalize\",\n                \"LeftShiftDivisor\",\n                \"ComputeInverse\",\n                \"should_terminate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        RecursionLevel* RecursionLevel::CreateLevels(digit_t base_divisor,\n                                                     int base_char_count,\n                                                     int target_bit_length,\n                                                     ProcessorImpl* processor) {\n          RecursionLevel* level = new RecursionLevel(base_divisor, base_char_count);\n          // We can stop creating levels when the next level's divisor, which is the\n          // square of the current level's divisor, would be strictly bigger (in terms\n          // of its numeric value) than the input we're formatting. Since computing that\n          // next divisor is expensive, we want to predict the necessity based on bit\n          // lengths. Bit lengths are an imperfect predictor of numeric value, so we\n          // have to be careful:\n          // - since we can't estimate which one of two numbers of equal bit length\n          //   is bigger, we have to aim for a strictly bigger bit length.\n          // - when squaring, the bit length sometimes doubles (e.g. 0b11\u00b2 == 0b1001),\n          //   but usually we \"lose\" a bit (e.g. 0b10\u00b2 == 0b100).\n          while (BitLength(level->divisor_) * 2 - 1 <= target_bit_length) {\n            RecursionLevel* prev = level;\n            level = new RecursionLevel(prev);\n            processor->Multiply(level->divisor_, prev->divisor_, prev->divisor_);\n            if (processor->should_terminate()) {\n              delete level;\n              return nullptr;\n            }\n            level->divisor_.Normalize();\n            // Left-shifting the divisor must only happen after it's been used to\n            // compute the next divisor.\n            prev->LeftShiftDivisor();\n            prev->ComputeInverse(processor);\n          }\n          level->LeftShiftDivisor();\n          // Not calling info->ComputeInverse here so that it can take the input's\n          // length into account to save some effort on inverse generation.\n          return level;\n        }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ComputeInverse\",\n            \"parent\": \"RecursionLevel\",\n            \"about\": \"Computes the modular inverse of the divisor for Barrett reduction.\",\n            \"logic\": \"Calculates the inverse using the Invert function from digit-arithmetic, storing the result in inverse_.\",\n            \"parameters\": [\n                {\n                    \"name\": \"processor\",\n                    \"type\": \"ProcessorImpl*\",\n                    \"purpose\": \"Processor implementation to utilize for Barrett division.\"\n                },\n                {\n                    \"name\": \"dividend_length\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The length of the dividend to be used in modular reduction.  0 means use the max length\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Invert\",\n                \"Storage\",\n                \"RWDigits\",\n                \"Digits\",\n                \"InvertScratchSpace\",\n                \"Invert\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        void RecursionLevel::ComputeInverse(ProcessorImpl* processor,\n                                            int dividend_length) {\n          int inverse_len = divisor_.len();\n          if (dividend_length != 0) {\n            inverse_len = dividend_length - divisor_.len();\n            DCHECK(inverse_len <= divisor_.len());\n          }\n          int scratch_len = InvertScratchSpace(inverse_len);\n          ScratchDigits scratch(scratch_len);\n          Storage* inv_storage = new Storage(inverse_len + 1);\n          inverse_storage_.reset(inv_storage);\n          RWDigits inverse_initializer(inv_storage->get(), inverse_len + 1);\n          Digits input(divisor_, divisor_.len() - inverse_len, inverse_len);\n          processor->Invert(inverse_initializer, input, scratch);\n          inverse_initializer.TrimOne();\n          inverse_ = inverse_initializer;\n        }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetInverse\",\n            \"parent\": \"RecursionLevel\",\n            \"about\": \"Returns the precomputed inverse of the divisor.\",\n            \"logic\": \"Returns a sub-sequence of the stored inverse, based on inverse_len = dividend_length - divisor_.len().\",\n            \"parameters\": [\n                {\n                    \"name\": \"dividend_length\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Length of the dividend (input) to modular reduction.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Digits\",\n                \"description\": \"The precomputed inverse of the divisor as Digits.\"\n            },\n            \"dependencies\": [\n                \"Digits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        Digits RecursionLevel::GetInverse(int dividend_length) {\n          DCHECK(inverse_.len() != 0);\n          int inverse_len = dividend_length - divisor_.len();\n          // If the bits in memory are reliable, then we always have enough digits\n          // in the inverse available. This is a Release-mode CHECK because malicious\n          // concurrent heap mutation can throw off the decisions made by the recursive\n          // procedure, and this is a good bottleneck to catch them.\n          CHECK(inverse_len <= inverse_.len());\n          return inverse_ + (inverse_.len() - inverse_len);\n        }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LeftShiftDivisor\",\n            \"parent\": \"RecursionLevel\",\n            \"about\": \"Left-shifts the divisor to normalize it for division operations.\",\n            \"logic\": \"Calculates the number of leading zeros in the most significant digit of the divisor and then left-shifts the divisor by that amount.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CountLeadingZeros\",\n                \"LeftShift\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        void RecursionLevel::LeftShiftDivisor() {\n          leading_zero_shift_ = CountLeadingZeros(divisor_.msd());\n          LeftShift(divisor_, divisor_, leading_zero_shift_);\n        }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ToStringFormatter\",\n            \"about\": \"Formats BigInt objects to string representations.\",\n            \"attributes\": [\n                {\n                    \"name\": \"digits_\",\n                    \"type\": \"Digits\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The digits of the BigInt to be formatted.\"\n                },\n                {\n                    \"name\": \"radix_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The radix for the string representation (e.g., 10 for decimal, 16 for hexadecimal).\"\n                },\n                {\n                    \"name\": \"max_bits_per_char_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The maximum number of bits that can be represented by a single character in the given radix.\"\n                },\n                {\n                    \"name\": \"chunk_chars_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of characters in a chunk for division.\"\n                },\n                {\n                    \"name\": \"sign_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the BigInt is negative.\"\n                },\n                {\n                    \"name\": \"out_start_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the beginning of the output buffer.\"\n                },\n                {\n                    \"name\": \"out_end_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the end of the output buffer.\"\n                },\n                {\n                    \"name\": \"out_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the current position in the output buffer.\"\n                },\n                {\n                    \"name\": \"chunk_divisor_\",\n                    \"type\": \"digit_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The divisor used to split the BigInt into chunks.\"\n                },\n                {\n                    \"name\": \"processor_\",\n                    \"type\": \"ProcessorImpl*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A pointer to the processor impl.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Digits\",\n                \"ScratchDigits\",\n                \"ProcessorImpl\",\n                \"RecursionLevel\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        class ToStringFormatter {\n         public:\n          ToStringFormatter(Digits X, int radix, bool sign, char* out,\n                            uint32_t chars_available, ProcessorImpl* processor)\n              : digits_(X),\n                radix_(radix),\n                sign_(sign),\n                out_start_(out),\n                out_end_(out + chars_available),\n                out_(out_end_),\n                processor_(processor) {\n            digits_.Normalize();\n            DCHECK(chars_available >= ToStringResultLength(digits_, radix_, sign_));\n          }\n\n          void Start();\n          int Finish();\n\n          void Classic() {\n            if (digits_.len() == 0) {\n              *(--out_) = '0';\n              return;\n            }\n            if (digits_.len() == 1) {\n              out_ = BasecaseLast(digits_[0], out_);\n              return;\n            }\n            // {rest} holds the part of the BigInt that we haven't looked at yet.\n            // Not to be confused with \"remainder\"!\n            ScratchDigits rest(digits_.len());\n            // In the first round, divide the input, allocating a new BigInt for\n            // the result == rest; from then on divide the rest in-place.\n            Digits dividend = digits_;\n            do {\n              if (radix_ == 10) {\n                // Faster but costs binary size, so we optimize the most common case.\n                out_ = DivideByMagic<10>(rest, dividend, out_);\n                MAYBE_INTERRUPT(processor_->AddWorkEstimate(rest.len() * 2));\n              } else {\n                digit_t chunk;\n                processor_->DivideSingle(rest, &chunk, dividend, chunk_divisor_);\n                out_ = BasecaseMiddle(chunk, out_);\n                // Assume that a division is about ten times as expensive as a\n                // multiplication.\n                MAYBE_INTERRUPT(processor_->AddWorkEstimate(rest.len() * 10));\n              }\n              MAYBE_INTERRUPT(if (processor_->should_terminate()) return );\n              rest.Normalize();\n              dividend = rest;\n            } while (rest.len() > 1);\n            out_ = BasecaseLast(rest[0], out_);\n          }\n\n          void BasePowerOfTwo();\n\n          void Fast();\n          char* FillWithZeros(RecursionLevel* level, char* prev_cursor, char* out,\n                                bool is_last_on_level);\n          char* ProcessLevel(RecursionLevel* level, Digits chunk, char* out,\n                             bool is_last_on_level);\n\n         private:\n          // When processing the last (most significant) digit, don't write leading\n          // zeros.\n          char* BasecaseLast(digit_t digit, char* out) {\n            if (radix_ == 10) return BasecaseFixedLast<10>(digit, out);\n            do {\n              DCHECK(*(out - 1) == kStringZapValue);\n              *(--out) = kConversionChars[digit % radix_];\n              digit /= radix_;\n            } while (digit > 0);\n            return out;\n          }\n\n          // When processing a middle (non-most significant) digit, always write the\n          // same number of characters (as many '0' as necessary).\n          char* BasecaseMiddle(digit_t digit, char* out) {\n            for (int i = 0; i < chunk_chars_; i++) {\n              DCHECK(*(out - 1) == kStringZapValue);\n              *(--out) = kConversionChars[digit % radix_];\n              digit /= radix_;\n            }\n            DCHECK(digit == 0);\n            return out;\n          }\n\n          Digits digits_;\n          int radix_;\n          int max_bits_per_char_ = 0;\n          int chunk_chars_ = 0;\n          bool sign_;\n          char* out_start_;\n          char* out_end_;\n          char* out_;\n          digit_t chunk_divisor_ = 0;\n          ProcessorImpl* processor_;\n        };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Start\",\n            \"parent\": \"ToStringFormatter\",\n            \"about\": \"Initializes the ToStringFormatter object for classic BigInt string conversion.\",\n            \"logic\": \"Calculates max_bits_per_char_, chunk_chars_, and chunk_divisor_ based on the radix.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"kMaxBitsPerChar\",\n                \"kDigitBits\",\n                \"kBitsPerCharTableMultiplier\",\n                \"digit_pow\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        void ToStringFormatter::Start() {\n          max_bits_per_char_ = kMaxBitsPerChar[radix_];\n          chunk_chars_ = kDigitBits * kBitsPerCharTableMultiplier / max_bits_per_char_;\n          chunk_divisor_ = digit_pow(radix_, chunk_chars_);\n          // By construction of chunk_chars_, there can't have been overflow.\n          DCHECK(chunk_divisor_ != 0);\n        }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Finish\",\n            \"parent\": \"ToStringFormatter\",\n            \"about\": \"Finishes the BigInt string conversion process by adding the sign (if necessary) and copying the result to the beginning of the output buffer.\",\n            \"logic\": \"Adds the negative sign if the number is negative.  Moves the converted string to the beginning of the buffer, removing any leading zeros.  Zeroes out the excess chars at the end of the string.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The number of excess characters at the beginning of the output buffer (leading zeros).\"\n            },\n            \"dependencies\": [\n                \"std::memmove\",\n                \"memset\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        int ToStringFormatter::Finish() {\n          DCHECK(out_ >= out_start_);\n          DCHECK(out_ < out_end_);  // At least one character was written.\n          while (out_ < out_end_ && *out_ == '0') out_++;\n          if (sign_) *(--out_) = '-';\n          int excess = 0;\n          if (out_ > out_start_) {\n            size_t actual_length = out_end_ - out_;\n            excess = static_cast<int>(out_ - out_start_);\n            std::memmove(out_start_, out_, actual_length);\n          }\n          return excess;\n        }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BasePowerOfTwo\",\n            \"parent\": \"ToStringFormatter\",\n            \"about\": \"Converts a BigInt to a string representation when the radix is a power of two.\",\n            \"logic\": \"Uses bit masking and shifting to extract characters directly from the BigInt's digits, optimizing for power-of-two radices.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CountTrailingZeros\",\n                \"kConversionChars\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        void ToStringFormatter::BasePowerOfTwo() {\n          const int bits_per_char = CountTrailingZeros(radix_);\n          const int char_mask = radix_ - 1;\n          digit_t digit = 0;\n          // Keeps track of how many unprocessed bits there are in {digit}.\n          int available_bits = 0;\n          for (int i = 0; i < digits_.len() - 1; i++) {\n            digit_t new_digit = digits_[i];\n            // Take any leftover bits from the last iteration into account.\n            int current = (digit | (new_digit << available_bits)) & char_mask;\n            *(--out_) = kConversionChars[current];\n            int consumed_bits = bits_per_char - available_bits;\n            digit = new_digit >> consumed_bits;\n            available_bits = kDigitBits - consumed_bits;\n            while (available_bits >= bits_per_char) {\n              *(--out_) = kConversionChars[digit & char_mask];\n              digit >>= bits_per_char;\n              available_bits -= bits_per_char;\n            }\n          }\n          // Take any leftover bits from the last iteration into account.\n          digit_t msd = digits_.msd();\n          int current = (digit | (msd << available_bits)) & char_mask;\n          *(--out_) = kConversionChars[current];\n          digit = msd >> (bits_per_char - available_bits);\n          while (digit != 0) {\n            *(--out_) = kConversionChars[digit & char_mask];\n            digit >>= bits_per_char;\n          }\n        }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Fast\",\n            \"parent\": \"ToStringFormatter\",\n            \"about\": \"Fast divide-and-conquer algorithm for converting BigInt to string.\",\n            \"logic\": \"Recursively divides the BigInt and uses precomputed divisors and inverses.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"RecursionLevel\",\n                \"CreateLevels\",\n                \"ProcessLevel\",\n                \"kDigitBits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        void ToStringFormatter::Fast() {\n          // As a sandbox proofing measure, we round up here. Using {BitLength(digits_)}\n          // would be technically optimal, but vulnerable to a malicious worker that\n          // uses an in-sandbox corruption primitive to concurrently toggle the MSD bits\n          // between the invocations of {CreateLevels} and {ProcessLevel}.\n          int target_bit_length = digits_.len() * kDigitBits;\n          std::unique_ptr<RecursionLevel> recursion_levels(RecursionLevel::CreateLevels(\n              chunk_divisor_, chunk_chars_, target_bit_length, processor_));\n          if (processor_->should_terminate()) return;\n          out_ = ProcessLevel(recursion_levels.get(), digits_, out_, true);\n        }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FillWithZeros\",\n            \"parent\": \"ToStringFormatter\",\n            \"about\": \"Fills the output buffer with leading zeros to ensure correct formatting.\",\n            \"logic\": \"Writes '0' characters from right-to-left until the number of characters matches the expected output length.\",\n            \"parameters\": [\n                {\n                    \"name\": \"level\",\n                    \"type\": \"RecursionLevel*\",\n                    \"purpose\": \"The recursion level to get char count from or null to use the default.\"\n                },\n                {\n                    \"name\": \"right_boundary\",\n                    \"type\": \"char*\",\n                    \"purpose\": \"Marks the right side of what's been output so far.\"\n                },\n                {\n                    \"name\": \"out\",\n                    \"type\": \"char*\",\n                    \"purpose\": \"The output buffer to be filled with '0' characters.\"\n                },\n                {\n                    \"name\": \"is_last_on_level\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether we are at the leftmost edge.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"char*\",\n                \"description\": \"The updated output buffer pointer.\"\n            },\n            \"dependencies\": [\n                \"chunk_chars_\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        char* ToStringFormatter::FillWithZeros(RecursionLevel* level,\n                                             char* right_boundary, char* out,\n                                             bool is_last_on_level) {\n          // Fill up with zeros up to the character count expected to be generated\n          // on this level; unless this is the left edge of the result.\n          if (is_last_on_level) return out;\n          int chunk_chars = level == nullptr ? chunk_chars_ : level->char_count_ * 2;\n          char* end = right_boundary - chunk_chars;\n          DCHECK(out >= end);\n          while (out > end) {\n            *(--out) = '0';\n          }\n          return out;\n        }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessLevel\",\n            \"parent\": \"ToStringFormatter\",\n            \"about\": \"Recursively processes a chunk of the BigInt for fast string conversion.\",\n            \"logic\": \"Divides the chunk, recurses on the left and right halves, and fills with zeros.\",\n            \"parameters\": [\n                {\n                    \"name\": \"level\",\n                    \"type\": \"RecursionLevel*\",\n                    \"purpose\": \"The recursion level for the current step.\"\n                },\n                {\n                    \"name\": \"chunk\",\n                    \"type\": \"Digits\",\n                    \"purpose\": \"The chunk of the BigInt to be processed.\"\n                },\n                {\n                    \"name\": \"out\",\n                    \"type\": \"char*\",\n                    \"purpose\": \"The output buffer.\"\n                },\n                {\n                    \"name\": \"is_last_on_level\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates if this is the most significant part of the current level.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"char*\",\n                \"description\": \"The updated output buffer pointer.\"\n            },\n            \"dependencies\": [\n                \"Digits\",\n                \"Normalize\",\n                \"BasecaseLast\",\n                \"FillWithZeros\",\n                \"divisor_\",\n                \"leading_zero_shift_\",\n                \"Compare\",\n                \"ProcessLevel\",\n                \"ShiftedDigits\",\n                \"ScratchDigits\",\n                \"DivideSchoolbook\",\n                \"DivideSingle\",\n                \"DivideBarrett\",\n                \"GetInverse\",\n                \"RightShift\",\n                \"should_terminate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        char* ToStringFormatter::ProcessLevel(RecursionLevel* level, Digits chunk,\n                                              char* out, bool is_last_on_level) {\n          // Step 0: if only one digit is left, bail out to the base case.\n          Digits normalized = chunk;\n          normalized.Normalize();\n          if (normalized.len() <= 1) {\n            char* right_boundary = out;\n            if (normalized.len() == 1) {\n              out = BasecaseLast(normalized[0], out);\n            }\n            return FillWithZeros(level, right_boundary, out, is_last_on_level);\n          }\n\n          // Step 1: If the chunk is guaranteed to remain smaller than the divisor\n          // even after left-shifting, fall through to the next level immediately.\n          if (normalized.len() < level->divisor_.len()) {\n            char* right_boundary = out;\n            out = ProcessLevel(level->next_, chunk, out, is_last_on_level);\n            return FillWithZeros(level, right_boundary, out, is_last_on_level);\n          }\n          // Step 2: Prepare the chunk.\n          bool allow_inplace_modification = chunk.digits() != digits_.digits();\n          Digits original_chunk = chunk;\n          ShiftedDigits chunk_shifted(chunk, level->leading_zero_shift_,\n                                      allow_inplace_modification);\n          chunk = chunk_shifted;\n          chunk.Normalize();\n          // Check (now precisely) if the chunk is smaller than the divisor.\n          int comparison = Compare(chunk, level->divisor_);\n          if (comparison <= 0) {\n            char* right_boundary = out;\n            if (comparison < 0) {\n              // If the chunk is strictly smaller than the divisor, we can process\n              // it directly on the next level as the right half, and know that the\n              // left half is all '0'.\n              // In case we shifted {chunk} in-place, we must undo that\n              // before the call...\n              chunk_shifted.Reset();\n              // ...and otherwise undo the {chunk = chunk_shifted} assignment above.\n              chunk = original_chunk;\n              out = ProcessLevel(level->next_, chunk, out, is_last_on_level);\n            } else {\n              DCHECK(comparison == 0);\n              // If the chunk is equal to the divisor, we know that the right half\n              // is all '0', and the left half is '...0001'.\n              // Handling this case specially is an optimization; we could also\n              // fall through to the generic \"chunk > divisor\" path below.\n              out = FillWithZeros(level->next_, right_boundary, out, false);\n              *(--out) = '1';\n            }\n            // In both cases, make sure the left half is fully written.\n            return FillWithZeros(level, right_boundary, out, is_last_on_level);\n          }\n          // Step 3: Allocate space for the results.\n          // Allocate one extra digit so the next level can left-shift in-place.\n          ScratchDigits right(level->divisor_.len() + 1);\n          // Allocate one extra digit because DivideBarrett requires it.\n          ScratchDigits left(chunk.len() - level->divisor_.len() + 1);\n\n          // Step 4: Divide to split {chunk} into {left} and {right}.\n          int inverse_len = chunk.len() - level->divisor_.len();\n          if (inverse_len == 0) {\n            processor_->DivideSchoolbook(left, right, chunk, level->divisor_);\n          } else if (level->divisor_.len() == 1) {\n            processor_->DivideSingle(left, right.digits(), chunk, level->divisor_[0]);\n            for (int i = 1; i < right.len(); i++) right[i] = 0;\n          } else {\n            ScratchDigits scratch(DivideBarrettScratchSpace(chunk.len()));\n            // The top level only computes its inverse when {chunk.len()} is\n            // available. Other levels have precomputed theirs.\n            if (level->is_toplevel_) {\n              level->ComputeInverse(processor_, chunk.len());\n              if (processor_->should_terminate()) return out;\n            }\n            Digits inverse = level->GetInverse(chunk.len());\n            processor_->DivideBarrett(left, right, chunk, level->divisor_, inverse,\n                                      "
}