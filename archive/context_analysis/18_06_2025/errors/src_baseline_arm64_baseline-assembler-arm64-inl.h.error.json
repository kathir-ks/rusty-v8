{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/arm64/baseline-assembler-arm64-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/arm64/baseline-assembler-arm64-inl.h\",\n        \"file_name\": \"baseline-assembler-arm64-inl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Inline implementation details for the BaselineAssembler on the ARM64 architecture.  This includes helper functions for stack management, register allocation, and code emission specific to the baseline compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for baseline assembly, ARM64 macro assembly, interface descriptors, and literal objects.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/baseline/baseline-assembler.h\"\n            #include \"src/codegen/arm64/macro-assembler-arm64-inl.h\"\n            #include \"src/codegen/interface-descriptors.h\"\n            #include \"src/objects/literal-objects-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BaselineAssembler::ScratchRegisterScope\",\n            \"about\": \"Manages the allocation and deallocation of scratch registers within a BaselineAssembler.  It provides a mechanism to acquire and release temporary registers for use within a limited scope, ensuring that registers are not inadvertently clobbered.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"BaselineAssembler\",\n                \"UseScratchRegisterScope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class BaselineAssembler::ScratchRegisterScope {\n            public:\n            explicit ScratchRegisterScope(BaselineAssembler* assembler)\n                : assembler_(assembler),\n                prev_scope_(assembler->scratch_register_scope_),\n                wrapped_scope_(assembler->masm()) {\n                if (!assembler_->scratch_register_scope_) {\n                // If we haven't opened a scratch scope yet, for the first one add a\n                // couple of extra registers.\n                wrapped_scope_.Include(x14, x15);\n                wrapped_scope_.Include(x19);\n                }\n                assembler_->scratch_register_scope_ = this;\n            }\n            ~ScratchRegisterScope() { assembler_->scratch_register_scope_ = prev_scope_; }\n\n            Register AcquireScratch() { return wrapped_scope_.AcquireX(); }\n\n            private:\n            BaselineAssembler* assembler_;\n            ScratchRegisterScope* prev_scope_;\n            UseScratchRegisterScope wrapped_scope_;\n            };\n        ]]></code>\n    </class>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"detail\",\n            \"type\": \"namespace\",\n            \"about\": \"Provides internal, implementation-specific helper functions for the BaselineAssembler.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace detail {\n\n            #ifdef DEBUG\n            inline bool Clobbers(Register target, MemOperand op) {\n            return op.base() == target || op.regoffset() == target;\n            }\n            #endif\n\n            }  // namespace detail\n        ]]></code>\n    </namespace>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterFrameOperand\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Calculates the memory operand for a register within the interpreter's register frame.\",\n            \"logic\": \"Calculates the memory offset based on the interpreter register number and the system pointer size.  Returns a MemOperand representing this address.\",\n            \"parameters\": [\n                {\n                    \"name\": \"interpreter_register\",\n                    \"type\": \"interpreter::Register\",\n                    \"purpose\": \"The interpreter register to get the frame operand for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"A MemOperand representing the memory location of the register in the frame.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            MemOperand BaselineAssembler::RegisterFrameOperand(\n                interpreter::Register interpreter_register) {\n            return MemOperand(fp, interpreter_register.ToOperand() * kSystemPointerSize);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterFrameAddress\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Calculates the address of a register within the interpreter's register frame and stores it in a scratch register.\",\n            \"logic\": \"Calculates memory address based on interpreter register number and the system pointer size. Address is added to frame pointer and stored in the scratch register\",\n            \"parameters\": [\n                {\n                    \"name\": \"interpreter_register\",\n                    \"type\": \"interpreter::Register\",\n                    \"purpose\": \"The interpreter register to get the frame address for.\"\n                },\n                {\n                    \"name\": \"rscratch\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to store the calculated frame address.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::RegisterFrameAddress(\n                interpreter::Register interpreter_register, Register rscratch) {\n            return __ Add(rscratch, fp,\n                        interpreter_register.ToOperand() * kSystemPointerSize);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FeedbackVectorOperand\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Gets the memory operand for the feedback vector.\",\n            \"logic\": \"Returns a MemOperand representing the feedback vector location using BaselineFrameConstants::kFeedbackVectorFromFp\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"MemOperand for accessing the feedback vector.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            MemOperand BaselineAssembler::FeedbackVectorOperand() {\n            return MemOperand(fp, BaselineFrameConstants::kFeedbackVectorFromFp);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FeedbackCellOperand\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Gets the memory operand for the feedback cell.\",\n            \"logic\": \"Returns a MemOperand representing the feedback cell location using BaselineFrameConstants::kFeedbackCellFromFp.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"MemOperand for accessing the feedback cell.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            MemOperand BaselineAssembler::FeedbackCellOperand() {\n            return MemOperand(fp, BaselineFrameConstants::kFeedbackCellFromFp);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Bind\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Binds a label to the current code position.\",\n            \"logic\": \"Delegates to the underlying MacroAssembler's Bind method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"label\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to bind.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::Bind(Label* label) { __ Bind(label); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpTarget\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Marks the current code position as a potential jump target. Generates a no-op instruction.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"logic\": \"Delegates to the underlying MacroAssembler's JumpTarget method.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpTarget() { __ JumpTarget(); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Jump\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Unconditional jump to a target label.\",\n            \"logic\": \"Delegates to the underlying MacroAssembler's B (branch) instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::Jump(Label* target, Label::Distance distance) {\n            __ B(target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfRoot\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump if a register's value is equal to a specific root value.\",\n            \"logic\": \"Delegates to the underlying MacroAssembler's JumpIfRoot method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the value to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The index of the root value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfRoot(Register value, RootIndex index,\n                                            Label* target, Label::Distance) {\n            __ JumpIfRoot(value, index, target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfNotRoot\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump if a register's value is not equal to a specific root value.\",\n            \"logic\": \"Delegates to the underlying MacroAssembler's JumpIfNotRoot method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the value to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The index of the root value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfNotRoot(Register value, RootIndex index,\n                                            Label* target, Label::Distance) {\n            __ JumpIfNotRoot(value, index, target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump if a register contains a Smi (small integer).\",\n            \"logic\": \"Delegates to the underlying MacroAssembler's JumpIfSmi method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the value to check.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfSmi(Register value, Label* target,\n                                    Label::Distance) {\n            __ JumpIfSmi(value, target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfNotSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump if a register does not contain a Smi (small integer).\",\n            \"logic\": \"Delegates to the underlying MacroAssembler's JumpIfNotSmi method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the value to check.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfNotSmi(Register value, Label* target,\n                                        Label::Distance) {\n            __ JumpIfNotSmi(value, target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfImmediate\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump based on comparison of a register and an immediate value.\",\n            \"logic\": \"Delegates to the JumpIf method, passing the condition, register, immediate operand, target label and distance.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                },\n                {\n                    \"name\": \"left\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"right\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The immediate value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"JumpIf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfImmediate(Condition cc, Register left, int right,\n                                            Label* target,\n                                            Label::Distance distance) {\n            JumpIf(cc, left, Immediate(right), target, distance);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TestAndBranch\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump based on a bitwise test of a register's value.\",\n            \"logic\": \"Performs a bitwise AND between the register and a mask.  If the result satisfies the specified condition (kZero or kNotZero), it jumps to the target.  Uses Tst instruction for general conditions and TestAndBranchIfAllClear/AnySet for kZero/kNotZero conditions\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the value to test.\"\n                },\n                {\n                    \"name\": \"mask\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The bitmask to use for the test.\"\n                },\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check (kZero or kNotZero).\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::TestAndBranch(Register value, int mask, Condition cc,\n                                        Label* target, Label::Distance) {\n            if (cc == kZero) {\n                __ TestAndBranchIfAllClear(value, mask, target);\n            } else if (cc == kNotZero) {\n                __ TestAndBranchIfAnySet(value, mask, target);\n            } else {\n                __ Tst(value, Immediate(mask));\n                __ B(cc, target);\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIf\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump based on comparison of a register and an operand.\",\n            \"logic\": \"Delegates to underlying MacroAssembler's CompareAndBranch instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                },\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const Operand&\",\n                    \"purpose\": \"The operand to compare against (can be a register, immediate, or memory location).\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIf(Condition cc, Register lhs, const Operand& rhs,\n                                    Label* target, Label::Distance) {\n            __ CompareAndBranch(lhs, rhs, cc, target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfJSAnyIsPrimitive\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditionally jumps to the target if the provided register holds a JSAny value that is primitive.\",\n            \"logic\": \"Uses a scratch register to perform the primitive check, then jumps based on the result. Relies on the V8_STATIC_ROOTS_BOOL flag being enabled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"heap_object\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the JSAny value.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is true.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance hint for the target label.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #if V8_STATIC_ROOTS_BOOL\n            void BaselineAssembler::JumpIfJSAnyIsPrimitive(Register heap_object,\n                                                    Label* target,\n                                                    Label::Distance distance) {\n            __ AssertNotSmi(heap_object);\n            ScratchRegisterScope temps(this);\n            Register scratch = temps.AcquireScratch();\n            __ JumpIfJSAnyIsPrimitive(heap_object, scratch, target, distance);\n            }\n            #endif  // V8_STATIC_ROOTS_BOOL\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfObjectTypeFast\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump based on comparing the object type to a given InstanceType.  Optimized for equality/inequality checks.\",\n            \"logic\": \"Acquires a scratch register. Then if the comparison is for equality or inequality, it calls IsObjectType, then branches based on the result. Otherwise calls JumpIfObjectType\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the object to check.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"JumpIfObjectType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfObjectTypeFast(Condition cc, Register object,\n                                                InstanceType instance_type,\n                                                Label* target,\n                                                Label::Distance distance) {\n            ScratchRegisterScope temps(this);\n            Register scratch = temps.AcquireScratch();\n            if (cc == eq || cc == ne) {\n                __ IsObjectType(object, scratch, scratch, instance_type);\n                __ B(cc, target);\n                return;\n            }\n            JumpIfObjectType(cc, object, instance_type, scratch, target, distance);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfObjectType\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump based on comparing the object type to a given InstanceType.\",\n            \"logic\": \"Loads the map of the object, extracts the instance type from the map, and then compares the instance type to the given InstanceType. Jumps to the target based on the result\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the object to check.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type to compare against.\"\n                },\n                {\n                    \"name\": \"map\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to load the map into.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfObjectType(Condition cc, Register object,\n                                            InstanceType instance_type,\n                                            Register map, Label* target,\n                                            Label::Distance) {\n            ScratchRegisterScope temps(this);\n            Register type = temps.AcquireScratch();\n            __ LoadMap(map, object);\n            __ Ldrh(type, FieldMemOperand(map, Map::kInstanceTypeOffset));\n            JumpIf(cc, type, instance_type, target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfInstanceType\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump based on comparing the instance type from map to a given InstanceType.\",\n            \"logic\": \"Loads the instance type from map, and then compares the instance type to the given InstanceType. Uses debug asserts to ensure the given map is actually a map.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                },\n                {\n                    \"name\": \"map\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the map to check.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfInstanceType(Condition cc, Register map,\n                                            InstanceType instance_type,\n                                            Label* target, Label::Distance) {\n            ScratchRegisterScope temps(this);\n            Register type = temps.AcquireScratch();\n            if (v8_flags.debug_code) {\n                __ AssertNotSmi(map);\n                __ CompareObjectType(map, type, type, MAP_TYPE);\n                __ Assert(eq, AbortReason::kUnexpectedValue);\n            }\n            __ Ldrh(type, FieldMemOperand(map, Map::kInstanceTypeOffset));\n            JumpIf(cc, type, instance_type, target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfPointer\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump based on comparison of a register and the value at a memory operand.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"operand\",\n                    \"type\": \"MemOperand\",\n                    \"purpose\": \"The memory operand whose value is to be loaded and compared.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfPointer(Condition cc, Register value,\n                                        MemOperand operand, Label* target,\n                                        Label::Distance) {\n            ScratchRegisterScope temps(this);\n            Register tmp = temps.AcquireScratch();\n            __ Ldr(tmp, operand);\n            JumpIf(cc, value, tmp, target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump based on comparison of a register and a Smi value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"smi\",\n                    \"type\": \"Tagged<Smi>\",\n                    \"purpose\": \"The Smi value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The target label to jump to if the condition is met.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The expected distance to the target label (near/far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void BaselineAssembler::JumpIfSmi(Condition cc, Register value, Tagged<Smi> smi,\n                                    Label* target, Label::Distance distance) {\n            __ AssertSmi(value);\n            __ CompareTaggedAndBranch(value, smi, cc, target);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Conditional jump based on comparison of two registers containing Smi values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check (e.g., eq, ne, lt, gt).\"\n                },\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the left-hand side Smi value.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the right-hand side Smi value.\"\n                },\n                {\n"
}