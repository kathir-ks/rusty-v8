{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/internal/write-barrier.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/internal/write-barrier.h\",\n        \"file_name\": \"write-barrier.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the WriteBarrier class and related functionality for garbage collection in cppgc.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers and cppgc specific headers to provide necessary functionalities like size definitions, heap management, atomic operations, and platform-specific configurations.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <cstddef>\n#include <cstdint>\n\n#include \"cppgc/heap-handle.h\"\n#include \"cppgc/heap-state.h\"\n#include \"cppgc/internal/api-constants.h\"\n#include \"cppgc/internal/atomic-entry-flag.h\"\n#include \"cppgc/internal/base-page-handle.h\"\n#include \"cppgc/internal/member-storage.h\"\n#include \"cppgc/platform.h\"\n#include \"cppgc/sentinel-pointer.h\"\n#include \"cppgc/trace-trait.h\"\n#include \"v8config.h\"  // NOLINT(build/include_directory)\n\n#if defined(CPPGC_CAGED_HEAP)\n#include \"cppgc/internal/caged-heap-local-data.h\"\n#include \"cppgc/internal/caged-heap.h\"\n#endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WriteBarrier\",\n            \"about\": \"Provides write barrier functionality for the garbage collector to track object mutations.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"HeapHandle\",\n                \"AtomicEntryFlag\",\n                \"WriteBarrierTypeForCagedHeapPolicy\",\n                \"WriteBarrierTypeForNonCagedHeapPolicy\",\n                \"CagedHeapLocalData\",\n                \"AgeTable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT WriteBarrier final {\n public:\n  enum class Type : uint8_t {\n    kNone,\n    kMarking,\n    kGenerational,\n  };\n\n  enum class GenerationalBarrierType : uint8_t {\n    kPreciseSlot,\n    kPreciseUncompressedSlot,\n    kImpreciseSlot,\n  };\n\n  struct Params {\n    HeapHandle* heap = nullptr;\n#if V8_ENABLE_CHECKS\n    Type type = Type::kNone;\n#endif  // !V8_ENABLE_CHECKS\n#if defined(CPPGC_CAGED_HEAP)\n    uintptr_t slot_offset = 0;\n    uintptr_t value_offset = 0;\n#endif  // CPPGC_CAGED_HEAP\n  };\n\n  enum class ValueMode {\n    kValuePresent,\n    kNoValuePresent,\n  };\n\n  // Returns the required write barrier for a given `slot` and `value`.\n  static V8_INLINE Type GetWriteBarrierType(const void* slot, const void* value,\n                                            Params& params);\n  // Returns the required write barrier for a given `slot` and `value`.\n  template <typename MemberStorage>\n  static V8_INLINE Type GetWriteBarrierType(const void* slot, MemberStorage,\n                                            Params& params);\n  // Returns the required write barrier for a given `slot`.\n  template <typename HeapHandleCallback>\n  static V8_INLINE Type GetWriteBarrierType(const void* slot, Params& params,\n                                            HeapHandleCallback callback);\n  // Returns the required write barrier for a given  `value`.\n  static V8_INLINE Type GetWriteBarrierType(const void* value, Params& params);\n\n#ifdef CPPGC_SLIM_WRITE_BARRIER\n  // A write barrier that combines `GenerationalBarrier()` and\n  // `DijkstraMarkingBarrier()`. We only pass a single parameter here to clobber\n  // as few registers as possible.\n  template <WriteBarrierSlotType>\n  static V8_NOINLINE void V8_PRESERVE_MOST\n  CombinedWriteBarrierSlow(const void* slot);\n#endif  // CPPGC_SLIM_WRITE_BARRIER\n\n  static V8_INLINE void DijkstraMarkingBarrier(const Params& params,\n                                               const void* object);\n  static V8_INLINE void DijkstraMarkingBarrierRange(\n      const Params& params, const void* first_element, size_t element_size,\n      size_t number_of_elements, TraceCallback trace_callback);\n  static V8_INLINE void SteeleMarkingBarrier(const Params& params,\n                                             const void* object);\n#if defined(CPPGC_YOUNG_GENERATION)\n  template <GenerationalBarrierType>\n  static V8_INLINE void GenerationalBarrier(const Params& params,\n                                            const void* slot);\n#else  // !CPPGC_YOUNG_GENERATION\n  template <GenerationalBarrierType>\n  static V8_INLINE void GenerationalBarrier(const Params& params,\n                                            const void* slot){}\n#endif  // CPPGC_YOUNG_GENERATION\n\n#if V8_ENABLE_CHECKS\n  static void CheckParams(Type expected_type, const Params& params);\n#else   // !V8_ENABLE_CHECKS\n  static void CheckParams(Type expected_type, const Params& params) {}\n#endif  // !V8_ENABLE_CHECKS\n\n  // The FlagUpdater class allows cppgc internal to update\n  // |write_barrier_enabled_|.\n  class FlagUpdater;\n  static bool IsEnabled() { return write_barrier_enabled_.MightBeEntered(); }\n\n private:\n  WriteBarrier() = delete;\n\n#if defined(CPPGC_CAGED_HEAP)\n  using WriteBarrierTypePolicy = WriteBarrierTypeForCagedHeapPolicy;\n#else   // !CPPGC_CAGED_HEAP\n  using WriteBarrierTypePolicy = WriteBarrierTypeForNonCagedHeapPolicy;\n#endif  // !CPPGC_CAGED_HEAP\n\n  static void DijkstraMarkingBarrierSlow(const void* value);\n  static void DijkstraMarkingBarrierSlowWithSentinelCheck(const void* value);\n  static void DijkstraMarkingBarrierRangeSlow(HeapHandle& heap_handle,\n                                              const void* first_element,\n                                              size_t element_size,\n                                              size_t number_of_elements,\n                                              TraceCallback trace_callback);\n  static void SteeleMarkingBarrierSlow(const void* value);\n  static void SteeleMarkingBarrierSlowWithSentinelCheck(const void* value);\n\n#if defined(CPPGC_YOUNG_GENERATION)\n  static CagedHeapLocalData& GetLocalData(HeapHandle&);\n  static void GenerationalBarrierSlow(const CagedHeapLocalData& local_data,\n                                      const AgeTable& age_table,\n                                      const void* slot, uintptr_t value_offset,\n                                      HeapHandle* heap_handle);\n  static void GenerationalBarrierForUncompressedSlotSlow(\n      const CagedHeapLocalData& local_data, const AgeTable& age_table,\n      const void* slot, uintptr_t value_offset, HeapHandle* heap_handle);\n  static void GenerationalBarrierForSourceObjectSlow(\n      const CagedHeapLocalData& local_data, const void* object,\n      HeapHandle* heap_handle);\n#endif  // CPPGC_YOUNG_GENERATION\n\n  static AtomicEntryFlag write_barrier_enabled_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SetAndReturnType\",\n            \"about\": \"Sets the type in the params and returns the type. Used for write barrier type determination.\",\n            \"logic\": \"Conditionally sets the type based on the template parameter and returns the type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"params\",\n                    \"type\": \"WriteBarrier::Params&\",\n                    \"purpose\": \"Reference to the write barrier parameters.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"WriteBarrier::Type\",\n                \"description\": \"The determined write barrier type.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <WriteBarrier::Type type>\nV8_INLINE WriteBarrier::Type SetAndReturnType(WriteBarrier::Params& params) {\n  if constexpr (type == WriteBarrier::Type::kNone)\n    return WriteBarrier::Type::kNone;\n#if V8_ENABLE_CHECKS\n  params.type = type;\n#endif  // !V8_ENABLE_CHECKS\n  return type;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WriteBarrierTypeForCagedHeapPolicy\",\n            \"about\": \"Determines the write barrier type for caged heaps.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"WriteBarrier\",\n                \"CagedHeapBase\",\n                \"BasePageHandle\",\n                \"HeapHandle\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#if defined(CPPGC_CAGED_HEAP)\nclass V8_EXPORT WriteBarrierTypeForCagedHeapPolicy final {\n public:\n  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type Get(const void* slot, const void* value,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback callback) {\n    return ValueModeDispatch<value_mode>::Get(slot, value, params, callback);\n  }\n\n  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback,\n            typename MemberStorage>\n  static V8_INLINE WriteBarrier::Type Get(const void* slot, MemberStorage value,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback callback) {\n    return ValueModeDispatch<value_mode>::Get(slot, value, params, callback);\n  }\n\n  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type Get(const void* value,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback callback) {\n    return GetNoSlot(value, params, callback);\n  }\n\n private:\n  WriteBarrierTypeForCagedHeapPolicy() = delete;\n\n  template <typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type GetNoSlot(const void* value,\n                                                WriteBarrier::Params& params,\n                                                HeapHandleCallback) {\n    const bool within_cage = CagedHeapBase::IsWithinCage(value);\n    if (!within_cage) return WriteBarrier::Type::kNone;\n\n    // We know that |value| points either within the normal page or to the\n    // beginning of large-page, so extract the page header by bitmasking.\n    BasePageHandle* page =\n        BasePageHandle::FromPayload(const_cast<void*>(value));\n\n    HeapHandle& heap_handle = page->heap_handle();\n    if (V8_UNLIKELY(heap_handle.is_incremental_marking_in_progress())) {\n      return SetAndReturnType<WriteBarrier::Type::kMarking>(params);\n    }\n\n    return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n  }\n\n  template <WriteBarrier::ValueMode value_mode>\n  struct ValueModeDispatch;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueModeDispatch\",\n            \"parent\": \"WriteBarrierTypeForCagedHeapPolicy\",\n            \"about\": \"Dispatches based on the value mode for caged heap write barriers.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"WriteBarrier\",\n                \"CagedHeapBase\",\n                \"HeapHandle\",\n                \"AgeTable\",\n                \"CagedHeapLocalData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nstruct WriteBarrierTypeForCagedHeapPolicy::ValueModeDispatch<\n    WriteBarrier::ValueMode::kValuePresent> {\n  template <typename HeapHandleCallback, typename MemberStorage>\n  static V8_INLINE WriteBarrier::Type Get(const void* slot,\n                                          MemberStorage storage,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback) {\n    if (V8_LIKELY(!WriteBarrier::IsEnabled()))\n      return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n\n    return BarrierEnabledGet(slot, storage.Load(), params);\n  }\n\n  template <typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type Get(const void* slot, const void* value,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback) {\n    if (V8_LIKELY(!WriteBarrier::IsEnabled()))\n      return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n\n    return BarrierEnabledGet(slot, value, params);\n  }\n\n private:\n  static V8_INLINE WriteBarrier::Type BarrierEnabledGet(\n      const void* slot, const void* value, WriteBarrier::Params& params) {\n    const bool within_cage = CagedHeapBase::AreWithinCage(slot, value);\n    if (!within_cage) return WriteBarrier::Type::kNone;\n\n    // We know that |value| points either within the normal page or to the\n    // beginning of large-page, so extract the page header by bitmasking.\n    BasePageHandle* page =\n        BasePageHandle::FromPayload(const_cast<void*>(value));\n\n    HeapHandle& heap_handle = page->heap_handle();\n    if (V8_LIKELY(!heap_handle.is_incremental_marking_in_progress())) {\n#if defined(CPPGC_YOUNG_GENERATION)\n      if (!heap_handle.is_young_generation_enabled())\n        return WriteBarrier::Type::kNone;\n      params.heap = &heap_handle;\n      params.slot_offset = CagedHeapBase::OffsetFromAddress(slot);\n      params.value_offset = CagedHeapBase::OffsetFromAddress(value);\n      return SetAndReturnType<WriteBarrier::Type::kGenerational>(params);\n#else   // !CPPGC_YOUNG_GENERATION\n      return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n#endif  // !CPPGC_YOUNG_GENERATION\n    }\n\n    // Use marking barrier.\n    params.heap = &heap_handle;\n    return SetAndReturnType<WriteBarrier::Type::kMarking>(params);\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueModeDispatch\",\n            \"parent\": \"WriteBarrierTypeForCagedHeapPolicy\",\n            \"about\": \"Specialization for no value present.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"WriteBarrier\",\n                \"HeapHandle\",\n                \"CagedHeapBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nstruct WriteBarrierTypeForCagedHeapPolicy::ValueModeDispatch<\n    WriteBarrier::ValueMode::kNoValuePresent> {\n  template <typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type Get(const void* slot, const void*,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback callback) {\n    if (V8_LIKELY(!WriteBarrier::IsEnabled()))\n      return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n\n    HeapHandle& handle = callback();\n#if defined(CPPGC_YOUNG_GENERATION)\n    if (V8_LIKELY(!handle.is_incremental_marking_in_progress())) {\n      if (!handle.is_young_generation_enabled()) {\n        return WriteBarrier::Type::kNone;\n      }\n      params.heap = &handle;\n      // Check if slot is on stack.\n      if (V8_UNLIKELY(!CagedHeapBase::IsWithinCage(slot))) {\n        return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n      }\n      params.slot_offset = CagedHeapBase::OffsetFromAddress(slot);\n      return SetAndReturnType<WriteBarrier::Type::kGenerational>(params);\n    }\n#else   // !defined(CPPGC_YOUNG_GENERATION)\n    if (V8_UNLIKELY(!handle.is_incremental_marking_in_progress())) {\n      return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n    }\n#endif  // !defined(CPPGC_YOUNG_GENERATION)\n    params.heap = &handle;\n    return SetAndReturnType<WriteBarrier::Type::kMarking>(params);\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WriteBarrierTypeForNonCagedHeapPolicy\",\n            \"about\": \"Determines the write barrier type for non-caged heaps.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"WriteBarrier\",\n                \"RawPointer\",\n                \"BasePageHandle\",\n                \"HeapHandle\",\n                \"kSentinelPointer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#endif  // CPPGC_CAGED_HEAP\n\nclass V8_EXPORT WriteBarrierTypeForNonCagedHeapPolicy final {\n public:\n  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type Get(const void* slot, const void* value,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback callback) {\n    return ValueModeDispatch<value_mode>::Get(slot, value, params, callback);\n  }\n\n  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type Get(const void* slot, RawPointer value,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback callback) {\n    return ValueModeDispatch<value_mode>::Get(slot, value.Load(), params,\n                                              callback);\n  }\n\n  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type Get(const void* value,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback callback) {\n    // The slot will never be used in `Get()` below.\n    return Get<WriteBarrier::ValueMode::kValuePresent>(nullptr, value, params,\n                                                       callback);\n  }\n\n private:\n  template <WriteBarrier::ValueMode value_mode>\n  struct ValueModeDispatch;\n\n  WriteBarrierTypeForNonCagedHeapPolicy() = delete;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueModeDispatch\",\n            \"parent\": \"WriteBarrierTypeForNonCagedHeapPolicy\",\n            \"about\": \"Dispatches the write barrier type based on whether a value is present for non-caged heaps.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"WriteBarrier\",\n                \"BasePageHandle\",\n                \"HeapHandle\",\n                \"kSentinelPointer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nstruct WriteBarrierTypeForNonCagedHeapPolicy::ValueModeDispatch<\n    WriteBarrier::ValueMode::kValuePresent> {\n  template <typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type Get(const void*, const void* object,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback callback) {\n    // The following check covers nullptr as well as sentinel pointer.\n    if (object <= static_cast<void*>(kSentinelPointer)) {\n      return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n    }\n    if (V8_LIKELY(!WriteBarrier::IsEnabled())) {\n      return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n    }\n    // We know that |object| is within the normal page or in the beginning of a\n    // large page, so extract the page header by bitmasking.\n    BasePageHandle* page =\n        BasePageHandle::FromPayload(const_cast<void*>(object));\n\n    HeapHandle& heap_handle = page->heap_handle();\n    if (V8_LIKELY(heap_handle.is_incremental_marking_in_progress())) {\n      return SetAndReturnType<WriteBarrier::Type::kMarking>(params);\n    }\n    return SetAndReturnType<WriteBarrier::Type::kNone>(params);\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ValueModeDispatch\",\n            \"parent\": \"WriteBarrierTypeForNonCagedHeapPolicy\",\n            \"about\": \"Specialization of ValueModeDispatch when no value is present.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"WriteBarrier\",\n                \"HeapHandle\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nstruct WriteBarrierTypeForNonCagedHeapPolicy::ValueModeDispatch<\n    WriteBarrier::ValueMode::kNoValuePresent> {\n  template <typename HeapHandleCallback>\n  static V8_INLINE WriteBarrier::Type Get(const void*, const void*,\n                                          WriteBarrier::Params& params,\n                                          HeapHandleCallback callback) {\n    if (V8_UNLIKELY(WriteBarrier::IsEnabled())) {\n      HeapHandle& handle = callback();\n      if (V8_LIKELY(handle.is_incremental_marking_in_progress())) {\n        params.heap = &handle;\n        return SetAndReturnType<WriteBarrier::Type::kMarking>(params);\n      }\n    }\n    return WriteBarrier::Type::kNone;\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetWriteBarrierType\",\n            \"parent\": \"WriteBarrier\",\n            \"about\": \"Determines the write barrier type for a given slot and value.\",\n            \"logic\": \"Uses WriteBarrierTypePolicy to get the write barrier type with value present mode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"slot\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The memory slot being written to.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The value being written.\"\n                },\n                {\n                    \"name\": \"params\",\n                    \"type\": \"WriteBarrier::Params&\",\n                    \"purpose\": \"Parameters for the write barrier.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"WriteBarrier::Type\",\n                \"description\": \"The determined write barrier type.\"\n            },\n            \"dependencies\": [\n                \"WriteBarrierTypePolicy\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nWriteBarrier::Type WriteBarrier::GetWriteBarrierType(\n    const void* slot, const void* value, WriteBarrier::Params& params) {\n  return WriteBarrierTypePolicy::Get<ValueMode::kValuePresent>(slot, value,\n                                                               params, []() {});\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetWriteBarrierType\",\n            \"parent\": \"WriteBarrier\",\n            \"about\": \"Determines the write barrier type for a given slot and member storage.\",\n            \"logic\": \"Uses WriteBarrierTypePolicy to get the write barrier type with value present mode, using member storage.\",\n            \"parameters\": [\n                {\n                    \"name\": \"slot\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The memory slot being written to.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"MemberStorage\",\n                    \"purpose\": \"The value being written, accessed through member storage.\"\n                },\n                {\n                    \"name\": \"params\",\n                    \"type\": \"WriteBarrier::Params&\",\n                    \"purpose\": \"Parameters for the write barrier.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"WriteBarrier::Type\",\n                \"description\": \"The determined write barrier type.\"\n            },\n            \"dependencies\": [\n                \"WriteBarrierTypePolicy\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\ntemplate <typename MemberStorage>\nWriteBarrier::Type WriteBarrier::GetWriteBarrierType(\n    const void* slot, MemberStorage value, WriteBarrier::Params& params) {\n  return WriteBarrierTypePolicy::Get<ValueMode::kValuePresent>(slot, value,\n                                                               params, []() {});\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetWriteBarrierType\",\n            \"parent\": \"WriteBarrier\",\n            \"about\": \"Determines the write barrier type for a given slot using a heap handle callback.\",\n            \"logic\": \"Uses WriteBarrierTypePolicy to get the write barrier type with no value present mode, using a callback to obtain the heap handle.\",\n            \"parameters\": [\n                {\n                    \"name\": \"slot\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The memory slot being written to.\"\n                },\n                {\n                    \"name\": \"params\",\n                    \"type\": \"WriteBarrier::Params&\",\n                    \"purpose\": \"Parameters for the write barrier.\"\n                },\n                {\n                    \"name\": \"callback\",\n                    \"type\": \"HeapHandleCallback\",\n                    \"purpose\": \"Callback to obtain the heap handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"WriteBarrier::Type\",\n                \"description\": \"The determined write barrier type.\"\n            },\n            \"dependencies\": [\n                \"WriteBarrierTypePolicy\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\ntemplate <typename HeapHandleCallback>\nWriteBarrier::Type WriteBarrier::GetWriteBarrierType(\n    const void* slot, WriteBarrier::Params& params,\n    HeapHandleCallback callback) {\n  return WriteBarrierTypePolicy::Get<ValueMode::kNoValuePresent>(\n      slot, nullptr, params, callback);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetWriteBarrierType\",\n            \"parent\": \"WriteBarrier\",\n            \"about\": \"Determines the write barrier type for a given value.\",\n            \"logic\": \"Uses WriteBarrierTypePolicy to get the write barrier type with value present mode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The value being written.\"\n                },\n                {\n                    \"name\": \"params\",\n                    \"type\": \"WriteBarrier::Params&\",\n                    \"purpose\": \"Parameters for the write barrier.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"WriteBarrier::Type\",\n                \"description\": \"The determined write barrier type.\"\n            },\n            \"dependencies\": [\n                \"WriteBarrierTypePolicy\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nWriteBarrier::Type WriteBarrier::GetWriteBarrierType(\n    const void* value, WriteBarrier::Params& params) {\n  return WriteBarrierTypePolicy::Get<ValueMode::kValuePresent>(value, params,\n                                                               []() {});\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DijkstraMarkingBarrier\",\n            \"parent\": \"WriteBarrier\",\n            \"about\": \"Performs the Dijkstra marking barrier operation.\",\n            \"logic\": \"Calls DijkstraMarkingBarrierSlow or DijkstraMarkingBarrierSlowWithSentinelCheck based on whether CPPGC_CAGED_HEAP is defined.  Checks params before the call.\",\n            \"parameters\": [\n                {\n                    \"name\": \"params\",\n                    \"type\": \"const Params&\",\n                    \"purpose\": \"Write barrier parameters.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The object being marked.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CheckParams\",\n                \"DijkstraMarkingBarrierSlow\",\n                \"DijkstraMarkingBarrierSlowWithSentinelCheck\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid WriteBarrier::DijkstraMarkingBarrier(const Params& params,\n                                          const void* object) {\n  CheckParams(Type::kMarking, params);\n#if defined(CPPGC_CAGED_HEAP)\n  // Caged heap already filters out sentinels.\n  DijkstraMarkingBarrierSlow(object);\n#else   // !CPPGC_CAGED_HEAP\n  DijkstraMarkingBarrierSlowWithSentinelCheck(object);\n#endif  // !CPPGC_CAGED_HEAP\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DijkstraMarkingBarrierRange\",\n            \"parent\": \"WriteBarrier\",\n            \"about\": \"Performs the Dijkstra marking barrier operation on a range of elements.\",\n            \"logic\": \"Calls DijkstraMarkingBarrierRangeSlow. Checks params before the call.\",\n            \"parameters\": [\n                {\n                    \"name\": \"params\",\n                    \"type\": \"const Params&\",\n                    \"purpose\": \"Write barrier parameters.\"\n                },\n                {\n                    \"name\": \"first_element\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"Pointer to the first element in the range.\"\n                },\n                {\n                    \"name\": \"element_size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"Size of each element in bytes.\"\n                },\n                {\n                    \"name\": \"number_of_elements\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"Number of elements in the range.\"\n                },\n                {\n                    \"name\": \"trace_callback\",\n                    \"type\": \"TraceCallback\",\n                    \"purpose\": \"Callback for tracing objects.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CheckParams\",\n                \"DijkstraMarkingBarrierRangeSlow\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid WriteBarrier::DijkstraMarkingBarrierRange(const Params& params,\n                                               const void* first_element,\n                                               size_t element_size,\n                                               size_t number_of_elements,\n                                               TraceCallback trace_callback) {\n  CheckParams(Type::kMarking, params);\n  DijkstraMarkingBarrierRangeSlow(*params.heap, first_element, element_size,\n                                  number_of_elements, trace_callback);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SteeleMarkingBarrier\",\n            \"parent\": \"WriteBarrier\",\n            \"about\": \"Performs the Steele marking barrier operation.\",\n            \"logic\": \"Calls SteeleMarkingBarrierSlow or SteeleMarkingBarrierSlowWithSentinelCheck based on whether CPPGC_CAGED_HEAP is defined. Checks params before the call.\",\n            \"parameters\": [\n                {\n                    \"name\": \"params\",\n                    \"type\": \"const Params&\",\n                    \"purpose\": \"Write barrier parameters.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The object being marked.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CheckParams\",\n                \"SteeleMarkingBarrierSlow\",\n                \"SteeleMarkingBarrierSlowWithSentinelCheck\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid WriteBarrier::SteeleMarkingBarrier(const Params& params,\n                                        const void* object) {\n  CheckParams(Type::kMarking, params);\n#if defined(CPPGC_CAGED_HEAP)\n  // Caged heap already filters out sentinels.\n  SteeleMarkingBarrierSlow(object);\n#else   // !CPPGC_CAGED_HEAP\n  SteeleMarkingBarrierSlowWithSentinelCheck(object);\n#endif  // !CPPGC_CAGED_HEAP\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GenerationalBarrier\",\n            \"parent\": \"WriteBarrier\",\n            \"about\": \"Performs the generational barrier operation based on the specified type.\",\n            \"logic\": \"Checks if the slot is in the young generation. If not, dispatches to the appropriate slow path function based on the GenerationalBarrierType. Only compiled when CPPGC_YOUNG_GENERATION is defined.\",\n            \"parameters\": [\n                {\n                    \"name\": \"params\",\n                    \"type\": \"const Params&\",\n                    \"purpose\": \"Write barrier parameters.\"\n                },\n                {\n                    \"name\": \"slot\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The memory slot being written to.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value"
}