{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/types.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/types.cc\",\n            \"file_name\": \"types.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implementation of the Type system for the Torque DSL, including type representations, relations, and operations.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for type definitions, utilities, and data structures.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/types.h\"\n\n#include <cmath>\n#include <iostream>\n#include <optional>\n\n#include \"src/base/bits.h\"\n#include \"src/torque/ast.h\"\n#include \"src/torque/declarable.h\"\n#include \"src/torque/global-context.h\"\n#include \"src/torque/source-positions.h\"\n#include \"src/torque/type-oracle.h\"\n#include \"src/torque/type-visitor.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Type\",\n                \"extends\": \"TypeBase\",\n                \"about\": \"Base class for all types in Torque.  Represents the common properties and operations for all types.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"parent_\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Parent type in the type hierarchy (for subtyping).\"\n                    },\n                    {\n                        \"name\": \"aliases_\",\n                        \"type\": \"std::set<std::string>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of aliases for the type name.\"\n                    },\n                    {\n                        \"name\": \"id_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Unique identifier for the type.\"\n                    },\n                    {\n                        \"name\": \"specialized_from_\",\n                        \"type\": \"MaybeSpecializationKey\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Information about what generic type, if any, this type is a specialization of.\"\n                    },\n                    {\n                        \"name\": \"constexpr_version_\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A constexpr (compile-time constant) version of this type, if one exists.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TypeBase\",\n                    \"TypeOracle\",\n                    \"MaybeSpecializationKey\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::torque {\n\n// This custom copy constructor doesn't copy aliases_ and id_ because they\n// should be distinct for each type.\nType::Type(const Type& other) V8_NOEXCEPT\n    : TypeBase(other),\n      parent_(other.parent_),\n      aliases_(),\n      id_(TypeOracle::FreshTypeId()),\n      constexpr_version_(other.constexpr_version_) {}\nType::Type(TypeBase::Kind kind, const Type* parent,\n           MaybeSpecializationKey specialized_from)\n    : TypeBase(kind),\n      parent_(parent),\n      id_(TypeOracle::FreshTypeId()),\n      specialized_from_(specialized_from),\n      constexpr_version_(nullptr) {}\n\nstd::string Type::ToString() const {\n  if (aliases_.empty())\n    return ComputeName(ToExplicitString(), GetSpecializedFrom());\n  if (aliases_.size() == 1) return *aliases_.begin();\n  std::stringstream result;\n  int i = 0;\n  for (const std::string& alias : aliases_) {\n    if (i == 0) {\n      result << alias << \" (aka. \";\n    } else if (i == 1) {\n      result << alias;\n    } else {\n      result << \", \" << alias;\n    }\n    ++i;\n  }\n  result << \")\";\n  return result.str();\n}\n\nstd::string Type::SimpleName() const {\n  if (aliases_.empty()) {\n    std::stringstream result;\n    result << SimpleNameImpl();\n    if (GetSpecializedFrom()) {\n      for (const Type* t : GetSpecializedFrom()->specialized_types) {\n        result << \"_\" << t->SimpleName();\n      }\n    }\n    return result.str();\n  }\n  return *aliases_.begin();\n}\n\nstd::string Type::GetHandleTypeName(HandleKind kind,\n                                    const std::string& type_name) const {\n  switch (kind) {\n    case HandleKind::kIndirect:\n      return \"Handle<\" + type_name + \">\";\n    case HandleKind::kDirect:\n      return \"DirectHandle<\" + type_name + \">\";\n  }\n}\n\n// TODO(danno): HandlifiedCppTypeName should be used universally in Torque\n// where the C++ type of a Torque object is required.\nstd::string Type::HandlifiedCppTypeName(HandleKind kind) const {\n  if (IsSubtypeOf(TypeOracle::GetSmiType())) return \"int\";\n  if (IsSubtypeOf(TypeOracle::GetTaggedType())) {\n    return GetHandleTypeName(kind, GetConstexprGeneratedTypeName());\n  } else {\n    return GetConstexprGeneratedTypeName();\n  }\n}\n\nstd::string Type::TagglifiedCppTypeName() const {\n  if (IsSubtypeOf(TypeOracle::GetSmiType())) return \"int\";\n  if (IsSubtypeOf(TypeOracle::GetTaggedType())) {\n    return \"Tagged<\" + GetConstexprGeneratedTypeName() + \">\";\n  } else {\n    return GetConstexprGeneratedTypeName();\n  }\n}\n\nbool Type::IsSubtypeOf(const Type* supertype) const {\n  if (supertype->IsTopType()) return true;\n  if (IsNever()) return true;\n  if (const UnionType* union_type = UnionType::DynamicCast(supertype)) {\n    return union_type->IsSupertypeOf(this);\n  }\n  const Type* subtype = this;\n  while (subtype != nullptr) {\n    if (subtype == supertype) return true;\n    subtype = subtype->parent();\n  }\n  return false;\n}\n\nstd::string Type::GetConstexprGeneratedTypeName() const {\n  const Type* constexpr_version = ConstexprVersion();\n  if (constexpr_version == nullptr) {\n    Error(\"Type '\", ToString(), \"' requires a constexpr representation\");\n    return \"\";\n  }\n  return constexpr_version->GetGeneratedTypeName();\n}\n\nstd::optional<const ClassType*> Type::ClassSupertype() const {\n  for (const Type* t = this; t != nullptr; t = t->parent()) {\n    if (auto* class_type = ClassType::DynamicCast(t)) {\n      return class_type;\n    }\n  }\n  return std::nullopt;\n}\n\nstd::optional<const StructType*> Type::StructSupertype() const {\n  for (const Type* t = this; t != nullptr; t = t->parent()) {\n    if (auto* struct_type = StructType::DynamicCast(t)) {\n      return struct_type;\n    }\n  }\n  return std::nullopt;\n}\n\nstd::optional<const AggregateType*> Type::AggregateSupertype() const {\n  for (const Type* t = this; t != nullptr; t = t->parent()) {\n    if (auto* aggregate_type = AggregateType::DynamicCast(t)) {\n      return aggregate_type;\n    }\n  }\n  return std::nullopt;\n}\n\n// static\nconst Type* Type::CommonSupertype(const Type* a, const Type* b) {\n  int diff = a->Depth() - b->Depth();\n  const Type* a_supertype = a;\n  const Type* b_supertype = b;\n  for (; diff > 0; --diff) a_supertype = a_supertype->parent();\n  for (; diff < 0; ++diff) b_supertype = b_supertype->parent();\n  while (a_supertype && b_supertype) {\n    if (a_supertype == b_supertype) return a_supertype;\n    a_supertype = a_supertype->parent();\n    b_supertype = b_supertype->parent();\n  }\n  ReportError(\"types \" + a->ToString() + \" and \" + b->ToString() +\n              \" have no common supertype\");\n}\n\nint Type::Depth() const {\n  int result = 0;\n  for (const Type* current = parent_; current; current = current->parent_) {\n    ++result;\n  }\n  return result;\n}\n\nbool Type::IsAbstractName(const std::string& name) const {\n  if (!IsAbstractType()) return false;\n  return AbstractType::cast(this)->name() == name;\n}\n\nstd::string Type::GetGeneratedTypeName() const {\n  std::string result = GetGeneratedTypeNameImpl();\n  if (result.empty() || result == \"TNode<>\") {\n    ReportError(\"Generated type is required for type '\", ToString(),\n                \"'. Use 'generates' clause in definition.\");\n  }\n  return result;\n}\n\nstd::string Type::GetGeneratedTNodeTypeName() const {\n  std::string result = GetGeneratedTNodeTypeNameImpl();\n  if (result.empty() || IsConstexpr()) {\n    ReportError(\"Generated TNode type is required for type '\", ToString(),\n                \"'. Use 'generates' clause in definition.\");\n  }\n  return result;\n}\n\n// static\nstd::optional<const Type*> Type::MatchUnaryGeneric(const Type* type,\n                                                   GenericType* generic) {\n  DCHECK_EQ(generic->generic_parameters().size(), 1);\n  if (!type->GetSpecializedFrom()) {\n    return std::nullopt;\n  }\n  auto& key = type->GetSpecializedFrom().value();\n  if (key.generic != generic || key.specialized_types.size() != 1) {\n    return std::nullopt;\n  }\n  return {key.specialized_types[0]};\n}\n\nstd::string Type::GetRuntimeType() const {\n  if (IsSubtypeOf(TypeOracle::GetSmiType())) return \"Tagged<Smi>\";\n  if (IsSubtypeOf(TypeOracle::GetTaggedType())) {\n    return \"Tagged<\" + GetGeneratedTNodeTypeName() + \">\";\n  }\n  if (std::optional<const StructType*> struct_type = StructSupertype()) {\n    std::stringstream result;\n    result << \"std::tuple<\";\n    bool first = true;\n    for (const Type* field_type : LowerType(*struct_type)) {\n      if (!first) result << \", \";\n      first = false;\n      result << field_type->GetRuntimeType();\n    }\n    result << \">\";\n    return result.str();\n  }\n  return ConstexprVersion()->GetGeneratedTypeName();\n}\n\nstd::string Type::GetDebugType() const {\n  if (IsSubtypeOf(TypeOracle::GetSmiType())) return \"uintptr_t\";\n  if (IsSubtypeOf(TypeOracle::GetTaggedType())) {\n    return \"uintptr_t\";\n  }\n  if (std::optional<const StructType*> struct_type = StructSupertype()) {\n    std::stringstream result;\n    result << \"std::tuple<\";\n    bool first = true;\n    for (const Type* field_type : LowerType(*struct_type)) {\n      if (!first) result << \", \";\n      first = false;\n      result << field_type->GetDebugType();\n    }\n    result << \">\";\n    return result.str();\n  }\n  return ConstexprVersion()->GetGeneratedTypeName();\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ComputeName\",\n                \"parent\": \"Type\",\n                \"about\": \"Computes the name of a type, potentially including specialization information from generic types.\",\n                \"logic\": \"If the type is a specialization of a generic type, it appends the specialized types within angle brackets to the base name.  Handles const and mutable reference types as special cases.  Otherwise returns the base name.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"basename\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The base name of the type.\"\n                    },\n                    {\n                        \"name\": \"specialized_from\",\n                        \"type\": \"MaybeSpecializationKey\",\n                        \"purpose\": \"Optional specialization information for generic types.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"The computed type name.\"\n                },\n                \"dependencies\": [\n                    \"TypeOracle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// static\nstd::string Type::ComputeName(const std::string& basename,\n                              MaybeSpecializationKey specialized_from) {\n  if (!specialized_from) return basename;\n  if (specialized_from->generic == TypeOracle::GetConstReferenceGeneric()) {\n    return torque::ToString(\"const &\", *specialized_from->specialized_types[0]);\n  }\n  if (specialized_from->generic == TypeOracle::GetMutableReferenceGeneric()) {\n    return torque::ToString(\"&\", *specialized_from->specialized_types[0]);\n  }\n  std::stringstream s;\n  s << basename << \"<\";\n  bool first = true;\n  for (auto t : specialized_from->specialized_types) {\n    if (!first) {\n      s << \", \";\n    }\n    s << t->ToString();\n    first = false;\n  }\n  s << \">\";\n  return s.str();\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AbstractType\",\n                \"extends\": \"Type\",\n                \"about\": \"Represents abstract types in Torque, which are types defined with the 'abstract' keyword.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"generated_type_\",\n                        \"type\": \"std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the name of the generated C++ type for this Torque type.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\",\n                    \"TypeOracle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::string AbstractType::GetGeneratedTypeNameImpl() const {\n  // A special case that is not very well represented by the \"generates\"\n  // syntax in the .tq files: Lazy<T> represents a std::function that\n  // produces a TNode of the wrapped type.\n  if (std::optional<const Type*> type_wrapped_in_lazy =\n          Type::MatchUnaryGeneric(this, TypeOracle::GetLazyGeneric())) {\n    DCHECK(!IsConstexpr());\n    return \"std::function<\" + (*type_wrapped_in_lazy)->GetGeneratedTypeName() +\n           \"()>\";\n  }\n\n  if (generated_type_.empty()) {\n    return parent()->GetGeneratedTypeName();\n  }\n  return IsConstexpr() ? generated_type_ : \"TNode<\" + generated_type_ + \">\";\n}\n\nstd::string AbstractType::GetGeneratedTNodeTypeNameImpl() const {\n  if (generated_type_.empty()) return parent()->GetGeneratedTNodeTypeName();\n  return generated_type_;\n}\n\nstd::vector<TypeChecker> AbstractType::GetTypeCheckers() const {\n  if (UseParentTypeChecker()) return parent()->GetTypeCheckers();\n  std::string type_name = name();\n  if (auto strong_type =\n          Type::MatchUnaryGeneric(this, TypeOracle::GetWeakGeneric())) {\n    auto strong_runtime_types = (*strong_type)->GetTypeCheckers();\n    std::vector<TypeChecker> result;\n    for (const TypeChecker& type : strong_runtime_types) {\n      // Generic parameter in Weak<T> should have already been checked to\n      // extend HeapObject, so it couldn't itself be another weak type.\n      DCHECK(type.weak_ref_to.empty());\n      result.push_back({type_name, type.type});\n    }\n    return result;\n  }\n  return {{type_name, \"\"}};\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BuiltinPointerType\",\n                \"extends\": \"Type\",\n                \"about\": \"Represents the type of a built-in function pointer.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"parameter_types_\",\n                        \"type\": \"TypeVector\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of types representing the parameters of the built-in function.\"\n                    },\n                    {\n                        \"name\": \"return_type_\",\n                        \"type\": \"const Type*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the type that the built-in function returns.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\",\n                    \"TypeVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::string BuiltinPointerType::ToExplicitString() const {\n  std::stringstream result;\n  result << \"builtin (\";\n  PrintCommaSeparatedList(result, parameter_types_);\n  result << \") => \" << *return_type_;\n  return result.str();\n}\n\nstd::string BuiltinPointerType::SimpleNameImpl() const {\n  std::stringstream result;\n  result << \"BuiltinPointer\";\n  for (const Type* t : parameter_types_) {\n    result << \"_\" << t->SimpleName();\n  }\n  result << \"_\" << return_type_->SimpleName();\n  return result.str();\n}\n\nbool BuiltinPointerType::HasContextParameter() const {\n  return FirstTypeIsContext(parameter_types());\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UnionType\",\n                \"extends\": \"Type\",\n                \"about\": \"Represents a union of types in Torque, where a value can be of any of the types in the union.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"types_\",\n                        \"type\": \"std::set<const Type*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The set of types that are part of this union.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\",\n                    \"TypeOracle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::string UnionType::ToExplicitString() const {\n  std::stringstream result;\n  result << \"(\";\n  bool first = true;\n  for (const Type* t : types_) {\n    if (!first) {\n      result << \" | \";\n    }\n    first = false;\n    result << *t;\n  }\n  result << \")\";\n  return result.str();\n}\n\nstd::string UnionType::SimpleNameImpl() const {\n  std::stringstream result;\n  bool first = true;\n  for (const Type* t : types_) {\n    if (!first) {\n      result << \"_OR_\";\n    }\n    first = false;\n    result << t->SimpleName();\n  }\n  return result.str();\n}\n\n// static\nvoid UnionType::InsertGeneratedTNodeTypeName(std::set<std::string>& names,\n                                             const Type* t) {\n  if (t->IsUnionType()) {\n    for (const Type* u : ((const UnionType*)t)->types_) {\n      names.insert(u->GetGeneratedTNodeTypeName());\n    }\n  } else {\n    names.insert(t->GetGeneratedTNodeTypeName());\n  }\n}\n\nstd::string UnionType::GetGeneratedTNodeTypeNameImpl() const {\n  // For non-tagged unions, use the parent GetGeneratedTNodeTypeName.\n  for (const Type* t : types_) {\n    if (!t->IsSubtypeOf(TypeOracle::GetTaggedType())) {\n      return parent()->GetGeneratedTNodeTypeName();\n    }\n  }\n\n  std::string simple_name = SimpleName();\n  if (simple_name == \"Object\") return simple_name;\n  if (simple_name == \"Number\") return simple_name;\n  if (simple_name == \"Numeric\") return simple_name;\n  if (simple_name == \"JSAny\") return simple_name;\n  if (simple_name == \"JSPrimitive\") return simple_name;\n\n  std::set<std::string> names;\n  for (const Type* t : types_) {\n    InsertGeneratedTNodeTypeName(names, t);\n  }\n  std::stringstream result;\n  result << \"Union<\";\n  bool first = true;\n  for (std::string name : names) {\n    if (!first) {\n      result << \", \";\n    }\n    first = false;\n    result << name;\n  }\n  result << \">\";\n  return result.str();\n}\n\nstd::string UnionType::GetRuntimeType() const {\n  for (const Type* t : types_) {\n    if (!t->IsSubtypeOf(TypeOracle::GetTaggedType())) {\n      return parent()->GetRuntimeType();\n    }\n  }\n  return \"Tagged<\" + GetConstexprGeneratedTypeName() + \">\";\n}\n\n// static\nvoid UnionType::InsertConstexprGeneratedTypeName(std::set<std::string>& names,\n                                                 const Type* t) {\n  if (t->IsUnionType()) {\n    for (const Type* u : ((const UnionType*)t)->types_) {\n      names.insert(u->GetConstexprGeneratedTypeName());\n    }\n  } else {\n    names.insert(t->GetConstexprGeneratedTypeName());\n  }\n}\n\nstd::string UnionType::GetConstexprGeneratedTypeName() const {\n  // For non-tagged unions, use the superclass GetConstexprGeneratedTypeName.\n  for (const Type* t : types_) {\n    if (!t->IsSubtypeOf(TypeOracle::GetTaggedType())) {\n      return this->Type::GetConstexprGeneratedTypeName();\n    }\n  }\n\n  // Allow some aliased simple names to be used as-is.\n  std::string simple_name = SimpleName();\n  if (simple_name == \"Object\") return simple_name;\n  if (simple_name == \"Number\") return simple_name;\n  if (simple_name == \"Numeric\") return simple_name;\n  if (simple_name == \"JSAny\") return simple_name;\n  if (simple_name == \"JSPrimitive\") return simple_name;\n\n  // Deduplicate generated typenames and flatten unions.\n  std::set<std::string> names;\n  for (const Type* t : types_) {\n    InsertConstexprGeneratedTypeName(names, t);\n  }\n  std::stringstream result;\n  result << \"Union<\";\n  bool first = true;\n  for (std::string name : names) {\n    if (!first) {\n      result << \", \";\n    }\n    first = false;\n    result << name;\n  }\n  result << \">\";\n  return result.str();\n}\n\nstd::string UnionType::GetDebugType() const { return parent()->GetDebugType(); }\n\nvoid UnionType::RecomputeParent() {\n  const Type* parent = nullptr;\n  for (const Type* t : types_) {\n    if (parent == nullptr) {\n      parent = t;\n    } else {\n      parent = CommonSupertype(parent, t);\n    }\n  }\n  set_parent(parent);\n}\n\nvoid UnionType::Subtract(const Type* t) {\n  for (auto it = types_.begin(); it != types_.end();) {\n    if ((*it)->IsSubtypeOf(t)) {\n      it = types_.erase(it);\n    } else {\n      ++it;\n    }\n  }\n  if (types_.empty()) types_.insert(TypeOracle::GetNeverType());\n  RecomputeParent();\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"SubtractType\",\n                \"about\": \"Subtracts a type from a union type, returning a new union type representing the difference.\",\n                \"logic\": \"Creates a UnionType from the first type, subtracts the second type from it, and then returns the resulting UnionType (obtained via TypeOracle).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"const Type*\",\n                        \"purpose\": \"The type from which to subtract.\"\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"type\": \"const Type*\",\n                        \"purpose\": \"The type to subtract.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const Type*\",\n                    \"description\": \"The resulting type after subtraction.\"\n                },\n                \"dependencies\": [\n                    \"UnionType\",\n                    \"TypeOracle\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconst Type* SubtractType(const Type* a, const Type* b) {\n  UnionType result = UnionType::FromType(a);\n  result.Subtract(b);\n  return TypeOracle::GetUnionType(result);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BitFieldStructType\",\n                \"extends\": \"Type\",\n                \"about\": \"Represents a struct specifically designed to hold bit fields.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"fields_\",\n                        \"type\": \"std::vector<BitField>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the bit fields defined within this struct.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::string BitFieldStructType::ToExplicitString() const {\n  return \"bitfield struct \" + name();\n}\n\nconst BitField& BitFieldStructType::LookupField(const std::string& name) const {\n  for (const BitField& field : fields_) {\n    if (field.name_and_type.name == name) {\n      return field;\n    }\n  }\n  ReportError(\"Couldn't find bitfield \", name);\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AggregateType\",\n                \"extends\": \"Type\",\n                \"about\": \"Base class for types that can contain fields, such as structs and classes.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"fields_\",\n                        \"type\": \"std::vector<Field>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of fields contained within the aggregate type.\"\n                    },\n                    {\n                        \"name\": \"methods_\",\n                        \"type\": \"std::vector<Method*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A vector of methods associated with the aggregate type.\"\n                    },\n                    {\n                        \"name\": \"nspace_\",\n                        \"type\": \"Namespace*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the namespace in which this aggregate type is defined.\"\n                    },\n                    {\n                        \"name\": \"is_finalized_\",\n                        \"type\": \"bool\",\n                        \"access\": \"mutable private\",\n                        \"purpose\": \"A flag indicating whether the type has been finalized (field and method resolution completed).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Type\",\n                    \"Field\",\n                    \"Method\",\n                    \"Namespace\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AggregateType::CheckForDuplicateFields() const {\n  // Check the aggregate hierarchy and currently defined class for duplicate\n  // field declarations.\n  auto hierarchy = GetHierarchy();\n  std::map<std::string, const AggregateType*> field_names;\n  for (const AggregateType* aggregate_type : hierarchy) {\n    for (const Field& field : aggregate_type->fields()) {\n      const std::string& field_name = field.name_and_type.name;\n      auto i = field_names.find(field_name);\n      if (i != field_names.end()) {\n        CurrentSourcePosition::Scope current_source_position(field.pos);\n        std::string aggregate_type_name =\n            aggregate_type->IsClassType() ? \"class\" : \"struct\";\n        if (i->second == this) {\n          ReportError(aggregate_type_name, \" '\", name(),\n                      \"' declares a field with the name '\", field_name,\n                      \"' more than once\");\n        } else {\n          ReportError(aggregate_type_name, \" '\", name(),\n                      \"' declares a field with the name '\", field_name,\n                      \"' that masks an inherited field from class '\",\n                      i->second->name(), \"'\");\n        }\n      }\n      field_names[field_name] = aggregate_type;\n    }\n  }\n}\n\nstd::vector<const AggregateType*> AggregateType::GetHierarchy() const {\n  if (!is_finalized_) Finalize();\n  std::vector<const AggregateType*> hierarchy;\n  const AggregateType* current_container_type = this;\n  while (current_container_type != nullptr) {\n    hierarchy.push_back(current_container_type);\n    current_container_type =\n        current_container_type->IsClassType()\n            ? ClassType::cast(current_container_type)->GetSuperClass()\n            : nullptr;\n  }\n  std::reverse(hierarchy.begin(), hierarchy.end());\n  return hierarchy;\n}\n\nbool AggregateType::HasField(const std::string& name) const {\n  if (!is_finalized_) Finalize();\n  for (auto& field : fields_) {\n    if (field.name_and_type.name == name) return true;\n  }\n  if (parent() != nullptr) {\n    if (auto parent_class = ClassType::DynamicCast(parent())) {\n      return parent_class->HasField(name);\n    }\n  }\n  return false;\n}\n\nconst Field& AggregateType::LookupFieldInternal(const std::string& name) const {\n  for (auto& field : fields_) {\n    if (field.name_and_type.name == name) return field;\n  }\n  if (parent() != nullptr) {\n    if (auto parent_class = ClassType::DynamicCast(parent())) {\n      return parent_class->LookupField(name);\n    }\n  }\n  ReportError(\"no field \", name, \" found in \", this->ToString());\n}\n\nconst Field& AggregateType::LookupField(const std::string& name) const {\n  if (!is_finalized_) Finalize();\n  return LookupFieldInternal(name);\n}\n\nstd::vector<Method*> AggregateType::Methods(const std::string& name) const {\n  if (!is_finalized_) Finalize();\n  std::vector<Method*> result;\n  std::copy_if(methods_.begin(), methods_.end(), std::back_inserter(result),\n               [name](Macro* macro) { return macro->ReadableName() == name; });\n  if (result.empty() && parent() != nullptr) {\n    if (auto aggregate_parent = parent()->AggregateSupertype()) {\n      return (*aggregate_parent)->Methods(name);\n    }\n  }\n  return result;\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StructType\",\n                \"extends\": \"AggregateType\",\n                \"about\": \"Represents a struct type in Torque.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"decl_\",\n                        \"type\": \"const StructDeclaration*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the StructDeclaration AST node that defines this struct.\"\n                    },\n                    {\n                        \"name\": \"generated_type_name_\",\n                        \"type\": \"std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the generated C++ type name for this struct.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AggregateType\",\n                    \"StructDeclaration\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nStructType::StructType(Namespace* nspace, const StructDeclaration* decl,\n                       MaybeSpecializationKey specialized_from)\n    : AggregateType(Kind::kStructType, nullptr, nspace, decl->name->value,\n                    specialized_from),\n      decl_(decl) {\n  if (decl->flags & StructFlag::kExport) {\n    generated_type_name_ = \"TorqueStruct\" + name();\n  } else {\n    generated_type_name_ =\n        GlobalContext::MakeUniqueName(\"TorqueStruct\" + SimpleName());\n  }\n}\n\nstd::string StructType::GetGeneratedTypeNameImpl() const {\n  return generated_type_name_;\n}\n\nsize_t StructType::PackedSize() const {\n  size_t result = 0;\n  for (const Field& field : fields()) {\n    result += std::get<0>(field.GetFieldSizeInformation());\n  }\n  return result;\n}\n\nStructType::Classification StructType::ClassifyContents() const {\n  Classification result = ClassificationFlag::kEmpty;\n  for (const Field& struct_field : fields()) {\n    const Type* field_type = struct_field.name_and_type.type;\n    if (field_type->IsSubtypeOf(TypeOracle::GetStrongTaggedType())) {\n      result |= ClassificationFlag::kStrongTagged;\n    } else if (field_type->IsSubtypeOf(TypeOracle::GetTaggedType())) {\n      result |= ClassificationFlag::kWeakTagged;\n    } else if (auto field_as_struct = field_type->StructSupertype()) {"
}