{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/functional-list.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 261, column 53",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/functional-list.h\",\n        \"file_name\": \"functional-list.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines a generic stack implemented with a singly-linked list for use as a functional list in the compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for iterator base class and zone allocation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/iterator.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FunctionalList\",\n            \"about\": \"A generic stack implemented with a singly-linked list, which results in an O(1) copy operation.  Caches the length of the list in each node.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"base::iterator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class A>\nclass FunctionalList {\n private:\n  struct Cons : ZoneObject {\n    Cons(A top, Cons* rest)\n        : top(std::move(top)), rest(rest), size(1 + (rest ? rest->size : 0)) {}\n    A const top;\n    Cons* const rest;\n    size_t const size;\n  };\n\n public:\n  FunctionalList() : elements_(nullptr) {}\n\n  bool operator==(const FunctionalList<A>& other) const {\n    if (Size() != other.Size()) return false;\n    iterator it = begin();\n    iterator other_it = other.begin();\n    while (true) {\n      if (it == other_it) return true;\n      if (*it != *other_it) return false;\n      ++it;\n      ++other_it;\n    }\n  }\n  bool operator!=(const FunctionalList<A>& other) const {\n    return !(*this == other);\n  }\n\n  bool TriviallyEquals(const FunctionalList<A>& other) const {\n    return elements_ == other.elements_;\n  }\n\n  const A& Front() const {\n    DCHECK_GT(Size(), 0);\n    return elements_->top;\n  }\n\n  FunctionalList Rest() const {\n    FunctionalList result = *this;\n    result.DropFront();\n    return result;\n  }\n\n  void DropFront() {\n    CHECK_GT(Size(), 0);\n    elements_ = elements_->rest;\n  }\n\n  void PushFront(A a, Zone* zone) {\n    elements_ = zone->New<Cons>(std::move(a), elements_);\n  }\n\n  // If {hint} happens to be exactly what we want to allocate, avoid allocation\n  // by reusing {hint}.\n  void PushFront(A a, Zone* zone, FunctionalList hint) {\n    if (hint.Size() == Size() + 1 && hint.Front() == a &&\n        hint.Rest() == *this) {\n      *this = hint;\n    } else {\n      PushFront(a, zone);\n    }\n  }\n\n  // Drop elements until the current stack is equal to the tail shared with\n  // {other}. The shared tail must not only be equal, but also refer to the\n  // same memory.\n  void ResetToCommonAncestor(FunctionalList other) {\n    while (other.Size() > Size()) other.DropFront();\n    while (other.Size() < Size()) DropFront();\n    while (elements_ != other.elements_) {\n      DropFront();\n      other.DropFront();\n    }\n  }\n\n  size_t Size() const { return elements_ ? elements_->size : 0; }\n\n  void Clear() { elements_ = nullptr; }\n\n  class iterator : public base::iterator<std::forward_iterator_tag, A> {\n   public:\n    explicit iterator(Cons* cur) : current_(cur) {}\n\n    const A& operator*() const { return current_->top; }\n    iterator& operator++() {\n      current_ = current_->rest;\n      return *this;\n    }\n    bool operator==(const iterator& other) const {\n      return this->current_ == other.current_;\n    }\n    bool operator!=(const iterator& other) const { return !(*this == other); }\n\n   private:\n    Cons* current_;\n  };\n\n  iterator begin() const { return iterator(elements_); }\n  iterator end() const { return iterator(nullptr); }\n\n private:\n  Cons* elements_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"Cons\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Represents a node in the singly-linked list.\",\n            \"attributes\": [\n                {\n                    \"name\": \"top\",\n                    \"type\": \"A const\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The data stored in this node.\"\n                },\n                {\n                    \"name\": \"rest\",\n                    \"type\": \"Cons* const\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Pointer to the next node in the list.\"\n                },\n                {\n                    \"name\": \"size\",\n                    \"type\": \"size_t const\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The size of the list from this node onwards.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  struct Cons : ZoneObject {\n    Cons(A top, Cons* rest)\n        : top(std::move(top)), rest(rest), size(1 + (rest ? rest->size : 0)) {}\n    A const top;\n    Cons* const rest;\n    size_t const size;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"iterator\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Iterator for the FunctionalList.\",\n            \"attributes\": [\n                {\n                    \"name\": \"current_\",\n                    \"type\": \"Cons*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current node the iterator is pointing to.\"\n                }\n            ],\n            \"dependencies\": [\n                \"base::iterator\",\n                \"Cons\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class iterator : public base::iterator<std::forward_iterator_tag, A> {\n   public:\n    explicit iterator(Cons* cur) : current_(cur) {}\n\n    const A& operator*() const { return current_->top; }\n    iterator& operator++() {\n      current_ = current_->rest;\n      return *this;\n    }\n    bool operator==(const iterator& other) const {\n      return this->current_ == other.current_;\n    }\n    bool operator!=(const iterator& other) const { return !(*this == other); }\n\n   private:\n    Cons* current_;\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FunctionalList\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Constructor for the FunctionalList.\",\n            \"logic\": \"Initializes the list with a null pointer, indicating an empty list.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  FunctionalList() : elements_(nullptr) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator==\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Equality operator for FunctionalList. Compares two lists for equality.\",\n            \"logic\": \"Compares the size and elements of two FunctionalLists. Iterates through both lists simultaneously, comparing the top element of each node.  Returns true if both lists are identical.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const FunctionalList<A>&\",\n                    \"purpose\": \"The FunctionalList to compare with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the lists are equal, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Size\",\n                \"begin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  bool operator==(const FunctionalList<A>& other) const {\n    if (Size() != other.Size()) return false;\n    iterator it = begin();\n    iterator other_it = other.begin();\n    while (true) {\n      if (it == other_it) return true;\n      if (*it != *other_it) return false;\n      ++it;\n      ++other_it;\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator!=\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Inequality operator for FunctionalList.\",\n            \"logic\": \"Returns the negation of the equality operator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const FunctionalList<A>&\",\n                    \"purpose\": \"The FunctionalList to compare with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the lists are not equal, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"operator==\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  bool operator!=(const FunctionalList<A>& other) const {\n    return !(*this == other);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TriviallyEquals\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Checks if two FunctionalLists are trivially equal by comparing their element pointers.\",\n            \"logic\": \"Performs a direct comparison of the internal 'elements_' pointers. This implies that the lists are not only equal in content but also share the exact same underlying memory representation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const FunctionalList<A>&\",\n                    \"purpose\": \"The FunctionalList to compare with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the lists are trivially equal, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  bool TriviallyEquals(const FunctionalList<A>& other) const {\n    return elements_ == other.elements_;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Front\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Returns a const reference to the element at the front of the FunctionalList.\",\n            \"logic\": \"Accesses the 'top' member of the 'elements_' pointer.  Requires that the list is not empty, enforced by DCHECK_GT.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"const A&\",\n                \"description\": \"A const reference to the element at the front of the list.\"\n            },\n            \"dependencies\": [\n                \"Size\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  const A& Front() const {\n    DCHECK_GT(Size(), 0);\n    return elements_->top;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Rest\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Returns a new FunctionalList containing all elements except the first.\",\n            \"logic\": \"Creates a copy of the current FunctionalList and calls DropFront() on the copy.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"FunctionalList\",\n                \"description\": \"A new FunctionalList with the first element removed.\"\n            },\n            \"dependencies\": [\n                \"DropFront\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  FunctionalList Rest() const {\n    FunctionalList result = *this;\n    result.DropFront();\n    return result;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DropFront\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Removes the first element from the FunctionalList.\",\n            \"logic\": \"Sets 'elements_' to point to the 'rest' member of the current first element. Requires that the list is not empty.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Size\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void DropFront() {\n    CHECK_GT(Size(), 0);\n    elements_ = elements_->rest;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PushFront\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Adds a new element to the front of the FunctionalList.\",\n            \"logic\": \"Creates a new Cons node using the provided Zone allocator and sets the 'elements_' pointer to point to the new node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"A\",\n                    \"purpose\": \"The element to add to the front of the list.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone allocator to use for creating the new node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Cons\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void PushFront(A a, Zone* zone) {\n    elements_ = zone->New<Cons>(std::move(a), elements_);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PushFront\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Adds a new element to the front, reusing an existing hint FunctionalList if possible.\",\n            \"logic\": \"Optimized version of PushFront. Checks if the provided 'hint' FunctionalList can be reused instead of allocating a new node. If the 'hint' list has the correct size, the same front element, and its Rest() is equal to the current list, it's directly assigned to the current list to avoid allocation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"A\",\n                    \"purpose\": \"The element to add to the front of the list.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone allocator to use if allocation is needed.\"\n                },\n                {\n                    \"name\": \"hint\",\n                    \"type\": \"FunctionalList\",\n                    \"purpose\": \"A FunctionalList that might be reusable to avoid allocation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Size\",\n                \"Front\",\n                \"Rest\",\n                \"PushFront\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  // If {hint} happens to be exactly what we want to allocate, avoid allocation\n  // by reusing {hint}.\n  void PushFront(A a, Zone* zone, FunctionalList hint) {\n    if (hint.Size() == Size() + 1 && hint.Front() == a &&\n        hint.Rest() == *this) {\n      *this = hint;\n    } else {\n      PushFront(a, zone);\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ResetToCommonAncestor\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Drops elements from both lists until they share a common ancestor.\",\n            \"logic\": \"Efficiently finds the common ancestor between two FunctionalLists by dropping elements from the front of each list until they are equal. The equality check (elements_ != other.elements_) also requires that the lists share the same memory address, ensuring it's not just structural equality but actual shared memory.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"FunctionalList\",\n                    \"purpose\": \"The other FunctionalList to find the common ancestor with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Size\",\n                \"DropFront\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  // Drop elements until the current stack is equal to the tail shared with\n  // {other}. The shared tail must not only be equal, but also refer to the\n  // same memory.\n  void ResetToCommonAncestor(FunctionalList other) {\n    while (other.Size() > Size()) other.DropFront();\n    while (other.Size() < Size()) DropFront();\n    while (elements_ != other.elements_) {\n      DropFront();\n      other.DropFront();\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Size\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Returns the number of elements in the FunctionalList.\",\n            \"logic\": \"Returns the cached size of the list, stored in the 'size' member of the Cons node. If the list is empty (elements_ is nullptr), it returns 0.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The number of elements in the list.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  size_t Size() const { return elements_ ? elements_->size : 0; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Clear\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Clears the FunctionalList, making it empty.\",\n            \"logic\": \"Sets the 'elements_' pointer to nullptr.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void Clear() { elements_ = nullptr; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"iterator\",\n            \"parent\": \"FunctionalList::iterator\",\n            \"about\": \"Constructor for the FunctionalList iterator.\",\n            \"logic\": \"Initializes the iterator with a pointer to the current node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cur\",\n                    \"type\": \"Cons*\",\n                    \"purpose\": \"Pointer to the current Cons node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n    explicit iterator(Cons* cur) : current_(cur) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator*\",\n            \"parent\": \"FunctionalList::iterator\",\n            \"about\": \"Dereference operator for the FunctionalList iterator.\",\n            \"logic\": \"Returns a const reference to the top element of the current node.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"const A&\",\n                \"description\": \"A const reference to the element at the current iterator position.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n    const A& operator*() const { return current_->top; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator++\",\n            \"parent\": \"FunctionalList::iterator\",\n            \"about\": \"Increment operator for the FunctionalList iterator.\",\n            \"logic\": \"Moves the iterator to the next node in the list.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"iterator&\",\n                \"description\": \"A reference to the incremented iterator.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n    iterator& operator++() {\n      current_ = current_->rest;\n      return *this;\n    }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator==\",\n            \"parent\": \"FunctionalList::iterator\",\n            \"about\": \"Equality operator for the FunctionalList iterator.\",\n            \"logic\": \"Compares two iterators for equality by comparing their current node pointers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const iterator&\",\n                    \"purpose\": \"The other iterator to compare with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the iterators are equal, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n    bool operator==(const iterator& other) const {\n      return this->current_ == other.current_;\n    }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"operator!=\",\n            \"parent\": \"FunctionalList::iterator\",\n            \"about\": \"Inequality operator for the FunctionalList iterator.\",\n            \"logic\": \"Returns the negation of the equality operator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const iterator&\",\n                    \"purpose\": \"The other iterator to compare with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the iterators are not equal, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"operator==\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n    bool operator!=(const iterator& other) const { return !(*this == other); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"begin\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Returns an iterator pointing to the beginning of the FunctionalList.\",\n            \"logic\": \"Creates and returns a new iterator initialized with the 'elements_' pointer.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"iterator\",\n                \"description\": \"An iterator pointing to the beginning of the list.\"\n            },\n            \"dependencies\": [\n                \"iterator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  iterator begin() const { return iterator(elements_); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"end\",\n            \"parent\": \"FunctionalList\",\n            \"about\": \"Returns an iterator pointing to the end of the FunctionalList.\",\n            \"logic\": \"Creates and returns a new iterator initialized with a null pointer.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"iterator\",\n                \"description\": \"An iterator pointing to the end of the list.\"\n            },\n            \"dependencies\": [\n                \"iterator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  iterator end() const { return iterator(nullptr); }\n        ]]></code>\n    </func>\n</file>\n```"
}