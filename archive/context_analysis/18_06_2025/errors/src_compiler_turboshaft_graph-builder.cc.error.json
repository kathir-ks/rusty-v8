{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/graph-builder.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/graph-builder.cc\",\n            \"file_name\": \"graph-builder.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Builds a Turboshaft graph from a TurboFan schedule\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard library headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <limits>\n            #include <numeric>\n            #include <optional>\n            #include <string_view>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 base library headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/container-utils.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/base/safe-conversions.h\"\n            #include \"src/base/small-vector.h\"\n            #include \"src/base/vector.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 codegen headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/codegen/bailout-reason.h\"\n            #include \"src/codegen/machine-type.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 common headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 compiler headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/compiler-source-position-table.h\"\n            #include \"src/compiler/fast-api-calls.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/machine-operator.h\"\n            #include \"src/compiler/node-aux-data.h\"\n            #include \"src/compiler/node-matchers.h\"\n            #include \"src/compiler/node-origin-table.h\"\n            #include \"src/compiler/node-properties.h\"\n            #include \"src/compiler/opcodes.h\"\n            #include \"src/compiler/operator.h\"\n            #include \"src/compiler/schedule.h\"\n            #include \"src/compiler/simplified-operator.h\"\n            #include \"src/compiler/state-values-utils.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Turboshaft specific headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/turboshaft/assembler.h\"\n            #include \"src/compiler/turboshaft/deopt-data.h\"\n            #include \"src/compiler/turboshaft/explicit-truncation-reducer.h\"\n            #include \"src/compiler/turboshaft/graph.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/opmasks.h\"\n            #include \"src/compiler/turboshaft/phase.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n            #include \"src/compiler/turboshaft/variable-reducer.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 flag headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/flags/flags.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 heap headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/heap/factory-inl.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 object headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/objects/js-objects.h\"\n            #include \"src/objects/map.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 zone headers\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"GraphBuilder\",\n                \"about\": \"Builds a Turboshaft graph from a TurboFan schedule\",\n                \"attributes\": [\n                    {\n                        \"name\": \"phase_zone\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Zone for managing temporary data during the graph building phase\"\n                    },\n                    {\n                        \"name\": \"schedule\",\n                        \"type\": \"Schedule&\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The TurboFan schedule to translate into a Turboshaft graph\"\n                    },\n                    {\n                        \"name\": \"linkage\",\n                        \"type\": \"Linkage*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Describes the linkage convention used for function calls\"\n                    },\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The V8 isolate\"\n                    },\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Broker for accessing JS heap objects\"\n                    },\n                    {\n                        \"name\": \"graph_zone\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Zone for allocating the Turboshaft graph\"\n                    },\n                    {\n                        \"name\": \"assembler\",\n                        \"type\": \"AssemblerT\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Turboshaft assembler used to construct the graph\"\n                    },\n                    {\n                        \"name\": \"source_positions\",\n                        \"type\": \"SourcePositionTable*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Table for mapping nodes to source positions\"\n                    },\n                    {\n                        \"name\": \"origins\",\n                        \"type\": \"NodeOriginTable*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Table for tracking the origins of nodes\"\n                    },\n                    {\n                        \"name\": \"js_wasm_calls_sidetable\",\n                        \"type\": \"JsWasmCallsSidetable*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Sidetable for tracking js-wasm calls\"\n                    },\n                    {\n                        \"name\": \"pipeline_kind\",\n                        \"type\": \"TurboshaftPipelineKind\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The Turboshaft pipeline kind\"\n                    },\n                    {\n                        \"name\": \"op_mapping\",\n                        \"type\": \"NodeAuxData<OpIndex>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Maps TurboFan nodes to Turboshaft operations\"\n                    },\n                    {\n                        \"name\": \"block_mapping\",\n                        \"type\": \"ZoneVector<BlockData>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Maps TurboFan basic blocks to Turboshaft blocks\"\n                    },\n                    {\n                        \"name\": \"inside_region\",\n                        \"type\": \"bool\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Indicates whether the builder is currently inside a region\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Zone\",\n                    \"Schedule\",\n                    \"Linkage\",\n                    \"Isolate\",\n                    \"JSHeapBroker\",\n                    \"TSAssembler\",\n                    \"SourcePositionTable\",\n                    \"NodeOriginTable\",\n                    \"JsWasmCallsSidetable\",\n                    \"TurboshaftPipelineKind\",\n                    \"NodeAuxData\",\n                    \"OpIndex\",\n                    \"ZoneVector\",\n                    \"BlockData\",\n                    \"ExplicitTruncationReducer\",\n                    \"VariableReducer\",\n                    \"BasicBlock\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct GraphBuilder {\n              Zone* phase_zone;\n              Schedule& schedule;\n              Linkage* linkage;\n\n              Isolate* isolate;\n              JSHeapBroker* broker;\n              Zone* graph_zone;\n              using AssemblerT = TSAssembler<ExplicitTruncationReducer, VariableReducer>;\n              AssemblerT assembler;\n              SourcePositionTable* source_positions;\n              NodeOriginTable* origins;\n              JsWasmCallsSidetable* js_wasm_calls_sidetable;\n              TurboshaftPipelineKind pipeline_kind;\n\n              GraphBuilder(PipelineData* data, Zone* phase_zone, Schedule& schedule,\n                           Linkage* linkage, JsWasmCallsSidetable* js_wasm_calls_sidetable)\n                  : phase_zone(phase_zone),\n                    schedule(schedule),\n                    linkage(linkage),\n                    isolate(data->isolate()),\n                    broker(data->broker()),\n                    graph_zone(data->graph_zone()),\n                    assembler(data, data->graph(), data->graph(), phase_zone),\n                    source_positions(data->source_positions()),\n                    origins(data->node_origins()),\n                    js_wasm_calls_sidetable(js_wasm_calls_sidetable),\n                    pipeline_kind(data->pipeline_kind()) {}\n\n              struct BlockData {\n                Block* block;\n                OpIndex final_frame_state;\n              };\n              NodeAuxData<OpIndex> op_mapping{phase_zone};\n              ZoneVector<BlockData> block_mapping{schedule.RpoBlockCount(), phase_zone};\n              bool inside_region = false;\n\n              std::optional<BailoutReason> Run();\n              AssemblerT& Asm() { return assembler; }\n\n             private:\n              template <typename T>\n              V<T> Map(Node* old_node) {\n                V<T> result = V<T>::Cast(op_mapping.Get(old_node));\n                DCHECK(__ output_graph().IsValid(result));\n                return result;\n              }\n\n              OpIndex Map(Node* old_node) {\n                OpIndex result = op_mapping.Get(old_node);\n                DCHECK(__ output_graph().IsValid(result));\n                return result;\n              }\n\n              Block* Map(BasicBlock* block) {\n                Block* result = block_mapping[block->rpo_number()].block;\n                DCHECK_NOT_NULL(result);\n                return result;\n              }\n\n              void FixLoopPhis(BasicBlock* loop) {\n                DCHECK(loop->IsLoopHeader());\n                for (Node* node : *loop->nodes()) {\n                  if (node->opcode() != IrOpcode::kPhi) {\n                    continue;\n                  }\n                  OpIndex phi_index = Map(node);\n                  PendingLoopPhiOp& pending_phi =\n                      __ output_graph().Get(phi_index).Cast<PendingLoopPhiOp>();\n                  __ output_graph().Replace<PhiOp>(\n                      phi_index,\n                      base::VectorOf({pending_phi.first(), Map(node->InputAt(1))}),\n                      pending_phi.rep);\n                }\n              }\n\n              void ProcessDeoptInput(FrameStateData::Builder* builder, Node* input,\n                                     MachineType type) {\n                DCHECK_NE(input->opcode(), IrOpcode::kObjectState);\n                DCHECK_NE(input->opcode(), IrOpcode::kStateValues);\n                DCHECK_NE(input->opcode(), IrOpcode::kTypedStateValues);\n                if (input->opcode() == IrOpcode::kObjectId) {\n                  builder->AddDematerializedObjectReference(ObjectIdOf(input->op()));\n                } else if (input->opcode() == IrOpcode::kTypedObjectState) {\n                  const TypedObjectStateInfo& info =\n                      OpParameter<TypedObjectStateInfo>(input->op());\n                  int field_count = input->op()->ValueInputCount();\n                  builder->AddDematerializedObject(info.object_id(),\n                                                   static_cast<uint32_t>(field_count));\n                  for (int i = 0; i < field_count; ++i) {\n                    ProcessDeoptInput(builder, input->InputAt(i),\n                                      (*info.machine_types())[i]);\n                  }\n                } else if (input->opcode() == IrOpcode::kArgumentsElementsState) {\n                  builder->AddArgumentsElements(ArgumentsStateTypeOf(input->op()));\n                } else if (input->opcode() == IrOpcode::kArgumentsLengthState) {\n                  builder->AddArgumentsLength();\n                } else {\n                  builder->AddInput(type, Map(input));\n                }\n              }\n\n              void ProcessStateValues(FrameStateData::Builder* builder,\n                                      Node* state_values) {\n                for (auto it = StateValuesAccess(state_values).begin(); !it.done(); ++it) {\n                  if (Node* node = it.node()) {\n                    ProcessDeoptInput(builder, node, (*it).type);\n                  } else {\n                    builder->AddUnusedRegister();\n                  }\n                }\n              }\n\n              void BuildFrameStateData(FrameStateData::Builder* builder,\n                                       compiler::FrameState frame_state) {\n                if (frame_state.outer_frame_state()->opcode() != IrOpcode::kStart) {\n                  builder->AddParentFrameState(Map(frame_state.outer_frame_state()));\n                }\n                ProcessDeoptInput(builder, frame_state.function(),\n                                  MachineType::AnyTagged());\n                ProcessStateValues(builder, frame_state.parameters());\n                ProcessDeoptInput(builder, frame_state.context(), MachineType::AnyTagged());\n                ProcessStateValues(builder, frame_state.locals());\n                Node* stack = frame_state.stack();\n                ProcessStateValues(builder, stack);\n              }\n\n              Block::Kind BlockKind(BasicBlock* block) {\n                switch (block->front()->opcode()) {\n                  case IrOpcode::kStart:\n                  case IrOpcode::kEnd:\n                  case IrOpcode::kMerge:\n                    return Block::Kind::kMerge;\n                  case IrOpcode::kIfTrue:\n                  case IrOpcode::kIfFalse:\n                  case IrOpcode::kIfValue:\n                  case IrOpcode::kIfDefault:\n                  case IrOpcode::kIfSuccess:\n                  case IrOpcode::kIfException:\n                    return Block::Kind::kBranchTarget;\n                  case IrOpcode::kLoop:\n                    return Block::Kind::kLoopHeader;\n                  default:\n                    block->front()->Print();\n                    UNIMPLEMENTED();\n                }\n              }\n              OpIndex Process(Node* node, BasicBlock* block,\n                              const base::SmallVector<int, 16>& predecessor_permutation,\n                              OpIndex& dominating_frame_state,\n                              std::optional<BailoutReason>* bailout,\n                              bool is_final_control = false);\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsValidSmi\",\n                \"about\": \"Checks if a given integer is a valid Smi (small integer)\",\n                \"logic\": \"The function first converts the integer to a Tagged<Object> and then checks if it's a Smi. If it is, it converts the Smi back to an integer and ensures that converting it back to Smi yields the original pointer value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"c\",\n                        \"type\": \"intptr_t\",\n                        \"purpose\": \"The integer to check\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the integer is a valid Smi, false otherwise\"\n                },\n                \"dependencies\": [\n                    \"Object\",\n                    \"Smi\",\n                    \"IsSmi\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool IsValidSmi(intptr_t c) {\n              Tagged<Object> as_obj = Tagged<Object>(c);\n              if (!IsSmi(as_obj)) return false;\n\n              return Smi::FromInt(Smi::ToInt(as_obj)).ptr() == static_cast<uintptr_t>(c);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Run\",\n                \"parent\": \"GraphBuilder\",\n                \"about\": \"Runs the graph building process\",\n                \"logic\": \"Iterates through the schedule's reverse postorder, mapping basic blocks to Turboshaft blocks.  Processes each node within each block, translating TurboFan operations to Turboshaft operations using the 'Process' method. Handles control flow (Goto, Branch, Switch), loop phis, and source position/origin information.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"std::optional<BailoutReason>\",\n                    \"description\": \"An optional BailoutReason if an error occurs during graph building, otherwise std::nullopt\"\n                },\n                \"dependencies\": [\n                    \"BasicBlock\",\n                    \"Block\",\n                    \"Schedule\",\n                    \"BailoutReason\",\n                    \"Map\",\n                    \"Block::IsLoopHeader\",\n                    \"__NewLoopHeader\",\n                    \"__NewBlock\",\n                    \"__Bind\",\n                    \"__Goto\",\n                    \"FixLoopPhis\",\n                    \"OpIndex\",\n                    \"Process\",\n                    \"__current_block\",\n                    \"__output_graph\",\n                    \"SourcePositionTable\",\n                    \"NodeOriginTable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            std::optional<BailoutReason> GraphBuilder::Run() {\n              for (BasicBlock* block : *schedule.rpo_order()) {\n                block_mapping[block->rpo_number()].block =\n                    block->IsLoopHeader() ? __ NewLoopHeader() : __ NewBlock();\n              }\n\n              for (BasicBlock* block : *schedule.rpo_order()) {\n                Block* target_block = Map(block);\n                if (!__ Bind(target_block)) continue;\n\n                // Since we visit blocks in rpo-order, the new block predecessors are sorted\n                // in rpo order too. However, the input schedule does not order\n                // predecessors, so we have to apply a corresponding permutation to phi\n                // inputs.\n                const BasicBlockVector& predecessors = block->predecessors();\n                base::SmallVector<int, 16> predecessor_permutation(predecessors.size());\n                std::iota(predecessor_permutation.begin(), predecessor_permutation.end(),\n                          0);\n                std::sort(predecessor_permutation.begin(), predecessor_permutation.end(),\n                          [&](size_t i, size_t j) {\n                            return predecessors[i]->rpo_number() <\n                                   predecessors[j]->rpo_number();\n                          });\n\n                OpIndex dominating_frame_state = OpIndex::Invalid();\n                if (!predecessors.empty()) {\n                  dominating_frame_state =\n                      block_mapping[predecessors[0]->rpo_number()].final_frame_state;\n                  for (size_t i = 1; i < predecessors.size(); ++i) {\n                    if (block_mapping[predecessors[i]->rpo_number()].final_frame_state !=\n                        dominating_frame_state) {\n                      dominating_frame_state = OpIndex::Invalid();\n                      break;\n                    }\n                  }\n                }\n                std::optional<BailoutReason> bailout = std::nullopt;\n                for (Node* node : *block->nodes()) {\n                  if (V8_UNLIKELY(node->InputCount() >=\n                                  int{std::numeric_limits<\n                                      decltype(Operation::input_count)>::max()})) {\n                    return BailoutReason::kTooManyArguments;\n                  }\n                  OpIndex i = Process(node, block, predecessor_permutation,\n                                      dominating_frame_state, &bailout);\n                  if (V8_UNLIKELY(bailout)) return bailout;\n                  if (!__ current_block()) break;\n                  op_mapping.Set(node, i);\n                }\n                // We have terminated this block with `Unreachable`, so we stop generation\n                // here and continue with the next block.\n                if (!__ current_block()) continue;\n\n                if (Node* node = block->control_input()) {\n                  if (V8_UNLIKELY(node->InputCount() >=\n                                  int{std::numeric_limits<\n                                      decltype(Operation::input_count)>::max()})) {\n                    return BailoutReason::kTooManyArguments;\n                  }\n                  OpIndex i = Process(node, block, predecessor_permutation,\n                                      dominating_frame_state, &bailout, true);\n                  if (V8_UNLIKELY(bailout)) return bailout;\n                  op_mapping.Set(node, i);\n                }\n                switch (block->control()) {\n                  case BasicBlock::kGoto: {\n                    DCHECK_EQ(block->SuccessorCount(), 1);\n                    Block* destination = Map(block->SuccessorAt(0));\n                    __ Goto(destination);\n                    if (destination->IsBound()) {\n                      DCHECK(destination->IsLoop());\n                      FixLoopPhis(block->SuccessorAt(0));\n                    }\n                    break;\n                  }\n                  case BasicBlock::kBranch:\n                  case BasicBlock::kSwitch:\n                  case BasicBlock::kReturn:\n                  case BasicBlock::kDeoptimize:\n                  case BasicBlock::kThrow:\n                  case BasicBlock::kCall:\n                  case BasicBlock::kTailCall:\n                    break;\n                  case BasicBlock::kNone:\n                    UNREACHABLE();\n                }\n                DCHECK_NULL(__ current_block());\n\n                block_mapping[block->rpo_number()].final_frame_state =\n                    dominating_frame_state;\n              }\n\n              if (source_positions && source_positions->IsEnabled()) {\n                for (OpIndex index : __ output_graph().AllOperationIndices()) {\n                  compiler::NodeId origin =\n                      __ output_graph().operation_origins()[index].DecodeTurbofanNodeId();\n                  __ output_graph().source_positions()[index] =\n                      source_positions->GetSourcePosition(origin);\n                }\n              }\n\n              if (origins) {\n                for (OpIndex index : __ output_graph().AllOperationIndices()) {\n                  OpIndex origin = __ output_graph().operation_origins()[index];\n                  origins->SetNodeOrigin(index.id(), origin.DecodeTurbofanNodeId());\n                }\n              }\n\n              return std::nullopt;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Process\",\n                \"parent\": \"GraphBuilder\",\n                \"about\": \"Processes a single TurboFan node and translates it into Turboshaft operations\",\n                \"logic\": \"This is a large switch statement that handles different TurboFan opcodes. It maps TurboFan nodes to their corresponding Turboshaft operations using the TSAssembler.  The exact translation depends on the opcode and may involve creating new Turboshaft operations, calling methods on the TSAssembler, and handling deoptimization and exception handling.  Many opcodes are directly translated to TSAssembler methods.  Handles special cases and architecture-specific optimizations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The TurboFan node to process\"\n                    },\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"BasicBlock*\",\n                        \"purpose\": \"The basic block the node belongs to\"\n                    },\n                    {\n                        \"name\": \"predecessor_permutation\",\n                        \"type\": \"const base::SmallVector<int, 16>&\",\n                        \"purpose\": \"A permutation of the predecessor indices, used to properly order phi inputs\"\n                    },\n                    {\n                        \"name\": \"dominating_frame_state\",\n                        \"type\": \"OpIndex&\",\n                        \"purpose\": \"The dominating frame state for deoptimization\"\n                    },\n                    {\n                        \"name\": \"bailout\",\n                        \"type\": \"std::optional<BailoutReason>*\",\n                        \"purpose\": \"A pointer to an optional BailoutReason, used to signal a bailout\"\n                    },\n                    {\n                        \"name\": \"is_final_control\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"Indicates whether this node is the final control node of the block\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"OpIndex\",\n                    \"description\": \"The OpIndex of the newly created Turboshaft operation\"\n                },\n                \"dependencies\": [\n                    \"Asm\",\n                    \"__SetCurrentOrigin\",\n                    \"op\",\n                    \"Opcode\",\n                    \"IrOpcode\",\n                    \"__CatchBlockBegin\",\n                    \"ParameterInfoOf\",\n                    \"RegisterRepresentation\",\n                    \"linkage\",\n                    \"ParameterIndexOf\",\n                    \"__Parameter\",\n                    \"OsrValueIndexOf\",\n                    \"__OsrValue\",\n                    \"PhiRepresentationOf\",\n                    \"__PendingLoopPhi\",\n                    \"__Phi\",\n                    \"OpIndex\",\n                    \"Block\",\n                    \"BasicBlock\",\n                    \"__HeapConstant\",\n                    \"HeapConstantOf\",\n                    \"ExternalReference\",\n                    \"RelocatablePtrConstantInfo\",\n                    \"Float32Add\",\n                    \"Map\",\n                    \"ObjectIsOp\",\n                    \"OpEffects\",\n                    \"CheckParameters\",\n                    \"CheckTaggedInputParameters\",\n                    \"CheckedBigIntToBigInt64\",\n                    \"ConvertOp\",\n                    \"ConvertJSPrimitiveToUntaggedOp\",\n                    \"TruncateJSPrimitiveToUntaggedOp\",\n                    \"TruncateJSPrimitiveToUntaggedOrDeoptOp\",\n                    \"CheckForMinusZeroMode\",\n                    \"CheckMinusZeroParameters\",\n                    \"ChangeOrDeoptOp\",\n                    \"SelectParameters\",\n                    \"UnalignedStoreRepresentationOf\",\n                    \"FieldAccess\",\n                    \"ConstantOp\",\n                    \"LoadRepresentationOf\",\n                    \"ElementAccess\",\n                    \"StaticAssertSourceOf\",\n                    \"CompareMapsParameters\",\n                    \"TransitionAndStoreArrayElementOp\",\n                    \"ExternalArrayType\",\n                    \"StoreRepresentationOf\",\n                    \"DoubleMapParameter\",\n                    \"CheckMapsParameter\",\n                    \"FastApiCallParameters\",\n                    \"FastApiCallNode\",\n                    \"ValueTypeParameter\",\n                    \"CheckIfParameters\",\n                    \"DeoptimizeParameters\",\n                    \"SameValueOp\",\n                    \"CallDescriptor\",\n                    \"SelectOp\",\n                    \"V\",\n                    \"MachineType\",\n                    \"kAdditiveSafeIntegerShift\",\n                    \"DeoptimizeReason\",\n                    \"FastApiCallFunction\",\n                    \"CheckBoundsParameters\",\n                    \"kBoundedSizeShift\",\n                    \"CheckedClosure\",\n                    \"FeedbackCellOf\",\n                    \"StackCheckKind\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            OpIndex GraphBuilder::Process(\n                Node* node, BasicBlock* block,\n                const base::SmallVector<int, 16>& predecessor_permutation,\n                OpIndex& dominating_frame_state, std::optional<BailoutReason>* bailout,\n                bool is_final_control) {\n              if (Asm().current_block() == nullptr) {\n                return OpIndex::Invalid();\n              }\n              __ SetCurrentOrigin(OpIndex::EncodeTurbofanNodeId(node->id()));\n              const Operator* op = node->op();\n              Operator::Opcode opcode = op->opcode();\n              switch (opcode) {\n                case IrOpcode::kStart:\n                case IrOpcode::kMerge:\n                case IrOpcode::kLoop:\n                case IrOpcode::kIfTrue:\n                case IrOpcode::kIfFalse:\n                case IrOpcode::kIfDefault:\n                case IrOpcode::kIfValue:\n                case IrOpcode::kStateValues:\n                case IrOpcode::kTypedStateValues:\n                case IrOpcode::kObjectId:\n                case IrOpcode::kTypedObjectState:\n                case IrOpcode::kArgumentsElementsState:\n                case IrOpcode::kArgumentsLengthState:\n                case IrOpcode::kEffectPhi:\n                case IrOpcode::kTerminate:\n                  return OpIndex::Invalid();\n\n                case IrOpcode::kCheckpoint: {\n                  // Preserve the frame state from this checkpoint for following nodes.\n                  dominating_frame_state = Map(NodeProperties::GetFrameStateInput(node));\n                  return OpIndex::Invalid();\n                }\n\n                case IrOpcode::kIfException: {\n                  return __ CatchBlockBegin();\n                }\n\n                case IrOpcode::kIfSuccess: {\n                  return OpIndex::Invalid();\n                }\n\n                case IrOpcode::kParameter: {\n                  const ParameterInfo& info = ParameterInfoOf(op);\n                  RegisterRepresentation rep =\n                      RegisterRepresentation::FromMachineRepresentation(\n                          linkage->GetParameterType(ParameterIndexOf(node->op()))\n                              .representation());\n                  return __ Parameter(info.index(), rep, info.debug_name());\n                }\n\n                case IrOpcode::kOsrValue: {\n                  return __ OsrValue(OsrValueIndexOf(op));\n                }\n\n                case IrOpcode::kPhi: {\n                  int input_count = op->ValueInputCount();\n                  RegisterRepresentation rep =\n                      RegisterRepresentation::FromMachineRepresentation(\n                          PhiRepresentationOf(op));\n                  if (__ current_block()->IsLoop()) {\n                    DCHECK_EQ(input_count, 2);\n                    return __ PendingLoopPhi(Map(node->InputAt(0)), rep);\n                  } else {\n                    base::SmallVector<OpIndex, 16> inputs;\n                    for (int i = 0; i < input_count; ++i) {\n                      // If this predecessor end with an unreachable (and doesn't jump to\n                      // this merge block), we skip its Phi input.\n                      Block* pred = Map(block->PredecessorAt(predecessor_permutation[i]));\n                      if (!pred->IsBound() ||\n                          pred->LastOperation(__ output_graph()).Is<UnreachableOp>()) {\n                        continue;\n                      }\n                      inputs.push_back(Map(node->InputAt(predecessor_permutation[i])));\n                    }\n                    return __ Phi(base::VectorOf(inputs), rep);\n                  }\n                }\n\n                case IrOpcode::kInt64Constant:\n                  return __ Word64Constant(static_cast<uint64_t>(OpParameter<int64_t>(op)));\n                case IrOpcode::kInt32Constant:\n                  return __ Word32Constant(static_cast<uint32_t>(OpParameter<int32_t>(op)));\n                case IrOpcode::kFloat64Constant:\n                  return __ Float64Constant(OpParameter<double>(op));\n                case IrOpcode::kFloat32Constant:\n                  return __ Float32Constant(OpParameter<float>(op));\n                case IrOpcode::kNumberConstant:\n                  return __ NumberConstant(OpParameter<double>(op));\n                case IrOpcode::kTaggedIndexConstant:\n                  return __ TaggedIndexConstant(OpParameter<int32_t>(op));\n                case IrOpcode::kHeapConstant:\n                  return __ HeapConstant(HeapConstantOf(op));\n                case IrOpcode::kCompressedHeapConstant:\n                  return __ CompressedHeapConstant(HeapConstantOf(op));\n                case IrOpcode::kTrustedHeapConstant:\n                  return __ TrustedHeapConstant(HeapConstantOf(op));\n                case IrOpcode::kExternalConstant:\n                  return __ ExternalConstant(OpParameter<ExternalReference>(op));\n                case IrOpcode::kRelocatableInt64Constant:\n                  return __ RelocatableConstant(\n                      OpParameter<RelocatablePtrConstantInfo>(op).value(),\n                      OpParameter<RelocatablePtrConstantInfo>(op).rmode());\n#define BINOP_CASE(opcode, assembler_op) \\\n              case IrOpcode::k##opcode:              \\\n                return __ assembler_op(Map(node->InputAt(0)), Map(node->InputAt(1)));\n\n                BINOP_CASE(Int32Add, Word32Add)\n                BINOP_CASE(Int64Add, Word64Add)\n                BINOP_CASE(Int32Mul, Word32Mul)\n                BINOP_CASE(Int64Mul, Word64Mul)\n                BINOP_CASE(Word32And, Word32BitwiseAnd)\n                BINOP_CASE(Word64And, Word64BitwiseAnd)\n                BINOP_CASE(Word32Or, Word32BitwiseOr)\n                BINOP_CASE(Word64Or, Word64BitwiseOr)\n                BINOP_CASE(Word32Xor, Word32BitwiseXor)\n                BINOP_CASE(Word64Xor, Word64BitwiseXor)\n                BINOP_CASE(Int32Sub, Word32Sub)\n                BINOP_CASE(Int64Sub, Word64Sub)\n                BINOP_CASE(Int32Div, Int32Div)\n                BINOP_CASE(Uint32Div, Uint32Div)\n                BINOP_CASE(Int64Div, Int64Div)\n                BINOP_CASE(Uint64Div, Uint64Div)\n                BINOP_CASE(Int32Mod, Int32Mod)\n                BINOP_CASE(Uint32"
}