{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node.h\",\n        \"file_name\": \"node.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Node class, which is a basic primitive used in graphs within the V8 compiler.  It also defines related classes and iterators for traversing the graph.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for globals, graph zone traits, opcodes, operator definitions, turbofan types, and zone containers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/common/globals.h\"\n#include \"src/compiler/graph-zone-traits.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operator.h\"\n#include \"src/compiler/turbofan-types.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Node\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"The basic primitive of graphs. Nodes are chained together by input/use chains.  Contains an identifying number and a mutable Operator.\",\n            \"attributes\": [\n                {\n                    \"name\": \"op_\",\n                    \"type\": \"const Operator*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The operator associated with this node.  Can change during compilation.\"\n                },\n                {\n                    \"name\": \"type_\",\n                    \"type\": \"Type\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The type of the value produced by this node.\"\n                },\n                {\n                    \"name\": \"mark_\",\n                    \"type\": \"Mark\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A mark used during graph traversal to distinguish states of nodes.\"\n                },\n                {\n                    \"name\": \"bit_field_\",\n                    \"type\": \"uint32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A bitfield used to store the node ID, inline count and inline capacity.\"\n                },\n                {\n                    \"name\": \"first_use_\",\n                    \"type\": \"ZoneUsePtr\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the first use of this node in the use chain.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Operator\",\n                \"Edge\",\n                \"TFGraph\",\n                \"Zone\",\n                \"Type\",\n                \"IrOpcode\",\n                \"GraphZoneTraits\",\n                \"base::BitField\",\n                \"base::Vector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE Node final {\n public:\n  static Node* New(Zone* zone, NodeId id, const Operator* op, int input_count,\n                   Node* const* inputs, bool has_extensible_inputs);\n  static Node* Clone(Zone* zone, NodeId id, const Node* node);\n\n  inline bool IsDead() const;\n  void Kill();\n\n  const Operator* op() const { return op_; }\n\n  constexpr IrOpcode::Value opcode() const {\n    DCHECK_GE(IrOpcode::kLast, op_->opcode());\n    return static_cast<IrOpcode::Value>(op_->opcode());\n  }\n\n  NodeId id() const { return IdField::decode(bit_field_); }\n\n  int InputCount() const {\n    return has_inline_inputs() ? InlineCountField::decode(bit_field_)\n                               : outline_inputs()->count_;\n  }\n\n#ifdef DEBUG\n  void Verify();\n#else\n  inline void Verify() {}\n#endif\n\n  Node* InputAt(int index) const {\n    DCHECK_LE(0, index);\n    DCHECK_LT(index, InputCount());\n    return *GetInputPtrConst(index);\n  }\n\n  void ReplaceInput(int index, Node* new_to) {\n    DCHECK_LE(0, index);\n    DCHECK_LT(index, InputCount());\n    ZoneNodePtr* input_ptr = GetInputPtr(index);\n    Node* old_to = *input_ptr;\n    if (old_to != new_to) {\n      Use* use = GetUsePtr(index);\n      if (old_to) old_to->RemoveUse(use);\n      *input_ptr = new_to;\n      if (new_to) new_to->AppendUse(use);\n    }\n  }\n\n  void AppendInput(Zone* zone, Node* new_to);\n  void InsertInput(Zone* zone, int index, Node* new_to);\n  void InsertInputs(Zone* zone, int index, int count);\n  // Returns the removed input.\n  Node* RemoveInput(int index);\n  void NullAllInputs();\n  void TrimInputCount(int new_input_count);\n  // Can trim, extend by appending new inputs, or do nothing.\n  void EnsureInputCount(Zone* zone, int new_input_count);\n\n  int UseCount() const;\n  int BranchUseCount() const;\n  void ReplaceUses(Node* replace_to);\n\n  class InputEdges;\n  inline InputEdges input_edges();\n\n  class Inputs;\n  inline Inputs inputs() const;\n  inline base::Vector<Node*> inputs_vector() const;\n\n  class UseEdges final {\n   public:\n    using value_type = Edge;\n\n    class iterator;\n    inline iterator begin() const;\n    inline iterator end() const;\n\n    bool empty() const;\n\n    explicit UseEdges(Node* node) : node_(node) {}\n\n   private:\n    Node* node_;\n  };\n\n  UseEdges use_edges() { return UseEdges(this); }\n\n  class V8_EXPORT_PRIVATE Uses final {\n   public:\n    using value_type = Node*;\n\n    class const_iterator;\n    inline const_iterator begin() const;\n    inline const_iterator end() const;\n\n    bool empty() const;\n\n    explicit Uses(Node* node) : node_(node) {}\n\n   private:\n    Node* node_;\n  };\n\n  Uses uses() { return Uses(this); }\n\n  // Returns true if {owner} is the only user of {this} node.\n  bool OwnedBy(Node const* owner) const;\n\n  // Returns true if {owner1} and {owner2} are the only users of {this} node.\n  bool OwnedBy(Node const* owner1, Node const* owner2) const;\n\n  void Print() const { Print(1); }\n  void Print(int depth) const;\n  void Print(std::ostream&, int depth = 1) const;\n\n private:\n  template <typename NodePtrT>\n  inline static Node* NewImpl(Zone* zone, NodeId id, const Operator* op,\n                              int input_count, NodePtrT const* inputs,\n                              bool has_extensible_inputs);\n\n  struct Use;\n  using ZoneUsePtr = GraphZoneTraits::Ptr<Use>;\n\n  // Out of line storage for inputs when the number of inputs overflowed the\n  // capacity of the inline-allocated space.\n  struct OutOfLineInputs {\n    ZoneNodePtr node_;\n    int count_;\n    int capacity_;\n\n    // Inputs are allocated right behind the OutOfLineInputs instance.\n    inline ZoneNodePtr* inputs();\n\n    static OutOfLineInputs* New(Zone* zone, int capacity);\n    void ExtractFrom(Use* use_ptr, ZoneNodePtr* input_ptr, int count);\n  };\n  using ZoneOutOfLineInputsPtr = GraphZoneTraits::Ptr<OutOfLineInputs>;\n\n  // A link in the use chain for a node. Every input {i} to a node {n} has an\n  // associated {Use} which is linked into the use chain of the {i} node.\n  struct Use {\n    ZoneUsePtr next;\n    ZoneUsePtr prev;\n    uint32_t bit_field_;\n\n    int input_index() const { return InputIndexField::decode(bit_field_); }\n    bool is_inline_use() const { return InlineField::decode(bit_field_); }\n    ZoneNodePtr* input_ptr() {\n      int index = input_index();\n      Use* start = this + 1 + index;\n      ZoneNodePtr* inputs =\n          is_inline_use() ? reinterpret_cast<Node*>(start)->inline_inputs()\n                          : reinterpret_cast<OutOfLineInputs*>(start)->inputs();\n      return &inputs[index];\n    }\n\n    Node* from() {\n      Use* start = this + 1 + input_index();\n      return is_inline_use() ? reinterpret_cast<Node*>(start)\n                             : reinterpret_cast<OutOfLineInputs*>(start)->node_;\n    }\n\n    using InlineField = base::BitField<bool, 0, 1>;\n    using InputIndexField = base::BitField<unsigned, 1, 31>;\n  };\n\n  //============================================================================\n  //== Memory layout ===========================================================\n  //============================================================================\n  // Saving space for big graphs is important. We use a memory layout trick to\n  // be able to map {Node} objects to {Use} objects and vice-versa in a\n  // space-efficient manner.\n  //\n  // {Use} links are laid out in memory directly before a {Node}, followed by\n  // direct pointers to input {Nodes}.\n  //\n  // inline case:\n  // |Use #N  |Use #N-1|...|Use #1  |Use #0  |Node xxxx |I#0|I#1|...|I#N-1|I#N|\n  //          ^                              ^                  ^\n  //          + Use                          + Node             + Input\n  //\n  // Since every {Use} instance records its {input_index}, pointer arithmetic\n  // can compute the {Node}.\n  //\n  // out-of-line case:\n  //     |Node xxxx |\n  //     ^       + outline ------------------+\n  //     +----------------------------------------+\n  //                                         |    |\n  //                                         v    | node\n  // |Use #N  |Use #N-1|...|Use #1  |Use #0  |OOL xxxxx |I#0|I#1|...|I#N-1|I#N|\n  //          ^                                                 ^\n  //          + Use                                             + Input\n  //\n  // Out-of-line storage of input lists is needed if appending an input to\n  // a node exceeds the maximum inline capacity.\n\n  Node(NodeId id, const Operator* op, int inline_count, int inline_capacity);\n  Node(const Node&) = delete;\n  Node& operator=(const Node&) = delete;\n\n  inline Address inputs_location() const;\n\n  ZoneNodePtr* inline_inputs() const {\n    return reinterpret_cast<ZoneNodePtr*>(inputs_location());\n  }\n  OutOfLineInputs* outline_inputs() const {\n    return *reinterpret_cast<ZoneOutOfLineInputsPtr*>(inputs_location());\n  }\n  void set_outline_inputs(OutOfLineInputs* outline) {\n    *reinterpret_cast<ZoneOutOfLineInputsPtr*>(inputs_location()) = outline;\n  }\n\n  ZoneNodePtr const* GetInputPtrConst(int input_index) const {\n    return has_inline_inputs() ? &(inline_inputs()[input_index])\n                               : &(outline_inputs()->inputs()[input_index]);\n  }\n  ZoneNodePtr* GetInputPtr(int input_index) {\n    return has_inline_inputs() ? &(inline_inputs()[input_index])\n                               : &(outline_inputs()->inputs()[input_index]);\n  }\n  Use* GetUsePtr(int input_index) {\n    Use* ptr = has_inline_inputs() ? reinterpret_cast<Use*>(this)\n                                   : reinterpret_cast<Use*>(outline_inputs());\n    return &ptr[-1 - input_index];\n  }\n\n  void AppendUse(Use* use);\n  void RemoveUse(Use* use);\n\n  void* operator new(size_t, void* location) { return location; }\n\n  // Only NodeProperties should manipulate the op.\n  void set_op(const Operator* op) { op_ = op; }\n\n  // Only NodeProperties should manipulate the type.\n  Type type() const { return type_; }\n  void set_type(Type type) { type_ = type; }\n\n  // Only NodeMarkers should manipulate the marks on nodes.\n  Mark mark() const { return mark_; }\n  void set_mark(Mark mark) { mark_ = mark; }\n\n  inline bool has_inline_inputs() const {\n    return InlineCountField::decode(bit_field_) != kOutlineMarker;\n  }\n\n  void ClearInputs(int start, int count);\n\n  using IdField = base::BitField<NodeId, 0, 24>;\n  using InlineCountField = base::BitField<unsigned, 24, 4>;\n  using InlineCapacityField = base::BitField<unsigned, 28, 4>;\n  static const int kOutlineMarker = InlineCountField::kMax;\n  static const int kMaxInlineCapacity = InlineCapacityField::kMax - 1;\n\n  friend class Edge;\n  friend class NodeMarkerBase;\n  friend class NodeProperties;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Node::inputs_location\",\n            \"parent\": \"Node\",\n            \"about\": \"Calculates the memory address where the inputs are stored, either inline or out-of-line.\",\n            \"logic\": \"Calculates the address by adding the size of the Node object to the base address of the Node.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Address\",\n                \"description\": \"The memory address where the inputs are stored.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nAddress Node::inputs_location() const {\n  return reinterpret_cast<Address>(this) + sizeof(Node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Node::OutOfLineInputs::inputs\",\n            \"parent\": \"Node::OutOfLineInputs\",\n            \"about\": \"Calculates the memory address where the out-of-line inputs are stored.\",\n            \"logic\": \"Calculates the address by adding the size of the OutOfLineInputs object to the base address of the OutOfLineInputs.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"ZoneNodePtr*\",\n                \"description\": \"The memory address where the out-of-line inputs are stored.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nZoneNodePtr* Node::OutOfLineInputs::inputs() {\n  return reinterpret_cast<ZoneNodePtr*>(reinterpret_cast<Address>(this) +\n                                        sizeof(Node::OutOfLineInputs));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"parent\": null,\n            \"about\": \"Overloads the << operator to print a Node to an output stream.\",\n            \"logic\": \"Delegates to the Node::Print(std::ostream&, int) method to print the Node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream to print to.\"\n                },\n                {\n                    \"name\": \"n\",\n                    \"type\": \"const Node&\",\n                    \"purpose\": \"The Node to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, const Node& n);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NodeWrapper\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Base class for node wrappers.\",\n            \"attributes\": [\n                {\n                    \"name\": \"node_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The wrapped node.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Base class for node wrappers.\nclass NodeWrapper {\n public:\n  explicit constexpr NodeWrapper(Node* node) : node_(node) {}\n  operator Node*() const { return node_; }\n  Node* operator->() const { return node_; }\n\n protected:\n  Node* node() const { return node_; }\n  void set_node(Node* node) {\n    DCHECK_NOT_NULL(node);\n    node_ = node;\n  }\n\n private:\n  Node* node_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Effect\",\n            \"extends\": \"NodeWrapper\",\n            \"implements\": [],\n            \"about\": \"Wrapper class for effect nodes.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Node\",\n                \"NodeWrapper\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass Effect : public NodeWrapper {\n public:\n  explicit constexpr Effect(Node* node) : NodeWrapper(node) {\n    // TODO(jgruber): Remove the End special case.\n    SLOW_DCHECK(node == nullptr || node->op()->opcode() == IrOpcode::kEnd ||\n                node->op()->EffectOutputCount() > 0);\n  }\n\n  // Support the common `Node* x = effect = ...` pattern.\n  Node* operator=(Node* value) {\n    DCHECK_GT(value->op()->EffectOutputCount(), 0);\n    set_node(value);\n    return value;\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Control\",\n            \"extends\": \"NodeWrapper\",\n            \"implements\": [],\n            \"about\": \"Wrapper class for control nodes.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Node\",\n                \"NodeWrapper\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass Control : public NodeWrapper {\n public:\n  explicit constexpr Control(Node* node) : NodeWrapper(node) {\n    // TODO(jgruber): Remove the End special case.\n    SLOW_DCHECK(node == nullptr || node->opcode() == IrOpcode::kEnd ||\n                node->op()->ControlOutputCount() > 0);\n  }\n\n  // Support the common `Node* x = control = ...` pattern.\n  Node* operator=(Node* value) {\n    DCHECK_GT(value->op()->ControlOutputCount(), 0);\n    set_node(value);\n    return value;\n  }\n};\n        ]]></code>\n    </class>\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"NodeDeque\",\n            \"about\": \"Typedef for a zone-allocated deque of Node pointers.\",\n            \"dependencies\": [\n                \"Node\",\n                \"ZoneDeque\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nusing NodeDeque = ZoneDeque<Node*>;\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"NodeSet\",\n            \"about\": \"Typedef for a zone-allocated set of Node pointers.\",\n            \"dependencies\": [\n                \"Node\",\n                \"ZoneSet\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nusing NodeSet = ZoneSet<Node*>;\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"NodeVector\",\n            \"about\": \"Typedef for a zone-allocated vector of Node pointers.\",\n            \"dependencies\": [\n                \"Node\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nusing NodeVector = ZoneVector<Node*>;\n        ]]></code>\n    </typedef>\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"typedef\",\n            \"name\": \"NodeVectorVector\",\n            \"about\": \"Typedef for a zone-allocated vector of NodeVector.\",\n            \"dependencies\": [\n                \"NodeVector\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nusing NodeVectorVector = ZoneVector<NodeVector>;\n        ]]></code>\n    </typedef>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Node::InputEdges\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents the input edges of a node.\",\n            \"attributes\": [\n                {\n                    \"name\": \"input_root_\",\n                    \"type\": \"ZoneNodePtr*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the beginning of the input array.\"\n                },\n                {\n                    \"name\": \"use_root_\",\n                    \"type\": \"Use*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the beginning of the use array.\"\n                },\n                {\n                    \"name\": \"count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of inputs.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Edge\",\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass Node::InputEdges final {\n public:\n  using value_type = Edge;\n\n  class iterator;\n  inline iterator begin() const;\n  inline iterator end() const;\n\n  bool empty() const { return count_ == 0; }\n  int count() const { return count_; }\n\n  inline value_type operator[](int index) const;\n\n  InputEdges(ZoneNodePtr* input_root, Use* use_root, int count)\n      : input_root_(input_root), use_root_(use_root), count_(count) {}\n\n private:\n  ZoneNodePtr* input_root_;\n  Use* use_root_;\n  int count_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Node::Inputs\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents the inputs of a node.\",\n            \"attributes\": [\n                {\n                    \"name\": \"input_root_\",\n                    \"type\": \"ZoneNodePtr const*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the beginning of the input array.\"\n                },\n                {\n                    \"name\": \"count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of inputs.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE Node::Inputs final {\n public:\n  using value_type = Node*;\n\n  class const_iterator;\n  inline const_iterator begin() const;\n  inline const_iterator end() const;\n\n  bool empty() const { return count_ == 0; }\n  int count() const { return count_; }\n\n  inline value_type operator[](int index) const;\n\n  explicit Inputs(ZoneNodePtr const* input_root, int count)\n      : input_root_(input_root), count_(count) {}\n\n private:\n  ZoneNodePtr const* input_root_;\n  int count_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Edge\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Encapsulates information associated with a single use of a node as an input from another node.\",\n            \"attributes\": [\n                {\n                    \"name\": \"use_\",\n                    \"type\": \"Node::Use*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the Use structure representing the edge.\"\n                },\n                {\n                    \"name\": \"input_ptr_\",\n                    \"type\": \"ZoneNodePtr*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the input node in the input array of the using node.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// An encapsulation for information associated with a single use of a node as an\n// input from another node, allowing access to both the defining node and\n// the node having the input.\nclass Edge final {\n public:\n  Node* from() const { return use_->from(); }\n  Node* to() const { return *input_ptr_; }\n  int index() const {\n    int const index = use_->input_index();\n    DCHECK_LT(index, use_->from()->InputCount());\n    return index;\n  }\n\n  bool operator==(const Edge& other) { return input_ptr_ == other.input_ptr_; }\n  bool operator!=(const Edge& other) { return !(*this == other); }\n\n  void UpdateTo(Node* new_to) {\n    Node* old_to = *input_ptr_;\n    if (old_to != new_to) {\n      if (old_to) old_to->RemoveUse(use_);\n      *input_ptr_ = new_to;\n      if (new_to) new_to->AppendUse(use_);\n    }\n  }\n\n private:\n  friend class Node::UseEdges::iterator;\n  friend class Node::InputEdges;\n  friend class Node::InputEdges::iterator;\n\n  Edge(Node::Use* use, ZoneNodePtr* input_ptr)\n      : use_(use), input_ptr_(input_ptr) {\n    DCHECK_NOT_NULL(use);\n    DCHECK_NOT_NULL(input_ptr);\n    DCHECK_EQ(input_ptr, use->input_ptr());\n  }\n\n  Node::Use* use_;\n  ZoneNodePtr* input_ptr_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Node::IsDead\",\n            \"parent\": \"Node\",\n            \"about\": \"Checks if a node is dead.\",\n            \"logic\": \"A node is considered dead if it has inputs and the first input is null.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the node is dead, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Node::IsDead() const {\n  Node::Inputs inputs = this->inputs();\n  return inputs.count() > 0 && inputs[0] == nullptr;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Node::input_edges\",\n            \"parent\": \"Node\",\n            \"about\": \"Returns an InputEdges object for iterating over the input edges of the node.\",\n            \"logic\": \"Creates an InputEdges object based on whether the inputs are stored inline or out-of-line.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Node::InputEdges\",\n                \"description\": \"An InputEdges object for iterating over the input edges.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Node::InputEdges\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode::InputEdges Node::input_edges() {\n  int inline_count = InlineCountField::decode(bit_field_);\n  if (inline_count != kOutlineMarker) {\n    return InputEdges(inline_inputs(), reinterpret_cast<Use*>(this) - 1,\n                      inline_count);\n  } else {\n    return InputEdges(outline_inputs()->inputs(),\n                      reinterpret_cast<Use*>(outline_inputs()) - 1,\n                      outline_inputs()->count_);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Node::inputs\",\n            \"parent\": \"Node\",\n            \"about\": \"Returns an Inputs object for iterating over the inputs of the node.\",\n            \"logic\": \"Creates an Inputs object based on whether the inputs are stored inline or out-of-line.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Node::Inputs\",\n                \"description\": \"An Inputs object for iterating over the inputs.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Node::Inputs\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode::Inputs Node::inputs() const {\n  int inline_count = InlineCountField::decode(bit_field_);\n  if (inline_count != kOutlineMarker) {\n    return Inputs(inline_inputs(), inline_count);\n  } else {\n    return Inputs(outline_inputs()->inputs(), outline_inputs()->count_);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Node::inputs_vector\",\n            \"parent\": \"Node\",\n            \"about\": \"Returns a base::Vector of Node pointers representing the inputs of the node.\",\n            \"logic\": \"Creates a base::Vector based on whether the inputs are stored inline or out-of-line.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"base::Vector<Node*>\",\n                \"description\": \"A base::Vector of Node pointers representing the inputs.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"base::Vector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbase::Vector<Node*> Node::inputs_vector() const {\n  int inline_count = InlineCountField::decode(bit_field_);\n  if (inline_count != kOutlineMarker) {\n    return base::VectorOf<Node*>(inline_inputs(), inline_count);\n  } else {\n    return base::VectorOf<Node*>(outline_inputs()->inputs(),\n                                 outline_inputs()->count_);\n  }\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Node::InputEdges::iterator\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Iterator for InputEdges.\",\n            \"attributes\": [\n                {\n                    \"name\": \"use_\",\n                    \"type\": \"Use*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current Use*.\"\n                },\n                {\n                    \"name\": \"input_ptr_\",\n                    \"type\": \"ZoneNodePtr*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current ZoneNodePtr* (input).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\",\n                \"Edge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// A forward iterator to visit the edges for the input dependencies of a node.\nclass Node::InputEdges::iterator final {\n public:\n  using iterator_category = std::forward_iterator_tag;\n  using difference_type = std::ptrdiff_t;\n  using value_type = Edge;\n  using pointer = Edge*;\n  using reference = Edge&;\n\n  iterator() : use_(nullptr), input_ptr_(nullptr) {}\n  iterator(const iterator& other) = default;\n\n  Edge operator*() const { return Edge(use_, input_ptr_); }\n  bool operator==(const iterator& other) const {\n    return input_ptr_ == other.input_ptr_;\n  }\n  bool operator!=(const iterator& other) const { return !(*this == other); }\n  iterator& operator++() {\n    input_ptr_++;\n    use_--;\n    return *this;\n  }\n  iterator operator++(int);\n  iterator& operator+=(difference_type offset) {\n    input_ptr_ += offset;\n    use_ -= offset;\n    return *this;\n  }\n  iterator operator+(difference_type offset) const {\n    return iterator(use_ - offset, input_ptr_ + offset);\n  }\n  difference_type operator-(const iterator& other) const {\n    return input_ptr_ - other.input_ptr_;\n  }\n\n private:\n  friend class Node;\n\n  explicit iterator(Use* use, ZoneNodePtr* input_ptr)\n      : use_(use), input_ptr_(input_ptr) {}\n\n  Use* use_;\n  ZoneNodePtr* input_ptr_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Node::InputEdges::"
}