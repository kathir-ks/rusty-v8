{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/mips64/simulator-mips64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/mips64/simulator-mips64.cc\",\n        \"file_name\": \"simulator-mips64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the MIPS64 simulator for running V8 JavaScript engine code on non-MIPS64 hardware.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for simulator functionality, standard libraries, V8 internals, code generation, diagnostics, heap management, runtime utilities, and output streams.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/mips64/simulator-mips64.h\"\n\n// Only build the simulator if not compiling for real MIPS hardware.\n#if defined(USE_SIMULATOR)\n\n#include <limits.h>\n#include <stdarg.h>\n#include <stdlib.h>\n\n#include <cmath>\n\n#include \"src/base/bits.h\"\n#include \"src/base/platform/memory.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/base/strings.h\"\n#include \"src/base/vector.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/codegen/mips64/constants-mips64.h\"\n#include \"src/diagnostics/disasm.h\"\n#include \"src/heap/combined-heap.h\"\n#include \"src/runtime/runtime-utils.h\"\n#include \"src/utils/ostreams.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Simulator::GlobalMonitor\",\n            \"about\": \"Manages global monitor for simulator\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nDEFINE_LAZY_LEAKY_OBJECT_GETTER(Simulator::GlobalMonitor,\n                                Simulator::GlobalMonitor::Get)\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"HaveSameSign\",\n            \"about\": \"Checks if two 64-bit integers have the same sign.\",\n            \"logic\": \"Uses bitwise XOR to check if the sign bits are the same.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"First integer.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"Second integer.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if both integers have same sign, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ninline bool HaveSameSign(int64_t a, int64_t b) { return ((a ^ b) >= 0); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"isMipsSupportUnalignedAccess\",\n            \"about\": \"Global variable indicating whether the MIPS architecture supports unaligned memory access.\",\n            \"logic\": \"Defaults to true, but can be configured based on the environment.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if unaligned access is supported, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool isMipsSupportUnalignedAccess = true;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"get_fcsr_condition_bit\",\n            \"about\": \"Calculates the bit position in the FCSR (Floating-Point Control and Status Register) corresponding to a given condition code.\",\n            \"logic\": \"If cc is 0, return bit 23. Otherwise, return 24 + cc.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"Condition code.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"uint32_t\",\n                \"description\": \"The bit position in FCSR.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nuint32_t get_fcsr_condition_bit(uint32_t cc) {\n  if (cc == 0) {\n    return 23;\n  } else {\n    return 24 + cc;\n  }\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MipsDebugger\",\n            \"about\": \"Provides debugging functionality for the MIPS simulator, including breakpoints, register inspection, and disassembly.\",\n            \"attributes\": [\n                {\n                    \"name\": \"sim_\",\n                    \"type\": \"Simulator*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the simulator instance.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Simulator\",\n                \"Instruction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass MipsDebugger {\n public:\n  explicit MipsDebugger(Simulator* sim) : sim_(sim) {}\n\n  void Stop(Instruction* instr);\n  void Debug();\n  // Print all registers with a nice formatting.\n  void PrintAllRegs();\n  void PrintAllRegsIncludingFPU();\n\n private:\n  // We set the breakpoint code to 0xFFFFF to easily recognize it.\n  static const Instr kBreakpointInstr = SPECIAL | BREAK | 0xFFFFF << 6;\n  static const Instr kNopInstr = 0x0;\n\n  Simulator* sim_;\n\n  int64_t GetRegisterValue(int regnum);\n  int64_t GetFPURegisterValue(int regnum);\n  float GetFPURegisterValueFloat(int regnum);\n  double GetFPURegisterValueDouble(int regnum);\n  bool GetValue(const char* desc, int64_t* value);\n\n  // Set or delete a breakpoint. Returns true if successful.\n  bool SetBreakpoint(Instruction* breakpc);\n  bool DeleteBreakpoint(Instruction* breakpc);\n\n  // Undo and redo all breakpoints. This is needed to bracket disassembly and\n  // execution to skip past breakpoints when run from the debugger.\n  void UndoBreakpoints();\n  void RedoBreakpoints();\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"UNSUPPORTED\",\n            \"about\": \"Prints a message indicating that an unsupported instruction was encountered.\",\n            \"logic\": \"Prints the error message to stdout.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ninline void UNSUPPORTED() { printf(\"Sim: Unsupported instruction.\\n\"); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Stop\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Stops the simulator execution and enters the debugger.\",\n            \"logic\": \"Prints the stop code and then calls the Debug method to enter the debugger shell.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"Pointer to the instruction that triggered the stop.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"Debug\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MipsDebugger::Stop(Instruction* instr) {\n  // Get the stop code.\n  uint32_t code = instr->Bits(25, 6);\n  PrintF(\"Simulator hit (%u)\\n\", code);\n  Debug();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetRegisterValue\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Retrieves the value of a given register.\",\n            \"logic\": \"If the register number is equal to kNumSimuRegisters, returns the program counter (PC). Otherwise, returns the value of the specified register from the simulator's register array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"regnum\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The register number to retrieve.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int64_t\",\n                \"description\": \"The value of the register.\"\n            },\n            \"dependencies\": [\n                \"Simulator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint64_t MipsDebugger::GetRegisterValue(int regnum) {\n  if (regnum == kNumSimuRegisters) {\n    return sim_->get_pc();\n  } else {\n    return sim_->get_register(regnum);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetFPURegisterValue\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Retrieves the value of a given FPU register.\",\n            \"logic\": \"If the register number is equal to kNumFPURegisters, returns the program counter (PC). Otherwise, returns the value of the specified register from the simulator's FPU register array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"regnum\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The register number to retrieve.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int64_t\",\n                \"description\": \"The value of the FPU register.\"\n            },\n            \"dependencies\": [\n                \"Simulator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint64_t MipsDebugger::GetFPURegisterValue(int regnum) {\n  if (regnum == kNumFPURegisters) {\n    return sim_->get_pc();\n  } else {\n    return sim_->get_fpu_register(regnum);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetFPURegisterValueFloat\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Retrieves the float value of a given FPU register.\",\n            \"logic\": \"If the register number is equal to kNumFPURegisters, returns the program counter (PC). Otherwise, returns the float value of the specified register from the simulator's FPU register array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"regnum\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The register number to retrieve.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float\",\n                \"description\": \"The float value of the FPU register.\"\n            },\n            \"dependencies\": [\n                \"Simulator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nfloat MipsDebugger::GetFPURegisterValueFloat(int regnum) {\n  if (regnum == kNumFPURegisters) {\n    return sim_->get_pc();\n  } else {\n    return sim_->get_fpu_register_float(regnum);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetFPURegisterValueDouble\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Retrieves the double value of a given FPU register.\",\n            \"logic\": \"If the register number is equal to kNumFPURegisters, returns the program counter (PC). Otherwise, returns the double value of the specified register from the simulator's FPU register array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"regnum\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The register number to retrieve.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"double\",\n                \"description\": \"The double value of the FPU register.\"\n            },\n            \"dependencies\": [\n                \"Simulator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ndouble MipsDebugger::GetFPURegisterValueDouble(int regnum) {\n  if (regnum == kNumFPURegisters) {\n    return sim_->get_pc();\n  } else {\n    return sim_->get_fpu_register_double(regnum);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetValue\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Retrieves the value of a register or a memory address based on a given description.\",\n            \"logic\": \"Attempts to interpret the description as a register name (using Registers::Number and FPURegisters::Number) or a hexadecimal/decimal number (using sscanf).\",\n            \"parameters\": [\n                {\n                    \"name\": \"desc\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The description of the register or address to retrieve.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int64_t*\",\n                    \"purpose\": \"Pointer to store the retrieved value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the value was successfully retrieved, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Registers\",\n                \"FPURegisters\",\n                \"SScanF\",\n                \"GetRegisterValue\",\n                \"GetFPURegisterValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MipsDebugger::GetValue(const char* desc, int64_t* value) {\n  int regnum = Registers::Number(desc);\n  int fpuregnum = FPURegisters::Number(desc);\n\n  if (regnum != kInvalidRegister) {\n    *value = GetRegisterValue(regnum);\n    return true;\n  } else if (fpuregnum != kInvalidFPURegister) {\n    *value = GetFPURegisterValue(fpuregnum);\n    return true;\n  } else if (strncmp(desc, \"0x\", 2) == 0) {\n    return SScanF(desc + 2, \"%\" SCNx64, reinterpret_cast<uint64_t*>(value)) ==\n           1;\n  } else {\n    return SScanF(desc, \"%\" SCNu64, reinterpret_cast<uint64_t*>(value)) == 1;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetBreakpoint\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Sets a breakpoint at a given instruction address.\",\n            \"logic\": \"Checks if a breakpoint can be set. If so it sets breakpoint at given address. Returns true if successful. Stores previous instruction bits.\",\n            \"parameters\": [\n                {\n                    \"name\": \"breakpc\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The address at which to set the breakpoint.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if breakpoint was set, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Simulator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MipsDebugger::SetBreakpoint(Instruction* breakpc) {\n  // Check if a breakpoint can be set. If not return without any side-effects.\n  if (sim_->break_pc_ != nullptr) {\n    return false;\n  }\n\n  // Set the breakpoint.\n  sim_->break_pc_ = breakpc;\n  sim_->break_instr_ = breakpc->InstructionBits();\n  // Not setting the breakpoint instruction in the code itself. It will be set\n  // when the debugger shell continues.\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DeleteBreakpoint\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Deletes a breakpoint.\",\n            \"logic\": \"Restores the instruction bits at the breakpoint address and resets the simulator's breakpoint state.\",\n            \"parameters\": [\n                {\n                    \"name\": \"breakpc\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The address at which the breakpoint is to be deleted.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the breakpoint was deleted, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Simulator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MipsDebugger::DeleteBreakpoint(Instruction* breakpc) {\n  if (sim_->break_pc_ != nullptr) {\n    sim_->break_pc_->SetInstructionBits(sim_->break_instr_);\n  }\n\n  sim_->break_pc_ = nullptr;\n  sim_->break_instr_ = 0;\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UndoBreakpoints\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Removes any set breakpoints for the duration of the debugger.\",\n            \"logic\": \"Replaces the breakpoint instruction with the original instruction bits.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"Simulator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MipsDebugger::UndoBreakpoints() {\n  if (sim_->break_pc_ != nullptr) {\n    sim_->break_pc_->SetInstructionBits(sim_->break_instr_);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RedoBreakpoints\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Re-enables breakpoints when exiting debugger.\",\n            \"logic\": \"Sets breakpoints again.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"Simulator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MipsDebugger::RedoBreakpoints() {\n  if (sim_->break_pc_ != nullptr) {\n    sim_->break_pc_->SetInstructionBits(kBreakpointInstr);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PrintAllRegs\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Prints all general-purpose registers and program counter with their hexadecimal and decimal values.\",\n            \"logic\": \"Uses PrintF to display the values of all registers.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"Registers\",\n                \"PrintF\",\n                \"GetRegisterValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MipsDebugger::PrintAllRegs() {\n#define REG_INFO(n) Registers::Name(n), GetRegisterValue(n), GetRegisterValue(n)\n\n  PrintF(\"\\n\");\n  // at, v0, a0.\n  PrintF(\"%3s: 0x%016\" PRIx64 \" %14\" PRId64 \"\\t%3s: 0x%016\" PRIx64 \" %14\" PRId64\n         \"\\t%3s: 0x%016\" PRIx64 \" %14\" PRId64 \"\\n\",\n         REG_INFO(1), REG_INFO(2), REG_INFO(4));\n  // v1, a1.\n  PrintF(\"%34s\\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\n\",\n         \"\", REG_INFO(3), REG_INFO(5));\n  // a2.\n  PrintF(\"%34s\\t%34s\\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\", \"\", \"\",\n         REG_INFO(6));\n  // a3.\n  PrintF(\"%34s\\t%34s\\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\", \"\", \"\",\n         REG_INFO(7));\n  PrintF(\"\\n\");\n  // a4-t3, s0-s7\n  for (int i = 0; i < 8; i++) {\n    PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n           \"  %14\" PRId64 \" \\n\",\n           REG_INFO(8 + i), REG_INFO(16 + i));\n  }\n  PrintF(\"\\n\");\n  // t8, k0, LO.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\",\n         REG_INFO(24), REG_INFO(26), REG_INFO(32));\n  // t9, k1, HI.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\",\n         REG_INFO(25), REG_INFO(27), REG_INFO(33));\n  // sp, fp, gp.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\",\n         REG_INFO(29), REG_INFO(30), REG_INFO(28));\n  // pc.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\n\",\n         REG_INFO(31), REG_INFO(34));\n\n#undef REG_INFO\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PrintAllRegsIncludingFPU\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Prints all general-purpose and floating-point registers with their hexadecimal and floating-point values.\",\n            \"logic\": \"Calls PrintAllRegs to print general-purpose registers and then prints the FPU registers.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"Registers\",\n                \"FPURegisters\",\n                \"PrintF\",\n                \"GetFPURegisterValue\",\n                \"PrintAllRegs\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MipsDebugger::PrintAllRegsIncludingFPU() {\n#define FPU_REG_INFO(n) \\\n  FPURegisters::Name(n), GetFPURegisterValue(n), GetFPURegisterValueDouble(n)\n\n  PrintAllRegs();\n\n  PrintF(\"\\n\\n\");\n  // f0, f1, f2, ... f31.\n  // TODO(plind): consider printing 2 columns for space efficiency.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(0));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(1));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(2));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(3));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(4));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(5));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(6));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(7));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(8));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(9));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(10));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(11));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(12));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(13));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(14));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(15));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(16));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(17));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(18));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(19));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(20));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(21));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(22));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(23));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(24));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(25));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(26));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(27));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(28));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(29));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(30));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(31));\n\n#undef FPU_REG_INFO\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Debug\",\n            \"parent\": \"MipsDebugger\",\n            \"about\": \"Enters an interactive debugger shell for the MIPS simulator.\",\n            \"logic\": \"Allows stepping through instructions, printing register values, setting breakpoints, and other debugging actions.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"Registers\",\n                \"FPURegisters\",\n                \"disasm::Disassembler\",\n                \"ReadLine\",\n                \"SScanF\",\n                \"Instruction\",\n                \"Simulator\",\n                \"Registers\",\n                \"PrintAllRegs\",\n                \"PrintAllRegsIncludingFPU\",\n                \"GetValue\",\n                \"IsSmi\",\n                \"IsValidHeapObject\",\n                \"ShortPrint\",\n                \"SetBreakpoint\",\n                \"DeleteBreakpoint\",\n                \"UndoBreakpoints\",\n                \"RedoBreakpoints\",\n                \"Registers::Number\",\n                \"FPURegisters::Number\",\n                \"Simulator::get_pc\",\n                \"disasm::NameConverter\",\n                \"v8::base::OS::DebugBreak\",\n                \"PrintF\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MipsDebugger::Debug() {\n  if (v8_flags.correctness_fuzzer_suppressions) {\n    PrintF(\"Debugger disabled for differential fuzzing.\\n\");\n    return;\n  }\n  intptr_t last_pc = -1;\n  bool done = false;\n\n#define COMMAND_SIZE 63\n#define ARG_SIZE 255\n\n#define STR(a) #a\n#define XSTR(a) STR(a)\n\n  char cmd[COMMAND_SIZE + 1];\n  char arg1[ARG_SIZE + 1];\n  char arg2[ARG_SIZE + 1];\n  char* argv[3] = {cmd, arg1, arg2};\n\n  // Make sure to have a proper terminating character if reaching the limit.\n  cmd[COMMAND_SIZE] = 0;\n  arg1[ARG_SIZE] = 0;\n  arg2[ARG_SIZE] = 0;\n\n  // Undo all set breakpoints while running in the debugger shell."
}