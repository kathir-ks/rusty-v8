{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/bytecode-liveness-map.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 294, column 61",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/bytecode-liveness-map.h\",\n            \"file_name\": \"bytecode-liveness-map.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines data structures for tracking the liveness of bytecode registers for compiler optimizations.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library string for string manipulation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <string>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes the BitVector class for efficient bit manipulation.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/utils/bit-vector.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes the Zone class for memory management.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BytecodeLivenessState\",\n                \"extends\": \"ZoneObject\",\n                \"about\": \"Represents the liveness state of bytecode registers at a given point in the bytecode stream.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"bit_vector_\",\n                        \"type\": \"BitVector\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the liveness information for each register using a bit vector.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneObject\",\n                    \"BitVector\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class BytecodeLivenessState : public ZoneObject {\n            public:\n              class Iterator {\n               public:\n                int operator*() const {\n                  // Subtract one to compensate for the accumulator at the start of the\n                  // bit vector.\n                  return *it_ - 1;\n                }\n\n                void operator++() { return ++it_; }\n\n                bool operator!=(const Iterator& other) const { return it_ != other.it_; }\n\n               private:\n                static constexpr struct StartTag {\n                } kStartTag = {};\n                static constexpr struct EndTag {\n                } kEndTag = {};\n                explicit Iterator(const BytecodeLivenessState& liveness, StartTag)\n                    : it_(liveness.bit_vector_.begin()) {\n                  // If we're not at the end, and the current value is the accumulator, skip\n                  // over it.\n                  if (it_ != liveness.bit_vector_.end() && *it_ == 0) {\n                    ++it_;\n                  }\n                }\n                explicit Iterator(const BytecodeLivenessState& liveness, EndTag)\n                    : it_(liveness.bit_vector_.end()) {}\n\n                BitVector::Iterator it_;\n                friend class BytecodeLivenessState;\n              };\n\n              BytecodeLivenessState(int register_count, Zone* zone)\n                  : bit_vector_(register_count + 1, zone) {}\n              BytecodeLivenessState(const BytecodeLivenessState&) = delete;\n              BytecodeLivenessState& operator=(const BytecodeLivenessState&) = delete;\n\n              BytecodeLivenessState(const BytecodeLivenessState& other, Zone* zone)\n                  : bit_vector_(other.bit_vector_, zone) {}\n\n              bool RegisterIsLive(int index) const {\n                DCHECK_GE(index, 0);\n                DCHECK_LT(index, bit_vector_.length() - 1);\n                return bit_vector_.Contains(index + 1);\n              }\n\n              bool AccumulatorIsLive() const { return bit_vector_.Contains(0); }\n\n              bool Equals(const BytecodeLivenessState& other) const {\n                return bit_vector_.Equals(other.bit_vector_);\n              }\n\n              void MarkRegisterLive(int index) {\n                DCHECK_GE(index, 0);\n                DCHECK_LT(index, bit_vector_.length() - 1);\n                bit_vector_.Add(index + 1);\n              }\n\n              void MarkRegisterDead(int index) {\n                DCHECK_GE(index, 0);\n                DCHECK_LT(index, bit_vector_.length() - 1);\n                bit_vector_.Remove(index + 1);\n              }\n\n              void MarkAccumulatorLive() { bit_vector_.Add(0); }\n\n              void MarkAccumulatorDead() { bit_vector_.Remove(0); }\n\n              void MarkAllLive() { bit_vector_.AddAll(); }\n\n              void Union(const BytecodeLivenessState& other) {\n                bit_vector_.Union(other.bit_vector_);\n              }\n\n              bool UnionIsChanged(const BytecodeLivenessState& other) {\n                return bit_vector_.UnionIsChanged(other.bit_vector_);\n              }\n\n              void CopyFrom(const BytecodeLivenessState& other) {\n                bit_vector_.CopyFrom(other.bit_vector_);\n              }\n\n              int register_count() const { return bit_vector_.length() - 1; }\n\n              // Number of live values, including the accumulator.\n              int live_value_count() const { return bit_vector_.Count(); }\n\n              Iterator begin() const { return Iterator(*this, Iterator::kStartTag); }\n\n              Iterator end() const { return Iterator(*this, Iterator::kEndTag); }\n\n             private:\n              BitVector bit_vector_;\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"BytecodeLiveness\",\n                \"about\": \"A pair of BytecodeLivenessState pointers, one for the 'in' state and one for the 'out' state.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"in\",\n                        \"type\": \"BytecodeLivenessState*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Represents the liveness state at the beginning of a bytecode instruction.\"\n                    },\n                    {\n                        \"name\": \"out\",\n                        \"type\": \"BytecodeLivenessState*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Represents the liveness state at the end of a bytecode instruction.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BytecodeLivenessState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct BytecodeLiveness {\n              BytecodeLivenessState* in;\n              BytecodeLivenessState* out;\n            };\n        ]]></code>\n    </struct>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BytecodeLivenessMap\",\n                \"about\": \"Maps bytecode offsets to BytecodeLiveness structs, allowing efficient access to liveness information for each bytecode instruction.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"liveness_\",\n                        \"type\": \"BytecodeLiveness*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An array of BytecodeLiveness structs, indexed by bytecode offset.\"\n                    },\n                    {\n                        \"name\": \"size_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The size of the liveness array (only in DEBUG mode).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BytecodeLiveness\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE BytecodeLivenessMap {\n            public:\n              BytecodeLivenessMap(int bytecode_size, Zone* zone)\n                  : liveness_(zone->AllocateArray<BytecodeLiveness>(bytecode_size))\n            #ifdef DEBUG\n                    ,\n                    size_(bytecode_size)\n            #endif\n              {\n              }\n\n              BytecodeLiveness& InsertNewLiveness(int offset) {\n                DCHECK_GE(offset, 0);\n                DCHECK_LT(offset, size_);\n            #ifdef DEBUG\n                // Null out the in/out liveness, so that later DCHECKs know whether these\n                // have been correctly initialised or not. That code does initialise them\n                // unconditionally though, so we can skip the nulling out in release.\n                liveness_[offset].in = nullptr;\n                liveness_[offset].out = nullptr;\n            #endif\n                return liveness_[offset];\n              }\n\n              BytecodeLiveness& GetLiveness(int offset) {\n                DCHECK_GE(offset, 0);\n                DCHECK_LT(offset, size_);\n                return liveness_[offset];\n              }\n              const BytecodeLiveness& GetLiveness(int offset) const {\n                DCHECK_GE(offset, 0);\n                DCHECK_LT(offset, size_);\n                return liveness_[offset];\n              }\n\n              BytecodeLivenessState* GetInLiveness(int offset) {\n                return GetLiveness(offset).in;\n              }\n              const BytecodeLivenessState* GetInLiveness(int offset) const {\n                return GetLiveness(offset).in;\n              }\n\n              BytecodeLivenessState* GetOutLiveness(int offset) {\n                return GetLiveness(offset).out;\n              }\n              const BytecodeLivenessState* GetOutLiveness(int offset) const {\n                return GetLiveness(offset).out;\n              }\n\n             private:\n              BytecodeLiveness* liveness_;\n            #ifdef DEBUG\n              size_t size_;\n            #endif\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ToString\",\n                \"about\": \"Converts a BytecodeLivenessState object to a string representation for debugging purposes.\",\n                \"logic\": \"Iterates through the live registers and appends them to a string.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"liveness\",\n                        \"type\": \"const BytecodeLivenessState&\",\n                        \"purpose\": \"The BytecodeLivenessState object to convert to a string.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"The string representation of the BytecodeLivenessState.\"\n                },\n                \"dependencies\": [\n                    \"BytecodeLivenessState\",\n                    \"std::string\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE std::string ToString(const BytecodeLivenessState& liveness);\n        ]]></code>\n    </func>\n</file>\n```"
}