{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/load-elimination.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/load-elimination.h\",\n        \"file_name\": \"load-elimination.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the LoadElimination class, which performs load elimination optimization in the compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for base types, compiler-specific features, code generation, common utilities, graph reduction, simplified operators, and handle management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/compiler-specific.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/graph-reducer.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/handles/maybe-handles.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LoadElimination\",\n            \"extends\": \"AdvancedReducer\",\n            \"about\": \"Performs load elimination optimization on the graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"broker_\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the JS heap for type information.\"\n                },\n                {\n                    \"name\": \"node_states_\",\n                    \"type\": \"AbstractStateForEffectNodes\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the abstract state for each effect node.\"\n                },\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the JS graph.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AdvancedReducer\",\n                \"Editor\",\n                \"JSHeapBroker\",\n                \"JSGraph\",\n                \"Zone\",\n                \"Node\",\n                \"Reduction\",\n                \"AbstractStateForEffectNodes\",\n                \"FieldAccess\",\n                \"AbstractState\",\n                \"CommonOperatorBuilder\",\n                \"Isolate\",\n                \"Factory\",\n                \"TFGraph\",\n                \"MachineRepresentation\",\n                \"Name\",\n                \"MaybeHandle\",\n                \"ZoneRefSet\",\n                \"Map\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE LoadElimination final\n    : public NON_EXPORTED_BASE(AdvancedReducer) {\n public:\n  LoadElimination(Editor* editor, JSHeapBroker* broker, JSGraph* jsgraph,\n                  Zone* zone)\n      : AdvancedReducer(editor),\n        broker_(broker),\n        node_states_(zone),\n        jsgraph_(jsgraph) {}\n  ~LoadElimination() final = default;\n  LoadElimination(const LoadElimination&) = delete;\n  LoadElimination& operator=(const LoadElimination&) = delete;\n\n  const char* reducer_name() const override { return \"LoadElimination\"; }\n\n  Reduction Reduce(Node* node) final;\n\n private:\n  static const size_t kMaxTrackedElements = 8;\n\n  // Abstract state to approximate the current state of an element along the\n  // effect paths through the graph.\n  class AbstractElements final : public ZoneObject {\n   public:\n    explicit AbstractElements(Zone* zone) {\n      for (size_t i = 0; i < arraysize(elements_); ++i) {\n        elements_[i] = Element();\n      }\n    }\n    AbstractElements(Node* object, Node* index, Node* value,\n                     MachineRepresentation representation, Zone* zone)\n        : AbstractElements(zone) {\n      elements_[next_index_++] = Element(object, index, value, representation);\n    }\n\n    AbstractElements const* Extend(Node* object, Node* index, Node* value,\n                                   MachineRepresentation representation,\n                                   Zone* zone) const {\n      AbstractElements* that = zone->New<AbstractElements>(*this);\n      that->elements_[that->next_index_] =\n          Element(object, index, value, representation);\n      that->next_index_ = (that->next_index_ + 1) % arraysize(elements_);\n      return that;\n    }\n    Node* Lookup(Node* object, Node* index,\n                 MachineRepresentation representation) const;\n    AbstractElements const* Kill(Node* object, Node* index, Zone* zone) const;\n    bool Equals(AbstractElements const* that) const;\n    AbstractElements const* Merge(AbstractElements const* that,\n                                  Zone* zone) const;\n\n    void Print() const;\n\n   private:\n    struct Element {\n      Element() = default;\n      Element(Node* object, Node* index, Node* value,\n              MachineRepresentation representation)\n          : object(object),\n            index(index),\n            value(value),\n            representation(representation) {}\n\n      Node* object = nullptr;\n      Node* index = nullptr;\n      Node* value = nullptr;\n      MachineRepresentation representation = MachineRepresentation::kNone;\n    };\n\n    Element elements_[kMaxTrackedElements];\n    size_t next_index_ = 0;\n  };\n\n  // Information we use to resolve object aliasing. Currently, we consider\n  // object not aliased if they have different maps or if the nodes may\n  // not alias.\n  class AliasStateInfo;\n\n  struct FieldInfo {\n    FieldInfo() = default;\n    FieldInfo(Node* value, MachineRepresentation representation,\n              MaybeHandle<Name> name = {},\n              ConstFieldInfo const_field_info = ConstFieldInfo::None())\n        : value(value),\n          representation(representation),\n          name(name),\n          const_field_info(const_field_info) {}\n\n    bool operator==(const FieldInfo& other) const {\n      return value == other.value && representation == other.representation &&\n             name.address() == other.name.address() &&\n             const_field_info == other.const_field_info;\n    }\n    bool operator!=(const FieldInfo& other) const { return !(*this == other); }\n\n    Node* value = nullptr;\n    MachineRepresentation representation = MachineRepresentation::kNone;\n    MaybeHandle<Name> name;\n    ConstFieldInfo const_field_info;\n  };\n\n  // Abstract state to approximate the current state of a certain field along\n  // the effect paths through the graph.\n  class AbstractField final : public ZoneObject {\n   public:\n    explicit AbstractField(Zone* zone) : info_for_node_(zone) {}\n    AbstractField(Node* object, FieldInfo info, Zone* zone)\n        : info_for_node_(zone) {\n      info_for_node_.insert(std::make_pair(object, info));\n    }\n\n    AbstractField const* Extend(Node* object, FieldInfo info, Zone* zone,\n                                int current_field_count) const {\n      AbstractField* that = zone->New<AbstractField>(*this);\n      if ((current_field_count >= kMaxTrackedFields &&\n           that->info_for_node_.size() > 0) ||\n          that->info_for_node_.size() >= kMaxTrackedObjects) {\n        // We are tracking too many objects, which leads to bad performance.\n        // Delete one to avoid the map from becoming bigger.\n        that->info_for_node_.erase(that->info_for_node_.begin());\n      }\n      that->info_for_node_[object] = info;\n      return that;\n    }\n    FieldInfo const* Lookup(Node* object) const;\n    AbstractField const* KillConst(Node* object, Zone* zone) const;\n    AbstractField const* Kill(const AliasStateInfo& alias_info,\n                              MaybeHandle<Name> name, Zone* zone) const;\n    bool Equals(AbstractField const* that) const {\n      return this == that || this->info_for_node_ == that->info_for_node_;\n    }\n    AbstractField const* Merge(AbstractField const* that, Zone* zone,\n                               int* count) const {\n      if (this->Equals(that)) return this;\n      AbstractField* copy = zone->New<AbstractField>(zone);\n      for (auto this_it : this->info_for_node_) {\n        Node* this_object = this_it.first;\n        FieldInfo this_second = this_it.second;\n        if (this_object->IsDead()) continue;\n        auto that_it = that->info_for_node_.find(this_object);\n        if (that_it != that->info_for_node_.end() &&\n            that_it->second == this_second) {\n          copy->info_for_node_.insert(this_it);\n          (*count)++;\n        }\n      }\n      return copy;\n    }\n\n    void Print() const;\n\n    int count() const { return static_cast<int>(info_for_node_.size()); }\n\n   private:\n    ZoneMap<Node*, FieldInfo> info_for_node_;\n  };\n\n  static size_t const kMaxTrackedFieldsPerObject = 32;\n  static size_t const kMaxTrackedObjects = 100;\n  static int const kMaxTrackedFields = 300;\n\n  // Abstract state to approximate the current map of an object along the\n  // effect paths through the graph.\n  class AbstractMaps final : public ZoneObject {\n   public:\n    explicit AbstractMaps(Zone* zone);\n    AbstractMaps(Node* object, ZoneRefSet<Map> maps, Zone* zone);\n\n    AbstractMaps const* Extend(Node* object, ZoneRefSet<Map> maps,\n                               Zone* zone) const;\n    bool Lookup(Node* object, ZoneRefSet<Map>* object_maps) const;\n    AbstractMaps const* Kill(const AliasStateInfo& alias_info,\n                             Zone* zone) const;\n    bool Equals(AbstractMaps const* that) const {\n      return this == that || this->info_for_node_ == that->info_for_node_;\n    }\n    AbstractMaps const* Merge(AbstractMaps const* that, Zone* zone) const;\n\n    void Print() const;\n\n   private:\n    ZoneMap<Node*, ZoneRefSet<Map>> info_for_node_;\n  };\n\n  class IndexRange {\n   public:\n    IndexRange(int begin, int size) : begin_(begin), end_(begin + size) {\n      DCHECK_LE(0, begin);\n      DCHECK_LE(1, size);\n      if (end_ > static_cast<int>(kMaxTrackedFieldsPerObject)) {\n        *this = IndexRange::Invalid();\n      }\n    }\n    static IndexRange Invalid() { return IndexRange(); }\n\n    bool operator==(const IndexRange& other) const {\n      return begin_ == other.begin_ && end_ == other.end_;\n    }\n    bool operator!=(const IndexRange& other) const { return !(*this == other); }\n\n    struct Iterator {\n      int i;\n      int operator*() { return i; }\n      void operator++() { ++i; }\n      bool operator!=(Iterator other) { return i != other.i; }\n    };\n\n    Iterator begin() { return {begin_}; }\n    Iterator end() { return {end_}; }\n\n   private:\n    int begin_;\n    int end_;\n\n    IndexRange() : begin_(-1), end_(-1) {}\n  };\n\n  class AbstractState final : public ZoneObject {\n   public:\n    bool Equals(AbstractState const* that) const;\n    void Merge(AbstractState const* that, Zone* zone);\n\n    AbstractState const* SetMaps(Node* object, ZoneRefSet<Map> maps,\n                                 Zone* zone) const;\n    AbstractState const* KillMaps(Node* object, Zone* zone) const;\n    AbstractState const* KillMaps(const AliasStateInfo& alias_info,\n                                  Zone* zone) const;\n    bool LookupMaps(Node* object, ZoneRefSet<Map>* object_maps) const;\n\n    AbstractState const* AddField(Node* object, IndexRange index,\n                                  FieldInfo info, Zone* zone) const;\n    AbstractState const* KillConstField(Node* object, IndexRange index_range,\n                                        Zone* zone) const;\n    AbstractState const* KillField(const AliasStateInfo& alias_info,\n                                   IndexRange index, MaybeHandle<Name> name,\n                                   Zone* zone) const;\n    AbstractState const* KillField(Node* object, IndexRange index,\n                                   MaybeHandle<Name> name, Zone* zone) const;\n    AbstractState const* KillFields(Node* object, MaybeHandle<Name> name,\n                                    Zone* zone) const;\n    AbstractState const* KillAll(Zone* zone) const;\n    FieldInfo const* LookupField(Node* object, IndexRange index,\n                                 ConstFieldInfo const_field_info) const;\n\n    AbstractState const* AddElement(Node* object, Node* index, Node* value,\n                                    MachineRepresentation representation,\n                                    Zone* zone) const;\n    AbstractState const* KillElement(Node* object, Node* index,\n                                     Zone* zone) const;\n    Node* LookupElement(Node* object, Node* index,\n                        MachineRepresentation representation) const;\n\n    void Print() const;\n\n    static AbstractState const* empty_state() { return &empty_state_; }\n\n   private:\n    static AbstractState const empty_state_;\n\n    using AbstractFields =\n        std::array<AbstractField const*, kMaxTrackedFieldsPerObject>;\n\n    bool FieldsEquals(AbstractFields const& this_fields,\n                      AbstractFields const& that_fields) const;\n    void FieldsMerge(AbstractFields* this_fields,\n                     AbstractFields const& that_fields, Zone* zone);\n\n    AbstractElements const* elements_ = nullptr;\n    AbstractFields fields_{};\n    AbstractFields const_fields_{};\n    AbstractMaps const* maps_ = nullptr;\n    int const_fields_count_ = 0;\n    // Note that fields_count_ includes both const_fields and non-const fields.\n    // To get the number of non-const fields, use `fields_count_ -\n    // const_fields_count_`.\n    int fields_count_ = 0;\n  };\n\n  class AbstractStateForEffectNodes final : public ZoneObject {\n   public:\n    explicit AbstractStateForEffectNodes(Zone* zone) : info_for_node_(zone) {}\n    AbstractState const* Get(Node* node) const;\n    void Set(Node* node, AbstractState const* state);\n\n    Zone* zone() const { return info_for_node_.zone(); }\n\n   private:\n    ZoneVector<AbstractState const*> info_for_node_;\n  };\n\n  Reduction ReduceCheckMaps(Node* node);\n  Reduction ReduceCompareMaps(Node* node);\n  Reduction ReduceMapGuard(Node* node);\n  Reduction ReduceEnsureWritableFastElements(Node* node);\n  Reduction ReduceMaybeGrowFastElements(Node* node);\n  Reduction ReduceTransitionElementsKind(Node* node);\n  Reduction ReduceTransitionElementsKindOrCheckMap(Node* node);\n  Reduction ReduceLoadField(Node* node, FieldAccess const& access);\n  Reduction ReduceStoreField(Node* node, FieldAccess const& access);\n  Reduction ReduceLoadElement(Node* node);\n  Reduction ReduceStoreElement(Node* node);\n  Reduction ReduceTransitionAndStoreElement(Node* node);\n  Reduction ReduceStoreTypedElement(Node* node);\n  Reduction ReduceEffectPhi(Node* node);\n  Reduction ReduceStart(Node* node);\n  Reduction ReduceOtherNode(Node* node);\n\n  Reduction UpdateState(Node* node, AbstractState const* state);\n\n  AbstractState const* ComputeLoopState(Node* node,\n                                        AbstractState const* state) const;\n  AbstractState const* ComputeLoopStateForStoreField(\n      Node* current, LoadElimination::AbstractState const* state,\n      FieldAccess const& access) const;\n  AbstractState const* UpdateStateForPhi(AbstractState const* state,\n                                         Node* effect_phi, Node* phi);\n\n  static IndexRange FieldIndexOf(int offset, int representation_size);\n  static IndexRange FieldIndexOf(FieldAccess const& access);\n\n  static AbstractState const* empty_state() {\n    return AbstractState::empty_state();\n  }\n\n  CommonOperatorBuilder* common() const;\n  Isolate* isolate() const;\n  Factory* factory() const;\n  TFGraph* graph() const;\n  JSGraph* jsgraph() const { return jsgraph_; }\n  JSHeapBroker* broker() const { return broker_; }\n  Zone* zone() const { return node_states_.zone(); }\n\n  JSHeapBroker* broker_;\n  AbstractStateForEffectNodes node_states_;\n  JSGraph* const jsgraph_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AbstractElements\",\n            \"about\": \"Abstract state to approximate the current state of an element along the effect paths through the graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"elements_\",\n                    \"type\": \"Element[kMaxTrackedElements]\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of elements being tracked.\"\n                },\n                {\n                    \"name\": \"next_index_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Index of the next element to be replaced in the array.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"Node\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  // Abstract state to approximate the current state of an element along the\n  // effect paths through the graph.\n  class AbstractElements final : public ZoneObject {\n   public:\n    explicit AbstractElements(Zone* zone) {\n      for (size_t i = 0; i < arraysize(elements_); ++i) {\n        elements_[i] = Element();\n      }\n    }\n    AbstractElements(Node* object, Node* index, Node* value,\n                     MachineRepresentation representation, Zone* zone)\n        : AbstractElements(zone) {\n      elements_[next_index_++] = Element(object, index, value, representation);\n    }\n\n    AbstractElements const* Extend(Node* object, Node* index, Node* value,\n                                   MachineRepresentation representation,\n                                   Zone* zone) const {\n      AbstractElements* that = zone->New<AbstractElements>(*this);\n      that->elements_[that->next_index_] =\n          Element(object, index, value, representation);\n      that->next_index_ = (that->next_index_ + 1) % arraysize(elements_);\n      return that;\n    }\n    Node* Lookup(Node* object, Node* index,\n                 MachineRepresentation representation) const;\n    AbstractElements const* Kill(Node* object, Node* index, Zone* zone) const;\n    bool Equals(AbstractElements const* that) const;\n    AbstractElements const* Merge(AbstractElements const* that,\n                                  Zone* zone) const;\n\n    void Print() const;\n\n   private:\n    struct Element {\n      Element() = default;\n      Element(Node* object, Node* index, Node* value,\n              MachineRepresentation representation)\n          : object(object),\n            index(index),\n            value(value),\n            representation(representation) {}\n\n      Node* object = nullptr;\n      Node* index = nullptr;\n      Node* value = nullptr;\n      MachineRepresentation representation = MachineRepresentation::kNone;\n    };\n\n    Element elements_[kMaxTrackedElements];\n    size_t next_index_ = 0;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AbstractField\",\n            \"about\": \"Abstract state to approximate the current state of a certain field along the effect paths through the graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"info_for_node_\",\n                    \"type\": \"ZoneMap<Node*, FieldInfo>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of nodes to their field information.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"Node\",\n                \"FieldInfo\",\n                \"ZoneMap\",\n                \"AliasStateInfo\",\n                \"MaybeHandle\",\n                \"Name\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  // Abstract state to approximate the current state of a certain field along\n  // the effect paths through the graph.\n  class AbstractField final : public ZoneObject {\n   public:\n    explicit AbstractField(Zone* zone) : info_for_node_(zone) {}\n    AbstractField(Node* object, FieldInfo info, Zone* zone)\n        : info_for_node_(zone) {\n      info_for_node_.insert(std::make_pair(object, info));\n    }\n\n    AbstractField const* Extend(Node* object, FieldInfo info, Zone* zone,\n                                int current_field_count) const {\n      AbstractField* that = zone->New<AbstractField>(*this);\n      if ((current_field_count >= kMaxTrackedFields &&\n           that->info_for_node_.size() > 0) ||\n          that->info_for_node_.size() >= kMaxTrackedObjects) {\n        // We are tracking too many objects, which leads to bad performance.\n        // Delete one to avoid the map from becoming bigger.\n        that->info_for_node_.erase(that->info_for_node_.begin());\n      }\n      that->info_for_node_[object] = info;\n      return that;\n    }\n    FieldInfo const* Lookup(Node* object) const;\n    AbstractField const* KillConst(Node* object, Zone* zone) const;\n    AbstractField const* Kill(const AliasStateInfo& alias_info,\n                              MaybeHandle<Name> name, Zone* zone) const;\n    bool Equals(AbstractField const* that) const {\n      return this == that || this->info_for_node_ == that->info_for_node_;\n    }\n    AbstractField const* Merge(AbstractField const* that, Zone* zone,\n                               int* count) const {\n      if (this->Equals(that)) return this;\n      AbstractField* copy = zone->New<AbstractField>(zone);\n      for (auto this_it : this->info_for_node_) {\n        Node* this_object = this_it.first;\n        FieldInfo this_second = this_it.second;\n        if (this_object->IsDead()) continue;\n        auto that_it = that->info_for_node_.find(this_object);\n        if (that_it != that->info_for_node_.end() &&\n            that_it->second == this_second) {\n          copy->info_for_node_.insert(this_it);\n          (*count)++;\n        }\n      }\n      return copy;\n    }\n\n    void Print() const;\n\n    int count() const { return static_cast<int>(info_for_node_.size()); }\n\n   private:\n    ZoneMap<Node*, FieldInfo> info_for_node_;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AbstractMaps\",\n            \"about\": \"Abstract state to approximate the current map of an object along the effect paths through the graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"info_for_node_\",\n                    \"type\": \"ZoneMap<Node*, ZoneRefSet<Map>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of nodes to their maps.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"Node\",\n                \"ZoneRefSet\",\n                \"Map\",\n                \"ZoneMap\",\n                \"AliasStateInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  // Abstract state to approximate the current map of an object along the\n  // effect paths through the graph.\n  class AbstractMaps final : public ZoneObject {\n   public:\n    explicit AbstractMaps(Zone* zone);\n    AbstractMaps(Node* object, ZoneRefSet<Map> maps, Zone* zone);\n\n    AbstractMaps const* Extend(Node* object, ZoneRefSet<Map> maps,\n                               Zone* zone) const;\n    bool Lookup(Node* object, ZoneRefSet<Map>* object_maps) const;\n    AbstractMaps const* Kill(const AliasStateInfo& alias_info,\n                             Zone* zone) const;\n    bool Equals(AbstractMaps const* that) const {\n      return this == that || this->info_for_node_ == that->info_for_node_;\n    }\n    AbstractMaps const* Merge(AbstractMaps const* that, Zone* zone) const;\n\n    void Print() const;\n\n   private:\n    ZoneMap<Node*, ZoneRefSet<Map>> info_for_node_;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IndexRange\",\n            \"about\": \"Represents a range of indices.\",\n            \"attributes\": [\n                {\n                    \"name\": \"begin_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Start index of the range.\"\n                },\n                {\n                    \"name\": \"end_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"End index of the range (exclusive).\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  class IndexRange {\n   public:\n    IndexRange(int begin, int size) : begin_(begin), end_(begin + size) {\n      DCHECK_LE(0, begin);\n      DCHECK_LE(1, size);\n      if (end_ > static_cast<int>(kMaxTrackedFieldsPerObject)) {\n        *this = IndexRange::Invalid();\n      }\n    }\n    static IndexRange Invalid() { return IndexRange(); }\n\n    bool operator==(const IndexRange& other) const {\n      return begin_ == other.begin_ && end_ == other.end_;\n    }\n    bool operator!=(const IndexRange& other) const { return !(*this == other); }\n\n    struct Iterator {\n      int i;\n      int operator*() { return i; }\n      void operator++() { ++i; }\n      bool operator!=(Iterator other) { return i != other.i; }\n    };\n\n    Iterator begin() { return {begin_}; }\n    Iterator end() { return {end_}; }\n\n   private:\n    int begin_;\n    int end_;\n\n    IndexRange() : begin_(-1), end_(-1) {}\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AbstractState\",\n            \"about\": \"Abstract state to approximate the current state of objects and their fields/elements along the effect paths through the graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"elements_\",\n                    \"type\": \"AbstractElements const*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks abstract state of array elements.\"\n                },\n                {\n                    \"name\": \"fields_\",\n                    \"type\": \"AbstractFields\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks abstract state of object fields.\"\n                },\n                {\n                    \"name\": \"const_fields_\",\n                    \"type\": \"AbstractFields\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks abstract state of constant object fields.\"\n                },\n                {\n                    \"name\": \"maps_\",\n                    \"type\": \"AbstractMaps const*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks abstract state of object maps.\"\n                },\n                {\n                    \"name\": \"const_fields_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Count of constant fields.\"\n                },\n                {\n                    \"name\": \"fields_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Count of all fields.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"Node\",\n                \"ZoneRefSet\",\n                \"Map\",\n                \"FieldInfo\",\n                \"AbstractElements\",\n                \"AbstractField\",\n                \"AbstractMaps\",\n                \"IndexRange\",\n                \"AliasStateInfo\",\n                \"MaybeHandle\",\n                \"Name\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class AbstractState final : public ZoneObject {\n   public:\n    bool Equals(AbstractState const* that) const;\n    void Merge(AbstractState const* that, Zone* zone);\n\n    AbstractState const* SetMaps(Node* object, ZoneRefSet<Map> maps,\n                                 Zone* zone) const;\n    AbstractState const* KillMaps(Node* object, Zone* zone) const;\n    AbstractState const* KillMaps(const AliasStateInfo& alias_info,\n                                  Zone* zone) const;\n    bool LookupMaps(Node* object, ZoneRefSet<Map>* object_maps) const;\n\n    AbstractState const* AddField(Node* object, IndexRange index,\n                                  FieldInfo info, Zone* zone) const;\n    AbstractState const* KillConstField(Node* object, IndexRange index_range,\n                                        Zone* zone) const;\n    AbstractState const* KillField(const AliasStateInfo& alias_info,\n                                   IndexRange index, MaybeHandle<Name> name,\n                                   Zone* zone) const;\n    AbstractState const* KillField(Node* object, IndexRange index,\n                                   MaybeHandle<Name> name, Zone* zone) const;\n    AbstractState const* KillFields(Node* object, MaybeHandle<Name> name,\n                                    Zone* zone) const;\n    AbstractState const* KillAll(Zone* zone) const;\n    FieldInfo const* LookupField(Node* object, IndexRange index,\n                                 ConstFieldInfo const_field_info) const;\n\n    AbstractState const* AddElement(Node* object, Node* index, Node* value,\n                                    MachineRepresentation representation,\n                                    Zone* zone) const;\n    AbstractState const* KillElement(Node* object, Node* index,\n                                     Zone* zone) const;\n    Node* LookupElement(Node* object, Node* index,\n                        MachineRepresentation representation) const;\n\n    void Print() const;\n\n    static AbstractState const* empty_state() { return &empty_state_; }\n\n   private:\n    static AbstractState const empty_state_;\n\n    using AbstractFields =\n        std::array<AbstractField const*, kMaxTrackedFieldsPerObject>;\n\n    bool FieldsEquals(AbstractFields const& this_fields,\n                      AbstractFields const& that_fields) const;\n    void FieldsMerge(AbstractFields* this_fields,\n                     AbstractFields const& that_fields, Zone* zone);\n\n    AbstractElements const* elements_ = nullptr;\n    AbstractFields fields_{};\n    AbstractFields const_fields_{};\n    AbstractMaps const* maps_ = nullptr;\n    int const_fields_count_ = 0;\n    // Note that fields_count_ includes both const_fields and non-const fields.\n    // To get the number of non-const fields, use `fields_count_ -\n    // const_fields_count_`.\n    int fields_count_ = 0;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AbstractStateForEffectNodes\",\n            \"about\": \"Stores the abstract state for each effect node in the graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"info_for_node_\",\n                    \"type\": \"ZoneVector<AbstractState const*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of abstract states for each node.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ZoneObject\",\n                \"Node\",\n                \"AbstractState\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class AbstractStateForEffectNodes final : public ZoneObject {\n   public:\n    explicit AbstractStateForEffectNodes(Zone* zone) : info_for_node_(zone) {}\n    AbstractState const* Get(Node* node) const;\n    void Set(Node* node, AbstractState const* state);\n\n    Zone* zone() const { return info_for_node_.zone(); }\n\n   private:\n    ZoneVector<AbstractState const*> info_for_node_;\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"reducer_name\",\n            \"parent\": \"LoadElimination\",\n            \"about\": \"Returns the name of the reducer.\",\n            \"logic\": \"Returns a string literal representing the name of this reducer, which is 'LoadElimination'.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"const char*\",\n                \"description\": \"The name of the reducer.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  const char* reducer_name() const override { return \"LoadElimination\"; }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"LoadElimination\",\n            \"about\": \"Reduces the given node.\",\n            \"logic\": \"This is the main method for performing load elimination.  It dispatches to specific handlers based on the node's opcode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Reduction\",\n                \"ReduceCheck"
}