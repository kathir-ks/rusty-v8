{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/type-traits.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 219, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/type-traits.h\",\n            \"file_name\": \"type-traits.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines type traits for the cppgc garbage collector, allowing compile-time introspection of types for garbage collection purposes.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers for size_t, type traits and utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cstddef>\n            #include <type_traits>\n            #include <utility>\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Visitor\",\n                \"about\": \"Represents a visitor for traversing garbage-collected objects.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace cppgc {\n\n            class Visitor;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BasicMember\",\n                \"about\": \"A template class representing a basic member that can be garbage collected.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                    typename CheckingPolicy, typename StorageType>\n            class BasicMember;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"DijkstraWriteBarrierPolicy\",\n                \"about\": \"Write barrier policy for Dijkstra's algorithm.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            struct DijkstraWriteBarrierPolicy;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"NoWriteBarrierPolicy\",\n                \"about\": \"A write barrier policy that does nothing.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            struct NoWriteBarrierPolicy;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StrongMemberTag\",\n                \"about\": \"Tag for strong members.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class StrongMemberTag;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UntracedMemberTag\",\n                \"about\": \"Tag for untraced members.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class UntracedMemberTag;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WeakMemberTag\",\n                \"about\": \"Tag for weak members.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class WeakMemberTag;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsWeak\",\n                \"about\": \"Type trait to check if a type is a weak reference.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            // Not supposed to be specialized by the user.\n            template <typename T>\n            struct IsWeak : std::false_type {};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsTraceMethodConst\",\n                \"about\": \"Type trait to check if a type has a const Trace method.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Visitor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // IsTraceMethodConst is used to verify that all Trace methods are marked as\n            // const. It is equivalent to IsTraceable but for a non-const object.\n            template <typename T, typename = void>\n            struct IsTraceMethodConst : std::false_type {};\n\n            template <typename T>\n            struct IsTraceMethodConst<T, std::void_t<decltype(std::declval<const T>().Trace(\n                                    std::declval<Visitor*>()))>> : std::true_type {\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsTraceable\",\n                \"about\": \"Type trait to check if a type is traceable (has a Trace method).\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Visitor\",\n                    \"IsTraceMethodConst\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename = void>\n            struct IsTraceable : std::false_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n\n            template <typename T>\n            struct IsTraceable<\n                T, std::void_t<decltype(std::declval<T>().Trace(std::declval<Visitor*>()))>>\n                : std::true_type {\n            // All Trace methods should be marked as const. If an object of type\n            // 'T' is traceable then any object of type 'const T' should also\n            // be traceable.\n            static_assert(IsTraceMethodConst<T>(),\n                            \"Trace methods should be marked as const.\");\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsTraceableV\",\n                \"about\": \"Inline variable for accessing the value of IsTraceable.\",\n                \"logic\": \"A constexpr variable that stores the result of IsTraceable<T>::value.\",\n                \"dependencies\": [\n                    \"IsTraceable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            constexpr bool IsTraceableV = IsTraceable<T>::value;\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"HasGarbageCollectedMixinTypeMarker\",\n                \"about\": \"Type trait to check if a type has a GarbageCollectedMixinType marker.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename = void>\n            struct HasGarbageCollectedMixinTypeMarker : std::false_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n\n            template <typename T>\n            struct HasGarbageCollectedMixinTypeMarker<\n                T, std::void_t<\n                    typename std::remove_const_t<T>::IsGarbageCollectedMixinTypeMarker>>\n                : std::true_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"HasGarbageCollectedTypeMarker\",\n                \"about\": \"Type trait to check if a type has a GarbageCollectedType marker.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename = void>\n            struct HasGarbageCollectedTypeMarker : std::false_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n\n            template <typename T>\n            struct HasGarbageCollectedTypeMarker<\n                T,\n                std::void_t<typename std::remove_const_t<T>::IsGarbageCollectedTypeMarker>>\n                : std::true_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsGarbageCollectedMixinType\",\n                \"about\": \"Type trait to check if a type is a GarbageCollectedMixinType.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"HasGarbageCollectedMixinTypeMarker\",\n                    \"HasGarbageCollectedTypeMarker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, bool = HasGarbageCollectedTypeMarker<T>::value,\n                    bool = HasGarbageCollectedMixinTypeMarker<T>::value>\n            struct IsGarbageCollectedMixinType : std::false_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n\n            template <typename T>\n            struct IsGarbageCollectedMixinType<T, false, true> : std::true_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsGarbageCollectedType\",\n                \"about\": \"Type trait to check if a type is a GarbageCollectedType.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"HasGarbageCollectedTypeMarker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, bool = HasGarbageCollectedTypeMarker<T>::value>\n            struct IsGarbageCollectedType : std::false_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n\n            template <typename T>\n            struct IsGarbageCollectedType<T, true> : std::true_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsGarbageCollectedOrMixinType\",\n                \"about\": \"Type trait to check if a type is either a GarbageCollectedType or a GarbageCollectedMixinType.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"IsGarbageCollectedType\",\n                    \"IsGarbageCollectedMixinType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            struct IsGarbageCollectedOrMixinType\n                : std::integral_constant<bool, IsGarbageCollectedType<T>::value ||\n                                                IsGarbageCollectedMixinType<T>::value> {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsGarbageCollectedWithMixinType\",\n                \"about\": \"Type trait to check if a type is both a GarbageCollectedType and a GarbageCollectedMixinType.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"HasGarbageCollectedTypeMarker\",\n                    \"HasGarbageCollectedMixinTypeMarker\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, bool = (HasGarbageCollectedTypeMarker<T>::value &&\n                                        HasGarbageCollectedMixinTypeMarker<T>::value)>\n            struct IsGarbageCollectedWithMixinType : std::false_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n\n            template <typename T>\n            struct IsGarbageCollectedWithMixinType<T, true> : std::true_type {\n            static_assert(sizeof(T), \"T must be fully defined\");\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsSubclassOfBasicMemberTemplate\",\n                \"about\": \"Type trait to check if a type is a subclass of BasicMember.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"BasicMember\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename BasicMemberCandidate, typename WeaknessTag,\n                    typename WriteBarrierPolicy>\n            struct IsSubclassOfBasicMemberTemplate {\n            private:\n            template <typename T, typename CheckingPolicy, typename StorageType>\n            static std::true_type SubclassCheck(\n                const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,\n                                StorageType>*);\n            static std::false_type SubclassCheck(...);\n\n            public:\n            static constexpr bool value = decltype(SubclassCheck(\n                std::declval<std::decay_t<BasicMemberCandidate>*>()))::value;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsMemberType\",\n                \"about\": \"Type trait to check if a type is a Member type.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"IsSubclassOfBasicMemberTemplate\",\n                    \"StrongMemberTag\",\n                    \"DijkstraWriteBarrierPolicy\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T,\n                    bool = IsSubclassOfBasicMemberTemplate<\n                        T, StrongMemberTag, DijkstraWriteBarrierPolicy>::value>\n            struct IsMemberType : std::false_type {};\n\n            template <typename T>\n            struct IsMemberType<T, true> : std::true_type {};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsWeakMemberType\",\n                \"about\": \"Type trait to check if a type is a WeakMember type.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"IsSubclassOfBasicMemberTemplate\",\n                    \"WeakMemberTag\",\n                    \"DijkstraWriteBarrierPolicy\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, bool = IsSubclassOfBasicMemberTemplate<\n                            T, WeakMemberTag, DijkstraWriteBarrierPolicy>::value>\n            struct IsWeakMemberType : std::false_type {};\n\n            template <typename T>\n            struct IsWeakMemberType<T, true> : std::true_type {};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsUntracedMemberType\",\n                \"about\": \"Type trait to check if a type is an UntracedMember type.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"IsSubclassOfBasicMemberTemplate\",\n                    \"UntracedMemberTag\",\n                    \"NoWriteBarrierPolicy\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, bool = IsSubclassOfBasicMemberTemplate<\n                            T, UntracedMemberTag, NoWriteBarrierPolicy>::value>\n            struct IsUntracedMemberType : std::false_type {};\n\n            template <typename T>\n            struct IsUntracedMemberType<T, true> : std::true_type {};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsComplete\",\n                \"about\": \"Type trait to check if a type is complete.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            struct IsComplete {\n            private:\n            template <typename U, size_t = sizeof(U)>\n            static std::true_type IsSizeOfKnown(U*);\n            static std::false_type IsSizeOfKnown(...);\n\n            public:\n            static constexpr bool value =\n                decltype(IsSizeOfKnown(std::declval<T*>()))::value;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsDecayedSameV\",\n                \"about\": \"Inline variable to check if two decayed types are the same.\",\n                \"logic\": \"Uses std::is_same_v to compare the decayed types of T and U.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename U>\n            constexpr bool IsDecayedSameV =\n                std::is_same_v<std::decay_t<T>, std::decay_t<U>>;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsStrictlyBaseOfV\",\n                \"about\": \"Inline variable to check if B is a strict base of D.\",\n                \"logic\": \"Uses std::is_base_of_v and IsDecayedSameV to determine if B is a base of D, but not the same type.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename B, typename D>\n            constexpr bool IsStrictlyBaseOfV =\n                std::is_base_of_v<std::decay_t<B>, std::decay_t<D>> &&\n                !IsDecayedSameV<B, D>;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsAnyMemberTypeV\",\n                \"about\": \"Inline variable to check if a type is any kind of Member type.\",\n                \"logic\": \"Specialized template for BasicMember to return true, otherwise false.\",\n                \"dependencies\": [\n                    \"BasicMember\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            constexpr bool IsAnyMemberTypeV = false;\n\n            template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,\n                    typename CheckingPolicy, typename StorageType>\n            constexpr bool IsAnyMemberTypeV<internal::BasicMember<\n                T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy, StorageType>> = true;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsGarbageCollectedMixinTypeV\",\n                \"about\": \"Inline variable for accessing the value of IsGarbageCollectedMixinType.\",\n                \"logic\": \"A constexpr variable that stores the result of IsGarbageCollectedMixinType<T>::value.\",\n                \"dependencies\": [\n                    \"IsGarbageCollectedMixinType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for types that inherit from `GarbageCollectedMixin` but not\n             * `GarbageCollected<T>` (i.e., they are free mixins), and false otherwise.\n             */\n            template <typename T>\n            constexpr bool IsGarbageCollectedMixinTypeV =\n                internal::IsGarbageCollectedMixinType<T>::value;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsGarbageCollectedTypeV\",\n                \"about\": \"Inline variable for accessing the value of IsGarbageCollectedType.\",\n                \"logic\": \"A constexpr variable that stores the result of IsGarbageCollectedType<T>::value.\",\n                \"dependencies\": [\n                    \"IsGarbageCollectedType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for types that inherit from `GarbageCollected<T>`, and false\n             * otherwise.\n             */\n            template <typename T>\n            constexpr bool IsGarbageCollectedTypeV =\n                internal::IsGarbageCollectedType<T>::value;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsGarbageCollectedOrMixinTypeV\",\n                \"about\": \"Inline variable for accessing the value of IsGarbageCollectedOrMixinType.\",\n                \"logic\": \"A constexpr variable that stores the result of IsGarbageCollectedOrMixinType<T>::value.\",\n                \"dependencies\": [\n                    \"IsGarbageCollectedOrMixinType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for types that inherit from either `GarbageCollected<T>` or\n             * `GarbageCollectedMixin`, and false otherwise.\n             */\n            template <typename T>\n            constexpr bool IsGarbageCollectedOrMixinTypeV =\n                internal::IsGarbageCollectedOrMixinType<T>::value;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsGarbageCollectedWithMixinTypeV\",\n                \"about\": \"Inline variable for accessing the value of IsGarbageCollectedWithMixinType.\",\n                \"logic\": \"A constexpr variable that stores the result of IsGarbageCollectedWithMixinType<T>::value.\",\n                \"dependencies\": [\n                    \"IsGarbageCollectedWithMixinType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for types that inherit from `GarbageCollected<T>` and\n             * `GarbageCollectedMixin`, and false otherwise.\n             */\n            template <typename T>\n            constexpr bool IsGarbageCollectedWithMixinTypeV =\n                internal::IsGarbageCollectedWithMixinType<T>::value;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsMemberTypeV\",\n                \"about\": \"Inline variable for accessing the value of IsMemberType.\",\n                \"logic\": \"A constexpr variable that stores the result of IsMemberType<T>::value.\",\n                \"dependencies\": [\n                    \"IsMemberType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for types of type `Member<T>`, and false otherwise.\n             */\n            template <typename T>\n            constexpr bool IsMemberTypeV = internal::IsMemberType<T>::value;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsUntracedMemberTypeV\",\n                \"about\": \"Inline variable for accessing the value of IsUntracedMemberType.\",\n                \"logic\": \"A constexpr variable that stores the result of IsUntracedMemberType<T>::value.\",\n                \"dependencies\": [\n                    \"IsUntracedMemberType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for types of type `UntracedMember<T>`, and false otherwise.\n             */\n            template <typename T>\n            constexpr bool IsUntracedMemberTypeV = internal::IsUntracedMemberType<T>::value;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsWeakMemberTypeV\",\n                \"about\": \"Inline variable for accessing the value of IsWeakMemberType.\",\n                \"logic\": \"A constexpr variable that stores the result of IsWeakMemberType<T>::value.\",\n                \"dependencies\": [\n                    \"IsWeakMemberType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for types of type `WeakMember<T>`, and false otherwise.\n             */\n            template <typename T>\n            constexpr bool IsWeakMemberTypeV = internal::IsWeakMemberType<T>::value;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsWeakV\",\n                \"about\": \"Inline variable for accessing the value of IsWeak.\",\n                \"logic\": \"A constexpr variable that stores the result of IsWeak<T>::value.\",\n                \"dependencies\": [\n                    \"IsWeak\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for types that are considered weak references, and false\n             * otherwise.\n             */\n            template <typename T>\n            constexpr bool IsWeakV = internal::IsWeak<T>::value;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsCompleteV\",\n                \"about\": \"Inline variable for accessing the value of IsComplete.\",\n                \"logic\": \"A constexpr variable that stores the result of IsComplete<T>::value.\",\n                \"dependencies\": [\n                    \"IsComplete\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for types that are complete, and false otherwise.\n             */\n            template <typename T>\n            constexpr bool IsCompleteV = internal::IsComplete<T>::value;\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsMemberOrWeakMemberTypeV\",\n                \"about\": \"Inline variable to check if a type is a Member or WeakMember type.\",\n                \"logic\": \"Uses IsMemberTypeV and IsWeakMemberTypeV to determine if a type is either a Member or a WeakMember.\",\n                \"dependencies\": [\n                    \"IsMemberTypeV\",\n                    \"IsWeakMemberTypeV\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for member types `Member<T>` and `WeakMember<T>`.\n             */\n            template <typename T>\n            constexpr bool IsMemberOrWeakMemberTypeV =\n                IsMemberTypeV<T> || IsWeakMemberTypeV<T>;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsAnyMemberTypeV\",\n                \"about\": \"Inline variable for accessing the value of IsAnyMemberTypeV.\",\n                \"logic\": \"A constexpr variable that stores the result of IsAnyMemberTypeV<T>::value.\",\n                \"dependencies\": [\n                    \"IsAnyMemberTypeV\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            /**\n             * Value is true for any member type.\n             */\n            template <typename T>\n            constexpr bool IsAnyMemberTypeV = internal::IsAnyMemberTypeV<std::decay_t<T>>;\n\n            }  // namespace internal\n\n            }  // namespace cppgc\n        ]]></code>\n    </func>\n</file>\n```"
}