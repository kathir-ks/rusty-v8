{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/bytecode-analysis.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/bytecode-analysis.cc\",\n            \"file_name\": \"bytecode-analysis.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Analyzes bytecode arrays to determine liveness information, loop assignments, and resume jump targets for generators.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for bytecode analysis, utility functions, bytecode definitions, object representation, and output streams.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/bytecode-analysis.h\"\n\n            #include <utility>\n\n            #include \"src/compiler/bytecode-liveness-map.h\"\n            #include \"src/interpreter/bytecode-array-iterator.h\"\n            #include \"src/interpreter/bytecode-array-random-iterator.h\"\n            #include \"src/interpreter/bytecodes.h\"\n            #include \"src/objects/objects-inl.h\"\n            #include \"src/utils/ostreams.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BytecodeLoopAssignments\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents register assignments within a bytecode loop, tracking which registers are assigned in the loop.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"parameter_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the number of parameters in the bytecode array.\"\n                    },\n                    {\n                        \"name\": \"bit_vector_\",\n                        \"type\": \"BitVector*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores a bit vector representing the registers assigned in the loop.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"interpreter::Register\",\n                    \"BitVector\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class BytecodeLoopAssignments {\n            public:\n              BytecodeLoopAssignments(int parameter_count,\n                                                       int register_count, Zone* zone)\n                  : parameter_count_(parameter_count),\n                    bit_vector_(\n                        zone->New<BitVector>(parameter_count + register_count, zone)) {}\n\n              void Add(interpreter::Register r);\n              void AddList(interpreter::Register r, uint32_t count);\n              void Union(const BytecodeLoopAssignments& other);\n              bool ContainsParameter(int index) const;\n              bool ContainsLocal(int index) const;\n\n            private:\n              int parameter_count_;\n              BitVector* bit_vector_;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Add\",\n                \"parent\": \"BytecodeLoopAssignments\",\n                \"about\": \"Adds a register to the set of assigned registers in the loop.\",\n                \"logic\": \"If the register is a parameter, adds its parameter index to the bit vector. Otherwise, adds the register's index offset by the parameter count.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"r\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The register to add to the assignment set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"interpreter::Register\",\n                    \"BitVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BytecodeLoopAssignments::Add(interpreter::Register r) {\n              if (r.is_parameter()) {\n                bit_vector_->Add(r.ToParameterIndex());\n              } else {\n                bit_vector_->Add(parameter_count_ + r.index());\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddList\",\n                \"parent\": \"BytecodeLoopAssignments\",\n                \"about\": \"Adds a list of registers to the set of assigned registers in the loop.\",\n                \"logic\": \"Iterates through the count, adding each register to the bit vector. It asserts that the register remains a parameter/local depending on the initial register's parameter status.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"r\",\n                        \"type\": \"interpreter::Register\",\n                        \"purpose\": \"The first register in the list to add to the assignment set.\"\n                    },\n                    {\n                        \"name\": \"count\",\n                        \"type\": \"uint32_t\",\n                        \"purpose\": \"The number of registers to add to the assignment set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"interpreter::Register\",\n                    \"BitVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BytecodeLoopAssignments::AddList(interpreter::Register r, uint32_t count) {\n              if (r.is_parameter()) {\n                for (uint32_t i = 0; i < count; i++) {\n                  DCHECK(interpreter::Register(r.index() + i).is_parameter());\n                  bit_vector_->Add(r.ToParameterIndex() + i);\n                }\n              } else {\n                for (uint32_t i = 0; i < count; i++) {\n                  DCHECK(!interpreter::Register(r.index() + i).is_parameter());\n                  bit_vector_->Add(parameter_count_ + r.index() + i);\n                }\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Union\",\n                \"parent\": \"BytecodeLoopAssignments\",\n                \"about\": \"Performs a union operation with another BytecodeLoopAssignments object, combining their assigned register sets.\",\n                \"logic\": \"Unions the underlying bit vectors to combine the sets of assigned registers.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"other\",\n                        \"type\": \"const BytecodeLoopAssignments&\",\n                        \"purpose\": \"The other BytecodeLoopAssignments object to union with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"BitVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void BytecodeLoopAssignments::Union(const BytecodeLoopAssignments& other) {\n              bit_vector_->Union(*other.bit_vector_);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ContainsParameter\",\n                \"parent\": \"BytecodeLoopAssignments\",\n                \"about\": \"Checks if a given parameter index is contained in the assignment set.\",\n                \"logic\": \"Checks if the bit vector contains the given parameter index.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The parameter index to check for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the parameter index is in the assignment set, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BitVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool BytecodeLoopAssignments::ContainsParameter(int index) const {\n              DCHECK_GE(index, 0);\n              DCHECK_LT(index, parameter_count());\n              return bit_vector_->Contains(index);\n            }\n        ]]></code>\n    </func>\n        <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ContainsLocal\",\n                \"parent\": \"BytecodeLoopAssignments\",\n                \"about\": \"Checks if a given local register index is contained in the assignment set.\",\n                \"logic\": \"Checks if the bit vector contains the given local register index, offset by the number of parameters.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The local register index to check for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the local register index is in the assignment set, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"BitVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool BytecodeLoopAssignments::ContainsLocal(int index) const {\n              DCHECK_GE(index, 0);\n              DCHECK_LT(index, local_count());\n              return bit_vector_->Contains(parameter_count_ + index);\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ResumeJumpTarget\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents a jump target for resuming a generator, including suspend ID and target offsets.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"suspend_id_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The ID of the suspend operation that this target resumes.\"\n                    },\n                    {\n                        \"name\": \"target_offset_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The offset to jump to resume the generator.\"\n                    },\n                    {\n                        \"name\": \"final_target_offset_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The ultimate offset to jump to after a series of AtLoopHeader calls.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            ResumeJumpTarget::ResumeJumpTarget(int suspend_id, int target_offset,\n                                                   int final_target_offset)\n                : suspend_id_(suspend_id),\n                  target_offset_(target_offset),\n                  final_target_offset_(final_target_offset) {}\n\n            ResumeJumpTarget ResumeJumpTarget::Leaf(int suspend_id, int target_offset) {\n              return ResumeJumpTarget(suspend_id, target_offset, target_offset);\n            }\n\n            ResumeJumpTarget ResumeJumpTarget::AtLoopHeader(int loop_header_offset,\n                                                        const ResumeJumpTarget& next) {\n              return ResumeJumpTarget(next.suspend_id(), loop_header_offset,\n                                      next.target_offset());\n            }\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"UpdateInLivenessForOutOperand\",\n                \"parent\": null,\n                \"about\": \"Updates the in-liveness state based on output operands of a bytecode.\",\n                \"logic\": \"Marks registers used as output operands as dead in the in-liveness state, meaning their previous values are no longer needed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_liveness\",\n                        \"type\": \"BytecodeLivenessState*\",\n                        \"purpose\": \"The in-liveness state to update.\"\n                    },\n                    {\n                        \"name\": \"iterator\",\n                        \"type\": \"const interpreter::BytecodeArrayIterator&\",\n                        \"purpose\": \"The bytecode array iterator providing information about the current bytecode.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"BytecodeLivenessState\",\n                    \"interpreter::BytecodeArrayIterator\",\n                    \"interpreter::Register\",\n                    \"Bytecodes\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <Bytecode bytecode, OperandType operand_type, size_t i>\n            void UpdateInLivenessForOutOperand(\n                BytecodeLivenessState* in_liveness,\n                const interpreter::BytecodeArrayIterator& iterator) {\n              if constexpr (operand_type == OperandType::kRegOut ||\n                            operand_type == OperandType::kRegInOut) {\n                Register r = iterator.GetRegisterOperand(i);\n                if (!r.is_parameter()) {\n                  in_liveness->MarkRegisterDead(r.index());\n                }\n              } else if constexpr (operand_type == OperandType::kRegOutList) {\n                Register r = iterator.GetRegisterOperand(i);\n                uint32_t reg_count = iterator.GetRegisterCountOperand(i + 1);\n                if (!r.is_parameter()) {\n                  for (uint32_t j = 0; j < reg_count; ++j) {\n                    DCHECK(!Register(r.index() + j).is_parameter());\n                    in_liveness->MarkRegisterDead(r.index() + j);\n                  }\n                }\n              } else if constexpr (operand_type == OperandType::kRegOutPair) {\n                Register r = iterator.GetRegisterOperand(i);\n                if (!r.is_parameter()) {\n                  DCHECK(!Register(r.index() + 1).is_parameter());\n                  in_liveness->MarkRegisterDead(r.index());\n                  in_liveness->MarkRegisterDead(r.index() + 1);\n                }\n              } else if constexpr (operand_type == OperandType::kRegOutTriple) {\n                Register r = iterator.GetRegisterOperand(i);\n                if (!r.is_parameter()) {\n                  DCHECK(!Register(r.index() + 1).is_parameter());\n                  DCHECK(!Register(r.index() + 2).is_parameter());\n                  in_liveness->MarkRegisterDead(r.index());\n                  in_liveness->MarkRegisterDead(r.index() + 1);\n                  in_liveness->MarkRegisterDead(r.index() + 2);\n                }\n              } else {\n                DCHECK(!Bytecodes::IsRegisterOutputOperandType(operand_type));\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"UpdateInLivenessForInOperand\",\n                \"parent\": null,\n                \"about\": \"Updates the in-liveness state based on input operands of a bytecode.\",\n                \"logic\": \"Marks registers used as input operands as live in the in-liveness state, meaning their values are needed by the current bytecode.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_liveness\",\n                        \"type\": \"BytecodeLivenessState*\",\n                        \"purpose\": \"The in-liveness state to update.\"\n                    },\n                    {\n                        \"name\": \"iterator\",\n                        \"type\": \"const interpreter::BytecodeArrayIterator&\",\n                        \"purpose\": \"The bytecode array iterator providing information about the current bytecode.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"BytecodeLivenessState\",\n                    \"interpreter::BytecodeArrayIterator\",\n                    \"interpreter::Register\",\n                    \"Bytecodes\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <Bytecode bytecode, OperandType operand_type, size_t i>\n            void UpdateInLivenessForInOperand(\n                BytecodeLivenessState* in_liveness,\n                const interpreter::BytecodeArrayIterator& iterator) {\n              if constexpr (operand_type == OperandType::kReg ||\n                            operand_type == OperandType::kRegInOut) {\n                Register r = iterator.GetRegisterOperand(i);\n                if (!r.is_parameter()) {\n                  in_liveness->MarkRegisterLive(r.index());\n                }\n              } else if constexpr (operand_type == OperandType::kRegPair) {\n                Register r = iterator.GetRegisterOperand(i);\n                if (!r.is_parameter()) {\n                  DCHECK(!Register(r.index() + 1).is_parameter());\n                  in_liveness->MarkRegisterLive(r.index());\n                  in_liveness->MarkRegisterLive(r.index() + 1);\n                }\n              } else if constexpr (operand_type == OperandType::kRegList) {\n                Register r = iterator.GetRegisterOperand(i);\n                uint32_t reg_count = iterator.GetRegisterCountOperand(i + 1);\n                if (!r.is_parameter()) {\n                  for (uint32_t j = 0; j < reg_count; ++j) {\n                    DCHECK(!interpreter::Register(r.index() + j).is_parameter());\n                    in_liveness->MarkRegisterLive(r.index() + j);\n                  }\n                }\n              } else {\n                DCHECK(!Bytecodes::IsRegisterInputOperandType(operand_type));\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"UpdateInLiveness\",\n                \"parent\": null,\n                \"about\": \"Updates the in-liveness state based on a bytecode's accumulator and register usage.\",\n                \"logic\": \"Handles accumulator reads/writes and calls `UpdateInLivenessForOutOperand` and `UpdateInLivenessForInOperand` for register operands.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"in_liveness\",\n                        \"type\": \"BytecodeLivenessState*\",\n                        \"purpose\": \"The in-liveness state to update.\"\n                    },\n                    {\n                        \"name\": \"iterator\",\n                        \"type\": \"const interpreter::BytecodeArrayIterator&\",\n                        \"purpose\": \"The bytecode array iterator providing information about the current bytecode.\"\n                    },\n                    {\n                        \"name\": \"operand_index\",\n                        \"type\": \"std::index_sequence<operand_index...>\",\n                        \"purpose\": \"A sequence of indices representing the operands to process.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"BytecodeLivenessState\",\n                    \"interpreter::BytecodeArrayIterator\",\n                    \"interpreter::Register\",\n                    \"Bytecodes\",\n                    \"BytecodeOperands\",\n                    \"UpdateInLivenessForOutOperand\",\n                    \"UpdateInLivenessForInOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <Bytecode bytecode, ImplicitRegisterUse implicit_register_use,\n                      OperandType... operand_types, size_t... operand_index>\n            void UpdateInLiveness(BytecodeLivenessState* in_liveness,\n                                  const interpreter::BytecodeArrayIterator& iterator,\n                                  std::index_sequence<operand_index...>) {\n              // Special case Suspend and Resume to just pass through liveness.\n              if constexpr (bytecode == Bytecode::kSuspendGenerator) {\n                // The generator object has to be live.\n                in_liveness->MarkRegisterLive(iterator.GetRegisterOperand(0).index());\n                // Suspend additionally reads and returns the accumulator\n                DCHECK(Bytecodes::ReadsAccumulator(bytecode));\n                in_liveness->MarkAccumulatorLive();\n                return;\n              } else if constexpr (bytecode == Bytecode::kResumeGenerator) {\n                // The generator object has to be live.\n                in_liveness->MarkRegisterLive(iterator.GetRegisterOperand(0).index());\n                return;\n              }\n\n              // Otherwise, walk all accumulator and register writes and reads.\n              if constexpr (BytecodeOperands::WritesAccumulator(implicit_register_use)) {\n                in_liveness->MarkAccumulatorDead();\n              }\n              DCHECK_IMPLIES(BytecodeOperands::ClobbersAccumulator(implicit_register_use),\n                             !in_liveness->AccumulatorIsLive());\n              (UpdateInLivenessForOutOperand<bytecode, operand_types, operand_index>(\n                   in_liveness, iterator),\n               ...);\n\n              if constexpr (BytecodeOperands::WritesImplicitRegister(\n                                  implicit_register_use)) {\n                in_liveness->MarkRegisterDead(Register::FromShortStar(bytecode).index());\n              }\n\n              if constexpr (BytecodeOperands::ReadsAccumulator(implicit_register_use)) {\n                in_liveness->MarkAccumulatorLive();\n              }\n              (UpdateInLivenessForInOperand<bytecode, operand_types, operand_index>(\n                   in_liveness, iterator),\n               ...);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"UpdateInLiveness\",\n                \"parent\": null,\n                \"about\": \"A wrapper around the templated `UpdateInLiveness` function to handle different bytecode types.\",\n                \"logic\": \"Uses a switch statement to dispatch to the correct templated `UpdateInLiveness` function based on the bytecode.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"bytecode\",\n                        \"type\": \"Bytecode\",\n                        \"purpose\": \"The bytecode to process.\"\n                    },\n                    {\n                        \"name\": \"in_liveness\",\n                        \"type\": \"BytecodeLivenessState*\",\n                        \"purpose\": \"The in-liveness state to update.\"\n                    },\n                    {\n                        \"name\": \"iterator\",\n                        \"type\": \"const interpreter::BytecodeArrayIterator&\",\n                        \"purpose\": \"The bytecode array iterator providing information about the current bytecode.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"BytecodeLivenessState\",\n                    \"interpreter::BytecodeArrayIterator\",\n                    \"UpdateInLiveness\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <Bytecode bytecode, ImplicitRegisterUse implicit_register_use,\n                      OperandType... operand_types>\n            void UpdateInLiveness(BytecodeLivenessState* in_liveness,\n                                  const interpreter::BytecodeArrayIterator& iterator) {\n              UpdateInLiveness<bytecode, implicit_register_use, operand_types...>(\n                  in_liveness, iterator,\n                  std::make_index_sequence<sizeof...(operand_types)>());\n            }\n\n            #ifdef DEBUG\n            void UpdateInLiveness(Bytecode bytecode, BytecodeLivenessState* in_liveness,\n                                  const interpreter::BytecodeArrayIterator& iterator) {\n              switch (bytecode) {\n            #define BYTECODE_UPDATE_IN_LIVENESS(Name, ...)                           \\\n              case Bytecode::k##Name:                                                \\\n                return UpdateInLiveness<Bytecode::k##Name, __VA_ARGS__>(in_liveness, \\\n                                                                        iterator);\n                BYTECODE_LIST(BYTECODE_UPDATE_IN_LIVENESS, BYTECODE_UPDATE_IN_LIVENESS)\n            #undef BYTECODE_UPDATE_IN_LIVENESS\n              }\n            }\n            #endif  // DEBUG\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"EnsureOutLivenessIsNotAlias\",\n                \"parent\": null,\n                \"about\": \"Ensures that the out-liveness state does not alias the next bytecode's in-liveness state.\",\n                \"logic\": \"If the out-liveness state aliases the next bytecode's in-liveness state, allocates a new `BytecodeLivenessState` and copies the data to it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"liveness\",\n                        \"type\": \"BytecodeLiveness&\",\n                        \"purpose\": \"The liveness information for the current bytecode.\"\n                    },\n                    {\n                        \"name\": \"next_bytecode_in_liveness\",\n                        \"type\": \"BytecodeLivenessState*\",\n                        \"purpose\": \"The in-liveness information for the next bytecode.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to allocate from.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"BytecodeLiveness\",\n                    \"BytecodeLivenessState\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <bool IsFirstUpdate = false>\n            void EnsureOutLivenessIsNotAlias(\n                BytecodeLiveness& liveness,\n                BytecodeLivenessState* next_bytecode_in_liveness, Zone* zone) {\n              if (!IsFirstUpdate) {\n                // We should have copied the next bytecode's in liveness already in the\n                // first pass, so on subsequent passes this should already not be an alias.\n                DCHECK_NE(liveness.out, next_bytecode_in_liveness);\n                return;\n              }\n              if (liveness.out == next_bytecode_in_liveness) {\n                // If the out-liveness is aliasing the next bytecode's in-liveness,\n                // reallocate it and copy the data to the newly allocated state.\n                liveness.out =\n                    zone->New<BytecodeLivenessState>(*next_bytecode_in_liveness, zone);\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"UpdateOutLiveness\",\n                \"parent\": null,\n                \"about\": \"Updates the out-liveness based on the bytecode and jump targets.\",\n                \"logic\": \"Determines the out-liveness based on the next bytecode, jump targets, and exception handlers, performing a union of liveness states.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"liveness\",\n                        \"type\": \"BytecodeLiveness&\",\n                        \"purpose\": \"The liveness information for the current bytecode.\"\n                    },\n                    {\n                        \"name\": \"next_bytecode_in_liveness\",\n                        \"type\": \"BytecodeLivenessState*\",\n                        \"purpose\": \"The in-liveness information for the next bytecode.\"\n                    },\n                    {\n                        \"name\": \"iterator\",\n                        \"type\": \"const interpreter::BytecodeArrayIterator&\",\n                        \"purpose\": \"The bytecode array iterator providing information about the current bytecode.\"\n                    },\n                    {\n                        \"name\": \"bytecode_array\",\n                        \"type\": \"DirectHandle<BytecodeArray>\",\n                        \"purpose\": \"The bytecode array being analyzed.\"\n                    },\n                    {\n                        \"name\": \"liveness_map\",\n                        \"type\": \"const BytecodeLivenessMap&\",\n                        \"purpose\": \"The liveness map containing liveness information for other bytecodes.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to allocate from.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"BytecodeLiveness\",\n                    \"BytecodeLivenessState\",\n                    \"interpreter::BytecodeArrayIterator\",\n                    \"DirectHandle<BytecodeArray>\",\n                    \"BytecodeLivenessMap\",\n                    \"Bytecodes\",\n                    \"EnsureOutLivenessIsNotAlias\",\n                    \"HandlerTable\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <bool IsFirstUpdate, Bytecode bytecode>\n            void UpdateOutLiveness(BytecodeLiveness& liveness,\n                                   BytecodeLivenessState* next_bytecode_in_liveness,\n                                   const interpreter::BytecodeArrayIterator& iterator,\n                                   DirectHandle<BytecodeArray> bytecode_array,\n                                   const BytecodeLivenessMap& liveness_map, Zone* zone) {\n              // On subsequent updates, only update out-liveness manually if it isn't\n              // already aliasing the next bytecode's in-liveness.\n              if (!IsFirstUpdate && liveness.out == next_bytecode_in_liveness) return;\n\n              // Special case Suspend and Resume to just pass through liveness.\n              if (bytecode == Bytecode::kSuspendGenerator ||\n                  bytecode == Bytecode::kResumeGenerator) {\n                DCHECK_NOT_NULL(next_bytecode_in_liveness);\n                if (IsFirstUpdate) {\n                  liveness.out = next_bytecode_in_liveness;\n                } else {\n                  liveness.out->Union(*next_bytecode_in_liveness);\n                }\n                return;\n              }\n\n              // Special case SwitchOnGeneratorState to ignore resume liveness, since that's\n              // a pass through. Instead, just consider the fallthrough live, plus the\n              // generator register itself for the resumes.\n              if (bytecode == Bytecode::kSwitchOnGeneratorState) {\n                DCHECK_NOT_NULL(next_bytecode_in_liveness);\n                if (IsFirstUpdate) {\n                  // The generator register won't be live in the fallthrough, so copy the\n                  // liveness and make it live here.\n                  int generator_reg_index = iterator.GetRegisterOperand(0).index();\n                  DCHECK(!next_bytecode_in_liveness->RegisterIsLive(generator_reg_index));\n                  liveness.out =\n                      zone->New<BytecodeLivenessState>(*next_bytecode_in_liveness, zone);\n                  liveness.out->MarkRegisterLive(generator_reg_index);\n                } else {\n                  liveness.out->Union(*next_bytecode_in_liveness);\n                }\n                return;\n              }\n\n              // Update from next bytecode (unless there isn't one or this is an\n              // unconditional jump).\n              if (next_bytecode_in_liveness != nullptr &&\n                  !Bytecodes::IsUnconditionalJump(bytecode) &&\n                  !Bytecodes::Returns(bytecode) &&\n                  !Bytecodes::UnconditionallyThrows(bytecode)) {\n                if (IsFirstUpdate) {\n                  // On first update, we can assume that this out-liveness is the same as\n                  // the next liveness, and can directly alias it -- we'll allocate a new\n                  // one using EnsureOutLivenessIsNotAlias if it needs to be mutated.\n                  DCHECK_NULL(liveness.out);\n                  liveness.out = next_bytecode_in_liveness;\n                } else {\n                  liveness.out->Union(*next_bytecode_in_liveness);\n                }\n              } else if (IsFirstUpdate) {\n                // Otherwise, on the first allocation we need to make sure that there is an\n                // allocated out liveness.\n                DCHECK_NULL(liveness.out);\n                liveness.out = zone->New<BytecodeLivenessState>(\n                    bytecode_array->register_count(), zone);\n              }\n\n              DCHECK_NOT_NULL(liveness.out);\n\n              // Update from jump target (if any). Skip loops, we update these manually in\n              // the liveness iterations.\n              if (Bytecodes::IsForwardJump(bytecode)) {\n                int target_offset = iterator.GetJumpTargetOffset();\n                EnsureOutLivenessIsNotAlias<IsFirstUpdate>(liveness,\n                                                           next_bytecode_in_liveness, zone);\n                liveness.out->Union(*liveness_map.GetInLiveness(target_offset));\n              } else if (Bytecodes::IsSwitch(bytecode)) {\n                EnsureOutLivenessIsNotAlias<IsFirstUpdate>(liveness,\n                                                           next_bytecode_in_liveness, zone);\n                for (interpreter::JumpTableTargetOffset entry :\n                     iterator.GetJumpTableTargetOffsets()) {\n                  liveness.out->Union(*liveness_map.GetInLiveness(entry.target_offset));\n                }\n              }\n\n              // Update from exception handler (if any).\n              if (!interpreter::Bytecodes::IsWithoutExternalSideEffects(bytecode)) {\n                // TODO(leszeks): We should look up this range only once per entry.\n                HandlerTable table(*bytecode_array);\n                int handler_index =\n                    table.LookupHandlerIndexForRange(iterator.current_offset());\n\n                if (handler_index != HandlerTable::kNoHandlerFound) {\n                  EnsureOutLivenessIsNotAlias<IsFirstUpdate>(\n                      liveness, next_bytecode_in_liveness, zone);\n                  bool was_accumulator_live = liveness.out->AccumulatorIsLive();\n                  liveness.out->Union(\n                      *liveness_map.GetInLiveness(table.GetRangeHandler(handler_index)));\n                  liveness.out->MarkRegisterLive(table.GetRangeData(handler_index));\n                  if (!was_accumulator_live) {\n                    // The accumulator is reset to the exception on entry into a handler,\n                    // and so shouldn't be considered live coming out of this bytecode just\n                    // because it's live coming into the handler. So, kill the accumulator\n                    // if the handler is the only thing that made it live.\n                    liveness.out->MarkAccumulatorDead();\n\n                    // TODO(leszeks): Ideally the accumulator wouldn't be considered live at\n                    // the start of the handler, but looking up if the current bytecode is\n                    // the start of a handler is not free, so we should only do it if we\n                    // decide it's necessary.\n                  }\n                }\n              }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"UpdateOutLiveness\",\n                \"parent\": null,\n                \"about\": \"A wrapper around the templated `UpdateOutLiveness` function to handle different bytecode types.\",\n                \"logic\": \"Uses a switch statement to dispatch to the correct templated `UpdateOutLiveness` function based on the bytecode.\",\n                \"parameters\": [\n                    {\n                        "
}