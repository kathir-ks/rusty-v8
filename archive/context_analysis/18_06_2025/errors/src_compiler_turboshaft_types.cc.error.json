{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/types.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/types.cc\",\n        \"file_name\": \"types.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the type system for the Turboshaft compiler, including type representation, equality, subtype checking, and least upper bound computation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for type definitions, standard library components, and V8-specific utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/types.h\"\n\n#include <optional>\n#include <sstream>\n#include <string_view>\n\n#include \"src/base/logging.h\"\n#include \"src/compiler/turboshaft/type-parser.h\"\n#include \"src/heap/factory.h\"\n#include \"src/objects/turboshaft-types-inl.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"uint64_to_high_low\",\n            \"parent\": null,\n            \"about\": \"Converts a 64-bit unsigned integer into a pair of 32-bit unsigned integers representing the high and low parts.\",\n            \"logic\": \"Performs a right bit shift by 32 bits to obtain the high part and a static cast to uint32_t to obtain the low part.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"uint64_t\",\n                    \"purpose\": \"The 64-bit unsigned integer to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::pair<uint32_t, uint32_t>\",\n                \"description\": \"A pair containing the high and low 32-bit parts of the input.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nstd::pair<uint32_t, uint32_t> uint64_to_high_low(uint64_t value) {\n  return {static_cast<uint32_t>(value >> 32), static_cast<uint32_t>(value)};\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Equals\",\n            \"parent\": \"Type\",\n            \"about\": \"Checks if two Type objects are equal.\",\n            \"logic\": \"Compares the kinds of the two types. If the kinds are the same, it calls the Equals method of the specific type (Word32, Word64, Float32, Float64, Tuple).\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const Type&\",\n                    \"purpose\": \"The other Type object to compare with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the two types are equal, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"AsWord32\",\n                \"AsWord64\",\n                \"AsFloat32\",\n                \"AsFloat64\",\n                \"AsTuple\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Type::Equals(const Type& other) const {\n  DCHECK(!IsInvalid());\n  DCHECK(!other.IsInvalid());\n\n  if (kind_ != other.kind_) return false;\n  switch (kind_) {\n    case Kind::kInvalid:\n      UNREACHABLE();\n    case Kind::kNone:\n      return true;\n    case Kind::kWord32:\n      return AsWord32().Equals(other.AsWord32());\n    case Kind::kWord64:\n      return AsWord64().Equals(other.AsWord64());\n    case Kind::kFloat32:\n      return AsFloat32().Equals(other.AsFloat32());\n    case Kind::kFloat64:\n      return AsFloat64().Equals(other.AsFloat64());\n    case Kind::kTuple:\n      return AsTuple().Equals(other.AsTuple());\n    case Kind::kAny:\n      return true;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsSubtypeOf\",\n            \"parent\": \"Type\",\n            \"about\": \"Checks if the current Type object is a subtype of another Type object.\",\n            \"logic\": \"If the other type is Any or the current type is None, it returns true. Otherwise, it checks if the kinds are the same and calls the IsSubtypeOf method of the specific type (Word32, Word64, Float32, Float64, Tuple).\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const Type&\",\n                    \"purpose\": \"The other Type object to check against.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the current type is a subtype of the other type, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"AsWord32\",\n                \"AsWord64\",\n                \"AsFloat32\",\n                \"AsFloat64\",\n                \"AsTuple\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Type::IsSubtypeOf(const Type& other) const {\n  DCHECK(!IsInvalid());\n  DCHECK(!other.IsInvalid());\n\n  if (other.IsAny() || IsNone()) return true;\n  if (kind_ != other.kind_) return false;\n\n  switch (kind_) {\n    case Kind::kInvalid:\n    case Kind::kNone:\n      UNREACHABLE();\n    case Kind::kWord32:\n      return AsWord32().IsSubtypeOf(other.AsWord32());\n    case Kind::kWord64:\n      return AsWord64().IsSubtypeOf(other.AsWord64());\n    case Kind::kFloat32:\n      return AsFloat32().IsSubtypeOf(other.AsFloat32());\n    case Kind::kFloat64:\n      return AsFloat64().IsSubtypeOf(other.AsFloat64());\n    case Kind::kTuple:\n      return AsTuple().IsSubtypeOf(other.AsTuple());\n    case Kind::kAny:\n      UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PrintTo\",\n            \"parent\": \"Type\",\n            \"about\": \"Prints the Type object to an output stream.\",\n            \"logic\": \"Switches on the kind of the type and calls the PrintTo method of the specific type (Word32, Word64, Float32, Float64, Tuple).\",\n            \"parameters\": [\n                {\n                    \"name\": \"stream\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream to print to.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"AsWord32\",\n                \"AsWord64\",\n                \"AsFloat32\",\n                \"AsFloat64\",\n                \"AsTuple\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Type::PrintTo(std::ostream& stream) const {\n  switch (kind_) {\n    case Kind::kInvalid:\n      UNREACHABLE();\n    case Kind::kNone:\n      stream << \"None\";\n      break;\n    case Kind::kWord32: {\n      AsWord32().PrintTo(stream);\n      break;\n    }\n    case Kind::kWord64: {\n      AsWord64().PrintTo(stream);\n      break;\n    }\n    case Kind::kFloat32: {\n      AsFloat32().PrintTo(stream);\n      break;\n    }\n    case Kind::kFloat64: {\n      AsFloat64().PrintTo(stream);\n      break;\n    }\n    case Kind::kTuple: {\n      AsTuple().PrintTo(stream);\n      break;\n    }\n    case Kind::kAny: {\n      stream << \"Any\";\n      break;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Print\",\n            \"parent\": \"Type\",\n            \"about\": \"Prints the Type object to the standard output stream.\",\n            \"logic\": \"Creates a StdoutStream object and calls the PrintTo method with it.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PrintTo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Type::Print() const {\n  StdoutStream os;\n  PrintTo(os);\n  os << '\\n';\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"LeastUpperBound\",\n            \"parent\": \"Type\",\n            \"about\": \"Computes the least upper bound of two Type objects.\",\n            \"logic\": \"If either type is Any, returns Any. If either type is None, returns the other type. Otherwise, checks if the kinds are the same and calls the LeastUpperBound method of the specific type (Word32, Word64, Float32, Float64, Tuple).\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const Type&\",\n                    \"purpose\": \"The first Type object.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const Type&\",\n                    \"purpose\": \"The second Type object.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone to allocate memory from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Type\",\n                \"description\": \"The least upper bound of the two types.\"\n            },\n            \"dependencies\": [\n                \"Word32Type::LeastUpperBound\",\n                \"Word64Type::LeastUpperBound\",\n                \"Float32Type::LeastUpperBound\",\n                \"Float64Type::LeastUpperBound\",\n                \"TupleType::LeastUpperBound\",\n                \"Any\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nType Type::LeastUpperBound(const Type& lhs, const Type& rhs, Zone* zone) {\n  if (lhs.IsAny() || rhs.IsAny()) return Type::Any();\n  if (lhs.IsNone()) return rhs;\n  if (rhs.IsNone()) return lhs;\n\n  // TODO(nicohartmann@): We might use more precise types here but currently\n  // there is not much benefit in that.\n  if (lhs.kind() != rhs.kind()) return Type::Any();\n\n  switch (lhs.kind()) {\n    case Type::Kind::kInvalid:\n    case Type::Kind::kNone:\n    case Type::Kind::kAny:\n      UNREACHABLE();\n    case Type::Kind::kWord32:\n      return Word32Type::LeastUpperBound(lhs.AsWord32(), rhs.AsWord32(), zone);\n    case Type::Kind::kWord64:\n      return Word64Type::LeastUpperBound(lhs.AsWord64(), rhs.AsWord64(), zone);\n    case Type::Kind::kFloat32:\n      return Float32Type::LeastUpperBound(lhs.AsFloat32(), rhs.AsFloat32(),\n                                          zone);\n    case Type::Kind::kFloat64:\n      return Float64Type::LeastUpperBound(lhs.AsFloat64(), rhs.AsFloat64(),\n                                          zone);\n    case Type::Kind::kTuple:\n      return TupleType::LeastUpperBound(lhs.AsTuple(), rhs.AsTuple(), zone);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"ParseFromString\",\n            \"parent\": \"Type\",\n            \"about\": \"Parses a Type object from a string.\",\n            \"logic\": \"Creates a TypeParser object and calls its Parse method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"const std::string_view&\",\n                    \"purpose\": \"The string to parse from.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone to allocate memory from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<Type>\",\n                \"description\": \"The parsed Type object, or std::nullopt if parsing fails.\"\n            },\n            \"dependencies\": [\n                \"TypeParser::Parse\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::optional<Type> Type::ParseFromString(const std::string_view& str,\n                                          Zone* zone) {\n  TypeParser parser(str, zone);\n  return parser.Parse();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllocateOnHeap\",\n            \"parent\": \"Type\",\n            \"about\": \"Allocates a TurboshaftType object on the heap.\",\n            \"logic\": \"Switches on the kind of the type and calls the AllocateOnHeap method of the specific type (Word32, Word64, Float32, Float64).\",\n            \"parameters\": [\n                {\n                    \"name\": \"factory\",\n                    \"type\": \"Factory*\",\n                    \"purpose\": \"The factory to use for allocation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Handle<TurboshaftType>\",\n                \"description\": \"A handle to the allocated TurboshaftType object.\"\n            },\n            \"dependencies\": [\n                \"AsWord32\",\n                \"AsWord64\",\n                \"AsFloat32\",\n                \"AsFloat64\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nHandle<TurboshaftType> Type::AllocateOnHeap(Factory* factory) const {\n  DCHECK_NOT_NULL(factory);\n  switch (kind_) {\n    case Kind::kInvalid:\n      UNREACHABLE();\n    case Kind::kNone:\n      UNIMPLEMENTED();\n    case Kind::kWord32:\n      return AsWord32().AllocateOnHeap(factory);\n    case Kind::kWord64:\n      return AsWord64().AllocateOnHeap(factory);\n    case Kind::kFloat32:\n      return AsFloat32().AllocateOnHeap(factory);\n    case Kind::kFloat64:\n      return AsFloat64().AllocateOnHeap(factory);\n    case Kind::kTuple:\n      UNIMPLEMENTED();\n    case Kind::kAny:\n      UNIMPLEMENTED();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Contains\",\n            \"parent\": \"WordType\",\n            \"about\": \"Checks if a word value is contained within the WordType.\",\n            \"logic\": \"Checks if the subkind is range or set and does range or set contains check respectively.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"word_t\",\n                    \"purpose\": \"The word value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the value is contained, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <size_t Bits>\nbool WordType<Bits>::Contains(word_t value) const {\n  switch (sub_kind()) {\n    case SubKind::kRange: {\n      if (is_wrapping()) return range_to() >= value || range_from() <= value;\n      return range_from() <= value && value <= range_to();\n    }\n    case SubKind::kSet: {\n      for (int i = 0; i < set_size(); ++i) {\n        if (set_element(i) == value) return true;\n      }\n      return false;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Equals\",\n            \"parent\": \"WordType\",\n            \"about\": \"Checks if two WordType objects are equal.\",\n            \"logic\": \"Checks if the subkind is the same and does range or set equality check respectively.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const WordType<Bits>&\",\n                    \"purpose\": \"The other WordType object to compare with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the two types are equal, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <size_t Bits>\nbool WordType<Bits>::Equals(const WordType<Bits>& other) const {\n  if (sub_kind() != other.sub_kind()) return false;\n  switch (sub_kind()) {\n    case SubKind::kRange:\n      return (range_from() == other.range_from() &&\n              range_to() == other.range_to()) ||\n             (is_any() && other.is_any());\n    case SubKind::kSet: {\n      if (set_size() != other.set_size()) return false;\n      for (int i = 0; i < set_size(); ++i) {\n        if (set_element(i) != other.set_element(i)) return false;\n      }\n      return true;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsSubtypeOf\",\n            \"parent\": \"WordType\",\n            \"about\": \"Checks if the current WordType object is a subtype of another WordType object.\",\n            \"logic\": \"Checks if the other type is Any or if the subkind is the same and does range or set subtype check respectively.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const WordType<Bits>&\",\n                    \"purpose\": \"The other WordType object to check against.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the current type is a subtype of the other type, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Contains\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <size_t Bits>\nbool WordType<Bits>::IsSubtypeOf(const WordType<Bits>& other) const {\n  if (other.is_any()) return true;\n  switch (sub_kind()) {\n    case SubKind::kRange: {\n      if (other.is_set()) return false;\n      DCHECK(other.is_range());\n      if (is_wrapping() == other.is_wrapping()) {\n        return range_from() >= other.range_from() &&\n               range_to() <= other.range_to();\n      }\n      return !is_wrapping() && (range_to() <= other.range_to() ||\n                                range_from() >= other.range_from());\n    }\n    case SubKind::kSet: {\n      if (other.is_set() && set_size() > other.set_size()) return false;\n      for (int i = 0; i < set_size(); ++i) {\n        if (!other.Contains(set_element(i))) return false;\n      }\n      return true;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"LeastUpperBoundFromRanges\",\n            \"parent\": null,\n            \"about\": \"Computes the least upper bound of two word ranges, handling wrapping ranges.\",\n            \"logic\": \"Handles different cases based on whether the ranges are wrapping or not, and calculates the appropriate upper bound range.\",\n            \"parameters\": [\n                {\n                    \"name\": \"l_from\",\n                    \"type\": \"word_t\",\n                    \"purpose\": \"The lower bound of the first range.\"\n                },\n                {\n                    \"name\": \"l_to\",\n                    \"type\": \"word_t\",\n                    \"purpose\": \"The upper bound of the first range.\"\n                },\n                {\n                    \"name\": \"r_from\",\n                    \"type\": \"word_t\",\n                    \"purpose\": \"The lower bound of the second range.\"\n                },\n                {\n                    \"name\": \"r_to\",\n                    \"type\": \"word_t\",\n                    \"purpose\": \"The upper bound of the second range.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone to allocate memory from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"WordType<Bits>\",\n                \"description\": \"The least upper bound of the two ranges.\"\n            },\n            \"dependencies\": [\n                \"WordType<Bits>::Range\",\n                \"WordType<Bits>::Any\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <size_t Bits, typename word_t = typename WordType<Bits>::word_t>\nWordType<Bits> LeastUpperBoundFromRanges(word_t l_from, word_t l_to,\n                                         word_t r_from, word_t r_to,\n                                         Zone* zone) {\n  const bool lhs_wrapping = l_to < l_from;\n  const bool rhs_wrapping = r_to < r_from;\n  // Case 1: Both ranges non-wrapping\n  // lhs ---|XXX|--  --|XXX|---  -|XXXXXX|-  ---|XX|--- -|XX|------\n  // rhs -|XXX|----  ----|XXX|-  ---|XX|---  -|XXXXXX|- ------|XX|-\n  // ==> -|XXXXX|--  --|XXXXX|-  -|XXXXXX|-  -|XXXXXX|- -|XXXXXXX|-\n  if (!lhs_wrapping && !rhs_wrapping) {\n    return WordType<Bits>::Range(std::min(l_from, r_from), std::max(l_to, r_to),\n                                 zone);\n  }\n  // Case 2: Both ranges wrapping\n  // lhs XXX|----|XXX   X|---|XXXXXX   XXXXXX|---|X   XX|--|XXXXXX\n  // rhs X|---|XXXXXX   XXX|----|XXX   XX|--|XXXXXX   XXXXXX|--|XX\n  // ==> XXX|-|XXXXXX   XXX|-|XXXXXX   XXXXXXXXXXXX   XXXXXXXXXXXX\n  if (lhs_wrapping && rhs_wrapping) {\n    const auto from = std::min(l_from, r_from);\n    const auto to = std::max(l_to, r_to);\n    if (to >= from) return WordType<Bits>::Any();\n    auto result = WordType<Bits>::Range(from, to, zone);\n    DCHECK(result.is_wrapping());\n    return result;\n  }\n\n  if (rhs_wrapping)\n    return LeastUpperBoundFromRanges<Bits>(r_from, r_to, l_from, l_to, zone);\n  DCHECK(lhs_wrapping);\n  DCHECK(!rhs_wrapping);\n  // Case 3 & 4: lhs is wrapping, rhs is not\n  // lhs XXX|----|XXX   XXX|----|XXX   XXXXX|--|XXX   X|-------|XX\n  // rhs -------|XX|-   -|XX|-------   ----|XXXXX|-   ---|XX|-----\n  // ==> XXX|---|XXXX   XXXX|---|XXX   XXXXXXXXXXXX   XXXXXX|--|XX\n  if (r_from <= l_to) {\n    if (r_to <= l_to)\n      return WordType<Bits>::Range(l_from, l_to, zone);       // y covered by x\n    if (r_to >= l_from) return WordType<Bits>::Any();         // ex3\n    auto result = WordType<Bits>::Range(l_from, r_to, zone);  // ex 1\n    DCHECK(result.is_wrapping());\n    return result;\n  } else if (r_to >= l_from) {\n    if (r_from >= l_from)\n      return WordType<Bits>::Range(l_from, l_to, zone);       // y covered by x\n    DCHECK_GT(r_from, l_to);                                  // handled above\n    auto result = WordType<Bits>::Range(r_from, l_to, zone);  // ex 2\n    DCHECK(result.is_wrapping());\n    return result;\n  } else {\n    const auto df = r_from - l_to;\n    const auto dt = l_from - r_to;\n    WordType<Bits> result =\n        df > dt ? WordType<Bits>::Range(r_from, l_to, zone)  // ex 4\n                : WordType<Bits>::Range(l_from, r_to, zone);\n    DCHECK(result.is_wrapping());\n    return result;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"LeastUpperBound\",\n            \"parent\": \"WordType\",\n            \"about\": \"Computes the least upper bound of two WordType objects.\",\n            \"logic\": \"Handles cases where one or both types are sets, and calls LeastUpperBoundFromRanges if both are ranges.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const WordType<Bits>&\",\n                    \"purpose\": \"The first WordType object.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const WordType<Bits>&\",\n                    \"purpose\": \"The second WordType object.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone to allocate memory from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"WordType<Bits>\",\n                \"description\": \"The least upper bound of the two types.\"\n            },\n            \"dependencies\": [\n                \"LeastUpperBoundFromRanges\",\n                \"WordType<Bits>::Range\",\n                \"WordType<Bits>::Set\",\n                \"Contains\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <size_t Bits>\n// static\nWordType<Bits> WordType<Bits>::LeastUpperBound(const WordType<Bits>& lhs,\n                                               const WordType<Bits>& rhs,\n                                               Zone* zone) {\n  if (lhs.is_set()) {\n    if (!rhs.is_set()) {\n      if (lhs.set_size() == 1) {\n        word_t e = lhs.set_element(0);\n        if (rhs.is_wrapping()) {\n          // If {rhs} already contains e, {rhs} is the upper bound.\n          if (e <= rhs.range_to() || rhs.range_from() <= e) return rhs;\n          return (e - rhs.range_to() < rhs.range_from() - e)\n                     ? Range(rhs.range_from(), e, zone)\n                     : Range(e, rhs.range_to(), zone);\n        }\n        return Range(std::min(e, rhs.range_from()), std::max(e, rhs.range_to()),\n                     zone);\n      }\n\n      // TODO(nicohartmann@): A wrapping range may be a better fit in some\n      // cases.\n      return LeastUpperBoundFromRanges<Bits>(\n          lhs.unsigned_min(), lhs.unsigned_max(), rhs.range_from(),\n          rhs.range_to(), zone);\n    }\n\n    // Both sides are sets. We try to construct the combined set.\n    base::SmallVector<word_t, kMaxSetSize * 2> result_elements;\n    base::vector_append(result_elements, lhs.set_elements());\n    base::vector_append(result_elements, rhs.set_elements());\n    DCHECK(!result_elements.empty());\n    base::sort(result_elements);\n    auto it = std::unique(result_elements.begin(), result_elements.end());\n    result_elements.pop_back(std::distance(it, result_elements.end()));\n    if (result_elements.size() <= kMaxSetSize) {\n      return Set(result_elements, zone);\n    }\n    // We have to construct a range instead.\n    // TODO(nicohartmann@): A wrapping range may be a better fit in some cases.\n    return Range(result_elements.front(), result_elements.back(), zone);\n  } else if (rhs.is_set()) {\n    return LeastUpperBound(rhs, lhs, zone);\n  }\n\n  // Both sides are ranges.\n  return LeastUpperBoundFromRanges<Bits>(\n      lhs.range_from(), lhs.range_to(), rhs.range_from(), rhs.range_to(), zone);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"Intersect\",\n            \"parent\": \"WordType\",\n            \"about\": \"Computes the intersection of two WordType objects.\",\n            \"logic\": \"Handles cases where one or both types are Any, and if the types are sets, then it calculates set intersections. Otherwise does range intersection.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const WordType<Bits>&\",\n                    \"purpose\": \"The first WordType object.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const WordType<Bits>&\",\n                    \"purpose\": \"The second WordType object.\"\n                },\n                {\n                    \"name\": \"resolution_mode\",\n                    \"type\": \"ResolutionMode\",\n                    \"purpose\": \"The resolution mode to use.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone to allocate memory from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Type\",\n                \"description\": \"The intersection of the two types.\"\n            },\n            \"dependencies\": [\n                \"WordType::Set\",\n                \"WordType::Range\",\n                \"LeastUpperBound\",\n                \"Contains\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <size_t Bits>\nType WordType<Bits>::Intersect(const WordType<Bits>& lhs,\n                               const WordType<Bits>& rhs,\n                               ResolutionMode resolution_mode, Zone* zone) {\n  if (lhs.is_any()) return rhs;\n  if (rhs.is_any()) return lhs;\n\n  if (lhs.is_set() || rhs.is_set()) {\n    const auto& x = lhs.is_set() ? lhs : rhs;\n    const auto& y = lhs.is_set() ? rhs : lhs;\n    base::SmallVector<word_t, kMaxSetSize * 2> result_elements;\n    for (int i = 0; i < x.set_size(); ++i) {\n      const word_t element = x.set_element(i);\n      if (y.Contains(element)) result_elements.push_back(element);\n    }\n    if (result_elements.empty()) return Type::None();\n    DCHECK(detail::is_unique_and_sorted(result_elements));\n    return Set(result_elements, zone);\n  }\n\n  DCHECK(lhs.is_range() && rhs.is_range());\n  const bool lhs_wrapping = lhs.is_wrapping();\n  if (!lhs_wrapping && !rhs.is_wrapping()) {\n    const auto result_from = std::max(lhs.range_from(), rhs.range_from());\n    const auto result_to = std::min(lhs.range_to(), rhs.range_to());\n    return result_to < result_from\n               ? Type::None()\n               : WordType::Range(result_from, result_to, zone);\n  }\n\n  if (lhs_wrapping && rhs.is_wrapping()) {\n    const auto result_from = std::max(lhs.range_from(), rhs.range_from());\n    const auto result_to = std::min(lhs.range_to(), rhs.range_to());\n    auto result = WordType::Range(result_from, result_to, zone);\n    DCHECK(result.is_wrapping());\n    return result;\n  }\n\n  const auto& x = lhs_wrapping ? lhs : rhs;\n  const auto& y = lhs_wrapping ? rhs : lhs;\n  DCHECK(x.is_wrapping());\n  DCHECK(!y.is_wrapping());\n  auto subrange_low = Intersect(y, Range"
}