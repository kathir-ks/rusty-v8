{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 123, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone.h\",\n        \"file_name\": \"zone.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Zone class for memory management in V8, allowing fast allocation and bulk deallocation of memory.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include standard library headers and V8 specific headers for memory management, data structures, and utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <limits>\n            #include <memory>\n            #include <type_traits>\n            #include <utility>\n\n            #include \"src/base/logging.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/zone/accounting-allocator.h\"\n            #include \"src/zone/type-stats.h\"\n            #include \"src/zone/zone-segment.h\"\n            #include \"src/zone/zone-type-traits.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Zone\",\n            \"about\": \"Provides a memory allocation arena where individual allocations cannot be freed, but the entire zone can be cleared quickly.  Not thread-safe.\",\n            \"attributes\": [\n                {\n                    \"name\": \"allocation_size_\",\n                    \"type\": \"std::atomic<size_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks the total number of bytes allocated in the zone.\"\n                },\n                {\n                    \"name\": \"segment_bytes_allocated_\",\n                    \"type\": \"std::atomic<size_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks the total number of bytes allocated in the zone segments.\"\n                },\n                {\n                    \"name\": \"position_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current allocation position within the current segment.\"\n                },\n                {\n                    \"name\": \"limit_\",\n                    \"type\": \"Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The end of the currently allocated region in the current segment.\"\n                },\n                {\n                    \"name\": \"allocator_\",\n                    \"type\": \"AccountingAllocator*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The allocator used to obtain memory segments for the zone.\"\n                },\n                {\n                    \"name\": \"segment_head_\",\n                    \"type\": \"Segment*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the first segment in the zone's segment list.\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Name of the zone for debugging purposes.\"\n                },\n                {\n                    \"name\": \"supports_compression_\",\n                    \"type\": \"const bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the zone supports pointer compression.\"\n                },\n                {\n                    \"name\": \"sealed_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the zone is sealed and no further allocations are allowed.\"\n                },\n                {\n                    \"name\": \"type_stats_\",\n                    \"type\": \"TypeStats\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks allocation statistics by type, enabled when V8_ENABLE_PRECISE_ZONE_STATS is defined.\"\n                },\n                {\n                    \"name\": \"allocation_size_for_tracing_\",\n                    \"type\": \"std::atomic<size_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks allocation size for tracing purposes.\"\n                },\n                {\n                    \"name\": \"freed_size_for_tracing_\",\n                    \"type\": \"std::atomic<size_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks the amount of memory freed in the zone.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AccountingAllocator\",\n                \"ZoneSegment\",\n                \"TypeStats\",\n                \"ZoneSnapshot\",\n                \"base::Vector\",\n                \"Address\",\n                \"std::atomic\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE Zone final {\n            public:\n            Zone(AccountingAllocator* allocator, const char* name,\n                bool support_compression = false);\n            ~Zone();\n\n            // Returns true if the zone supports zone pointer compression.\n            bool supports_compression() const {\n                return COMPRESS_ZONES_BOOL && supports_compression_;\n            }\n\n            // Allocate 'size' bytes of uninitialized memory in the Zone; expands the Zone\n            // by allocating new segments of memory on demand using AccountingAllocator\n            // (see AccountingAllocator::AllocateSegment()).\n            //\n            // When V8_ENABLE_PRECISE_ZONE_STATS is defined, the allocated bytes are\n            // associated with the provided TypeTag type.\n            template <typename TypeTag>\n            void* Allocate(size_t size) {\n            #ifdef V8_USE_ADDRESS_SANITIZER\n                return AsanNew(size);\n            #else\n                size = RoundUp(size, kAlignmentInBytes);\n            #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n                if (V8_UNLIKELY(TracingFlags::is_zone_stats_enabled())) {\n                type_stats_.AddAllocated<TypeTag>(size);\n                }\n                allocation_size_for_tracing_ += size;\n            #endif\n                if (V8_UNLIKELY(size > limit_ - position_)) {\n                Expand(size);\n                }\n\n                DCHECK_LE(position_, limit_);\n                DCHECK_LE(size, limit_ - position_);\n                DCHECK_EQ(0, position_ % kAlignmentInBytes);\n                void* result = reinterpret_cast<void*>(position_);\n                position_ += size;\n                return result;\n            #endif  // V8_USE_ADDRESS_SANITIZER\n            }\n\n            // Return 'size' bytes of memory back to Zone. These bytes can be reused\n            // for following allocations.\n            //\n            // When V8_ENABLE_PRECISE_ZONE_STATS is defined, the deallocated bytes are\n            // associated with the provided TypeTag type.\n            template <typename TypeTag = void>\n            void Delete(void* pointer, size_t size) {\n                DCHECK_NOT_NULL(pointer);\n                DCHECK_NE(size, 0);\n                size = RoundUp(size, kAlignmentInBytes);\n            #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n                if (V8_UNLIKELY(TracingFlags::is_zone_stats_enabled())) {\n                type_stats_.AddDeallocated<TypeTag>(size);\n                }\n                freed_size_for_tracing_ += size;\n            #endif\n\n            #ifdef DEBUG\n                static const unsigned char kZapDeadByte = 0xcd;\n                memset(pointer, kZapDeadByte, size);\n            #endif\n            }\n\n            // Allocates memory for T instance and constructs object by calling respective\n            // Args... constructor.\n            //\n            // When V8_ENABLE_PRECISE_ZONE_STATS is defined, the allocated bytes are\n            // associated with the T type.\n            template <typename T, typename... Args>\n            T* New(Args&&... args) {\n                static_assert(alignof(T) <= kAlignmentInBytes);\n                void* memory = Allocate<T>(sizeof(T));\n                return new (memory) T(std::forward<Args>(args)...);\n            }\n\n            // Allocates uninitialized memory for 'length' number of T instances.\n            //\n            // When V8_ENABLE_PRECISE_ZONE_STATS is defined, the allocated bytes are\n            // associated with the provided TypeTag type. It might be useful to tag\n            // buffer allocations with meaningful names to make buffer allocation sites\n            // distinguishable between each other.\n            template <typename T, typename TypeTag = T[]>\n            T* AllocateArray(size_t length) {\n                static_assert(alignof(T) <= kAlignmentInBytes);\n                DCHECK_IMPLIES(is_compressed_pointer<T>::value, supports_compression());\n                DCHECK_LT(length, std::numeric_limits<size_t>::max() / sizeof(T));\n                return static_cast<T*>(Allocate<TypeTag>(length * sizeof(T)));\n            }\n\n            // Allocates a Vector with 'length' uninitialized entries.\n            template <typename T, typename TypeTag = T[]>\n            base::Vector<T> AllocateVector(size_t length) {\n                T* new_array = AllocateArray<T, TypeTag>(length);\n                return {new_array, length};\n            }\n\n            // Allocates a Vector with 'length' elements and value-constructs them.\n            template <typename T, typename TypeTag = T[]>\n            base::Vector<T> NewVector(size_t length) {\n                T* new_array = AllocateArray<T, TypeTag>(length);\n                std::uninitialized_value_construct_n(new_array, length);\n                return {new_array, length};\n            }\n\n            // Allocates a Vector with 'length' elements and initializes them with\n            // 'value'.\n            template <typename T, typename TypeTag = T[]>\n            base::Vector<T> NewVector(size_t length, T value) {\n                T* new_array = AllocateArray<T, TypeTag>(length);\n                std::uninitialized_fill_n(new_array, length, value);\n                return {new_array, length};\n            }\n\n            template <typename T, typename TypeTag = std::remove_const_t<T>[]>\n            base::Vector<std::remove_const_t<T>> CloneVector(base::Vector<T> v) {\n                auto* new_array = AllocateArray<std::remove_const_t<T>, TypeTag>(v.size());\n                std::uninitialized_copy(v.begin(), v.end(), new_array);\n                return {new_array, v.size()};\n            }\n\n            // Return array of 'length' elements back to Zone. These bytes can be reused\n            // for following allocations.\n            //\n            // When V8_ENABLE_PRECISE_ZONE_STATS is defined, the deallocated bytes are\n            // associated with the provided TypeTag type.\n            template <typename T, typename TypeTag = T[]>\n            void DeleteArray(T* pointer, size_t length) {\n                Delete<TypeTag>(pointer, length * sizeof(T));\n            }\n\n            // Seals the zone to prevent any further allocation.\n            void Seal() { sealed_ = true; }\n\n            // Allows the zone to be safely reused. Releases the memory except for the\n            // last page, and fires zone destruction and creation events for the\n            // accounting allocator.\n            void Reset();\n\n            size_t segment_bytes_allocated() const { return segment_bytes_allocated_; }\n\n            const char* name() const { return name_; }\n\n            // Returns precise value of used zone memory, allowed to be called only\n            // from thread owning the zone.\n            size_t allocation_size() const {\n                size_t extra = segment_head_ ? position_ - segment_head_->start() : 0;\n                return allocation_size_ + extra;\n            }\n\n            // When V8_ENABLE_PRECISE_ZONE_STATS is not defined, returns used zone memory\n            // not including the head segment.\n            // Can be called from threads not owning the zone.\n            size_t allocation_size_for_tracing() const {\n            #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n                return allocation_size_for_tracing_;\n            #else\n                return allocation_size_;\n            #endif\n            }\n\n            // Returns number of bytes freed in this zone via Delete<T>()/DeleteArray<T>()\n            // calls. Returns non-zero values only when V8_ENABLE_PRECISE_ZONE_STATS is\n            // defined.\n            size_t freed_size_for_tracing() const {\n            #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n                return freed_size_for_tracing_;\n            #else\n                return 0;\n            #endif\n            }\n\n            AccountingAllocator* allocator() const { return allocator_; }\n\n        #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n            const TypeStats& type_stats() const { return type_stats_; }\n        #endif\n\n        #ifdef DEBUG\n            bool Contains(const void* ptr) const;\n        #endif\n\n            V8_WARN_UNUSED_RESULT ZoneSnapshot Snapshot() const;\n\n            private:\n            void* AsanNew(size_t size);\n\n            // Deletes all objects and free all memory allocated in the Zone.\n            void DeleteAll();\n\n            // Releases the current segment without performing any local bookkeeping\n            // (e.g. tracking allocated bytes, maintaining linked lists, etc).\n            void ReleaseSegment(Segment* segment);\n\n            // All pointers returned from New() are 8-byte aligned.\n            // ASan requires 8-byte alignment. MIPS also requires 8-byte alignment.\n            static const size_t kAlignmentInBytes = 8;\n\n            // Never allocate segments smaller than this size in bytes.\n            static const size_t kMinimumSegmentSize = 8 * KB;\n\n            // Never allocate segments larger than this size in bytes.\n            static const size_t kMaximumSegmentSize = 32 * KB;\n\n            // The number of bytes allocated in this zone so far.\n            std::atomic<size_t> allocation_size_ = {0};\n\n            // The number of bytes allocated in segments.  Note that this number\n            // includes memory allocated from the OS but not yet allocated from\n            // the zone.\n            std::atomic<size_t> segment_bytes_allocated_ = {0};\n\n            // Expand the Zone to hold at least 'size' more bytes.\n            // Should only be called if there is not enough room in the Zone already.\n            V8_NOINLINE V8_PRESERVE_MOST void Expand(size_t size);\n\n            // The free region in the current (front) segment is represented as\n            // the half-open interval [position, limit). The 'position' variable\n            // is guaranteed to be aligned as dictated by kAlignment.\n            Address position_ = 0;\n            Address limit_ = 0;\n\n            AccountingAllocator* allocator_;\n\n            Segment* segment_head_ = nullptr;\n            const char* name_;\n            const bool supports_compression_;\n            bool sealed_ = false;\n\n        #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n            TypeStats type_stats_;\n            std::atomic<size_t> allocation_size_for_tracing_ = {0};\n\n            // The number of bytes freed in this zone so far.\n            std::atomic<size_t> freed_size_for_tracing_ = {0};\n        #endif\n\n            friend class ZoneSnapshot;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneSnapshot\",\n            \"about\": \"Represents a snapshot of the Zone's allocation state, allowing the Zone to be reset to that state later.\",\n            \"attributes\": [\n                {\n                    \"name\": \"allocation_size_for_tracing_\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the allocation size for tracing at the time of the snapshot.\"\n                },\n                {\n                    \"name\": \"freed_size_for_tracing_\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the freed size for tracing at the time of the snapshot.\"\n                },\n                {\n                    \"name\": \"allocation_size_\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the allocation size at the time of the snapshot.\"\n                },\n                {\n                    \"name\": \"segment_bytes_allocated_\",\n                    \"type\": \"const size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the segment bytes allocated at the time of the snapshot.\"\n                },\n                {\n                    \"name\": \"position_\",\n                    \"type\": \"const Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the allocation position at the time of the snapshot.\"\n                },\n                {\n                    \"name\": \"limit_\",\n                    \"type\": \"const Address\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the allocation limit at the time of the snapshot.\"\n                },\n                {\n                    \"name\": \"segment_head_\",\n                    \"type\": \"Segment* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the head of the segment list at the time of the snapshot.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"Address\",\n                \"Segment\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ZoneSnapshot final {\n            public:\n            // Reset the `Zone` from which this snapshot was taken to the state stored in\n            // this snapshot.\n            void Restore(Zone* zone) const;\n\n            private:\n            explicit ZoneSnapshot(const Zone* zone);\n            friend class Zone;\n\n        #ifdef V8_ENABLE_PRECISE_ZONE_STATS\n            const size_t allocation_size_for_tracing_;\n            const size_t freed_size_for_tracing_;\n        #endif\n            const size_t allocation_size_;\n            const size_t segment_bytes_allocated_;\n            const Address position_;\n            const Address limit_;\n            Segment* const segment_head_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneScope\",\n            \"about\": \"Manages the lifetime of Zone memory allocations by taking a snapshot on construction and restoring the Zone to that state on destruction.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Zone being managed by this scope.\"\n                },\n                {\n                    \"name\": \"snapshot_\",\n                    \"type\": \"const ZoneSnapshot\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The snapshot of the Zone's state at the beginning of the scope.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"ZoneSnapshot\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ZoneScope final {\n            public:\n            explicit ZoneScope(Zone* zone) : zone_(zone), snapshot_(zone->Snapshot()) {}\n\n            ~ZoneScope() { snapshot_.Restore(zone_); }\n\n            private:\n            Zone* const zone_;\n            const ZoneSnapshot snapshot_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneObject\",\n            \"about\": \"Base class for objects allocated in the Zone.  Overrides operator new to prevent direct allocation and requires using zone->New<T>() for allocation.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ZoneObject {\n            public:\n            // The accidential old-style pattern\n            //    new (zone) SomeObject(...)\n            // now produces compilation error. The proper way of allocating objects in\n            // Zones looks like this:\n            //    zone->New<SomeObject>(...)\n            void* operator new(size_t, Zone*) = delete;  // See explanation above.\n            // Allow non-allocating placement new.\n            void* operator new(size_t size, void* ptr) {  // See explanation above.\n                return ptr;\n            }\n\n            // Ideally, the delete operator should be private instead of\n            // public, but unfortunately the compiler sometimes synthesizes\n            // (unused) destructors for classes derived from ZoneObject, which\n            // require the operator to be visible. MSVC requires the delete\n            // operator to be public.\n\n            // ZoneObjects should never be deleted individually; use\n            // Zone::DeleteAll() to delete all zone objects in one go.\n            // Note, that descructors will not be called.\n            void operator delete(void*, size_t) { UNREACHABLE(); }\n            void operator delete(void* pointer, Zone* zone) = delete;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ZoneAllocationPolicy\",\n            \"about\": \"Provides an allocation policy for data structures to allocate their memory within a Zone.\",\n            \"attributes\": [\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Zone in which to allocate memory.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ZoneAllocationPolicy {\n            public:\n            // Creates unusable allocation policy.\n            ZoneAllocationPolicy() : zone_(nullptr) {}\n            explicit ZoneAllocationPolicy(Zone* zone) : zone_(zone) {}\n\n            template <typename T, typename TypeTag = T[]>\n            V8_INLINE T* AllocateArray(size_t length) {\n                return zone()->AllocateArray<T, TypeTag>(length);\n            }\n            template <typename T, typename TypeTag = T[]>\n            V8_INLINE void DeleteArray(T* p, size_t length) {\n                zone()->DeleteArray<T, TypeTag>(p, length);\n            }\n\n            Zone* zone() const { return zone_; }\n\n            private:\n            Zone* zone_;\n            };\n        ]]></code>\n    </class>\n</file>\n```"
}