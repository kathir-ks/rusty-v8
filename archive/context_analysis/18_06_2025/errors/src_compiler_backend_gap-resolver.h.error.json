{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/gap-resolver.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 191, column 59",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/gap-resolver.h\",\n        \"file_name\": \"gap-resolver.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the GapResolver class, which resolves parallel moves in compiler backend.\",\n        \"note\": \"This header file defines the interface for resolving register allocation conflicts during code generation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary header for instruction representation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/backend/instruction.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GapResolver\",\n            \"about\": \"Resolves parallel moves by emitting move and swap instructions.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Assembler\",\n                \"ParallelMove\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass GapResolver final {\n public:\n  // Interface used by the gap resolver to emit moves and swaps.\n  class Assembler {\n   public:\n    virtual ~Assembler() = default;\n\n    // Assemble move.\n    virtual void AssembleMove(InstructionOperand* source,\n                              InstructionOperand* destination) = 0;\n    // Assemble swap.\n    virtual void AssembleSwap(InstructionOperand* source,\n                              InstructionOperand* destination) = 0;\n\n    // Helper functions to resolve cyclic dependencies.\n    // - {Push} pushes {src} and returns an operand that encodes the new stack\n    // slot.\n    // - {Pop} pops the topmost stack operand and moves it to {dest}.\n    // - {PopTempStackSlots} pops all remaining unpopped stack slots.\n    // - {SetPendingMove} reserves scratch registers needed to perform the moves\n    // in the cycle.\n    // - {MoveToTempLocation} moves an operand to a temporary location, either\n    // a scratch register or a new stack slot, depending on the platform and the\n    // reserved registers.\n    // - {MoveTempLocationTo} moves the temp location to the destination,\n    // thereby completing the cycle.\n    virtual AllocatedOperand Push(InstructionOperand* src) = 0;\n    virtual void Pop(InstructionOperand* dest, MachineRepresentation rep) = 0;\n    virtual void PopTempStackSlots() = 0;\n    virtual void MoveToTempLocation(InstructionOperand* src,\n                                    MachineRepresentation rep) = 0;\n    virtual void MoveTempLocationTo(InstructionOperand* dst,\n                                    MachineRepresentation rep) = 0;\n    virtual void SetPendingMove(MoveOperands* move) = 0;\n    int temp_slots_ = 0;\n  };\n\n  explicit GapResolver(Assembler* assembler) : assembler_(assembler) {}\n\n  // Resolve a set of parallel moves, emitting assembler instructions.\n  V8_EXPORT_PRIVATE void Resolve(ParallelMove* parallel_move);\n\n private:\n  // Take a vector of moves where each move blocks the next one, and the last\n  // one blocks the first one, and resolve it using a temporary location.\n  void PerformCycle(const std::vector<MoveOperands*>& cycle);\n  // Performs the given move, possibly performing other moves to unblock the\n  // destination operand.\n  void PerformMove(ParallelMove* moves, MoveOperands* move);\n  // Perform the move and its dependencies. Also performs simple cyclic\n  // dependencies. For more complex cases the method may bail out:\n  // in this case, it returns one of the problematic moves. The caller\n  // ({PerformMove}) will use a temporary stack slot to unblock the dependencies\n  // and try again.\n  MoveOperands* PerformMoveHelper(ParallelMove* moves, MoveOperands* move,\n                                  std::vector<MoveOperands*>* cycle);\n  // Assembler used to emit moves and save registers.\n  Assembler* const assembler_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Assembler\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Abstract interface for emitting move and swap instructions.  Used by GapResolver to perform the actual code generation.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"InstructionOperand\",\n                \"ParallelMove\",\n                \"MoveOperands\",\n                \"AllocatedOperand\",\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n    class Assembler {\n   public:\n    virtual ~Assembler() = default;\n\n    // Assemble move.\n    virtual void AssembleMove(InstructionOperand* source,\n                              InstructionOperand* destination) = 0;\n    // Assemble swap.\n    virtual void AssembleSwap(InstructionOperand* source,\n                              InstructionOperand* destination) = 0;\n\n    // Helper functions to resolve cyclic dependencies.\n    // - {Push} pushes {src} and returns an operand that encodes the new stack\n    // slot.\n    // - {Pop} pops the topmost stack operand and moves it to {dest}.\n    // - {PopTempStackSlots} pops all remaining unpopped stack slots.\n    // - {SetPendingMove} reserves scratch registers needed to perform the moves\n    // in the cycle.\n    // - {MoveToTempLocation} moves an operand to a temporary location, either\n    // a scratch register or a new stack slot, depending on the platform and the\n    // reserved registers.\n    // - {MoveTempLocationTo} moves the temp location to the destination,\n    // thereby completing the cycle.\n    virtual AllocatedOperand Push(InstructionOperand* src) = 0;\n    virtual void Pop(InstructionOperand* dest, MachineRepresentation rep) = 0;\n    virtual void PopTempStackSlots() = 0;\n    virtual void MoveToTempLocation(InstructionOperand* src,\n                                    MachineRepresentation rep) = 0;\n    virtual void MoveTempLocationTo(InstructionOperand* dst,\n                                    MachineRepresentation rep) = 0;\n    virtual void SetPendingMove(MoveOperands* move) = 0;\n    int temp_slots_ = 0;\n  };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Resolve\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Resolves a set of parallel moves, emitting assembler instructions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parallel_move\",\n                    \"type\": \"ParallelMove*\",\n                    \"purpose\": \"The parallel move to resolve\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ParallelMove\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  V8_EXPORT_PRIVATE void Resolve(ParallelMove* parallel_move);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PerformCycle\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Resolves a cycle of moves using a temporary location.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cycle\",\n                    \"type\": \"const std::vector<MoveOperands*>&\",\n                    \"purpose\": \"The cycle of moves to resolve\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"MoveOperands\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void PerformCycle(const std::vector<MoveOperands*>& cycle);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PerformMove\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Performs a move, possibly performing other moves to unblock the destination operand.\",\n            \"parameters\": [\n                {\n                    \"name\": \"moves\",\n                    \"type\": \"ParallelMove*\",\n                    \"purpose\": \"The set of parallel moves\"\n                },\n                {\n                    \"name\": \"move\",\n                    \"type\": \"MoveOperands*\",\n                    \"purpose\": \"The move to perform\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ParallelMove\",\n                \"MoveOperands\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void PerformMove(ParallelMove* moves, MoveOperands* move);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PerformMoveHelper\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Performs the move and its dependencies, handling simple cyclic dependencies.  May return a problematic move if a temporary stack slot is needed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"moves\",\n                    \"type\": \"ParallelMove*\",\n                    \"purpose\": \"The set of parallel moves\"\n                },\n                {\n                    \"name\": \"move\",\n                    \"type\": \"MoveOperands*\",\n                    \"purpose\": \"The move to perform\"\n                },\n                {\n                    \"name\": \"cycle\",\n                    \"type\": \"std::vector<MoveOperands*>*\",\n                    \"purpose\": \"Vector to store the cycle of moves, if one exists\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MoveOperands*\",\n                \"description\": \"A problematic move, or nullptr if the move was performed successfully\"\n            },\n            \"dependencies\": [\n                \"ParallelMove\",\n                \"MoveOperands\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  MoveOperands* PerformMoveHelper(ParallelMove* moves, MoveOperands* move,\n                                  std::vector<MoveOperands*>* cycle);\n        ]]></code>\n    </func>\n</file>\n```"
}