{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/revectorizer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/revectorizer.cc\",\n        \"file_name\": \"revectorizer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Revectorizer optimization pass for the V8 compiler, which attempts to combine scalar SIMD operations into wider SIMD operations (e.g., SIMD128 to SIMD256) to improve performance.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary header files for the Revectorizer.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/revectorizer.h\"\n\n#include \"src/base/cpu.h\"\n#include \"src/base/logging.h\"\n#include \"src/compiler/all-nodes.h\"\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node-observer.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operator.h\"\n#include \"src/compiler/verifier.h\"\n#include \"src/execution/isolate-inl.h\"\n#include \"src/wasm/simd-shuffle.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsSupportedLoad\",\n            \"parent\": null,\n            \"about\": \"Checks if a given node is a supported load operation for revectorization.\",\n            \"logic\": \"Returns true if the node's opcode is one of kProtectedLoad, kLoad, or kLoadTransform; otherwise, returns false.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"const Node*\",\n                    \"purpose\": \"The node to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the node is a supported load operation, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsSupportedLoad(const Node* node) {\n  if (node->opcode() == IrOpcode::kProtectedLoad ||\n      node->opcode() == IrOpcode::kLoad ||\n      node->opcode() == IrOpcode::kLoadTransform) {\n    return true;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsSupportedLoad\",\n            \"parent\": null,\n            \"about\": \"Checks if all nodes in a group are supported load operations.\",\n            \"logic\": \"Iterates through the node group and returns false if any node is not a supported load; otherwise, returns true.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node_group\",\n                    \"type\": \"const ZoneVector<Node*>&\",\n                    \"purpose\": \"The group of nodes to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all nodes are supported loads, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"IsSupportedLoad\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nbool IsSupportedLoad(const ZoneVector<Node*>& node_group) {\n  for (auto node : node_group) {\n    if (!IsSupportedLoad(node)) return false;\n  }\n  return true;\n}\n#endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetConstantValue\",\n            \"parent\": null,\n            \"about\": \"Retrieves the constant integer value of a node.\",\n            \"logic\": \"Checks if the node is an Int64Constant. If so, returns the constant value; otherwise, returns -1.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"const Node*\",\n                    \"purpose\": \"The node to retrieve the value from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int64_t\",\n                \"description\": \"The constant value if the node is a constant, -1 otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nint64_t GetConstantValue(const Node* node) {\n  int64_t value = -1;\n  if (node->opcode() == IrOpcode::kInt64Constant) {\n    value = OpParameter<int64_t>(node->op());\n  }\n  return value;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetMemoryOffsetValue\",\n            \"parent\": null,\n            \"about\": \"Retrieves the memory offset value from a load or store node.\",\n            \"logic\": \"Extracts the offset from the node's input. It handles cases where the offset is a constant or an addition of a constant. Returns -1 if no offset is found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"const Node*\",\n                    \"purpose\": \"The load or store node to get the offset from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int64_t\",\n                \"description\": \"The memory offset value, or -1 if not found.\"\n            },\n            \"dependencies\": [\n                \"IsSupportedLoad\",\n                \"GetConstantValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint64_t GetMemoryOffsetValue(const Node* node) {\n  DCHECK(IsSupportedLoad(node) || node->opcode() == IrOpcode::kStore ||\n         node->opcode() == IrOpcode::kProtectedStore);\n\n  Node* offset = node->InputAt(0);\n  if (offset->opcode() == IrOpcode::kLoadFromObject ||\n      offset->opcode() == IrOpcode::kLoad) {\n    return 0;\n  }\n\n  int64_t offset_value = -1;\n  if (offset->opcode() == IrOpcode::kInt64Add) {\n    if (NodeProperties::IsConstant(offset->InputAt(0))) {\n      offset_value = GetConstantValue(offset->InputAt(0));\n    } else if (NodeProperties::IsConstant(offset->InputAt(1))) {\n      offset_value = GetConstantValue(offset->InputAt(1));\n    }\n  }\n  return offset_value;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetNodeAddress\",\n            \"parent\": null,\n            \"about\": \"Gets the address node from a memory access node (load/store).\",\n            \"logic\": \"Extracts the address from the input of the memory access node. If the address is a ChangeUint32ToUint64 node, it returns the input of that node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"const Node*\",\n                    \"purpose\": \"The memory access node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The address node.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nNode* GetNodeAddress(const Node* node) {\n  Node* address = node->InputAt(1);\n  // The index is changed to Uint64 for memory32\n  if (address->opcode() == IrOpcode::kChangeUint32ToUint64) {\n    address = address->InputAt(0);\n  }\n  return address;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsContinuousAccess\",\n            \"parent\": null,\n            \"about\": \"Checks if a group of memory access nodes (loads) access continuous memory locations.\",\n            \"logic\": \"Calculates the offset between adjacent nodes in the group. It supports special cases for LoadTransform nodes with extend operations. Returns true if all nodes access continuous memory; otherwise, returns false.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node_group\",\n                    \"type\": \"const ZoneVector<Node*>&\",\n                    \"purpose\": \"The group of memory access nodes.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the memory access is continuous, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"GetMemoryOffsetValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsContinuousAccess(const ZoneVector<Node*>& node_group) {\n  DCHECK_GT(node_group.size(), 0);\n  int64_t previous_offset = GetMemoryOffsetValue(node_group[0]);\n  for (size_t i = 1; i < node_group.size(); ++i) {\n    int64_t current_offset = GetMemoryOffsetValue(node_group[i]);\n    int64_t diff = current_offset - previous_offset;\n    if (diff == 8 && node_group[0]->opcode() == IrOpcode::kLoadTransform) {\n      LoadTransformParameters params =\n          LoadTransformParametersOf(node_group[0]->op());\n      if (params.transformation < LoadTransformation::kFirst128Extend ||\n          params.transformation > LoadTransformation::kLast128Extend) {\n        TRACE(\"Non-continuous access!\\n\");\n        return false;\n      }\n      TRACE(\"Continuous access with load extend offset!\\n\");\n    } else if (diff != kSimd128Size) {\n      TRACE(\"Non-continuous access!\\n\");\n      return false;\n    }\n    previous_offset = current_offset;\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AllConstant\",\n            \"parent\": null,\n            \"about\": \"Checks if all nodes in a group are constant nodes.\",\n            \"logic\": \"Iterates through the node group and returns false if any node is not a constant; otherwise, returns true.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node_group\",\n                    \"type\": \"const ZoneVector<Node*>&\",\n                    \"purpose\": \"The group of nodes to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all nodes are constant, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool AllConstant(const ZoneVector<Node*>& node_group) {\n  for (Node* node : node_group) {\n    if (!NodeProperties::IsConstant(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AllSameAddress\",\n            \"parent\": null,\n            \"about\": \"Checks if all nodes in a group have the same address.\",\n            \"logic\": \"Iterates through the node group and returns false if any node has a different address than the first node; otherwise, returns true.\",\n            \"parameters\": [\n                {\n                    \"name\": \"nodes\",\n                    \"type\": \"const ZoneVector<Node*>&\",\n                    \"purpose\": \"The group of nodes to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all nodes have the same address, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"GetNodeAddress\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool AllSameAddress(const ZoneVector<Node*>& nodes) {\n  Node* address = GetNodeAddress(nodes[0]);\n  for (size_t i = 1; i < nodes.size(); i++) {\n    if (GetNodeAddress(nodes[i]) != address) {\n      TRACE(\"Diff address #%d,#%d!\\n\", address->id(),\n            GetNodeAddress(nodes[i])->id());\n      return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsSplat\",\n            \"parent\": null,\n            \"about\": \"Checks if all nodes in a group are identical (splat).\",\n            \"logic\": \"Iterates through the node group and returns false if any node is different from the first node; otherwise, returns true.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node_group\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The group of nodes to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all nodes are identical (splat), false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nbool IsSplat(const T& node_group) {\n  for (typename T::size_type i = 1; i < node_group.size(); ++i) {\n    if (node_group[i] != node_group[0]) {\n      return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"OperatorCanBePacked\",\n            \"parent\": null,\n            \"about\": \"Determines if two operators can be packed together.\",\n            \"logic\": \"Compares the opcode and properties of the two operators to see if they are the same.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const Operator*\",\n                    \"purpose\": \"The left-hand side operator.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const Operator*\",\n                    \"purpose\": \"The right-hand side operator.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the operators can be packed, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE static bool OperatorCanBePacked(const Operator* lhs,\n                                          const Operator* rhs) {\n  return lhs->opcode() == rhs->opcode() &&\n         lhs->properties() == rhs->properties();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AllPackableOperator\",\n            \"parent\": null,\n            \"about\": \"Checks if all nodes in a group have the same packable operator.\",\n            \"logic\": \"Iterates through the node group and returns false if any node has a different operator (as determined by OperatorCanBePacked) than the first node; otherwise, returns true.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node_group\",\n                    \"type\": \"const ZoneVector<Node*>&\",\n                    \"purpose\": \"The group of nodes to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all nodes have the same packable operator, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"OperatorCanBePacked\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool AllPackableOperator(const ZoneVector<Node*>& node_group) {\n  auto op = node_group[0]->op();\n  for (ZoneVector<Node*>::size_type i = 1; i < node_group.size(); i++) {\n    if (!OperatorCanBePacked(node_group[i]->op(), op)) {\n      return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ShiftBySameScalar\",\n            \"parent\": null,\n            \"about\": \"Checks if all shift nodes in a group shift by the same scalar value.\",\n            \"logic\": \"Iterates through the node group and returns false if any shift node shifts by a different scalar than the first node; otherwise, returns true.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node_group\",\n                    \"type\": \"const ZoneVector<Node*>&\",\n                    \"purpose\": \"The group of shift nodes to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all shift nodes shift by the same scalar, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool ShiftBySameScalar(const ZoneVector<Node*>& node_group) {\n  auto node0 = node_group[0];\n  for (ZoneVector<Node*>::size_type i = 1; i < node_group.size(); i++) {\n    DCHECK_EQ(node_group[i]->op(), node0->op());\n    DCHECK_EQ(node0->InputCount(), 2);\n    if (node_group[i]->InputAt(1) != node0->InputAt(1)) {\n      return false;\n    }\n  }\n  return true;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsSignExtensionOperation\",\n            \"parent\": null,\n            \"about\": \"Checks if the given opcode is a sign extension operation.\",\n            \"logic\": \"Uses a switch statement over the IrOpcode::Value enum to check if the opcode falls under the SIMD_SIGN_EXTENSION_CONVERT_OP macro.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"IrOpcode::Value\",\n                    \"purpose\": \"The opcode to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode is a sign extension operation, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsSignExtensionOperation(IrOpcode::Value op) {\n#define CASE(op_low, op_high, not_used) \\\n  case IrOpcode::k##op_low:             \\\n  case IrOpcode::k##op_high:\n  switch (op) {\n    SIMD_SIGN_EXTENSION_CONVERT_OP(CASE)\n    return true;\n    default:\n      return false;\n  }\n#undef CASE\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MaybePackSignExtensionOp\",\n            \"parent\": null,\n            \"about\": \"Checks if a pair of sign extension operations can be packed (low and high versions).\",\n            \"logic\": \"Checks if the first node is a low-version sign extension operation and the second node is its corresponding high-version. Also verifies the first input of the node is same.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node_group\",\n                    \"type\": \"const ZoneVector<Node*>&\",\n                    \"purpose\": \"The group of nodes to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the pair can be packed, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool MaybePackSignExtensionOp(const ZoneVector<Node*>& node_group) {\n#define CHECK_SIGN_EXTENSION_CASE(op_low, op_high, not_used)      \\\n  case IrOpcode::k##op_low: {                                     \\\n    if (node_group[1]->opcode() == IrOpcode::k##op_high &&        \\\n        node_group[0]->InputAt(0) == node_group[1]->InputAt(0)) { \\\n      return true;                                                \\\n    }                                                             \\\n    return false;                                                 \\\n  }\n  switch (node_group[0]->opcode()) {\n    SIMD_SIGN_EXTENSION_CONVERT_OP(CHECK_SIGN_EXTENSION_CASE)\n    default: {\n      return false;\n    }\n  }\n#undef CHECK_SIGN_EXTENSION_CASE\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EffectChainIterator\",\n            \"about\": \"Iterates through an effect chain of nodes, particularly for load operations.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass EffectChainIterator {\n public:\n  explicit EffectChainIterator(Node* node) : node_(node), prev_(nullptr) {}\n\n  Node* Advance() {\n    prev_ = node_;\n    node_ = EffectInputOf(node_);\n    return node_;\n  }\n\n  Node* Prev() {\n    DCHECK_NE(prev_, nullptr);\n    return prev_;\n  }\n\n  Node* Next() { return EffectInputOf(node_); }\n\n  void Set(Node* node) {\n    node_ = node;\n    prev_ = nullptr;\n  }\n\n  Node* operator*() { return node_; }\n\n private:\n  Node* EffectInputOf(Node* node) {\n    DCHECK(IsSupportedLoad(node));\n    return node->InputAt(2);\n  }\n\n  Node* node_;\n  Node* prev_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"InsertAfter\",\n            \"parent\": null,\n            \"about\": \"Inserts one effect chain after another.\",\n            \"logic\": \"Rearranges effect inputs to insert the source chain after the destination chain.\",\n            \"parameters\": [\n                {\n                    \"name\": \"dest\",\n                    \"type\": \"EffectChainIterator&\",\n                    \"purpose\": \"The destination iterator.\"\n                },\n                {\n                    \"name\": \"src\",\n                    \"type\": \"EffectChainIterator&\",\n                    \"purpose\": \"The source iterator.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InsertAfter(EffectChainIterator& dest, EffectChainIterator& src) {\n  Node* dest_next = dest.Next();\n  NodeProperties::ReplaceEffectInput(src.Prev(), src.Next());\n  NodeProperties::ReplaceEffectInput(*dest, *src);\n  NodeProperties::ReplaceEffectInput(*src, dest_next);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MemoryOffsetComparer\",\n            \"about\": \"Compares two nodes based on their memory offset.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"GetMemoryOffsetValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Sort load/store node by offset\nbool MemoryOffsetComparer::operator()(const Node* lhs, const Node* rhs) const {\n  return GetMemoryOffsetValue(lhs) < GetMemoryOffsetValue(rhs);\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PackNode\",\n            \"about\": \"Represents a packed node in the SLP tree.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid PackNode::Print() const {\n  if (revectorized_node_ != nullptr) {\n    TRACE(\"0x%p #%d:%s(%d %d, %s)\\n\", this, revectorized_node_->id(),\n          revectorized_node_->op()->mnemonic(), nodes_[0]->id(),\n          nodes_[1]->id(), nodes_[0]->op()->mnemonic());\n  } else {\n    TRACE(\"0x%p null(%d %d, %s)\\n\", this, nodes_[0]->id(), nodes_[1]->id(),\n          nodes_[0]->op()->mnemonic());\n  }\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SLPTree\",\n            \"about\": \"Implements the SLP (Superword Level Parallelism) tree for vectorization.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"PackNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool SLPTree::CanBePacked(const ZoneVector<Node*>& node_group) {\n  DCHECK_EQ(node_group.size(), 2);\n  // Only Support simd128 operators or common operators with simd128\n  // MachineRepresentation. The MachineRepresentation of root had been checked,\n  // and the leaf node will be checked later. here we omit the check of\n  // MachineRepresentation, only check the opcode itself.\n  IrOpcode::Value op = node_group[0]->opcode();\n  if (!NodeProperties::IsSimd128Operation(node_group[0]) &&\n      (op != IrOpcode::kStore) && (op != IrOpcode::kProtectedStore) &&\n      (op != IrOpcode::kLoad) && (op != IrOpcode::kProtectedLoad) &&\n      (op != IrOpcode::kPhi) && (op != IrOpcode::kLoopExitValue) &&\n      (op != IrOpcode::kExtractF128)) {\n    return false;\n  }\n\n  // TODO(jiepan): add support for Constant\n  if (AllConstant(node_group)) {\n    TRACE(\"%s(#%d, #%d) are constantant, not supported yet!\\n\",\n          node_group[0]->op()->mnemonic(), node_group[0]->id(),\n          node_group[1]->id());\n    return false;\n  }\n  if (IsSignExtensionOperation(op)) {\n    if (MaybePackSignExtensionOp(node_group)) {\n      return true;\n    } else {\n      TRACE(\"%s(#%d, #%d) are not (low, high) sign extension pair\\n\",\n            node_group[0]->op()->mnemonic(), node_group[0]->id(),\n            node_group[1]->id());\n      return false;\n    }\n  }\n  if (!AllPackableOperator(node_group)) {\n    TRACE(\n        \"%s(#%d, #%d) have different op, and are not sign extension operator\\n\",\n        node_group[0]->op()->mnemonic(), node_group[0]->id(),\n        node_group[1]->id());\n    return false;\n  }\n  return true;\n}\n\nPackNode* SLPTree::NewPackNode(const ZoneVector<Node*>& node_group) {\n  TRACE(\"PackNode %s(#%d:, #%d)\\n\", node_group[0]->op()->mnemonic(),\n        node_group[0]->id(), node_group[1]->id());\n  PackNode* pnode = zone_->New<PackNode>(zone_, node_group);\n  for (Node* node : node_group) {\n    node_to_packnode_[node] = pnode;\n  }\n  return pnode;\n}\n\nPackNode* SLPTree::NewPackNodeAndRecurs(const ZoneVector<Node*>& node_group,\n                                        int start_index, int count,\n                                        unsigned recursion_depth) {\n  PackNode* pnode = NewPackNode(node_group);\n  for (int i = start_index; i < start_index + count; ++i) {\n    ZoneVector<Node*> operands(zone_);\n    // Prepare the operand vector.\n    for (size_t j = 0; j < node_group.size(); j++) {\n      Node* node = node_group[j];\n      operands.push_back(NodeProperties::GetValueInput(node, i));\n    }\n\n    PackNode* child = BuildTreeRec(operands, recursion_depth + 1);\n    if (child) {\n      pnode->SetOperand(i, child);\n    } else {\n      return nullptr;\n    }\n  }\n  return pnode;\n}\n\nPackNode* SLPTree::GetPackNode(Node* node) {\n  auto I = node_to_packnode_.find(node);\n  if (I != node_to_packnode_.end()) {\n    return I->second;\n  }\n  return nullptr;\n}\n\nvoid SLPTree::PushStack(const ZoneVector<Node*>& node_group) {\n  TRACE(\"Stack Push (%d %s, %d %s)\\n\", node_group[0]->id(),\n        node_group[0]->op()->mnemonic(), node_group[1]->id(),\n        node_group[1]->op()->mnemonic());\n  for (auto node : node_group) {\n    on_stack_.insert(node);\n  }\n  stack_.push({node_group});\n}\n\nvoid SLPTree::PopStack() {\n  const ZoneVector<Node*>& node_group = stack_.top();\n  DCHECK_EQ(node_group.size(), 2);\n  TRACE(\"Stack Pop (%d %s, %d %s)\\n\", node_group[0]->id(),\n        node_group[0]->op()->mnemonic(), node_group[1]->id(),\n        node_group[1]->op()->mnemonic());\n  for (auto node : node_group) {\n    on_stack_.erase(node);\n  }\n  stack_.pop();\n}\n\nbool SLPTree::OnStack(Node* node) {\n  return on_stack_.find(node) != on_stack_.end();\n}\n\nbool SLPTree::AllOnStack(const ZoneVector<Node*>& node_group) {\n  for (auto node : node_group) {\n    if (OnStack(node)) return true;\n  }\n  return false;\n}\n\nbool SLPTree::StackTopIsPhi() {\n  const ZoneVector<Node*>& node_group = stack_.top();\n  DCHECK_EQ(node_group.size(), 2);\n  return NodeProperties::IsPhi(node_group[0]);\n}\n\nvoid SLPTree::ClearStack() {\n  stack_ = ZoneStack<ZoneVector<Node*>>(zone_);\n  on_stack_.clear();\n}\n\n// Try to connect the nodes in |loads| by effect edges. This allows us to build\n// |PackNode| without breaking effect dependency:\n// Before: [Load1]->...->[Load2]->...->[Load3]->...->[Load4]\n// After:  [Load1]->[Load2]->[Load3]->[Load4]\nvoid SLPTree::TryReduceLoadChain(const ZoneVector<Node*>& loads) {\n  ZoneSet<Node*> visited(zone());\n  for (Node* load : loads) {\n    if (visited.find(load) != visited.end()) continue;\n    visited.insert(load);\n\n    EffectChainIterator dest(load);\n    EffectChainIterator it(dest.Next());\n    while (SameBasicBlock(*it, load) && IsSupportedLoad(*it)) {\n      if (std::find(loads.begin(), loads.end(), *it) != loads.end()) {\n        visited.insert(*it);\n        if (dest.Next() != *it) {\n          Node* prev = it.Prev();\n          InsertAfter(dest, it);\n          it.Set(prev);\n        }\n        dest.Advance();\n      }\n      it.Advance();\n    }\n  }\n}\n\nbool SLPTree::IsSideEffectFreeLoad(const ZoneVector<Node*>& node_group) {\n  DCHECK(IsSupportedLoad(node_group));\n  DCHECK_EQ(node_group.size(), 2);\n  TRACE(\"Enter IsSideEffectFreeLoad (%d %s, %d %s)\\n\", node_group[0]->id(),\n        node_group[0]->op()->mnemonic(), node_group[1]->id(),\n        node_group[1]->op()->mnemonic());\n\n  TryReduceLoadChain(node_group);\n  // We only allows Loads that are connected by effect edges.\n  if (node_group[0] != node_group[1] &&\n      NodeProperties::GetEffectInput(node_group[0]) != node_group[1] &&\n      NodeProperties::GetEffectInput(node_group[1]) != node_group[0])\n    return false;\n\n  std::stack<Node*> to_visit;\n  std::unordered_set<Node*> visited;\n  // Visit all the inputs (except for control inputs) of Loads.\n  for (size_t i = 0, e = node_group.size(); i < e; i++) {\n    Node* load = node_group[i];\n    for (int j"
}