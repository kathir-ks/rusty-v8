{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/frames.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/frames.h\",\n        \"file_name\": \"frames.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the stack frame hierarchy and related classes for V8's execution engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary V8 headers for initialization, base utilities, code generation, object representation, and WebAssembly support.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"include/v8-initialization.h\"\n            #include \"src/base/bounds.h\"\n            #include \"src/codegen/handler-table.h\"\n            #include \"src/codegen/safepoint-table.h\"\n            #include \"src/common/assert-scope.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/objects/code.h\"\n            #include \"src/objects/deoptimization-data.h\"\n            #include \"src/objects/objects.h\"\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/wasm/stacks.h\"\n            #include \"src/wasm/wasm-code-manager.h\"\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackHandlerConstants\",\n            \"extends\": \"AllStatic\",\n            \"about\": \"Defines constants related to the layout of StackHandler objects.\",\n            \"attributes\": [\n                {\n                    \"name\": \"kNextOffset\",\n                    \"type\": \"const int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Offset to the next StackHandler in the chain.\"\n                },\n                {\n                    \"name\": \"kPaddingOffset\",\n                    \"type\": \"const int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Offset to padding in the StackHandler structure.\"\n                },\n                {\n                    \"name\": \"kSize\",\n                    \"type\": \"const int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Total size of the StackHandler structure.\"\n                },\n                {\n                    \"name\": \"kSlotCount\",\n                    \"type\": \"const int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The number of slots in a stack handler.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class StackHandlerConstants : public AllStatic {\n            public:\n            static const int kNextOffset = 0 * kSystemPointerSize;\n            static const int kPaddingOffset = 1 * kSystemPointerSize;\n\n            static const int kSize = kPaddingOffset + kSystemPointerSize;\n            static const int kSlotCount = kSize >> kSystemPointerSizeLog2;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackHandler\",\n            \"about\": \"Represents a stack handler in the stack unwinding chain.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class StackHandler {\n            public:\n            // Get the address of this stack handler.\n            inline Address address() const;\n\n            // Get the next stack handler in the chain.\n            inline StackHandler* next() const;\n\n            // Get the next stack handler, as an Address. This is safe to use even\n            // when the next handler is null.\n            inline Address next_address() const;\n\n            // Conversion support.\n            static inline StackHandler* FromAddress(Address address);\n\n            private:\n            DISALLOW_IMPLICIT_CONSTRUCTORS(StackHandler);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StackFrame\",\n            \"about\": \"Abstract base class for all stack frames.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"StackFrameIteratorBase\",\n                \"RootVisitor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class StackFrame {\n            public:\n            #define DECLARE_TYPE(type, ignore) type,\n            enum Type {\n                NO_FRAME_TYPE = 0,\n                STACK_FRAME_TYPE_LIST(DECLARE_TYPE) NUMBER_OF_TYPES,\n                // Used by FrameScope to indicate that the stack frame is constructed\n                // manually and the FrameScope does not need to emit code.\n                MANUAL\n            };\n            #undef DECLARE_TYPE\n\n            // Used to mark the outermost JS entry frame.\n            //\n            // The mark is an opaque value that should be pushed onto the stack directly,\n            // carefully crafted to not be interpreted as a tagged pointer.\n            enum JsFrameMarker {\n                INNER_JSENTRY_FRAME = (0 << kSmiTagSize) | kSmiTag,\n                OUTERMOST_JSENTRY_FRAME = (1 << kSmiTagSize) | kSmiTag\n            };\n            static_assert((INNER_JSENTRY_FRAME & kHeapObjectTagMask) != kHeapObjectTag);\n            static_assert((OUTERMOST_JSENTRY_FRAME & kHeapObjectTagMask) !=\n                            kHeapObjectTag);\n\n            struct State {\n                Address sp = kNullAddress;\n                Address fp = kNullAddress;\n                Address* pc_address = nullptr;\n                Address callee_fp = kNullAddress;\n                Address callee_pc = kNullAddress;\n                Address* constant_pool_address = nullptr;\n                bool is_profiler_entry_frame = false;\n                bool is_stack_exit_frame = false;\n            };\n\n            // Convert a stack frame type to a marker that can be stored on the stack.\n            //\n            // The marker is an opaque value, not intended to be interpreted in any way\n            // except being checked by IsTypeMarker or converted by MarkerToType.\n            // It has the same tagging as Smis, so any marker value that does not pass\n            // IsTypeMarker can instead be interpreted as a tagged pointer.\n            //\n            // Note that the marker is not a Smi: Smis on 64-bit architectures are stored\n            // in the top 32 bits of a 64-bit value, which in turn makes them expensive\n            // (in terms of code/instruction size) to push as immediates onto the stack.\n            static constexpr int32_t TypeToMarker(Type type) {\n                DCHECK_GE(type, 0);\n                return (type << kSmiTagSize) | kSmiTag;\n            }\n\n            // Convert a marker back to a stack frame type.\n            //\n            // Unlike the return value of TypeToMarker, this takes an intptr_t, as that is\n            // the type of the value on the stack.\n            static constexpr Type MarkerToType(intptr_t marker) {\n                DCHECK(IsTypeMarker(marker));\n                return static_cast<Type>(marker >> kSmiTagSize);\n            }\n\n            // Check if a marker is a stack frame type marker.\n            //\n            // Returns true if the given marker is tagged as a stack frame type marker,\n            // and should be converted back to a stack frame type using MarkerToType.\n            static constexpr bool IsTypeMarker(uintptr_t function_or_marker) {\n                static_assert(kSmiTag == 0);\n                static_assert((std::numeric_limits<uintptr_t>::max() >> kSmiTagSize) >\n                                Type::NUMBER_OF_TYPES);\n                return (function_or_marker & kSmiTagMask) == kSmiTag &&\n                    function_or_marker < (Type::NUMBER_OF_TYPES << kSmiTagSize);\n            }\n\n            // Copy constructor; it breaks the connection to host iterator\n            // (as an iterator usually lives on stack).\n            StackFrame(const StackFrame& original) V8_NOEXCEPT\n                : iterator_(nullptr),\n                isolate_(original.isolate_),\n                state_(original.state_) {}\n\n            // Type testers.\n            bool is_entry() const { return type() == ENTRY; }\n            bool is_construct_entry() const { return type() == CONSTRUCT_ENTRY; }\n            bool is_exit() const { return type() == EXIT; }\n            bool is_optimized_js() const {\n                static_assert(TURBOFAN_JS == MAGLEV + 1);\n                return base::IsInRange(type(), MAGLEV, TURBOFAN_JS);\n            }\n            bool is_unoptimized_js() const {\n                static_assert(BASELINE == INTERPRETED + 1);\n                return base::IsInRange(type(), INTERPRETED, BASELINE);\n            }\n            bool is_interpreted() const { return type() == INTERPRETED; }\n            bool is_baseline() const { return type() == BASELINE; }\n            bool is_maglev() const { return type() == MAGLEV; }\n            bool is_turbofan_js() const { return type() == TURBOFAN_JS; }\n            #if V8_ENABLE_WEBASSEMBLY\n            bool is_wasm() const {\n                return this->type() == WASM || this->type() == WASM_SEGMENT_START\n            #ifdef V8_ENABLE_DRUMBRAKE\n                || this->type() == WASM_INTERPRETER_ENTRY\n            #endif  // V8_ENABLE_DRUMBRAKE\n                    ;\n            }\n            bool is_c_wasm_entry() const { return type() == C_WASM_ENTRY; }\n            bool is_wasm_liftoff_setup() const { return type() == WASM_LIFTOFF_SETUP; }\n            #if V8_ENABLE_DRUMBRAKE\n            bool is_wasm_interpreter_entry() const {\n                return type() == WASM_INTERPRETER_ENTRY;\n            }\n            #endif  // V8_ENABLE_DRUMBRAKE\n            bool is_wasm_debug_break() const { return type() == WASM_DEBUG_BREAK; }\n            bool is_wasm_to_js() const {\n                return type() == WASM_TO_JS || type() == WASM_TO_JS_FUNCTION;\n            }\n            bool is_js_to_wasm() const { return type() == JS_TO_WASM; }\n            #endif  // V8_ENABLE_WEBASSEMBLY\n            bool is_builtin() const { return type() == BUILTIN; }\n            bool is_internal() const { return type() == INTERNAL; }\n            bool is_builtin_continuation() const {\n                return type() == BUILTIN_CONTINUATION;\n            }\n            bool is_javascript_builtin_continuation() const {\n                return type() == JAVASCRIPT_BUILTIN_CONTINUATION;\n            }\n            bool is_javascript_builtin_with_catch_continuation() const {\n                return type() == JAVASCRIPT_BUILTIN_CONTINUATION_WITH_CATCH;\n            }\n            bool is_construct() const { return type() == CONSTRUCT; }\n            bool is_fast_construct() const { return type() == FAST_CONSTRUCT; }\n            bool is_builtin_exit() const { return type() == BUILTIN_EXIT; }\n            bool is_api_accessor_exit() const { return type() == API_ACCESSOR_EXIT; }\n            bool is_api_callback_exit() const { return type() == API_CALLBACK_EXIT; }\n            bool is_irregexp() const { return type() == IRREGEXP; }\n\n            static bool IsJavaScript(Type t) {\n                static_assert(INTERPRETED + 1 == BASELINE);\n                static_assert(BASELINE + 1 == MAGLEV);\n                static_assert(MAGLEV + 1 == TURBOFAN_JS);\n                return t >= INTERPRETED && t <= TURBOFAN_JS;\n            }\n            bool is_javascript() const { return IsJavaScript(type()); }\n\n            // Accessors.\n            Address sp() const {\n                DCHECK(!InFastCCall());\n                return state_.sp;\n            }\n            Address fp() const { return state_.fp; }\n            Address callee_fp() const { return state_.callee_fp; }\n            Address callee_pc() const { return state_.callee_pc; }\n            Address caller_sp() const { return GetCallerStackPointer(); }\n            inline Address pc() const;\n            bool is_profiler_entry_frame() const {\n                return state_.is_profiler_entry_frame;\n            }\n            bool is_stack_exit_frame() const { return state_.is_stack_exit_frame; }\n\n            // Skip authentication of the PC, when using CFI. Used in the profiler, where\n            // in certain corner-cases we do not use an address on the stack, which would\n            // be signed, as the PC of the frame.\n            inline Address unauthenticated_pc() const;\n            static inline Address unauthenticated_pc(Address* pc_address);\n\n            // Conditionally calls either pc() or unauthenticated_pc() based on whether\n            // this is fast C call stack frame.\n            inline Address maybe_unauthenticated_pc() const;\n            static inline Address maybe_unauthenticated_pc(Address* pc_address);\n\n            // If the stack pointer is missing, this is a fast C call frame. For such\n            // frames we cannot compute a stack pointer because of the missing ExitFrame.\n            bool InFastCCall() const { return state_.sp == kNullAddress; }\n\n            Address constant_pool() const { return *constant_pool_address(); }\n            void set_constant_pool(Address constant_pool) {\n                *constant_pool_address() = constant_pool;\n            }\n\n            Address* pc_address() const { return state_.pc_address; }\n\n            Address* constant_pool_address() const {\n                return state_.constant_pool_address;\n            }\n\n            // Get the id of this stack frame.\n            StackFrameId id() const { return static_cast<StackFrameId>(caller_sp()); }\n\n            // Get the top handler from the current stack iterator.\n            inline StackHandler* top_handler() const;\n\n            // Get the type of this frame.\n            virtual Type type() const = 0;\n\n            // Get the code associated with this frame. The result might be a Code object\n            // or an empty value.\n            // This method is used by Isolate::PushStackTraceAndDie() for collecting a\n            // stack trace on fatal error and thus it might be called in the middle of GC\n            // and should be as safe as possible.\n            virtual Tagged<HeapObject> unchecked_code() const = 0;\n\n            // Search for the code associated with this frame.\n            V8_EXPORT_PRIVATE Tagged<Code> LookupCode() const;\n            V8_EXPORT_PRIVATE std::pair<Tagged<Code>, int> LookupCodeAndOffset() const;\n            V8_EXPORT_PRIVATE Tagged<GcSafeCode> GcSafeLookupCode() const;\n            V8_EXPORT_PRIVATE std::pair<Tagged<GcSafeCode>, int>\n            GcSafeLookupCodeAndOffset() const;\n\n            virtual void Iterate(RootVisitor* v) const = 0;\n            void IteratePc(RootVisitor* v, Address* constant_pool_address,\n                            Tagged<GcSafeCode> holder) const;\n\n            // Sets a callback function for return-address rewriting profilers\n            // to resolve the location of a return address to the location of the\n            // profiler's stashed return address.\n            static void SetReturnAddressLocationResolver(\n                ReturnAddressLocationResolver resolver);\n\n            static inline Address ReadPC(Address* pc_address);\n\n            // Resolves pc_address through the resolution address function if one is set.\n            static inline Address* ResolveReturnAddressLocation(Address* pc_address);\n\n            // Printing support.\n            enum PrintMode { OVERVIEW, DETAILS };\n            virtual void Print(StringStream* accumulator, PrintMode mode,\n                                int index) const;\n\n            Isolate* isolate() const { return isolate_; }\n\n            void operator=(const StackFrame& original) = delete;\n\n            protected:\n            inline explicit StackFrame(StackFrameIteratorBase* iterator);\n\n            // Compute the stack pointer for the calling frame.\n            virtual Address GetCallerStackPointer() const = 0;\n\n            const StackFrameIteratorBase* const iterator_;\n\n            private:\n            Isolate* const isolate_;\n            State state_;\n\n            static ReturnAddressLocationResolver return_address_location_resolver_;\n\n            // Fill in the state of the calling frame.\n            virtual void ComputeCallerState(State* state) const = 0;\n\n            // Get the type and the state of the calling frame.\n            virtual Type GetCallerState(State* state) const;\n\n            static const intptr_t kIsolateTag = 1;\n\n            friend class StackFrameIterator;\n            friend class StackFrameIteratorBase;\n            friend class StackHandlerIterator;\n            friend class StackFrameIteratorForProfiler;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CommonFrame\",\n            \"extends\": \"StackFrame\",\n            \"about\": \"Base class for stack frames that have a standard layout.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Object\",\n                \"StackFrameIteratorBase\",\n                \"RootVisitor\",\n                \"Code\",\n                \"FrameSummaries\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CommonFrame : public StackFrame {\n            public:\n            // Accessors.\n            virtual Tagged<Object> context()\n                const;  // TODO(victorgomes): CommonFrames don't have context.\n            virtual int position() const;\n\n            // Access the expressions in the stack frame including locals.\n            inline Tagged<Object> GetExpression(int index) const;\n            inline void SetExpression(int index, Tagged<Object> value);\n            int ComputeExpressionsCount() const;\n\n            Address GetCallerStackPointer() const override;\n\n            // Build a list with summaries for this frame including all inlined frames.\n            // The functions are ordered bottom-to-top (i.e. summaries.last() is the\n            // top-most activation; caller comes before callee).\n            virtual FrameSummaries Summarize() const;\n\n            static CommonFrame* cast(StackFrame* frame) {\n                // It is always safe to cast to common.\n                return static_cast<CommonFrame*>(frame);\n            }\n\n            protected:\n            inline explicit CommonFrame(StackFrameIteratorBase* iterator);\n\n            bool HasTaggedOutgoingParams(Tagged<GcSafeCode> code_lookup) const;\n\n            void ComputeCallerState(State* state) const override;\n\n            // Accessors.\n            inline Address caller_fp() const;\n            inline Address caller_pc() const;\n\n            // Iterate over expression stack including stack handlers, locals,\n            // and parts of the fixed part including context and code fields.\n            void IterateExpressions(RootVisitor* v) const;\n\n            void IterateTurbofanJSOptimizedFrame(RootVisitor* v) const;\n\n            // Returns the address of the n'th expression stack element.\n            virtual Address GetExpressionAddress(int n) const;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TurbofanStubWithContextFrame\",\n            \"extends\": \"CommonFrame\",\n            \"about\": \"This frame is used for TF-optimized code without JS linkage, but contains the context instead of a type marker.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"HeapObject\",\n                \"RootVisitor\",\n                \"StackFrameIteratorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class TurbofanStubWithContextFrame : public CommonFrame {\n            public:\n            Type type() const override { return TURBOFAN_STUB_WITH_CONTEXT; }\n\n            Tagged<HeapObject> unchecked_code() const override;\n            void Iterate(RootVisitor* v) const override;\n\n            protected:\n            inline explicit TurbofanStubWithContextFrame(\n                StackFrameIteratorBase* iterator);\n\n            private:\n            friend class StackFrameIteratorBase;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypedFrame\",\n            \"extends\": \"CommonFrame\",\n            \"about\": \"Base class for stack frames that have a type marker.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"HeapObject\",\n                \"RootVisitor\",\n                \"StackFrameIteratorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class TypedFrame : public CommonFrame {\n            public:\n            Tagged<HeapObject> unchecked_code() const override { return {}; }\n            void Iterate(RootVisitor* v) const override;\n\n            void IterateParamsOfGenericWasmToJSWrapper(RootVisitor* v) const;\n            void IterateParamsOfOptimizedWasmToJSWrapper(RootVisitor* v) const;\n\n            protected:\n            inline explicit TypedFrame(StackFrameIteratorBase* iterator);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CommonFrameWithJSLinkage\",\n            \"extends\": \"CommonFrame\",\n            \"about\": \"Base class for stack frames that have JS linkage (i.e., represent JavaScript functions).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"JSFunction\",\n                \"Object\",\n                \"StackFrameIteratorBase\",\n                \"Code\",\n                \"FixedArray\",\n                \"HandlerTable\",\n                \"FrameSummaries\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CommonFrameWithJSLinkage : public CommonFrame {\n            public:\n            // Accessors.\n            virtual Tagged<JSFunction> function() const = 0;\n\n            // Access the parameters.\n            virtual Tagged<Object> receiver() const;\n            virtual Tagged<Object> GetParameter(int index) const;\n            virtual int ComputeParametersCount() const;\n            DirectHandle<FixedArray> GetParameters() const;\n            virtual int GetActualArgumentCount() const;\n\n            Tagged<HeapObject> unchecked_code() const override;\n\n            // Lookup exception handler for current {pc}, returns -1 if none found. Also\n            // returns data associated with the handler site specific to the frame type:\n            //  - OptimizedJSFrame  : Data is not used and will not return a value.\n            //  - UnoptimizedJSFrame: Data is the register index holding the context.\n            virtual int LookupExceptionHandlerInTable(\n                int* data, HandlerTable::CatchPrediction* prediction);\n\n            // Check if this frame is a constructor frame invoked through 'new'.\n            virtual bool IsConstructor() const;\n\n            // Summarize Frame\n            FrameSummaries Summarize() const override;\n\n            protected:\n            inline explicit CommonFrameWithJSLinkage(StackFrameIteratorBase* iterator);\n\n            // Determines if the standard frame for the given frame pointer is a\n            // construct frame.\n            static inline bool IsConstructFrame(Address fp);\n            inline Address GetParameterSlot(int index) const;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TypedFrameWithJSLinkage\",\n            \"extends\": \"CommonFrameWithJSLinkage\",\n            \"about\": \"Base class for stack frames that have JS linkage and a type marker.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"RootVisitor\",\n                \"StackFrameIteratorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class TypedFrameWithJSLinkage : public CommonFrameWithJSLinkage {\n            public:\n            void Iterate(RootVisitor* v) const override;\n\n            protected:\n            inline explicit TypedFrameWithJSLinkage(StackFrameIteratorBase* iterator);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JavaScriptFrame\",\n            \"extends\": \"CommonFrameWithJSLinkage\",\n            \"about\": \"Base class for stack frames that represent JavaScript functions.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"JSFunction\",\n                \"Script\",\n                \"Object\",\n                \"StackFrameIteratorBase\",\n                \"SharedFunctionInfo\",\n                \"AbstractCode\",\n                \"RootVisitor\",\n                \"StringStream\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class JavaScriptFrame : public CommonFrameWithJSLinkage {\n            public:\n            Type type() const override = 0;\n\n            // Accessors.\n            Tagged<JSFunction> function() const override;\n            Tagged<Object> unchecked_function() const;\n            Tagged<Script> script() const;\n            Tagged<Object> context() const override;\n            int GetActualArgumentCount() const override;\n\n            inline void set_receiver(Tagged<Object> value);\n\n            // Debugger access.\n            void SetParameterValue(int index, Tagged<Object> value) const;\n\n            // Check if this frame is a constructor frame invoked through 'new'.\n            bool IsConstructor() const override;\n\n            // Garbage collection support.\n            void Iterate(RootVisitor* v) const override;\n\n            // Printing support.\n            void Print(StringStream* accumulator, PrintMode mode,\n                        int index) const override;\n\n            // Return a list with {SharedFunctionInfo} objects of this frame.\n            virtual void GetFunctions(\n                std::vector<Tagged<SharedFunctionInfo>>* functions) const;\n\n            void GetFunctions(std::vector<Handle<SharedFunctionInfo>>* functions) const;\n\n            // Returns {AbstractCode, code offset} pair for this frame's PC value.\n            std::tuple<Tagged<AbstractCode>, int> GetActiveCodeAndOffset() const;\n\n            // Architecture-specific register description.\n            static Register fp_register();\n            static Register context_register();\n            static Register constant_pool_pointer_register();\n\n            bool is_unoptimized() const { return is_unoptimized_js(); }\n            bool is_optimized() const { return is_optimized_js(); }\n            bool is_turbofan() const { return is_turbofan_js(); }\n\n            static JavaScriptFrame* cast(StackFrame* frame) {\n                DCHECK(frame->is_javascript());\n                return static_cast<JavaScriptFrame*>(frame);\n            }\n\n            static void PrintFunctionAndOffset(Isolate* isolate,\n                                                Tagged<JSFunction> function,\n                                                Tagged<AbstractCode> code, int code_offset,\n                                                FILE* file, bool print_line_number);\n\n            static void PrintTop(Isolate* isolate, FILE* file, bool print_args,\n                                bool print_line_number);\n\n            static void CollectFunctionAndOffsetForICStats(Isolate* isolate,\n                                                            Tagged<JSFunction> function,\n                                                            Tagged<AbstractCode> code,\n                                                            int code_offset);\n\n            protected:\n            inline explicit JavaScriptFrame(StackFrameIteratorBase* iterator);\n\n            Address GetCallerStackPointer() const override;\n\n            virtual void PrintFrameKind(StringStream* accumulator) const {}\n\n            private:\n            inline Tagged<Object> function_slot_object() const;\n\n            friend class StackFrameIteratorBase;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NativeFrame\",\n            \"extends\": \"TypedFrame\",\n            \"about\": \"Represents a stack frame for native (C/C++) code.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"RootVisitor\",\n                \"StackFrameIteratorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class NativeFrame : public TypedFrame {\n            public:\n            Type type() const override { return NATIVE; }\n\n            // Garbage collection support.\n            void Iterate(RootVisitor* v) const override {}\n\n            protected:\n            inline explicit NativeFrame(StackFrameIteratorBase* iterator);\n\n            private:\n            void ComputeCallerState(State* state) const override;\n\n            friend class StackFrameIteratorBase;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EntryFrame\",\n            \"extends\": \"TypedFrame\",\n            \"about\": \"Represents a stack frame used when entering JavaScript execution from C/C++.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"HeapObject\",\n                \"RootVisitor\",\n                \"StackFrameIteratorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // Entry frames are used to enter JavaScript execution from C.\n            class EntryFrame : public TypedFrame {\n            public:\n            Type type() const override { return ENTRY; }\n\n            Tagged<HeapObject> unchecked_code() const override;\n\n            // Garbage collection support.\n            void Iterate(RootVisitor* v) const override;\n\n            static EntryFrame* cast(StackFrame* frame) {\n                DCHECK(frame->is_entry());\n                return static_cast<EntryFrame*>(frame);\n            }\n\n            protected:\n            inline explicit EntryFrame(StackFrameIteratorBase* iterator);\n\n            // The caller stack pointer for entry frames is always zero. The\n            // real information about the caller frame is available through the\n            // link to the top exit frame.\n            Address GetCallerStackPointer() const override { return 0; }\n\n            private:\n            void ComputeCallerState(State* state) const override;\n            Type GetCallerState(State* state) const override;\n\n            friend class StackFrameIteratorBase;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ConstructEntryFrame\",\n            \"extends\": \"EntryFrame\",\n            \"about\": \"Represents a stack frame used when entering JavaScript execution from C/C++ for constructor calls.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"HeapObject\",\n                \"StackFrameIteratorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ConstructEntryFrame : public EntryFrame {\n            public:\n            Type type() const override { return CONSTRUCT_ENTRY; }\n\n            Tagged<HeapObject> unchecked_code() const override;\n\n            static ConstructEntryFrame* cast(StackFrame* frame) {\n                DCHECK(frame->is_construct_entry());\n                return static_cast<ConstructEntryFrame*>(frame);\n            }\n\n            protected:\n            inline explicit ConstructEntryFrame(StackFrameIteratorBase* iterator);\n\n            private:\n            friend class StackFrameIteratorBase;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ExitFrame\",\n            \"extends\": \"TypedFrame\",\n            \"about\": \"Represents a stack frame used when exiting JavaScript execution to C/C++.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"RootVisitor\",\n                \"StackFrameIteratorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // Exit frames are used to exit JavaScript execution and go to C, or to switch\n            // out of the current stack for wasm stack-switching.\n            class ExitFrame : public TypedFrame {\n            public:\n            Type type() const override { return EXIT; }\n\n            // Garbage collection support.\n            void Iterate(RootVisitor* v) const override;\n\n            static ExitFrame* cast(StackFrame* frame) {\n                DCHECK(frame->is_exit());\n                return static_cast<ExitFrame*>(frame);\n            }\n\n            // Compute the state and type of an exit frame given a frame\n            // pointer. Used when constructing the first stack frame seen by an\n            // iterator and the frames following entry frames.\n            static Type GetStateForFramePointer(Address fp, State* state);\n            static Address ComputeStackPointer(Address fp);\n            static StackFrame::Type ComputeFrameType(Address fp);\n            static void FillState(Address fp, Address sp, State* state);\n\n            protected:\n            inline explicit ExitFrame(StackFrameIteratorBase* iterator);\n\n            private:\n            void ComputeCallerState(State* state) const override;\n\n            friend class StackFrameIteratorBase;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BuiltinExitFrame\",\n            \"extends\": \"ExitFrame\",\n            \"about\": \"Represents a special case of exit frames used when calling C++ builtins.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"JSFunction\",\n                \"Object\",\n                \"StackFrameIteratorBase\",\n                \"FixedArray\",\n                \"StringStream\",\n                \"FrameSummaries\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // Builtin exit frames are a special case of exit frames, which are used\n            // whenever C++ builtins (e.g., Math.acos) are called. Their main purpose is\n            // to allow such builtins to appear in stack traces.\n            class BuiltinExitFrame : public ExitFrame {\n            public:\n            Type type() const override { return BUILTIN_EXIT; }\n\n            Tagged<JSFunction> function() const;\n\n            Tagged<Object> receiver() const;\n            Tagged<Object> GetParameter(int i) const;\n            int ComputeParametersCount() const;\n            DirectHandle<FixedArray> GetParameters() const;\n\n            // Check if this frame is a constructor frame invoked through 'new'.\n            bool IsConstructor() const;\n\n            void Print(StringStream* accumulator, PrintMode mode,\n                        int index) const override;\n\n            // Summarize Frame\n            FrameSummaries Summarize() const override;\n\n            protected:\n            inline explicit BuiltinExitFrame(StackFrameIteratorBase* iterator);\n\n            private:\n            inline Tagged<Object> receiver_slot_object() const;\n            inline Tagged<Object> argc_slot_object() const;\n            inline Tagged<Object> target_slot_object() const;\n"
}