{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/pretenuring-propagation-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 43, column 39",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/pretenuring-propagation-reducer.h\",\n            \"file_name\": \"pretenuring-propagation-reducer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines a Turboshaft reducer that propagates pretenuring (old object allocation) information throughout the graph.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for Turboshaft compiler phase, assembler, reducer traits, utilities, zone allocation, and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/reducer-traits.h\"\n#include \"src/compiler/turboshaft/utils.h\"\n#include \"src/zone/zone-allocator.h\"\n#include \"src/zone/zone-containers.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PretenuringPropagationAnalyzer\",\n                \"about\": \"Analyzes the Turboshaft graph to propagate pretenuring information.  It identifies old allocations and transitively marks allocations stored within them as old as well.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating data structures.\"\n                    },\n                    {\n                        \"name\": \"input_graph_\",\n                        \"type\": \"Graph&\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Reference to the Turboshaft graph being analyzed.\"\n                    },\n                    {\n                        \"name\": \"old_allocs_\",\n                        \"type\": \"ZoneVector<OpIndex>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of OpIndices representing old allocations.\"\n                    },\n                    {\n                        \"name\": \"store_graph_\",\n                        \"type\": \"ZoneAbslFlatHashMap<OpIndex, ZoneVector<OpIndex>*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Graph representing store relationships between operations.  Maps an OpIndex to a vector of OpIndices that are stored in it.\"\n                    },\n                    {\n                        \"name\": \"old_phis_\",\n                        \"type\": \"ZoneAbslFlatHashSet<OpIndex>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of OpIndices representing Phi nodes that have already been marked as old.\"\n                    },\n                    {\n                        \"name\": \"queue_\",\n                        \"type\": \"ZoneVector<OpIndex>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Queue used for performing a depth-first search of the store graph.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Zone\",\n                    \"Graph\",\n                    \"ZoneVector\",\n                    \"ZoneAbslFlatHashMap\",\n                    \"ZoneAbslFlatHashSet\",\n                    \"OpIndex\",\n                    \"StoreOp\",\n                    \"PhiOp\",\n                    \"AllocateOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass PretenuringPropagationAnalyzer {\n public:\n  PretenuringPropagationAnalyzer(Zone* phase_zone, Graph& mutable_input_graph)\n      : zone_(phase_zone),\n        input_graph_(mutable_input_graph),\n        old_allocs_(phase_zone),\n        store_graph_(phase_zone),\n        old_phis_(phase_zone),\n        queue_(phase_zone) {}\n\n  void Run();\n\n private:\n  void ProcessStore(const StoreOp& store);\n  void ProcessPhi(const PhiOp& phi);\n  void ProcessAllocate(const AllocateOp& allocate);\n\n  bool PushContainedValues(OpIndex base);\n  void OldifySubgraph(OpIndex old_alloc);\n\n  void BuildStoreInputGraph();\n  void PropagateAllocationTypes();\n\n  ZoneVector<OpIndex>* FindOrCreate(OpIndex idx) {\n    auto it = store_graph_.find(idx);\n    if (it != store_graph_.end()) return it->second;\n    return Create(idx);\n  }\n\n  ZoneVector<OpIndex>* Create(OpIndex idx) {\n    DCHECK_EQ(store_graph_.count(idx), 0);\n    ZoneVector<OpIndex>* stored_items = zone_->New<ZoneVector<OpIndex>>(zone_);\n    store_graph_.insert({idx, stored_items});\n    return stored_items;\n  }\n\n  ZoneVector<OpIndex>* TryFind(OpIndex idx) {\n    auto it = store_graph_.find(idx);\n    if (it != store_graph_.end()) return it->second;\n    return nullptr;\n  }\n\n  Zone* zone_;\n  Graph& input_graph_;\n  ZoneVector<OpIndex> old_allocs_;\n\n  // (see main comment at the begining of this file for the role of\n  // `store_graph_`)\n  // `store_graph_` contains mapping from OpIndex to vector<OpIndex>. If for an\n  // entry `a` it contains a vector `v`, it means that `a` has edges to all of\n  // the values in `v`.\n  ZoneAbslFlatHashMap<OpIndex, ZoneVector<OpIndex>*> store_graph_;\n\n  // AllocateOp have an AllocationType field, which is set to kOld once they've\n  // been visited, thus ensuring that recursion ends. However, PhiOp don't have\n  // such a field. Thus, once we've visited a Phi, we store it in {old_phis_} to\n  // prevent revisiting it.\n  ZoneAbslFlatHashSet<OpIndex> old_phis_;\n\n  // Used in the final phase to do DFS in the graph from each old store. It\n  // could be a local variable, but we instead use an instance variable to reuse\n  // memory.\n  ZoneVector<OpIndex> queue_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PretenuringPropagationReducer\",\n                \"about\": \"Turboshaft reducer that performs pretenuring propagation analysis and optimization.\",\n                \"extends\": \"Next\",\n                \"dependencies\": [\n                    \"Next\",\n                    \"PretenuringPropagationAnalyzer\",\n                    \"MemoryOptimizationReducer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass PretenuringPropagationReducer : public Next {\n#if defined(__clang__)\n  // PretenuringPropagationReducer should run before MemoryOptimizationReducer\n  // (because once young allocations are marked for folding, they can't be\n  // oldified anymore). We enforce this by making PretenuringPropagationReducer\n  // run in the same phase as MemoryOptimizationReducer, but before.\n  static_assert(next_contains_reducer<Next, MemoryOptimizationReducer>::value);\n#endif\n\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(PretenuringPropagation)\n\n  void Analyze() {\n    PretenuringPropagationAnalyzer analyzer(Asm().phase_zone(),\n                                            Asm().modifiable_input_graph());\n    analyzer.Run();\n    Next::Analyze();\n  }\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"MemoryOptimizationReducer\",\n                    \"about\": \"A Turboshaft reducer that performs memory optimization.\"\n                }\n            </metadata>\n            <code><![CDATA[\nclass MemoryOptimizationReducer {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}