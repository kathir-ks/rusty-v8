{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-shuffle-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-shuffle-reducer.cc\",\n            \"file_name\": \"wasm-shuffle-reducer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements a reducer to optimize SIMD128 shuffle operations in WebAssembly code for the Turboshaft compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for the WasmShuffleReducer.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/wasm-shuffle-reducer.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DemandedElementAnalysis\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Analyzes which elements of SIMD128 operations are actually demanded/used by subsequent operations.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"visited_\",\n                        \"type\": \"std::unordered_set<const Operation*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of visited operations to avoid infinite recursion.\"\n                    },\n                    {\n                        \"name\": \"demanded_elements_\",\n                        \"type\": \"std::vector<std::pair<const Simd128ShuffleOp*, LaneBitSet>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores demanded elements for shuffle operations.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Operation\",\n                    \"Simd128UnaryOp\",\n                    \"Simd128BinopOp\",\n                    \"Simd128ShuffleOp\",\n                    \"LaneBitSet\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid DemandedElementAnalysis::AddUnaryOp(const Simd128UnaryOp& unop,\n                                         LaneBitSet lanes) {\n  if (Visited(&unop)) return;\n  visited_.insert(&unop);\n\n  const Operation& input = input_graph().Get(unop.input());\n  if (!input.saturated_use_count.IsOne()) {\n    return;\n  }\n  // TODO(sparker): Add floating-point conversions:\n  // - PromoteLow\n  // - ConvertLow\n  static constexpr std::array low_half_ops = {\n      Simd128UnaryOp::Kind::kI16x8SConvertI8x16Low,\n      Simd128UnaryOp::Kind::kI16x8UConvertI8x16Low,\n      Simd128UnaryOp::Kind::kI32x4SConvertI16x8Low,\n      Simd128UnaryOp::Kind::kI32x4UConvertI16x8Low,\n      Simd128UnaryOp::Kind::kI64x2SConvertI32x4Low,\n      Simd128UnaryOp::Kind::kI64x2UConvertI32x4Low,\n  };\n\n  for (auto const kind : low_half_ops) {\n    if (kind == unop.kind) {\n      DCHECK(lanes == k8x16 || lanes == k8x8Low || lanes == k8x4Low);\n      lanes >>= lanes.count() / 2;\n      RecordOp(&input, lanes);\n      return;\n    }\n  }\n}\n\nvoid DemandedElementAnalysis::AddBinaryOp(const Simd128BinopOp& binop,\n                                          LaneBitSet lanes) {\n  if (Visited(&binop)) return;\n  visited_.insert(&binop);\n\n  static constexpr std::array low_half_ops = {\n      Simd128BinopOp::Kind::kI16x8ExtMulLowI8x16S,\n      Simd128BinopOp::Kind::kI16x8ExtMulLowI8x16U,\n      Simd128BinopOp::Kind::kI32x4ExtMulLowI16x8S,\n      Simd128BinopOp::Kind::kI32x4ExtMulLowI16x8U,\n      Simd128BinopOp::Kind::kI64x2ExtMulLowI32x4S,\n      Simd128BinopOp::Kind::kI64x2ExtMulLowI32x4U,\n  };\n  const Operation& left = input_graph().Get(binop.left());\n  const Operation& right = input_graph().Get(binop.right());\n  for (auto const& kind : low_half_ops) {\n    if (kind == binop.kind) {\n      DCHECK(lanes == k8x16 || lanes == k8x8Low);\n      lanes >>= lanes.count() / 2;\n      if (left.saturated_use_count.IsOne()) {\n        RecordOp(&left, lanes);\n      }\n      if (right.saturated_use_count.IsOne()) {\n        RecordOp(&right, lanes);\n      }\n    }\n  }\n}\n\nvoid DemandedElementAnalysis::RecordOp(const Operation* op, LaneBitSet lanes) {\n  if (auto* unop = op->TryCast<Simd128UnaryOp>()) {\n    AddUnaryOp(*unop, lanes);\n  } else if (auto* binop = op->TryCast<Simd128BinopOp>()) {\n    AddBinaryOp(*binop, lanes);\n  } else if (auto* shuffle = op->TryCast<Simd128ShuffleOp>()) {\n    demanded_elements_.emplace_back(shuffle, lanes);\n  }\n}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"WasmShuffleAnalyzer\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Analyzes SIMD128 shuffle operations to identify opportunities for optimization, such as reducing the width of shuffles.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"demanded_element_analysis\",\n                        \"type\": \"DemandedElementAnalysis\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An instance of the DemandedElementAnalysis class used for analyzing demanded elements.\"\n                    },\n                    {\n                        \"name\": \"shift_shuffles_\",\n                        \"type\": \"std::vector<const Operation*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores shuffle operations that need to be shifted.\"\n                    },\n                    {\n                        \"name\": \"low_half_shuffles_\",\n                        \"type\": \"std::vector<const Simd128ShuffleOp*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores shuffle operations that use the low half of another shuffle.\"\n                    },\n                    {\n                        \"name\": \"high_half_shuffles_\",\n                        \"type\": \"std::vector<const Simd128ShuffleOp*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores shuffle operations that use the high half of another shuffle.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"DemandedElementAnalysis\",\n                    \"Operation\",\n                    \"Simd128UnaryOp\",\n                    \"Simd128BinopOp\",\n                    \"Simd128ShuffleOp\",\n                    \"Block\",\n                    \"BlockIndex\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmShuffleAnalyzer::Run() {\n  for (uint32_t processed = input_graph().block_count(); processed > 0;\n       --processed) {\n    BlockIndex block_index = static_cast<BlockIndex>(processed - 1);\n    const Block& block = input_graph().Get(block_index);\n    auto idx_range = input_graph().OperationIndices(block);\n    for (auto it = idx_range.rbegin(); it != idx_range.rend(); ++it) {\n      const Operation& op = input_graph().Get(*it);\n      Process(op);\n    }\n  }\n}\n\nvoid WasmShuffleAnalyzer::Process(const Operation& op) {\n  if (ShouldSkipOperation(op)) {\n    return;\n  }\n\n  if (auto* unop = op.TryCast<Simd128UnaryOp>()) {\n    ProcessUnary(*unop);\n    return;\n  }\n\n  if (auto* binop = op.TryCast<Simd128BinopOp>()) {\n    ProcessBinary(*binop);\n    return;\n  }\n\n  if (auto* shuffle_op = op.TryCast<Simd128ShuffleOp>()) {\n    ProcessShuffle(*shuffle_op);\n    return;\n  }\n}\n\nvoid WasmShuffleAnalyzer::ProcessUnary(const Simd128UnaryOp& unop) {\n  demanded_element_analysis.AddUnaryOp(unop, DemandedElementAnalysis::k8x16);\n}\n\nvoid WasmShuffleAnalyzer::ProcessBinary(const Simd128BinopOp& binop) {\n  demanded_element_analysis.AddBinaryOp(binop, DemandedElementAnalysis::k8x16);\n}\n\nvoid WasmShuffleAnalyzer::ProcessShuffleOfShuffle(\n    const Simd128ShuffleOp& shuffle_op, const Simd128ShuffleOp& shuffle,\n    uint8_t lower_limit, uint8_t upper_limit) {\n  // Suppose we have two 16-byte shuffles:\n  // |---a1---|---b3---|--------|--------|  shuffle_op = (a, b)\n  //\n  // |---a1---|---b3---|---c?---|---c?---|  shuffle = (shf0, c)\n  //\n  // As only half of the shf0 is used, it means that half the work of shf0 is\n  // wasted so, here, we try to reduce shf0 to a more narrow kind. In the case\n  // above we can simply truncate shf0.shuffle but there are other situations\n  // which involve more work:\n  //\n  // In the following case, shf0.shuffle needs to be shifted left so that it\n  // writes the required lanes to the low half of the result. This then means\n  // that shf1.shuffle needs to be updated to read from the low half.\n  //\n  // |--------|--------|---a1---|---b3---|  shuffle_op = (a, b)\n  //\n  // |---a1---|---b3---|---c?---|---c?---|  shuffle = (shf0, c)\n  //\n\n  struct ShuffleHelper {\n    explicit ShuffleHelper(const uint8_t* shuffle) : shuffle(shuffle) {}\n\n    const uint8_t* begin() const { return shuffle; }\n\n    const uint8_t* midpoint() const {\n      constexpr size_t half_lanes = kSimd128Size / 2;\n      return shuffle + half_lanes;\n    }\n\n    const uint8_t* end() const { return shuffle + kSimd128Size; }\n\n    const uint8_t* shuffle;\n  };\n\n  ShuffleHelper view(shuffle.shuffle);\n\n  // Test whether the low half of the shuffle is within the inclusive range.\n  auto all_low_half = [&view](uint8_t lower_limit, uint8_t upper_limit) {\n    return std::all_of(view.begin(), view.midpoint(),\n                       [lower_limit, upper_limit](uint8_t i) {\n                         return i >= lower_limit && i <= upper_limit;\n                       });\n  };\n  // Test whether the high half of the shuffle is within the inclusive range.\n  auto all_high_half = [&view](uint8_t lower_limit, uint8_t upper_limit) {\n    return std::all_of(view.midpoint(), view.end(),\n                       [lower_limit, upper_limit](uint8_t i) {\n                         return i >= lower_limit && i <= upper_limit;\n                       });\n  };\n  // Test whether none of the low half of the shuffle contains lanes within the\n  // inclusive range.\n  auto none_low_half = [&view](uint8_t lower_limit, uint8_t upper_limit) {\n    return std::none_of(view.begin(), view.midpoint(),\n                        [lower_limit, upper_limit](uint8_t i) {\n                          return i >= lower_limit && i <= upper_limit;\n                        });\n  };\n  // Test whether none of the high half of the shuffle contains lanes within the\n  // inclusive range.\n  auto none_high_half = [&view](uint8_t lower_limit, uint8_t upper_limit) {\n    return std::none_of(view.midpoint(), view.end(),\n                        [lower_limit, upper_limit](uint8_t i) {\n                          return i >= lower_limit && i <= upper_limit;\n                        });\n  };\n\n  // lower_ and upper_limit and set from the caller depending on whether we're\n  // examining the left or right operand of shuffle. So, here we check if\n  // shuffle_op is being exclusively shuffled into the low or high half using\n  // either the lower and upper limits of {0,15} or {16,31}.\n  bool shf_into_low_half = all_low_half(lower_limit, upper_limit) &&\n                           none_high_half(lower_limit, upper_limit);\n  bool shf_into_high_half = all_high_half(lower_limit, upper_limit) &&\n                            none_low_half(lower_limit, upper_limit);\n  DCHECK(!(shf_into_low_half && shf_into_high_half));\n\n  constexpr size_t quarter_lanes = kSimd128Size / 4;\n  if (shf_into_low_half) {\n    if (all_low_half(lower_limit + quarter_lanes, upper_limit)) {\n      // Low half of shuffle is sourced from the high half of shuffle_op.\n      demanded_element_analysis.RecordOp(&shuffle_op,\n                                         DemandedElementAnalysis::k8x8Low);\n      shift_shuffles_.push_back(&shuffle_op);\n      low_half_shuffles_.push_back(&shuffle);\n    } else if (all_low_half(lower_limit, upper_limit - quarter_lanes)) {\n      // Low half of shuffle is sourced from the low half of shuffle_op.\n      demanded_element_analysis.RecordOp(&shuffle_op,\n                                         DemandedElementAnalysis::k8x8Low);\n    }\n  } else if (shf_into_high_half) {\n    if (all_high_half(lower_limit + quarter_lanes, upper_limit)) {\n      // High half of shuffle is sourced from the high half of shuffle_op.\n      demanded_element_analysis.RecordOp(&shuffle_op,\n                                         DemandedElementAnalysis::k8x8Low);\n      shift_shuffles_.push_back(&shuffle_op);\n      high_half_shuffles_.push_back(&shuffle);\n    } else if (all_high_half(lower_limit, upper_limit - quarter_lanes)) {\n      // High half of shuffle is sourced from the low half of shuffle_op.\n      demanded_element_analysis.RecordOp(&shuffle_op,\n                                         DemandedElementAnalysis::k8x8Low);\n    }\n  }\n}\n\nvoid WasmShuffleAnalyzer::ProcessShuffle(const Simd128ShuffleOp& shuffle) {\n  if (shuffle.kind != Simd128ShuffleOp::Kind::kI8x16) {\n    return;\n  }\n  const Operation& left = input_graph().Get(shuffle.left());\n  const Operation& right = input_graph().Get(shuffle.right());\n\n  auto* shuffle_left = left.TryCast<Simd128ShuffleOp>();\n  auto* shuffle_right = right.TryCast<Simd128ShuffleOp>();\n  if (!shuffle_left && !shuffle_right) {\n    return;\n  }\n  constexpr uint8_t left_lower = 0;\n  constexpr uint8_t left_upper = 15;\n  constexpr uint8_t right_lower = 16;\n  constexpr uint8_t right_upper = 31;\n  if (shuffle_left && shuffle_left->kind == Simd128ShuffleOp::Kind::kI8x16 &&\n      shuffle_left->saturated_use_count.IsOne()) {\n    ProcessShuffleOfShuffle(*shuffle_left, shuffle, left_lower, left_upper);\n  }\n  if (shuffle_right && shuffle_right->kind == Simd128ShuffleOp::Kind::kI8x16 &&\n      shuffle_right->saturated_use_count.IsOne()) {\n    ProcessShuffleOfShuffle(*shuffle_right, shuffle, right_lower, right_upper);\n  }\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddUnaryOp\",\n                \"parent\": \"DemandedElementAnalysis\",\n                \"about\": \"Adds a unary SIMD128 operation to the analysis, tracking demanded lanes.\",\n                \"logic\": \"Checks if the operation has been visited. If not, it checks if the input operation has a saturated use count of one. For specific 'low half' operations, it shifts the lane bitset and records the operation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"unop\",\n                        \"type\": \"const Simd128UnaryOp&\",\n                        \"purpose\": \"The unary SIMD128 operation to add.\"\n                    },\n                    {\n                        \"name\": \"lanes\",\n                        \"type\": \"LaneBitSet\",\n                        \"purpose\": \"The set of lanes demanded by the operation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Visited\",\n                    \"input_graph\",\n                    \"Operation\",\n                    \"LaneBitSet\",\n                    \"Simd128UnaryOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid DemandedElementAnalysis::AddUnaryOp(const Simd128UnaryOp& unop,\n                                         LaneBitSet lanes) {\n  if (Visited(&unop)) return;\n  visited_.insert(&unop);\n\n  const Operation& input = input_graph().Get(unop.input());\n  if (!input.saturated_use_count.IsOne()) {\n    return;\n  }\n  // TODO(sparker): Add floating-point conversions:\n  // - PromoteLow\n  // - ConvertLow\n  static constexpr std::array low_half_ops = {\n      Simd128UnaryOp::Kind::kI16x8SConvertI8x16Low,\n      Simd128UnaryOp::Kind::kI16x8UConvertI8x16Low,\n      Simd128UnaryOp::Kind::kI32x4SConvertI16x8Low,\n      Simd128UnaryOp::Kind::kI32x4UConvertI16x8Low,\n      Simd128UnaryOp::Kind::kI64x2SConvertI32x4Low,\n      Simd128UnaryOp::Kind::kI64x2UConvertI32x4Low,\n  };\n\n  for (auto const kind : low_half_ops) {\n    if (kind == unop.kind) {\n      DCHECK(lanes == k8x16 || lanes == k8x8Low || lanes == k8x4Low);\n      lanes >>= lanes.count() / 2;\n      RecordOp(&input, lanes);\n      return;\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddBinaryOp\",\n                \"parent\": \"DemandedElementAnalysis\",\n                \"about\": \"Adds a binary SIMD128 operation to the analysis, tracking demanded lanes.\",\n                \"logic\": \"Similar to AddUnaryOp, but handles binary operations with left and right inputs.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"binop\",\n                        \"type\": \"const Simd128BinopOp&\",\n                        \"purpose\": \"The binary SIMD128 operation to add.\"\n                    },\n                    {\n                        \"name\": \"lanes\",\n                        \"type\": \"LaneBitSet\",\n                        \"purpose\": \"The set of lanes demanded by the operation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Visited\",\n                    \"input_graph\",\n                    \"Operation\",\n                    \"LaneBitSet\",\n                    \"Simd128BinopOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid DemandedElementAnalysis::AddBinaryOp(const Simd128BinopOp& binop,\n                                          LaneBitSet lanes) {\n  if (Visited(&binop)) return;\n  visited_.insert(&binop);\n\n  static constexpr std::array low_half_ops = {\n      Simd128BinopOp::Kind::kI16x8ExtMulLowI8x16S,\n      Simd128BinopOp::Kind::kI16x8ExtMulLowI8x16U,\n      Simd128BinopOp::Kind::kI32x4ExtMulLowI16x8S,\n      Simd128BinopOp::Kind::kI32x4ExtMulLowI16x8U,\n      Simd128BinopOp::Kind::kI64x2ExtMulLowI32x4S,\n      Simd128BinopOp::Kind::kI64x2ExtMulLowI32x4U,\n  };\n  const Operation& left = input_graph().Get(binop.left());\n  const Operation& right = input_graph().Get(binop.right());\n  for (auto const& kind : low_half_ops) {\n    if (kind == binop.kind) {\n      DCHECK(lanes == k8x16 || lanes == k8x8Low);\n      lanes >>= lanes.count() / 2;\n      if (left.saturated_use_count.IsOne()) {\n        RecordOp(&left, lanes);\n      }\n      if (right.saturated_use_count.IsOne()) {\n        RecordOp(&right, lanes);\n      }\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RecordOp\",\n                \"parent\": \"DemandedElementAnalysis\",\n                \"about\": \"Records the demanded lanes for a given operation, recursively handling unary, binary, and shuffle operations.\",\n                \"logic\": \"Uses `TryCast` to determine the operation type (unary, binary, or shuffle) and calls the appropriate handler method.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operation*\",\n                        \"purpose\": \"The operation to record.\"\n                    },\n                    {\n                        \"name\": \"lanes\",\n                        \"type\": \"LaneBitSet\",\n                        \"purpose\": \"The set of lanes demanded by the operation.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AddUnaryOp\",\n                    \"AddBinaryOp\",\n                    \"Simd128UnaryOp\",\n                    \"Simd128BinopOp\",\n                    \"Simd128ShuffleOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid DemandedElementAnalysis::RecordOp(const Operation* op, LaneBitSet lanes) {\n  if (auto* unop = op->TryCast<Simd128UnaryOp>()) {\n    AddUnaryOp(*unop, lanes);\n  } else if (auto* binop = op->TryCast<Simd128BinopOp>()) {\n    AddBinaryOp(*binop, lanes);\n  } else if (auto* shuffle = op->TryCast<Simd128ShuffleOp>()) {\n    demanded_elements_.emplace_back(shuffle, lanes);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Run\",\n                \"parent\": \"WasmShuffleAnalyzer\",\n                \"about\": \"Runs the shuffle analysis on the input graph.\",\n                \"logic\": \"Iterates through the blocks and operations in reverse order, processing each operation.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"input_graph\",\n                    \"Block\",\n                    \"BlockIndex\",\n                    \"Operation\",\n                    \"Process\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmShuffleAnalyzer::Run() {\n  for (uint32_t processed = input_graph().block_count(); processed > 0;\n       --processed) {\n    BlockIndex block_index = static_cast<BlockIndex>(processed - 1);\n    const Block& block = input_graph().Get(block_index);\n    auto idx_range = input_graph().OperationIndices(block);\n    for (auto it = idx_range.rbegin(); it != idx_range.rend(); ++it) {\n      const Operation& op = input_graph().Get(*it);\n      Process(op);\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Process\",\n                \"parent\": \"WasmShuffleAnalyzer\",\n                \"about\": \"Processes a single operation, determining its type and calling the appropriate handler method.\",\n                \"logic\": \"Uses `TryCast` to determine the operation type (unary, binary, or shuffle) and calls the appropriate handler method.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operation&\",\n                        \"purpose\": \"The operation to process.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"ShouldSkipOperation\",\n                    \"ProcessUnary\",\n                    \"ProcessBinary\",\n                    \"ProcessShuffle\",\n                    \"Simd128UnaryOp\",\n                    \"Simd128BinopOp\",\n                    \"Simd128ShuffleOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmShuffleAnalyzer::Process(const Operation& op) {\n  if (ShouldSkipOperation(op)) {\n    return;\n  }\n\n  if (auto* unop = op.TryCast<Simd128UnaryOp>()) {\n    ProcessUnary(*unop);\n    return;\n  }\n\n  if (auto* binop = op.TryCast<Simd128BinopOp>()) {\n    ProcessBinary(*binop);\n    return;\n  }\n\n  if (auto* shuffle_op = op.TryCast<Simd128ShuffleOp>()) {\n    ProcessShuffle(*shuffle_op);\n    return;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ProcessUnary\",\n                \"parent\": \"WasmShuffleAnalyzer\",\n                \"about\": \"Processes a SIMD128 unary operation.\",\n                \"logic\": \"Adds the unary operation to the demanded element analysis.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"unop\",\n                        \"type\": \"const Simd128UnaryOp&\",\n                        \"purpose\": \"The unary operation to process.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"demanded_element_analysis\",\n                    \"DemandedElementAnalysis\",\n                    \"Simd128UnaryOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmShuffleAnalyzer::ProcessUnary(const Simd128UnaryOp& unop) {\n  demanded_element_analysis.AddUnaryOp(unop, DemandedElementAnalysis::k8x16);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ProcessBinary\",\n                \"parent\": \"WasmShuffleAnalyzer\",\n                \"about\": \"Processes a SIMD128 binary operation.\",\n                \"logic\": \"Adds the binary operation to the demanded element analysis.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"binop\",\n                        \"type\": \"const Simd128BinopOp&\",\n                        \"purpose\": \"The binary operation to process.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"demanded_element_analysis\",\n                    \"DemandedElementAnalysis\",\n                    \"Simd128BinopOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmShuffleAnalyzer::ProcessBinary(const Simd128BinopOp& binop) {\n  demanded_element_analysis.AddBinaryOp(binop, DemandedElementAnalysis::k8x16);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ProcessShuffleOfShuffle\",\n                \"parent\": \"WasmShuffleAnalyzer\",\n                \"about\": \"Processes a shuffle operation that is composed of another shuffle operation.\",\n                \"logic\": \"Analyzes the shuffle to determine if it can be optimized by reducing the width of the inner shuffle.  This involves checking if the shuffle is only using the low or high half of the inner shuffle.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"shuffle_op\",\n                        \"type\": \"const Simd128ShuffleOp&\",\n                        \"purpose\": \"The outer shuffle operation.\"\n                    },\n                    {\n                        \"name\": \"shuffle\",\n                        \"type\": \"const Simd128ShuffleOp&\",\n                        \"purpose\": \"The inner shuffle operation.\"\n                    },\n                    {\n                        \"name\": \"lower_limit\",\n                        \"type\": \"uint8_t\",\n                        \"purpose\": \"The lower limit of the lane indices being considered.\"\n                    },\n                    {\n                        \"name\": \"upper_limit\",\n                        \"type\": \"uint8_t\",\n                        \"purpose\": \"The upper limit of the lane indices being considered.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"demanded_element_analysis\",\n                    \"DemandedElementAnalysis\",\n                    \"Simd128ShuffleOp\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid WasmShuffleAnalyzer::ProcessShuffleOfShuffle(\n    const Simd128ShuffleOp& shuffle_op, const Simd128ShuffleOp& shuffle,\n    uint8_t lower_limit, uint8_t upper_limit) {\n  // Suppose we have two 16-byte shuffles:\n  // |---a1---|---b3---|--------|--------|  shuffle_op = (a, b)\n  //\n  // |---a1---|---b3---|---c?---|---c?---|  shuffle = (shf0, c)\n  //\n  // As only half of the shf0 is used, it means that half the work of shf0 is\n  // wasted so, here, we try to reduce shf0 to a more narrow kind. In the case\n  // above we can simply truncate shf0.shuffle but there are other situations\n  // which involve more work:\n  //\n  // In the following case, shf0.shuffle needs to be shifted left so that it\n  // writes the required lanes to the low half of the result. This then means\n  // that shf1.shuffle needs to be updated to read from the low half.\n  //\n  // |--------|--------|---a1---|---b3---|  shuffle_op = (a, b)\n  //\n  // |---a1---|---b3---|---c?---|---c?---|  shuffle = (shf0, c)\n  //\n\n  struct ShuffleHelper {\n    explicit ShuffleHelper(const uint8_t* shuffle) : shuffle(shuffle) {}\n\n    const uint8_t* begin() const { return shuffle; }\n\n    const uint8_t* midpoint() const {\n      constexpr size_t half_lanes = kSimd128Size / 2;\n      return shuffle + half_lanes;\n    }\n\n    const uint8_t* end() const { return shuffle + kSimd128Size; }\n\n    const uint8_t* shuffle;\n  };\n\n  ShuffleHelper view(shuffle.shuffle);\n\n  // Test whether the low half of the shuffle is within the inclusive range.\n  auto all_low_half = [&view](uint8_t lower_limit, uint8_t upper_limit) {\n    return std::all_of(view.begin(), view.midpoint(),\n                       [lower_limit, upper_limit](uint8_t i) {\n                         return i >= lower_limit && i <= upper_limit"
}