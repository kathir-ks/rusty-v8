{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm/simulator-arm.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm/simulator-arm.h\",\n            \"file_name\": \"simulator-arm.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the ARM instruction simulator used when not generating native ARM binaries. Allows running and debugging ARM code generation on desktop machines.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for globals, data structures, and platform-specific features.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n        ]]></code>\n    </imports>\n    \n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for running with a simulator.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #if defined(USE_SIMULATOR)\n            #include \"src/base/hashmap.h\"\n            #include \"src/base/lazy-instance.h\"\n            #include \"src/base/platform/mutex.h\"\n            #include \"src/codegen/arm/constants-arm.h\"\n            #include \"src/execution/simulator-base.h\"\n            #include \"src/utils/allocation.h\"\n            #include \"src/utils/boxed-float.h\"\n\n            namespace heap::base {\n            class StackVisitor;\n            }\n            #endif\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CachePage\",\n                \"about\": \"Represents a page in the simulated instruction cache.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"data_\",\n                        \"type\": \"char[kPageSize]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The cached data for the page.\"\n                    },\n                    {\n                        \"name\": \"validity_map_\",\n                        \"type\": \"char[kValidityMapSize]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A byte array indicating the validity of each cache line in the page.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class CachePage {\n            public:\n                static const int LINE_VALID = 0;\n                static const int LINE_INVALID = 1;\n\n                static const int kPageShift = 12;\n                static const int kPageSize = 1 << kPageShift;\n                static const int kPageMask = kPageSize - 1;\n                static const int kLineShift = 2;  // The cache line is only 4 bytes right now.\n                static const int kLineLength = 1 << kLineShift;\n                static const int kLineMask = kLineLength - 1;\n\n                CachePage() { memset(&validity_map_, LINE_INVALID, sizeof(validity_map_)); }\n\n                char* ValidityByte(int offset) {\n                    return &validity_map_[offset >> kLineShift];\n                }\n\n                char* CachedData(int offset) { return &data_[offset]; }\n\n            private:\n                char data_[kPageSize];  // The cached data.\n                static const int kValidityMapSize = kPageSize >> kLineShift;\n                char validity_map_[kValidityMapSize];  // One byte per line.\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Simulator\",\n                \"extends\": \"SimulatorBase\",\n                \"about\": \"The ARM instruction simulator.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"registers_\",\n                        \"type\": \"int32_t[16]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Simulates the ARM general-purpose registers.\"\n                    },\n                    {\n                        \"name\": \"n_flag_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Negative condition flag.\"\n                    },\n                    {\n                        \"name\": \"z_flag_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Zero condition flag.\"\n                    },\n                    {\n                        \"name\": \"c_flag_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Carry condition flag.\"\n                    },\n                    {\n                        \"name\": \"v_flag_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Overflow condition flag.\"\n                    },\n                    {\n                        \"name\": \"vfp_registers_\",\n                        \"type\": \"unsigned int[num_d_registers * 2]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Simulates the VFP registers.\"\n                    },\n                    {\n                        \"name\": \"n_flag_FPSCR_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP Negative condition flag.\"\n                    },\n                    {\n                        \"name\": \"z_flag_FPSCR_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP Zero condition flag.\"\n                    },\n                    {\n                        \"name\": \"c_flag_FPSCR_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP Carry condition flag.\"\n                    },\n                    {\n                        \"name\": \"v_flag_FPSCR_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP Overflow condition flag.\"\n                    },\n                    {\n                        \"name\": \"FPSCR_rounding_mode_\",\n                        \"type\": \"VFPRoundingMode\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP rounding mode.\"\n                    },\n                    {\n                        \"name\": \"FPSCR_default_NaN_mode_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP default NaN mode flag.\"\n                    },\n                    {\n                        \"name\": \"inv_op_vfp_flag_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP Invalid Operation exception flag.\"\n                    },\n                    {\n                        \"name\": \"div_zero_vfp_flag_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP Division by Zero exception flag.\"\n                    },\n                    {\n                        \"name\": \"overflow_vfp_flag_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP Overflow exception flag.\"\n                    },\n                    {\n                        \"name\": \"underflow_vfp_flag_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP Underflow exception flag.\"\n                    },\n                    {\n                        \"name\": \"inexact_vfp_flag_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"VFP Inexact exception flag.\"\n                    },\n                    {\n                        \"name\": \"stack_\",\n                        \"type\": \"uint8_t*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The simulated stack.\"\n                    },\n                    {\n                        \"name\": \"pc_modified_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating if the PC has been modified.\"\n                    },\n                    {\n                        \"name\": \"icount_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Instruction count.\"\n                    },\n                    {\n                        \"name\": \"last_debugger_input_\",\n                        \"type\": \"ArrayUniquePtr<char>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the last debugger input.\"\n                    },\n                    {\n                        \"name\": \"break_pc_\",\n                        \"type\": \"Instruction*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The address of a breakpoint instruction.\"\n                    },\n                    {\n                        \"name\": \"break_instr_\",\n                        \"type\": \"Instr\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The breakpoint instruction.\"\n                    },\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"v8::internal::Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"instruction_tracing_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether instruction tracing is enabled.\"\n                    },\n                    {\n                        \"name\": \"watched_stops_\",\n                        \"type\": \"StopCountAndDesc[kNumOfWatchedStops]\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Breakpoint metadata.\"\n                    },\n                    {\n                        \"name\": \"local_monitor_\",\n                        \"type\": \"LocalMonitor\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Local monitor for exclusive memory access.\"\n                    },\n                    {\n                        \"name\": \"global_monitor_processor_\",\n                        \"type\": \"GlobalMonitor::Processor\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Processor for global monitor.\"\n                    },\n                    {\n                        \"name\": \"global_monitor_\",\n                        \"type\": \"GlobalMonitor*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Global monitor for exclusive memory access.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"SimulatorBase\",\n                    \"Isolate\",\n                    \"CachePage\",\n                    \"Float64\",\n                    \"Float32\",\n                    \"heap::base::StackVisitor\",\n                    \"base::Vector\",\n                    \"ArrayUniquePtr\",\n                    \"base::CustomMatcherHashMap\",\n                    \"LocalMonitor\",\n                    \"GlobalMonitor\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class Simulator : public SimulatorBase {\n            public:\n                friend class ArmDebugger;\n                enum Register {\n                    no_reg = -1,\n                    r0 = 0,\n                    r1,\n                    r2,\n                    r3,\n                    r4,\n                    r5,\n                    r6,\n                    r7,\n                    r8,\n                    r9,\n                    r10,\n                    r11,\n                    r12,\n                    r13,\n                    r14,\n                    r15,\n                    num_registers,\n                    fp = 11,\n                    ip = 12,\n                    sp = 13,\n                    lr = 14,\n                    pc = 15,\n                    s0 = 0,\n                    s1,\n                    s2,\n                    s3,\n                    s4,\n                    s5,\n                    s6,\n                    s7,\n                    s8,\n                    s9,\n                    s10,\n                    s11,\n                    s12,\n                    s13,\n                    s14,\n                    s15,\n                    s16,\n                    s17,\n                    s18,\n                    s19,\n                    s20,\n                    s21,\n                    s22,\n                    s23,\n                    s24,\n                    s25,\n                    s26,\n                    s27,\n                    s28,\n                    s29,\n                    s30,\n                    s31,\n                    num_s_registers = 32,\n                    d0 = 0,\n                    d1,\n                    d2,\n                    d3,\n                    d4,\n                    d5,\n                    d6,\n                    d7,\n                    d8,\n                    d9,\n                    d10,\n                    d11,\n                    d12,\n                    d13,\n                    d14,\n                    d15,\n                    d16,\n                    d17,\n                    d18,\n                    d19,\n                    d20,\n                    d21,\n                    d22,\n                    d23,\n                    d24,\n                    d25,\n                    d26,\n                    d27,\n                    d28,\n                    d29,\n                    d30,\n                    d31,\n                    num_d_registers = 32,\n                    q0 = 0,\n                    q1,\n                    q2,\n                    q3,\n                    q4,\n                    q5,\n                    q6,\n                    q7,\n                    q8,\n                    q9,\n                    q10,\n                    q11,\n                    q12,\n                    q13,\n                    q14,\n                    q15,\n                    num_q_registers = 16\n                };\n\n                explicit Simulator(Isolate* isolate);\n                ~Simulator();\n\n                // The currently executing Simulator instance. Potentially there can be one\n                // for each native thread.\n                V8_EXPORT_PRIVATE static Simulator* current(v8::internal::Isolate* isolate);\n\n                // Accessors for register state. Reading the pc value adheres to the ARM\n                // architecture specification and is off by a 8 from the currently executing\n                // instruction.\n                void set_register(int reg, int32_t value);\n                V8_EXPORT_PRIVATE int32_t get_register(int reg) const;\n                double get_double_from_register_pair(int reg);\n                void set_register_pair_from_double(int reg, double* value);\n                void set_dw_register(int dreg, const int* dbl);\n\n                // Support for VFP.\n                void get_d_register(int dreg, uint64_t* value);\n                void set_d_register(int dreg, const uint64_t* value);\n                void get_d_register(int dreg, uint32_t* value);\n                void set_d_register(int dreg, const uint32_t* value);\n                // Support for NEON.\n                template <typename T, int SIZE = kSimd128Size>\n                void get_neon_register(int reg, T (&value)[SIZE / sizeof(T)]);\n                template <typename T, int SIZE = kSimd128Size>\n                void set_neon_register(int reg, const T (&value)[SIZE / sizeof(T)]);\n\n                void set_s_register(int reg, unsigned int value);\n                unsigned int get_s_register(int reg) const;\n\n                void set_d_register_from_double(int dreg, const Float64 dbl) {\n                    SetVFPRegister<Float64, 2>(dreg, dbl);\n                }\n                void set_d_register_from_double(int dreg, const double dbl) {\n                    SetVFPRegister<double, 2>(dreg, dbl);\n                }\n\n                Float64 get_double_from_d_register(int dreg) {\n                    return GetFromVFPRegister<Float64, 2>(dreg);\n                }\n\n                void set_s_register_from_float(int sreg, const Float32 flt) {\n                    SetVFPRegister<Float32, 1>(sreg, flt);\n                }\n                void set_s_register_from_float(int sreg, const float flt) {\n                    SetVFPRegister<float, 1>(sreg, flt);\n                }\n\n                Float32 get_float_from_s_register(int sreg) {\n                    return GetFromVFPRegister<Float32, 1>(sreg);\n                }\n\n                void set_s_register_from_sinteger(int sreg, const int sint) {\n                    SetVFPRegister<int, 1>(sreg, sint);\n                }\n\n                int get_sinteger_from_s_register(int sreg) {\n                    return GetFromVFPRegister<int, 1>(sreg);\n                }\n\n                // Special case of set_register and get_register to access the raw PC value.\n                void set_pc(int32_t value);\n                V8_EXPORT_PRIVATE int32_t get_pc() const;\n\n                Address get_sp() const { return static_cast<Address>(get_register(sp)); }\n\n                // Accessor to the internal simulator stack area. Adds a safety\n                // margin to prevent overflows (kAdditionalStackMargin).\n                uintptr_t StackLimit(uintptr_t c_limit) const;\n\n                uintptr_t StackBase() const;\n\n                // Return central stack view, without additional safety margins.\n                // Users, for example wasm::StackMemory, can add their own.\n                base::Vector<uint8_t> GetCentralStackView() const;\n\n                void IterateRegistersAndStack(::heap::base::StackVisitor* visitor);\n\n                // Executes ARM instructions until the PC reaches end_sim_pc.\n                void Execute();\n\n                template <typename Return, typename... Args>\n                Return Call(Address entry, Args... args) {\n                    return VariadicCall<Return>(this, &Simulator::CallImpl, entry, args...);\n                }\n\n                // Alternative: call a 2-argument double function.\n                template <typename Return>\n                Return CallFP(Address entry, double d0, double d1) {\n                    return ConvertReturn<Return>(CallFPImpl(entry, d0, d1));\n                }\n\n                // Push an address onto the JS stack.\n                V8_EXPORT_PRIVATE uintptr_t PushAddress(uintptr_t address);\n\n                // Pop an address from the JS stack.\n                V8_EXPORT_PRIVATE uintptr_t PopAddress();\n\n                // Debugger input.\n                void set_last_debugger_input(ArrayUniquePtr<char> input) {\n                    last_debugger_input_ = std::move(input);\n                }\n                const char* last_debugger_input() { return last_debugger_input_.get(); }\n\n                // Redirection support.\n                static void SetRedirectInstruction(Instruction* instruction);\n\n                // ICache checking.\n                static bool ICacheMatch(void* one, void* two);\n                static void FlushICache(base::CustomMatcherHashMap* i_cache, void* start,\n                                          size_t size);\n\n                // Returns true if pc register contains one of the 'special_values' defined\n                // below (bad_lr, end_sim_pc).\n                bool has_bad_pc() const;\n\n                // EABI variant for double arguments in use.\n                bool use_eabi_hardfloat() {\n                #if USE_EABI_HARDFLOAT\n                    return true;\n                #else\n                    return false;\n                #endif\n                }\n\n                // Manage instruction tracing.\n                bool InstructionTracingEnabled();\n\n                void ToggleInstructionTracing();\n\n            private:\n                enum special_values {\n                    // Known bad pc value to ensure that the simulator does not execute\n                    // without being properly setup.\n                    bad_lr = -1,\n                    // A pc value used to signal the simulator to stop execution.  Generally\n                    // the lr is set to this value on transition from native C code to\n                    // simulated execution, so that the simulator can \"return\" to the native\n                    // C code.\n                    end_sim_pc = -2\n                };\n\n                V8_EXPORT_PRIVATE intptr_t CallImpl(Address entry, int argument_count,\n                                                    const intptr_t* arguments);\n                intptr_t CallFPImpl(Address entry, double d0, double d1);\n\n                // Unsupported instructions use Format to print an error and stop execution.\n                void Format(Instruction* instr, const char* format);\n\n                // Checks if the current instruction should be executed based on its\n                // condition bits.\n                inline bool ConditionallyExecute(Instruction* instr);\n\n                // Helper functions to set the conditional flags in the architecture state.\n                void SetNZFlags(int32_t val);\n                void SetCFlag(bool val);\n                void SetVFlag(bool val);\n                bool CarryFrom(int32_t left, int32_t right, int32_t carry = 0);\n                bool BorrowFrom(int32_t left, int32_t right, int32_t carry = 1);\n                bool OverflowFrom(int32_t alu_out, int32_t left, int32_t right,\n                                    bool addition);\n\n                inline int GetCarry() { return c_flag_ ? 1 : 0; }\n\n                // Support for VFP.\n                void Compute_FPSCR_Flags(float val1, float val2);\n                void Compute_FPSCR_Flags(double val1, double val2);\n                void Copy_FPSCR_to_APSR();\n                inline float canonicalizeNaN(float value);\n                inline double canonicalizeNaN(double value);\n                inline Float32 canonicalizeNaN(Float32 value);\n                inline Float64 canonicalizeNaN(Float64 value);\n\n                // Helper functions to decode common \"addressing\" modes\n                int32_t GetShiftRm(Instruction* instr, bool* carry_out);\n                int32_t GetImm(Instruction* instr, bool* carry_out);\n                int32_t ProcessPU(Instruction* instr, int num_regs, int operand_size,\n                                    intptr_t* start_address, intptr_t* end_address);\n                void HandleRList(Instruction* instr, bool load);\n                void HandleVList(Instruction* inst);\n                void SoftwareInterrupt(Instruction* instr);\n                void DebugAtNextPC();\n\n                // Take a copy of v8 simulator tracing flag because flags are frozen after\n                // start.\n                bool instruction_tracing_ = v8_flags.trace_sim;\n\n                // Helper to write back values to register.\n                void AdvancedSIMDElementOrStructureLoadStoreWriteback(int Rn, int Rm,\n                                                                        int ebytes);\n\n                // Stop helper functions.\n                inline bool isWatchedStop(uint32_t bkpt_code);\n                inline bool isEnabledStop(uint32_t bkpt_code);\n                inline void EnableStop(uint32_t bkpt_code);\n                inline void DisableStop(uint32_t bkpt_code);\n                inline void IncreaseStopCounter(uint32_t bkpt_code);\n                void PrintStopInfo(uint32_t code);\n\n                // Read and write memory.\n                // The *Ex functions are exclusive access. The writes return the strex status:\n                // 0 if the write succeeds, and 1 if the write fails.\n                inline uint8_t ReadBU(int32_t addr);\n                inline int8_t ReadB(int32_t addr);\n                uint8_t ReadExBU(int32_t addr);\n                inline void WriteB(int32_t addr, uint8_t value);\n                inline void WriteB(int32_t addr, int8_t value);\n                int WriteExB(int32_t addr, uint8_t value);\n\n                inline uint16_t ReadHU(int32_t addr);\n                inline int16_t ReadH(int32_t addr);\n                uint16_t ReadExHU(int32_t addr);\n                // Note: Overloaded on the sign of the value.\n                inline void WriteH(int32_t addr, uint16_t value);\n                inline void WriteH(int32_t addr, int16_t value);\n                int WriteExH(int32_t addr, uint16_t value);\n\n                inline int ReadW(int32_t addr);\n                int ReadExW(int32_t addr);\n                inline void WriteW(int32_t addr, int value);\n                int WriteExW(int32_t addr, int value);\n\n                int32_t* ReadDW(int32_t addr);\n                void WriteDW(int32_t addr, int32_t value1, int32_t value2);\n                int32_t* ReadExDW(int32_t addr);\n                int WriteExDW(int32_t addr, int32_t value1, int32_t value2);\n\n                // Executing is handled based on the instruction type.\n                // Both type 0 and type 1 rolled into one.\n                void DecodeType01(Instruction* instr);\n                void DecodeType2(Instruction* instr);\n                void DecodeType3(Instruction* instr);\n                void DecodeType4(Instruction* instr);\n                void DecodeType5(Instruction* instr);\n                void DecodeType6(Instruction* instr);\n                void DecodeType7(Instruction* instr);\n\n                // CP15 coprocessor instructions.\n                void DecodeTypeCP15(Instruction* instr);\n\n                // Support for VFP.\n                void DecodeTypeVFP(Instruction* instr);\n                void DecodeType6CoprocessorIns(Instruction* instr);\n                void DecodeSpecialCondition(Instruction* instr);\n\n                void DecodeFloatingPointDataProcessing(Instruction* instr);\n                void DecodeUnconditional(Instruction* instr);\n                void DecodeAdvancedSIMDDataProcessing(Instruction* instr);\n                void DecodeMemoryHintsAndBarriers(Instruction* instr);\n                void DecodeAdvancedSIMDElementOrStructureLoadStore(Instruction* instr);\n                void DecodeAdvancedSIMDLoadStoreMultipleStructures(Instruction* instr);\n                void DecodeAdvancedSIMDLoadSingleStructureToAllLanes(Instruction* instr);\n                void DecodeAdvancedSIMDLoadStoreSingleStructureToOneLane(Instruction* instr);\n                void DecodeAdvancedSIMDTwoOrThreeRegisters(Instruction* instr);\n\n                void DecodeVMOVBetweenCoreAndSinglePrecisionRegisters(Instruction* instr);\n                void DecodeVCMP(Instruction* instr);\n                void DecodeVCVTBetweenDoubleAndSingle(Instruction* instr);\n                int32_t ConvertDoubleToInt(double val, bool unsigned_integer,\n                                             VFPRoundingMode mode);\n                void DecodeVCVTBetweenFloatingPointAndInteger(Instruction* instr);\n\n                // Executes one instruction.\n                void InstructionDecode(Instruction* instr);\n\n                // ICache.\n                static void CheckICache(base::CustomMatcherHashMap* i_cache,\n                                          Instruction* instr);\n                static void FlushOnePage(base::CustomMatcherHashMap* i_cache, intptr_t start,\n                                           int size);\n                static CachePage* GetCachePage(base::CustomMatcherHashMap* i_cache,\n                                                  void* page);\n\n                // Handle arguments and return value for runtime FP functions.\n                void GetFpArgs(double* x, double* y, int32_t* z);\n                void SetFpResult(const double& result);\n                void TrashCallerSaveRegisters();\n\n                template <class ReturnType, int register_size>\n                ReturnType GetFromVFPRegister(int reg_index);\n\n                template <class InputType, int register_size>\n                void SetVFPRegister(int reg_index, const InputType& value);\n\n                void SetSpecialRegister(SRegisterFieldMask reg_and_mask, uint32_t value);\n                uint32_t GetFromSpecialRegister(SRegister reg);\n\n                void CallInternal(Address entry);\n\n                // Architecture state.\n                // Saturating instructions require a Q flag to indicate saturation.\n                // There is currently no way to read the CPSR directly, and thus read the Q\n                // flag, so this is left unimplemented.\n                int32_t registers_[16];\n                bool n_flag_;\n                bool z_flag_;\n                bool c_flag_;\n                bool v_flag_;\n\n                // VFP architecture state.\n                unsigned int vfp_registers_[num_d_registers * 2];\n                bool n_flag_FPSCR_;\n                bool z_flag_FPSCR_;\n                bool c_flag_FPSCR_;\n                bool v_flag_FPSCR_;\n\n                // VFP rounding mode. See ARM DDI 0406B Page A2-29.\n                VFPRoundingMode FPSCR_rounding_mode_;\n                bool FPSCR_default_NaN_mode_;\n\n                // VFP FP exception flags architecture state.\n                bool inv_op_vfp_flag_;\n                bool div_zero_vfp_flag_;\n                bool overflow_vfp_flag_;\n                bool underflow_vfp_flag_;\n                bool inexact_vfp_flag_;\n\n                // Simulator support for the stack.\n                uint8_t* stack_;\n                static const size_t kAllocatedStackSize = 1 * MB;\n                // We leave a small buffer below the usable stack to protect against potential\n                // stack underflows.\n                static const int kStackMargin = 64;\n                // Added in Simulator::StackLimit()\n                static const int kAdditionalStackMargin = 4 * KB;\n                static const size_t kUsableStackSize = kAllocatedStackSize - kStackMargin;\n                bool pc_modified_;\n                int icount_;\n\n                // Debugger input.\n                ArrayUniquePtr<char> last_debugger_input_;\n\n                // Registered breakpoints.\n                Instruction* break_pc_;\n                Instr break_instr_;\n\n                v8::internal::Isolate* isolate_;\n\n                // A stop is watched if its code is less than kNumOfWatchedStops.\n                // Only watched stops support enabling/disabling and the counter feature.\n                static const uint32_t kNumOfWatchedStops = 256;\n\n                // Breakpoint is disabled if bit 31 is set.\n                static const uint32_t kStopDisabledBit = 1 << 31;\n\n                // A stop is enabled, meaning the simulator will stop when meeting the\n                // instruction, if bit 31 of watched_stops_[code].count is unset.\n                // The value watched_stops_[code].count & ~(1 << 31) indicates how many times\n                // the breakpoint was hit or gone through.\n                struct StopCountAndDesc {\n                    uint32_t count;\n                    char* desc;\n                };\n                StopCountAndDesc watched_stops_[kNumOfWatchedStops];\n\n                // Synchronization primitives. See ARM DDI 0406C.b, A2.9.\n                enum class MonitorAccess {\n                    Open,\n                    Exclusive,\n                };\n\n                enum class TransactionSize {\n                    None = 0,\n                    Byte = 1,\n                    HalfWord = 2,\n                    Word = 4,\n                    DoubleWord = 8,\n                };\n\n                // The least-significant bits of the address are ignored. The number of bits\n                // is implementation-defined, between 3 and 11. See ARM DDI 0406C.b, A3.4.3.\n                static const int32_t kExclusiveTaggedAddrMask = ~((1 << 11) - 1);\n\n                class LocalMonitor {\n                public:\n                    LocalMonitor();\n\n                    // These functions manage the state machine for the local monitor, but do\n                    // not actually perform loads and stores. NotifyStoreExcl only returns\n                    // true if the exclusive store is allowed; the global monitor will still\n                    // have to be checked to see whether the memory should be updated.\n                    void NotifyLoad(int32_t addr);\n                    void NotifyLoadExcl(int32_t addr, TransactionSize size);\n                    void NotifyStore(int32_t addr);\n                    bool NotifyStoreExcl(int32_t addr, TransactionSize size);\n\n                private:\n                    void Clear();\n\n                    MonitorAccess access_state_;\n                    int32_t tagged_addr_;\n                    TransactionSize size_;\n                };\n\n                class GlobalMonitor {\n                public:\n                    class SimulatorMutex final {\n                    public:\n                        explicit SimulatorMutex(GlobalMonitor* global_monitor) {\n                            if (!global_monitor->IsSingleThreaded()) {\n                                guard.emplace(global_monitor->mutex_);\n                            }\n                        }\n\n                    private:\n                        std::optional<base::MutexGuard> guard;\n                    };\n\n                    class Processor {\n                    public:\n                        Processor();\n\n                    private:\n                        friend class GlobalMonitor;\n                        // These functions manage the state machine for the global monitor, but do\n                        // not actually perform loads and stores.\n                        void Clear_Locked();\n                        void NotifyLoadExcl_Locked(int32_t addr);\n                        void NotifyStore_Locked(int32_t addr, bool is_requesting_processor);\n                        bool NotifyStoreExcl_Locked(int32_t addr, bool is_requesting_processor);\n\n                        MonitorAccess access_state_;\n                        int32_t tagged_addr_;\n                        Processor* next_;\n                        Processor* prev_;\n                        // A strex can fail due to background cache evictions. Rather than\n                        // simulating this, we'll just occasionally introduce cases where an\n                        // exclusive store fails. This will happen once after every\n                        // kMaxFailureCounter exclusive stores.\n                        static const int kMaxFailureCounter = 5;\n                        int failure_counter_;\n                    };\n\n                    void NotifyLoadExcl_Locked(int32_t addr, Processor* processor);\n                    void NotifyStore_Locked(int32_t addr, Processor* processor);\n                    bool NotifyStoreExcl_Locked(int32_t addr, Processor* processor);\n\n                    // Called when the simulator is constructed.\n                    void PrependProcessor(Processor* processor);\n                    // Called when the simulator is destroyed.\n                    void RemoveProcessor(Processor* processor);\n\n                    static GlobalMonitor* Get();\n\n                private:\n                    bool IsSingleThreaded() const { return num_processors_ == 1; }\n\n                    // Private constructor. Call {GlobalMonitor::Get()} to get the singleton.\n                    GlobalMonitor() = default;\n                    friend class base::LeakyObject<GlobalMonitor>;\n\n                    Processor* head_ = nullptr;\n                    std::atomic<uint32_t> num_processors_ = 0;\n                    base::Mutex mutex_;\n                };\n\n                LocalMonitor local_monitor_;\n                GlobalMonitor::Processor global_monitor_processor_;\n                GlobalMonitor* global_monitor_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalMonitor\",\n                \"about\": \"Manages the local monitor for exclusive memory access.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"access_state_\",\n                        \"type\": \"MonitorAccess\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The current access state of the monitor (Open or Exclusive).\"\n                    },\n                    {\n                        \"name\": \"tagged_addr_\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The tagged address being monitored.\"\n                    },\n                    {\n                        \"name\": \"size_\",\n                        \"type\": \"TransactionSize\",\n                        \"access\": \"private\",\n                        \"purpose"
}