{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm/code-generator-arm.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/arm/code-generator-arm.cc\",\n        \"file_name\": \"code-generator-arm.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Arm-specific code generator for the V8 compiler backend.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library and V8-specific headers for number handling, code generation, architecture-specific definitions, compilation information, node matching, and other utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/numbers/double.h\"\n#include \"src/codegen/arm/assembler-arm.h\"\n#include \"src/codegen/arm/constants-arm.h\"\n#include \"src/codegen/arm/register-arm.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/interface-descriptors-inl.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/backend/code-generator-impl.h\"\n#include \"src/compiler/backend/code-generator.h\"\n#include \"src/compiler/backend/gap-resolver.h\"\n#include \"src/compiler/backend/instruction-codes.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/osr.h\"\n#include \"src/heap/mutable-page-metadata.h\"\n#include \"src/utils/boxed-float.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-linkage.h\"\n#include \"src/wasm/wasm-objects.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ArmOperandConverter\",\n            \"extends\": \"InstructionOperandConverter\",\n            \"about\": \"Adds Arm-specific methods to convert InstructionOperands.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"Instruction\",\n                \"Operand\",\n                \"MemOperand\",\n                \"AddressingModeField\",\n                \"Constant\",\n                \"FrameOffset\",\n                \"NeonMemOperand\",\n                \"FlagsCondition\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ArmOperandConverter final : public InstructionOperandConverter {\n public:\n  ArmOperandConverter(CodeGenerator* gen, Instruction* instr)\n      : InstructionOperandConverter(gen, instr) {}\n\n  SBit OutputSBit() const {\n    switch (instr_->flags_mode()) {\n      case kFlags_branch:\n      case kFlags_conditional_branch:\n      case kFlags_deoptimize:\n      case kFlags_set:\n      case kFlags_conditional_set:\n      case kFlags_trap:\n      case kFlags_select:\n        return SetCC;\n      case kFlags_none:\n        return LeaveCC;\n    }\n    UNREACHABLE();\n  }\n\n  Operand InputImmediate(size_t index) const {\n    return ToImmediate(instr_->InputAt(index));\n  }\n\n  Operand InputOperand2(size_t first_index) {\n    const size_t index = first_index;\n    switch (AddressingModeField::decode(instr_->opcode())) {\n      case kMode_None:\n      case kMode_Offset_RI:\n      case kMode_Offset_RR:\n      case kMode_Root:\n        break;\n      case kMode_Operand2_I:\n        return InputImmediate(index + 0);\n      case kMode_Operand2_R:\n        return Operand(InputRegister(index + 0));\n      case kMode_Operand2_R_ASR_I:\n        return Operand(InputRegister(index + 0), ASR, InputInt5(index + 1));\n      case kMode_Operand2_R_ASR_R:\n        return Operand(InputRegister(index + 0), ASR, InputRegister(index + 1));\n      case kMode_Operand2_R_LSL_I:\n        return Operand(InputRegister(index + 0), LSL, InputInt5(index + 1));\n      case kMode_Operand2_R_LSL_R:\n        return Operand(InputRegister(index + 0), LSL, InputRegister(index + 1));\n      case kMode_Operand2_R_LSR_I:\n        return Operand(InputRegister(index + 0), LSR, InputInt5(index + 1));\n      case kMode_Operand2_R_LSR_R:\n        return Operand(InputRegister(index + 0), LSR, InputRegister(index + 1));\n      case kMode_Operand2_R_ROR_I:\n        return Operand(InputRegister(index + 0), ROR, InputInt5(index + 1));\n      case kMode_Operand2_R_ROR_R:\n        return Operand(InputRegister(index + 0), ROR, InputRegister(index + 1));\n    }\n    UNREACHABLE();\n  }\n\n  MemOperand InputOffset(size_t* first_index) {\n    const size_t index = *first_index;\n    switch (AddressingModeField::decode(instr_->opcode())) {\n      case kMode_None:\n      case kMode_Operand2_I:\n      case kMode_Operand2_R:\n      case kMode_Operand2_R_ASR_I:\n      case kMode_Operand2_R_ASR_R:\n      case kMode_Operand2_R_LSL_R:\n      case kMode_Operand2_R_LSR_I:\n      case kMode_Operand2_R_LSR_R:\n      case kMode_Operand2_R_ROR_I:\n      case kMode_Operand2_R_ROR_R:\n        break;\n      case kMode_Operand2_R_LSL_I:\n        *first_index += 3;\n        return MemOperand(InputRegister(index + 0), InputRegister(index + 1),\n                          LSL, InputInt32(index + 2));\n      case kMode_Offset_RI:\n        *first_index += 2;\n        return MemOperand(InputRegister(index + 0), InputInt32(index + 1));\n      case kMode_Offset_RR:\n        *first_index += 2;\n        return MemOperand(InputRegister(index + 0), InputRegister(index + 1));\n      case kMode_Root:\n        *first_index += 1;\n        return MemOperand(kRootRegister, InputInt32(index));\n    }\n    UNREACHABLE();\n  }\n\n  MemOperand InputOffset(size_t first_index = 0) {\n    return InputOffset(&first_index);\n  }\n\n  Operand ToImmediate(InstructionOperand* operand) const {\n    Constant constant = ToConstant(operand);\n    switch (constant.type()) {\n      case Constant::kInt32:\n        return Operand(constant.ToInt32(), constant.rmode());\n      case Constant::kFloat32:\n        return Operand::EmbeddedNumber(constant.ToFloat32());\n      case Constant::kFloat64:\n        return Operand::EmbeddedNumber(constant.ToFloat64().value());\n      case Constant::kExternalReference:\n        return Operand(constant.ToExternalReference());\n      case Constant::kInt64:\n      case Constant::kCompressedHeapObject:\n      case Constant::kHeapObject:\n      // TODO(dcarney): loading RPO constants on arm.\n      case Constant::kRpoNumber:\n        break;\n    }\n    UNREACHABLE();\n  }\n\n  MemOperand ToMemOperand(InstructionOperand* op) const {\n    DCHECK_NOT_NULL(op);\n    DCHECK(op->IsStackSlot() || op->IsFPStackSlot());\n    return SlotToMemOperand(AllocatedOperand::cast(op)->index());\n  }\n\n  MemOperand SlotToMemOperand(int slot) const {\n    FrameOffset offset = frame_access_state()->GetFrameOffset(slot);\n    return MemOperand(offset.from_stack_pointer() ? sp : fp, offset.offset());\n  }\n\n  NeonMemOperand NeonInputOperand(size_t first_index) {\n    const size_t index = first_index;\n    switch (AddressingModeField::decode(instr_->opcode())) {\n      case kMode_Operand2_R:\n        return NeonMemOperand(InputRegister(index + 0));\n      default:\n        break;\n    }\n    UNREACHABLE();\n  }\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineRecordWrite\",\n            \"extends\": \"OutOfLineCode\",\n            \"about\": \"Handles out-of-line record write operations for write barriers.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"Register\",\n                \"Operand\",\n                \"RecordWriteMode\",\n                \"OutOfLineCode\",\n                \"MemoryChunk\",\n                \"SaveFPRegsMode\",\n                \"Zone\",\n                \"UnwindingInfoWriter\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass OutOfLineRecordWrite final : public OutOfLineCode {\n public:\n  OutOfLineRecordWrite(CodeGenerator* gen, Register object, Operand offset,\n                       Register value, RecordWriteMode mode,\n                       StubCallMode stub_mode,\n                       UnwindingInfoWriter* unwinding_info_writer)\n      : OutOfLineCode(gen),\n        object_(object),\n        offset_(offset),\n        value_(value),\n        mode_(mode),\n#if V8_ENABLE_WEBASSEMBLY\n        stub_mode_(stub_mode),\n#endif  // V8_ENABLE_WEBASSEMBLY\n        must_save_lr_(!gen->frame_access_state()->has_frame()),\n        unwinding_info_writer_(unwinding_info_writer),\n        zone_(gen->zone()) {\n  }\n\n  void Generate() final {\n    __ CheckPageFlag(value_, MemoryChunk::kPointersToHereAreInterestingMask, eq,\n                     exit());\n    SaveFPRegsMode const save_fp_mode = frame()->DidAllocateDoubleRegisters()\n                                            ? SaveFPRegsMode::kSave\n                                            : SaveFPRegsMode::kIgnore;\n    if (must_save_lr_) {\n      // We need to save and restore lr if the frame was elided.\n      __ Push(lr);\n      unwinding_info_writer_->MarkLinkRegisterOnTopOfStack(__ pc_offset());\n    }\n    if (mode_ == RecordWriteMode::kValueIsEphemeronKey) {\n      __ CallEphemeronKeyBarrier(object_, offset_, save_fp_mode);\n#if V8_ENABLE_WEBASSEMBLY\n    } else if (stub_mode_ == StubCallMode::kCallWasmRuntimeStub) {\n      __ CallRecordWriteStubSaveRegisters(object_, offset_, save_fp_mode,\n                                          StubCallMode::kCallWasmRuntimeStub);\n#endif  // V8_ENABLE_WEBASSEMBLY\n    } else {\n      __ CallRecordWriteStubSaveRegisters(object_, offset_, save_fp_mode);\n    }\n    if (must_save_lr_) {\n      __ Pop(lr);\n      unwinding_info_writer_->MarkPopLinkRegisterFromTopOfStack(__ pc_offset());\n    }\n  }\n\n private:\n  Register const object_;\n  Operand const offset_;\n  Register const value_;\n  RecordWriteMode const mode_;\n#if V8_ENABLE_WEBASSEMBLY\n  StubCallMode stub_mode_;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  bool must_save_lr_;\n  UnwindingInfoWriter* const unwinding_info_writer_;\n  Zone* zone_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineFloatMin\",\n            \"about\": \"Handles out-of-line float min operations.\",\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"OutOfLineCode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass OutOfLineFloatMin final : public OutOfLineCode {\n public:\n  OutOfLineFloatMin(CodeGenerator* gen, T result, T left, T right)\n      : OutOfLineCode(gen), result_(result), left_(left), right_(right) {}\n\n  void Generate() final { __ FloatMinOutOfLine(result_, left_, right_); }\n\n private:\n  T const result_;\n  T const left_;\n  T const right_;\n};\nusing OutOfLineFloat32Min = OutOfLineFloatMin<SwVfpRegister>;\nusing OutOfLineFloat64Min = OutOfLineFloatMin<DwVfpRegister>;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutOfLineFloatMax\",\n            \"about\": \"Handles out-of-line float max operations.\",\n            \"dependencies\": [\n                \"CodeGenerator\",\n                \"OutOfLineCode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nclass OutOfLineFloatMax final : public OutOfLineCode {\n public:\n  OutOfLineFloatMax(CodeGenerator* gen, T result, T left, T right)\n      : OutOfLineCode(gen), result_(result), left_(left), right_(right) {}\n\n  void Generate() final { __ FloatMaxOutOfLine(result_, left_, right_); }\n\n private:\n  T const result_;\n  T const left_;\n  T const right_;\n};\nusing OutOfLineFloat32Max = OutOfLineFloatMax<SwVfpRegister>;\nusing OutOfLineFloat64Max = OutOfLineFloatMax<DwVfpRegister>;\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FlagsConditionToCondition\",\n            \"about\": \"Converts a FlagsCondition enum value to an assembler Condition enum value.\",\n            \"logic\": \"A switch statement maps FlagsCondition enum values (kEqual, kNotEqual, etc.) to their corresponding assembler Condition enum values (eq, ne, etc.).  Handles float-specific and unsigned comparisons appropriately.  Returns an error if an unknown FlagsCondition is encountered.\",\n            \"parameters\": [\n                {\n                    \"name\": \"condition\",\n                    \"type\": \"FlagsCondition\",\n                    \"purpose\": \"The FlagsCondition value to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Condition\",\n                \"description\": \"The corresponding assembler Condition enum value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nCondition FlagsConditionToCondition(FlagsCondition condition) {\n  switch (condition) {\n    case kEqual:\n      return eq;\n    case kNotEqual:\n      return ne;\n    case kSignedLessThan:\n      return lt;\n    case kSignedGreaterThanOrEqual:\n      return ge;\n    case kSignedLessThanOrEqual:\n      return le;\n    case kSignedGreaterThan:\n      return gt;\n    case kUnsignedLessThan:\n      return lo;\n    case kUnsignedGreaterThanOrEqual:\n      return hs;\n    case kUnsignedLessThanOrEqual:\n      return ls;\n    case kUnsignedGreaterThan:\n      return hi;\n    case kFloatLessThanOrUnordered:\n      return lt;\n    case kFloatGreaterThanOrEqual:\n      return ge;\n    case kFloatLessThanOrEqual:\n      return ls;\n    case kFloatGreaterThanOrUnordered:\n      return hi;\n    case kFloatLessThan:\n      return lo;\n    case kFloatGreaterThanOrEqualOrUnordered:\n      return hs;\n    case kFloatLessThanOrEqualOrUnordered:\n      return le;\n    case kFloatGreaterThan:\n      return gt;\n    case kOverflow:\n      return vs;\n    case kNotOverflow:\n      return vc;\n    case kPositiveOrZero:\n      return pl;\n    case kNegative:\n      return mi;\n    default:\n      break;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleDeconstructFrame\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the code to deconstruct a stack frame.\",\n            \"logic\": \"Calls the LeaveFrame macro to restore the stack pointer and frame pointer. Marks the frame deconstruction point for unwinding information.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleDeconstructFrame() {\n  __ LeaveFrame(StackFrame::MANUAL);\n  unwinding_info_writer_.MarkFrameDeconstructed(__ pc_offset());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssemblePrepareTailCall\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the code to prepare for a tail call.\",\n            \"logic\": \"If a frame exists, loads the link register and frame pointer from the stack. Sets the frame access state to use the stack pointer.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssemblePrepareTailCall() {\n  if (frame_access_state()->has_frame()) {\n    __ ldm(ia, fp, {lr, fp});\n  }\n  frame_access_state()->SetFrameAccessToSP();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FlushPendingPushRegisters\",\n            \"about\": \"Flushes any registers currently being pushed onto the stack.\",\n            \"logic\": \"Based on the number of registers being pushed, calls the appropriate push macro. Updates the frame access state to reflect the stack change.\",\n            \"parameters\": [\n                {\n                    \"name\": \"masm\",\n                    \"type\": \"MacroAssembler*\",\n                    \"purpose\": \"The macro assembler to use.\"\n                },\n                {\n                    \"name\": \"frame_access_state\",\n                    \"type\": \"FrameAccessState*\",\n                    \"purpose\": \"The frame access state to update.\"\n                },\n                {\n                    \"name\": \"pending_pushes\",\n                    \"type\": \"ZoneVector<Register>*\",\n                    \"purpose\": \"The vector of registers to push.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid FlushPendingPushRegisters(MacroAssembler* masm,\n                               FrameAccessState* frame_access_state,\n                               ZoneVector<Register>* pending_pushes) {\n  switch (pending_pushes->size()) {\n    case 0:\n      break;\n    case 1:\n      masm->push((*pending_pushes)[0]);\n      break;\n    case 2:\n      masm->Push((*pending_pushes)[0], (*pending_pushes)[1]);\n      break;\n    case 3:\n      masm->Push((*pending_pushes)[0], (*pending_pushes)[1],\n                 (*pending_pushes)[2]);\n      break;\n    default:\n      UNREACHABLE();\n  }\n  frame_access_state->IncreaseSPDelta(pending_pushes->size());\n  pending_pushes->clear();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AdjustStackPointerForTailCall\",\n            \"about\": \"Adjusts the stack pointer to the correct offset for a tail call.\",\n            \"logic\": \"Calculates the difference between the current stack pointer offset and the desired offset. Allocates or deallocates stack space as necessary. Calls FlushPendingPushRegisters if needed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"masm\",\n                    \"type\": \"MacroAssembler*\",\n                    \"purpose\": \"The macro assembler to use.\"\n                },\n                {\n                    \"name\": \"state\",\n                    \"type\": \"FrameAccessState*\",\n                    \"purpose\": \"The frame access state to update.\"\n                },\n                {\n                    \"name\": \"new_slot_above_sp\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The desired stack pointer offset.\"\n                },\n                {\n                    \"name\": \"pending_pushes\",\n                    \"type\": \"ZoneVector<Register>*\",\n                    \"purpose\": \"Optional vector of registers being pushed.\"\n                },\n                {\n                    \"name\": \"allow_shrinkage\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether stack pointer shrinkage is allowed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"FlushPendingPushRegisters\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AdjustStackPointerForTailCall(\n    MacroAssembler* masm, FrameAccessState* state, int new_slot_above_sp,\n    ZoneVector<Register>* pending_pushes = nullptr,\n    bool allow_shrinkage = true) {\n  int current_sp_offset = state->GetSPToFPSlotCount() +\n                          StandardFrameConstants::kFixedSlotCountAboveFp;\n  int stack_slot_delta = new_slot_above_sp - current_sp_offset;\n  if (stack_slot_delta > 0) {\n    if (pending_pushes != nullptr) {\n      FlushPendingPushRegisters(masm, state, pending_pushes);\n    }\n    masm->AllocateStackSpace(stack_slot_delta * kSystemPointerSize);\n    state->IncreaseSPDelta(stack_slot_delta);\n  } else if (allow_shrinkage && stack_slot_delta < 0) {\n    if (pending_pushes != nullptr) {\n      FlushPendingPushRegisters(masm, state, pending_pushes);\n    }\n    masm->add(sp, sp, Operand(-stack_slot_delta * kSystemPointerSize));\n    state->IncreaseSPDelta(stack_slot_delta);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleTailCallBeforeGap\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the code for a tail call before a gap.\",\n            \"logic\": \"Optimizes pushes compatible with tail calls. Adjusts the stack pointer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction being assembled.\"\n                },\n                {\n                    \"name\": \"first_unused_slot_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The offset of the first unused stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"AdjustStackPointerForTailCall\",\n                \"ArmOperandConverter\",\n                \"FlushPendingPushRegisters\",\n                \"GetPushCompatibleMoves\",\n                \"LocationOperand\",\n                \"kRegisterPush\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleTailCallBeforeGap(Instruction* instr,\n                                              int first_unused_slot_offset) {\n  ZoneVector<MoveOperands*> pushes(zone());\n  GetPushCompatibleMoves(instr, kRegisterPush, &pushes);\n\n  if (!pushes.empty() &&\n      (LocationOperand::cast(pushes.back()->destination()).index() + 1 ==\n       first_unused_slot_offset)) {\n    ArmOperandConverter g(this, instr);\n    ZoneVector<Register> pending_pushes(zone());\n    for (auto move : pushes) {\n      LocationOperand destination_location(\n          LocationOperand::cast(move->destination()));\n      InstructionOperand source(move->source());\n      AdjustStackPointerForTailCall(\n          masm(), frame_access_state(),\n          destination_location.index() - pending_pushes.size(),\n          &pending_pushes);\n      // Pushes of non-register data types are not supported.\n      DCHECK(source.IsRegister());\n      LocationOperand source_location(LocationOperand::cast(source));\n      pending_pushes.push_back(source_location.GetRegister());\n      // TODO(arm): We can push more than 3 registers at once. Add support in\n      // the macro-assembler for pushing a list of registers.\n      if (pending_pushes.size() == 3) {\n        FlushPendingPushRegisters(masm(), frame_access_state(),\n                                  &pending_pushes);\n      }\n      move->Eliminate();\n    }\n    FlushPendingPushRegisters(masm(), frame_access_state(), &pending_pushes);\n  }\n  AdjustStackPointerForTailCall(masm(), frame_access_state(),\n                                first_unused_slot_offset, nullptr, false);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleTailCallAfterGap\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles the code for a tail call after a gap.\",\n            \"logic\": \"Adjusts the stack pointer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction being assembled.\"\n                },\n                {\n                    \"name\": \"first_unused_slot_offset\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The offset of the first unused stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"AdjustStackPointerForTailCall\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid CodeGenerator::AssembleTailCallAfterGap(Instruction* instr,\n                                             int first_unused_slot_offset) {\n  AdjustStackPointerForTailCall(masm(), frame_access_state(),\n                                first_unused_slot_offset);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleCodeStartRegisterCheck\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles a check that the code start register is correct.\",\n            \"logic\": \"Computes the code start address and compares it to the expected register. Asserts if they are not equal.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n// Check that {kJavaScriptCallCodeStartRegister} is correct.\nvoid CodeGenerator::AssembleCodeStartRegisterCheck() {\n  UseScratchRegisterScope temps(masm());\n  Register scratch = temps.Acquire();\n  __ ComputeCodeStartAddress(scratch);\n  __ cmp(scratch, kJavaScriptCallCodeStartRegister);\n  __ Assert(eq, AbortReason::kWrongFunctionCodeStart);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BailoutIfDeoptimized\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles a check for deoptimization and bails out if necessary.\",\n            \"logic\": \"Calls the BailoutIfDeoptimized macro, which checks if the code object is marked for deoptimization and jumps to the CompileLazyDeoptimizedCode builtin if it is.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n// Assembles an instruction after register allocation, producing machine code.\nCodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(\n    Instruction* instr) {\n  ArmOperandConverter i(this, instr);\n\n  __ MaybeCheckConstPool();\n  InstructionCode opcode = instr->opcode();\n  ArchOpcode arch_opcode = ArchOpcodeField::decode(opcode);\n  switch (arch_opcode) {\n    case kArchCallCodeObject: {\n      if (instr->InputAt(0)->IsImmediate()) {\n        __ Call(i.InputCode(0), RelocInfo::CODE_TARGET);\n      } else {\n        Register reg = i.InputRegister(0);\n        DCHECK_IMPLIES(\n            instr->HasCallDescriptorFlag(CallDescriptor::kFixedTargetRegister),\n            reg == kJavaScriptCallCodeStartRegister);\n        __ CallCodeObject(reg);\n      }\n      RecordCallPosition(instr);\n      DCHECK_EQ(LeaveCC, i.OutputSBit());\n      frame_access_state()->ClearSPDelta();\n      break;\n    }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AssembleArchInstruction\",\n            \"parent\": \"CodeGenerator\",\n            \"about\": \"Assembles an architecture-specific instruction after register allocation.\",\n            \"logic\": \"This is the main function for assembling ARM instructions. It uses a large switch statement to handle different opcodes, calling the appropriate assembly macros for each instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction to assemble.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CodeGenerator::CodeGenResult\",\n                \"description\": \"Result of code generation\"\n            },\n            \"dependencies\": [\n                \"ArmOperandConverter\",\n                \"RecordCallPosition\",\n                \"FrameScope\",\n                \"ExternalReference\",\n                \"RecordSafepoint\",\n                \"RecordDeoptInfo\",\n                \"FlagsConditionToCondition\",\n                \"OutOfLineRecordWrite\",\n                \"OutOfLineFloat32Max\",\n                \"OutOfLineFloat64Max\",\n                \"OutOfLineFloat32Min\",\n                \"OutOfLineFloat64Min\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Assembles an instruction after register allocation, producing machine code.\nCodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(\n    Instruction* instr) {\n  ArmOperandConverter i(this, instr);\n\n  __ MaybeCheckConstPool();\n  InstructionCode opcode = instr->opcode();\n  ArchOpcode arch_opcode = ArchOpcodeField::decode(opcode);\n  switch (arch_opcode) {\n    case kArchCallCodeObject: {\n      if (instr->InputAt(0)->IsImmediate()) {\n        __ Call(i.InputCode(0), RelocInfo::CODE_TARGET);\n      } else {\n        Register reg = i.InputRegister(0);\n        DCHECK_IMPLIES(\n            instr->HasCallDescriptorFlag(CallDescriptor::kFixedTargetRegister),\n            reg == kJavaScriptCallCodeStartRegister);\n        __ CallCodeObject(reg);\n      }\n      RecordCallPosition(instr);\n      DCHECK_EQ(LeaveCC, i.OutputSBit());\n      frame_access_state()->ClearSPDelta();\n      break;\n    }\n    case kArchCallBuiltinPointer: {\n      DCHECK(!instr->InputAt(0)->IsImmediate());\n      Register builtin_index = i.InputRegister(0);\n      Register target =\n          instr->HasCallDescriptorFlag(CallDescriptor::kFixedTargetRegister)\n              ? kJavaScriptCallCodeStartRegister\n              : builtin_index;\n      __ CallBuiltinByIndex(builtin_index, target);\n      RecordCallPosition(instr);\n      frame_access_state()->ClearSPDelta();\n      break;\n    }\n#if V8_ENABLE_WEBASSEMBLY\n    case kArchCallWasmFunction:\n    case kArchCallWasmFunctionIndirect: {\n      if (instr->InputAt(0)->IsImmediate()) {\n        DCHECK_EQ(arch_opcode, kArchCallWasmFunction);\n        Constant constant = i.ToConstant(instr->InputAt(0));\n        Address wasm_code = static_cast<Address>(constant.ToInt32());\n        __ Call(wasm_code, constant.rmode());\n      } else if (arch_opcode == kArchCallWasmFunctionIndirect) {\n        __ CallWasmCodePointer(i.InputRegister(0));\n      } else {\n        __ Call(i.InputRegister(0));\n      }\n      RecordCallPosition(instr);\n      DCHECK_EQ(LeaveCC, i.OutputSBit());\n      frame_access_state()->ClearSPDelta();\n      break;\n    }\n    case kArchTailCallWasm:\n    case kArchTailCallWasmIndirect: {\n      if (instr->InputAt(0)->IsImmediate()) {\n        DCHECK_EQ(arch_opcode, kArchTailCallWasm);\n        Constant constant = i.ToConstant(instr->InputAt(0));\n        Address wasm_code = static_cast<"
}