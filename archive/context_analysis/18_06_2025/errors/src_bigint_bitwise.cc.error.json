{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/bigint/bitwise.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/bigint/bitwise.cc\",\n            \"file_name\": \"bitwise.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements bitwise operations for BigInts in V8\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for BigInt operations and utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/bigint/bigint-internal.h\"\n#include \"src/bigint/digit-arithmetic.h\"\n#include \"src/bigint/util.h\"\n#include \"src/bigint/vector-arithmetic.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseAnd_PosPos\",\n                \"parent\": null,\n                \"about\": \"Calculates the bitwise AND of two positive BigInts.\",\n                \"logic\": \"Iterates through the digits of both BigInts, performing the AND operation on corresponding digits. Pads the result with zeros.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first BigInt (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second BigInt (read-only digits).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseAnd_PosPos(RWDigits Z, Digits X, Digits Y) {\n  int pairs = std::min(X.len(), Y.len());\n  DCHECK(Z.len() >= pairs);\n  int i = 0;\n  for (; i < pairs; i++) Z[i] = X[i] & Y[i];\n  for (; i < Z.len(); i++) Z[i] = 0;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseAnd_NegNeg\",\n                \"parent\": null,\n                \"about\": \"Calculates the bitwise AND of two negative BigInts.\",\n                \"logic\": \"Uses the identity (-x) & (-y) == ~((x-1) | (y-1)) == -(((x-1) | (y-1)) + 1). Subtracts 1 from both inputs, performs bitwise OR, adds 1 to the result, and negates.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first BigInt (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second BigInt (read-only digits).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"digit_sub\",\n                    \"Add\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseAnd_NegNeg(RWDigits Z, Digits X, Digits Y) {\n  // (-x) & (-y) == ~(x-1) & ~(y-1)\n  //             == ~((x-1) | (y-1))\n  //             == -(((x-1) | (y-1)) + 1)\n  int pairs = std::min(X.len(), Y.len());\n  digit_t x_borrow = 1;\n  digit_t y_borrow = 1;\n  int i = 0;\n  for (; i < pairs; i++) {\n    Z[i] = digit_sub(X[i], x_borrow, &x_borrow) |\n           digit_sub(Y[i], y_borrow, &y_borrow);\n  }\n  // (At least) one of the next two loops will perform zero iterations:\n  for (; i < X.len(); i++) Z[i] = digit_sub(X[i], x_borrow, &x_borrow);\n  for (; i < Y.len(); i++) Z[i] = digit_sub(Y[i], y_borrow, &y_borrow);\n  DCHECK(x_borrow == 0);\n  DCHECK(y_borrow == 0);\n  for (; i < Z.len(); i++) Z[i] = 0;\n  Add(Z, 1);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseAnd_PosNeg\",\n                \"parent\": null,\n                \"about\": \"Calculates the bitwise AND of a positive and a negative BigInt.\",\n                \"logic\": \"Uses the identity x & (-y) == x & ~(y-1). Subtracts 1 from the negative input, inverts it, and performs bitwise AND with the positive input.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first BigInt (read-only digits, positive).\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second BigInt (read-only digits, negative).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"digit_sub\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseAnd_PosNeg(RWDigits Z, Digits X, Digits Y) {\n  // x & (-y) == x & ~(y-1)\n  int pairs = std::min(X.len(), Y.len());\n  digit_t borrow = 1;\n  int i = 0;\n  for (; i < pairs; i++) Z[i] = X[i] & ~digit_sub(Y[i], borrow, &borrow);\n  for (; i < X.len(); i++) Z[i] = X[i];\n  for (; i < Z.len(); i++) Z[i] = 0;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseOr_PosPos\",\n                \"parent\": null,\n                \"about\": \"Calculates the bitwise OR of two positive BigInts.\",\n                \"logic\": \"Iterates through the digits of both BigInts, performing the OR operation on corresponding digits. Copies the remaining digits from the longer BigInt. Pads the result with zeros.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first BigInt (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second BigInt (read-only digits).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseOr_PosPos(RWDigits Z, Digits X, Digits Y) {\n  int pairs = std::min(X.len(), Y.len());\n  int i = 0;\n  for (; i < pairs; i++) Z[i] = X[i] | Y[i];\n  // (At least) one of the next two loops will perform zero iterations:\n  for (; i < X.len(); i++) Z[i] = X[i];\n  for (; i < Y.len(); i++) Z[i] = Y[i];\n  for (; i < Z.len(); i++) Z[i] = 0;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseOr_NegNeg\",\n                \"parent\": null,\n                \"about\": \"Calculates the bitwise OR of two negative BigInts.\",\n                \"logic\": \"Uses the identity (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1)) == -(((x-1) & (y-1)) + 1). Subtracts 1 from both inputs, performs bitwise AND, adds 1 to the result, and negates.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first BigInt (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second BigInt (read-only digits).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"digit_sub\",\n                    \"Add\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseOr_NegNeg(RWDigits Z, Digits X, Digits Y) {\n  // (-x) | (-y) == ~(x-1) | ~(y-1)\n  //             == ~((x-1) & (y-1))\n  //             == -(((x-1) & (y-1)) + 1)\n  int pairs = std::min(X.len(), Y.len());\n  digit_t x_borrow = 1;\n  digit_t y_borrow = 1;\n  int i = 0;\n  for (; i < pairs; i++) {\n    Z[i] = digit_sub(X[i], x_borrow, &x_borrow) &\n           digit_sub(Y[i], y_borrow, &y_borrow);\n  }\n  // Any leftover borrows don't matter, the '&' would drop them anyway.\n  for (; i < Z.len(); i++) Z[i] = 0;\n  Add(Z, 1);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseOr_PosNeg\",\n                \"parent\": null,\n                \"about\": \"Calculates the bitwise OR of a positive and a negative BigInt.\",\n                \"logic\": \"Uses the identity x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) &~ x) + 1). Subtracts 1 from the negative input, inverts the positive input, performs bitwise AND, adds 1 to the result, and negates.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first BigInt (read-only digits, positive).\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second BigInt (read-only digits, negative).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"digit_sub\",\n                    \"Add\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseOr_PosNeg(RWDigits Z, Digits X, Digits Y) {\n  // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) &~ x) + 1)\n  int pairs = std::min(X.len(), Y.len());\n  digit_t borrow = 1;\n  int i = 0;\n  for (; i < pairs; i++) Z[i] = digit_sub(Y[i], borrow, &borrow) & ~X[i];\n  for (; i < Y.len(); i++) Z[i] = digit_sub(Y[i], borrow, &borrow);\n  DCHECK(borrow == 0);\n  for (; i < Z.len(); i++) Z[i] = 0;\n  Add(Z, 1);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseXor_PosPos\",\n                \"parent\": null,\n                \"about\": \"Calculates the bitwise XOR of two positive BigInts.\",\n                \"logic\": \"Iterates through the digits of both BigInts, performing the XOR operation on corresponding digits. Copies the remaining digits from the longer BigInt. Pads the result with zeros.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first BigInt (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second BigInt (read-only digits).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseXor_PosPos(RWDigits Z, Digits X, Digits Y) {\n  int pairs = X.len();\n  if (Y.len() < X.len()) {\n    std::swap(X, Y);\n    pairs = X.len();\n  }\n  DCHECK(X.len() <= Y.len());\n  int i = 0;\n  for (; i < pairs; i++) Z[i] = X[i] ^ Y[i];\n  for (; i < Y.len(); i++) Z[i] = Y[i];\n  for (; i < Z.len(); i++) Z[i] = 0;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseXor_NegNeg\",\n                \"parent\": null,\n                \"about\": \"Calculates the bitwise XOR of two negative BigInts.\",\n                \"logic\": \"Uses the identity (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1). Subtracts 1 from both inputs and performs bitwise XOR.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first BigInt (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second BigInt (read-only digits).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"digit_sub\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseXor_NegNeg(RWDigits Z, Digits X, Digits Y) {\n  // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)\n  int pairs = std::min(X.len(), Y.len());\n  digit_t x_borrow = 1;\n  digit_t y_borrow = 1;\n  int i = 0;\n  for (; i < pairs; i++) {\n    Z[i] = digit_sub(X[i], x_borrow, &x_borrow) ^\n           digit_sub(Y[i], y_borrow, &y_borrow);\n  }\n  // (At least) one of the next two loops will perform zero iterations:\n  for (; i < X.len(); i++) Z[i] = digit_sub(X[i], x_borrow, &x_borrow);\n  for (; i < Y.len(); i++) Z[i] = digit_sub(Y[i], y_borrow, &y_borrow);\n  DCHECK(x_borrow == 0);\n  DCHECK(y_borrow == 0);\n  for (; i < Z.len(); i++) Z[i] = 0;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitwiseXor_PosNeg\",\n                \"parent\": null,\n                \"about\": \"Calculates the bitwise XOR of a positive and a negative BigInt.\",\n                \"logic\": \"Uses the identity x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1). Subtracts 1 from the negative input, performs bitwise XOR with the positive input, adds 1 to the result, and negates.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The first BigInt (read-only digits, positive).\"\n                    },\n                    {\n                        \"name\": \"Y\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The second BigInt (read-only digits, negative).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"digit_sub\",\n                    \"Add\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid BitwiseXor_PosNeg(RWDigits Z, Digits X, Digits Y) {\n  // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)\n  int pairs = std::min(X.len(), Y.len());\n  digit_t borrow = 1;\n  int i = 0;\n  for (; i < pairs; i++) Z[i] = X[i] ^ digit_sub(Y[i], borrow, &borrow);\n  // (At least) one of the next two loops will perform zero iterations:\n  for (; i < X.len(); i++) Z[i] = X[i];\n  for (; i < Y.len(); i++) Z[i] = digit_sub(Y[i], borrow, &borrow);\n  DCHECK(borrow == 0);\n  for (; i < Z.len(); i++) Z[i] = 0;\n  Add(Z, 1);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"LeftShift\",\n                \"parent\": null,\n                \"about\": \"Performs a left bitwise shift on a BigInt.\",\n                \"logic\": \"Shifts the digits to the left by the specified amount. Handles both digit and bit shifts. Uses carry to propagate shifted bits.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The BigInt to shift (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"shift\",\n                        \"type\": \"digit_t\",\n                        \"purpose\": \"The number of bits to shift.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LeftShift(RWDigits Z, Digits X, digit_t shift) {\n  int digit_shift = static_cast<int>(shift / kDigitBits);\n  int bits_shift = static_cast<int>(shift % kDigitBits);\n\n  int i = 0;\n  for (; i < digit_shift; ++i) Z[i] = 0;\n  if (bits_shift == 0) {\n    for (; i < X.len() + digit_shift; ++i) Z[i] = X[i - digit_shift];\n    for (; i < Z.len(); ++i) Z[i] = 0;\n  } else {\n    digit_t carry = 0;\n    for (; i < X.len() + digit_shift; ++i) {\n      digit_t d = X[i - digit_shift];\n      Z[i] = (d << bits_shift) | carry;\n      carry = d >> (kDigitBits - bits_shift);\n    }\n    if (carry != 0) Z[i++] = carry;\n    for (; i < Z.len(); ++i) Z[i] = 0;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RightShift_ResultLength\",\n                \"parent\": null,\n                \"about\": \"Calculates the result length of a right bitwise shift on a BigInt.\",\n                \"logic\": \"Calculates the length of the result after a right shift. Takes into account the sign of the number and whether rounding down is necessary for negative numbers. Detects possible overflows.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The BigInt to shift (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"x_sign\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"True if the BigInt is negative.\"\n                    },\n                    {\n                        \"name\": \"shift\",\n                        \"type\": \"digit_t\",\n                        \"purpose\": \"The number of bits to shift.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"RightShiftState*\",\n                        \"purpose\": \"Optional pointer to store the right shift state.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The length of the result.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nint RightShift_ResultLength(Digits X, bool x_sign, digit_t shift,\n                            RightShiftState* state) {\n  int digit_shift = static_cast<int>(shift / kDigitBits);\n  int bits_shift = static_cast<int>(shift % kDigitBits);\n  int result_length = X.len() - digit_shift;\n  if (result_length <= 0) return 0;\n\n  // For negative numbers, round down if any bit was shifted out (so that e.g.\n  // -5n >> 1n == -3n and not -2n). Check now whether this will happen and\n  // whether it can cause overflow into a new digit.\n  bool must_round_down = false;\n  if (x_sign) {\n    const digit_t mask = (static_cast<digit_t>(1) << bits_shift) - 1;\n    if ((X[digit_shift] & mask) != 0) {\n      must_round_down = true;\n    } else {\n      for (int i = 0; i < digit_shift; i++) {\n        if (X[i] != 0) {\n          must_round_down = true;\n          break;\n        }\n      }\n    }\n  }\n  // If bits_shift is non-zero, it frees up bits, preventing overflow.\n  if (must_round_down && bits_shift == 0) {\n    // Overflow cannot happen if the most significant digit has unset bits.\n    const bool rounding_can_overflow = digit_ismax(X.msd());\n    if (rounding_can_overflow) ++result_length;\n  }\n\n  if (state) {\n    DCHECK(!must_round_down || x_sign);\n    state->must_round_down = must_round_down;\n  }\n  return result_length;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RightShift\",\n                \"parent\": null,\n                \"about\": \"Performs a right bitwise shift on a BigInt.\",\n                \"logic\": \"Shifts the digits to the right by the specified amount. Handles both digit and bit shifts. Uses carry to propagate shifted bits. Rounds down negative numbers if necessary.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The BigInt to shift (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"shift\",\n                        \"type\": \"digit_t\",\n                        \"purpose\": \"The number of bits to shift.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"const RightShiftState&\",\n                        \"purpose\": \"The right shift state.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Add\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid RightShift(RWDigits Z, Digits X, digit_t shift,\n                const RightShiftState& state) {\n  int digit_shift = static_cast<int>(shift / kDigitBits);\n  int bits_shift = static_cast<int>(shift % kDigitBits);\n\n  int i = 0;\n  if (bits_shift == 0) {\n    for (; i < X.len() - digit_shift; ++i) Z[i] = X[i + digit_shift];\n  } else {\n    digit_t carry = X[digit_shift] >> bits_shift;\n    for (; i < X.len() - digit_shift - 1; ++i) {\n      digit_t d = X[i + digit_shift + 1];\n      Z[i] = (d << (kDigitBits - bits_shift)) | carry;\n      carry = d >> bits_shift;\n    }\n    Z[i++] = carry;\n  }\n  for (; i < Z.len(); ++i) Z[i] = 0;\n\n  if (state.must_round_down) {\n    // Rounding down (a negative value) means adding one to\n    // its absolute value. This cannot overflow.\n    Add(Z, 1);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TruncateToNBits\",\n                \"parent\": null,\n                \"about\": \"Truncates a BigInt to a specified number of bits.\",\n                \"logic\": \"Copies the least significant N bits of the input BigInt to the output. Masks the most significant digit if necessary.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The BigInt to truncate (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"n\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of bits to keep.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\n// Z := (least significant n bits of X).\nvoid TruncateToNBits(RWDigits Z, Digits X, int n) {\n  int digits = DIV_CEIL(n, kDigitBits);\n  int bits = n % kDigitBits;\n  // Copy all digits except the MSD.\n  int last = digits - 1;\n  for (int i = 0; i < last; i++) {\n    Z[i] = X[i];\n  }\n  // The MSD might contain extra bits that we don't want.\n  digit_t msd = X[last];\n  if (bits != 0) {\n    int drop = kDigitBits - bits;\n    msd = (msd << drop) >> drop;\n  }\n  Z[last] = msd;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"TruncateAndSubFromPowerOfTwo\",\n                \"parent\": null,\n                \"about\": \"Truncates a BigInt to a specified number of bits and subtracts the result from 2**n.\",\n                \"logic\": \"Calculates 2**n - (least significant n bits of X).  Simulates leading zeroes when the number of digits in X is less than the number needed to represent n bits.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"Z\",\n                        \"type\": \"RWDigits\",\n                        \"purpose\": \"The destination for the result (read/write digits).\"\n                    },\n                    {\n                        \"name\": \"X\",\n                        \"type\": \"Digits\",\n                        \"purpose\": \"The BigInt to truncate and subtract (read-only digits).\"\n                    },\n                    {\n                        \"name\": \"n\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The number of bits to consider.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"digit_sub\",\n                    \"digit_sub2\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// Z := 2**n - (least significant n bits of X).\nvoid TruncateAndSubFromPowerOfTwo(RWDigits Z, Digits X, int n) {\n  int digits = DIV_CEIL(n, kDigitBits);\n  int bits = n % kDigitBits;\n  // Process all digits except the MSD. Take X's digits, then simulate leading\n  // zeroes.\n  int last = digits - 1;\n  int have_x = std::min(last, X.len());\n  digit_t borrow = 0;\n  int i = 0;\n  for (; i < have_x; i++) Z[i] = digit_sub2(0, X[i], borrow, &borrow);\n  for (; i < last; i++) Z[i] = digit_sub(0, borrow, &borrow);\n\n  // The MSD might contain extra bits that we don't want.\n  digit_t msd = last < X.len() ? X[last] : 0;\n  if (bits == 0) {\n    Z[last] = digit_sub2(0, msd, borrow, &borrow);\n  } else {\n    int drop = kDigitBits - bits;\n    msd = (msd << drop) >> drop;\n    digit_t minuend_msd = static_cast<digit_t>(1) << bits;\n    digit_t result_msd = digit_sub2(minuend_msd, msd, borrow, &borrow);\n    DCHECK(borrow == 0);  // result < 2^n.\n    // If all subtracted bits were zero, we have to get rid of the\n    // materialized minuend_msd again.\n    Z[last] = result_msd & (minuend_msd - 1);\n  }\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"AsIntNResultLength\",\n                \""
}