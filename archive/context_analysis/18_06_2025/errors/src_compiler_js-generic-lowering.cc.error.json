{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-generic-lowering.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-generic-lowering.cc\",\n        \"file_name\": \"js-generic-lowering.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Lowers JavaScript operations to generic builtin calls in the compiler's intermediate representation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for compiler, AST, builtins, code generation, and other utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/js-generic-lowering.h\"\n\n            #include \"src/ast/ast.h\"\n            #include \"src/builtins/builtins-constructor.h\"\n            #include \"src/codegen/code-factory.h\"\n            #include \"src/codegen/interface-descriptors-inl.h\"\n            #include \"src/compiler/access-builder.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/js-graph.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/machine-operator.h\"\n            #include \"src/compiler/node-properties.h\"\n            #include \"src/compiler/operator-properties.h\"\n            #include \"src/compiler/processed-feedback.h\"\n            #include \"src/compiler/simplified-operator.h\"\n            #include \"src/objects/scope-info.h\"\n            #include \"src/objects/template-objects-inl.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FrameStateFlagForCall\",\n            \"about\": \"Determines the CallDescriptor::Flags based on whether the node has a FrameState input.\",\n            \"logic\": \"Checks if the operator of the given node has a FrameState input using OperatorProperties::HasFrameStateInput. Returns CallDescriptor::kNeedsFrameState if it does, otherwise returns CallDescriptor::kNoFlags.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to check for FrameState input.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CallDescriptor::Flags\",\n                \"description\": \"CallDescriptor flags indicating whether a frame state is needed.\"\n            },\n            \"dependencies\": [\n                \"OperatorProperties\",\n                \"CallDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n\n            CallDescriptor::Flags FrameStateFlagForCall(Node* node) {\n              return OperatorProperties::HasFrameStateInput(node->op())\n                         ? CallDescriptor::kNeedsFrameState\n                         : CallDescriptor::kNoFlags;\n            }\n\n            }  // namespace\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JSGenericLowering\",\n            \"about\": \"Reduces JavaScript operations to builtin calls or runtime calls.\",\n            \"attributes\": [\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the JavaScript graph.\"\n                },\n                {\n                    \"name\": \"broker_\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides access to the JS heap broker.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AdvancedReducer\",\n                \"JSGraph\",\n                \"JSHeapBroker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class JSGenericLowering : public AdvancedReducer {\n            public:\n                JSGenericLowering(JSGraph* jsgraph, Editor* editor,\n                                             JSHeapBroker* broker);\n                ~JSGenericLowering() override = default;\n\n\n                Reduction Reduce(Node* node) override;\n\n            private:\n                void ReplaceWithBuiltinCall(Node* node, Builtin builtin);\n                void ReplaceWithBuiltinCall(Node* node, Callable callable,\n                                                       CallDescriptor::Flags flags);\n                void ReplaceWithBuiltinCall(\n                    Node* node, Callable callable, CallDescriptor::Flags flags,\n                    Operator::Properties properties);\n                void ReplaceWithRuntimeCall(Node* node,\n                                                       Runtime::FunctionId f,\n                                                       int nargs_override);\n                void ReplaceUnaryOpWithBuiltinCall(\n                    Node* node, Builtin builtin_without_feedback,\n                    Builtin builtin_with_feedback);\n                void ReplaceBinaryOpWithBuiltinCall(\n                    Node* node, Builtin builtin_without_feedback,\n                    Builtin builtin_with_feedback);\n\n                Zone* zone() const;\n                Isolate* isolate() const;\n                TFGraph* graph() const;\n                CommonOperatorBuilder* common() const;\n                MachineOperatorBuilder* machine() const;\n\n            #define DECLARE_LOWERING_FUNCTION(Name) void LowerJS##Name(Node* node);\n                JS_OP_LIST(DECLARE_LOWERING_FUNCTION)\n            #undef DECLARE_LOWERING_FUNCTION\n\n                JSGraph* jsgraph_;\n                JSHeapBroker* broker_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JSGenericLowering\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Constructor for JSGenericLowering.\",\n            \"logic\": \"Initializes the JSGenericLowering reducer with the given JSGraph and Editor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"jsgraph\",\n                    \"type\": \"JSGraph*\",\n                    \"purpose\": \"The JavaScript graph.\"\n                },\n                {\n                    \"name\": \"editor\",\n                    \"type\": \"Editor*\",\n                    \"purpose\": \"The graph editor.\"\n                },\n                {\n                    \"name\": \"broker\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"purpose\": \"The JSHeapBroker to use for heap access.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"AdvancedReducer\",\n                \"JSGraph\",\n                \"Editor\",\n                \"JSHeapBroker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            JSGenericLowering::JSGenericLowering(JSGraph* jsgraph, Editor* editor,\n                                                 JSHeapBroker* broker)\n                : AdvancedReducer(editor), jsgraph_(jsgraph), broker_(broker) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Reduces a given node by replacing it with a builtin or runtime call.\",\n            \"logic\": \"Switches on the opcode of the node and calls the corresponding LowerJS... method. Returns NoChange if the opcode is not handled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether the node was changed.\"\n            },\n            \"dependencies\": [\n                \"IrOpcode\",\n                \"JS_OP_LIST\",\n                \"LowerJSToLength\",\n                \"LowerJSBitwiseNot\",\n                \"LowerJSDecrement\",\n                \"LowerJSIncrement\",\n                \"LowerJSNegate\",\n                \"NoChange\",\n                \"Changed\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Reduction JSGenericLowering::Reduce(Node* node) {\n              switch (node->opcode()) {\n            #define DECLARE_CASE(x, ...) \\\n              case IrOpcode::k##x:       \\\n                LowerJS##x(node);          \\\n                break;\n                JS_OP_LIST(DECLARE_CASE)\n            #undef DECLARE_CASE\n                default:\n                  // Nothing to see.\n                  return NoChange();\n              }\n              return Changed(node);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReplaceWithBuiltinCall\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Replaces a node with a call to a builtin function.\",\n            \"logic\": \"Determines call flags based on the node, gets the Callable for the builtin, and calls the overloaded ReplaceWithBuiltinCall method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace.\"\n                },\n                {\n                    \"name\": \"builtin\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin to call.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FrameStateFlagForCall\",\n                \"Builtins\",\n                \"isolate\",\n                \"ReplaceWithBuiltinCall\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::ReplaceWithBuiltinCall(Node* node, Builtin builtin) {\n              CallDescriptor::Flags flags = FrameStateFlagForCall(node);\n              Callable callable = Builtins::CallableFor(isolate(), builtin);\n              ReplaceWithBuiltinCall(node, callable, flags);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReplaceWithBuiltinCall\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Replaces a node with a call to a builtin function, specifying flags.\",\n            \"logic\": \"Gets the CallInterfaceDescriptor, then gets the stub call descriptor using Linkage::GetStubCallDescriptor, then inserts the stub code as the first input to the node, and finally changes the node's operator to a common Call operator with the new call descriptor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace.\"\n                },\n                {\n                    \"name\": \"callable\",\n                    \"type\": \"Callable\",\n                    \"purpose\": \"The callable to call.\"\n                },\n                {\n                    \"name\": \"flags\",\n                    \"type\": \"CallDescriptor::Flags\",\n                    \"purpose\": \"Flags to use for the call descriptor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Callable\",\n                \"Linkage\",\n                \"zone\",\n                \"jsgraph\",\n                \"HeapConstantNoHole\",\n                \"common\",\n                \"Call\",\n                \"NodeProperties\",\n                \"CallInterfaceDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::ReplaceWithBuiltinCall(Node* node, Callable callable,\n                                                           CallDescriptor::Flags flags) {\n              ReplaceWithBuiltinCall(node, callable, flags, node->op()->properties());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReplaceWithBuiltinCall\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Replaces a node with a call to a builtin function, specifying flags and operator properties.\",\n            \"logic\": \"Gets the CallInterfaceDescriptor, then gets the stub call descriptor using Linkage::GetStubCallDescriptor, then inserts the stub code as the first input to the node, and finally changes the node's operator to a common Call operator with the new call descriptor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace.\"\n                },\n                {\n                    \"name\": \"callable\",\n                    \"type\": \"Callable\",\n                    \"purpose\": \"The callable to call.\"\n                },\n                {\n                    \"name\": \"flags\",\n                    \"type\": \"CallDescriptor::Flags\",\n                    \"purpose\": \"Flags to use for the call descriptor.\"\n                },\n                {\n                    \"name\": \"properties\",\n                    \"type\": \"Operator::Properties\",\n                    \"purpose\": \"Operator properties to apply to the call.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Callable\",\n                \"Linkage\",\n                \"zone\",\n                \"jsgraph\",\n                \"HeapConstantNoHole\",\n                \"common\",\n                \"Call\",\n                \"NodeProperties\",\n                \"CallInterfaceDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::ReplaceWithBuiltinCall(\n                Node* node, Callable callable, CallDescriptor::Flags flags,\n                Operator::Properties properties) {\n              const CallInterfaceDescriptor& descriptor = callable.descriptor();\n              auto call_descriptor = Linkage::GetStubCallDescriptor(\n                  zone(), descriptor, descriptor.GetStackParameterCount(), flags,\n                  properties);\n              Node* stub_code = jsgraph()->HeapConstantNoHole(callable.code());\n              node->InsertInput(zone(), 0, stub_code);\n              NodeProperties::ChangeOp(node, common()->Call(call_descriptor));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReplaceWithRuntimeCall\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Replaces a node with a call to a runtime function.\",\n            \"logic\": \"Gets the runtime function descriptor using Linkage::GetRuntimeCallDescriptor, then inserts the CEntryStubConstant, ExternalReference, and arity as inputs to the node, and finally changes the node's operator to a common Call operator with the new call descriptor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace.\"\n                },\n                {\n                    \"name\": \"f\",\n                    \"type\": \"Runtime::FunctionId\",\n                    \"purpose\": \"The ID of the runtime function to call.\"\n                },\n                {\n                    \"name\": \"nargs_override\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Override for the number of arguments, or -1 to use the runtime function's default.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Linkage\",\n                \"zone\",\n                \"Runtime\",\n                \"ExternalReference\",\n                \"jsgraph\",\n                \"CEntryStubConstant\",\n                \"Int32Constant\",\n                \"common\",\n                \"Call\",\n                \"NodeProperties\",\n                \"ExternalReference::Create\",\n                \"Runtime::FunctionForId\",\n                \"GetRuntimeCallDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::ReplaceWithRuntimeCall(Node* node,\n                                                           Runtime::FunctionId f,\n                                                           int nargs_override) {\n              CallDescriptor::Flags flags = FrameStateFlagForCall(node);\n              Operator::Properties properties = node->op()->properties();\n              const Runtime::Function* fun = Runtime::FunctionForId(f);\n              int nargs = (nargs_override < 0) ? fun->nargs : nargs_override;\n              auto call_descriptor =\n                  Linkage::GetRuntimeCallDescriptor(zone(), f, nargs, properties, flags);\n              Node* ref = jsgraph()->ExternalConstant(ExternalReference::Create(f));\n              Node* arity = jsgraph()->Int32Constant(nargs);\n              node->InsertInput(zone(), 0, jsgraph()->CEntryStubConstant(fun->result_size));\n              node->InsertInput(zone(), nargs + 1, ref);\n              node->InsertInput(zone(), nargs + 2, arity);\n              NodeProperties::ChangeOp(node, common()->Call(call_descriptor));\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReplaceUnaryOpWithBuiltinCall\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Replaces a unary operation node with a builtin call, handling feedback.\",\n            \"logic\": \"Checks if feedback collection is enabled and if the feedback is valid. If so, inserts the feedback slot as an input. Otherwise, removes the feedback vector input.  Finally, calls ReplaceWithBuiltinCall to perform the replacement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace.\"\n                },\n                {\n                    \"name\": \"builtin_without_feedback\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin to call if no feedback is available.\"\n                },\n                {\n                    \"name\": \"builtin_with_feedback\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin to call if feedback is available.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"JSOperator\",\n                \"FeedbackParameterOf\",\n                \"CollectFeedbackInGenericLowering\",\n                \"FeedbackParameter\",\n                \"Builtins\",\n                \"isolate\",\n                \"jsgraph\",\n                \"UintPtrConstant\",\n                \"HeapConstantNoHole\",\n                \"common\",\n                \"Call\",\n                \"NodeProperties\",\n                \"ReplaceWithBuiltinCall\",\n                \"CallDescriptor\",\n                \"Linkage\",\n                \"CallInterfaceDescriptor\",\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::ReplaceUnaryOpWithBuiltinCall(\n                Node* node, Builtin builtin_without_feedback,\n                Builtin builtin_with_feedback) {\n              DCHECK(JSOperator::IsUnaryWithFeedback(node->opcode()));\n              const FeedbackParameter& p = FeedbackParameterOf(node->op());\n              if (CollectFeedbackInGenericLowering() && p.feedback().IsValid()) {\n                Callable callable = Builtins::CallableFor(isolate(), builtin_with_feedback);\n                Node* slot = jsgraph()->UintPtrConstant(p.feedback().slot.ToInt());\n                const CallInterfaceDescriptor& descriptor = callable.descriptor();\n                CallDescriptor::Flags flags = FrameStateFlagForCall(node);\n                auto call_descriptor = Linkage::GetStubCallDescriptor(\n                    zone(), descriptor, descriptor.GetStackParameterCount(), flags,\n                    node->op()->properties());\n                Node* stub_code = jsgraph()->HeapConstantNoHole(callable.code());\n                static_assert(JSUnaryOpNode::ValueIndex() == 0);\n                static_assert(JSUnaryOpNode::FeedbackVectorIndex() == 1);\n                DCHECK_EQ(node->op()->ValueInputCount(), 2);\n                node->InsertInput(zone(), 0, stub_code);\n                node->InsertInput(zone(), 2, slot);\n                NodeProperties::ChangeOp(node, common()->Call(call_descriptor));\n              } else {\n                node->RemoveInput(JSUnaryOpNode::FeedbackVectorIndex());\n                ReplaceWithBuiltinCall(node, builtin_without_feedback);\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReplaceBinaryOpWithBuiltinCall\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Replaces a binary operation node with a builtin call, handling feedback.\",\n            \"logic\": \"Checks if feedback collection is enabled and if the feedback is valid. If so, inserts the feedback slot as an input. Otherwise, removes the feedback vector input. Finally, calls ReplaceWithBuiltinCall to perform the replacement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace.\"\n                },\n                {\n                    \"name\": \"builtin_without_feedback\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin to call if no feedback is available.\"\n                },\n                {\n                    \"name\": \"builtin_with_feedback\",\n                    \"type\": \"Builtin\",\n                    \"purpose\": \"The builtin to call if feedback is available.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"JSOperator\",\n                \"FeedbackParameterOf\",\n                \"CollectFeedbackInGenericLowering\",\n                \"FeedbackParameter\",\n                \"Builtins\",\n                \"isolate\",\n                \"jsgraph\",\n                \"UintPtrConstant\",\n                \"common\",\n                \"Call\",\n                \"NodeProperties\",\n                \"ReplaceWithBuiltinCall\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::ReplaceBinaryOpWithBuiltinCall(\n                Node* node, Builtin builtin_without_feedback,\n                Builtin builtin_with_feedback) {\n              DCHECK(JSOperator::IsBinaryWithFeedback(node->opcode()));\n              Builtin builtin;\n              const FeedbackParameter& p = FeedbackParameterOf(node->op());\n              if (CollectFeedbackInGenericLowering() && p.feedback().IsValid()) {\n                Node* slot = jsgraph()->UintPtrConstant(p.feedback().slot.ToInt());\n                static_assert(JSBinaryOpNode::LeftIndex() == 0);\n                static_assert(JSBinaryOpNode::RightIndex() == 1);\n                static_assert(JSBinaryOpNode::FeedbackVectorIndex() == 2);\n                DCHECK_EQ(node->op()->ValueInputCount(), 3);\n                node->InsertInput(zone(), 2, slot);\n                builtin = builtin_with_feedback;\n              } else {\n                node->RemoveInput(JSBinaryOpNode::FeedbackVectorIndex());\n                builtin = builtin_without_feedback;\n              }\n\n              ReplaceWithBuiltinCall(node, builtin);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LowerJSStrictEqual\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Lowers a JSStrictEqual node by replacing it with a builtin call.\",\n            \"logic\": \"Removes the context and control inputs, and inserts the feedback slot if feedback collection is enabled and the feedback is valid. Then calls ReplaceWithBuiltinCall with appropriate Builtin.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to lower.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"jsgraph\",\n                \"FeedbackParameterOf\",\n                \"CollectFeedbackInGenericLowering\",\n                \"ReplaceWithBuiltinCall\",\n                \"Builtins\",\n                \"isolate\",\n                \"UintPtrConstant\",\n                \"CallDescriptor\",\n                \"Operator\",\n                \"Callable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::LowerJSStrictEqual(Node* node) {\n              // The === operator doesn't need the current context.\n              NodeProperties::ReplaceContextInput(node, jsgraph()->NoContextConstant());\n              DCHECK_EQ(node->op()->ControlInputCount(), 1);\n              node->RemoveInput(NodeProperties::FirstControlIndex(node));\n\n              Builtin builtin;\n              const FeedbackParameter& p = FeedbackParameterOf(node->op());\n              if (CollectFeedbackInGenericLowering() && p.feedback().IsValid()) {\n                Node* slot = jsgraph()->UintPtrConstant(p.feedback().slot.ToInt());\n                static_assert(JSStrictEqualNode::LeftIndex() == 0);\n                static_assert(JSStrictEqualNode::RightIndex() == 1);\n                static_assert(JSStrictEqualNode::FeedbackVectorIndex() == 2);\n                DCHECK_EQ(node->op()->ValueInputCount(), 3);\n                node->InsertInput(zone(), 2, slot);\n                builtin = Builtin::kStrictEqual_WithFeedback;\n              } else {\n                node->RemoveInput(JSStrictEqualNode::FeedbackVectorIndex());\n                builtin = Builtin::kStrictEqual;\n              }\n\n              Callable callable = Builtins::CallableFor(isolate(), builtin);\n              ReplaceWithBuiltinCall(node, callable, CallDescriptor::kNoFlags,\n                                     Operator::kEliminatable);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ShouldUseMegamorphicAccessBuiltin\",\n            \"about\": \"Determines whether the megamorphic load/store builtin should be used for a property access.\",\n            \"logic\": \"Checks if the feedback for the property access indicates megamorphic access patterns (empty transition groups for element access, or empty maps for named access).\",\n            \"parameters\": [\n                {\n                    \"name\": \"source\",\n                    \"type\": \"FeedbackSource const&\",\n                    \"purpose\": \"The feedback source for the property access.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"OptionalNameRef\",\n                    \"purpose\": \"The name of the property being accessed (if named access).\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"AccessMode\",\n                    \"purpose\": \"The access mode (kLoad or kStore).\"\n                },\n                {\n                    \"name\": \"broker\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"purpose\": \"The JSHeapBroker to use for feedback retrieval.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the megamorphic builtin should be used, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ProcessedFeedback\",\n                \"JSHeapBroker\",\n                \"ProcessedFeedback::kElementAccess\",\n                \"ProcessedFeedback::kNamedAccess\",\n                \"ProcessedFeedback::kInsufficient\",\n                \"ProcessedFeedback::AsElementAccess\",\n                \"ProcessedFeedback::AsNamedAccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n\n            // The megamorphic load/store builtin can be used as a performance optimization\n            // in some cases - unlike the full builtin, the megamorphic builtin does fewer\n            // checks and does not collect feedback.\n            bool ShouldUseMegamorphicAccessBuiltin(FeedbackSource const& source,\n                                                   OptionalNameRef name, AccessMode mode,\n                                                   JSHeapBroker* broker) {\n              ProcessedFeedback const& feedback =\n                  broker->GetFeedbackForPropertyAccess(source, mode, name);\n\n              if (feedback.kind() == ProcessedFeedback::kElementAccess) {\n                return feedback.AsElementAccess().transition_groups().empty();\n              } else if (feedback.kind() == ProcessedFeedback::kNamedAccess) {\n                return feedback.AsNamedAccess().maps().empty();\n              } else if (feedback.kind() == ProcessedFeedback::kInsufficient) {\n                return false;\n              }\n              UNREACHABLE();\n            }\n\n            }  // namespace\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LowerJSHasProperty\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Lowers a JSHasProperty node by replacing it with a builtin call.\",\n            \"logic\": \"If no feedback is provided, it replaces the node with a call to the kHasProperty builtin. Otherwise, it uses the kKeyedHasIC builtin and inserts the feedback index as input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to lower.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"JSHasPropertyNode\",\n                \"PropertyAccess\",\n                \"Builtin\",\n                \"jsgraph\",\n                \"TaggedIndexConstant\",\n                \"ReplaceWithBuiltinCall\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::LowerJSHasProperty(Node* node) {\n              JSHasPropertyNode n(node);\n              const PropertyAccess& p = n.Parameters();\n              if (!p.feedback().IsValid()) {\n                node->RemoveInput(JSHasPropertyNode::FeedbackVectorIndex());\n                ReplaceWithBuiltinCall(node, Builtin::kHasProperty);\n              } else {\n                static_assert(n.FeedbackVectorIndex() == 2);\n                n->InsertInput(zone(), 2,\n                               jsgraph()->TaggedIndexConstant(p.feedback().index()));\n                ReplaceWithBuiltinCall(node, Builtin::kKeyedHasIC);\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LowerJSLoadProperty\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Lowers a JSLoadProperty node by replacing it with a builtin call.\",\n            \"logic\": \"Depending on whether an outer frame state exists, the appropriate KeyedLoadIC builtin (trampoline or non-trampoline version) is selected. Additionally the megamorphic optimization version may be selected based on feedback from the broker.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to lower.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"JSLoadPropertyNode\",\n                \"PropertyAccess\",\n                \"FrameState\",\n                \"IrOpcode\",\n                \"Builtin\",\n                \"jsgraph\",\n                \"TaggedIndexConstant\",\n                \"ReplaceWithBuiltinCall\",\n                \"ShouldUseMegamorphicAccessBuiltin\",\n                \"AccessMode::kLoad\",\n                \"broker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::LowerJSLoadProperty(Node* node) {\n              JSLoadPropertyNode n(node);\n              const PropertyAccess& p = n.Parameters();\n              FrameState frame_state = n.frame_state();\n              Node* outer_state = frame_state.outer_frame_state();\n              static_assert(n.FeedbackVectorIndex() == 2);\n              if (outer_state->opcode() != IrOpcode::kFrameState) {\n                n->RemoveInput(n.FeedbackVectorIndex());\n                n->InsertInput(zone(), 2,\n                               jsgraph()->TaggedIndexConstant(p.feedback().index()));\n                ReplaceWithBuiltinCall(\n                    node, ShouldUseMegamorphicAccessBuiltin(p.feedback(), {},\n                                                            AccessMode::kLoad, broker())\n                              ? Builtin::kKeyedLoadICTrampoline_Megamorphic\n                              : Builtin::kKeyedLoadICTrampoline);\n              } else {\n                n->InsertInput(zone(), 2,\n                               jsgraph()->TaggedIndexConstant(p.feedback().index()));\n                ReplaceWithBuiltinCall(\n                    node, ShouldUseMegamorphicAccessBuiltin(p.feedback(), {},\n                                                            AccessMode::kLoad, broker())\n                              ? Builtin::kKeyedLoadIC_Megamorphic\n                              : Builtin::kKeyedLoadIC);\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LowerJSLoadNamed\",\n            \"parent\": \"JSGenericLowering\",\n            \"about\": \"Lowers a JSLoadNamed node by replacing it with a builtin call.\",\n            \"logic\": \"Depending on the availability of feedback, outer frame state, and whether the megamorphic access builtin should be used, the appropriate builtin is called.  If there's no feedback the GetProperty builtin is called, else depending on outer frame state KeyedLoadICTrampoline or KeyedLoadIC is called, with megamorphic optimizations if `ShouldUseMegamorphicAccessBuiltin` returns true.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to lower.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"JSLoadNamedNode\",\n                \"NamedAccess\",\n                \"FrameState\",\n                \"IrOpcode\",\n                \"Builtin\",\n                \"jsgraph\",\n                \"TaggedIndexConstant\",\n                \"ReplaceWithBuiltinCall\",\n                \"ShouldUseMegamorphicAccessBuiltin\",\n                \"ConstantNoHole\",\n                \"GetProperty\",\n                \"KeyedLoadICTrampoline\",\n                \"KeyedLoadIC\",\n                \"AccessMode::kLoad\",\n                \"broker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void JSGenericLowering::LowerJSLoadNamed(Node* node) {\n              JSLoadNamedNode n(node);\n              NamedAccess const& p = n.Parameters();\n              FrameState frame_state = n.frame_state();\n              Node* outer_state = frame_state.outer_frame_state();\n              "
}