{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/platform-embedded-file-writer-base.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 384, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/platform-embedded-file-writer-base.cc\",\n            \"file_name\": \"platform-embedded-file-writer-base.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides a base class and factory function for creating platform-specific embedded file writers used for generating snapshot files.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for string manipulation, standard library functions, and platform-specific embedded file writer implementations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/embedded/platform-embedded-file-writer-base.h\"\n\n#include <string>\n\n#include \"src/common/globals.h\"\n#include \"src/snapshot/embedded/platform-embedded-file-writer-aix.h\"\n#include \"src/snapshot/embedded/platform-embedded-file-writer-generic.h\"\n#include \"src/snapshot/embedded/platform-embedded-file-writer-mac.h\"\n#include \"src/snapshot/embedded/platform-embedded-file-writer-win.h\"\n#include \"src/snapshot/embedded/platform-embedded-file-writer-zos.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"PointerSizeDirective\",\n                \"parent\": null,\n                \"about\": \"Determines the appropriate data directive (kQuad or kLong) based on the system's pointer size.\",\n                \"logic\": \"Checks the value of kSystemPointerSize. If it's 8, returns kQuad. Otherwise, checks if it's 4 and returns kLong.  Asserts that kSystemPointerSize is either 4 or 8.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"DataDirective\",\n                    \"description\": \"The appropriate data directive based on pointer size.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nDataDirective PointerSizeDirective() {\n  if (kSystemPointerSize == 8) {\n    return kQuad;\n  } else {\n    CHECK_EQ(4, kSystemPointerSize);\n    return kLong;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"HexLiteral\",\n                \"parent\": \"PlatformEmbeddedFileWriterBase\",\n                \"about\": \"Writes a 64-bit unsigned integer as a hexadecimal literal to the file.\",\n                \"logic\": \"Uses fprintf to format the given 64-bit value as a hexadecimal string.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"The value to be written as a hexadecimal literal.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The number of characters written to the file.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nint PlatformEmbeddedFileWriterBase::HexLiteral(uint64_t value) {\n  return fprintf(fp_, \"0x%\" PRIx64, value);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DataDirectiveSize\",\n                \"parent\": null,\n                \"about\": \"Returns the size in bytes associated with a given DataDirective.\",\n                \"logic\": \"Uses a switch statement to determine the size based on the DataDirective value.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"directive\",\n                        \"type\": \"DataDirective\",\n                        \"purpose\": \"The DataDirective to determine the size of.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The size in bytes of the DataDirective.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nint DataDirectiveSize(DataDirective directive) {\n  switch (directive) {\n    case kByte:\n      return 1;\n    case kLong:\n      return 4;\n    case kQuad:\n      return 8;\n    case kOcta:\n      return 16;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"WriteByteChunk\",\n                \"parent\": \"PlatformEmbeddedFileWriterBase\",\n                \"about\": \"Writes a chunk of bytes as a hexadecimal literal to the file, handling different data sizes and endianness.\",\n                \"logic\": \"Determines the size of the byte chunk based on ByteChunkDataDirective().  Reads the data into uint64_t or two uint64_t variables (high, low) depending on the size. Handles big-endian/little-endian byte order when kSize is 16. Finally, prints the value (or high and low parts) as a hexadecimal literal using fprintf.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"data\",\n                        \"type\": \"const uint8_t*\",\n                        \"purpose\": \"Pointer to the byte data to be written.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The number of characters written to the file.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nint PlatformEmbeddedFileWriterBase::WriteByteChunk(const uint8_t* data) {\n  size_t kSize = DataDirectiveSize(ByteChunkDataDirective());\n  size_t kHalfSize = kSize / 2;\n  uint64_t high = 0, low = 0;\n\n  switch (kSize) {\n    case 1:\n      low = *data;\n      break;\n    case 4:\n      low = *reinterpret_cast<const uint32_t*>(data);\n      break;\n    case 8:\n      low = *reinterpret_cast<const uint64_t*>(data);\n      break;\n    case 16:\n#ifdef V8_TARGET_BIG_ENDIAN\n      memcpy(&high, data, kHalfSize);\n      memcpy(&low, data + kHalfSize, kHalfSize);\n#else\n      memcpy(&high, data + kHalfSize, kHalfSize);\n      memcpy(&low, data, kHalfSize);\n#endif  // V8_TARGET_BIG_ENDIAN\n      break;\n    default:\n      UNREACHABLE();\n  }\n\n  if (high != 0) {\n    return fprintf(fp(), \"0x%\" PRIx64 \"%016\" PRIx64, high, low);\n  } else {\n    return fprintf(fp(), \"0x%\" PRIx64, low);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DefaultEmbeddedTargetArch\",\n                \"parent\": null,\n                \"about\": \"Returns the default EmbeddedTargetArch based on preprocessor defines.\",\n                \"logic\": \"Uses preprocessor directives (V8_TARGET_ARCH_*) to determine the target architecture.  If none of the specific architecture macros are defined, it returns kGeneric.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"EmbeddedTargetArch\",\n                    \"description\": \"The default embedded target architecture.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nEmbeddedTargetArch DefaultEmbeddedTargetArch() {\n#if defined(V8_TARGET_ARCH_ARM)\n  return EmbeddedTargetArch::kArm;\n#elif defined(V8_TARGET_ARCH_ARM64)\n  return EmbeddedTargetArch::kArm64;\n#elif defined(V8_TARGET_ARCH_IA32)\n  return EmbeddedTargetArch::kIA32;\n#elif defined(V8_TARGET_ARCH_X64)\n  return EmbeddedTargetArch::kX64;\n#else\n  return EmbeddedTargetArch::kGeneric;\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ToEmbeddedTargetArch\",\n                \"parent\": null,\n                \"about\": \"Converts a string representation to an EmbeddedTargetArch enum value.\",\n                \"logic\": \"Takes a C-style string as input. If the string is null, it returns the DefaultEmbeddedTargetArch(). Otherwise, it creates a std::string from the C-style string and compares it to known architecture names (arm, arm64, ia32, x64). If a match is found, it returns the corresponding EmbeddedTargetArch enum value. Otherwise, it returns kGeneric.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"s\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"String representation of the target architecture.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"EmbeddedTargetArch\",\n                    \"description\": \"The corresponding EmbeddedTargetArch enum value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nEmbeddedTargetArch ToEmbeddedTargetArch(const char* s) {\n  if (s == nullptr) {\n    return DefaultEmbeddedTargetArch();\n  }\n\n  std::string string(s);\n  if (string == \"arm\") {\n    return EmbeddedTargetArch::kArm;\n  } else if (string == \"arm64\") {\n    return EmbeddedTargetArch::kArm64;\n  } else if (string == \"ia32\") {\n    return EmbeddedTargetArch::kIA32;\n  } else if (string == \"x64\") {\n    return EmbeddedTargetArch::kX64;\n  } else {\n    return EmbeddedTargetArch::kGeneric;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DefaultEmbeddedTargetOs\",\n                \"parent\": null,\n                \"about\": \"Returns the default EmbeddedTargetOs based on preprocessor defines.\",\n                \"logic\": \"Uses preprocessor directives (V8_OS_*) to determine the target operating system. If none of the specific OS macros are defined, it returns kGeneric.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"EmbeddedTargetOs\",\n                    \"description\": \"The default embedded target operating system.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nEmbeddedTargetOs DefaultEmbeddedTargetOs() {\n#if defined(V8_OS_AIX)\n  return EmbeddedTargetOs::kAIX;\n#elif defined(V8_OS_DARWIN)\n  return EmbeddedTargetOs::kMac;\n#elif defined(V8_OS_WIN)\n  return EmbeddedTargetOs::kWin;\n#elif defined(V8_OS_ZOS)\n  return EmbeddedTargetOs::kZOS;\n#else\n  return EmbeddedTargetOs::kGeneric;\n#endif\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ToEmbeddedTargetOs\",\n                \"parent\": null,\n                \"about\": \"Converts a string representation to an EmbeddedTargetOs enum value.\",\n                \"logic\": \"Takes a C-style string as input. If the string is null, it returns the DefaultEmbeddedTargetOs(). Otherwise, it creates a std::string from the C-style string and compares it to known operating system names (aix, chromeos, fuchsia, ios, mac, win, starboard, zos).  It also handles the 'os400' alias for 'aix'. If a match is found, it returns the corresponding EmbeddedTargetOs enum value. Otherwise, it returns kGeneric.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"s\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"String representation of the target operating system.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"EmbeddedTargetOs\",\n                    \"description\": \"The corresponding EmbeddedTargetOs enum value.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nEmbeddedTargetOs ToEmbeddedTargetOs(const char* s) {\n  if (s == nullptr) {\n    return DefaultEmbeddedTargetOs();\n  }\n\n  std::string string(s);\n  // Python 3.9+ on IBM i returns os400 as sys.platform instead of aix\n  if (string == \"aix\" || string == \"os400\") {\n    return EmbeddedTargetOs::kAIX;\n  } else if (string == \"chromeos\") {\n    return EmbeddedTargetOs::kChromeOS;\n  } else if (string == \"fuchsia\") {\n    return EmbeddedTargetOs::kFuchsia;\n  } else if (string == \"ios\" || string == \"mac\") {\n    return EmbeddedTargetOs::kMac;\n  } else if (string == \"win\") {\n    return EmbeddedTargetOs::kWin;\n  } else if (string == \"starboard\") {\n    return EmbeddedTargetOs::kStarboard;\n  } else if (string == \"zos\") {\n    return EmbeddedTargetOs::kZOS;\n  } else {\n    return EmbeddedTargetOs::kGeneric;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"NewPlatformEmbeddedFileWriter\",\n                \"parent\": null,\n                \"about\": \"Factory function to create a platform-specific PlatformEmbeddedFileWriterBase instance.\",\n                \"logic\": \"Converts the input target_arch and target_os strings into EmbeddedTargetArch and EmbeddedTargetOs enum values respectively, using the helper functions ToEmbeddedTargetArch and ToEmbeddedTargetOs. Handles a special case for the 'starboard' OS. Creates an instance of PlatformEmbeddedFileWriterAIX, PlatformEmbeddedFileWriterMac, PlatformEmbeddedFileWriterWin, PlatformEmbeddedFileWriterZOS or PlatformEmbeddedFileWriterGeneric depending on the identified OS. Returns a unique_ptr to the created PlatformEmbeddedFileWriterBase instance.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"target_arch\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"String representation of the target architecture.\"\n                    },\n                    {\n                        \"name\": \"target_os\",\n                        \"type\": \"const char*\",\n                        \"purpose\": \"String representation of the target operating system.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::unique_ptr<PlatformEmbeddedFileWriterBase>\",\n                    \"description\": \"A unique pointer to the created PlatformEmbeddedFileWriterBase instance.\"\n                },\n                \"dependencies\": [\n                    \"ToEmbeddedTargetArch\",\n                    \"ToEmbeddedTargetOs\",\n                    \"PlatformEmbeddedFileWriterAIX\",\n                    \"PlatformEmbeddedFileWriterMac\",\n                    \"PlatformEmbeddedFileWriterWin\",\n                    \"PlatformEmbeddedFileWriterZOS\",\n                    \"PlatformEmbeddedFileWriterGeneric\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<PlatformEmbeddedFileWriterBase> NewPlatformEmbeddedFileWriter(\n    const char* target_arch, const char* target_os) {\n  auto embedded_target_arch = ToEmbeddedTargetArch(target_arch);\n  auto embedded_target_os = ToEmbeddedTargetOs(target_os);\n\n  if (embedded_target_os == EmbeddedTargetOs::kStarboard) {\n    // target OS is \"Starboard\" for all starboard build so we need to\n    // use host OS macros to decide which writer to use.\n    // Cobalt also has Windows-based Posix target platform,\n    // in which case generic writer should be used.\n    switch (DefaultEmbeddedTargetOs()) {\n      case EmbeddedTargetOs::kMac:\n#if defined(V8_TARGET_OS_WIN)\n      case EmbeddedTargetOs::kWin:\n        // V8_TARGET_OS_WIN is used to enable WINDOWS-specific assembly code,\n        // for windows-hosted non-windows targets, we should still fallback to\n        // the generic writer.\n#endif\n        embedded_target_os = DefaultEmbeddedTargetOs();\n        break;\n      default:\n        // In the block below, we will use WriterGeneric for other cases.\n        break;\n    }\n  }\n\n  if (embedded_target_os == EmbeddedTargetOs::kAIX) {\n    return std::make_unique<PlatformEmbeddedFileWriterAIX>(embedded_target_arch,\n                                                           embedded_target_os);\n  } else if (embedded_target_os == EmbeddedTargetOs::kMac) {\n    return std::make_unique<PlatformEmbeddedFileWriterMac>(embedded_target_arch,\n                                                           embedded_target_os);\n  } else if (embedded_target_os == EmbeddedTargetOs::kWin) {\n    return std::make_unique<PlatformEmbeddedFileWriterWin>(embedded_target_arch,\n                                                           embedded_target_os);\n  } else if (embedded_target_os == EmbeddedTargetOs::kZOS) {\n    return std::make_unique<PlatformEmbeddedFileWriterZOS>(embedded_target_arch,\n                                                           embedded_target_os);\n  } else {\n    return std::make_unique<PlatformEmbeddedFileWriterGeneric>(\n        embedded_target_arch, embedded_target_os);\n  }\n\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n</file>\n```"
}