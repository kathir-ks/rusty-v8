{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/implementation-visitor.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/implementation-visitor.cc\",\n      \"file_name\": \"implementation-visitor.cc\",\n      \"language\": \"cpp\",\n      \"purpose\": \"This file implements the ImplementationVisitor class, which traverses the Torque AST and generates code for different target languages (CSA, C++).\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes standard libraries and Torque-specific headers.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/torque/implementation-visitor.h\"\n\n#include <algorithm>\n#include <iomanip>\n#include <optional>\n#include <string>\n\n#include \"src/common/globals.h\"\n#include \"src/numbers/integer-literal-inl.h\"\n#include \"src/torque/cc-generator.h\"\n#include \"src/torque/cfg.h\"\n#include \"src/torque/constants.h\"\n#include \"src/torque/cpp-builder.h\"\n#include \"src/torque/csa-generator.h\"\n#include \"src/torque/declaration-visitor.h\"\n#include \"src/torque/global-context.h\"\n#include \"src/torque/kythe-data.h\"\n#include \"src/torque/parameter-difference.h\"\n#include \"src/torque/server-data.h\"\n#include \"src/torque/source-positions.h\"\n#include \"src/torque/type-inference.h\"\n#include \"src/torque/type-visitor.h\"\n#include \"src/torque/types.h\"\n#include \"src/torque/utils.h\"\n]]></code>\n  </imports>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Visit\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Visits an Expression node and dispatches to the appropriate handler based on its kind.\",\n        \"logic\": \"Uses a switch statement to determine the expression type and calls the corresponding Visit method.\",\n        \"parameters\": [\n          {\n            \"name\": \"expr\",\n            \"type\": \"Expression*\",\n            \"purpose\": \"The expression node to visit.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"VisitResult\",\n          \"description\": \"The result of visiting the expression.\"\n        },\n        \"dependencies\": [\n          \"AST_EXPRESSION_NODE_KIND_LIST\",\n          \"Visit(name::cast(expr))\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nVisitResult ImplementationVisitor::Visit(Expression* expr) {\n  CurrentSourcePosition::Scope scope(expr->pos);\n  switch (expr->kind) {\n#define ENUM_ITEM(name)        \\\n  case AstNode::Kind::k##name: \\\n    return Visit(name::cast(expr));\n    AST_EXPRESSION_NODE_KIND_LIST(ENUM_ITEM)\n#undef ENUM_ITEM\n    default:\n      UNREACHABLE();\n  }\n}\n]]></code>\n  </func>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Visit\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Visits a Statement node and dispatches to the appropriate handler based on its kind.\",\n        \"logic\": \"Uses a switch statement to determine the statement type and calls the corresponding Visit method. Manages stack scope and checks if the current block is complete.\",\n        \"parameters\": [\n          {\n            \"name\": \"stmt\",\n            \"type\": \"Statement*\",\n            \"purpose\": \"The statement node to visit.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"const Type*\",\n          \"description\": \"The resulting type of the statement.\"\n        },\n        \"dependencies\": [\n          \"AST_STATEMENT_NODE_KIND_LIST\",\n          \"StackScope\",\n          \"assembler().CurrentBlockIsComplete()\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nconst Type* ImplementationVisitor::Visit(Statement* stmt) {\n  CurrentSourcePosition::Scope scope(stmt->pos);\n  StackScope stack_scope(this);\n  const Type* result;\n  switch (stmt->kind) {\n#define ENUM_ITEM(name)               \\\n  case AstNode::Kind::k##name:        \\\n    result = Visit(name::cast(stmt)); \\\n    break;\n    AST_STATEMENT_NODE_KIND_LIST(ENUM_ITEM)\n#undef ENUM_ITEM\n    default:\n      UNREACHABLE();\n  }\n  DCHECK_EQ(result == TypeOracle::GetNeverType(),\n            assembler().CurrentBlockIsComplete());\n  return result;\n}\n]]></code>\n  </func>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"BeginGeneratedFiles\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Initializes the output streams for generating code for each source file.\",\n        \"logic\": \"Iterates through all source files, retrieves the corresponding output streams, and outputs the beginning of CSA .cc and .h files, as well as the class definition .cc file. Includes header guards and namespace declarations.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"TypeOracle::GetClasses\",\n          \"SourceFileMap::AllSources\",\n          \"GlobalContext::GeneratedPerFile\",\n          \"SourceFileMap::PathFromV8RootWithoutExtension\",\n          \"StringLiteralQuote\",\n          \"UnderlinifyPath\",\n          \"SourceFileMap::PathFromV8Root\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid ImplementationVisitor::BeginGeneratedFiles() {\n  std::set<SourceId> contains_class_definitions;\n  std::set<SourceId> contains_class_asserts;\n  for (const ClassType* type : TypeOracle::GetClasses()) {\n    if (type->ShouldGenerateCppClassDefinitions()) {\n      contains_class_definitions.insert(type->AttributedToFile());\n    }\n    if (type->ShouldGenerateCppObjectDefinitionAsserts() ||\n        type->ShouldGenerateCppObjectLayoutDefinitionAsserts()) {\n      contains_class_asserts.insert(type->AttributedToFile());\n    }\n  }\n\n  for (SourceId source : SourceFileMap::AllSources()) {\n    auto& streams = GlobalContext::GeneratedPerFile(source);\n    // Output beginning of CSA .cc file.\n    {\n      cpp::File& file = streams.csa_cc;\n\n      for (const std::string& include_path : GlobalContext::CppIncludes()) {\n        file << \"#include \" << StringLiteralQuote(include_path) << \"\\n\";\n      }\n      file << \"#include \\\"src/codegen/code-stub-assembler-inl.h\\\"\\n\";\n\n      file << \"// Required Builtins:\\n\";\n      file << \"#include \\\"torque-generated/\" +\n                  SourceFileMap::PathFromV8RootWithoutExtension(source) +\n                  \"-tq-csa.h\\\"\\n\";\n      // Now that required include files are collected while generating the\n      // file, we only know the full set at the end. Insert a marker here that\n      // is replaced with the list of includes at the very end.\n      // TODO(nicohartmann@): This is not the most beautiful way to do this,\n      // replace once the cpp file builder is available, where this can be\n      // handled easily.\n      file << BuiltinIncludesMarker;\n      file << \"\\n\";\n\n      streams.csa_cc.BeginNamespace(\"v8\", \"internal\");\n      streams.csa_ccfile << \"\\n\";\n    }\n    // Output beginning of CSA .h file.\n    {\n      cpp::File& file = streams.csa_header;\n      std::string header_define =\n          \"V8_GEN_TORQUE_GENERATED_\" +\n          UnderlinifyPath(SourceFileMap::PathFromV8Root(source)) + \"_CSA_H_\";\n      streams.csa_header.BeginIncludeGuard(header_define);\n      file << \"#include \\\"src/builtins/torque-csa-header-includes.h\\\"\\n\";\n      file << \"\\n\";\n\n      streams.csa_header.BeginNamespace(\"v8\", \"internal\");\n      streams.csa_headerfile << \"\\n\";\n    }\n    // Output beginning of class definition .cc file.\n    {\n      cpp::File& file = streams.class_definition_cc;\n      if (contains_class_definitions.count(source) != 0) {\n        file << \"#include \\\"\"\n             << SourceFileMap::PathFromV8RootWithoutExtension(source)\n             << \"-inl.h\\\"\\n\\n\";\n        file << \"#include \\\"torque-generated/class-verifiers.h\\\"\\n\";\n        file << \"#include \\\"src/objects/instance-type-inl.h\\\"\\n\\n\";\n      }\n      if (contains_class_asserts.count(source) != 0) {\n        file << \"#include \\\"\"\n             << SourceFileMap::PathFromV8RootWithoutExtension(source)\n             << \".h\\\"\\n\\n\";\n      }\n\n      streams.class_definition_cc.BeginNamespace(\"v8\", \"internal\");\n      streams.class_definition_ccfile << \"\\n\";\n    }\n  }\n}\n]]></code>\n  </func>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"EndGeneratedFiles\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Closes the output streams for generating code for each source file.\",\n        \"logic\": \"Iterates through all source files, retrieves the corresponding output streams, and outputs the ending of CSA .cc and .h files, as well as the class definition .cc file. Includes header guards and namespace declarations.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"SourceFileMap::AllSources\",\n          \"GlobalContext::GeneratedPerFile\",\n          \"UnderlinifyPath\",\n          \"SourceFileMap::PathFromV8Root\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid ImplementationVisitor::EndGeneratedFiles() {\n  for (SourceId file : SourceFileMap::AllSources()) {\n    auto& streams = GlobalContext::GeneratedPerFile(file);\n\n    // Output ending of CSA .cc file.\n    streams.csa_cc.EndNamespace(\"v8\", \"internal\");\n\n    // Output ending of CSA .h file.\n    {\n      std::string header_define =\n          \"V8_GEN_TORQUE_GENERATED_\" +\n          UnderlinifyPath(SourceFileMap::PathFromV8Root(file)) + \"_CSA_H_\";\n\n      streams.csa_header.EndNamespace(\"v8\", \"internal\");\n      streams.csa_headerfile << \"\\n\";\n      streams.csa_header.EndIncludeGuard(header_define);\n    }\n\n    // Output ending of class definition .cc file.\n    streams.class_definition_cc.EndNamespace(\"v8\", \"internal\");\n  }\n}\n]]></code>\n  </func>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"BeginDebugMacrosFile\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Opens output streams to begin writing debug macros.\",\n        \"logic\": \"Includes necessary header files for defining debug macros, opens the namespace v8::internal::debug_helper_internal, and defines the include guard for the debug macros header file.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid ImplementationVisitor::BeginDebugMacrosFile() {\n  // TODO(torque-builer): Can use builder for debug_macros_*_\n  std::ostream& source = debug_macros_cc_;\n  std::ostream& header = debug_macros_h_;\n\n  source << \"#include \\\"torque-generated/debug-macros.h\\\"\\n\\n\";\n  source << \"#include \\\"src/objects/swiss-name-dictionary.h\\\"\\n\";\n  source << \"#include \\\"src/objects/ordered-hash-table.h\\\"\\n\";\n  source << \"#include \\\"src/torque/runtime-support.h\\\"\\n\";\n  source << \"#include \\\"tools/debug_helper/debug-macro-shims.h\\\"\\n\";\n  source << \"#include \\\"include/v8-internal.h\\\"\\n\";\n  source << \"\\n\";\n\n  source << \"namespace v8 {\\n\"\n         << \"namespace internal {\\n\"\n         << \"namespace debug_helper_internal {\\n\"\n         << \"\\n\";\n\n  const char* kHeaderDefine = \"V8_GEN_TORQUE_GENERATED_DEBUG_MACROS_H_\";\n  header << \"#ifndef \" << kHeaderDefine << \"\\n\";\n  header << \"#define \" << kHeaderDefine << \"\\n\\n\";\n  header << \"#include \\\"tools/debug_helper/debug-helper-internal.h\\\"\\n\";\n  header << \"#include \\\"src/numbers/integer-literal.h\\\"\\n\";\n  header << \"\\n\";\n\n  header << \"namespace v8 {\\n\"\n         << \"namespace internal {\\n\"\n         << \"namespace debug_helper_internal {\\n\"\n         << \"\\n\";\n}\n]]></code>\n  </func>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"EndDebugMacrosFile\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Closes output streams at the end of writing debug macros.\",\n        \"logic\": \"Closes the namespace v8::internal::debug_helper_internal and defines the ending ifndef for the debug macros header file.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nvoid ImplementationVisitor::EndDebugMacrosFile() {\n  // TODO(torque-builder): Can use builder for debug_macros_*_\n  std::ostream& source = debug_macros_cc_;\n  std::ostream& header = debug_macros_h_;\n\n  source << \"}  // namespace internal\\n\"\n         << \"}  // namespace v8\\n\"\n         << \"}  // namespace debug_helper_internal\\n\"\n         << \"\\n\";\n\n  header << \"\\n}  // namespace internal\\n\"\n         << \"}  // namespace v8\\n\"\n         << \"}  // namespace debug_helper_internal\\n\"\n         << \"\\n\";\n  header << \"#endif  // V8_GEN_TORQUE_GENERATED_DEBUG_MACROS_H_\\n\";\n}\n]]></code>\n  </func>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Visit\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Visits a NamespaceConstant declaration.\",\n        \"logic\": \"Generates a function that returns the value of the namespace constant.  The function is declared in the csa_headerfile and defined in the csa_ccfile. The body of the function visits the expression that defines the constant and emits the appropriate CSA code.\",\n        \"parameters\": [\n          {\n            \"name\": \"decl\",\n            \"type\": \"NamespaceConstant*\",\n            \"purpose\": \"The NamespaceConstant declaration to visit.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"Signature\",\n          \"BindingsManagersScope\",\n          \"GenerateFunction\",\n          \"VisitResult\",\n          \"GenerateImplicitConvert\",\n          \"CSAGenerator\",\n          \"CSAGenerator::EmitCSAValue\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid ImplementationVisitor::Visit(NamespaceConstant* decl) {\n  Signature signature{{},           std::nullopt, {{}, false}, 0,\n                      decl->type(), {},           false};\n\n  BindingsManagersScope bindings_managers_scope;\n\n  cpp::Function f =\n      GenerateFunction(nullptr, decl->external_name(), signature, {});\n\n  f.PrintDeclaration(csa_headerfile());\n\n  f.PrintDefinition(csa_ccfile(), [&](std::ostream& stream) {\n    stream << \"  compiler::CodeAssembler ca_(state_);\\n\";\n\n    DCHECK(!signature.return_type->IsVoidOrNever());\n\n    assembler_ = CfgAssembler(Stack<const Type*>{});\n\n    VisitResult expression_result = Visit(decl->body());\n    VisitResult return_result =\n        GenerateImplicitConvert(signature.return_type, expression_result);\n\n    CSAGenerator csa_generator{assembler().Result(), stream};\n    Stack<std::string> values = *csa_generator.EmitGraph(Stack<std::string>{});\n\n    assembler_ = std::nullopt;\n\n    stream << \"  return \";\n    CSAGenerator::EmitCSAValue(return_result, values, stream);\n    stream << \";\";\n  });\n}\n]]></code>\n  </func>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Visit\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Visits a TypeAlias declaration.\",\n        \"logic\": \"If the type alias is a class that is external and not in the default namespace, it reports an error. Otherwise, it does nothing.\",\n        \"parameters\": [\n          {\n            \"name\": \"alias\",\n            \"type\": \"TypeAlias*\",\n            \"purpose\": \"The TypeAlias declaration to visit.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"ClassType::DynamicCast\",\n          \"Error\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid ImplementationVisitor::Visit(TypeAlias* alias) {\n  if (alias->IsRedeclaration()) return;\n  if (const ClassType* class_type = ClassType::DynamicCast(alias->type())) {\n    if (class_type->IsExtern() && !class_type->nspace()->IsDefaultNamespace()) {\n      Error(\n          \"extern classes are currently only supported in the default \"\n          \"namespace\");\n    }\n  }\n}\n]]></code>\n  </func>\n\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"MacroInliningScope\",\n        \"about\": \"Manages the inlining of macros to prevent recursive expansion.\",\n        \"attributes\": [\n          {\n            \"name\": \"visitor_\",\n            \"type\": \"ImplementationVisitor*\",\n            \"access\": \"private\",\n            \"purpose\": \"A pointer to the ImplementationVisitor.\"\n          },\n          {\n            \"name\": \"macro_\",\n            \"type\": \"const Macro*\",\n            \"access\": \"private\",\n            \"purpose\": \"A pointer to the Macro object being inlined.\"\n          }\n        ],\n        \"dependencies\": [\n          \"ImplementationVisitor\",\n          \"Macro\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nclass ImplementationVisitor::MacroInliningScope {\n public:\n  MacroInliningScope(ImplementationVisitor* visitor, const Macro* macro)\n      : visitor_(visitor), macro_(macro) {\n    if (!visitor_->inlining_macros_.insert(macro).second) {\n      // Recursive macro expansion would just keep going until stack overflow.\n      // To avoid crashes, throw an error immediately.\n      ReportError(\"Recursive macro call to \", *macro);\n    }\n  }\n  ~MacroInliningScope() { visitor_->inlining_macros_.erase(macro_); }\n\n private:\n  ImplementationVisitor* visitor_;\n  const Macro* macro_;\n};\n]]></code>\n  </class>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"InlineMacro\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Inlines a macro by visiting its body and binding parameters.\",\n        \"logic\": \"Creates a new scope for the macro, binds parameters and labels, and visits the macro body. Handles return values and error reporting for macros with and without return types.\",\n        \"parameters\": [\n          {\n            \"name\": \"macro\",\n            \"type\": \"Macro*\",\n            \"purpose\": \"The macro to inline.\"\n          },\n          {\n            \"name\": \"this_reference\",\n            \"type\": \"std::optional<LocationReference>\",\n            \"purpose\": \"The this reference for methods.\"\n          },\n          {\n            \"name\": \"arguments\",\n            \"type\": \"const std::vector<VisitResult>&\",\n            \"purpose\": \"The arguments to the macro.\"\n          },\n          {\n            \"name\": \"label_blocks\",\n            \"type\": \"const std::vector<Block*>\",\n            \"purpose\": \"The label blocks for the macro.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"VisitResult\",\n          \"description\": \"The result of inlining the macro.\"\n        },\n        \"dependencies\": [\n          \"MacroInliningScope\",\n          \"CurrentScope\",\n          \"BindingsManagersScope\",\n          \"CurrentCallable\",\n          \"CurrentReturnValue\",\n          \"Signature\",\n          \"BlockBindings\",\n          \"LocalValue\",\n          \"LocalLabel\",\n          \"KytheData::AddBindingDefinition\",\n          \"assembler().NewBlock\",\n          \"LowerType\",\n          \"SetReturnValue\",\n          \"assembler().Goto\",\n          \"assembler().Bind\",\n          \"GetAndClearReturnValue\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nVisitResult ImplementationVisitor::InlineMacro(\n    Macro* macro, std::optional<LocationReference> this_reference,\n    const std::vector<VisitResult>& arguments,\n    const std::vector<Block*> label_blocks) {\n  MacroInliningScope macro_inlining_scope(this, macro);\n  CurrentScope::Scope current_scope(macro);\n  BindingsManagersScope bindings_managers_scope;\n  CurrentCallable::Scope current_callable(macro);\n  CurrentReturnValue::Scope current_return_value;\n  const Signature& signature = macro->signature();\n  const Type* return_type = macro->signature().return_type;\n  bool can_return = return_type != TypeOracle::GetNeverType();\n\n  BlockBindings<LocalValue> parameter_bindings(&ValueBindingsManager::Get());\n  BlockBindings<LocalLabel> label_bindings(&LabelBindingsManager::Get());\n  DCHECK_EQ(macro->signature().parameter_names.size(),\n            arguments.size() + (this_reference ? 1 : 0));\n  DCHECK_EQ(this_reference.has_value(), macro->IsMethod());\n\n  // Bind the this for methods. Methods that modify a struct-type \"this\" must\n  // only be called if the this is in a variable, in which case the\n  // LocalValue is non-const. Otherwise, the LocalValue used for the parameter\n  // binding is const, and thus read-only, which will cause errors if\n  // modified, e.g. when called by a struct method that sets the structs\n  // fields. This prevents using temporary struct values for anything other\n  // than read operations.\n  if (this_reference) {\n    DCHECK(macro->IsMethod());\n    parameter_bindings.Add(kThisParameterName, LocalValue{*this_reference},\n                           true);\n    // TODO(v8:12261): Tracking 'this'-binding for kythe led to a few weird\n    // issues. Review to fully support 'this' in methods.\n  }\n\n  size_t count = 0;\n  for (const auto& arg : arguments) {\n    if (this_reference && count == signature.implicit_count) count++;\n    const bool mark_as_used = signature.implicit_count > count;\n    const Identifier* name = macro->parameter_names()[count++];\n    Binding<LocalValue>* binding =\n        parameter_bindings.Add(name,\n                               LocalValue{LocationReference::Temporary(\n                                   arg, \"parameter \" + name->value)},\n                               mark_as_used);\n    if (GlobalContext::collect_kythe_data()) {\n      KytheData::AddBindingDefinition(binding);\n    }\n  }\n\n  DCHECK_EQ(label_blocks.size(), signature.labels.size());\n  for (size_t i = 0; i < signature.labels.size(); ++i) {\n    const LabelDeclaration& label_info = signature.labels[i];\n    Binding<LocalLabel>* binding = label_bindings.Add(\n        label_info.name, LocalLabel{label_blocks[i], label_info.types});\n    if (GlobalContext::collect_kythe_data()) {\n      KytheData::AddBindingDefinition(binding);\n    }\n  }\n\n  Block* macro_end;\n  std::optional<Binding<LocalLabel>> macro_end_binding;\n  if (can_return) {\n    Stack<const Type*> stack = assembler().CurrentStack();\n    std::vector<const Type*> lowered_return_types = LowerType(return_type);\n    stack.PushMany(lowered_return_types);\n    if (!return_type->IsConstexpr()) {\n      SetReturnValue(VisitResult(return_type,\n                                 stack.TopRange(lowered_return_types.size())));\n    }\n    // The stack copy used to initialize the _macro_end block is only used\n    // as a template for the actual gotos generated by return statements. It\n    // doesn't correspond to any real return values, and thus shouldn't contain\n    // top types, because these would pollute actual return value types that get\n    // unioned with them for return statements, erroneously forcing them to top.\n    for (auto i = stack.begin(); i != stack.end(); ++i) {\n      if ((*i)->IsTopType()) {\n        *i = TopType::cast(*i)->source_type();\n      }\n    }\n    macro_end = assembler().NewBlock(std::move(stack));\n    macro_end_binding.emplace(&LabelBindingsManager::Get(), kMacroEndLabelName,\n                              LocalLabel{macro_end, {return_type}});\n  } else {\n    SetReturnValue(VisitResult::NeverResult());\n  }\n\n  const Type* result = Visit(*macro->body());\n\n  if (result->IsNever()) {\n    if (!return_type->IsNever() && !macro->HasReturns()) {\n      std::stringstream s;\n      s << \"macro \" << macro->ReadableName()\n        << \" that never returns must have return type never\";\n      ReportError(s.str());\n    }\n  } else {\n    if (return_type->IsNever()) {\n      std::stringstream s;\n      s << \"macro \" << macro->ReadableName()\n        << \" has implicit return at end of its declartion but return type \"\n           \"never\";\n      ReportError(s.str());\n    } else if (!macro->signature().return_type->IsVoid()) {\n      std::stringstream s;\n      s << \"macro \" << macro->ReadableName()\n        << \" expects to return a value but doesn't on all paths\";\n      ReportError(s.str());\n    }\n  }\n  if (!result->IsNever()) {\n    assembler().Goto(macro_end);\n  }\n\n  if (macro->HasReturns() || !result->IsNever()) {\n    assembler().Bind(macro_end);\n  }\n\n  return GetAndClearReturnValue();\n}\n]]></code>\n  </func>\n\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"VisitMacroCommon\",\n        \"parent\": \"ImplementationVisitor\",\n        \"about\": \"Handles the common logic for visiting both TorqueMacro and Method declarations.\",\n        \"logic\": \"Generates the function declaration, begins the function definition in the CSA .cc file, prepares the assembler, and then inlines the macro using InlineMacro. After inlining, it emits the graph using either CCGenerator or CSAGenerator depending on the output type.\",\n        \"parameters\": [\n          {\n            \"name\": \"macro\",\n            \"type\": \"Macro*\",\n            \"purpose\": \"The macro to visit.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"CurrentCallable\",\n          \"Signature\",\n          \"GenerateMacroFunctionDeclaration\",\n          \"cpp::IncludeGuardScope\",\n          \"InlineMacro\",\n          \"CCGenerator\",\n          \"CSAGenerator\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid ImplementationVisitor::VisitMacroCommon(Macro* macro) {\n  CurrentCallable::Scope current_callable(macro);\n  const Signature& signature = macro->signature();\n  const Type* return_type = macro->signature().return_type;\n  bool can_return = return_type != TypeOracle::GetNeverType();\n  bool has_return_value =\n      can_return && return_type != TypeOracle::GetVoidType();\n\n  cpp::Function f = GenerateMacroFunctionDeclaration(macro);\n  f.PrintDeclaration(csa_headerfile());\n  csa_headerfile() << \"\\n\";\n\n  cpp::File csa_cc(csa_ccfile());\n\n  // Avoid multiple-definition errors since it is possible for multiple\n  // generated -inl.inc files to all contain function definitions for the same\n  // Torque macro.\n  std::optional<cpp::IncludeGuardScope> include_guard;\n  if (output_type_ == OutputType::kCC) {\n    include_guard.emplace(&csa_cc, \"V8_INTERNAL_DEFINED_\"s + macro->CCName());\n  } else if (output_type_ == OutputType::kCCDebug) {\n    include_guard.emplace(&csa_cc,\n                          \"V8_INTERNAL_DEFINED_\"s + macro->CCDebugName());\n  }\n\n  f.PrintBeginDefinition(csa_ccfile());\n\n  if (output_type_ == OutputType::kCC) {\n    // For now, generated C++ is only for field offset computations. If we ever\n    // generate C++ code that can allocate, then it should be handlified.\n    csa_ccfile() << \"  DisallowGarbageCollection no_gc;\\n\";\n  } else if (output_type_ == OutputType::kCSA) {\n    csa_ccfile() << \"  compiler::CodeAssembler ca_(state_);\\n\";\n    csa_ccfile()\n        << \"  compiler::CodeAssembler::SourcePositionScope pos_scope(&ca_);\\n\";\n  }\n\n  Stack<std::string> lowered_parameters;\n  Stack<const Type*> lowered_parameter_types;\n\n  std::vector<VisitResult> arguments;\n\n  std::optional<LocationReference> this_reference;\n  if (Method* method = Method::DynamicCast(macro)) {\n    const Type* this_type = method->aggregate_type();\n    LowerParameter(this_type, ExternalParameterName(kThisParameterName),\n                   &lowered_parameters);\n    StackRange range = lowered_parameter_types.PushMany(LowerType(this_type));\n    VisitResult this_result = VisitResult(this_type, range);\n    // For classes, mark 'this' as a temporary to prevent assignment to it.\n    // Note that using a VariableAccess for non-class types is technically\n    // incorrect because changes to the 'this' variable do not get reflected\n    // to the caller. Therefore struct methods should always be inlined and a\n    // C++ version should never be generated, since it would be incorrect.\n    // However, in order to be able to type- and semantics-check even unused\n    // struct methods, set the this_reference to be the local variable copy of\n    // the passed-in this, which allows the visitor to at least find and report\n    // errors.\n    this_reference =\n        (this_type->IsClassType())\n            ? LocationReference::Temporary(this_result, \"this parameter\")\n            : LocationReference::VariableAccess(this_result);\n  }\n\n  for (size_t i = 0; i < macro->signature().parameter_names.size(); ++i) {\n    if (this_reference && i == macro->signature().implicit_count) continue;\n    const std::string& name = macro->parameter_names()[i]->value;\n    std::string external_name = ExternalParameterName(name);\n    const Type* type = macro->signature().types()[i];\n\n    if (type->IsConstexpr()) {\n      arguments.push_back(VisitResult(type, external_name));\n    } else {\n      LowerParameter(type, external_name, &lowered_parameters);\n      StackRange range = lowered_parameter_types.PushMany(LowerType(type));\n      arguments.push_back(VisitResult(type, range));\n    }\n  }\n\n  DCHECK_EQ(lowered_parameters.Size(), lowered_parameter_types.Size());\n  assembler_ = CfgAssembler(lowered_parameter_types);\n\n  std::vector<Block*> label_blocks;\n  for (const LabelDeclaration& label_info : signature.labels) {\n    Stack<const Type*> label_input_stack;\n    for (const Type* type : label_info.types) {\n      label_input_stack.PushMany(LowerType(type));\n    }\n    Block* block = assembler().NewBlock(std::move(label_input_stack));\n    label_blocks.push_back(block);\n  }\n\n  VisitResult return_value =\n      InlineMacro(macro, this_reference, arguments, label_blocks);\n  Block* end = assembler().NewBlock();\n  if (return_type != TypeOracle::GetNeverType()) {\n    assembler().Goto(end);\n  }\n\n  for (size_t i = 0; i < label_blocks.size(); ++i) {\n    Block"
}