{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/maglev-early-lowering-reducer-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/maglev-early-lowering-reducer-inl.h\",\n        \"file_name\": \"maglev-early-lowering-reducer-inl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides a reducer class (MaglevEarlyLoweringReducer) that helps lower Maglev operators during the MaglevGraphBuildingPhase in Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for optional types, compiler feedback, global compiler settings, Turboshaft assembler, indexing, representations, deoptimization reasons, object contexts, and instance types.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/compiler/feedback-source.h\"\n#include \"src/compiler/globals.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/representations.h\"\n#include \"src/deoptimizer/deoptimize-reason.h\"\n#include \"src/objects/contexts.h\"\n#include \"src/objects/instance-type-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MaglevEarlyLoweringReducer\",\n            \"extends\": \"Next\",\n            \"about\": \"A reducer class that provides helpers to lower Maglev operators during Maglev graph building.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Next\",\n                \"FeedbackSource\",\n                \"InstanceType\",\n                \"DeoptimizeReason\",\n                \"InternalizedStringRef\",\n                \"RootIndex\",\n                \"Context\",\n                \"JSGeneratorObject\",\n                \"FixedArray\",\n                \"JSArray\",\n                \"JSObject\",\n                \"PropertyArray\",\n                \"compiler::MapRef\",\n                \"MapRef\",\n                \"ZoneVector\",\n                \"LazyDeoptOnThrow\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass MaglevEarlyLoweringReducer : public Next {\n  // This Reducer provides some helpers that are used during\n  // MaglevGraphBuildingPhase to lower some Maglev operators. Depending on what\n  // we decide going forward (regarding SimplifiedLowering for instance), we\n  // could introduce new Simplified or JS operations instead of using these\n  // helpers to lower, and turn the helpers into regular REDUCE methods in the\n  // new simplified lowering or in MachineLoweringReducer.\n\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(MaglevEarlyLowering)\n\n  void CheckInstanceType(V<Object> input, V<FrameState> frame_state,\n                         const FeedbackSource& feedback,\n                         InstanceType first_instance_type,\n                         InstanceType last_instance_type, bool check_smi);\n\n  V<InternalizedString> CheckedInternalizedString(\n      V<Object> object, V<FrameState> frame_state, bool check_smi,\n      const FeedbackSource& feedback);\n\n  void CheckValueEqualsString(V<Object> object, InternalizedStringRef value,\n                              V<FrameState> frame_state,\n                              const FeedbackSource& feedback);\n\n  V<Object> CheckConstructResult(V<Object> construct_result,\n                                 V<Object> implicit_receiver);\n\n  V<Object> LoadScriptContextSideData(V<Context> script_context, int index);\n\n  V<Object> LoadScriptContextPropertyFromSideData(V<Object> side_data);\n\n  V<Object> LoadHeapNumberFromScriptContext(V<Context> script_context,\n                                            int index,\n                                            V<HeapNumber> heap_number);\n\n  void StoreScriptContextSlowPath(V<Context> script_context,\n                                  V<Object> old_value, V<Object> new_value,\n                                  V<Object> side_data,\n                                  V<FrameState> frame_state,\n                                  const FeedbackSource& feedback,\n                                  Label<>& done);\n\n  void CheckDerivedConstructResult(V<Object> construct_result,\n                                   V<FrameState> frame_state,\n                                   V<NativeContext> native_context,\n                                   LazyDeoptOnThrow lazy_deopt_on_throw);\n\n  V<Smi> UpdateJSArrayLength(V<Word32> length_raw, V<JSArray> object,\n                             V<Word32> index);\n\n  V<Map> TransitionMultipleElementsKind(\n      V<Object> object, V<Map> map,\n      const ZoneVector<compiler::MapRef>& transition_sources,\n      const MapRef transition_target);\n\n  void TransitionElementsKind(\n      V<Object> object, V<Map> map,\n      const ZoneVector<compiler::MapRef>& transition_sources,\n      const MapRef transition_target, Label<Map>& end);\n\n  V<Word32> JSAnyIsNotPrimitive(V<HeapObject> heap_object);\n\n  V<Boolean> HasInPrototypeChain(V<Object> object, HeapObjectRef prototype,\n                                 V<FrameState> frame_state,\n                                 V<NativeContext> native_context,\n                                 LazyDeoptOnThrow lazy_deopt_on_throw);\n\n  V<Map> MigrateMapIfNeeded(V<HeapObject> object, V<Map> map,\n                            V<FrameState> frame_state,\n                            const FeedbackSource& feedback);\n\n  V<PropertyArray> ExtendPropertiesBackingStore(\n      V<PropertyArray> old_property_array, V<JSObject> object, int old_length,\n      V<FrameState> frame_state, const FeedbackSource& feedback);\n\n  void GeneratorStore(V<Context> context, V<JSGeneratorObject> generator,\n                      base::SmallVector<OpIndex, 32> parameters_and_registers,\n                      int suspend_id, int bytecode_offset);\n\n private:\n  V<Word32> CheckInstanceTypeIsInRange(V<Map> map,\n                                       InstanceType first_instance_type,\n                                       InstanceType last_instance_type);\n\n  Isolate* isolate_ = __ data() -> isolate();\n  LocalIsolate* local_isolate_ = isolate_->AsLocalIsolate();\n  JSHeapBroker* broker_ = __ data() -> broker();\n  LocalFactory* factory_ = local_isolate_->factory();\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CheckInstanceType\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Checks if an object's instance type falls within a specified range, deoptimizing if it doesn't.\",\n            \"logic\": \"If check_smi is true, deoptimizes if the input is a smi. Loads the map and instance type of the object. If the instance type should equal exactly one value, the function checks using either static roots or a Word32Equal check. Otherwise, it checks if the instance type is within the given range using CheckInstanceTypeIsInRange and deoptimizes if it isn't.\",\n            \"parameters\": [\n                {\n                    \"name\": \"input\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The object to check.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"V<FrameState>\",\n                    \"purpose\": \"The current frame state for deoptimization.\"\n                },\n                {\n                    \"name\": \"feedback\",\n                    \"type\": \"const FeedbackSource&\",\n                    \"purpose\": \"Feedback source for deoptimization.\"\n                },\n                {\n                    \"name\": \"first_instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The lower bound of the instance type range.\"\n                },\n                {\n                    \"name\": \"last_instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The upper bound of the instance type range.\"\n                },\n                {\n                    \"name\": \"check_smi\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether to check if the input is a smi.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DeoptimizeReason\",\n                \"IsSmi\",\n                \"LoadMapField\",\n                \"TaggedEqual\",\n                \"HeapConstant\",\n                \"LoadInstanceTypeField\",\n                \"Word32Equal\",\n                \"CheckInstanceTypeIsInRange\",\n                \"Word32\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void CheckInstanceType(V<Object> input, V<FrameState> frame_state,\n                         const FeedbackSource& feedback,\n                         InstanceType first_instance_type,\n                         InstanceType last_instance_type, bool check_smi) {\n    if (check_smi) {\n      __ DeoptimizeIf(__ IsSmi(input), frame_state,\n                      DeoptimizeReason::kWrongInstanceType, feedback);\n    }\n\n    V<i::Map> map = __ LoadMapField(input);\n\n    if (first_instance_type == last_instance_type) {\n#if V8_STATIC_ROOTS_BOOL\n      if (InstanceTypeChecker::UniqueMapOfInstanceType(first_instance_type)) {\n        std::optional<RootIndex> expected_index =\n            InstanceTypeChecker::UniqueMapOfInstanceType(first_instance_type);\n        CHECK(expected_index.has_value());\n        Handle<HeapObject> expected_map =\n            Cast<HeapObject>(isolate_->root_handle(expected_index.value()));\n        __ DeoptimizeIfNot(__ TaggedEqual(map, __ HeapConstant(expected_map)),\n                           frame_state, DeoptimizeReason::kWrongInstanceType,\n                           feedback);\n        return;\n      }\n#endif  // V8_STATIC_ROOTS_BOOL\n      V<Word32> instance_type = __ LoadInstanceTypeField(map);\n      __ DeoptimizeIfNot(__ Word32Equal(instance_type, first_instance_type),\n                         frame_state, DeoptimizeReason::kWrongInstanceType,\n                         feedback);\n    } else {\n      __ DeoptimizeIfNot(CheckInstanceTypeIsInRange(map, first_instance_type,\n                                                    last_instance_type),\n                         frame_state, DeoptimizeReason::kWrongInstanceType,\n                         feedback);\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CheckedInternalizedString\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Checks if an object is an internalized string and returns it, deoptimizing if not.\",\n            \"logic\": \"Deoptimizes if the input is a Smi when `check_smi` is true. Loads the map and instance type of the object. Deoptimizes or loads internalized string from thin string if the object is not a string or not internalized.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The object to check.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"V<FrameState>\",\n                    \"purpose\": \"The current frame state for deoptimization.\"\n                },\n                {\n                    \"name\": \"check_smi\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether to check if the object is a Smi.\"\n                },\n                {\n                    \"name\": \"feedback\",\n                    \"type\": \"const FeedbackSource&\",\n                    \"purpose\": \"Feedback source for deoptimization.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<InternalizedString>\",\n                \"description\": \"The internalized string if the object is an internalized string.\"\n            },\n            \"dependencies\": [\n                \"DeoptimizeReason\",\n                \"IsSmi\",\n                \"LoadMapField\",\n                \"LoadInstanceTypeField\",\n                \"Word32BitwiseAnd\",\n                \"kIsNotStringMask\",\n                \"kIsNotInternalizedMask\",\n                \"Word32\",\n                \"kThinStringTagBit\",\n                \"LoadField\",\n                \"InternalizedString\",\n                \"AccessBuilder\",\n                \"Cast\",\n                \"Map\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  V<InternalizedString> CheckedInternalizedString(\n      V<Object> object, V<FrameState> frame_state, bool check_smi,\n      const FeedbackSource& feedback) {\n    if (check_smi) {\n      __ DeoptimizeIf(__ IsSmi(object), frame_state, DeoptimizeReason::kSmi,\n                      feedback);\n    }\n\n    Label<InternalizedString> done(this);\n    V<Map> map = __ LoadMapField(object);\n    V<Word32> instance_type = __ LoadInstanceTypeField(map);\n\n    // Go to the slow path if this is a non-string, or a non-internalised\n    // string.\n    static_assert((kStringTag | kInternalizedTag) == 0);\n    IF (UNLIKELY(__ Word32BitwiseAnd(\n            instance_type, kIsNotStringMask | kIsNotInternalizedMask))) {\n      // Deopt if this isn't a string.\n      __ DeoptimizeIf(__ Word32BitwiseAnd(instance_type, kIsNotStringMask),\n                      frame_state, DeoptimizeReason::kWrongMap, feedback);\n      // Deopt if this isn't a thin string.\n      static_assert(base::bits::CountPopulation(kThinStringTagBit) == 1);\n      __ DeoptimizeIfNot(__ Word32BitwiseAnd(instance_type, kThinStringTagBit),\n                         frame_state, DeoptimizeReason::kWrongMap, feedback);\n      // Load internalized string from thin string.\n      V<InternalizedString> intern_string =\n          __ template LoadField<InternalizedString>(\n              object, AccessBuilder::ForThinStringActual());\n      GOTO(done, intern_string);\n    } ELSE {\n      GOTO(done, V<InternalizedString>::Cast(object));\n    }\n\n    BIND(done, result);\n    return result;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CheckValueEqualsString\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Checks if an object is equal to a given internalized string value, deoptimizing if not.\",\n            \"logic\": \"Checks if the object is tagged equal to a given HeapConstant(internalized_string). Otherwise deoptimizes if object is not a string, creates a `StringEqual` operator and deoptimizes if the strings are not equal.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The object to check.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"InternalizedStringRef\",\n                    \"purpose\": \"The internalized string value to compare with.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"V<FrameState>\",\n                    \"purpose\": \"The current frame state for deoptimization.\"\n                },\n                {\n                    \"name\": \"feedback\",\n                    \"type\": \"const FeedbackSource&\",\n                    \"purpose\": \"Feedback source for deoptimization.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TaggedEqual\",\n                \"HeapConstant\",\n                \"DeoptimizeReason\",\n                \"ObjectIsString\",\n                \"StringEqual\",\n                \"String\",\n                \"Boolean\",\n                \"RootEqual\",\n                \"RootIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void CheckValueEqualsString(V<Object> object, InternalizedStringRef value,\n                              V<FrameState> frame_state,\n                              const FeedbackSource& feedback) {\n    IF_NOT (LIKELY(__ TaggedEqual(object, __ HeapConstant(value.object())))) {\n      __ DeoptimizeIfNot(__ ObjectIsString(object), frame_state,\n                         DeoptimizeReason::kNotAString, feedback);\n      V<Boolean> is_same_string_bool =\n          __ StringEqual(V<String>::Cast(object),\n                         __ template HeapConstant<String>(value.object()));\n      __ DeoptimizeIf(\n          __ RootEqual(is_same_string_bool, RootIndex::kFalseValue, isolate_),\n          frame_state, DeoptimizeReason::kWrongValue, feedback);\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CheckConstructResult\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Checks the result of a constructor invocation and returns either the result or the implicit receiver based on whether the result is an object.\",\n            \"logic\": \"Checks if the `construct_result` is undefined, a smi, or not a primitive. Returns the `implicit_receiver` or `construct_result` accordingly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"construct_result\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The result of the constructor invocation.\"\n                },\n                {\n                    \"name\": \"implicit_receiver\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The implicit receiver of the constructor invocation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Object>\",\n                \"description\": \"The result of the constructor invocation or the implicit receiver.\"\n            },\n            \"dependencies\": [\n                \"RootEqual\",\n                \"RootIndex\",\n                \"IsSmi\",\n                \"JSAnyIsNotPrimitive\",\n                \"HeapObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  V<Object> CheckConstructResult(V<Object> construct_result,\n                                 V<Object> implicit_receiver) {\n    // If the result is an object (in the ECMA sense), we should get rid\n    // of the receiver and use the result; see ECMA-262 version 5.1\n    // section 13.2.2-7 on page 74.\n    Label<Object> done(this);\n\n    GOTO_IF(\n        __ RootEqual(construct_result, RootIndex::kUndefinedValue, isolate_),\n        done, implicit_receiver);\n\n    // If the result is a smi, it is *not* an object in the ECMA sense.\n    GOTO_IF(__ IsSmi(construct_result), done, implicit_receiver);\n\n    // Check if the type of the result is not an object in the ECMA sense.\n    GOTO_IF(JSAnyIsNotPrimitive(V<HeapObject>::Cast(construct_result)), done,\n            construct_result);\n\n    // Throw away the result of the constructor invocation and use the\n    // implicit receiver as the result.\n    GOTO(done, implicit_receiver);\n\n    BIND(done, result);\n    return result;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LoadScriptContextSideData\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Loads side data from a script context at a given index.\",\n            \"logic\": \"Loads the FixedArray representing the side table from the script context, then loads the data at the specified index within the side table.\",\n            \"parameters\": [\n                {\n                    \"name\": \"script_context\",\n                    \"type\": \"V<Context>\",\n                    \"purpose\": \"The script context to load from.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the side data to load.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Object>\",\n                \"description\": \"The side data loaded from the script context.\"\n            },\n            \"dependencies\": [\n                \"FixedArray\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  V<Object> LoadScriptContextSideData(V<Context> script_context, int index) {\n    V<FixedArray> side_table = __ template LoadTaggedField<FixedArray>(\n        script_context,\n        Context::OffsetOfElementAt(Context::CONTEXT_SIDE_TABLE_PROPERTY_INDEX));\n    return __ LoadTaggedField(side_table,\n                              FixedArray::OffsetOfElementAt(\n                                  index - Context::MIN_CONTEXT_EXTENDED_SLOTS));\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LoadScriptContextPropertyFromSideData\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Loads a property from script context side data.  If the side data is not a Smi, the kPropertyDetailsRawOffset is loaded.\",\n            \"logic\": \"If `side_data` is a Smi, then returns `side_data`, otherwise, loads a tagged field from side_data at `kPropertyDetailsRawOffset`\",\n            \"parameters\": [\n                {\n                    \"name\": \"side_data\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The side data object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Object>\",\n                \"description\": \"The loaded script context property.\"\n            },\n            \"dependencies\": [\n                \"IsSmi\",\n                \"ContextSidePropertyCell\",\n                \"LoadTaggedField\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  V<Object> LoadScriptContextPropertyFromSideData(V<Object> side_data) {\n    ScopedVar<Object> property(this, side_data);\n    IF_NOT (__ IsSmi(side_data)) {\n      property = __ LoadTaggedField(\n          side_data, ContextSidePropertyCell::kPropertyDetailsRawOffset);\n    }\n    return property;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LoadHeapNumberFromScriptContext\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Loads a HeapNumber from a script context.\",\n            \"logic\": \"Loads side data and then the property from the side data.  If `script_context_mutable_heap_int32` is enabled, checks whether the property is ContextSidePropertyCell::MutableInt32 and allocates new heap number. Otherwise, checks if the property is a mutable heap number and returns allocated heap number with the corresponding value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"script_context\",\n                    \"type\": \"V<Context>\",\n                    \"purpose\": \"The script context to load from.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the side data to load.\"\n                },\n                {\n                    \"name\": \"heap_number\",\n                    \"type\": \"V<HeapNumber>\",\n                    \"purpose\": \"A heap number object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Object>\",\n                \"description\": \"The loaded property.\"\n            },\n            \"dependencies\": [\n                \"LoadScriptContextSideData\",\n                \"LoadScriptContextPropertyFromSideData\",\n                \"HeapNumber\",\n                \"ContextSidePropertyCell\",\n                \"SmiConstant\",\n                \"TaggedEqual\",\n                \"AllocateHeapNumberWithValue\",\n                \"ChangeInt32ToFloat64\",\n                \"LoadHeapInt32Value\",\n                \"LoadHeapNumberValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  V<Object> LoadHeapNumberFromScriptContext(V<Context> script_context,\n                                            int index,\n                                            V<HeapNumber> heap_number) {\n    V<Object> data = __ LoadScriptContextSideData(script_context, index);\n    V<Object> property = __ LoadScriptContextPropertyFromSideData(data);\n    ScopedVar<HeapNumber> result(this, heap_number);\n    Label<> done(this);\n    if (v8_flags.script_context_mutable_heap_int32) {\n      IF (__ TaggedEqual(\n              property,\n              __ SmiConstant(ContextSidePropertyCell::MutableInt32()))) {\n        result = __ AllocateHeapNumberWithValue(\n            __ ChangeInt32ToFloat64(__ LoadHeapInt32Value(heap_number)),\n            isolate_->factory());\n        GOTO(done);\n      }\n    }\n    IF (__ TaggedEqual(\n            property,\n            __ SmiConstant(ContextSidePropertyCell::MutableHeapNumber()))) {\n      result = __ AllocateHeapNumberWithValue(\n          __ LoadHeapNumberValue(heap_number), isolate_->factory());\n    }\n    GOTO(done);\n    BIND(done);\n    return result;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"StoreScriptContextSlowPath\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Handles the slow path for storing a value to a script context, performing checks and deoptimizations as needed.\",\n            \"logic\": \"Deoptimizes based on the type of the property. Performs stores based on whether flags are enabled and property type matches.\",\n            \"parameters\": [\n                {\n                    \"name\": \"script_context\",\n                    \"type\": \"V<Context>\",\n                    \"purpose\": \"The script context to store to.\"\n                },\n                {\n                    \"name\": \"old_value\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"Old value to be stored.\"\n                },\n                {\n                    \"name\": \"new_value\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"New value to be stored.\"\n                },\n                {\n                    \"name\": \"side_data\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"Side data associated with the script context.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"V<FrameState>\",\n                    \"purpose\": \"The current frame state for deoptimization.\"\n                },\n                {\n                    \"name\": \"feedback\",\n                    \"type\": \"const FeedbackSource&\",\n                    \"purpose\": \"Feedback source for deoptimization.\"\n                },\n                {\n                    \"name\": \"done\",\n                    \"type\": \"Label<>&\",\n                    \"purpose\": \"Label to jump to when done.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"RootEqual\",\n                \"RootIndex\",\n                \"DeoptimizeReason\",\n                \"LoadScriptContextPropertyFromSideData\",\n                \"ContextSidePropertyCell\",\n                \"TaggedEqual\",\n                \"SmiConstant\",\n                \"IsSmi\",\n                \"Map\",\n                \"HeapConstant\",\n                \"LoadMapField\",\n                \"ChangeFloat64ToInt32OrDeopt\",\n                \"CheckForMinusZeroMode\",\n                \"StoreField\",\n                \"HeapInt32Value\",\n                \"HeapNumber\",\n                \"ChangeInt32ToFloat64\",\n                \"HeapNumberValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void StoreScriptContextSlowPath(V<Context> script_context,\n                                  V<Object> old_value, V<Object> new_value,\n                                  V<Object> side_data,\n                                  V<FrameState> frame_state,\n                                  const FeedbackSource& feedback,\n                                  Label<>& done) {\n    // Check if Undefined.\n    __ DeoptimizeIf(\n        __ RootEqual(side_data, RootIndex::kUndefinedValue, isolate_),\n        frame_state, DeoptimizeReason::kWrongValue, feedback);\n    V<Object> property = __ LoadScriptContextPropertyFromSideData(side_data);\n    // Check for const case.\n    __ DeoptimizeIf(\n        __ TaggedEqual(property,\n                       __ SmiConstant(ContextSidePropertyCell::Const())),\n        frame_state, DeoptimizeReason::kWrongValue, feedback);\n    if (v8_flags.script_context_mutable_heap_number) {\n      // Check for smi case.\n      IF (__ TaggedEqual(\n              property, __ SmiConstant(ContextSidePropertyCell::SmiMarker()))) {\n        __ DeoptimizeIfNot(__ IsSmi(new_value), frame_state,\n                           DeoptimizeReason::kWrongValue, feedback);\n      } ELSE {\n        if (v8_flags.script_context_mutable_heap_int32) {\n          // Check for mutable heap int32 case.\n          IF (__ TaggedEqual(\n                  property,\n                  __ SmiConstant(ContextSidePropertyCell::MutableInt32()))) {\n            ScopedVar<Word32> number_value(this);\n            IF (__ IsSmi(new_value)) {\n              number_value = __ UntagSmi(V<Smi>::Cast(new_value));\n            } ELSE {\n              V<i::Map> map = __ LoadMapField(new_value);\n              __ DeoptimizeIfNot(\n                  __ TaggedEqual(map,\n                                 __ HeapConstant(factory_->heap_number_map())),\n                  frame_state, DeoptimizeReason::kWrongValue, feedback);\n              number_value = __ ChangeFloat64ToInt32OrDeopt(\n                  __ LoadHeapNumberValue(V<HeapNumber>::Cast(new_value)),\n                  frame_state, CheckForMinusZeroMode::kCheckForMinusZero,\n                  feedback);\n            }\n            __ StoreField(old_value, AccessBuilder::ForHeapInt32Value(),\n                          number_value);\n            GOTO(done);\n          }\n        }\n        // It must be a mutable heap number case.\n        ScopedVar<Float64> number_value(this);\n        IF (__ IsSmi(new_value)) {\n          number_value =\n              __ ChangeInt32ToFloat64(__ UntagSmi(V<Smi>::Cast(new_value)));\n        } ELSE {\n          V<i::Map> map = __ LoadMapField(new_value);\n          __ DeoptimizeIfNot(\n              __ TaggedEqual(map, __ HeapConstant(factory_->heap_number_map())),\n              frame_state, DeoptimizeReason::kWrongValue, feedback);\n          number_value = __ LoadHeapNumberValue(V<HeapNumber>::Cast(new_value));\n        }\n        __ StoreField(old_value, AccessBuilder::ForHeapNumberValue(),\n                      number_value);\n        GOTO(done);\n      }\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CheckDerivedConstructResult\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Checks the result of a derived constructor invocation, throwing an error if it is not an object.\",\n            \"logic\": \"Checks if the `construct_result` is a Smi or if the type of the result is not an object done the ECMA sense. Throws an error if the conditions match.\",\n            \"parameters\": [\n                {\n                    \"name\": \"construct_result\",\n                    \"type\": \"V<Object>\",\n                    \"purpose\": \"The result of the derived constructor invocation.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"V<FrameState>\",\n                    \"purpose\": \"The current frame state for deoptimization.\"\n                },\n                {\n                    \"name\": \"native_context\",\n                    \"type\": \"V<NativeContext>\",\n                    \"purpose\": \"The native context.\"\n                },\n                {\n                    \"name\": \"lazy_deopt_on_throw\",\n                    \"type\": \"LazyDeoptOnThrow\",\n                    \"purpose\": \"Specifies whether to perform lazy deoptimization on throw.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"IsSmi\",\n                \"JSAnyIsNotPrimitive\",\n                \"HeapObject\",\n                \"CallRuntime_ThrowConstructorReturnedNonObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void CheckDerivedConstructResult(V<Object> construct_result,\n                                   V<FrameState> frame_state,\n                                   V<NativeContext> native_context,\n                                   LazyDeoptOnThrow lazy_deopt_on_throw) {\n    // The result of a derived construct should be an object (in the ECMA\n    // sense).\n    Label<> do_throw(this);\n\n    // If the result is a smi, it is *not* an object in the ECMA sense.\n    GOTO_IF(__ IsSmi(construct_result), do_throw);\n\n    // Check if the type of the result is not an object done the ECMA sense.\n    IF_NOT (JSAnyIsNotPrimitive(V<HeapObject>::Cast(construct_result))) {\n      GOTO(do_throw);\n      BIND(do_throw);\n      __ CallRuntime_ThrowConstructorReturnedNonObject(\n          isolate_, frame_state, native_context, lazy_deopt_on_throw);\n      // ThrowConstructorReturnedNonObject should not return.\n      __ Unreachable();\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UpdateJSArrayLength\",\n            \"parent\": \"MaglevEarlyLoweringReducer\",\n            \"about\": \"Updates the length of a JSArray.\",\n            \"logic\": \"If the new index is less than the array's length, the original length is returned, otherwise, a new length is computed and"
}