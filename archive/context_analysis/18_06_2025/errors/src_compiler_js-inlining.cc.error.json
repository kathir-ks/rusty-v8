{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-inlining.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-inlining.cc\",\n        \"file_name\": \"js-inlining.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements JavaScript inlining for the Turbofan compiler\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for compiler, codegen, objects, and other V8 functionalities\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/js-inlining.h\"\n\n            #include <optional>\n\n            #include \"src/codegen/optimized-compilation-info.h\"\n            #include \"src/codegen/tick-counter.h\"\n            #include \"src/compiler/access-builder.h\"\n            #include \"src/compiler/all-nodes.h\"\n            #include \"src/compiler/bytecode-graph-builder.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/compiler-source-position-table.h\"\n            #include \"src/compiler/graph-reducer.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/js-operator.h\"\n            #include \"src/compiler/node-matchers.h\"\n            #include \"src/compiler/node-properties.h\"\n            #include \"src/compiler/simplified-operator.h\"\n            #include \"src/execution/isolate-inl.h\"\n            #include \"src/objects/feedback-cell-inl.h\"\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/compiler/wasm-compiler.h\"\n            #include \"src/wasm/names-provider.h\"\n            #include \"src/wasm/string-builder.h\"\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JSCallAccessor\",\n            \"about\": \"Provides convenience accessors for the common layout of nodes having either the {JSCall} or the {JSConstruct} operator.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Node\",\n                \"JSCallNode\",\n                \"JSConstructNode\",\n                \"FrameState\",\n                \"CallFrequency\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class JSCallAccessor {\n            public:\n                explicit JSCallAccessor(Node* call) : call_(call) {\n                    DCHECK(call->opcode() == IrOpcode::kJSCall ||\n                           call->opcode() == IrOpcode::kJSConstruct);\n                }\n\n                Node* target() const {\n                    return call_->InputAt(JSCallOrConstructNode::TargetIndex());\n                }\n\n                Node* receiver() const { return JSCallNode{call_}.receiver(); }\n\n                Node* new_target() const { return JSConstructNode{call_}.new_target(); }\n\n                FrameState frame_state() const {\n                    return FrameState{NodeProperties::GetFrameStateInput(call_)};\n                }\n\n                int argument_count() const {\n                    return (call_->opcode() == IrOpcode::kJSCall)\n                               ? JSCallNode{call_}.ArgumentCount()\n                               : JSConstructNode{call_}.ArgumentCount();\n                }\n\n                CallFrequency const& frequency() const {\n                    return (call_->opcode() == IrOpcode::kJSCall)\n                               ? JSCallNode{call_}.Parameters().frequency()\n                               : JSConstructNode{call_}.Parameters().frequency();\n                }\n\n            private:\n                Node* call_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InlineCall\",\n            \"parent\": \"JSInliner\",\n            \"about\": \"Inlines a function call by replacing the call node with the inlinee's graph.\",\n            \"logic\": \"Replaces uses of the inlinee's start node with corresponding inputs from the call node. Handles control and effect edges. Links uncaught calls in the inlinee to the surrounding exception handler if present. Merges return values from the inlinee.\",\n            \"parameters\": [\n                {\n                    \"name\": \"call\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The JSCall or JSConstruct node to be inlined\"\n                },\n                {\n                    \"name\": \"new_target\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The new.target value for constructors\"\n                },\n                {\n                    \"name\": \"context\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The context in which the inlined function is executed\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The frame state associated with the call\"\n                },\n                {\n                    \"name\": \"start\",\n                    \"type\": \"StartNode\",\n                    \"purpose\": \"The start node of the inlinee's graph\"\n                },\n                {\n                    \"name\": \"end\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The end node of the inlinee's graph\"\n                },\n                {\n                    \"name\": \"exception_target\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The exception target node for uncaught exceptions\"\n                },\n                {\n                    \"name\": \"uncaught_subcalls\",\n                    \"type\": \"const NodeVector&\",\n                    \"purpose\": \"A vector of uncaught call nodes within the inlinee\"\n                },\n                {\n                    \"name\": \"argument_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Number of arguments passed to the call\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"Indicates whether the inlining process changed the graph\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"NodeProperties\",\n                \"StartNode\",\n                \"Edge\",\n                \"ParameterIndexOf\",\n                \"Replace\",\n                \"jsgraph\",\n                \"common\",\n                \"graph\",\n                \"IrOpcode\",\n                \"MergeControlToEnd\",\n                \"ReplaceWithValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Reduction JSInliner::InlineCall(Node* call, Node* new_target, Node* context,\n                                        Node* frame_state, StartNode start, Node* end,\n                                        Node* exception_target,\n                                        const NodeVector& uncaught_subcalls,\n                                        int argument_count) {\n            DCHECK_IMPLIES(IrOpcode::IsInlineeOpcode(call->opcode()),\n                            argument_count == JSCallAccessor(call).argument_count());\n\n            // The scheduler is smart enough to place our code; we just ensure {control}\n            // becomes the control input of the start of the inlinee, and {effect} becomes\n            // the effect input of the start of the inlinee.\n            Node* control = NodeProperties::GetControlInput(call);\n            Node* effect = NodeProperties::GetEffectInput(call);\n\n            int const inlinee_new_target_index = start.NewTargetOutputIndex();\n            int const inlinee_arity_index = start.ArgCountOutputIndex();\n            int const inlinee_context_index = start.ContextOutputIndex();\n\n            // {inliner_inputs} counts the target, receiver/new_target, and arguments; but\n            // not feedback vector, context, effect or control.\n            const int inliner_inputs = argument_count +\n                                        JSCallOrConstructNode::kExtraInputCount -\n                                        JSCallOrConstructNode::kFeedbackVectorInputCount;\n            // Iterate over all uses of the start node.\n            for (Edge edge : start->use_edges()) {\n                Node* use = edge.from();\n                switch (use->opcode()) {\n                    case IrOpcode::kParameter: {\n                        int index = 1 + ParameterIndexOf(use->op());\n                        DCHECK_LE(index, inlinee_context_index);\n                        if (index < inliner_inputs && index < inlinee_new_target_index) {\n                            // There is an input from the call, and the index is a value\n                            // projection but not the context, so rewire the input.\n                            Replace(use, call->InputAt(index));\n                        } else if (index == inlinee_new_target_index) {\n                            // The projection is requesting the new target value.\n                            Replace(use, new_target);\n                        } else if (index == inlinee_arity_index) {\n                            // The projection is requesting the number of arguments.\n                            Replace(use, jsgraph()->ConstantNoHole(argument_count));\n                        } else if (index == inlinee_context_index) {\n                            // The projection is requesting the inlinee function context.\n                            Replace(use, context);\n                        } else {\n#ifdef V8_JS_LINKAGE_INCLUDES_DISPATCH_HANDLE\n                            // Using the dispatch handle here isn't currently supported.\n                            DCHECK_NE(index, start.DispatchHandleOutputIndex());\n#endif\n                            // Call has fewer arguments than required, fill with undefined.\n                            Replace(use, jsgraph()->UndefinedConstant());\n                        }\n                        break;\n                    }\n                    default:\n                        if (NodeProperties::IsEffectEdge(edge)) {\n                            edge.UpdateTo(effect);\n                        } else if (NodeProperties::IsControlEdge(edge)) {\n                            edge.UpdateTo(control);\n                        } else if (NodeProperties::IsFrameStateEdge(edge)) {\n                            edge.UpdateTo(frame_state);\n                        } else {\n                            UNREACHABLE();\n                        }\n                        break;\n                }\n            }\n\n            if (exception_target != nullptr) {\n                // Link uncaught calls in the inlinee to {exception_target}\n                int subcall_count = static_cast<int>(uncaught_subcalls.size());\n                if (subcall_count > 0) {\n                    TRACE(\"Inlinee contains \" << subcall_count\n                                            << \" calls without local exception handler; \"\n                                            << \"linking to surrounding exception handler.\");\n                }\n                NodeVector on_exception_nodes(local_zone_);\n                for (Node* subcall : uncaught_subcalls) {\n                    Node* on_success = graph()->NewNode(common()->IfSuccess(), subcall);\n                    NodeProperties::ReplaceUses(subcall, subcall, subcall, on_success);\n                    NodeProperties::ReplaceControlInput(on_success, subcall);\n                    Node* on_exception =\n                        graph()->NewNode(common()->IfException(), subcall, subcall);\n                    on_exception_nodes.push_back(on_exception);\n                }\n\n                DCHECK_EQ(subcall_count, static_cast<int>(on_exception_nodes.size()));\n                if (subcall_count > 0) {\n                    Node* control_output =\n                        graph()->NewNode(common()->Merge(subcall_count), subcall_count,\n                                        &on_exception_nodes.front());\n                    NodeVector values_effects(local_zone_);\n                    values_effects = on_exception_nodes;\n                    values_effects.push_back(control_output);\n                    Node* value_output = graph()->NewNode(\n                        common()->Phi(MachineRepresentation::kTagged, subcall_count),\n                        subcall_count + 1, &values_effects.front());\n                    Node* effect_output =\n                        graph()->NewNode(common()->EffectPhi(subcall_count),\n                                        subcall_count + 1, &values_effects.front());\n                    ReplaceWithValue(exception_target, value_output, effect_output,\n                                    control_output);\n                } else {\n                    ReplaceWithValue(exception_target, exception_target, exception_target,\n                                    jsgraph()->Dead());\n                }\n            }\n\n            NodeVector values(local_zone_);\n            NodeVector effects(local_zone_);\n            NodeVector controls(local_zone_);\n            for (Node* const input : end->inputs()) {\n                switch (input->opcode()) {\n                    case IrOpcode::kReturn:\n                        values.push_back(NodeProperties::GetValueInput(input, 1));\n                        effects.push_back(NodeProperties::GetEffectInput(input));\n                        controls.push_back(NodeProperties::GetControlInput(input));\n                        break;\n                    case IrOpcode::kDeoptimize:\n                    case IrOpcode::kTerminate:\n                    case IrOpcode::kThrow:\n                        MergeControlToEnd(graph(), common(), input);\n                        break;\n                    default:\n                        UNREACHABLE();\n                }\n            }\n            DCHECK_EQ(values.size(), effects.size());\n            DCHECK_EQ(values.size(), controls.size());\n\n            // Depending on whether the inlinee produces a value, we either replace value\n            // uses with said value or kill value uses if no value can be returned.\n            if (!values.empty()) {\n                int const input_count = static_cast<int>(controls.size());\n                Node* control_output = graph()->NewNode(common()->Merge(input_count),\n                                                        input_count, &controls.front());\n                values.push_back(control_output);\n                effects.push_back(control_output);\n                Node* value_output = graph()->NewNode(\n                    common()->Phi(MachineRepresentation::kTagged, input_count),\n                    static_cast<int>(values.size()), &values.front());\n                Node* effect_output =\n                    graph()->NewNode(common()->EffectPhi(input_count),\n                                    static_cast<int>(effects.size()), &effects.front());\n                ReplaceWithValue(call, value_output, effect_output, control_output);\n                return Changed(value_output);\n            } else {\n                ReplaceWithValue(call, jsgraph()->Dead(), jsgraph()->Dead(),\n                                jsgraph()->Dead());\n                return Changed(call);\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CreateArtificialFrameState\",\n            \"parent\": \"JSInliner\",\n            \"about\": \"Creates an artificial frame state for inlined functions, used for deoptimization.\",\n            \"logic\": \"Creates a FrameState node with specified parameters, including function info, bytecode array, context, and callee. Used for inlining scenarios where a precise frame state is not available, especially in constructor calls or when inlining Wasm code.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node triggering the frame state creation (e.g., JSCall, JSConstruct)\"\n                },\n                {\n                    \"name\": \"outer_frame_state\",\n                    \"type\": \"FrameState\",\n                    \"purpose\": \"The outer frame state to chain to\"\n                },\n                {\n                    \"name\": \"argument_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of arguments to the function\"\n                },\n                {\n                    \"name\": \"frame_state_type\",\n                    \"type\": \"FrameStateType\",\n                    \"purpose\": \"The type of frame state (e.g., kConstructCreateStub, kWasmInlinedIntoJS)\"\n                },\n                {\n                    \"name\": \"shared\",\n                    \"type\": \"SharedFunctionInfoRef\",\n                    \"purpose\": \"Reference to the shared function info\"\n                },\n                {\n                    \"name\": \"maybe_bytecode_array\",\n                    \"type\": \"OptionalBytecodeArrayRef\",\n                    \"purpose\": \"Optional bytecode array reference\"\n                },\n                {\n                    \"name\": \"context\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The context for the frame state\"\n                },\n                {\n                    \"name\": \"callee\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The callee (function) for the frame state\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"FrameState\",\n                \"description\": \"The newly created frame state\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"FrameState\",\n                \"FrameStateType\",\n                \"SharedFunctionInfoRef\",\n                \"OptionalBytecodeArrayRef\",\n                \"common\",\n                \"graph\",\n                \"jsgraph\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            FrameState JSInliner::CreateArtificialFrameState(\n                Node* node, FrameState outer_frame_state, int argument_count,\n                FrameStateType frame_state_type, SharedFunctionInfoRef shared,\n                OptionalBytecodeArrayRef maybe_bytecode_array, Node* context,\n                Node* callee) {\n            const int argument_count_with_receiver =\n                argument_count + JSCallOrConstructNode::kReceiverOrNewTargetInputCount;\n            CHECK_LE(argument_count_with_receiver, kMaxUInt16);\n            IndirectHandle<BytecodeArray> bytecode_array_handle = {};\n            if (maybe_bytecode_array.has_value()) {\n                bytecode_array_handle = maybe_bytecode_array->object();\n            }\n            const FrameStateFunctionInfo* state_info =\n                common()->CreateFrameStateFunctionInfo(\n                    frame_state_type, argument_count_with_receiver, 0, 0, shared.object(),\n                    bytecode_array_handle);\n\n            const Operator* op = common()->FrameState(\n                BytecodeOffset::None(), OutputFrameStateCombine::Ignore(), state_info);\n            const Operator* op0 = common()->StateValues(0, SparseInputMask::Dense());\n            Node* node0 = graph()->NewNode(op0);\n\n            Node* params_node = nullptr;\n#if V8_ENABLE_WEBASSEMBLY\n            const bool skip_params =\n                frame_state_type == FrameStateType::kWasmInlinedIntoJS;\n#else\n            const bool skip_params = false;\n#endif\n            if (skip_params) {\n                // For wasm inlined into JS the frame state doesn't need to be used for\n                // deopts. Also, due to different calling conventions, there isn't a\n                // receiver at input 1. We still need to store an undefined node here as the\n                // code requires this state values to have at least 1 entry.\n                // TODO(mliedtke): Can we clean up the FrameState handling, so that wasm\n                // inline FrameStates are closer to JS FrameStates without affecting\n                // performance?\n                const Operator* op_param =\n                    common()->StateValues(1, SparseInputMask::Dense());\n                params_node = graph()->NewNode(op_param, jsgraph()->UndefinedConstant());\n            } else {\n                NodeVector params(local_zone_);\n                params.push_back(\n                    node->InputAt(JSCallOrConstructNode::ReceiverOrNewTargetIndex()));\n                for (int i = 0; i < argument_count; i++) {\n                    params.push_back(node->InputAt(JSCallOrConstructNode::ArgumentIndex(i)));\n                }\n                const Operator* op_param = common()->StateValues(\n                    static_cast<int>(params.size()), SparseInputMask::Dense());\n                params_node = graph()->NewNode(op_param, static_cast<int>(params.size()),\n                                                &params.front());\n            }\n            if (context == nullptr) context = jsgraph()->UndefinedConstant();\n            if (callee == nullptr) {\n                callee = node->InputAt(JSCallOrConstructNode::TargetIndex());\n            }\n            return FrameState{graph()->NewNode(op, params_node, node0, node0, context,\n                                                callee, outer_frame_state)};\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DetermineCallTarget\",\n            \"parent\": \"JSInliner\",\n            \"about\": \"Determines whether the call target of the given call node is statically known and returns the SharedFunctionInfo if it is.\",\n            \"logic\": \"Checks if the target is a constant JSFunction or a JSCreateClosure node. If so, retrieves the SharedFunctionInfo and performs checks like native context equality to determine if the target is a valid inlining candidate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The JSCall or JSConstruct node for which to determine the call target.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"OptionalSharedFunctionInfoRef\",\n                \"description\": \"An optional containing the SharedFunctionInfo if the call target is statically known and valid for inlining, std::nullopt otherwise.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"HeapObjectMatcher\",\n                \"JSFunctionRef\",\n                \"JSCreateClosureNode\",\n                \"FeedbackCellRef\",\n                \"FeedbackCellOf\",\n                \"broker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            OptionalSharedFunctionInfoRef JSInliner::DetermineCallTarget(Node* node) {\n            DCHECK(IrOpcode::IsInlineeOpcode(node->opcode()));\n            Node* target = node->InputAt(JSCallOrConstructNode::TargetIndex());\n            HeapObjectMatcher match(target);\n\n            // This reducer can handle both normal function calls as well a constructor\n            // calls whenever the target is a constant function object, as follows:\n            //  - JSCall(target:constant, receiver, args..., vector)\n            //  - JSConstruct(target:constant, new.target, args..., vector)\n            if (match.HasResolvedValue() && match.Ref(broker()).IsJSFunction()) {\n                JSFunctionRef function = match.Ref(broker()).AsJSFunction();\n\n                // The function might have not been called yet.\n                if (!function.feedback_vector(broker()).has_value()) {\n                    return std::nullopt;\n                }\n\n                // Disallow cross native-context inlining for now. This means that all parts\n                // of the resulting code will operate on the same global object. This also\n                // prevents cross context leaks, where we could inline functions from a\n                // different context and hold on to that context (and closure) from the code\n                // object.\n                // TODO(turbofan): We might want to revisit this restriction later when we\n                // have a need for this, and we know how to model different native contexts\n                // in the same graph in a compositional way.\n                if (!function.native_context(broker()).equals(\n                        broker()->target_native_context())) {\n                    return std::nullopt;\n                }\n\n                return function.shared(broker());\n            }\n\n            // This reducer can also handle calls where the target is statically known to\n            // be the result of a closure instantiation operation, as follows:\n            //  - JSCall(JSCreateClosure[shared](context), receiver, args..., vector)\n            //  - JSConstruct(JSCreateClosure[shared](context),\n            //                new.target, args..., vector)\n            if (match.IsJSCreateClosure()) {\n                JSCreateClosureNode n(target);\n                FeedbackCellRef cell = n.GetFeedbackCellRefChecked(broker());\n                return cell.shared_function_info(broker());\n            } else if (match.IsCheckClosure()) {\n                FeedbackCellRef cell = MakeRef(broker(), FeedbackCellOf(match.op()));\n                return cell.shared_function_info(broker());\n            }\n\n            return std::nullopt;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DetermineCallContext\",\n            \"parent\": \"JSInliner\",\n            \"about\": \"Determines statically known information about the call target, particularly the context and feedback vector.\",\n            \"logic\": \"Checks if the target is a constant JSFunction or a JSCreateClosure node. If JSFunction, retrieves the context directly. If JSCreateClosure, uses the context from the instantiation site.  Returns the feedback cell.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The JSCall or JSConstruct node.\"\n                },\n                {\n                    \"name\": \"context_out\",\n                    \"type\": \"Node**\",\n                    \"purpose\": \"Output parameter to store the context node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"FeedbackCellRef\",\n                \"description\": \"The feedback cell associated with the call target.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"HeapObjectMatcher\",\n                \"JSFunctionRef\",\n                \"JSCreateClosureNode\",\n                \"FeedbackCellRef\",\n                \"FeedbackCellOf\",\n                \"AccessBuilder\",\n                \"simplified\",\n                \"graph\",\n                \"broker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            FeedbackCellRef JSInliner::DetermineCallContext(Node* node,\n                                                        Node** context_out) {\n            DCHECK(IrOpcode::IsInlineeOpcode(node->opcode()));\n            Node* target = node->InputAt(JSCallOrConstructNode::TargetIndex());\n            HeapObjectMatcher match(target);\n\n            if (match.HasResolvedValue() && match.Ref(broker()).IsJSFunction()) {\n                JSFunctionRef function = match.Ref(broker()).AsJSFunction();\n                // This was already ensured by DetermineCallTarget\n                CHECK(function.feedback_vector(broker()).has_value());\n\n                // The inlinee specializes to the context from the JSFunction object.\n                *context_out =\n                    jsgraph()->ConstantNoHole(function.context(broker()), broker());\n                return function.raw_feedback_cell(broker());\n            }\n\n            if (match.IsJSCreateClosure()) {\n                // Load the feedback vector of the target by looking up its vector cell at\n                // the instantiation site (we only decide to inline if it's populated).\n                JSCreateClosureNode n(target);\n                FeedbackCellRef cell = n.GetFeedbackCellRefChecked(broker());\n\n                // The inlinee uses the locally provided context at instantiation.\n                *context_out = NodeProperties::GetContextInput(match.node());\n                return cell;\n            } else if (match.IsCheckClosure()) {\n                FeedbackCellRef cell = MakeRef(broker(), FeedbackCellOf(match.op()));\n\n                Node* effect = NodeProperties::GetEffectInput(node);\n                Node* control = NodeProperties::GetControlInput(node);\n                *context_out = effect = graph()->NewNode(\n                    simplified()->LoadField(AccessBuilder::ForJSFunctionContext()),\n                    match.node(), effect, control);\n                NodeProperties::ReplaceEffectInput(node, effect);\n\n                return cell;\n            }\n\n            // Must succeed.\n            UNREACHABLE();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceJSCall\",\n            \"parent\": \"JSInliner\",\n            \"about\": \"Reduces a JSCall or JSConstruct node by inlining the target function.\",\n            \"logic\": \"Determines the call target, checks inlineability, and then inlines the function's graph into the current graph. Handles constructor calls, sloppy callees, and extra arguments. Creates artificial frame states as needed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The JSCall or JSConstruct node to be inlined.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"Indicates whether the reduction (inlining) changed the graph.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"JSCallAccessor\",\n                \"DetermineCallTarget\",\n                \"DetermineCallContext\",\n                \"BytecodeArrayRef\",\n                \"AddInlinedFunction\",\n                \"BytecodeGraphBuilder\",\n                \"AllNodes\",\n                \"FrameState\",\n                \"javascript\",\n                \"simplified\",\n                \"common\",\n                \"InlineCall\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Reduction JSInliner::ReduceJSCall(Node* node) {\n            DCHECK(IrOpcode::IsInlineeOpcode(node->opcode()));\n#if V8_ENABLE_WEBASSEMBLY\n            DCHECK_NE(node->opcode(), IrOpcode::kJSWasmCall);\n#endif  // V8_ENABLE_WEBASSEMBLY\n            JSCallAccessor call(node);\n\n            // Determine the call target.\n            OptionalSharedFunctionInfoRef shared_info(DetermineCallTarget(node));\n            if (!shared_info.has_value()) return NoChange();\n\n            SharedFunctionInfoRef outer_shared_info =\n                MakeRef(broker(), info_->shared_info());\n\n            SharedFunctionInfo::Inlineability inlineability =\n                shared_info->GetInlineability(broker());\n            if (inlineability != SharedFunctionInfo::kIsInlineable) {\n                // The function is no longer inlineable. The only way this can happen is if\n                // the function had its optimization disabled in the meantime, e.g. because\n                // another optimization job failed too often.\n                CHECK_EQ(inlineability, SharedFunctionInfo::kHasOptimizationDisabled);\n                TRACE(\"Not inlining \" << *shared_info << \" into \" << outer_shared_info\n                                    << \" because it had its optimization disabled.\");\n                return NoChange();\n            }\n            // NOTE: Even though we bailout in the kHasOptimizationDisabled case above, we\n            // won't notice if the function's optimization is disabled after this point.\n\n            // Constructor must be constructable.\n            if (node->opcode() == IrOpcode::kJSConstruct &&\n                !IsConstructable(shared_info->kind())) {\n                TRACE(\"Not inlining \" << *shared_info << \" into \" << outer_shared_info\n                                    << \" because constructor is not constructable.\");\n                return NoChange();\n            }\n\n            // Class constructors are callable, but [[Call]] will raise an exception.\n            // See ES6 section 9.2.1 [[Call]] ( thisArgument, argumentsList ).\n            if (node->opcode() == IrOpcode::kJSCall &&\n                IsClassConstructor(shared_info->kind())) {\n                TRACE(\"Not inlining \" << *shared_info << \" into \" << outer_shared_info\n                                    << \" because callee is a class constructor.\");\n                return NoChange();\n            }\n\n            // To ensure inlining always terminates, we have an upper limit on inlining\n            // the nested calls.\n            int nesting_level = 0;\n            for (Node* frame_state = call.frame_state();\n                frame_state->opcode() == IrOpcode::kFrameState;\n                frame_state = FrameState{frame_state}.outer_frame_state()) {\n                nesting_level++;\n                if (nesting_level > kMaxDepthForInlining) {\n                    TRACE(\"Not inlining \"\n                            << *shared_info << \" into \" << outer_shared_info\n                            << \" because call has exceeded the maximum depth for function \"\n                            \"inlining.\");\n                    return NoChange();\n                }\n            }\n\n            Node* exception_target = nullptr;\n            NodeProperties::IsExceptionalCall(node, &exception_target);\n\n            // JSInliningHeuristic has already filtered candidates without a BytecodeArray\n            // based on SharedFunctionInfoRef::GetInlineability. For the inlineable ones\n            // (kIsInlineable), the broker holds a reference to the bytecode array, which\n            // prevents it from getting flushed.  Therefore, the following check should\n            // always hold true.\n            CHECK(shared_info->is_compiled());\n\n            if (info_->source_positions() &&\n                !shared_info->object()->AreSourcePositionsAvailable(\n                    broker()->local_isolate_or_isolate())) {\n                // This case is expected to be very rare, since we generate source\n                // positions for all functions when debugging or profiling are turned\n                // on (see Isolate::NeedsDetailedOptimizedCodeLineInfo). Source\n                // positions should only be missing here if there is a race between 1)\n                // enabling/disabling the debugger/profiler, and 2) this compile job.\n                // In that case, we simply don't inline.\n                TRACE(\"Not inlining \" << *shared_info << \" into \" << outer_shared_info\n                                    << \" because source positions are missing.\");\n                return NoChange();\n            }\n\n            // Determine the target's feedback vector and its context.\n            Node* context;\n            FeedbackCellRef feedback_cell = DetermineCallContext(node, &context);\n\n            TRACE(\"Inlining \" << *shared_info << \" into \" << outer_shared_info\n                            << ((exception_target != nullptr) ? \" (inside try-block)\"\n                                                            : \"\"));\n            // ----------------------------------------------------------------\n            // After this point, we've made a decision to inline this function.\n            // We shall not bailout from inlining if we got here.\n\n            BytecodeArrayRef bytecode_array = shared_info->GetBytecodeArray(broker());\n\n            // Remember that we inlined this function.\n            int inlining_id =\n                info_->AddInlinedFunction(shared_info->object(), bytecode_array.object(),\n                                        source_positions_->GetSourcePosition(node));\n            if (v8_flags.profile_guided_optimization &&\n                feedback_cell.feedback_vector(broker()).has_value() &&\n                feedback_cell.feedback_vector(broker())\n                        .value()\n                        .object()\n                        ->invocation_count_before_stable(kRelaxedLoad) >\n                    v8_flags.invocation_count_for_early_optimization) {\n                info_->set_could_not_inline_all_candidates();\n            }\n\n            // Create the subgraph for the inlinee.\n            Node* start_node;\n            Node* end;\n            {\n                // Run the BytecodeGraphBuilder to create the subgraph.\n                TFGraph::SubgraphScope scope(graph());\n                BytecodeGraphBuilderFlags flags(\n                    BytecodeGraphBuilderFlag::kSkipFirstStackAndTierupCheck);\n                if (info_->analyze_environment_liveness()) {\n                    flags |= BytecodeGraphBuilderFlag::kAnalyzeEnvironmentLiveness;\n                }\n                if (info_->bailout_on_uninitialized()) {\n                    flags |= BytecodeGraphBuilderFlag::kBailoutOnUninitialized;\n                }\n                {\n                    CallFrequency frequency = call.frequency();\n"
}