{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-wasm.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 40, column 58",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-wasm.h\",\n        \"file_name\": \"v8-wasm.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the V8 API for WebAssembly integration, including classes for compiled modules, memory objects, module objects, and streaming compilation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8 internal headers required for WebAssembly support.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <functional>\n            #include <memory>\n            #include <string>\n\n            #include \"v8-internal.h\"      // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n            #include \"v8-memory-span.h\"   // NOLINT(build/include_directory)\n            #include \"v8-object.h\"        // NOLINT(build/include_directory)\n            #include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"OwnedBuffer\",\n            \"about\": \"Represents an owned byte buffer with an associated size. Used for passing data ownership.\",\n            \"attributes\": [\n                {\n                    \"name\": \"buffer\",\n                    \"type\": \"std::unique_ptr<const uint8_t[]>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The buffer containing the data.\"\n                },\n                {\n                    \"name\": \"size\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The size of the buffer.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct OwnedBuffer {\n            std::unique_ptr<const uint8_t[]> buffer;\n            size_t size = 0;\n            OwnedBuffer(std::unique_ptr<const uint8_t[]> buffer, size_t size)\n                : buffer(std::move(buffer)), size(size) {}\n            OwnedBuffer() = default;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CompiledWasmModule\",\n            \"about\": \"Wrapper around a compiled WebAssembly module, potentially shared by different WasmModuleObjects.\",\n            \"attributes\": [\n                {\n                    \"name\": \"native_module_\",\n                    \"type\": \"std::shared_ptr<internal::wasm::NativeModule>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A shared pointer to the internal NativeModule representation.\"\n                },\n                {\n                    \"name\": \"source_url_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The URL of the source code used to compile the module.\"\n                }\n            ],\n            \"dependencies\": [\n                \"internal::wasm::NativeModule\",\n                \"MemorySpan\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT CompiledWasmModule {\n            public:\n            /**\n             * Serialize the compiled module. The serialized data does not include the\n             * wire bytes.\n             */\n            OwnedBuffer Serialize();\n\n            /**\n             * Get the (wasm-encoded) wire bytes that were used to compile this module.\n             */\n            MemorySpan<const uint8_t> GetWireBytesRef();\n\n            const std::string& source_url() const { return source_url_; }\n\n            private:\n            friend class WasmModuleObject;\n            friend class WasmStreaming;\n\n            explicit CompiledWasmModule(std::shared_ptr<internal::wasm::NativeModule>,\n                                        const char* source_url, size_t url_length);\n\n            const std::shared_ptr<internal::wasm::NativeModule> native_module_;\n            const std::string source_url_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmMemoryObject\",\n            \"extends\": \"Object\",\n            \"about\": \"Represents an instance of WebAssembly.Memory.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ArrayBuffer\",\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT WasmMemoryObject : public Object {\n            public:\n            WasmMemoryObject() = delete;\n\n            /**\n             * Returns underlying ArrayBuffer.\n             */\n            Local<ArrayBuffer> Buffer();\n\n            V8_INLINE static WasmMemoryObject* Cast(Value* value) {\n            #ifdef V8_ENABLE_CHECKS\n                CheckCast(value);\n            #endif\n            return static_cast<WasmMemoryObject*>(value);\n            }\n\n            private:\n            static void CheckCast(Value* object);\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmModuleObject\",\n            \"extends\": \"Object\",\n            \"about\": \"Represents an instance of WebAssembly.Module.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CompiledWasmModule\",\n                \"Isolate\",\n                \"MemorySpan\",\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT WasmModuleObject : public Object {\n            public:\n            WasmModuleObject() = delete;\n\n            /**\n             * Efficiently re-create a WasmModuleObject, without recompiling, from\n             * a CompiledWasmModule.\n             */\n            static MaybeLocal<WasmModuleObject> FromCompiledModule(\n                Isolate* isolate, const CompiledWasmModule&);\n\n            /**\n             * Get the compiled module for this module object. The compiled module can be\n             * shared by several module objects.\n             */\n            CompiledWasmModule GetCompiledModule();\n\n            /**\n             * Compile a Wasm module from the provided uncompiled bytes.\n             */\n            static MaybeLocal<WasmModuleObject> Compile(\n                Isolate* isolate, MemorySpan<const uint8_t> wire_bytes);\n\n            V8_INLINE static WasmModuleObject* Cast(Value* value) {\n            #ifdef V8_ENABLE_CHECKS\n                CheckCast(value);\n            #endif\n            return static_cast<WasmModuleObject*>(value);\n            }\n\n            private:\n            static void CheckCast(Value* obj);\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmStreaming\",\n            \"about\": \"The V8 interface for WebAssembly streaming compilation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"impl_\",\n                    \"type\": \"std::unique_ptr<WasmStreamingImpl>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the internal implementation.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Value\",\n                \"CompiledWasmModule\",\n                \"WasmStreaming::WasmStreamingImpl\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT WasmStreaming final {\n            public:\n            static constexpr internal::ExternalPointerTag kManagedTag =\n                internal::kWasmWasmStreamingTag;\n            class WasmStreamingImpl;\n\n            explicit WasmStreaming(std::unique_ptr<WasmStreamingImpl> impl);\n\n            ~WasmStreaming();\n\n            /**\n             * Pass a new chunk of bytes to WebAssembly streaming compilation.\n             * The buffer passed into {OnBytesReceived} is owned by the caller.\n             */\n            void OnBytesReceived(const uint8_t* bytes, size_t size);\n\n            /**\n             * {Finish} should be called after all received bytes where passed to\n             * {OnBytesReceived} to tell V8 that there will be no more bytes. {Finish}\n             * must not be called after {Abort} has been called already.\n             * If {can_use_compiled_module} is true and {SetCompiledModuleBytes} was\n             * previously called, the compiled module bytes can be used.\n             * If {can_use_compiled_module} is false, the compiled module bytes previously\n             * set by {SetCompiledModuleBytes} should not be used.\n             */\n            void Finish(bool can_use_compiled_module = true);\n\n            /**\n             * Abort streaming compilation. If {exception} has a value, then the promise\n             * associated with streaming compilation is rejected with that value. If\n             * {exception} does not have value, the promise does not get rejected.\n             * {Abort} must not be called repeatedly, or after {Finish}.\n             */\n            void Abort(MaybeLocal<Value> exception);\n\n            /**\n             * Passes previously compiled module bytes. This must be called before\n             * {OnBytesReceived}, {Finish}, or {Abort}. Returns true if the module bytes\n             * can be used, false otherwise. The buffer passed via {bytes} and {size}\n             * is owned by the caller. If {SetCompiledModuleBytes} returns true, the\n             * buffer must remain valid until either {Finish} or {Abort} completes.\n             * The compiled module bytes should not be used until {Finish(true)} is\n             * called, because they can be invalidated later by {Finish(false)}.\n             */\n            bool SetCompiledModuleBytes(const uint8_t* bytes, size_t size);\n\n            /**\n             * Sets a callback which is called whenever a significant number of new\n             * functions are ready for serialization.\n             */\n            void SetMoreFunctionsCanBeSerializedCallback(\n                std::function<void(CompiledWasmModule)>);\n\n            /*\n             * Sets the UTF-8 encoded source URL for the {Script} object. This must be\n             * called before {Finish}.\n             */\n            void SetUrl(const char* url, size_t length);\n\n            /**\n             * Unpacks a {WasmStreaming} object wrapped in a  {Managed} for the embedder.\n             * Since the embedder is on the other side of the API, it cannot unpack the\n             * {Managed} itself.\n             */\n            static std::shared_ptr<WasmStreaming> Unpack(Isolate* isolate,\n                                                        Local<Value> value);\n\n            private:\n            std::unique_ptr<WasmStreamingImpl> impl_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmMemoryMapDescriptor\",\n            \"extends\": \"Object\",\n            \"about\": \"The V8 interface for a WebAssembly memory map descriptor (experimental).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Value\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT WasmMemoryMapDescriptor : public Object {\n            public:\n            WasmMemoryMapDescriptor() = delete;\n\n            V8_INLINE static WasmMemoryMapDescriptor* Cast(Value* value) {\n            #ifdef V8_ENABLE_CHECKS\n                CheckCast(value);\n            #endif\n            return static_cast<WasmMemoryMapDescriptor*>(value);\n            }\n\n            using WasmFileDescriptor = int32_t;\n\n            static Local<WasmMemoryMapDescriptor> New(Isolate* isolate,\n                                                    WasmFileDescriptor fd);\n\n            private:\n            static void CheckCast(Value* object);\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmStreaming::WasmStreamingImpl\",\n            \"about\": \"Forward declaration for inner class of WasmStreaming\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class WasmStreaming final {\n            public:\n                class WasmStreamingImpl;\n            };\n        ]]></code>\n    </class>\n        \n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Object\",\n                \"about\": \"Base class for V8 objects\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Object {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Value\",\n                \"about\": \"Base class for V8 values\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Value {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"V8 isolate\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ArrayBuffer\",\n                \"about\": \"V8 ArrayBuffer\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ArrayBuffer {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MaybeLocal\",\n                \"about\": \"Represents a value that might not be present\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> class MaybeLocal {};\n            ]]></code>\n        </class>\n                <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Local\",\n                \"about\": \"Represents a local handle to a V8 object\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> class Local {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MemorySpan\",\n                \"about\": \"Represents a span of memory\"\n            }\n            </metadata>\n            <code><![CDATA[\n            template <typename T>\n            class MemorySpan {\n                public:\n                const T* data() const;\n                size_t size() const;\n            };\n            ]]></code>\n        </class>\n\n    </dependencies>\n</file>\n```"
}