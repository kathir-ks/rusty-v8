{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-js.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/asmjs/asm-js.cc\",\n        \"file_name\": \"asm-js.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implementation of asm.js compilation and instantiation within the V8 JavaScript engine, leveraging WebAssembly.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for asm.js functionality, data structures, and V8 APIs.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/asmjs/asm-js.h\"\n\n            #include <optional>\n\n            #include \"src/asmjs/asm-names.h\"\n            #include \"src/asmjs/asm-parser.h\"\n            #include \"src/ast/ast.h\"\n            #include \"src/base/platform/elapsed-timer.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/codegen/compiler.h\"\n            #include \"src/codegen/unoptimized-compilation-info.h\"\n            #include \"src/common/assert-scope.h\"\n            #include \"src/common/message-template.h\"\n            #include \"src/execution/execution.h\"\n            #include \"src/execution/isolate.h\"\n            #include \"src/handles/handles.h\"\n            #include \"src/heap/factory.h\"\n            #include \"src/logging/counters.h\"\n            #include \"src/objects/heap-number-inl.h\"\n            #include \"src/objects/objects-inl.h\"\n            #include \"src/parsing/parse-info.h\"\n            #include \"src/parsing/scanner-character-streams.h\"\n            #include \"src/parsing/scanner.h\"\n            #include \"src/wasm/wasm-engine.h\"\n            #include \"src/wasm/wasm-js.h\"\n            #include \"src/wasm/wasm-limits.h\"\n            #include \"src/wasm/wasm-module-builder.h\"\n            #include \"src/wasm/wasm-objects-inl.h\"\n            #include \"src/wasm/wasm-result.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsmJs\",\n            \"about\": \"Provides static methods for compiling and instantiating asm.js code using WebAssembly.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            namespace internal {\n\n            const char* const AsmJs::kSingleFunctionName = \"__single_function__\";\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"StdlibMathMember\",\n            \"about\": \"Retrieves a member of the Math object within the standard library object.\",\n            \"logic\": \"Accesses the Math object, then accesses the specified member. Returns undefined if Math is not a JSReceiver or the member is not found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"stdlib\",\n                    \"type\": \"DirectHandle<JSReceiver>\",\n                    \"purpose\": \"The standard library object.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"DirectHandle<Name>\",\n                    \"purpose\": \"The name of the Math object member to retrieve.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DirectHandle<Object>\",\n                \"description\": \"The requested Math object member, or undefined if not found or if the stdlib isn't correct.\"\n            },\n            \"dependencies\": [\n                \"JSReceiver\",\n                \"Name\",\n                \"Object\",\n                \"base::StaticCharVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n\n            DirectHandle<Object> StdlibMathMember(Isolate* isolate,\n                                                  DirectHandle<JSReceiver> stdlib,\n                                                  DirectHandle<Name> name) {\n              DirectHandle<Name> math_name(\n                  isolate->factory()->InternalizeString(base::StaticCharVector(\"Math\")));\n              DirectHandle<Object> math =\n                  JSReceiver::GetDataProperty(isolate, stdlib, math_name);\n              if (!IsJSReceiver(*math)) return isolate->factory()->undefined_value();\n              DirectHandle<JSReceiver> math_receiver = Cast<JSReceiver>(math);\n              return JSReceiver::GetDataProperty(isolate, math_receiver, name);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AreStdlibMembersValid\",\n            \"about\": \"Validates that the standard library object contains the expected members with the correct values/types.\",\n            \"logic\": \"Checks for the presence and correct values/types of standard Math functions, constants, and TypedArray constructors within the provided standard library object. Returns false if any of the checks fail.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"stdlib\",\n                    \"type\": \"DirectHandle<JSReceiver>\",\n                    \"purpose\": \"The standard library object to validate.\"\n                },\n                {\n                    \"name\": \"members\",\n                    \"type\": \"wasm::AsmJsParser::StdlibSet\",\n                    \"purpose\": \"A set of standard library members that are expected to be present.\"\n                },\n                {\n                    \"name\": \"is_typed_array\",\n                    \"type\": \"bool*\",\n                    \"purpose\": \"Output parameter to indicate if any TypedArray constructors are present in the stdlib\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all expected members are valid, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"JSReceiver\",\n                \"Name\",\n                \"Object\",\n                \"std::isinf\",\n                \"IsNaN\",\n                \"StdlibMathMember\",\n                \"base::StaticCharVector\",\n                \"wasm::AsmJsParser::StdlibSet\",\n                \"Builtin\",\n                \"SharedFunctionInfo\",\n                \"JSFunction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool AreStdlibMembersValid(Isolate* isolate, DirectHandle<JSReceiver> stdlib,\n                                   wasm::AsmJsParser::StdlibSet members,\n                                   bool* is_typed_array) {\n              if (members.contains(wasm::AsmJsParser::StandardMember::kInfinity)) {\n                members.Remove(wasm::AsmJsParser::StandardMember::kInfinity);\n                DirectHandle<Name> name = isolate->factory()->Infinity_string();\n                DirectHandle<Object> value =\n                    JSReceiver::GetDataProperty(isolate, stdlib, name);\n                if (!IsNumber(*value) || !std::isinf(Object::NumberValue(*value)))\n                  return false;\n              }\n              if (members.contains(wasm::AsmJsParser::StandardMember::kNaN)) {\n                members.Remove(wasm::AsmJsParser::StandardMember::kNaN);\n                DirectHandle<Name> name = isolate->factory()->NaN_string();\n                DirectHandle<Object> value =\n                    JSReceiver::GetDataProperty(isolate, stdlib, name);\n                if (!IsNaN(*value)) return false;\n              }\n            #define STDLIB_MATH_FUNC(fname, FName, ignore1, ignore2)                   \\\n              if (members.contains(wasm::AsmJsParser::StandardMember::kMath##FName)) { \\\n                members.Remove(wasm::AsmJsParser::StandardMember::kMath##FName);       \\\n                DirectHandle<Name> name(isolate->factory()->InternalizeString(         \\\n                    base::StaticCharVector(#fname)));                                  \\\n                DirectHandle<Object> value = StdlibMathMember(isolate, stdlib, name);  \\\n                if (!IsJSFunction(*value)) return false;                               \\\n                Tagged<SharedFunctionInfo> shared = Cast<JSFunction>(value)->shared(); \\\n                if (!shared->HasBuiltinId() ||                                         \\\n                    shared->builtin_id() != Builtin::kMath##FName) {                   \\\n                  return false;                                                        \\\n                }                                                                      \\\n                DCHECK_EQ(shared->GetCode(isolate),                                    \\\n                          isolate->builtins()->code(Builtin::kMath##FName));           \\\n              }\n              STDLIB_MATH_FUNCTION_LIST(STDLIB_MATH_FUNC)\n            #undef STDLIB_MATH_FUNC\n            #define STDLIB_MATH_CONST(cname, const_value)                              \\\n              if (members.contains(wasm::AsmJsParser::StandardMember::kMath##cname)) { \\\n                members.Remove(wasm::AsmJsParser::StandardMember::kMath##cname);       \\\n                DirectHandle<Name> name(isolate->factory()->InternalizeString(         \\\n                    base::StaticCharVector(#cname)));                                  \\\n                DirectHandle<Object> value = StdlibMathMember(isolate, stdlib, name);  \\\n                if (!IsNumber(*value) || Object::NumberValue(*value) != const_value)   \\\n                  return false;                                                        \\\n              }\n              STDLIB_MATH_VALUE_LIST(STDLIB_MATH_CONST)\n            #undef STDLIB_MATH_CONST\n            #define STDLIB_ARRAY_TYPE(fname, FName)                                \\\n              if (members.contains(wasm::AsmJsParser::StandardMember::k##FName)) { \\\n                members.Remove(wasm::AsmJsParser::StandardMember::k##FName);       \\\n                *is_typed_array = true;                                            \\\n                DirectHandle<Name> name(isolate->factory()->InternalizeString(     \\\n                    base::StaticCharVector(#FName)));                              \\\n                DirectHandle<Object> value =                                       \\\n                    JSReceiver::GetDataProperty(isolate, stdlib, name);            \\\n                if (!IsJSFunction(*value)) return false;                           \\\n                DirectHandle<JSFunction> func = Cast<JSFunction>(value);           \\\n                if (!func.is_identical_to(isolate->fname())) return false;         \\\n              }\n              STDLIB_ARRAY_TYPE(int8_array_fun, Int8Array)\n              STDLIB_ARRAY_TYPE(uint8_array_fun, Uint8Array)\n              STDLIB_ARRAY_TYPE(int16_array_fun, Int16Array)\n              STDLIB_ARRAY_TYPE(uint16_array_fun, Uint16Array)\n              STDLIB_ARRAY_TYPE(int32_array_fun, Int32Array)\n              STDLIB_ARRAY_TYPE(uint32_array_fun, Uint32Array)\n              STDLIB_ARRAY_TYPE(float32_array_fun, Float32Array)\n              STDLIB_ARRAY_TYPE(float64_array_fun, Float64Array)\n            #undef STDLIB_ARRAY_TYPE\n              // All members accounted for.\n              DCHECK(members.empty());\n              return true;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Report\",\n            \"about\": \"Reports a message related to asm.js compilation or instantiation.\",\n            \"logic\": \"Creates a message object with the given text, position, and template, and reports it using the MessageHandler.\",\n            \"parameters\": [\n                {\n                    \"name\": \"script\",\n                    \"type\": \"Handle<Script>\",\n                    \"purpose\": \"The script associated with the message.\"\n                },\n                {\n                    \"name\": \"position\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The position in the script where the message occurred.\"\n                },\n                {\n                    \"name\": \"text\",\n                    \"type\": \"base::Vector<const char>\",\n                    \"purpose\": \"The text of the message.\"\n                },\n                {\n                    \"name\": \"message_template\",\n                    \"type\": \"MessageTemplate\",\n                    \"purpose\": \"The message template.\"\n                },\n                {\n                    \"name\": \"level\",\n                    \"type\": \"v8::Isolate::MessageErrorLevel\",\n                    \"purpose\": \"The error level of the message.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"Script\",\n                \"MessageHandler\",\n                \"MessageTemplate\",\n                \"JSMessageObject\",\n                \"MessageLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Report(Handle<Script> script, int position, base::Vector<const char> text,\n                        MessageTemplate message_template,\n                        v8::Isolate::MessageErrorLevel level) {\n              Isolate* isolate = script->GetIsolate();\n              MessageLocation location(script, position, position);\n              DirectHandle<String> text_object =\n                  isolate->factory()->InternalizeUtf8String(text);\n              DirectHandle<JSMessageObject> message = MessageHandler::MakeMessageObject(\n                  isolate, message_template, &location, text_object);\n              message->set_error_level(level);\n              MessageHandler::ReportMessage(isolate, &location, message);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ReportCompilationSuccess\",\n            \"about\": \"Reports a successful asm.js compilation.\",\n            \"logic\": \"Prints a message indicating the success, compilation time, and module size, if tracing is enabled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"script\",\n                    \"type\": \"Handle<Script>\",\n                    \"purpose\": \"The script associated with the compiled module.\"\n                },\n                {\n                    \"name\": \"position\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The position in the script where the compilation started.\"\n                },\n                {\n                    \"name\": \"compile_time\",\n                    \"type\": \"double\",\n                    \"purpose\": \"The compilation time in milliseconds.\"\n                },\n                {\n                    \"name\": \"module_size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The size of the compiled module in bytes.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Handle\",\n                \"Script\",\n                \"Report\",\n                \"base::EmbeddedVector\",\n                \"SNPrintF\",\n                \"MessageTemplate\",\n                \"v8::Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ReportCompilationSuccess(Handle<Script> script, int position,\n                                          double compile_time, size_t module_size) {\n              if (v8_flags.suppress_asm_messages || !v8_flags.trace_asm_time) return;\n              base::EmbeddedVector<char, 100> text;\n              int length = SNPrintF(text, \"success, compile time %0.3f ms, %zu bytes\",\n                                    compile_time, module_size);\n              CHECK_NE(-1, length);\n              text.Truncate(length);\n              Report(script, position, text, MessageTemplate::kAsmJsCompiled,\n                     v8::Isolate::kMessageInfo);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ReportCompilationFailure\",\n            \"about\": \"Reports a failed asm.js compilation.\",\n            \"logic\": \"Reports a warning with the given reason at the specified position in the script.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parse_info\",\n                    \"type\": \"ParseInfo*\",\n                    \"purpose\": \"The parse info for the script being compiled.\"\n                },\n                {\n                    \"name\": \"position\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The position in the script where the compilation failed.\"\n                },\n                {\n                    \"name\": \"reason\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The reason for the compilation failure.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ParseInfo\",\n                \"MessageTemplate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ReportCompilationFailure(ParseInfo* parse_info, int position,\n                                          const char* reason) {\n              if (v8_flags.suppress_asm_messages) return;\n              parse_info->pending_error_handler()->ReportWarningAt(\n                  position, position, MessageTemplate::kAsmJsInvalid, reason);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ReportInstantiationSuccess\",\n            \"about\": \"Reports a successful asm.js instantiation.\",\n            \"logic\": \"Prints a message indicating the success and instantiation time, if tracing is enabled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"script\",\n                    \"type\": \"Handle<Script>\",\n                    \"purpose\": \"The script associated with the instantiated module.\"\n                },\n                {\n                    \"name\": \"position\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The position in the script where the instantiation started.\"\n                },\n                {\n                    \"name\": \"instantiate_time\",\n                    \"type\": \"double\",\n                    \"purpose\": \"The instantiation time in milliseconds.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Handle\",\n                \"Script\",\n                \"Report\",\n                \"base::EmbeddedVector\",\n                \"SNPrintF\",\n                \"MessageTemplate\",\n                \"v8::Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ReportInstantiationSuccess(Handle<Script> script, int position,\n                                            double instantiate_time) {\n              if (v8_flags.suppress_asm_messages || !v8_flags.trace_asm_time) return;\n              base::EmbeddedVector<char, 50> text;\n              int length = SNPrintF(text, \"success, %0.3f ms\", instantiate_time);\n              CHECK_NE(-1, length);\n              text.Truncate(length);\n              Report(script, position, text, MessageTemplate::kAsmJsInstantiated,\n                     v8::Isolate::kMessageInfo);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ReportInstantiationFailure\",\n            \"about\": \"Reports a failed asm.js instantiation.\",\n            \"logic\": \"Reports a warning with the given reason at the specified position in the script.\",\n            \"parameters\": [\n                {\n                    \"name\": \"script\",\n                    \"type\": \"Handle<Script>\",\n                    \"purpose\": \"The script associated with the module being instantiated.\"\n                },\n                {\n                    \"name\": \"position\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The position in the script where the instantiation failed.\"\n                },\n                {\n                    \"name\": \"reason\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The reason for the instantiation failure.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Handle\",\n                \"Script\",\n                \"Report\",\n                \"base::Vector\",\n                \"base::CStrVector\",\n                \"MessageTemplate\",\n                \"v8::Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void ReportInstantiationFailure(Handle<Script> script, int position,\n                                            const char* reason) {\n              if (v8_flags.suppress_asm_messages) return;\n              base::Vector<const char> text = base::CStrVector(reason);\n              Report(script, position, text, MessageTemplate::kAsmJsLinkingFailed,\n                     v8::Isolate::kMessageWarning);\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsmJsCompilationJob\",\n            \"extends\": \"UnoptimizedCompilationJob\",\n            \"about\": \"A compilation job that translates asm.js to WebAssembly and then compiles the WebAssembly.\",\n            \"attributes\": [\n                {\n                    \"name\": \"allocator_\",\n                    \"type\": \"AccountingAllocator*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory allocator.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory zone for allocation.\"\n                },\n                {\n                    \"name\": \"compilation_info_\",\n                    \"type\": \"UnoptimizedCompilationInfo\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Compilation information.\"\n                },\n                {\n                    \"name\": \"module_\",\n                    \"type\": \"wasm::ZoneBuffer*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The WebAssembly module data.\"\n                },\n                {\n                    \"name\": \"asm_offsets_\",\n                    \"type\": \"wasm::ZoneBuffer*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Offsets for asm.js source mapping.\"\n                },\n                {\n                    \"name\": \"stdlib_uses_\",\n                    \"type\": \"wasm::AsmJsParser::StdlibSet\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A set of standard library members used by the asm.js module.\"\n                },\n                {\n                    \"name\": \"compile_time_\",\n                    \"type\": \"double\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Time taken for compilation.\"\n                },\n                {\n                    \"name\": \"module_source_size_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Size of the asm.js source.\"\n                }\n            ],\n            \"dependencies\": [\n                \"UnoptimizedCompilationJob\",\n                \"ParseInfo\",\n                \"FunctionLiteral\",\n                \"AccountingAllocator\",\n                \"wasm::ZoneBuffer\",\n                \"wasm::AsmJsParser::StdlibSet\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // The compilation of asm.js modules is split into two distinct steps:\n            //  [1] ExecuteJobImpl: The asm.js module source is parsed, validated, and\n            //      translated to a valid WebAssembly module. The result are two vectors\n            //      representing the encoded module as well as encoded source position\n            //      information and a StdlibSet bit set.\n            //  [2] FinalizeJobImpl: The module is handed to WebAssembly which decodes it\n            //      into an internal representation and eventually compiles it to machine\n            //      code.\n            class AsmJsCompilationJob final : public UnoptimizedCompilationJob {\n             public:\n              explicit AsmJsCompilationJob(ParseInfo* parse_info, FunctionLiteral* literal,\n                                           AccountingAllocator* allocator)\n                  : UnoptimizedCompilationJob(parse_info->stack_limit(), parse_info,\n                                              &compilation_info_),\n                    allocator_(allocator),\n                    zone_(allocator, ZONE_NAME),\n                    compilation_info_(&zone_, parse_info, literal),\n                    module_(nullptr),\n                    asm_offsets_(nullptr),\n                    compile_time_(0),\n                    module_source_size_(0) {}\n\n              AsmJsCompilationJob(const AsmJsCompilationJob&) = delete;\n              AsmJsCompilationJob& operator=(const AsmJsCompilationJob&) = delete;\n\n             protected:\n              Status ExecuteJobImpl() final;\n              Status FinalizeJobImpl(DirectHandle<SharedFunctionInfo> shared_info,\n                                     Isolate* isolate) final;\n              Status FinalizeJobImpl(DirectHandle<SharedFunctionInfo> shared_info,\n                                     LocalIsolate* isolate) final {\n                return CompilationJob::RETRY_ON_MAIN_THREAD;\n              }\n\n             private:\n              void RecordHistograms(Isolate* isolate);\n\n              AccountingAllocator* allocator_;\n              Zone zone_;\n              UnoptimizedCompilationInfo compilation_info_;\n              wasm::ZoneBuffer* module_;\n              wasm::ZoneBuffer* asm_offsets_;\n              wasm::AsmJsParser::StdlibSet stdlib_uses_;\n\n              double compile_time_;     // Time (milliseconds) taken to execute step [2].\n              int module_source_size_;  // Module source size in bytes.\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ExecuteJobImpl\",\n            \"parent\": \"AsmJsCompilationJob\",\n            \"about\": \"Translates asm.js module to a WebAssembly module.\",\n            \"logic\": \"Parses the asm.js source using AsmJsParser and translates it to a WebAssembly module, storing the module data and offset table. Reports compilation failure if parsing fails or the module size exceeds the limit.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Status\",\n                \"description\": \"SUCCEEDED if the translation was successful, FAILED otherwise.\"\n            },\n            \"dependencies\": [\n                \"Utf16CharacterStream\",\n                \"parse_info\",\n                \"wasm::AsmJsParser\",\n                \"ReportCompilationFailure\",\n                \"v8_flags\",\n                \"compilation_info\",\n                \"wasm::ZoneBuffer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            UnoptimizedCompilationJob::Status AsmJsCompilationJob::ExecuteJobImpl() {\n              DisallowHeapAccess no_heap_access;\n\n              // Step 1: Translate asm.js module to WebAssembly module.\n              Zone* compile_zone = &zone_;\n              Zone translate_zone(allocator_, ZONE_NAME);\n\n              Utf16CharacterStream* stream = parse_info()->character_stream();\n              std::optional<AllowHandleDereference> allow_deref;\n              if (stream->can_access_heap()) {\n                allow_deref.emplace();\n              }\n              stream->Seek(compilation_info()->literal()->start_position());\n              wasm::AsmJsParser parser(&translate_zone, stack_limit(), stream);\n              if (!parser.Run()) {\n                if (!v8_flags.suppress_asm_messages) {\n                  ReportCompilationFailure(parse_info(), parser.failure_location(),\n                                           parser.failure_message());\n                }\n                return FAILED;\n              }\n              module_ = compile_zone->New<wasm::ZoneBuffer>(compile_zone);\n              parser.module_builder()->WriteTo(module_);\n              if (module_->size() > v8_flags.wasm_max_module_size) {\n                if (!v8_flags.suppress_asm_messages) {\n                  ReportCompilationFailure(\n                      parse_info(), parser.failure_location(),\n                      \"Module size exceeds engine's supported maximum\");\n                }\n                return FAILED;\n              }\n              asm_offsets_ = compile_zone->New<wasm::ZoneBuffer>(compile_zone);\n              parser.module_builder()->WriteAsmJsOffsetTable(asm_offsets_);\n              stdlib_uses_ = *parser.stdlib_uses();\n\n              module_source_size_ = compilation_info()->literal()->end_position() -\n                                    compilation_info()->literal()->start_position();\n              return SUCCEEDED;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FinalizeJobImpl\",\n            \"parent\": \"AsmJsCompilationJob\",\n            \"about\": \"Compiles the WebAssembly module and records compilation statistics.\",\n            \"logic\": \"Compiles the WebAssembly module using `wasm::GetWasmEngine()->SyncCompileTranslatedAsmJs`. Records histograms and reports compilation success.\",\n            \"parameters\": [\n                {\n                    \"name\": \"shared_info\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"Shared function info for the compiled module.\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Status\",\n                \"description\": \"SUCCEEDED if the compilation was successful, FAILED otherwise.\"\n            },\n            \"dependencies\": [\n                \"wasm::GetWasmEngine\",\n                \"wasm::ErrorThrower\",\n                \"ReportCompilationSuccess\",\n                \"Isolate\",\n                \"SharedFunctionInfo\",\n                \"base::ElapsedTimer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            UnoptimizedCompilationJob::Status AsmJsCompilationJob::FinalizeJobImpl(\n                DirectHandle<SharedFunctionInfo> shared_info, Isolate* isolate) {\n              // Step 2: Compile and decode the WebAssembly module.\n              base::ElapsedTimer compile_timer;\n              compile_timer.Start();\n\n              DirectHandle<HeapNumber> uses_bitset =\n                  isolate->factory()->NewHeapNumberFromBits(stdlib_uses_.ToIntegral());\n\n              // The result is a compiled module and serialized standard library uses.\n              wasm::ErrorThrower thrower(isolate, \"AsmJs::Compile\");\n              Handle<Script> script(Cast<Script>(shared_info->script()), isolate);\n              Handle<AsmWasmData> result =\n                  wasm::GetWasmEngine()\n                      ->SyncCompileTranslatedAsmJs(\n                          isolate, &thrower, base::OwnedCopyOf(*module_), script,\n                          base::VectorOf(*asm_offsets_), uses_bitset,\n                          shared_info->language_mode())\n                      .ToHandleChecked();\n              DCHECK(!thrower.error());\n              compile_time_ = compile_timer.Elapsed().InMillisecondsF();\n\n              compilation_info()->SetAsmWasmData(result);\n\n              RecordHistograms(isolate);\n              ReportCompilationSuccess(script, shared_info->StartPosition(), compile_time_,\n                                       module_->size());\n              return SUCCEEDED;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RecordHistograms\",\n            \"parent\": \"AsmJsCompilationJob\",\n            \"about\": \"Records histograms related to asm.js module size.\",\n            \"logic\": \"Adds a sample to the asm_module_size_bytes counter with the module source size.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void AsmJsCompilationJob::RecordHistograms(Isolate* isolate) {\n              isolate->counters()->asm_module_size_bytes()->AddSample(module_source_size_);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"NewCompilationJob\",\n            \"about\": \"Creates a new AsmJsCompilationJob.\",\n            \"logic\": \"Allocates and returns a unique pointer to an AsmJsCompilationJob.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parse_info\",\n                    \"type\": \"ParseInfo*\",\n                    \"purpose\": \"The parse info.\"\n                },\n                {\n                    \"name\": \"literal\",\n                    \"type\": \"FunctionLiteral*\",\n                    \"purpose\": \"The function literal.\"\n                },\n                {\n                    \"name\": \"allocator\",\n                    \"type\": \"AccountingAllocator*\",\n                    \"purpose\": \"The memory allocator.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<UnoptimizedCompilationJob>\",\n                \"description\": \"A unique pointer to the created AsmJsCompilationJob.\"\n            },\n            \"dependencies\": [\n                \"AsmJsCompilationJob\",\n                \"ParseInfo\",\n                \"FunctionLiteral\",\n                \"AccountingAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::unique_ptr<UnoptimizedCompilationJob> AsmJs::NewCompilationJob(\n                ParseInfo* parse_info, FunctionLiteral* literal,\n                AccountingAllocator* allocator) {\n              return std::make_unique<AsmJsCompilationJob>(parse_info, literal, allocator);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsValidAsmjsMemorySize\",\n            \"about\": \"Checks if the provided size is valid for asm.js memory (ArrayBuffer).\",\n            \"logic\": \"Enforces asm.js spec minimum size, engine-limited maximum allocation size, power-of-2 sizes for 2^12 - 2^24, and multiple of 2^24 for sizes >= 2^24. Also checks that size is <= 2GiB.\",\n            \"parameters\": [\n                {\n                    \"name\": \"size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The size to validate.\"\n                }\n            ],\n            \"return\": {\n                \"type"
}