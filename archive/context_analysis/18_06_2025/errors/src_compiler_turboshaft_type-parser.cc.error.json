{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/type-parser.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 48, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/type-parser.cc\",\n            \"file_name\": \"type-parser.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Parses type strings and converts them into Type objects for Turboshaft.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for type parsing and standard optional type.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/type-parser.h\"\n\n#include <optional>\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ParseType\",\n                \"parent\": \"TypeParser\",\n                \"about\": \"Parses a type string and returns a Type object.\",\n                \"logic\": \"Consumes tokens to identify the type (Word32, Word64, Float32, Float64).  If a set or range is indicated (by '{' or '[' respectively) it calls the corresponding parsing function. Otherwise, it returns the 'Any' type for the consumed type.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"std::optional<Type>\",\n                    \"description\": \"The parsed Type object, or std::nullopt if parsing fails.\"\n                },\n                \"dependencies\": [\n                    \"ConsumeIf\",\n                    \"IsNext\",\n                    \"ParseSet\",\n                    \"ParseRange\",\n                    \"Word32Type\",\n                    \"Word64Type\",\n                    \"Float32Type\",\n                    \"Float64Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<Type> TypeParser::ParseType() {\n  if (ConsumeIf(\"Word32\")) {\n    if (IsNext(\"{\")) return ParseSet<Word32Type>();\n    if (IsNext(\"[\")) return ParseRange<Word32Type>();\n    return Word32Type::Any();\n  } else if (ConsumeIf(\"Word64\")) {\n    if (IsNext(\"{\")) return ParseSet<Word64Type>();\n    if (IsNext(\"[\")) return ParseRange<Word64Type>();\n    return Word64Type::Any();\n  } else if (ConsumeIf(\"Float32\")) {\n    // TODO(nicohartmann@): Handle NaN.\n    if (IsNext(\"{\")) return ParseSet<Float32Type>();\n    if (IsNext(\"[\")) return ParseRange<Float32Type>();\n    return Float64Type::Any();\n  } else if (ConsumeIf(\"Float64\")) {\n    // TODO(nicohartmann@): Handle NaN.\n    if (IsNext(\"{\")) return ParseSet<Float64Type>();\n    if (IsNext(\"[\")) return ParseRange<Float64Type>();\n    return Float64Type::Any();\n  } else {\n    return std::nullopt;\n  }\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TypeParser\",\n                \"about\": \"Class responsible for parsing type strings in Turboshaft.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8::internal::compiler::turboshaft {\n\nclass TypeParser {\n public:\n  std::optional<Type> ParseType();\n};\n\n}  // namespace v8::internal::compiler::turboshaft\n        ]]></code>\n    </class>\n    <dependencies>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"ConsumeIf\",\n                    \"parent\": \"TypeParser\",\n                    \"about\": \"Consumes the next token if it matches the expected string.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                bool ConsumeIf(const char* expected);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"IsNext\",\n                    \"parent\": \"TypeParser\",\n                    \"about\": \"Checks if the next token matches the expected string without consuming it.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                bool IsNext(const char* expected);\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"ParseSet\",\n                    \"parent\": \"TypeParser\",\n                    \"about\": \"Parses a set of values for the given type.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> std::optional<Type> ParseSet();\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"method\",\n                    \"name\": \"ParseRange\",\n                    \"parent\": \"TypeParser\",\n                    \"about\": \"Parses a range of values for the given type.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                template <typename T> std::optional<Type> ParseRange();\n            ]]></code>\n        </func>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Word32Type\",\n                    \"about\": \"Represents a 32-bit word type.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class Word32Type {\n                 public:\n                  static Type Any();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Word64Type\",\n                    \"about\": \"Represents a 64-bit word type.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class Word64Type {\n                 public:\n                  static Type Any();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Float32Type\",\n                    \"about\": \"Represents a 32-bit floating-point type.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class Float32Type {\n                 public:\n                  static Type Any();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Float64Type\",\n                    \"about\": \"Represents a 64-bit floating-point type.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class Float64Type {\n                 public:\n                  static Type Any();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Type\",\n                    \"about\": \"Base class for all types.\",\n                    \"dependencies\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class Type {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}