{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-list-inl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 37, column 37",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/zone/zone-list-inl.h\",\n        \"file_name\": \"zone-list-inl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Inlines methods for the ZoneList class, a dynamically resizing list that allocates memory from a Zone.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for macros, platform definitions, memory copying utilities, and the ZoneList class definition.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/macros.h\"\n            #include \"src/base/platform/platform.h\"\n            #include \"src/utils/memcopy.h\"\n            #include \"src/zone/zone-list.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Add\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Adds an element to the end of the list. Resizes the list if necessary.\",\n            \"logic\": \"Checks if there is enough capacity. If so, adds the element directly. Otherwise, calls ResizeAdd to resize and add.\",\n            \"parameters\": [\n                {\n                    \"name\": \"element\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The element to add to the list.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone from which to allocate memory if resizing is needed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ResizeAdd\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::Add(const T& element, Zone* zone) {\n              if (length_ < capacity_) {\n                data_[length_++] = element;\n              } else {\n                ZoneList<T>::ResizeAdd(element, zone);\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddAll\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Adds all elements from another ZoneList to the end of this list.\",\n            \"logic\": \"Converts the other ZoneList to a Vector and calls the overloaded AddAll function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"const ZoneList<T>&\",\n                    \"purpose\": \"The ZoneList to add elements from.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone from which to allocate memory if resizing is needed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ToVector\",\n                \"AddAll\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::AddAll(const ZoneList<T>& other, Zone* zone) {\n              AddAll(other.ToVector(), zone);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddAll\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Adds all elements from a base::Vector to the end of this list.\",\n            \"logic\": \"Checks if the vector is empty. If not, resizes the list if necessary and copies the elements using memcpy (if trivially copyable) or std::copy.\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"base::Vector<const T>\",\n                    \"purpose\": \"The Vector to add elements from.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone from which to allocate memory if resizing is needed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Resize\",\n                \"std::is_trivially_copyable\",\n                \"memcpy\",\n                \"std::copy\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::AddAll(base::Vector<const T> other, Zone* zone) {\n              int length = other.length();\n              if (length == 0) return;\n\n              int result_length = length_ + length;\n              if (capacity_ < result_length) Resize(result_length, zone);\n              if (std::is_trivially_copyable<T>::value) {\n                memcpy(&data_[length_], other.begin(), sizeof(T) * length);\n              } else {\n                std::copy(other.begin(), other.end(), &data_[length_]);\n              }\n              length_ = result_length;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ResizeAdd\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Resizes the list and adds an element to the end.\",\n            \"logic\": \"Calls ResizeAddInternal to perform the resizing and adding.  This is a two-layer inlining to potentially avoid code bloat with the inlined version.\",\n            \"parameters\": [\n                {\n                    \"name\": \"element\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The element to add after resizing.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone from which to allocate memory.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ResizeAddInternal\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::ResizeAdd(const T& element, Zone* zone) {\n              ResizeAddInternal(element, zone);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ResizeAddInternal\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Implementation for ResizeAdd, resizes the list and adds an element.\",\n            \"logic\": \"Doubles the capacity (plus 1), copies the element to a temporary variable (to handle self-assignment issues), resizes the array using the Zone, and then adds the element.\",\n            \"parameters\": [\n                {\n                    \"name\": \"element\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The element to add after resizing.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone from which to allocate memory.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DCHECK\",\n                \"Resize\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::ResizeAddInternal(const T& element, Zone* zone) {\n              DCHECK(length_ >= capacity_);\n              // Grow the list capacity by 100%, but make sure to let it grow\n              // even when the capacity is zero (possible initial case).\n              int new_capacity = 1 + 2 * capacity_;\n              // Since the element reference could be an element of the list, copy\n              // it out of the old backing storage before resizing.\n              T temp = element;\n              Resize(new_capacity, zone);\n              data_[length_++] = temp;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Resize\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Resizes the internal data array of the list.\",\n            \"logic\": \"Allocates a new array of the specified capacity from the Zone, copies the existing elements (using memcpy if trivially copyable, otherwise std::copy), deallocates the old array, and updates the internal pointers and capacity.\",\n            \"parameters\": [\n                {\n                    \"name\": \"new_capacity\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The new capacity of the list.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone from which to allocate memory.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DCHECK_LE\",\n                \"Zone::AllocateArray\",\n                \"std::is_trivially_copyable\",\n                \"MemCopy\",\n                \"std::copy\",\n                \"Zone::DeleteArray\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::Resize(int new_capacity, Zone* zone) {\n              DCHECK_LE(length_, new_capacity);\n              T* new_data = zone->AllocateArray<T>(new_capacity);\n              if (length_ > 0) {\n                if (std::is_trivially_copyable<T>::value) {\n                  MemCopy(new_data, data_, length_ * sizeof(T));\n                } else {\n                  std::copy(&data_[0], &data_[length_], &new_data[0]);\n                }\n              }\n              if (data_) zone->DeleteArray<T>(data_, capacity_);\n              data_ = new_data;\n              capacity_ = new_capacity;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddBlock\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Adds a block of elements with the same value to the end of the list.\",\n            \"logic\": \"Adds the value 'count' times, then returns a base::Vector representing the block added.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The value to add to the list.\"\n                },\n                {\n                    \"name\": \"count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of times to add the value.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone from which to allocate memory if resizing is needed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"base::Vector<T>\",\n                \"description\": \"A Vector representing the added block.\"\n            },\n            \"dependencies\": [\n                \"Add\",\n                \"base::Vector\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            base::Vector<T> ZoneList<T>::AddBlock(T value, int count, Zone* zone) {\n              int start = length_;\n              for (int i = 0; i < count; i++) Add(value, zone);\n              return base::Vector<T>(&data_[start], count);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Set\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Sets the element at a specific index in the list.\",\n            \"logic\": \"Assigns the given element to the specified index.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index to set.\"\n                },\n                {\n                    \"name\": \"elm\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The element to set at the index.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DCHECK\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::Set(int index, const T& elm) {\n              DCHECK(index >= 0 && index <= length_);\n              data_[index] = elm;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InsertAt\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Inserts an element at a specific index, shifting existing elements to the right.\",\n            \"logic\": \"Adds the element to increase the size, then shifts the elements from index to the end one position to the right. Finally, overwrites the element at the specified index.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index at which to insert.\"\n                },\n                {\n                    \"name\": \"elm\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The element to insert.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone from which to allocate memory, if the underlying `Add` call triggers a resize\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DCHECK\",\n                \"Add\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::InsertAt(int index, const T& elm, Zone* zone) {\n              DCHECK(index >= 0 && index <= length_);\n              Add(elm, zone);\n              for (int i = length_ - 1; i > index; --i) {\n                data_[i] = data_[i - 1];\n              }\n              data_[index] = elm;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Remove\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Removes the element at a given index, shifting the remaining elements to the left.\",\n            \"logic\": \"Copies the element at index i, then shifts the elements after index i one position to the left, effectively overwriting and removing the element at the index i.\",\n            \"parameters\": [\n                {\n                    \"name\": \"i\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the element to remove.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T\",\n                \"description\": \"The element that was removed.\"\n            },\n            \"dependencies\": [\n                \"at\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            T ZoneList<T>::Remove(int i) {\n              T element = at(i);\n              length_--;\n              while (i < length_) {\n                data_[i] = data_[i + 1];\n                i++;\n              }\n              return element;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Clear\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Clears the list, deallocating the internal data array.\",\n            \"logic\": \"Deallocates the memory used by the internal data array using the provided Zone, then calls DropAndClear to reset internal state without deallocating.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The Zone from which the memory was allocated.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Zone::DeleteArray\",\n                \"DropAndClear\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::Clear(Zone* zone) {\n              if (data_) zone->DeleteArray<T>(data_, capacity_);\n              DropAndClear();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Rewind\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Sets the length of the list to a specific position, effectively truncating it.\",\n            \"logic\": \"Sets the length_ member to the specified position.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pos\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The new length of the list.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DCHECK\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ZoneList<T>::Rewind(int pos) {\n              DCHECK(0 <= pos && pos <= length_);\n              length_ = pos;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Iterate\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Iterates over the elements of the list and applies a visitor to each element.\",\n            \"logic\": \"Loops through the elements from the start to the current length and calls the Apply method of the provided visitor.\",\n            \"parameters\": [\n                {\n                    \"name\": \"visitor\",\n                    \"type\": \"Visitor*\",\n                    \"purpose\": \"The visitor object to apply to each element.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            template <class Visitor>\n            void ZoneList<T>::Iterate(Visitor* visitor) {\n              for (int i = 0; i < length_; i++) visitor->Apply(&data_[i]);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Sort\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Sorts the elements of the list using a custom comparison function.\",\n            \"logic\": \"Uses std::sort with a lambda expression to adapt the custom comparison function. Includes a debug check to ensure elements are in sorted order.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cmp\",\n                    \"type\": \"CompareFunction\",\n                    \"purpose\": \"The comparison function to use for sorting.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"std::sort\",\n                \"DCHECK_LE\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            template <typename CompareFunction>\n            void ZoneList<T>::Sort(CompareFunction cmp) {\n              std::sort(begin(), end(),\n                        [cmp](const T& a, const T& b) { return cmp(&a, &b) < 0; });\n        #ifdef DEBUG\n              for (int i = 1; i < length_; i++) {\n                DCHECK_LE(cmp(&data_[i - 1], &data_[i]), 0);\n              }\n        #endif\n            }\n        ]]></code>\n    </func>\n\n        <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"StableSort\",\n            \"parent\": \"ZoneList\",\n            \"about\": \"Sorts the elements of the list using a custom comparison function in a stable manner.\",\n            \"logic\": \"Uses std::stable_sort with a lambda expression to adapt the custom comparison function. Includes a debug check to ensure elements are in sorted order.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cmp\",\n                    \"type\": \"CompareFunction\",\n                    \"purpose\": \"The comparison function to use for sorting.\"\n                },\n                {\n                    \"name\": \"s\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The starting index for the range to sort\"\n                },\n                                {\n                    \"name\": \"l\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The length of the range to sort\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"std::stable_sort\",\n                \"DCHECK_LE\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            template <typename CompareFunction>\n            void ZoneList<T>::StableSort(CompareFunction cmp, size_t s, size_t l) {\n              std::stable_sort(begin() + s, begin() + s + l,\n                               [cmp](const T& a, const T& b) { return cmp(&a, &b) < 0; });\n        #ifdef DEBUG\n              for (size_t i = s + 1; i < l; i++) {\n                DCHECK_LE(cmp(&data_[i - 1], &data_[i]), 0);\n              }\n        #endif\n            }\n        ]]></code>\n    </func>\n\n</file>\n```"
}