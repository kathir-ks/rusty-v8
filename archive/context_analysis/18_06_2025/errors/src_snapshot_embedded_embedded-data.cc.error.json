{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/embedded-data.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/embedded-data.cc\",\n        \"file_name\": \"embedded-data.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the EmbeddedData class for managing the embedded data (code and metadata) of builtins in V8's snapshot.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for the EmbeddedData class, assembler, callables, snapshot utilities, and sorting builtins.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/embedded/embedded-data.h\"\n\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/callable.h\"\n#include \"src/snapshot/embedded/embedded-data-inl.h\"\n#include \"src/snapshot/snapshot-utils.h\"\n#include \"src/snapshot/sort-builtins.h\"\n        ]]></code>\n    </imports>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TryLookupCode\",\n            \"parent\": \"EmbeddedData\",\n            \"about\": \"Looks up a Builtin ID for a given address within the embedded code range.\",\n            \"logic\": \"Checks if the address is within the code range. Calculates the offset within the raw code. Performs a binary search in the BuiltinLookupEntry table to find the corresponding Builtin ID. Returns the Builtin ID if found, otherwise returns kNoBuiltinId.\",\n            \"parameters\": [\n                {\n                    \"name\": \"address\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The address to lookup.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Builtin\",\n                \"description\": \"The Builtin ID corresponding to the address, or kNoBuiltinId if not found.\"\n            },\n            \"dependencies\": [\n                \"IsInCodeRange\",\n                \"RawCode\",\n                \"BuiltinLookupEntry\",\n                \"std::upper_bound\",\n                \"InstructionStartOf\",\n                \"PaddedInstructionSizeOf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nBuiltin EmbeddedData::TryLookupCode(Address address) const {\n  if (!IsInCodeRange(address)) return Builtin::kNoBuiltinId;\n\n  // Note: Addresses within the padding section between builtins (i.e. within\n  // start + size <= address < start + padded_size) are interpreted as belonging\n  // to the preceding builtin.\n  uint32_t offset =\n      static_cast<uint32_t>(address - reinterpret_cast<Address>(RawCode()));\n\n  const struct BuiltinLookupEntry* start =\n      BuiltinLookupEntry(static_cast<ReorderedBuiltinIndex>(0));\n  const struct BuiltinLookupEntry* end = start + kTableSize;\n  const struct BuiltinLookupEntry* desc =\n      std::upper_bound(start, end, offset,\n                       [](uint32_t o, const struct BuiltinLookupEntry& desc) {\n                         return o < desc.end_offset;\n                       });\n  Builtin builtin = static_cast<Builtin>(desc->builtin_id);\n  DCHECK_LT(address,\n            InstructionStartOf(builtin) + PaddedInstructionSizeOf(builtin));\n  DCHECK_GE(address, InstructionStartOf(builtin));\n  return builtin;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"PcIsOffHeap\",\n            \"parent\": \"OffHeapInstructionStream\",\n            \"about\": \"Determines if a given program counter (PC) address is located within the off-heap embedded code.\",\n            \"logic\": \"Checks if the embedded blob code is available. If so, it checks if the PC is within the code range of the embedded blob obtained from the isolate, and potentially the short builtin calls copy of the embedded blob.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to check against.\"\n                },\n                {\n                    \"name\": \"pc\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The program counter address to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the PC is within the off-heap instruction stream, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"EmbeddedData::FromBlob\",\n                \"EmbeddedData::IsInCodeRange\",\n                \"Isolate::is_short_builtin_calls_enabled\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nbool OffHeapInstructionStream::PcIsOffHeap(Isolate* isolate, Address pc) {\n  // Mksnapshot calls this while the embedded blob is not available yet.\n  if (isolate->embedded_blob_code() == nullptr) return false;\n  DCHECK_NOT_NULL(Isolate::CurrentEmbeddedBlobCode());\n\n  if (EmbeddedData::FromBlob(isolate).IsInCodeRange(pc)) return true;\n  return isolate->is_short_builtin_calls_enabled() &&\n         EmbeddedData::FromBlob().IsInCodeRange(pc);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"TryGetAddressForHashing\",\n            \"parent\": \"OffHeapInstructionStream\",\n            \"about\": \"Attempts to retrieve a hashable address for a given address, if it's within the embedded code range.\",\n            \"logic\": \"Checks if the embedded blob code is available. If the address is within the code range of the isolate's embedded data or the short builtin calls version, returns the address for hashing.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to use for retrieving the embedded data.\"\n                },\n                {\n                    \"name\": \"address\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The address to retrieve a hashable address for.\"\n                },\n                {\n                    \"name\": \"hashable_address\",\n                    \"type\": \"uint32_t*\",\n                    \"purpose\": \"Output parameter to store the hashable address.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a hashable address was found, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"EmbeddedData::FromBlob\",\n                \"EmbeddedData::IsInCodeRange\",\n                \"EmbeddedData::AddressForHashing\",\n                \"Isolate::is_short_builtin_calls_enabled\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nbool OffHeapInstructionStream::TryGetAddressForHashing(\n    Isolate* isolate, Address address, uint32_t* hashable_address) {\n  // Mksnapshot calls this while the embedded blob is not available yet.\n  if (isolate->embedded_blob_code() == nullptr) return false;\n  DCHECK_NOT_NULL(Isolate::CurrentEmbeddedBlobCode());\n\n  EmbeddedData d = EmbeddedData::FromBlob(isolate);\n  if (d.IsInCodeRange(address)) {\n    *hashable_address = d.AddressForHashing(address);\n    return true;\n  }\n\n  if (isolate->is_short_builtin_calls_enabled()) {\n    d = EmbeddedData::FromBlob();\n    if (d.IsInCodeRange(address)) {\n      *hashable_address = d.AddressForHashing(address);\n      return true;\n    }\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"TryLookupCode\",\n            \"parent\": \"OffHeapInstructionStream\",\n            \"about\": \"Looks up the Builtin ID corresponding to a given address in the off-heap instruction stream.\",\n            \"logic\": \"First checks the isolate's embedded data. If short builtin calls are enabled and the address isn't found, it checks the short builtin calls version. If shared pointer compression is enabled, it also checks the code range copy.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to check against.\"\n                },\n                {\n                    \"name\": \"address\",\n                    \"type\": \"Address\",\n                    \"purpose\": \"The address to lookup.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Builtin\",\n                \"description\": \"The Builtin ID if found, otherwise kNoBuiltinId.\"\n            },\n            \"dependencies\": [\n                \"EmbeddedData::FromBlob\",\n                \"EmbeddedData::TryLookupCode\",\n                \"Builtins::IsBuiltinId\",\n                \"Isolate::is_short_builtin_calls_enabled\",\n                \"IsolateGroup::current\",\n                \"CodeRange::embedded_blob_code_copy\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nBuiltin OffHeapInstructionStream::TryLookupCode(Isolate* isolate,\n                                                Address address) {\n  // Mksnapshot calls this while the embedded blob is not available yet.\n  if (isolate->embedded_blob_code() == nullptr) return Builtin::kNoBuiltinId;\n  DCHECK_NOT_NULL(Isolate::CurrentEmbeddedBlobCode());\n\n  Builtin builtin = EmbeddedData::FromBlob(isolate).TryLookupCode(address);\n\n  if (isolate->is_short_builtin_calls_enabled() &&\n      !Builtins::IsBuiltinId(builtin)) {\n    builtin = EmbeddedData::FromBlob().TryLookupCode(address);\n  }\n\n#ifdef V8_COMPRESS_POINTERS_IN_SHARED_CAGE\n  if (V8_SHORT_BUILTIN_CALLS_BOOL && !Builtins::IsBuiltinId(builtin)) {\n    // When shared pointer compression cage is enabled and it has the embedded\n    // code blob copy then it could have been used regardless of whether the\n    // isolate uses it or knows about it or not (see\n    // InstructionStream::OffHeapInstructionStart()).\n    // So, this blob has to be checked too.\n    CodeRange* code_range = IsolateGroup::current()->GetCodeRange();\n    if (code_range && code_range->embedded_blob_code_copy() != nullptr) {\n      builtin = EmbeddedData::FromBlob(code_range).TryLookupCode(address);\n    }\n  }\n#endif\n  return builtin;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"CreateOffHeapOffHeapInstructionStream\",\n            \"parent\": \"OffHeapInstructionStream\",\n            \"about\": \"Creates an off-heap instruction stream by allocating memory and copying the embedded blob to it.\",\n            \"logic\": \"Allocates memory for code and data sections outside V8's heap using the platform page allocator. Copies the embedded blob from the current isolate to the newly allocated memory. Sets memory permissions for code as read-execute and data as read. Returns pointers to the allocated code and data, along with their sizes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to create the stream for.\"\n                },\n                {\n                    \"name\": \"code\",\n                    \"type\": \"uint8_t**\",\n                    \"purpose\": \"Output parameter: pointer to the allocated code.\"\n                },\n                {\n                    \"name\": \"code_size\",\n                    \"type\": \"uint32_t*\",\n                    \"purpose\": \"Output parameter: size of the allocated code.\"\n                },\n                {\n                    \"name\": \"data\",\n                    \"type\": \"uint8_t**\",\n                    \"purpose\": \"Output parameter: pointer to the allocated data.\"\n                },\n                {\n                    \"name\": \"data_size\",\n                    \"type\": \"uint32_t*\",\n                    \"purpose\": \"Output parameter: size of the allocated data.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"EmbeddedData::NewFromIsolate\",\n                \"v8::PageAllocator\",\n                \"v8::internal::GetPlatformPageAllocator\",\n                \"AlignedAddress\",\n                \"isolate->heap()->GetRandomMmapAddr()\",\n                \"RoundUp\",\n                \"AllocatePages\",\n                \"SetPermissions\",\n                \"std::memcpy\",\n                \"FlushInstructionCache\",\n                \"EmbeddedData::code_size\",\n                \"EmbeddedData::data_size\",\n                \"EmbeddedData::code\",\n                \"EmbeddedData::data\",\n                \"EmbeddedData::Dispose\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid OffHeapInstructionStream::CreateOffHeapOffHeapInstructionStream(\n    Isolate* isolate, uint8_t** code, uint32_t* code_size, uint8_t** data,\n    uint32_t* data_size) {\n  // Create the embedded blob from scratch using the current Isolate's heap.\n  EmbeddedData d = EmbeddedData::NewFromIsolate(isolate);\n\n  // Allocate the backing store that will contain the embedded blob in this\n  // Isolate. The backing store is on the native heap, *not* on V8's garbage-\n  // collected heap.\n  v8::PageAllocator* page_allocator = v8::internal::GetPlatformPageAllocator();\n  const uint32_t alignment =\n      static_cast<uint32_t>(page_allocator->AllocatePageSize());\n\n  void* const requested_allocation_code_address =\n      AlignedAddress(isolate->heap()->GetRandomMmapAddr(), alignment);\n  const uint32_t allocation_code_size = RoundUp(d.code_size(), alignment);\n  uint8_t* allocated_code_bytes = static_cast<uint8_t*>(AllocatePages(\n      page_allocator, requested_allocation_code_address, allocation_code_size,\n      alignment, PageAllocator::kReadWrite));\n  CHECK_NOT_NULL(allocated_code_bytes);\n\n  void* const requested_allocation_data_address =\n      AlignedAddress(isolate->heap()->GetRandomMmapAddr(), alignment);\n  const uint32_t allocation_data_size = RoundUp(d.data_size(), alignment);\n  uint8_t* allocated_data_bytes = static_cast<uint8_t*>(AllocatePages(\n      page_allocator, requested_allocation_data_address, allocation_data_size,\n      alignment, PageAllocator::kReadWrite));\n  CHECK_NOT_NULL(allocated_data_bytes);\n\n  // Copy the embedded blob into the newly allocated backing store. Switch\n  // permissions to read-execute since builtin code is immutable from now on\n  // and must be executable in case any JS execution is triggered.\n  //\n  // Once this backing store is set as the current_embedded_blob, V8 cannot tell\n  // the difference between a 'real' embedded build (where the blob is embedded\n  // in the binary) and what we are currently setting up here (where the blob is\n  // on the native heap).\n  std::memcpy(allocated_code_bytes, d.code(), d.code_size());\n  if (v8_flags.experimental_flush_embedded_blob_icache) {\n    FlushInstructionCache(allocated_code_bytes, d.code_size());\n  }\n  CHECK(SetPermissions(page_allocator, allocated_code_bytes,\n                       allocation_code_size, PageAllocator::kReadExecute));\n\n  std::memcpy(allocated_data_bytes, d.data(), d.data_size());\n  CHECK(SetPermissions(page_allocator, allocated_data_bytes,\n                       allocation_data_size, PageAllocator::kRead));\n\n  *code = allocated_code_bytes;\n  *code_size = d.code_size();\n  *data = allocated_data_bytes;\n  *data_size = d.data_size();\n\n  d.Dispose();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"FreeOffHeapOffHeapInstructionStream\",\n            \"parent\": \"OffHeapInstructionStream\",\n            \"about\": \"Frees the memory allocated for the off-heap instruction stream.\",\n            \"logic\": \"Frees the memory allocated for the code and data sections using the platform page allocator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code\",\n                    \"type\": \"uint8_t*\",\n                    \"purpose\": \"Pointer to the allocated code.\"\n                },\n                {\n                    \"name\": \"code_size\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"Size of the allocated code.\"\n                },\n                {\n                    \"name\": \"data\",\n                    \"type\": \"uint8_t*\",\n                    \"purpose\": \"Pointer to the allocated data.\"\n                },\n                {\n                    \"name\": \"data_size\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"Size of the allocated data.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"v8::PageAllocator\",\n                \"v8::internal::GetPlatformPageAllocator\",\n                \"RoundUp\",\n                \"FreePages\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid OffHeapInstructionStream::FreeOffHeapOffHeapInstructionStream(\n    uint8_t* code, uint32_t code_size, uint8_t* data, uint32_t data_size) {\n  v8::PageAllocator* page_allocator = v8::internal::GetPlatformPageAllocator();\n  const uint32_t page_size =\n      static_cast<uint32_t>(page_allocator->AllocatePageSize());\n  FreePages(page_allocator, code, RoundUp(code_size, page_size));\n  FreePages(page_allocator, data, RoundUp(data_size, page_size));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"FinalizeEmbeddedCodeTargets\",\n            \"parent\": \"(anonymous namespace)\",\n            \"about\": \"Fixes up call targets within the embedded code that point to other embedded builtins.\",\n            \"logic\": \"Iterates through all builtins and their relocation information. For CODE_TARGET and RELATIVE_CODE_TARGET relocations, updates the target address to the correct offset within the embedded blob.  This is only performed on certain architectures (x64, arm/arm64, ia32, s390x, riscv64, loong64, riscv32) where relative jumps between builtins are used.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate containing the builtins.\"\n                },\n                {\n                    \"name\": \"blob\",\n                    \"type\": \"EmbeddedData*\",\n                    \"purpose\": \"The embedded data blob to finalize.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"RelocInfo::ModeMask\",\n                \"RelocIterator\",\n                \"Code::FromTargetAddress\",\n                \"Builtins::IsIsolateIndependentBuiltin\",\n                \"RelocInfo::set_off_heap_target_address\",\n                \"EmbeddedData::InstructionStartOf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nvoid FinalizeEmbeddedCodeTargets(Isolate* isolate, EmbeddedData* blob) {\n  static const int kRelocMask =\n      RelocInfo::ModeMask(RelocInfo::CODE_TARGET) |\n      RelocInfo::ModeMask(RelocInfo::RELATIVE_CODE_TARGET);\n\n  static_assert(Builtins::kAllBuiltinsAreIsolateIndependent);\n  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;\n       ++builtin) {\n    Tagged<Code> code = isolate->builtins()->code(builtin);\n    RelocIterator on_heap_it(code, kRelocMask);\n    RelocIterator off_heap_it(blob, code, kRelocMask);\n\n#if defined(V8_TARGET_ARCH_X64) || defined(V8_TARGET_ARCH_ARM64) ||     \\\n    defined(V8_TARGET_ARCH_ARM) || defined(V8_TARGET_ARCH_IA32) ||      \\\n    defined(V8_TARGET_ARCH_S390X) || defined(V8_TARGET_ARCH_RISCV64) || \\\n    defined(V8_TARGET_ARCH_LOONG64) || defined(V8_TARGET_ARCH_RISCV32)\n    // On these platforms we emit relative builtin-to-builtin\n    // jumps for isolate independent builtins in the snapshot. This fixes up the\n    // relative jumps to the right offsets in the snapshot.\n    // See also: InstructionStream::IsIsolateIndependent.\n    while (!on_heap_it.done()) {\n      DCHECK(!off_heap_it.done());\n\n      RelocInfo* rinfo = on_heap_it.rinfo();\n      DCHECK_EQ(rinfo->rmode(), off_heap_it.rinfo()->rmode());\n      Tagged<Code> target_code =\n          Code::FromTargetAddress(rinfo->target_address());\n      CHECK(Builtins::IsIsolateIndependentBuiltin(target_code));\n\n      // Do not emit write-barrier for off-heap writes.\n      off_heap_it.rinfo()->set_off_heap_target_address(\n          blob->InstructionStartOf(target_code->builtin_id()));\n\n      on_heap_it.next();\n      off_heap_it.next();\n    }\n    DCHECK(off_heap_it.done());\n#else\n    // Architectures other than x64 and arm/arm64 do not use pc-relative calls\n    // and thus must not contain embedded code targets. Instead, we use an\n    // indirection through the root register.\n    CHECK(on_heap_it.done());\n    CHECK(off_heap_it.done());\n#endif\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"EnsureRelocatable\",\n            \"parent\": \"(anonymous namespace)\",\n            \"about\": \"Ensures that the given code object is relocatable by either having no relocation information or having only CONST_POOL relocations.\",\n            \"logic\": \"Checks if the code has any relocation information. If so, it verifies that all relocations are of type CONST_POOL. If not, then it means that the relocation entries don't need to be updated when the InstructionStream is relocated, and dropping relocation info is safe.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code\",\n                    \"type\": \"Tagged<Code>\",\n                    \"purpose\": \"The code object to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"code->relocation_size\",\n                \"RelocIterator\",\n                \"it.rinfo()->rmode\",\n                \"RelocInfo::CONST_POOL\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid EnsureRelocatable(Tagged<Code> code) {\n  if (code->relocation_size() == 0) return;\n\n  // On some architectures (arm) the builtin might have a non-empty reloc\n  // info containing a CONST_POOL entry. These entries don't have to be\n  // updated when InstructionStream object is relocated, so it's safe to drop\n  // the reloc info alltogether. If it wasn't the case then we'd have to store\n  // it in the metadata.\n  for (RelocIterator it(code); !it.done(); it.next()) {\n    CHECK_EQ(it.rinfo()->rmode(), RelocInfo::CONST_POOL);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static method\",\n            \"name\": \"NewFromIsolate\",\n            \"parent\": \"EmbeddedData\",\n            \"about\": \"Creates a new EmbeddedData object from the given Isolate, representing the embedded data (code and metadata) for builtins.\",\n            \"logic\": \"Calculates the size and layout of the code and data sections for the embedded blob. Allocates memory for the code and data sections. Copies the code and metadata of each builtin into the allocated memory, aligning each section appropriately. Finalizes code targets by fixing up call targets within the embedded code. Computes and stores hashes for code and data sections. Ensures certain builtins are relocatable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to create the EmbeddedData from.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"EmbeddedData\",\n                \"description\": \"A new EmbeddedData object.\"\n            },\n            \"dependencies\": [\n                \"Builtins* builtins = isolate->builtins()\",\n                \"std::vector<struct LayoutDescription> layout_descriptions(kTableSize)\",\n                \"std::vector<struct BuiltinLookupEntry> offset_descriptions(kTableSize)\",\n                \"Tagged<Code> code = builtins->code(i)\",\n                \"PadAndAlignCode\",\n                \"sorter.SortBuiltins\",\n                \"raw_code_size += PadAndAlignCode(instruction_size)\",\n                \"raw_data_size += PadAndAlignData(code->metadata_size())\",\n                \"new uint8_t[blob_code_size]()\",\n                \"new uint8_t[blob_data_size]()\",\n                \"ZapCode\",\n                \"isolate->HashIsolateForEmbeddedBlob()\",\n                \"std::memcpy\",\n                \"FinalizeEmbeddedCodeTargets(isolate, &d)\",\n                \"d.CreateEmbeddedBlobDataHash()\",\n                \"d.CreateEmbeddedBlobCodeHash()\",\n                \"EnsureRelocatable\",\n                \"d.PrintStatistics()\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nEmbeddedData EmbeddedData::NewFromIsolate(Isolate* isolate) {\n  Builtins* builtins = isolate->builtins();\n\n  // Store instruction stream lengths and offsets.\n  std::vector<struct LayoutDescription> layout_descriptions(kTableSize);\n  std::vector<struct BuiltinLookupEntry> offset_descriptions(kTableSize);\n\n  bool saw_unsafe_builtin = false;\n  uint32_t raw_code_size = 0;\n  uint32_t raw_data_size = 0;\n  static_assert(Builtins::kAllBuiltinsAreIsolateIndependent);\n\n  std::vector<Builtin> reordered_builtins;\n  if (v8_flags.reorder_builtins &&\n      BuiltinsCallGraph::Get()->all_hash_matched()) {\n    DCHECK(v8_flags.turbo_profiling_input.value());\n    // TODO(ishell, v8:13938): avoid the binary size overhead for non-mksnapshot\n    // binaries.\n    BuiltinsSorter sorter;\n    std::vector<uint32_t> builtin_sizes;\n    for (Builtin i = Builtins::kFirst; i <= Builtins::kLast; ++i) {\n      Tagged<Code> code = builtins->code(i);\n      uint32_t instruction_size =\n          static_cast<uint32_t>(code->instruction_size());\n      uint32_t padding_size = PadAndAlignCode(instruction_size);\n      builtin_sizes.push_back(padding_size);\n    }\n    reordered_builtins = sorter.SortBuiltins(\n        v8_flags.turbo_profiling_input.value(), builtin_sizes);\n    CHECK_EQ(reordered_builtins.size(), Builtins::kBuiltinCount);\n  }\n\n  for (ReorderedBuiltinIndex embedded_index = 0;\n       embedded_index < Builtins::kBuiltinCount; embedded_index++) {\n    Builtin builtin;\n    if (reordered_builtins.empty()) {\n      builtin = static_cast<Builtin>(embedded_index);\n    } else {\n      builtin = reordered_builtins[embedded_index];\n    }\n    Tagged<Code> code = builtins->code(builtin);\n\n    // Sanity-check that the given builtin is isolate-independent.\n    if (!code->IsIsolateIndependent(isolate)) {\n      saw_unsafe_builtin = true;\n      fprintf(stderr, \"%s is not isolate-independent.\\n\",\n              Builtins::name(builtin));\n    }\n\n    uint32_t instruction_size = static_cast<uint32_t>(code->instruction_size());\n    DCHECK_EQ(0, raw_code_size % kCodeAlignment);\n    {\n      // We use builtin id as index in layout_descriptions.\n      const int builtin_id = static_cast<int>(builtin);\n      struct LayoutDescription& layout_desc = layout_descriptions[builtin_id];\n      layout_desc.instruction_offset = raw_code_size;\n      layout_desc.instruction_length = instruction_size;\n      layout_desc.metadata_offset = raw_data_size;\n    }\n    // Align the start of each section.\n    raw_code_size += PadAndAlignCode(instruction_size);\n    raw_data_size += PadAndAlignData(code->metadata_size());\n\n    {\n      // We use embedded index as index in offset_descriptions.\n      struct BuiltinLookupEntry& offset_desc =\n          offset_descriptions[embedded_index];\n      offset_desc.end_offset = raw_code_size;\n      offset_desc.builtin_id = static_cast<uint32_t>(builtin);\n    }\n  }\n  CHECK_WITH_MSG(\n      !saw_unsafe_builtin,\n      \"One or more builtins marked as isolate-independent either contains \"\n      \"isolate-dependent code or aliases the off-heap trampoline register. \"\n      \"If in doubt, ask jgruber@\");\n\n  // Allocate space for the code section, value-initialized to 0.\n  static_assert(RawCodeOffset() == 0);\n  const uint32_t blob_code_size = RawCodeOffset() + raw_code_size;\n  uint8_t* const blob_code = new uint8_t[blob_code_size]();\n\n  // Allocate space for the data section, value-initialized to 0.\n  static_assert(\n      IsAligned(FixedDataSize(), InstructionStream::kMetadataAlignment));\n  const uint32_t blob_data_size = FixedDataSize() + raw_data_size;\n  uint8_t* const blob_data = new uint8_t[blob_data_size]();\n\n  // Initially zap the entire blob, effectively padding the alignment area\n  // between two builtins with int3's (on x64/ia32).\n  ZapCode(reinterpret_cast<Address>(blob_code), blob_code_size);\n\n  // Hash relevant parts of the Isolate's heap and store the result.\n  {\n    static_assert(IsolateHashSize() == kSizetSize);\n    const size_t hash = isolate->HashIsolateForEmbeddedBlob();\n    std::memcpy(blob_data + IsolateHashOffset(), &hash, IsolateHashSize());\n  }\n\n  // Write the layout_descriptions tables.\n  DCHECK_EQ(LayoutDescriptionTableSize(),\n            sizeof(layout_descriptions[0]) * layout_descriptions.size());\n  std::memcpy(blob_data + LayoutDescriptionTableOffset(),\n              layout_descriptions.data(), LayoutDescriptionTableSize());\n\n  // Write the builtin_offset_descriptions tables.\n  DCHECK_EQ(BuiltinLookupEntryTableSize(),\n            sizeof(offset_descriptions[0]) * offset_descriptions.size());\n  std::memcpy(blob_data + BuiltinLookupEntryTableOffset(),\n              offset_descriptions.data(), BuiltinLookupEntryTableSize());\n\n  // .. and the variable-size data section.\n  uint8_t* const raw_metadata_start = blob_data + RawMetadataOffset();\n  static_assert(Builtins::kAllBuiltinsAreIsolateIndependent);\n  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;\n       ++builtin) {\n    Tagged<Code> code = builtins->code(builtin);\n    uint32_t offset =\n        layout_descriptions[static_cast<int>(builtin)].metadata_offset;\n    uint8_t* dst = raw_metadata_start + offset;\n    DCHECK_LE(RawMetadataOffset() + offset + code->metadata_size(),\n              blob_data_size);\n    std::memcpy(dst, reinterpret_cast<uint8_t*>(code->metadata_start()),\n                code->metadata_size());\n  }\n  CHECK_IMPLIES(\n      kMaxPCRelativeCodeRangeInMB,\n      static_cast<size_t>(raw_code_size) <= kMaxPCRelativeCodeRangeInMB * MB);\n\n  // .. and the variable-size code section.\n  uint8_t* const raw_code_start = blob_code + RawCodeOffset();\n  static_assert(Builtins::kAllBuiltinsAreIsolateIndependent);\n  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;\n       ++builtin) {\n    Tagged<Code> code = builtins->code(builtin);\n    uint32_t offset =\n        layout_descriptions[static_cast<int>(builtin)].instruction_offset;\n    uint8_t* dst = raw_code_start + offset;\n    DCHECK_LE(RawCodeOffset() + offset + code->"
}