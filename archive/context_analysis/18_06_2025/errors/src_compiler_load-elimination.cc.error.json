{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/load-elimination.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/load-elimination.cc\",\n        \"file_name\": \"load-elimination.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements load elimination optimization in the V8 compiler\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for load elimination functionality\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/load-elimination.h\"\n\n            #include <optional>\n\n            #include \"src/compiler/access-builder.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/js-graph.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/node-properties.h\"\n            #include \"src/heap/factory.h\"\n            #include \"src/objects/objects-inl.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsRename\",\n            \"about\": \"Checks if a node is a rename node.\",\n            \"logic\": \"Determines if a node's opcode indicates it's a rename operation like CheckHeapObject, FinishRegion, or TypeGuard and is not dead.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the node is a rename node, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"IrOpcode\",\n                \"Node::IsDead\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool IsRename(Node* node) {\n              switch (node->opcode()) {\n                case IrOpcode::kCheckHeapObject:\n                case IrOpcode::kFinishRegion:\n                case IrOpcode::kTypeGuard:\n                  return !node->IsDead();\n                default:\n                  return false;\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ResolveRenames\",\n            \"about\": \"Resolves a chain of rename nodes to the original node.\",\n            \"logic\": \"Follows the InputAt(0) of rename nodes until a non-rename node is found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The starting node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The original node after resolving all renames.\"\n            },\n            \"dependencies\": [\n                \"IsRename\",\n                \"Node::InputAt\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Node* ResolveRenames(Node* node) {\n              while (IsRename(node)) {\n                node = node->InputAt(0);\n              }\n              return node;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MayAlias\",\n            \"about\": \"Checks if two nodes may alias each other.\",\n            \"logic\": \"Considers type information and node opcodes (especially Allocate, HeapConstant, and Parameter) to determine potential aliasing.  Recursively calls itself to resolve rename nodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The first node.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The second node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the nodes may alias, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties::GetType\",\n                \"IsRename\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool MayAlias(Node* a, Node* b) {\n              if (a != b) {\n                if (!NodeProperties::GetType(a).Maybe(NodeProperties::GetType(b))) {\n                  return false;\n                } else if (IsRename(b)) {\n                  return MayAlias(a, b->InputAt(0));\n                } else if (IsRename(a)) {\n                  return MayAlias(a->InputAt(0), b);\n                } else if (b->opcode() == IrOpcode::kAllocate) {\n                  switch (a->opcode()) {\n                    case IrOpcode::kAllocate:\n                    case IrOpcode::kHeapConstant:\n                    case IrOpcode::kParameter:\n                      return false;\n                    default:\n                      break;\n                  }\n                } else if (a->opcode() == IrOpcode::kAllocate) {\n                  switch (b->opcode()) {\n                    case IrOpcode::kHeapConstant:\n                    case IrOpcode::kParameter:\n                      return false;\n                    default:\n                      break;\n                  }\n                }\n              }\n              return true;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MustAlias\",\n            \"about\": \"Checks if two nodes must alias each other.\",\n            \"logic\": \"Resolves renames for both nodes and compares the resolved nodes for equality.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The first node.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The second node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the nodes must alias, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ResolveRenames\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool MustAlias(Node* a, Node* b) {\n              return ResolveRenames(a) == ResolveRenames(b);\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LoadElimination\",\n            \"about\": \"Implements the load elimination optimization.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class LoadElimination {\n             public:\n              Reduction Reduce(Node* node);\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Reduce\",\n            \"parent\": \"LoadElimination\",\n            \"about\": \"Reduces a given node during load elimination.\",\n            \"logic\": \"The main dispatch function for the load elimination algorithm. Uses a switch statement to handle different node opcodes and call the appropriate reduction functions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to reduce.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"The result of the reduction.\"\n            },\n            \"dependencies\": [\n                \"v8_flags.trace_turbo_load_elimination\",\n                \"node->op()->EffectInputCount()\",\n                \"NodeProperties::GetEffectInput\",\n                \"node_states_.Get\",\n                \"AbstractState::Print\",\n                \"ReduceMapGuard\",\n                \"ReduceCheckMaps\",\n                \"ReduceCompareMaps\",\n                \"ReduceEnsureWritableFastElements\",\n                \"ReduceMaybeGrowFastElements\",\n                \"ReduceTransitionElementsKind\",\n                \"ReduceTransitionElementsKindOrCheckMap\",\n                \"ReduceLoadField\",\n                \"FieldAccessOf\",\n                \"ReduceStoreField\",\n                \"ReduceLoadElement\",\n                \"ReduceStoreElement\",\n                \"ReduceTransitionAndStoreElement\",\n                \"ReduceStoreTypedElement\",\n                \"ReduceEffectPhi\",\n                \"ReduceStart\",\n                \"ReduceOtherNode\",\n                \"NoChange\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Reduction LoadElimination::Reduce(Node* node) {\n              if (v8_flags.trace_turbo_load_elimination) {\n                if (node->op()->EffectInputCount() > 0) {\n                  PrintF(\" visit #%d:%s\", node->id(), node->op()->mnemonic());\n                  if (node->op()->ValueInputCount() > 0) {\n                    PrintF(\"(\");\n                    for (int i = 0; i < node->op()->ValueInputCount(); ++i) {\n                      if (i > 0) PrintF(\", \");\n                      Node* const value = NodeProperties::GetValueInput(node, i);\n                      PrintF(\"#%d:%s\", value->id(), value->op()->mnemonic());\n                    }\n                    PrintF(\")\");\n                  }\n                  PrintF(\"\\n\");\n                  for (int i = 0; i < node->op()->EffectInputCount(); ++i) {\n                    Node* const effect = NodeProperties::GetEffectInput(node, i);\n                    if (AbstractState const* const state = node_states_.Get(effect)) {\n                      PrintF(\"  state[%i]: #%d:%s\\n\", i, effect->id(),\n                             effect->op()->mnemonic());\n                      state->Print();\n                    } else {\n                      PrintF(\"  no state[%i]: #%d:%s\\n\", i, effect->id(),\n                             effect->op()->mnemonic());\n                    }\n                  }\n                }\n              }\n              switch (node->opcode()) {\n                case IrOpcode::kMapGuard:\n                  return ReduceMapGuard(node);\n                case IrOpcode::kCheckMaps:\n                  return ReduceCheckMaps(node);\n                case IrOpcode::kCompareMaps:\n                  return ReduceCompareMaps(node);\n                case IrOpcode::kEnsureWritableFastElements:\n                  return ReduceEnsureWritableFastElements(node);\n                case IrOpcode::kMaybeGrowFastElements:\n                  return ReduceMaybeGrowFastElements(node);\n                case IrOpcode::kTransitionElementsKind:\n                  return ReduceTransitionElementsKind(node);\n                case IrOpcode::kTransitionElementsKindOrCheckMap:\n                  return ReduceTransitionElementsKindOrCheckMap(node);\n                case IrOpcode::kLoadField:\n                  return ReduceLoadField(node, FieldAccessOf(node->op()));\n                case IrOpcode::kStoreField:\n                  return ReduceStoreField(node, FieldAccessOf(node->op()));\n                case IrOpcode::kLoadElement:\n                  return ReduceLoadElement(node);\n                case IrOpcode::kStoreElement:\n                  return ReduceStoreElement(node);\n                case IrOpcode::kTransitionAndStoreElement:\n                  return ReduceTransitionAndStoreElement(node);\n                case IrOpcode::kStoreTypedElement:\n                  return ReduceStoreTypedElement(node);\n                case IrOpcode::kEffectPhi:\n                  return ReduceEffectPhi(node);\n                case IrOpcode::kDead:\n                  break;\n                case IrOpcode::kStart:\n                  return ReduceStart(node);\n                default:\n                  return ReduceOtherNode(node);\n              }\n              return NoChange();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsCompatible\",\n            \"about\": \"Checks if two machine representations are compatible for load elimination.\",\n            \"logic\": \"Returns true if the representations are the same or if both are tagged representations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"r1\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The first machine representation.\"\n                },\n                {\n                    \"name\": \"r2\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The second machine representation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the representations are compatible, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"IsAnyTagged\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool IsCompatible(MachineRepresentation r1, MachineRepresentation r2) {\n              if (r1 == r2) return true;\n              return IsAnyTagged(r1) && IsAnyTagged(r2);\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AbstractState\",\n            \"about\": \"Represents the abstract state of the heap during load elimination.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            LoadElimination::AbstractState const\n                LoadElimination::AbstractState::empty_state_;\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AbstractElements\",\n            \"about\": \"Represents the abstract state of elements (array contents) during load elimination\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            Node* LoadElimination::AbstractElements::Lookup(\n                Node* object, Node* index, MachineRepresentation representation) const;\n\n            LoadElimination::AbstractElements const*\n            LoadElimination::AbstractElements::Kill(Node* object, Node* index,\n                                                    Zone* zone) const;\n\n            bool LoadElimination::AbstractElements::Equals(\n                AbstractElements const* that) const;\n\n            LoadElimination::AbstractElements const*\n            LoadElimination::AbstractElements::Merge(AbstractElements const* that,\n                                                     Zone* zone) const;\n\n            void LoadElimination::AbstractElements::Print() const;\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Lookup\",\n            \"parent\": \"AbstractElements\",\n            \"about\": \"Looks up an element in the abstract elements state.\",\n            \"logic\": \"Iterates through the stored elements and checks for matching object and index (using MustAlias) and compatible representation (using IsCompatible).\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The object to look up.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The index to look up.\"\n                },\n                {\n                    \"name\": \"representation\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The machine representation of the element.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The value of the element if found, nullptr otherwise.\"\n            },\n            \"dependencies\": [\n                \"MustAlias\",\n                \"IsCompatible\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Node* LoadElimination::AbstractElements::Lookup(\n                Node* object, Node* index, MachineRepresentation representation) const {\n              for (Element const element : elements_) {\n                if (element.object == nullptr) continue;\n                DCHECK_NOT_NULL(element.index);\n                DCHECK_NOT_NULL(element.value);\n                if (MustAlias(object, element.object) && MustAlias(index, element.index) &&\n                    IsCompatible(representation, element.representation)) {\n                  return element.value;\n                }\n              }\n              return nullptr;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Kill\",\n            \"parent\": \"AbstractElements\",\n            \"about\": \"Kills elements that may alias with the given object and index.\",\n            \"logic\": \"Iterates through the stored elements and removes any element whose object may alias with the given object. Uses MayAlias and NodeProperties::GetType to refine the removal process.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The object to kill.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The index to kill.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate new AbstractElements in.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AbstractElements const*\",\n                \"description\": \"A new AbstractElements with the aliasing elements removed, or the original AbstractElements if no elements were killed.\"\n            },\n            \"dependencies\": [\n                \"MayAlias\",\n                \"NodeProperties::GetType\",\n                \"arraysize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            LoadElimination::AbstractElements const*\n            LoadElimination::AbstractElements::Kill(Node* object, Node* index,\n                                                    Zone* zone) const {\n              for (Element const element : this->elements_) {\n                if (element.object == nullptr) continue;\n                if (MayAlias(object, element.object)) {\n                  AbstractElements* that = zone->New<AbstractElements>(zone);\n                  for (Element const element2 : this->elements_) {\n                    if (element2.object == nullptr) continue;\n                    DCHECK_NOT_NULL(element2.index);\n                    DCHECK_NOT_NULL(element2.value);\n                    if (!MayAlias(object, element2.object) ||\n                        !NodeProperties::GetType(index).Maybe(\n                            NodeProperties::GetType(element2.index))) {\n                      that->elements_[that->next_index_++] = element2;\n                    }\n                  }\n                  that->next_index_ %= arraysize(elements_);\n                  return that;\n                }\n              }\n              return this;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Equals\",\n            \"parent\": \"AbstractElements\",\n            \"about\": \"Checks if two AbstractElements states are equal.\",\n            \"logic\": \"Compares each element in both AbstractElements to ensure they contain the same object, index, and value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"that\",\n                    \"type\": \"AbstractElements const*\",\n                    \"purpose\": \"The AbstractElements to compare to.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the AbstractElements are equal, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"arraysize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool LoadElimination::AbstractElements::Equals(\n                AbstractElements const* that) const {\n              if (this == that) return true;\n              for (size_t i = 0; i < arraysize(elements_); ++i) {\n                Element this_element = this->elements_[i];\n                if (this_element.object == nullptr) continue;\n                for (size_t j = 0;; ++j) {\n                  if (j == arraysize(elements_)) return false;\n                  Element that_element = that->elements_[j];\n                  if (this_element.object == that_element.object &&\n                      this_element.index == that_element.index &&\n                      this_element.value == that_element.value) {\n                    break;\n                  }\n                }\n              }\n              for (size_t i = 0; i < arraysize(elements_); ++i) {\n                Element that_element = that->elements_[i];\n                if (that_element.object == nullptr) continue;\n                for (size_t j = 0;; ++j) {\n                  if (j == arraysize(elements_)) return false;\n                  Element this_element = this->elements_[j];\n                  if (that_element.object == this_element.object &&\n                      that_element.index == this_element.index &&\n                      that_element.value == this_element.value) {\n                    break;\n                  }\n                }\n              }\n              return true;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Merge\",\n            \"parent\": \"AbstractElements\",\n            \"about\": \"Merges two AbstractElements states.\",\n            \"logic\": \"Creates a new AbstractElements containing only elements that are present in both input AbstractElements.\",\n            \"parameters\": [\n                {\n                    \"name\": \"that\",\n                    \"type\": \"AbstractElements const*\",\n                    \"purpose\": \"The AbstractElements to merge with.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate the new AbstractElements in.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AbstractElements const*\",\n                \"description\": \"A new AbstractElements with the merged elements, or the original AbstractElements if they are equal.\"\n            },\n            \"dependencies\": [\n                \"Equals\",\n                \"arraysize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            LoadElimination::AbstractElements const*\n            LoadElimination::AbstractElements::Merge(AbstractElements const* that,\n                                                     Zone* zone) const {\n              if (this->Equals(that)) return this;\n              AbstractElements* copy = zone->New<AbstractElements>(zone);\n              for (Element const this_element : this->elements_) {\n                if (this_element.object == nullptr) continue;\n                for (Element const that_element : that->elements_) {\n                  if (this_element.object == that_element.object &&\n                      this_element.index == that_element.index &&\n                      this_element.value == that_element.value) {\n                    copy->elements_[copy->next_index_++] = this_element;\n                    break;\n                  }\n                }\n              }\n              copy->next_index_ %= arraysize(elements_);\n              return copy;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Print\",\n            \"parent\": \"AbstractElements\",\n            \"about\": \"Prints the contents of the AbstractElements state for debugging purposes.\",\n            \"logic\": \"Iterates through the elements and prints their object, index, and value nodes.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PrintF\",\n                \"Node::id\",\n                \"node->op()->mnemonic()\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void LoadElimination::AbstractElements::Print() const {\n              for (Element const& element : elements_) {\n                if (element.object) {\n                  PrintF(\"    #%d:%s @ #%d:%s -> #%d:%s\\n\", element.object->id(),\n                         element.object->op()->mnemonic(), element.index->id(),\n                         element.index->op()->mnemonic(), element.value->id(),\n                         element.value->op()->mnemonic());\n                }\n              }\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FieldInfo\",\n            \"about\": \"Represents information about a field.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class LoadElimination::FieldInfo {\n             public:\n                Node* value;\n                MachineRepresentation representation;\n                MaybeHandle<Name> name;\n                ConstFieldInfo const_field_info;\n            };\n        ]]></code>\n    </class>\n\n   <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AbstractField\",\n            \"about\": \"Represents the abstract state of fields of an object during load elimination.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            LoadElimination::FieldInfo const* LoadElimination::AbstractField::Lookup(\n                Node* object) const;\n\n            LoadElimination::AbstractField const* LoadElimination::AbstractField::KillConst(\n                Node* object, Zone* zone) const;\n\n            LoadElimination::AbstractField const* LoadElimination::AbstractField::Kill(\n                const AliasStateInfo& alias_info, MaybeHandle<Name> name,\n                Zone* zone) const;\n\n            void LoadElimination::AbstractField::Print() const;\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Lookup\",\n            \"parent\": \"AbstractField\",\n            \"about\": \"Looks up field information for a given object.\",\n            \"logic\": \"Iterates through the stored field information and checks for a matching object (using MustAlias).\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The object to look up.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"FieldInfo const*\",\n                \"description\": \"The FieldInfo if found, nullptr otherwise.\"\n            },\n            \"dependencies\": [\n                \"MustAlias\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            LoadElimination::FieldInfo const* LoadElimination::AbstractField::Lookup(\n                Node* object) const {\n              for (auto& pair : info_for_node_) {\n                if (pair.first->IsDead()) continue;\n                if (MustAlias(object, pair.first)) return &pair.second;\n              }\n              return nullptr;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MayAlias\",\n            \"about\": \"Checks if two MaybeHandle<Name> objects may alias.\",\n            \"logic\": \"Returns true if either handle is empty or if they point to the same address.\",\n            \"parameters\": [\n                {\n                    \"name\": \"x\",\n                    \"type\": \"MaybeHandle<Name>\",\n                    \"purpose\": \"The first handle.\"\n                },\n                {\n                    \"name\": \"y\",\n                    \"type\": \"MaybeHandle<Name>\",\n                    \"purpose\": \"The second handle.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the handles may alias, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool MayAlias(MaybeHandle<Name> x, MaybeHandle<Name> y) {\n              if (!x.address()) return true;\n              if (!y.address()) return true;\n              if (x.address() != y.address()) return false;\n              return true;\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AliasStateInfo\",\n            \"about\": \"Encapsulates alias state information for load elimination.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class LoadElimination::AliasStateInfo {\n             public:\n              AliasStateInfo(const AbstractState* state, Node* object, MapRef map);\n              AliasStateInfo(const AbstractState* state, Node* object);\n\n              bool MayAlias(Node* other) const;\n\n             private:\n              const AbstractState* state_;\n              Node* object_;\n              OptionalMapRef map_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"MayAlias\",\n            \"parent\": \"AliasStateInfo\",\n            \"about\": \"Checks if the object in this AliasStateInfo may alias with another node.\",\n            \"logic\": \"Considers allocation state, aliasing based on node kind and map information (if available).\",\n            \"parameters\": [\n                {\n                    \"name\": \"other\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to check for aliasing.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the objects may alias, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"object_->opcode()\",\n                \"IrOpcode::kAllocate\",\n                \"object_ == other\",\n                \"compiler::MayAlias\",\n                \"map_.has_value()\",\n                \"state_->LookupMaps\",\n                \"map_ != other_maps.at(0)\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            bool LoadElimination::AliasStateInfo::MayAlias(Node* other) const {\n              // If {object} is being initialized right here (indicated by {object} being\n              // an Allocate node instead of a FinishRegion node), we know that {other}\n              // can only alias with {object} if they refer to exactly the same node.\n              if (object_->opcode() == IrOpcode::kAllocate) {\n                return object_ == other;\n              }\n              // Decide aliasing based on the node kinds.\n              if (!compiler::MayAlias(object_, other)) {\n                return false;\n              }\n              // Decide aliasing based on maps (if available).\n              if (map_.has_value()) {\n                MapRef map = *map_;\n                ZoneRefSet<Map> other_maps;\n                if (state_->LookupMaps(other, &other_maps) && other_maps.size() == 1) {\n                  if (map != other_maps.at(0)) {\n                    return false;\n                  }\n                }\n              }\n              return true;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"KillConst\",\n            \"parent\": \"AbstractField\",\n            \"about\": \"Kills const field information that must alias the given object.\",\n            \"logic\": \"Iterates through the stored field information and removes any const field whose object must alias with the given object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The object to kill const fields for.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate the new AbstractField in.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AbstractField const*\",\n                \"description\": \"A new AbstractField with the aliasing const fields removed, or the original AbstractField if no fields were killed.\"\n            },\n            \"dependencies\": [\n                \"MustAlias\",\n                \"Node::IsDead\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            LoadElimination::AbstractField const* LoadElimination::AbstractField::KillConst(\n                Node* object, Zone* zone) const {\n              for (auto info1 : this->info_for_node_) {\n                if (info1.first->IsDead()) continue;\n                // If we previously recorded information about a const store on the given\n                // 'object', we might not have done it on the same node; e.g. we might now\n                // identify the object by a FinishRegion node, whereas the initial const\n                // store was performed on the Allocate node. We therefore remove information\n                // on all nodes that must alias with 'object'.\n                if (MustAlias(object, info1.first)) {\n                  AbstractField* that = zone->New<AbstractField>(zone);\n                  for (auto info2 : this->info_for_node_) {\n                    if (!MustAlias(object, info2.first)) {\n                      that->info_for_node_.insert(info2);\n                    }\n                  }\n                  return that;\n                }\n              }\n              return this;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Kill\",\n            \"parent\": \"AbstractField\",\n            \"about\": \"Kills field information that may alias the given AliasStateInfo and name.\",\n            \"logic\": \"Iterates through the stored field information and removes any field whose object may alias with the given alias_info's object and name may alias with the given name.\",\n            \"parameters\": [\n                {\n                    \"name\": \"alias_info\",\n                    \"type\": \"const AliasStateInfo&\",\n                    \"purpose\": \"The alias information.\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"MaybeHandle<Name>\",\n                    \"purpose\": \"The name to kill.\"\n                },\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate the new AbstractField in.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AbstractField const*\",\n                \"description\": \"A new AbstractField with the aliasing fields removed, or the original AbstractField if no fields were killed.\"\n            },\n            \"dependencies\": [\n                \"alias_info.MayAlias\",\n                \"MayAlias\",\n                \"Node::"
}