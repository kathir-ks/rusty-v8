{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/gap-resolver.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 81, column 54",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/gap-resolver.cc\",\n        \"file_name\": \"gap-resolver.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Resolves gaps (parallel moves) in the instruction stream by generating appropriate move sequences, handling register allocation conflicts and cycles.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for gap resolution, algorithms, sets, enum sets, and register configuration.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/backend/gap-resolver.h\"\n\n#include <algorithm>\n#include <set>\n\n#include \"src/base/enum-set.h\"\n#include \"src/codegen/register-configuration.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"GapResolver\",\n            \"about\": \"Resolves parallel moves by generating machine code, handling dependencies and cycles.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ParallelMove\",\n                \"Assembler\",\n                \"MoveOperands\",\n                \"InstructionOperand\",\n                \"MachineRepresentation\",\n                \"LocationOperand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass GapResolver {\n public:\n  explicit GapResolver(Assembler* assembler) : assembler_(assembler) {}\n  void Resolve(ParallelMove* moves);\n\n private:\n  Assembler* assembler_;\n\n  void PerformMove(ParallelMove* moves, MoveOperands* move);\n  MoveOperands* PerformMoveHelper(ParallelMove* moves, MoveOperands* move,\n                                   std::vector<MoveOperands*>* cycle);\n  void PerformCycle(const std::vector<MoveOperands*>& cycle);\n  bool IsSwap(MoveOperands* move1, MoveOperands* move2);\n};\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetKind\",\n            \"about\": \"Determines the kind of move operand (constant, general-purpose register, floating-point register, or stack).\",\n            \"logic\": \"Checks if the operand is a constant, then checks its location kind. If it's a register, it checks if it's floating-point. Otherwise, it's a stack slot.\",\n            \"parameters\": [\n                {\n                    \"name\": \"move\",\n                    \"type\": \"const InstructionOperand&\",\n                    \"purpose\": \"The move operand to analyze\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MoveOperandKind\",\n                \"description\": \"The kind of the move operand\"\n            },\n            \"dependencies\": [\n                \"InstructionOperand\",\n                \"LocationOperand\",\n                \"IsFloatingPoint\",\n                \"MoveOperandKind\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nenum MoveOperandKind : uint8_t { kConstant, kGpReg, kFpReg, kStack };\n\nMoveOperandKind GetKind(const InstructionOperand& move) {\n  if (move.IsConstant()) return kConstant;\n  LocationOperand loc_op = LocationOperand::cast(move);\n  if (loc_op.location_kind() != LocationOperand::REGISTER) return kStack;\n  return IsFloatingPoint(loc_op.representation()) ? kFpReg : kGpReg;\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Resolve\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Resolves a parallel move by generating the necessary move instructions, handling conflicts and cycles.\",\n            \"logic\": \"Analyzes the moves, eliminates redundant ones, detects simple non-overlapping moves for a fast path, and resolves more complex moves using the PerformMove function. Uses temporary stack slots if needed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"moves\",\n                    \"type\": \"ParallelMove*\",\n                    \"purpose\": \"The parallel move to resolve\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ParallelMove\",\n                \"MoveOperands\",\n                \"InstructionOperand\",\n                \"AssembleMove\",\n                \"GetKind\",\n                \"PopTempStackSlots\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid GapResolver::Resolve(ParallelMove* moves) {\n  base::EnumSet<MoveOperandKind, uint8_t> source_kinds;\n  base::EnumSet<MoveOperandKind, uint8_t> destination_kinds;\n\n  // Remove redundant moves, collect source kinds and destination kinds to\n  // detect simple non-overlapping moves, and collect FP move representations if\n  // aliasing is non-simple.\n  size_t nmoves = moves->size();\n  for (size_t i = 0; i < nmoves;) {\n    MoveOperands* move = (*moves)[i];\n    if (move->IsRedundant()) {\n      nmoves--;\n      if (i < nmoves) (*moves)[i] = (*moves)[nmoves];\n      continue;\n    }\n    i++;\n    source_kinds.Add(GetKind(move->source()));\n    destination_kinds.Add(GetKind(move->destination()));\n  }\n  if (nmoves != moves->size()) moves->resize(nmoves);\n\n  if ((source_kinds & destination_kinds).empty() || moves->size() < 2) {\n    // Fast path for non-conflicting parallel moves.\n    for (MoveOperands* move : *moves) {\n      assembler_->AssembleMove(&move->source(), &move->destination());\n    }\n    return;\n  }\n\n  for (size_t i = 0; i < moves->size(); ++i) {\n    auto move = (*moves)[i];\n    if (!move->IsEliminated()) PerformMove(moves, move);\n  }\n  assembler_->PopTempStackSlots();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsSwap\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Checks if two moves constitute a swap operation.\",\n            \"logic\": \"Verifies that the source of the first move is the destination of the second, and vice versa. Also checks that conflicting operands have the same representation and are either the same register or stack slots with the same index.\",\n            \"parameters\": [\n                {\n                    \"name\": \"move1\",\n                    \"type\": \"MoveOperands*\",\n                    \"purpose\": \"The first move\"\n                },\n                {\n                    \"name\": \"move2\",\n                    \"type\": \"MoveOperands*\",\n                    \"purpose\": \"The second move\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the two moves form a swap, false otherwise\"\n            },\n            \"dependencies\": [\n                \"MoveOperands\",\n                \"InstructionOperand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Check if a 2-move cycle is a swap. This is not always the case, for instance:\n//\n// [fp_stack:-3|s128] = [xmm5|R|s128]\n// [xmm5|R|s128] = [fp_stack:-4|s128]\n//\n// The two stack operands conflict but start at a different stack offset, so a\n// swap would be incorrect.\n// In general, swapping is allowed if the conflicting operands:\n// - Have the same representation, and\n// - Are the same register, or are stack slots with the same index\nbool GapResolver::IsSwap(MoveOperands* move1, MoveOperands* move2) {\n  return move1->source() == move2->destination() &&\n         move2->source() == move1->destination();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PerformCycle\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Performs a cycle of moves by using a temporary location.\",\n            \"logic\": \"If the cycle is a simple swap, calls AssembleSwap. Otherwise, moves the source of the last move in the cycle to a temporary location, assembles the remaining moves, and then moves the temporary location to the last move's destination.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cycle\",\n                    \"type\": \"const std::vector<MoveOperands*>&\",\n                    \"purpose\": \"The cycle of moves to perform\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"MoveOperands\",\n                \"InstructionOperand\",\n                \"AssembleSwap\",\n                \"SetPendingMove\",\n                \"MoveToTempLocation\",\n                \"AssembleMove\",\n                \"MoveTempLocationTo\",\n                \"MachineRepresentation\",\n                \"LocationOperand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid GapResolver::PerformCycle(const std::vector<MoveOperands*>& cycle) {\n  DCHECK(!cycle.empty());\n  MoveOperands* move1 = cycle.back();\n  if (cycle.size() == 2 && IsSwap(cycle.front(), cycle.back())) {\n    // Call {AssembleSwap} which can generate better code than the generic\n    // algorithm below in some cases.\n    MoveOperands* move2 = cycle.front();\n    InstructionOperand* source = &move1->source();\n    InstructionOperand* destination = &move1->destination();\n    // Ensure source is a register or both are stack slots, to limit swap\n    // cases.\n    if (source->IsAnyStackSlot()) {\n      std::swap(source, destination);\n    }\n    assembler_->AssembleSwap(source, destination);\n    move1->Eliminate();\n    move2->Eliminate();\n    return;\n  }\n  // Generic move-cycle algorithm. The cycle of size n is ordered such that the\n  // move at index i % n blocks the move at index (i + 1) % n.\n  // - Move the source of the last move to a platform-specific temporary\n  // location.\n  // - Assemble the remaining moves from left to right. The first move was\n  // unblocked by the temporary location, and each move unblocks the next one.\n  // - Move the temporary location to the last move's destination, thereby\n  // completing the cycle.\n  // To ensure that the temporary location does not conflict with any scratch\n  // register used during the move cycle, the platform implements\n  // {SetPendingMove}, which marks the registers needed for the given moves.\n  // {MoveToTempLocation} will then choose the location accordingly.\n  MachineRepresentation rep =\n      LocationOperand::cast(move1->destination()).representation();\n  for (size_t i = 0; i < cycle.size() - 1; ++i) {\n    assembler_->SetPendingMove(cycle[i]);\n  }\n  assembler_->MoveToTempLocation(&move1->source(), rep);\n  InstructionOperand destination = move1->destination();\n  move1->Eliminate();\n  for (size_t i = 0; i < cycle.size() - 1; ++i) {\n    assembler_->AssembleMove(&cycle[i]->source(), &cycle[i]->destination());\n    cycle[i]->Eliminate();\n  }\n  assembler_->MoveTempLocationTo(&destination, rep);\n  // We do not need to update the sources of the remaining moves in the parallel\n  // move. If any of the remaining moves had the same source as one of the moves\n  // in the cycle, it would block the cycle and would have already been\n  // assembled by {PerformMoveHelper}.\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PerformMove\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Performs a single move, handling dependencies and potential cycles.\",\n            \"logic\": \"Calls PerformMoveHelper to attempt to resolve the move. If PerformMoveHelper returns a blocking move (indicating a cycle), pushes the source of the blocking move to the stack to break the cycle and retries.\",\n            \"parameters\": [\n                {\n                    \"name\": \"moves\",\n                    \"type\": \"ParallelMove*\",\n                    \"purpose\": \"The parallel move containing the move to perform\"\n                },\n                {\n                    \"name\": \"move\",\n                    \"type\": \"MoveOperands*\",\n                    \"purpose\": \"The move to perform\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"ParallelMove\",\n                \"MoveOperands\",\n                \"PerformMoveHelper\",\n                \"Push\",\n                \"InstructionOperand\",\n                \"AllocatedOperand\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid GapResolver::PerformMove(ParallelMove* moves, MoveOperands* move) {\n  // Try to perform the move and its dependencies with {PerformMoveHelper}.\n  // This helper function will be able to solve most cases, including cycles.\n  // But for some rare cases, it will bail out and return one of the\n  // problematic moves. In this case, push the source to the stack to\n  // break the cycles that it belongs to, and try again.\n  std::vector<MoveOperands*> cycle;\n  while (MoveOperands* blocking_move = PerformMoveHelper(moves, move, &cycle)) {\n    // Push an arbitrary operand of the cycle to break it.\n    AllocatedOperand scratch = assembler_->Push(&blocking_move->source());\n    InstructionOperand source = blocking_move->source();\n    for (auto m : *moves) {\n      if (m->source() == source) {\n        m->set_source(scratch);\n      }\n    }\n    cycle.clear();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PerformMoveHelper\",\n            \"parent\": \"GapResolver\",\n            \"about\": \"Recursively performs a move and its dependencies, detecting and handling cycles.\",\n            \"logic\": \"Uses a DFS traversal to assemble moves in post-order, marking moves as pending to detect cycles. If a cycle is detected, reconstructs the cycle and returns to PerformMove to break it. Otherwise, assembles the move.\",\n            \"parameters\": [\n                {\n                    \"name\": \"moves\",\n                    \"type\": \"ParallelMove*\",\n                    \"purpose\": \"The parallel move containing the move to perform\"\n                },\n                {\n                    \"name\": \"move\",\n                    \"type\": \"MoveOperands*\",\n                    \"purpose\": \"The move to perform\"\n                },\n                {\n                    \"name\": \"cycle\",\n                    \"type\": \"std::vector<MoveOperands*>*\",\n                    \"purpose\": \"A vector to store the cycle of moves, if one is detected\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MoveOperands*\",\n                \"description\": \"A pointer to a blocking move if a cycle is detected and needs to be broken, nullptr otherwise\"\n            },\n            \"dependencies\": [\n                \"ParallelMove\",\n                \"MoveOperands\",\n                \"InstructionOperand\",\n                \"InterferesWith\",\n                \"PerformCycle\",\n                \"AssembleMove\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMoveOperands* GapResolver::PerformMoveHelper(\n    ParallelMove* moves, MoveOperands* move,\n    std::vector<MoveOperands*>* cycle) {\n  // We interpret moves as nodes in a graph. x is a successor of y (x blocks y)\n  // if x.source() conflicts with y.destination(). We recursively assemble the\n  // moves in this graph in post-order using a DFS traversal, such that all\n  // blocking moves are assembled first.\n  // We also mark moves in the current DFS branch as pending. If a move is\n  // blocked by a pending move, this is a cycle. In this case we just\n  // reconstruct the cycle on the way back, and assemble it using {PerformCycle}\n  // when we reach the first move.\n  // This algorithm can only process one cycle at a time. If another cycle is\n  // found while the first one is still being processed, we bail out.\n  // The caller breaks the cycle using a temporary stack slot, and we try\n  // again.\n\n  DCHECK(!move->IsPending());\n  DCHECK(!move->IsRedundant());\n\n  // Clear this move's destination to indicate a pending move.  The actual\n  // destination is saved on the side.\n  InstructionOperand source = move->source();\n  DCHECK(!source.IsInvalid());  // Or else it will look eliminated.\n  InstructionOperand destination = move->destination();\n  move->SetPending();\n  MoveOperands* blocking_move = nullptr;\n\n  for (size_t i = 0; i < moves->size(); ++i) {\n    auto other = (*moves)[i];\n    if (other->IsEliminated()) continue;\n    if (other == move) continue;\n    if (other->source().InterferesWith(destination)) {\n      if (other->IsPending()) {\n        // The conflicting move is pending, we found a cycle. Build the list of\n        // moves that belong to the cycle on the way back.\n        // If this move already belongs to a cycle, bail out.\n        if (!cycle->empty()) {\n          blocking_move = cycle->front();\n          break;\n        }\n        // Initialize the cycle with {other} and reconstruct the rest of the\n        // cycle on the way back.\n        cycle->push_back(other);\n      } else {\n        std::vector<MoveOperands*> cycle_rec;\n        blocking_move = PerformMoveHelper(moves, other, &cycle_rec);\n        if (blocking_move) break;\n        if (!cycle->empty() && !cycle_rec.empty()) {\n          blocking_move = cycle_rec.front();\n          break;\n        }\n        if (cycle->empty() && !cycle_rec.empty()) {\n          *cycle = std::move(cycle_rec);\n        }\n      }\n    }\n  }\n\n  // We finished processing all the blocking moves and don't need this one\n  // marked as pending anymore, restore its destination.\n  move->set_destination(destination);\n\n  if (blocking_move != nullptr) return blocking_move;\n\n  if (!cycle->empty()) {\n    if (cycle->front() == move) {\n      // We returned to the topmost move in the cycle and assembled all the\n      // other dependencies. Assemble the cycle.\n      PerformCycle(*cycle);\n      cycle->clear();\n    } else {\n      cycle->push_back(move);\n    }\n  } else {\n    assembler_->AssembleMove(&source, &destination);\n    move->Eliminate();\n  }\n  return nullptr;\n}\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ParallelMove\",\n                \"about\": \"Represents a set of parallel moves to be performed.\",\n                \"dependencies\": [\n                    \"MoveOperands\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nclass ParallelMove {\n public:\n  size_t size() const;\n  void resize(size_t n);\n  MoveOperands* operator[](size_t i);\n  // Other methods and members...\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Assembler\",\n                \"about\": \"Provides an interface for generating machine code.\",\n                \"dependencies\": [\n                    \"InstructionOperand\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nclass Assembler {\n public:\n  void AssembleMove(InstructionOperand* source, InstructionOperand* destination);\n  void AssembleSwap(InstructionOperand* source, InstructionOperand* destination);\n  void MoveToTempLocation(InstructionOperand* source, MachineRepresentation rep);\n  void MoveTempLocationTo(InstructionOperand* destination, MachineRepresentation rep);\n  void SetPendingMove(MoveOperands* move);\n  AllocatedOperand Push(InstructionOperand* operand);\n  void PopTempStackSlots();\n  // Other methods and members...\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"MoveOperands\",\n                \"about\": \"Represents a single move operation.\",\n                \"dependencies\": [\n                    \"InstructionOperand\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nclass MoveOperands {\n public:\n  InstructionOperand& source();\n  InstructionOperand& destination();\n  bool IsRedundant() const;\n  void Eliminate();\n  bool IsEliminated() const;\n  void SetPending();\n  bool IsPending() const;\n  void set_source(const InstructionOperand& source);\n  void set_destination(const InstructionOperand& destination);\n  // Other methods and members...\n};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"InstructionOperand\",\n                \"about\": \"Represents an operand of a machine instruction (register, stack slot, constant, etc.).\"\n            }\n            </metadata>\n            <code><![CDATA[\nclass InstructionOperand {\n public:\n  bool IsConstant() const;\n  bool IsInvalid() const;\n  bool IsAnyStackSlot() const;\n  bool InterferesWith(const InstructionOperand& other) const;\n  // Other methods and members...\n};\n            ]]></code>\n        </class>\n         <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocationOperand\",\n                \"about\": \"Represents an operand with a specific location (register or stack slot).\",\n                \"dependencies\": [\n                    \"InstructionOperand\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nclass LocationOperand : public InstructionOperand {\n public:\n  enum LocationKind {\n    REGISTER,\n    STACK_SLOT\n  };\n  LocationKind location_kind() const;\n  MachineRepresentation representation() const;\n  static LocationOperand cast(const InstructionOperand& operand);\n  // Other methods and members...\n};\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"MachineRepresentation\",\n                \"about\": \"Represents the data type of a value in the machine.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\nenum class MachineRepresentation {\n  kNone,\n  kBit,\n  kWord8,\n  kWord16,\n  kWord32,\n  kWord64,\n  kFloat32,\n  kFloat64,\n  kSimd128,\n  kTaggedSigned,\n  kTaggedPointer,\n  kTagged,\n  kLast = kTagged\n};\n            ]]></code>\n        </enum>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsFloatingPoint\",\n                \"about\": \"Checks if a given MachineRepresentation represents a floating-point value.\",\n                \"dependencies\": [\n                    \"MachineRepresentation\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nbool IsFloatingPoint(MachineRepresentation rep) {\n  return rep == MachineRepresentation::kFloat32 ||\n         rep == MachineRepresentation::kFloat64;\n}\n            ]]></code>\n        </func>\n         <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AllocatedOperand\",\n                \"about\": \"Represents an operand that has been allocated a specific location (e.g., a stack slot).\",\n                \"dependencies\": [\n                    \"InstructionOperand\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\nclass AllocatedOperand : public InstructionOperand {\n public:\n  // Methods to access allocated location\n};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}