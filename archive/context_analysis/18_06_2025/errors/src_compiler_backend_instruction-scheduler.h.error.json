{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-scheduler.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 320, column 56",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction-scheduler.h\",\n        \"file_name\": \"instruction-scheduler.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the InstructionScheduler class, which is responsible for scheduling instructions within a basic block to improve performance.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for standard library features, V8 base utilities, compiler backend components, and zone management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/utils/random-number-generator.h\"\n#include \"src/compiler/backend/instruction.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"ArchOpcodeFlags\",\n            \"about\": \"Defines flags representing properties of instructions, used to determine dependencies during scheduling.\",\n            \"values\": [\n                \"kNoOpcodeFlags\",\n                \"kHasSideEffect\",\n                \"kIsLoadOperation\",\n                \"kMayNeedDeoptOrTrapCheck\",\n                \"kIsBarrier\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nenum ArchOpcodeFlags {\n  kNoOpcodeFlags = 0,\n  kHasSideEffect = 1,    // The instruction has some side effects (memory\n                         // store, function call...)\n  kIsLoadOperation = 2,  // The instruction is a memory load.\n  kMayNeedDeoptOrTrapCheck = 4,  // The instruction may be associated with a\n                                 // deopt or trap check which must be run before\n                                 // instruction e.g. div on Intel platform which\n                                 // will raise an exception when the divisor is\n                                 // zero.\n  kIsBarrier = 8,  // The instruction can cause GC or it reads/writes registers\n                   // that are not explicitly given. Nothing can be reordered\n                   // across such an instruction.\n};\n        ]]></code>\n    </enum>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"InstructionScheduler\",\n            \"extends\": \"ZoneObject\",\n            \"about\": \"Schedules instructions within a basic block to improve performance by considering dependencies and latencies.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"RpoNumber\",\n                \"InstructionSequence\",\n                \"Instruction\",\n                \"ScheduleGraphNode\",\n                \"SchedulingQueueBase\",\n                \"CriticalPathFirstQueue\",\n                \"StressSchedulerQueue\",\n                \"Zone\",\n                \"ZoneVector\",\n                \"ZoneMap\",\n                \"std::optional\",\n                \"base::RandomNumberGenerator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass InstructionScheduler final : public ZoneObject {\n public:\n  V8_EXPORT_PRIVATE InstructionScheduler(Zone* zone,\n                                         InstructionSequence* sequence);\n\n  V8_EXPORT_PRIVATE void StartBlock(RpoNumber rpo);\n  V8_EXPORT_PRIVATE void EndBlock(RpoNumber rpo);\n\n  V8_EXPORT_PRIVATE void AddInstruction(Instruction* instr);\n  V8_EXPORT_PRIVATE void AddTerminator(Instruction* instr);\n\n  static bool SchedulerSupported();\n\n private:\n  // A scheduling graph node.\n  // Represent an instruction and their dependencies.\n  class ScheduleGraphNode : public ZoneObject {\n   public:\n    ScheduleGraphNode(Zone* zone, Instruction* instr);\n\n    // Mark the instruction represented by 'node' as a dependency of this one.\n    // The current instruction will be registered as an unscheduled predecessor\n    // of 'node' (i.e. it must be scheduled before 'node').\n    void AddSuccessor(ScheduleGraphNode* node);\n\n    // Check if all the predecessors of this instruction have been scheduled.\n    bool HasUnscheduledPredecessor() {\n      return unscheduled_predecessors_count_ != 0;\n    }\n\n    // Record that we have scheduled one of the predecessors of this node.\n    void DropUnscheduledPredecessor() {\n      DCHECK_LT(0, unscheduled_predecessors_count_);\n      unscheduled_predecessors_count_--;\n    }\n\n    Instruction* instruction() { return instr_; }\n    ZoneDeque<ScheduleGraphNode*>& successors() { return successors_; }\n    int latency() const { return latency_; }\n\n    int total_latency() const { return total_latency_; }\n    void set_total_latency(int latency) { total_latency_ = latency; }\n\n    int start_cycle() const { return start_cycle_; }\n    void set_start_cycle(int start_cycle) { start_cycle_ = start_cycle; }\n\n   private:\n    Instruction* instr_;\n    ZoneDeque<ScheduleGraphNode*> successors_;\n\n    // Number of unscheduled predecessors for this node.\n    int unscheduled_predecessors_count_;\n\n    // Estimate of the instruction latency (the number of cycles it takes for\n    // instruction to complete).\n    int latency_;\n\n    // The sum of all the latencies on the path from this node to the end of\n    // the graph (i.e. a node with no successor).\n    int total_latency_;\n\n    // The scheduler keeps a nominal cycle count to keep track of when the\n    // result of an instruction is available. This field is updated by the\n    // scheduler to indicate when the value of all the operands of this\n    // instruction will be available.\n    int start_cycle_;\n  };\n\n  // Keep track of all nodes ready to be scheduled (i.e. all their dependencies\n  // have been scheduled. Note that this class is inteded to be extended by\n  // concrete implementation of the scheduling queue which define the policy\n  // to pop node from the queue.\n  class SchedulingQueueBase {\n   public:\n    explicit SchedulingQueueBase(InstructionScheduler* scheduler)\n        : scheduler_(scheduler), nodes_(scheduler->zone()) {}\n\n    void AddNode(ScheduleGraphNode* node);\n\n    bool IsEmpty() const { return nodes_.empty(); }\n\n   protected:\n    InstructionScheduler* scheduler_;\n    ZoneLinkedList<ScheduleGraphNode*> nodes_;\n  };\n\n  // A scheduling queue which prioritize nodes on the critical path (we look\n  // for the instruction with the highest latency on the path to reach the end\n  // of the graph).\n  class CriticalPathFirstQueue : public SchedulingQueueBase {\n   public:\n    explicit CriticalPathFirstQueue(InstructionScheduler* scheduler)\n        : SchedulingQueueBase(scheduler) {}\n\n    // Look for the best candidate to schedule, remove it from the queue and\n    // return it.\n    ScheduleGraphNode* PopBestCandidate(int cycle);\n  };\n\n  // A queue which pop a random node from the queue to perform stress tests on\n  // the scheduler.\n  class StressSchedulerQueue : public SchedulingQueueBase {\n   public:\n    explicit StressSchedulerQueue(InstructionScheduler* scheduler)\n        : SchedulingQueueBase(scheduler) {}\n\n    ScheduleGraphNode* PopBestCandidate(int cycle);\n\n   private:\n    base::RandomNumberGenerator* random_number_generator() {\n      return scheduler_->random_number_generator();\n    }\n  };\n\n  // Perform scheduling for the current block specifying the queue type to\n  // use to determine the next best candidate.\n  template <typename QueueType>\n  void Schedule();\n\n  // Return the scheduling properties of the given instruction.\n  V8_EXPORT_PRIVATE int GetInstructionFlags(const Instruction* instr) const;\n  int GetTargetInstructionFlags(const Instruction* instr) const;\n\n  bool IsBarrier(const Instruction* instr) const {\n    return (GetInstructionFlags(instr) & kIsBarrier) != 0;\n  }\n\n  // Check whether the given instruction has side effects (e.g. function call,\n  // memory store).\n  bool HasSideEffect(const Instruction* instr) const {\n    return (GetInstructionFlags(instr) & kHasSideEffect) != 0;\n  }\n\n  // Return true if the instruction is a memory load.\n  bool IsLoadOperation(const Instruction* instr) const {\n    return (GetInstructionFlags(instr) & kIsLoadOperation) != 0;\n  }\n\n  bool CanTrap(const Instruction* instr) const {\n    return instr->IsTrap() ||\n           (instr->HasMemoryAccessMode() &&\n            instr->memory_access_mode() != kMemoryAccessDirect);\n  }\n\n  // The scheduler will not move the following instructions before the last\n  // deopt/trap check:\n  //  * loads (this is conservative)\n  //  * instructions with side effect\n  //  * other deopts/traps\n  // Any other instruction can be moved, apart from those that raise exceptions\n  // on specific inputs - these are filtered out by the deopt/trap check.\n  bool MayNeedDeoptOrTrapCheck(const Instruction* instr) const {\n    return (GetInstructionFlags(instr) & kMayNeedDeoptOrTrapCheck) != 0;\n  }\n\n  // Return true if the instruction cannot be moved before the last deopt or\n  // trap point we encountered.\n  bool DependsOnDeoptOrTrap(const Instruction* instr) const {\n    return MayNeedDeoptOrTrapCheck(instr) || instr->IsDeoptimizeCall() ||\n           CanTrap(instr) || HasSideEffect(instr) || IsLoadOperation(instr);\n  }\n\n  // Identify nops used as a definition point for live-in registers at\n  // function entry.\n  bool IsFixedRegisterParameter(const Instruction* instr) const {\n    return (instr->arch_opcode() == kArchNop) && (instr->OutputCount() == 1) &&\n           (instr->OutputAt(0)->IsUnallocated()) &&\n           (UnallocatedOperand::cast(instr->OutputAt(0))\n                ->HasFixedRegisterPolicy() ||\n            UnallocatedOperand::cast(instr->OutputAt(0))\n                ->HasFixedFPRegisterPolicy());\n  }\n\n  void ComputeTotalLatencies();\n\n  static int GetInstructionLatency(const Instruction* instr);\n\n  Zone* zone() { return zone_; }\n  InstructionSequence* sequence() { return sequence_; }\n  base::RandomNumberGenerator* random_number_generator() {\n    return &random_number_generator_.value();\n  }\n\n  Zone* zone_;\n  InstructionSequence* sequence_;\n  ZoneVector<ScheduleGraphNode*> graph_;\n\n  friend class InstructionSchedulerTester;\n\n  // Last side effect instruction encountered while building the graph.\n  ScheduleGraphNode* last_side_effect_instr_;\n\n  // Set of load instructions encountered since the last side effect instruction\n  // which will be added as predecessors of the next instruction with side\n  // effects.\n  ZoneVector<ScheduleGraphNode*> pending_loads_;\n\n  // Live-in register markers are nop instructions which are emitted at the\n  // beginning of a basic block so that the register allocator will find a\n  // defining instruction for live-in values. They must not be moved.\n  // All these nops are chained together and added as a predecessor of every\n  // other instructions in the basic block.\n  ScheduleGraphNode* last_live_in_reg_marker_;\n\n  // Last deoptimization or trap instruction encountered while building the\n  // graph.\n  ScheduleGraphNode* last_deopt_or_trap_;\n\n  // Keep track of definition points for virtual registers. This is used to\n  // record operand dependencies in the scheduling graph.\n  ZoneMap<int32_t, ScheduleGraphNode*> operands_map_;\n\n  std::optional<base::RandomNumberGenerator> random_number_generator_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ScheduleGraphNode\",\n            \"extends\": \"ZoneObject\",\n            \"about\": \"Represents an instruction and its dependencies in the scheduling graph.\",\n            \"attributes\": [\n                {\n                    \"name\": \"instr_\",\n                    \"type\": \"Instruction*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The instruction represented by this node.\"\n                },\n                {\n                    \"name\": \"successors_\",\n                    \"type\": \"ZoneDeque<ScheduleGraphNode*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A list of successor nodes (instructions that depend on this one).\"\n                },\n                {\n                    \"name\": \"unscheduled_predecessors_count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The number of unscheduled predecessors (instructions that this one depends on).\"\n                },\n                {\n                    \"name\": \"latency_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"An estimate of the instruction's latency (the number of cycles it takes to complete).\"\n                },\n                {\n                    \"name\": \"total_latency_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The sum of all latencies on the path from this node to the end of the graph.\"\n                },\n                {\n                    \"name\": \"start_cycle_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The nominal cycle count when the result of the instruction is available.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Instruction\",\n                \"ZoneDeque\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ScheduleGraphNode : public ZoneObject {\n   public:\n    ScheduleGraphNode(Zone* zone, Instruction* instr);\n\n    // Mark the instruction represented by 'node' as a dependency of this one.\n    // The current instruction will be registered as an unscheduled predecessor\n    // of 'node' (i.e. it must be scheduled before 'node').\n    void AddSuccessor(ScheduleGraphNode* node);\n\n    // Check if all the predecessors of this instruction have been scheduled.\n    bool HasUnscheduledPredecessor() {\n      return unscheduled_predecessors_count_ != 0;\n    }\n\n    // Record that we have scheduled one of the predecessors of this node.\n    void DropUnscheduledPredecessor() {\n      DCHECK_LT(0, unscheduled_predecessors_count_);\n      unscheduled_predecessors_count_--;\n    }\n\n    Instruction* instruction() { return instr_; }\n    ZoneDeque<ScheduleGraphNode*>& successors() { return successors_; }\n    int latency() const { return latency_; }\n\n    int total_latency() const { return total_latency_; }\n    void set_total_latency(int latency) { total_latency_ = latency; }\n\n    int start_cycle() const { return start_cycle_; }\n    void set_start_cycle(int start_cycle) { start_cycle_ = start_cycle; }\n\n   private:\n    Instruction* instr_;\n    ZoneDeque<ScheduleGraphNode*> successors_;\n\n    // Number of unscheduled predecessors for this node.\n    int unscheduled_predecessors_count_;\n\n    // Estimate of the instruction latency (the number of cycles it takes for\n    // instruction to complete).\n    int latency_;\n\n    // The sum of all the latencies on the path from this node to the end of\n    // the graph (i.e. a node with no successor).\n    int total_latency_;\n\n    // The scheduler keeps a nominal cycle count to keep track of when the\n    // result of an instruction is available. This field is updated by the\n    // scheduler to indicate when the value of all the operands of this\n    // instruction will be available.\n    int start_cycle_;\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SchedulingQueueBase\",\n            \"about\": \"Base class for scheduling queues, which manage nodes that are ready to be scheduled.\",\n            \"attributes\": [\n                {\n                    \"name\": \"scheduler_\",\n                    \"type\": \"InstructionScheduler*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"A pointer to the instruction scheduler.\"\n                },\n                {\n                    \"name\": \"nodes_\",\n                    \"type\": \"ZoneLinkedList<ScheduleGraphNode*>\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"A list of nodes that are ready to be scheduled.\"\n                }\n            ],\n            \"dependencies\": [\n                \"InstructionScheduler\",\n                \"ScheduleGraphNode\",\n                \"ZoneLinkedList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass SchedulingQueueBase {\n   public:\n    explicit SchedulingQueueBase(InstructionScheduler* scheduler)\n        : scheduler_(scheduler), nodes_(scheduler->zone()) {}\n\n    void AddNode(ScheduleGraphNode* node);\n\n    bool IsEmpty() const { return nodes_.empty(); }\n\n   protected:\n    InstructionScheduler* scheduler_;\n    ZoneLinkedList<ScheduleGraphNode*> nodes_;\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CriticalPathFirstQueue\",\n            \"extends\": \"SchedulingQueueBase\",\n            \"about\": \"A scheduling queue that prioritizes nodes on the critical path (nodes with the highest latency to the end of the graph).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"InstructionScheduler\",\n                \"ScheduleGraphNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass CriticalPathFirstQueue : public SchedulingQueueBase {\n   public:\n    explicit CriticalPathFirstQueue(InstructionScheduler* scheduler)\n        : SchedulingQueueBase(scheduler) {}\n\n    // Look for the best candidate to schedule, remove it from the queue and\n    // return it.\n    ScheduleGraphNode* PopBestCandidate(int cycle);\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StressSchedulerQueue\",\n            \"extends\": \"SchedulingQueueBase\",\n            \"about\": \"A scheduling queue that pops a random node from the queue, used for stress testing the scheduler.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"InstructionScheduler\",\n                \"ScheduleGraphNode\",\n                \"base::RandomNumberGenerator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass StressSchedulerQueue : public SchedulingQueueBase {\n   public:\n    explicit StressSchedulerQueue(InstructionScheduler* scheduler)\n        : SchedulingQueueBase(scheduler) {}\n\n    ScheduleGraphNode* PopBestCandidate(int cycle);\n\n   private:\n    base::RandomNumberGenerator* random_number_generator() {\n      return scheduler_->random_number_generator();\n    }\n  };\n        ]]></code>\n    </class>\n</file>\n```"
}