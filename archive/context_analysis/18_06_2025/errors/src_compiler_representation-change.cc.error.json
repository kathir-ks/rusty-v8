{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/representation-change.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/representation-change.cc\",\n        \"file_name\": \"representation-change.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements representation changes for the compiler, handling conversions between different data representations used in the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for representation changes, standard library, base utilities, compiler components, and heap management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/representation-change.h\"\n\n#include <sstream>\n\n#include \"src/base/safe_conversions.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/simplified-lowering-verifier.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/type-cache.h\"\n#include \"src/compiler/use-info.h\"\n#include \"src/heap/factory-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Truncation\",\n            \"about\": \"Represents the truncation state for values, indicating how a value is being used (e.g., as a boolean, word32, etc.)\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass Truncation {\n public:\n  enum class TruncationKind {\n    kNone,\n    kBool,\n    kWord32,\n    kWord64,\n    kOddballAndBigIntToNumber,\n    kAny\n  };\n  \n  enum class IdentifyZeros {\n    kDistinguishZeros,\n    kIdentifyZeros\n  };\n  \n  TruncationKind kind() const { return kind_; }\n  IdentifyZeros identify_zeros() const { return identify_zeros_; }\n\n  const char* description() const;\n\n  static TruncationKind Generalize(TruncationKind rep1, TruncationKind rep2);\n  static IdentifyZeros GeneralizeIdentifyZeros(IdentifyZeros i1,\n                                                  IdentifyZeros i2);\n  static bool LessGeneral(TruncationKind rep1, TruncationKind rep2);\n  static bool LessGeneralIdentifyZeros(IdentifyZeros i1, IdentifyZeros i2);\n\n  bool IsUsedAsWord32() const { return kind() == TruncationKind::kWord32; }\n  bool TruncatesOddballAndBigIntToNumber() const { return kind() == TruncationKind::kOddballAndBigIntToNumber; }\n  bool IdentifiesZeroAndMinusZero() const { return identify_zeros() == IdentifyZeros::kIdentifyZeros; }\n\n private:\n  TruncationKind kind_;\n  IdentifyZeros identify_zeros_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"description\",\n            \"parent\": \"Truncation\",\n            \"about\": \"Returns a string description of the truncation kind.\",\n            \"logic\": \"A switch statement returns a string based on the TruncationKind enum.  Includes handling of identify_zeros.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"const char*\",\n                \"description\": \"String representation of the truncation kind\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nconst char* Truncation::description() const {\n  switch (kind()) {\n    case TruncationKind::kNone:\n      return \"no-value-use\";\n    case TruncationKind::kBool:\n      return \"truncate-to-bool\";\n    case TruncationKind::kWord32:\n      return \"truncate-to-word32\";\n    case TruncationKind::kWord64:\n      return \"truncate-to-word64\";\n    case TruncationKind::kOddballAndBigIntToNumber:\n      switch (identify_zeros()) {\n        case kIdentifyZeros:\n          return \"truncate-oddball&bigint-to-number (identify zeros)\";\n        case kDistinguishZeros:\n          return \"truncate-oddball&bigint-to-number (distinguish zeros)\";\n      }\n    case TruncationKind::kAny:\n      switch (identify_zeros()) {\n        case kIdentifyZeros:\n          return \"no-truncation (but identify zeros)\";\n        case kDistinguishZeros:\n          return \"no-truncation (but distinguish zeros)\";\n      }\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Generalize\",\n            \"parent\": \"Truncation\",\n            \"about\": \"Generalizes two TruncationKind values to a more general type.\",\n            \"logic\": \"Uses LessGeneral to find the more general of two truncation types. If neither is more general, returns kOddballAndBigIntToNumber if both are less general than that, kAny if both are less general than kAny, otherwise FATAL.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rep1\",\n                    \"type\": \"TruncationKind\",\n                    \"purpose\": \"First truncation kind to generalize\"\n                },\n                {\n                    \"name\": \"rep2\",\n                    \"type\": \"TruncationKind\",\n                    \"purpose\": \"Second truncation kind to generalize\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"TruncationKind\",\n                \"description\": \"The generalized truncation kind\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nTruncation::TruncationKind Truncation::Generalize(TruncationKind rep1,\n                                                  TruncationKind rep2) {\n  if (LessGeneral(rep1, rep2)) return rep2;\n  if (LessGeneral(rep2, rep1)) return rep1;\n  // Handle the generalization of float64-representable values.\n  if (LessGeneral(rep1, TruncationKind::kOddballAndBigIntToNumber) &&\n      LessGeneral(rep2, TruncationKind::kOddballAndBigIntToNumber)) {\n    return TruncationKind::kOddballAndBigIntToNumber;\n  }\n  // Handle the generalization of any-representable values.\n  if (LessGeneral(rep1, TruncationKind::kAny) &&\n      LessGeneral(rep2, TruncationKind::kAny)) {\n    return TruncationKind::kAny;\n  }\n  // All other combinations are illegal.\n  FATAL(\"Tried to combine incompatible truncations\");\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GeneralizeIdentifyZeros\",\n            \"parent\": \"Truncation\",\n            \"about\": \"Generalizes two IdentifyZeros values.\",\n            \"logic\": \"Returns i1 if i1 == i2, otherwise returns kDistinguishZeros.\",\n            \"parameters\": [\n                {\n                    \"name\": \"i1\",\n                    \"type\": \"IdentifyZeros\",\n                    \"purpose\": \"First IdentifyZeros value\"\n                },\n                {\n                    \"name\": \"i2\",\n                    \"type\": \"IdentifyZeros\",\n                    \"purpose\": \"Second IdentifyZeros value\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"IdentifyZeros\",\n                \"description\": \"Generalized IdentifyZeros value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nIdentifyZeros Truncation::GeneralizeIdentifyZeros(IdentifyZeros i1,\n                                                  IdentifyZeros i2) {\n  if (i1 == i2) {\n    return i1;\n  } else {\n    return kDistinguishZeros;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LessGeneral\",\n            \"parent\": \"Truncation\",\n            \"about\": \"Determines if one TruncationKind is less general than another.\",\n            \"logic\": \"Uses a switch statement to determine the relationship between two TruncationKind values.  Implements a partial order.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rep1\",\n                    \"type\": \"TruncationKind\",\n                    \"purpose\": \"First truncation kind\"\n                },\n                {\n                    \"name\": \"rep2\",\n                    \"type\": \"TruncationKind\",\n                    \"purpose\": \"Second truncation kind\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if rep1 is less general than rep2, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool Truncation::LessGeneral(TruncationKind rep1, TruncationKind rep2) {\n  switch (rep1) {\n    case TruncationKind::kNone:\n      return true;\n    case TruncationKind::kBool:\n      return rep2 == TruncationKind::kBool || rep2 == TruncationKind::kAny;\n    case TruncationKind::kWord32:\n      return rep2 == TruncationKind::kWord32 ||\n             rep2 == TruncationKind::kWord64 ||\n             rep2 == TruncationKind::kOddballAndBigIntToNumber ||\n             rep2 == TruncationKind::kAny;\n    case TruncationKind::kWord64:\n      return rep2 == TruncationKind::kWord64 ||\n             rep2 == TruncationKind::kOddballAndBigIntToNumber ||\n             rep2 == TruncationKind::kAny;\n    case TruncationKind::kOddballAndBigIntToNumber:\n      return rep2 == TruncationKind::kOddballAndBigIntToNumber ||\n             rep2 == TruncationKind::kAny;\n    case TruncationKind::kAny:\n      return rep2 == TruncationKind::kAny;\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LessGeneralIdentifyZeros\",\n            \"parent\": \"Truncation\",\n            \"about\": \"Determines if one IdentifyZeros is less general than another.\",\n            \"logic\": \"Returns true if i1 == i2 or i1 == kIdentifyZeros.\",\n            \"parameters\": [\n                {\n                    \"name\": \"i1\",\n                    \"type\": \"IdentifyZeros\",\n                    \"purpose\": \"First IdentifyZeros value\"\n                },\n                {\n                    \"name\": \"i2\",\n                    \"type\": \"IdentifyZeros\",\n                    \"purpose\": \"Second IdentifyZeros value\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if i1 is less general than i2, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool Truncation::LessGeneralIdentifyZeros(IdentifyZeros i1, IdentifyZeros i2) {\n  return i1 == i2 || i1 == kIdentifyZeros;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsWord\",\n            \"parent\": \"\",\n            \"about\": \"Checks if a given MachineRepresentation is a word representation (8, 16, or 32 bits).\",\n            \"logic\": \"Returns true if the representation is kWord8, kWord16, or kWord32.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rep\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The machine representation to check\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the representation is a word, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nbool IsWord(MachineRepresentation rep) {\n  return rep == MachineRepresentation::kWord8 ||\n         rep == MachineRepresentation::kWord16 ||\n         rep == MachineRepresentation::kWord32;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TypeCheckIsBigInt\",\n            \"parent\": \"\",\n            \"about\": \"Checks if a given TypeCheckKind is a BigInt check.\",\n            \"logic\": \"Returns true if the type_check is kBigInt or kBigInt64.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type_check\",\n                    \"type\": \"TypeCheckKind\",\n                    \"purpose\": \"The type check kind to check\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the type check is a BigInt check, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool TypeCheckIsBigInt(TypeCheckKind type_check) {\n  return type_check == TypeCheckKind::kBigInt ||\n         type_check == TypeCheckKind::kBigInt64;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SupportsFpParamsInCLinkage\",\n            \"parent\": \"\",\n            \"about\": \"Determines whether floating-point parameters are supported in C linkage.\",\n            \"logic\": \"Returns Is64() if V8_ENABLE_FP_PARAMS_IN_C_LINKAGE is defined, false otherwise.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if FP parameters are supported in C linkage, false otherwise\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nconstexpr bool SupportsFpParamsInCLinkage() {\n#ifdef V8_ENABLE_FP_PARAMS_IN_C_LINKAGE\n  return Is64();\n#else\n  return false;\n#endif\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RepresentationChanger\",\n            \"about\": \"Handles the insertion of representation change nodes in the graph.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass RepresentationChanger {\n public:\n  RepresentationChanger(JSGraph* jsgraph, JSHeapBroker* broker,\n                        SimplifiedLoweringVerifier* verifier);\n\n  Node* GetRepresentationFor(Node* node, MachineRepresentation output_rep,\n                              Type output_type, Node* use_node,\n                              UseInfo use_info);\n\n  void set_testing_type_errors(bool testing_type_errors) {\n    testing_type_errors_ = testing_type_errors;\n  }\n\n  bool type_error() const { return type_error_; }\n\n private:\n  Node* GetTaggedSignedRepresentationFor(Node* node,\n                                          MachineRepresentation output_rep,\n                                          Type output_type, Node* use_node,\n                                          UseInfo use_info);\n  Node* GetTaggedPointerRepresentationFor(Node* node,\n                                            MachineRepresentation output_rep,\n                                            Type output_type, Node* use_node,\n                                            UseInfo use_info);\n  Node* GetTaggedRepresentationFor(Node* node, MachineRepresentation output_rep,\n                                   Type output_type, Truncation truncation);\n  Node* GetFloat16RawBitsRepresentationFor(Node* node,\n                                              MachineRepresentation output_rep,\n                                              Type output_type, Node* use_node,\n                                              UseInfo use_info);\n  Node* GetFloat32RepresentationFor(Node* node, MachineRepresentation output_rep,\n                                   Type output_type, Truncation truncation);\n  Node* GetFloat64RepresentationFor(Node* node, MachineRepresentation output_rep,\n                                   Type output_type, Node* use_node,\n                                   UseInfo use_info);\n  Node* GetBitRepresentationFor(Node* node, MachineRepresentation output_rep,\n                                Type output_type);\n  Node* GetWord32RepresentationFor(Node* node, MachineRepresentation output_rep,\n                                    Type output_type, Node* use_node,\n                                    UseInfo use_info);\n  Node* GetWord64RepresentationFor(Node* node, MachineRepresentation output_rep,\n                                    Type output_type, Node* use_node,\n                                    UseInfo use_info);\n\n  const Operator* Int32OperatorFor(IrOpcode::Value opcode);\n  const Operator* Int32OverflowOperatorFor(IrOpcode::Value opcode);\n  const Operator* AdditiveSafeIntegerOverflowOperatorFor(IrOpcode::Value opcode);\n  const Operator* Int64OperatorFor(IrOpcode::Value opcode);\n  const Operator* Int64OverflowOperatorFor(IrOpcode::Value opcode);\n  const Operator* BigIntOperatorFor(IrOpcode::Value opcode);\n  const Operator* TaggedSignedOperatorFor(IrOpcode::Value opcode);\n  const Operator* Uint32OperatorFor(IrOpcode::Value opcode);\n  const Operator* Uint32OverflowOperatorFor(IrOpcode::Value opcode);\n  const Operator* Float64OperatorFor(IrOpcode::Value opcode);\n\n  Node* TypeError(Node* node, MachineRepresentation output_rep, Type output_type,\n                  MachineRepresentation use);\n  Node* InsertChangeBitToTagged(Node* node);\n  Node* InsertChangeFloat32ToFloat64(Node* node);\n  Node* InsertChangeFloat64ToUint32(Node* node);\n  Node* InsertChangeFloat64ToInt32(Node* node);\n  Node* InsertChangeInt32ToFloat64(Node* node);\n  Node* InsertChangeTaggedSignedToInt32(Node* node);\n  Node* InsertChangeTaggedToFloat64(Node* node);\n  Node* InsertChangeUint32ToFloat64(Node* node);\n  Node* InsertTruncateInt64ToInt32(Node* node);\n  Node* InsertCheckedFloat64ToInt32(Node* node, CheckForMinusZeroMode check,\n                                      const FeedbackSource& feedback,\n                                      Node* use_node);\n\n  Node* MakeTruncatedInt32Constant(double value);\n  Node* InsertUnconditionalDeopt(Node* node, DeoptimizeReason reason,\n                                  const FeedbackSource& feedback = {});\n  Node* InsertConversion(Node* node, const Operator* op, Node* use_node);\n  Isolate* isolate() const;\n\n  // Helper methods to insert conversion nodes for float16 emulation.\n  Node* Ieee754Fp16RawBitsToFp32RawBitsCode();\n  Node* Ieee754Fp64ToFp16RawBitsCode();\n  Operator const* Ieee754Fp16RawBitsToFp32RawBitsOperator();\n  Operator const* Ieee754Fp64ToFp16RawBitsOperator();\n  Node* InsertChangeFloat16RawBitsToFloat64Fallback(Node* node);\n  Node* InsertTruncateFloat64ToFloat16RawBitsFallback(Node* node);\n\n  Node* InsertTypeOverrideForVerifier(const Type& type, Node* node);\n  bool verification_enabled() const { return verifier_ != nullptr; }\n\n  Zone* zone() const { return jsgraph()->zone(); }\n  Factory* factory() const { return isolate()->factory(); }\n  CommonOperatorBuilder* common() const { return jsgraph()->common(); }\n  SimplifiedOperatorBuilder* simplified() const {\n    return jsgraph()->simplified();\n  }\n  MachineOperatorBuilder* machine() const { return jsgraph()->machine(); }\n\n  JSGraph* jsgraph() const { return jsgraph_; }\n  JSHeapBroker* broker() const { return broker_; }\n\n private:\n  TypeCache const* cache_;\n  JSGraph* jsgraph_;\n  JSHeapBroker* broker_;\n  SimplifiedLoweringVerifier* verifier_;\n  bool testing_type_errors_;\n  bool type_error_;\n\n  // Cache for external constants.\n  base::LazyObject<Node> ieee754_fp16_raw_bits_to_fp32_raw_bits_code_;\n  base::LazyObject<Node> ieee754_fp64_to_fp16_raw_bits_code_;\n  base::LazyObject<const Operator>\n      ieee754_fp16_raw_bits_to_fp32_raw_bits_operator_;\n  base::LazyObject<const Operator> ieee754_fp64_to_fp16_raw_bits_operator_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RepresentationChanger\",\n            \"parent\": \"RepresentationChanger\",\n            \"about\": \"Constructor for the RepresentationChanger class.\",\n            \"logic\": \"Initializes the member variables, including the type cache, JSGraph, JSHeapBroker, and SimplifiedLoweringVerifier.\",\n            \"parameters\": [\n                {\n                    \"name\": \"jsgraph\",\n                    \"type\": \"JSGraph*\",\n                    \"purpose\": \"The JSGraph to use for creating nodes\"\n                },\n                {\n                    \"name\": \"broker\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"purpose\": \"The JSHeapBroker for accessing heap objects\"\n                },\n                {\n                    \"name\": \"verifier\",\n                    \"type\": \"SimplifiedLoweringVerifier*\",\n                    \"purpose\": \"The SimplifiedLoweringVerifier for verifying the graph\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"TypeCache\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nRepresentationChanger::RepresentationChanger(\n    JSGraph* jsgraph, JSHeapBroker* broker,\n    SimplifiedLoweringVerifier* verifier)\n    : cache_(TypeCache::Get()),\n      jsgraph_(jsgraph),\n      broker_(broker),\n      verifier_(verifier),\n      testing_type_errors_(false),\n      type_error_(false) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetRepresentationFor\",\n            \"parent\": \"RepresentationChanger\",\n            \"about\": \"Changes the representation of a node to the desired representation based on use information.\",\n            \"logic\": \"Checks for no-op shortcuts, BigInt handling, and then dispatches to specific Get...RepresentationFor methods based on use_info.representation().\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose representation needs to be changed\"\n                },\n                {\n                    \"name\": \"output_rep\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The current machine representation of the node\"\n                },\n                {\n                    \"name\": \"output_type\",\n                    \"type\": \"Type\",\n                    \"purpose\": \"The current type of the node\"\n                },\n                {\n                    \"name\": \"use_node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node where the value is being used\"\n                },\n                {\n                    \"name\": \"use_info\",\n                    \"type\": \"UseInfo\",\n                    \"purpose\": \"Information about how the value is being used\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The node with the appropriate representation\"\n            },\n            \"dependencies\": [\n                \"TypeError\",\n                \"TypeCheckIsBigInt\",\n                \"InsertConversion\",\n                \"simplified()->ChangeUint64ToBigInt()\",\n                \"simplified()->ChangeInt64ToBigInt()\",\n                \"machine()->ChangeFloat16RawBitsToFloat64()\",\n                \"InsertChangeFloat16RawBitsToFloat64Fallback\",\n                \"IsWord\",\n                \"GetTaggedSignedRepresentationFor\",\n                \"GetTaggedPointerRepresentationFor\",\n                \"GetTaggedRepresentationFor\",\n                \"GetFloat16RawBitsRepresentationFor\",\n                \"GetFloat32RepresentationFor\",\n                \"GetFloat64RepresentationFor\",\n                \"GetBitRepresentationFor\",\n                \"GetWord32RepresentationFor\",\n                \"GetWord64RepresentationFor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* RepresentationChanger::GetRepresentationFor(\n    Node* node, MachineRepresentation output_rep, Type output_type,\n    Node* use_node, UseInfo use_info) {\n  // We are currently not inserting conversions in machine graphs.\n  // We might add that, though.\n  DCHECK_IMPLIES(!output_type.IsNone(), !output_type.Is(Type::Machine()));\n  if (output_rep == MachineRepresentation::kNone && !output_type.IsNone()) {\n    // The output representation should be set if the type is inhabited (i.e.,\n    // if the value is possible).\n    return TypeError(node, output_rep, output_type, use_info.representation());\n  }\n\n  if (output_type.Is(Type::BigInt()) &&\n      output_rep == MachineRepresentation::kWord64 &&\n      !TypeCheckIsBigInt(use_info.type_check())) {\n    // Rematerialize any truncated BigInt if user is not expecting a BigInt.\n    if (output_type.Is(Type::UnsignedBigInt64())) {\n      node = InsertConversion(node, simplified()->ChangeUint64ToBigInt(),\n                              use_node);\n    } else {\n      node =\n          InsertConversion(node, simplified()->ChangeInt64ToBigInt(), use_node);\n    }\n    output_rep = MachineRepresentation::kTaggedPointer;\n  } else if (output_rep == MachineRepresentation::kFloat16RawBits) {\n    // Float16Array elements are loaded as raw bits in a word16 then converted\n    // to float64, since architectures have spotty support for fp16.\n    DCHECK(output_type.Is(Type::Number()));\n    if (machine()->ChangeFloat16RawBitsToFloat64().IsSupported()) {\n      node = jsgraph()->graph()->NewNode(\n          machine()->ChangeFloat16RawBitsToFloat64().op(), node);\n    } else {\n      node = InsertChangeFloat16RawBitsToFloat64Fallback(node);\n    }\n    output_rep = MachineRepresentation::kFloat64;\n  }\n\n  // Handle the no-op shortcuts when no checking is necessary.\n  if (use_info.type_check() == TypeCheckKind::kNone ||\n      // TODO(nicohartmann@, chromium:1077804): Ignoring {use_info.type_check()}\n      // in case the representation already matches is not correct. For now,\n      // this behavior is disabled only for TypeCheckKind::kBigInt, but should\n      // be fixed for all other type checks.\n      (output_rep != MachineRepresentation::kWord32 &&\n       !TypeCheckIsBigInt(use_info.type_check()))) {\n    if (use_info.representation() == output_rep) {\n      // Representations are the same. That's a no-op.\n      return node;\n    }\n    if (IsWord(use_info.representation()) && IsWord(output_rep)) {\n      // Both are words less than or equal to 32-bits.\n      // Since loads of integers from memory implicitly sign or zero extend the\n      // value to the full machine word size and stores implicitly truncate,\n      // no representation change is necessary.\n      return node;\n    }\n  }\n\n  switch (use_info.representation()) {\n    case MachineRepresentation::kTaggedSigned:\n      DCHECK(use_info.type_check() == TypeCheckKind::kNone ||\n             use_info.type_check() == TypeCheckKind::kSignedSmall);\n      return GetTaggedSignedRepresentationFor(node, output_rep, output_type,\n                                              use_node, use_info);\n    case MachineRepresentation::kTaggedPointer:\n      DCHECK(use_info.type_check() == TypeCheckKind::kNone ||\n             use_info.type_check() == TypeCheckKind::kHeapObject ||\n             use_info.type_check() == TypeCheckKind::kBigInt);\n      return GetTaggedPointerRepresentationFor(node, output_rep, output_type,\n                                               use_node, use_info);\n    case MachineRepresentation::kTagged:\n      DCHECK_EQ(TypeCheckKind::kNone, use_info.type_check());\n      return GetTaggedRepresentationFor(node, output_rep, output_type,\n                                        use_info.truncation());\n    case MachineRepresentation::kFloat16RawBits:\n      DCHECK_EQ(TypeCheckKind::kNone, use_info.type_check());\n      return GetFloat16RawBitsRepresentationFor(node, output_rep, output_type,\n                                                use_node, use_info);\n    case MachineRepresentation::kFloat32:\n      DCHECK_EQ(TypeCheckKind::kNone, use_info.type_check());\n      return GetFloat32RepresentationFor(node, output_rep, output_type,\n                                         use_info.truncation());\n    case MachineRepresentation::kFloat64:\n      DCHECK(use_info.type_check() == TypeCheckKind::kNone ||\n             use_info.type_check() == TypeCheckKind::kNumber ||\n             use_info.type_check() == TypeCheckKind::kNumberOrBoolean ||\n             use_info.type_check() == TypeCheckKind::kNumberOrOddball);\n      return GetFloat64RepresentationFor(node, output_rep, output_type,\n                                         use_node, use_info);\n    case MachineRepresentation::kBit:\n      DCHECK_EQ(TypeCheckKind::kNone, use_info.type_check());\n      return GetBitRepresentationFor(node, output_rep, output_type);\n    case MachineRepresentation::kWord8:\n    case MachineRepresentation::kWord16:\n    case MachineRepresentation::kWord32:\n      return GetWord32RepresentationFor(node, output_rep, output_type, use_node,\n                                        use_info);\n    case MachineRepresentation::kWord64:\n      DCHECK(use_info.type_check() == TypeCheckKind::kNone ||\n             use_info.type_check() == TypeCheckKind::kSigned64 ||\n             use_info.type_check() == TypeCheckKind::kAdditiveSafeInteger ||\n             TypeCheckIsBigInt(use_info.type_check()) ||\n             use_info.type_check() == TypeCheckKind::kArrayIndex);\n      return GetWord64RepresentationFor(node, output_rep, output_type, use_node,\n                                        use_info);\n    case MachineRepresentation::kSimd128:\n    case MachineRepresentation::kSimd256:\n    case MachineRepresentation::kNone:\n      return node;\n    case MachineRepresentation::kFloat16:\n    case MachineRepresentation::kCompressed:\n    case MachineRepresentation::kCompressedPointer:\n    case MachineRepresentation::kSandboxedPointer:\n    case MachineRepresentation::kProtectedPointer:\n    case MachineRepresentation::kIndirectPointer:\n    case MachineRepresentation::kMapWord:\n      UNREACHABLE();\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetTaggedSignedRepresentationFor\",\n            \"parent\": \"RepresentationChanger\",\n            \"about\": \"Changes the representation of a node to TaggedSigned.\",\n            \"logic\": \"Eagerly folds representation changes for constants. Selects the appropriate X -> Tagged operator based on output_rep and output_type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose representation needs to be changed\"\n                },\n                {\n                    \"name\": \"output_rep\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The current machine representation of the node\"\n                },\n                {\n                    \"name\": \"output_type\",\n                    \"type\": \"Type\",\n                    \"purpose\": \"The current type of the node\"\n                },\n                {\n                    \"name\": \"use_node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node where the value is being used\"\n                },\n                {\n                    \"name\": \"use_info\",\n                    \"type\": \"UseInfo\",\n                    \"purpose\": \"Information about how the value is being used\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The node with the appropriate representation\"\n            },\n            \"dependencies\": [\n                \"simplified()->ChangeInt31ToTaggedSigned()\",\n                \"simplified()->ChangeInt32ToTagged()\",\n                \"simplified()->CheckedInt32ToTaggedSigned()\",\n                \"TypeError\",\n                \"simplified()->CheckedUint32ToTaggedSigned()\",\n                \"InsertTruncateInt64ToInt32\",\n                \"SmiValuesAre32Bits\",\n                \"simplified()->CheckedUint64ToTaggedSigned\",\n                \"simplified()->CheckedInt64ToTaggedSigned\",\n                \"InsertChangeFloat64ToInt32\",\n                \"InsertChangeFloat64ToUint32\",\n                \"InsertCheckedFloat64ToInt3"
}