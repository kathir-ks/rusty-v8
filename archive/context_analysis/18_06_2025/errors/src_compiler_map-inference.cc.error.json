{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/map-inference.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 82, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/map-inference.cc\",\n        \"file_name\": \"map-inference.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides map inference capabilities for the V8 compiler, allowing optimization based on object shapes.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for map inference, compilation dependencies, feedback sources, JS graphs, simplified operators, and object maps.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/map-inference.h\"\n\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/feedback-source.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/objects/map-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MapInference\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Infers and tracks the possible maps (shapes) of a JavaScript object during compilation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"broker_\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A pointer to the JSHeapBroker, providing access to the JavaScript heap.\"\n                },\n                {\n                    \"name\": \"object_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A pointer to the node representing the object being analyzed.\"\n                },\n                {\n                    \"name\": \"maps_\",\n                    \"type\": \"ZoneRefSet<Map>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A set of possible maps for the object.\"\n                },\n                {\n                    \"name\": \"maps_state_\",\n                    \"type\": \"enum\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Represents the state of the maps (reliable, unreliable, etc.).\"\n                }\n            ],\n            \"dependencies\": [\n                \"JSHeapBroker\",\n                \"Node\",\n                \"ZoneRefSet\",\n                \"Map\",\n                \"NodeProperties\",\n                \"Effect\",\n                \"CompilationDependencies\",\n                \"FeedbackSource\",\n                \"JSGraph\",\n                \"Simplified\",\n                \"CheckMapsFlag\",\n                \"Control\",\n                \"MapRef\",\n                \"InstanceType\",\n                \"InstanceTypeChecker\",\n                \"Reducer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass MapInference {\n public:\n  MapInference(JSHeapBroker* broker, Node* object, Effect effect);\n  ~MapInference();\n\n  bool Safe() const;\n  void SetNeedGuardIfUnreliable();\n  void SetGuarded();\n  bool HaveMaps() const;\n  bool AllOfInstanceTypesAreJSReceiver() const;\n  bool AllOfInstanceTypesAre(InstanceType type) const;\n  bool AnyOfInstanceTypesAre(InstanceType type) const;\n  bool AllOfInstanceTypes(std::function<bool(InstanceType)> f);\n  ZoneRefSet<Map> const& GetMaps();\n  bool Is(MapRef expected_map);\n  void InsertMapChecks(JSGraph* jsgraph, Effect* effect, Control control,\n                       const FeedbackSource& feedback);\n  bool RelyOnMapsViaStability(CompilationDependencies* dependencies);\n  bool RelyOnMapsPreferStability(CompilationDependencies* dependencies,\n                                  JSGraph* jsgraph, Effect* effect,\n                                  Control control, const FeedbackSource& feedback);\n  Reduction NoChange();\n\n private:\n  bool AllOfInstanceTypesUnsafe(std::function<bool(InstanceType)> f) const;\n  bool AnyOfInstanceTypesUnsafe(std::function<bool(InstanceType)> f) const;\n  bool RelyOnMapsHelper(CompilationDependencies* dependencies, JSGraph* jsgraph,\n                        Effect* effect, Control control,\n                        const FeedbackSource& feedback);\n\n  JSHeapBroker* broker_;\n  Node* object_;\n  ZoneRefSet<Map> maps_;\n  enum MapsState {\n    kUnreliableDontNeedGuard,\n    kUnreliableNeedGuard,\n    kReliableOrGuarded\n  } maps_state_;\n};\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"MapInference\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Constructor for MapInference. Initializes the object with a JSHeapBroker, a Node representing the object, and an Effect.\",\n            \"logic\": \"It infers the possible maps using NodeProperties::InferMapsUnsafe, determines the state of the maps (reliable or unreliable), and initializes the maps_ member.\",\n            \"parameters\": [\n                {\n                    \"name\": \"broker\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"purpose\": \"The JSHeapBroker used to access the JavaScript heap.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The Node representing the object being analyzed.\"\n                },\n                {\n                    \"name\": \"effect\",\n                    \"type\": \"Effect\",\n                    \"purpose\": \"The effect associated with the object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"NodeProperties\",\n                \"ZoneRefSet\",\n                \"Map\",\n                \"Effect\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMapInference::MapInference(JSHeapBroker* broker, Node* object, Effect effect)\n    : broker_(broker), object_(object) {\n  auto result =\n      NodeProperties::InferMapsUnsafe(broker_, object_, effect, &maps_);\n  maps_state_ = (result == NodeProperties::kUnreliableMaps)\n                    ? kUnreliableDontNeedGuard\n                    : kReliableOrGuarded;\n  DCHECK_EQ(maps_.is_empty(), result == NodeProperties::kNoMaps);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"destructor\",\n            \"name\": \"~MapInference\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Destructor for MapInference.\",\n            \"logic\": \"Ensures the object is in a safe state before destruction.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nMapInference::~MapInference() { CHECK(Safe()); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Safe\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Checks if the current state of MapInference is safe.\",\n            \"logic\": \"Returns true if the maps are reliable or have been guarded, false otherwise.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if safe, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::Safe() const { return maps_state_ != kUnreliableNeedGuard; }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetNeedGuardIfUnreliable\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Sets the maps_state_ to kUnreliableNeedGuard if it's currently kUnreliableDontNeedGuard.\",\n            \"logic\": \"This is called when the inferred maps might be unreliable and require a guard check.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MapInference::SetNeedGuardIfUnreliable() {\n  CHECK(HaveMaps());\n  if (maps_state_ == kUnreliableDontNeedGuard) {\n    maps_state_ = kUnreliableNeedGuard;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetGuarded\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Sets the maps_state_ to kReliableOrGuarded, indicating that the maps are now guarded.\",\n            \"logic\": \"This is called after inserting a map check or relying on maps via stability.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MapInference::SetGuarded() { maps_state_ = kReliableOrGuarded; }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"HaveMaps\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Checks if any maps have been inferred.\",\n            \"logic\": \"Returns true if the maps_ set is not empty, false otherwise.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if maps exist, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::HaveMaps() const { return !maps_.is_empty(); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllOfInstanceTypesAreJSReceiver\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Checks if all inferred maps represent JSReceiver objects.\",\n            \"logic\": \"Uses AllOfInstanceTypesUnsafe with the IsJSReceiver check.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all maps are JSReceivers, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstanceTypeChecker\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::AllOfInstanceTypesAreJSReceiver() const {\n  return AllOfInstanceTypesUnsafe(\n      static_cast<bool (*)(InstanceType)>(&InstanceTypeChecker::IsJSReceiver));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllOfInstanceTypesAre\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Checks if all inferred maps have the specified InstanceType.\",\n            \"logic\": \"Uses AllOfInstanceTypesUnsafe with a lambda that checks for equality with the given type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The InstanceType to check against.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all maps have the given InstanceType, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::AllOfInstanceTypesAre(InstanceType type) const {\n  CHECK(!InstanceTypeChecker::IsString(type));\n  return AllOfInstanceTypesUnsafe(\n      [type](InstanceType other) { return type == other; });\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AnyOfInstanceTypesAre\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Checks if any of the inferred maps have the specified InstanceType.\",\n            \"logic\": \"Uses AnyOfInstanceTypesUnsafe with a lambda that checks for equality with the given type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The InstanceType to check against.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if any map has the given InstanceType, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::AnyOfInstanceTypesAre(InstanceType type) const {\n  CHECK(!InstanceTypeChecker::IsString(type));\n  return AnyOfInstanceTypesUnsafe(\n      [type](InstanceType other) { return type == other; });\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllOfInstanceTypes\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Checks if all inferred maps satisfy a given predicate function.\",\n            \"logic\": \"Calls SetNeedGuardIfUnreliable to ensure safety, then uses AllOfInstanceTypesUnsafe to perform the check.\",\n            \"parameters\": [\n                {\n                    \"name\": \"f\",\n                    \"type\": \"std::function<bool(InstanceType)>\",\n                    \"purpose\": \"The predicate function to apply to each InstanceType.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all maps satisfy the predicate, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::AllOfInstanceTypes(std::function<bool(InstanceType)> f) {\n  SetNeedGuardIfUnreliable();\n  return AllOfInstanceTypesUnsafe(f);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllOfInstanceTypesUnsafe\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Unsafe version of AllOfInstanceTypes, without the guard check.\",\n            \"logic\": \"Iterates through the maps and applies the provided function to the InstanceType of each map. Returns true if all maps satisfy the function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"f\",\n                    \"type\": \"std::function<bool(InstanceType)>\",\n                    \"purpose\": \"The predicate function to apply to each InstanceType.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if all maps satisfy the predicate, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"MapRef\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::AllOfInstanceTypesUnsafe(\n    std::function<bool(InstanceType)> f) const {\n  CHECK(HaveMaps());\n\n  auto instance_type = [f](MapRef map) { return f(map.instance_type()); };\n  return std::all_of(maps_.begin(), maps_.end(), instance_type);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AnyOfInstanceTypesUnsafe\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Unsafe version of AnyOfInstanceTypes, without the guard check.\",\n            \"logic\": \"Iterates through the maps and applies the provided function to the InstanceType of each map. Returns true if any map satisfies the function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"f\",\n                    \"type\": \"std::function<bool(InstanceType)>\",\n                    \"purpose\": \"The predicate function to apply to each InstanceType.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if any map satisfies the predicate, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"MapRef\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::AnyOfInstanceTypesUnsafe(\n    std::function<bool(InstanceType)> f) const {\n  CHECK(HaveMaps());\n\n  auto instance_type = [f](MapRef map) { return f(map.instance_type()); };\n\n  return std::any_of(maps_.begin(), maps_.end(), instance_type);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetMaps\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Returns the set of inferred maps.\",\n            \"logic\": \"Calls SetNeedGuardIfUnreliable to ensure safety before returning the maps_ set.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"ZoneRefSet<Map> const&\",\n                \"description\": \"The set of inferred maps.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nZoneRefSet<Map> const& MapInference::GetMaps() {\n  SetNeedGuardIfUnreliable();\n  return maps_;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Is\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Checks if the inferred map is exactly equal to an expected map.\",\n            \"logic\": \"Returns false if there are no maps, more than one map, or if the single map is not equal to the expected map.\",\n            \"parameters\": [\n                {\n                    \"name\": \"expected_map\",\n                    \"type\": \"MapRef\",\n                    \"purpose\": \"The expected map to compare against.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the inferred map matches the expected map exactly, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"MapRef\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::Is(MapRef expected_map) {\n  if (!HaveMaps()) return false;\n  if (maps_.size() != 1) return false;\n  return maps_.at(0).equals(expected_map);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InsertMapChecks\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Inserts a CheckMaps node into the graph to verify the inferred maps at runtime.\",\n            \"logic\": \"Creates a new CheckMaps node using the SimplifiedOperatorBuilder and adds it to the graph. Sets the state to guarded after inserting the check.\",\n            \"parameters\": [\n                {\n                    \"name\": \"jsgraph\",\n                    \"type\": \"JSGraph*\",\n                    \"purpose\": \"The JSGraph used to create the CheckMaps node.\"\n                },\n                {\n                    \"name\": \"effect\",\n                    \"type\": \"Effect*\",\n                    \"purpose\": \"A pointer to the Effect representing the current effect chain.\"\n                },\n                {\n                    \"name\": \"control\",\n                    \"type\": \"Control\",\n                    \"purpose\": \"The control node representing the current control flow.\"\n                },\n                {\n                    \"name\": \"feedback\",\n                    \"type\": \"FeedbackSource\",\n                    \"purpose\": \"The feedback source for the CheckMaps node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"JSGraph\",\n                \"Simplified\",\n                \"CheckMapsFlag\",\n                \"Effect\",\n                \"Control\",\n                \"FeedbackSource\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid MapInference::InsertMapChecks(JSGraph* jsgraph, Effect* effect,\n                                   Control control,\n                                   const FeedbackSource& feedback) {\n  CHECK(HaveMaps());\n  CHECK(feedback.IsValid());\n  *effect = jsgraph->graph()->NewNode(\n      jsgraph->simplified()->CheckMaps(CheckMapsFlag::kNone, maps_, feedback),\n      object_, *effect, control);\n  SetGuarded();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RelyOnMapsViaStability\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Attempts to rely on the inferred maps by checking their stability.\",\n            \"logic\": \"If all maps are stable, depends on those stable maps using CompilationDependencies.  Calls RelyOnMapsHelper to perform the stability check and dependency setup.\",\n            \"parameters\": [\n                {\n                    \"name\": \"dependencies\",\n                    \"type\": \"CompilationDependencies*\",\n                    \"purpose\": \"The CompilationDependencies object to register dependencies with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the maps could be relied on via stability, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"CompilationDependencies\",\n                \"MapRef\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::RelyOnMapsViaStability(\n    CompilationDependencies* dependencies) {\n  CHECK(HaveMaps());\n  return RelyOnMapsHelper(dependencies, nullptr, nullptr, Control{nullptr}, {});\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RelyOnMapsPreferStability\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Attempts to rely on maps, preferring stability but falling back to inserting map checks if necessary.\",\n            \"logic\": \"First checks if maps are already safe. If not, it attempts to rely on stability using RelyOnMapsViaStability. If that fails, it inserts map checks using RelyOnMapsHelper.\",\n            \"parameters\": [\n                {\n                    \"name\": \"dependencies\",\n                    \"type\": \"CompilationDependencies*\",\n                    \"purpose\": \"The CompilationDependencies object for stability checks.\"\n                },\n                {\n                    \"name\": \"jsgraph\",\n                    \"type\": \"JSGraph*\",\n                    \"purpose\": \"The JSGraph for inserting map checks.\"\n                },\n                {\n                    \"name\": \"effect\",\n                    \"type\": \"Effect*\",\n                    \"purpose\": \"The current effect for inserting map checks.\"\n                },\n                {\n                    \"name\": \"control\",\n                    \"type\": \"Control\",\n                    \"purpose\": \"The control node for inserting map checks.\"\n                },\n                {\n                    \"name\": \"feedback\",\n                    \"type\": \"FeedbackSource\",\n                    \"purpose\": \"The feedback source for inserting map checks.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the maps could be relied on via stability, false if map checks were inserted.\"\n            },\n            \"dependencies\": [\n                \"CompilationDependencies\",\n                \"JSGraph\",\n                \"Effect\",\n                \"Control\",\n                \"FeedbackSource\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::RelyOnMapsPreferStability(\n    CompilationDependencies* dependencies, JSGraph* jsgraph, Effect* effect,\n    Control control, const FeedbackSource& feedback) {\n  CHECK(HaveMaps());\n  if (Safe()) return false;\n  if (RelyOnMapsViaStability(dependencies)) return true;\n  CHECK(RelyOnMapsHelper(nullptr, jsgraph, effect, control, feedback));\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RelyOnMapsHelper\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Helper function for relying on maps, either through stability dependencies or by inserting map checks.\",\n            \"logic\": \"If all maps are stable, it depends on those stable maps using CompilationDependencies. Otherwise, if feedback is valid, it inserts map checks. Returns true if either stability dependencies or map checks were successful.\",\n            \"parameters\": [\n                {\n                    \"name\": \"dependencies\",\n                    \"type\": \"CompilationDependencies*\",\n                    \"purpose\": \"The CompilationDependencies object to register dependencies with.\"\n                },\n                {\n                    \"name\": \"jsgraph\",\n                    \"type\": \"JSGraph*\",\n                    \"purpose\": \"The JSGraph used for inserting map checks.\"\n                },\n                {\n                    \"name\": \"effect\",\n                    \"type\": \"Effect*\",\n                    \"purpose\": \"The effect representing the current effect chain.\"\n                },\n                {\n                    \"name\": \"control\",\n                    \"type\": \"Control\",\n                    \"purpose\": \"The control node representing the current control flow.\"\n                },\n                {\n                    \"name\": \"feedback\",\n                    \"type\": \"FeedbackSource\",\n                    \"purpose\": \"The feedback source for inserting map checks.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the maps could be relied on, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"CompilationDependencies\",\n                \"MapRef\",\n                \"JSGraph\",\n                \"Effect\",\n                \"Control\",\n                \"FeedbackSource\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool MapInference::RelyOnMapsHelper(CompilationDependencies* dependencies,\n                                    JSGraph* jsgraph, Effect* effect,\n                                    Control control,\n                                    const FeedbackSource& feedback) {\n  if (Safe()) return true;\n\n  auto is_stable = [](MapRef map) { return map.is_stable(); };\n  if (dependencies != nullptr &&\n      std::all_of(maps_.begin(), maps_.end(), is_stable)) {\n    for (MapRef map : maps_) {\n      dependencies->DependOnStableMap(map);\n    }\n    SetGuarded();\n    return true;\n  } else if (feedback.IsValid()) {\n    InsertMapChecks(jsgraph, effect, control, feedback);\n    return true;\n  } else {\n    return false;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NoChange\",\n            \"parent\": \"MapInference\",\n            \"about\": \"Indicates that the map inference has not resulted in any changes.\",\n            \"logic\": \"Sets the state to guarded and clears the maps to prevent further use. Returns Reducer::NoChange().\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"Reducer::NoChange()\"\n            },\n            \"dependencies\": [\n                \"Reducer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction MapInference::NoChange() {\n  SetGuarded();\n  maps_.clear();  // Just to make some CHECKs fail if {this} gets used after.\n  return Reducer::NoChange();\n}\n        ]]></code>\n    </func>\n</file>\n```"
}