{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/graph-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/graph-reducer.cc\",\n            \"file_name\": \"graph-reducer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the GraphReducer class, which performs graph optimizations by applying a set of reducers to the nodes of a graph.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for graph reduction, standard library functionalities, code generation, and compiler components.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/graph-reducer.h\"\n\n#include <functional>\n#include <limits>\n\n#include \"src/codegen/tick-counter.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/node-observer.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/compiler/verifier.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GraphReducer\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"The main class responsible for traversing the graph and applying reducers to optimize it.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The graph being reduced.\"\n                    },\n                    {\n                        \"name\": \"dead_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A dead node used for replacing nodes during reduction.\"\n                    },\n                    {\n                        \"name\": \"state_\",\n                        \"type\": \"ZoneVector<State>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Keeps track of the reduction state of each node (unvisited, revisit, on stack, visited).\"\n                    },\n                    {\n                        \"name\": \"reducers_\",\n                        \"type\": \"ZoneVector<Reducer*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A list of reducers to apply to the graph.\"\n                    },\n                    {\n                        \"name\": \"revisit_\",\n                        \"type\": \"std::queue<Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A queue of nodes that need to be revisited after an initial reduction.\"\n                    },\n                    {\n                        \"name\": \"stack_\",\n                        \"type\": \"std::stack<NodeState>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A stack used for depth-first traversal of the graph.\"\n                    },\n                    {\n                        \"name\": \"tick_counter_\",\n                        \"type\": \"TickCounter*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A counter for tracking execution ticks, used for safepoints.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A broker for accessing the JavaScript heap.\"\n                    },\n                    {\n                        \"name\": \"observe_node_manager_\",\n                        \"type\": \"ObserveNodeManager*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An optional manager for observing node changes during reduction.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Reducer\",\n                    \"TFGraph\",\n                    \"TickCounter\",\n                    \"JSHeapBroker\",\n                    \"Node\",\n                    \"ObserveNodeManager\",\n                    \"NodeProperties\",\n                    \"Reduction\",\n                    \"Zone\",\n                    \"ZoneVector\",\n                    \"State\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass GraphReducer {\n public:\n  enum class State : uint8_t { kUnvisited, kRevisit, kOnStack, kVisited };\n\n  GraphReducer(Zone* zone, TFGraph* graph, TickCounter* tick_counter,\n               JSHeapBroker* broker, Node* dead,\n               ObserveNodeManager* observe_node_manager);\n  ~GraphReducer();\n\n  void AddReducer(Reducer* reducer);\n\n  void ReduceNode(Node* node);\n  void ReduceGraph();\n\n private:\n  struct NodeState {\n    Node* node;\n    int input_index;\n  };\n\n  Reduction Reduce(Node* const node);\n  void ReduceTop();\n  void Replace(Node* node, Node* replacement);\n  void Replace(Node* node, Node* replacement, NodeId max_id);\n  void ReplaceWithValue(Node* node, Node* value, Node* effect, Node* control);\n  void Pop();\n  void Push(Node* const node);\n  bool Recurse(Node* node);\n  void Revisit(Node* node);\n\n  TFGraph* const graph_;\n  Node* const dead_;\n  ZoneVector<State> state_;\n  ZoneVector<Reducer*> reducers_;\n  std::queue<Node*> revisit_;\n  std::stack<NodeState> stack_;\n  TickCounter* const tick_counter_;\n  JSHeapBroker* const broker_;\n  ObserveNodeManager* const observe_node_manager_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Reducer\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Base class for reducers, which perform specific graph optimizations.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\",\n                    \"ObserveNodeManager\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass Reducer {\n public:\n  virtual ~Reducer() = default;\n  virtual void Finalize();\n  virtual Reduction Reduce(Node* node) = 0;\n  virtual const char* reducer_name() const = 0;\n\n  Reduction Reduce(Node* node, ObserveNodeManager* observe_node_manager);\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GraphReducer\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Constructor for the GraphReducer class.\",\n                \"logic\": \"Initializes the GraphReducer with the given graph, dead node, and other dependencies. Sets the type of the dead node to Type::None().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone used for memory allocation.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The graph to reduce.\"\n                    },\n                    {\n                        \"name\": \"tick_counter\",\n                        \"type\": \"TickCounter*\",\n                        \"purpose\": \"The tick counter for safepoints.\"\n                    },\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JS heap broker.\"\n                    },\n                    {\n                        \"name\": \"dead\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The dead node.\"\n                    },\n                    {\n                        \"name\": \"observe_node_manager\",\n                        \"type\": \"ObserveNodeManager*\",\n                        \"purpose\": \"The node observer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"TFGraph\",\n                    \"TickCounter\",\n                    \"JSHeapBroker\",\n                    \"Node\",\n                    \"ObserveNodeManager\",\n                    \"Zone\",\n                    \"ZoneVector\",\n                    \"Type\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nGraphReducer::GraphReducer(Zone* zone, TFGraph* graph,\n                           TickCounter* tick_counter, JSHeapBroker* broker,\n                           Node* dead, ObserveNodeManager* observe_node_manager)\n    : graph_(graph),\n      dead_(dead),\n      state_(graph, 4),\n      reducers_(zone),\n      revisit_(zone),\n      stack_(zone),\n      tick_counter_(tick_counter),\n      broker_(broker),\n      observe_node_manager_(observe_node_manager) {\n  if (dead != nullptr) {\n    NodeProperties::SetType(dead_, Type::None());\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"~GraphReducer\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Destructor for the GraphReducer class.\",\n                \"logic\": \"The destructor is default.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nGraphReducer::~GraphReducer() = default;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddReducer\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Adds a reducer to the list of reducers to apply.\",\n                \"logic\": \"Pushes the given reducer to the reducers_ vector.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"reducer\",\n                        \"type\": \"Reducer*\",\n                        \"purpose\": \"The reducer to add.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"Reducer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::AddReducer(Reducer* reducer) {\n  reducers_.push_back(reducer);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceNode\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Reduces the graph starting from the given node.\",\n                \"logic\": \"Performs a depth-first traversal of the graph, applying reducers to each node. Uses a stack and a revisit queue to manage the traversal.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The starting node for the reduction.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Reduction\",\n                    \"Reducer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::ReduceNode(Node* node) {\n  DCHECK(stack_.empty());\n  DCHECK(revisit_.empty());\n  Push(node);\n  for (;;) {\n    if (!stack_.empty()) {\n      // Process the node on the top of the stack, potentially pushing more or\n      // popping the node off the stack.\n      ReduceTop();\n    } else if (!revisit_.empty()) {\n      // If the stack becomes empty, revisit any nodes in the revisit queue.\n      node = revisit_.front();\n      revisit_.pop();\n      if (state_.Get(node) == State::kRevisit) {\n        // state can change while in queue.\n        Push(node);\n      }\n    } else {\n      // Run all finalizers.\n      for (Reducer* const reducer : reducers_) reducer->Finalize();\n\n      // Check if we have new nodes to revisit.\n      if (revisit_.empty()) break;\n    }\n  }\n  DCHECK(revisit_.empty());\n  DCHECK(stack_.empty());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceGraph\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Reduces the entire graph starting from the end node.\",\n                \"logic\": \"Calls ReduceNode with the graph's end node.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"ReduceNode\",\n                    \"graph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::ReduceGraph() { ReduceNode(graph()->end()); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reduce\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Applies all reducers to the given node.\",\n                \"logic\": \"Iterates through the list of reducers, applying each one to the node. If a reducer changes the node, the process restarts from the beginning of the list to allow other reducers to take advantage of the change. Handles in-place reductions and replacements.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node* const\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction (no change, changed, or replaced).\"\n                },\n                \"dependencies\": [\n                    \"Reducer\",\n                    \"Reduction\",\n                    \"observe_node_manager_\",\n                    \"tick_counter_\",\n                    \"broker_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction GraphReducer::Reduce(Node* const node) {\n  auto skip = reducers_.end();\n  for (auto i = reducers_.begin(); i != reducers_.end();) {\n    if (i != skip) {\n      tick_counter_->TickAndMaybeEnterSafepoint();\n      Reduction reduction = (*i)->Reduce(node, observe_node_manager_);\n      if (!reduction.Changed()) {\n        // No change from this reducer.\n      } else if (reduction.replacement() == node) {\n        // {replacement} == {node} represents an in-place reduction. Rerun\n        // all the other reducers for this node, as now there may be more\n        // opportunities for reduction.\n        if (v8_flags.trace_turbo_reduction) {\n          UnparkedScopeIfNeeded unparked(broker_);\n          // TODO(neis): Disallow racy handle dereference once we stop\n          // supporting --no-local-heaps --no-concurrent-inlining.\n          AllowHandleDereference allow_deref;\n          StdoutStream{} << \"- In-place update of #\" << *node << \" by reducer \"\n                         << (*i)->reducer_name() << std::endl;\n        }\n        skip = i;\n        i = reducers_.begin();\n        continue;\n      } else {\n        // {node} was replaced by another node.\n        if (v8_flags.trace_turbo_reduction) {\n          UnparkedScopeIfNeeded unparked(broker_);\n          // TODO(neis): Disallow racy handle dereference once we stop\n          // supporting --no-local-heaps --no-concurrent-inlining.\n          AllowHandleDereference allow_deref;\n          StdoutStream{} << \"- Replacement of #\" << *node << \" with #\"\n                         << *(reduction.replacement()) << \" by reducer \"\n                         << (*i)->reducer_name() << std::endl;\n        }\n        return reduction;\n      }\n    }\n    ++i;\n  }\n  if (skip == reducers_.end()) {\n    // No change from any reducer.\n    return Reducer::NoChange();\n  }\n  // At least one reducer did some in-place reduction.\n  return Reducer::Changed(node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceTop\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Reduces the node at the top of the stack.\",\n                \"logic\": \"Applies reductions to the node at the top of the stack. Recursively processes input nodes and handles in-place updates and replacements.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"Reduce\",\n                    \"Pop\",\n                    \"Recurse\",\n                    \"Revisit\",\n                    \"Replace\",\n                    \"Node\",\n                    \"Node::inputs\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::ReduceTop() {\n  NodeState& entry = stack_.top();\n  Node* node = entry.node;\n  DCHECK_EQ(State::kOnStack, state_.Get(node));\n\n  if (node->IsDead()) return Pop();  // Node was killed while on stack.\n\n  Node::Inputs node_inputs = node->inputs();\n\n  // Recurse on an input if necessary.\n  int start = entry.input_index < node_inputs.count() ? entry.input_index : 0;\n  for (int i = start; i < node_inputs.count(); ++i) {\n    Node* input = node_inputs[i];\n    if (input != node && Recurse(input)) {\n      entry.input_index = i + 1;\n      return;\n    }\n  }\n  for (int i = 0; i < start; ++i) {\n    Node* input = node_inputs[i];\n    if (input != node && Recurse(input)) {\n      entry.input_index = i + 1;\n      return;\n    }\n  }\n\n  // Remember the max node id before reduction.\n  NodeId const max_id = static_cast<NodeId>(graph()->NodeCount() - 1);\n\n  // All inputs should be visited or on stack. Apply reductions to node.\n  Reduction reduction = Reduce(node);\n\n  // If there was no reduction, pop {node} and continue.\n  if (!reduction.Changed()) return Pop();\n\n  // Check if the reduction is an in-place update of the {node}.\n  Node* const replacement = reduction.replacement();\n  if (replacement == node) {\n    for (Node* const user : node->uses()) {\n      DCHECK_IMPLIES(user == node, state_.Get(node) != State::kVisited);\n      Revisit(user);\n    }\n\n    // In-place update of {node}, may need to recurse on an input.\n    node_inputs = node->inputs();\n    for (int i = 0; i < node_inputs.count(); ++i) {\n      Node* input = node_inputs[i];\n      if (input != node && Recurse(input)) {\n        entry.input_index = i + 1;\n        return;\n      }\n    }\n  }\n\n  // After reducing the node, pop it off the stack.\n  Pop();\n\n  // Check if we have a new replacement.\n  if (replacement != node) {\n    Replace(node, replacement, max_id);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Replace\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Replaces a node with another node.\",\n                \"logic\": \"Replaces all uses of the original node with the replacement node. Handles cases where the replacement node is an old node or a new node. Kills the original node if it is no longer used.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to replace.\"\n                    },\n                    {\n                        \"name\": \"replacement\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to replace with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"Revisit\",\n                    \"graph\",\n                    \"Node\",\n                    \"Verifier::VerifyEdgeInputReplacement\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::Replace(Node* node, Node* replacement) {\n  Replace(node, replacement, std::numeric_limits<NodeId>::max());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Replace\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Replaces a node with another node, with a maximum node ID.\",\n                \"logic\": \"Replaces all uses of the original node with the replacement node. Handles cases where the replacement node is an old node (id <= max_id) or a new node.  If the replacement is an old node, the original node is unlinked and assumed to be already reduced.  If the replacement is a new node, the uses of the original node are updated up to max_id. The original node is killed if it is no longer used.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to replace.\"\n                    },\n                    {\n                        \"name\": \"replacement\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to replace with.\"\n                    },\n                    {\n                        \"name\": \"max_id\",\n                        \"type\": \"NodeId\",\n                        \"purpose\": \"The maximum node ID to consider for replacement.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"Revisit\",\n                    \"graph\",\n                    \"Node\",\n                    \"Verifier::VerifyEdgeInputReplacement\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::Replace(Node* node, Node* replacement, NodeId max_id) {\n  if (node == graph()->start()) graph()->SetStart(replacement);\n  if (node == graph()->end()) graph()->SetEnd(replacement);\n  if (replacement->id() <= max_id) {\n    // {replacement} is an old node, so unlink {node} and assume that\n    // {replacement} was already reduced and finish.\n    for (Edge edge : node->use_edges()) {\n      Node* const user = edge.from();\n      Verifier::VerifyEdgeInputReplacement(edge, replacement);\n      edge.UpdateTo(replacement);\n      // Don't revisit this node if it refers to itself.\n      if (user != node) Revisit(user);\n    }\n    node->Kill();\n  } else {\n    // Replace all old uses of {node} with {replacement}, but allow new nodes\n    // created by this reduction to use {node}.\n    for (Edge edge : node->use_edges()) {\n      Node* const user = edge.from();\n      if (user->id() <= max_id) {\n        edge.UpdateTo(replacement);\n        // Don't revisit this node if it refers to itself.\n        if (user != node) Revisit(user);\n      }\n    }\n    // Unlink {node} if it's no longer used.\n    if (node->uses().empty()) node->Kill();\n\n    // If there was a replacement, reduce it after popping {node}.\n    Recurse(replacement);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReplaceWithValue\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Replaces a node with a value, effect, and control node.\",\n                \"logic\": \"Replaces the uses of a node with different nodes based on whether the edge is a value, effect, or control edge. Handles IfSuccess and IfException opcodes for control edges. Requires distinguishing between value, effect and control edges.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to replace.\"\n                    },\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The replacement value node.\"\n                    },\n                    {\n                        \"name\": \"effect\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The replacement effect node.\"\n                    },\n                    {\n                        \"name\": \"control\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The replacement control node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": [\n                    \"Replace\",\n                    \"Revisit\",\n                    \"Node\",\n                    \"NodeProperties\",\n                    \"dead_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::ReplaceWithValue(Node* node, Node* value, Node* effect,\n                                    Node* control) {\n  if (effect == nullptr && node->op()->EffectInputCount() > 0) {\n    effect = NodeProperties::GetEffectInput(node);\n  }\n  if (control == nullptr && node->op()->ControlInputCount() > 0) {\n    control = NodeProperties::GetControlInput(node);\n  }\n\n  // Requires distinguishing between value, effect and control edges.\n  for (Edge edge : node->use_edges()) {\n    Node* const user = edge.from();\n    DCHECK(!user->IsDead());\n    if (NodeProperties::IsControlEdge(edge)) {\n      if (user->opcode() == IrOpcode::kIfSuccess) {\n        Replace(user, control);\n      } else if (user->opcode() == IrOpcode::kIfException) {\n        DCHECK_NOT_NULL(dead_);\n        edge.UpdateTo(dead_);\n        Revisit(user);\n      } else {\n        DCHECK_NOT_NULL(control);\n        edge.UpdateTo(control);\n        Revisit(user);\n      }\n    } else if (NodeProperties::IsEffectEdge(edge)) {\n      DCHECK_NOT_NULL(effect);\n      edge.UpdateTo(effect);\n      Revisit(user);\n    } else {\n      DCHECK_NOT_NULL(value);\n      edge.UpdateTo(value);\n      Revisit(user);\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Pop\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Pops a node from the stack.\",\n                \"logic\": \"Pops a node from the stack and marks it as visited.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::Pop() {\n  Node* node = stack_.top().node;\n  state_.Set(node, State::kVisited);\n  stack_.pop();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Push\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Pushes a node onto the stack.\",\n                \"logic\": \"Pushes a node onto the stack and marks it as being on the stack.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node* const\",\n                        \"purpose\": \"The node to push.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::Push(Node* const node) {\n  DCHECK_NE(State::kOnStack, state_.Get(node));\n  state_.Set(node, State::kOnStack);\n  stack_.push({node, 0});\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Recurse\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Recursively processes a node.\",\n                \"logic\": \"Checks if a node has already been visited or is on the stack. If not, pushes the node onto the stack and returns true, indicating that recursion should continue.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to recurse on.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if recursion should continue, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool GraphReducer::Recurse(Node* node) {\n  if (state_.Get(node) > State::kRevisit) return false;\n  Push(node);\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Revisit\",\n                \"parent\": \"GraphReducer\",\n                \"about\": \"Adds a node to the revisit queue.\",\n                \"logic\": \"Adds a node to the revisit queue if it has already been visited.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to revisit.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"None\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nvoid GraphReducer::Revisit(Node* node) {\n  if (state_.Get(node) == State::kVisited) {\n    state_.Set(node, State::kRevisit);\n    revisit_.push(node);\n  }\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"State\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents the state of a node during graph reduction.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nenum class GraphReducer::State : uint8_t {\n  kUnvisited,\n  kRevisit,\n  kOnStack,\n  kVisited\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Reduction\",\n                \"about\": \"Represents the result of reducing a node.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Reduction {\n                public:\n                    bool Changed() const;\n                    Node* replacement() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TFGraph\",\n                \"about\": \"Represents the Turbofan graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TFGraph {\n                public:\n                    Node* start() const;\n                    Node* end() const;\n                    void SetStart(Node* node);\n                    void SetEnd(Node* node);\n                    int NodeCount() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TickCounter\",\n                \"about\": \"Tracks execution ticks for safepoints.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TickCounter {\n                public:\n                    void TickAndMaybeEnterSafepoint();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSHeapBroker\",\n                \"about\": \"Broker for accessing the JavaScript heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class JSHeapBroker {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Node\",\n                \"about\": \"Represents a node in the graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Node {\n                public:\n                    bool IsDead() const;\n                    Node::Inputs inputs();\n                    Node::Uses uses();\n                    int id() const;\n                    const Operator* op() const;\n                    void Kill();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ObserveNodeManager\",\n                \"about\": \"Manages observation of node changes.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ObserveNodeManager {\n                public:\n                    void OnNodeChanged(const char* reducer_name, Node* node, Node* replacement);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NodeProperties\",\n                \"about\": \"Provides properties of a node.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class NodeProperties {\n                public:\n                    static void SetType(Node* node, Type type);\n                    static Node* GetEffectInput(Node* node);\n                    static Node* GetControlInput("
}