{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-compiler-definitions.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 121, column 30",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-compiler-definitions.h\",\n        \"file_name\": \"wasm-compiler-definitions.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines constants, enums, structs, and helper functions used in the WebAssembly compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <ostream>\n\n            #include \"src/base/hashing.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/codegen/linkage-location.h\"\n            #include \"src/codegen/register.h\"\n            #include \"src/codegen/signature.h\"\n            #include \"src/wasm/signature-hashing.h\"\n            #include \"src/wasm/value-type.h\"\n            #include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8\",\n            \"purpose\": \"V8's root namespace.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"internal\",\n            \"purpose\": \"V8's internal namespace.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"wasm\",\n            \"purpose\": \"WebAssembly related code.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace wasm {\n            struct WasmModule;\n            class WireBytesStorage;\n            struct ModuleWireBytes;\n            }  // namespace wasm\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"compiler\",\n            \"purpose\": \"Compiler related code.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace compiler {\n            class CallDescriptor;\n        ]]></code>\n    </namespace>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"WasmTypeCheckConfig\",\n            \"about\": \"Configuration for type checking in WebAssembly.\",\n            \"attributes\": [\n                {\n                    \"name\": \"from\",\n                    \"type\": \"wasm::ValueType\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The source ValueType.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"const wasm::ValueType\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The target ValueType.\"\n                }\n            ],\n            \"dependencies\": [\n                \"wasm::ValueType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct WasmTypeCheckConfig {\n            wasm::ValueType from;\n            const wasm::ValueType to;\n            };\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for WasmTypeCheckConfig to allow printing to ostream.\",\n            \"logic\": \"Prints the from and to value types to the provided ostream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream.\"\n                },\n                {\n                    \"name\": \"p\",\n                    \"type\": \"WasmTypeCheckConfig const&\",\n                    \"purpose\": \"The WasmTypeCheckConfig to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": [\n                \"WasmTypeCheckConfig\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE std::ostream& operator<<(std::ostream& os,\n                                            WasmTypeCheckConfig const& p) {\n            return os << p.from.name() << \" -> \" << p.to.name();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"hash_value\",\n            \"about\": \"Calculates a hash value for a WasmTypeCheckConfig object.\",\n            \"logic\": \"Combines the raw bit fields of the 'from' and 'to' ValueTypes using base::hash_combine.\",\n            \"parameters\": [\n                {\n                    \"name\": \"p\",\n                    \"type\": \"WasmTypeCheckConfig const&\",\n                    \"purpose\": \"The WasmTypeCheckConfig to hash.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The hash value.\"\n            },\n            \"dependencies\": [\n                \"WasmTypeCheckConfig\",\n                \"base::hash_combine\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE size_t hash_value(WasmTypeCheckConfig const& p) {\n            return base::hash_combine(p.from.raw_bit_field(), p.to.raw_bit_field());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Overloads the == operator for WasmTypeCheckConfig.\",\n            \"logic\": \"Compares the 'from' and 'to' ValueTypes of the two WasmTypeCheckConfig objects.\",\n            \"parameters\": [\n                {\n                    \"name\": \"p1\",\n                    \"type\": \"const WasmTypeCheckConfig&\",\n                    \"purpose\": \"The first WasmTypeCheckConfig object.\"\n                },\n                {\n                    \"name\": \"p2\",\n                    \"type\": \"const WasmTypeCheckConfig&\",\n                    \"purpose\": \"The second WasmTypeCheckConfig object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the two WasmTypeCheckConfig objects are equal, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"WasmTypeCheckConfig\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE bool operator==(const WasmTypeCheckConfig& p1,\n                                    const WasmTypeCheckConfig& p2) {\n            return p1.from == p2.from && p1.to == p2.to;\n            }\n        ]]></code>\n    </func>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"NullCheckStrategy\",\n            \"about\": \"Enumerates different strategies for performing null checks.\",\n            \"values\": [\n                \"kExplicit\",\n                \"kTrapHandler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class NullCheckStrategy { kExplicit, kTrapHandler };\n        ]]></code>\n    </enum>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"EnforceBoundsCheck\",\n            \"about\": \"Specifies whether bounds checks should be enforced.\",\n            \"values\": [\n                \"kNeedsBoundsCheck\",\n                \"kCanOmitBoundsCheck\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class EnforceBoundsCheck : bool {  // --\n            kNeedsBoundsCheck = true,\n            kCanOmitBoundsCheck = false\n            };\n        ]]></code>\n    </enum>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"AlignmentCheck\",\n            \"about\": \"Specifies whether alignment checks should be performed.\",\n            \"values\": [\n                \"kYes\",\n                \"kNo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class AlignmentCheck : bool {  // --\n            kYes = true,\n            kNo = false,\n            };\n        ]]></code>\n    </enum>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"BoundsCheckResult\",\n            \"about\": \"Represents the result of a bounds check.\",\n            \"values\": [\n                \"kDynamicallyChecked\",\n                \"kTrapHandler\",\n                \"kInBounds\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class BoundsCheckResult {\n            // Dynamically checked (using 1-2 conditional branches).\n            kDynamicallyChecked,\n            // OOB handled via the trap handler.\n            kTrapHandler,\n            // Statically known to be in bounds.\n            kInBounds\n            };\n        ]]></code>\n    </enum>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"CheckForNull\",\n            \"about\": \"Specifies whether a null check is needed before a wasm-gc operation.\",\n            \"values\": [\n                \"kWithoutNullCheck\",\n                \"kWithNullCheck\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // Static knowledge about whether a wasm-gc operation, such as struct.get, needs\n            // a null check.\n            enum CheckForNull : bool { kWithoutNullCheck, kWithNullCheck };\n        ]]></code>\n    </enum>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for CheckForNull enum.\",\n            \"logic\": \"Allows printing of CheckForNull enum to an ostream.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream.\"\n                },\n                {\n                    \"name\": \"null_check\",\n                    \"type\": \"CheckForNull\",\n                    \"purpose\": \"The CheckForNull value to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": [\n                \"CheckForNull\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os, CheckForNull null_check);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetDebugName\",\n            \"about\": \"Retrieves a debug name for a given index within a WasmModule.\",\n            \"logic\": \"Fetches the debug name from the provided module and wire bytes storage.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory in.\"\n                },\n                {\n                    \"name\": \"module\",\n                    \"type\": \"const wasm::WasmModule*\",\n                    \"purpose\": \"The WasmModule to get the debug name from.\"\n                },\n                {\n                    \"name\": \"wire_bytes\",\n                    \"type\": \"const wasm::WireBytesStorage*\",\n                    \"purpose\": \"The WireBytesStorage for the module.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the debug name.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"base::Vector<const char>\",\n                \"description\": \"The debug name as a character vector.\"\n            },\n            \"dependencies\": [\n                \"wasm::WasmModule\",\n                \"wasm::WireBytesStorage\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            base::Vector<const char> GetDebugName(Zone* zone,\n                                                const wasm::WasmModule* module,\n                                                const wasm::WireBytesStorage* wire_bytes,\n                                                int index);\n        ]]></code>\n    </func>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"WasmCallKind\",\n            \"about\": \"Enumerates different kinds of WebAssembly calls.\",\n            \"values\": [\n                \"kWasmFunction\",\n                \"kWasmIndirectFunction\",\n                \"kWasmImportWrapper\",\n                \"kWasmCapiFunction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            enum WasmCallKind {\n            kWasmFunction,\n            kWasmIndirectFunction,\n            kWasmImportWrapper,\n            kWasmCapiFunction\n            };\n        ]]></code>\n    </enum>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetWasmCallDescriptor\",\n            \"about\": \"Retrieves a CallDescriptor for a WebAssembly call.\",\n            \"logic\": \"Creates and returns a CallDescriptor based on the provided signature and call kind.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory in.\"\n                },\n                {\n                    \"name\": \"signature\",\n                    \"type\": \"const Signature<T>*\",\n                    \"purpose\": \"The signature of the call.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"WasmCallKind\",\n                    \"purpose\": \"The kind of WebAssembly call.\"\n                },\n                {\n                    \"name\": \"need_frame_state\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether the call needs a frame state.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CallDescriptor*\",\n                \"description\": \"The CallDescriptor for the call.\"\n            },\n            \"dependencies\": [\n                \"Signature\",\n                \"CallDescriptor\",\n                \"WasmCallKind\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            CallDescriptor* GetWasmCallDescriptor(Zone* zone, const Signature<T>* signature,\n                                                WasmCallKind kind = kWasmFunction,\n                                                bool need_frame_state = false);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetWasmCallDescriptor\",\n            \"about\": \"Explicit template instantiation for GetWasmCallDescriptor for wasm::ValueType.\",\n            \"logic\": \"Provides an explicit template instantiation to make the template visible across compilation units.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory in.\"\n                },\n                {\n                    \"name\": \"signature\",\n                    \"type\": \"const Signature<wasm::ValueType>*\",\n                    \"purpose\": \"The signature of the call.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"WasmCallKind\",\n                    \"purpose\": \"The kind of WebAssembly call.\"\n                },\n                {\n                    \"name\": \"need_frame_state\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether the call needs a frame state.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CallDescriptor*\",\n                \"description\": \"The CallDescriptor for the call.\"\n            },\n            \"dependencies\": [\n                \"Signature\",\n                \"CallDescriptor\",\n                \"WasmCallKind\",\n                \"Zone\",\n                \"wasm::ValueType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            extern template EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE)\n                CallDescriptor* GetWasmCallDescriptor(Zone*,\n                                                    const Signature<wasm::ValueType>*,\n                                                    WasmCallKind, bool);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"BuildLocations\",\n            \"about\": \"Builds LocationSignature for Wasm calls\",\n            \"logic\": \"Calculates locations and slots needed based on the signature\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory in.\"\n                },\n                {\n                    \"name\": \"sig\",\n                    \"type\": \"const Signature<T>*\",\n                    \"purpose\": \"The signature of the call.\"\n                },\n                {\n                    \"name\": \"extra_callable_param\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"extra callable parameter\"\n                },\n                {\n                    \"name\": \"parameter_slots\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"Number of param slots\"\n                },\n                {\n                    \"name\": \"return_slots\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"Number of return slots\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"LocationSignature*\",\n                \"description\": \"LocationSignature\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"Signature\",\n                \"LocationSignature\",\n                \"wasm::IterateSignatureImpl\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            LocationSignature* BuildLocations(Zone* zone, const Signature<T>* sig,\n                                            bool extra_callable_param,\n                                            int* parameter_slots, int* return_slots) {\n            int extra_params = extra_callable_param ? 2 : 1;\n            LocationSignature::Builder locations(zone, sig->return_count(),\n                                                sig->parameter_count() + extra_params);\n            int untagged_parameter_slots;  // Unused.\n            int untagged_return_slots;     // Unused.\n            wasm::IterateSignatureImpl(sig, extra_callable_param, locations,\n                                        &untagged_parameter_slots, parameter_slots,\n                                        &untagged_return_slots, return_slots);\n            return locations.Get();\n            }\n        ]]></code>\n    </func>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"compiler\",\n            \"purpose\": \"Closing compiler namespace\"\n        }\n        </metadata>\n        <code><![CDATA[\n            }  // namespace compiler\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"internal\",\n            \"purpose\": \"Closing internal namespace\"\n        }\n        </metadata>\n        <code><![CDATA[\n            }  // namespace internal\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"v8\",\n            \"purpose\": \"Closing v8 namespace\"\n        }\n        </metadata>\n        <code><![CDATA[\n            }  // namespace v8\n        ]]></code>\n    </namespace>\n</file>\n```"
}