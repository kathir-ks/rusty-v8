{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/tasks/cancelable-task.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 45, column 50",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/tasks/cancelable-task.h\",\n        \"file_name\": \"cancelable-task.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines classes for managing cancelable tasks in V8, allowing tasks to be registered, aborted, and waited upon.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8 specific headers for task management and platform functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <atomic>\n            #include <unordered_map>\n\n            #include \"include/v8-platform.h\"\n            #include \"src/base/macros.h\"\n            #include \"src/base/platform/condition-variable.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CancelableTaskManager\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Manages a collection of cancelable tasks, providing functionality to register, abort, and wait for their completion.\",\n            \"attributes\": [\n                {\n                    \"name\": \"task_id_counter_\",\n                    \"type\": \"Id\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A counter to generate unique IDs for each registered task.\"\n                },\n                {\n                    \"name\": \"cancelable_tasks_\",\n                    \"type\": \"std::unordered_map<Id, Cancelable*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the registered cancelable tasks, mapping their IDs to their Cancelable objects.\"\n                },\n                {\n                    \"name\": \"cancelable_tasks_barrier_\",\n                    \"type\": \"base::ConditionVariable\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A condition variable used for synchronizing access to the cancelable tasks and waiting for their completion.\"\n                },\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A mutex used to protect access to the cancelable tasks and related data structures.\"\n                },\n                {\n                    \"name\": \"canceled_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A flag indicating whether the task manager has been canceled.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Cancelable\",\n                \"Isolate\",\n                \"base::ConditionVariable\",\n                \"base::Mutex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE CancelableTaskManager {\n            public:\n            using Id = uint64_t;\n            static constexpr Id kInvalidTaskId = 0;\n\n            CancelableTaskManager();\n\n            ~CancelableTaskManager();\n            CancelableTaskManager(const CancelableTaskManager&) = delete;\n            CancelableTaskManager& operator=(const CancelableTaskManager&) = delete;\n\n            // Registers a new cancelable {task}. Returns the unique {id} of the task that\n            // can be used to try to abort a task by calling {Abort}.\n            // If {Register} is called after {CancelAndWait}, then the task will be\n            // aborted immediately.\n            // {Register} should only be called by the thread which owns the\n            // {CancelableTaskManager}, or by a task which is managed by the\n            // {CancelableTaskManager}.\n            Id Register(Cancelable* task);\n\n            // Try to abort running a task identified by {id}.\n            TryAbortResult TryAbort(Id id);\n\n            // Tries to cancel all remaining registered tasks. The return value indicates\n            // whether\n            //\n            // 1) No tasks were registered (kTaskRemoved), or\n            //\n            // 2) There is at least one remaining task that couldn't be cancelled\n            // (kTaskRunning), or\n            //\n            // 3) All registered tasks were cancelled (kTaskAborted).\n            TryAbortResult TryAbortAll();\n\n            // Cancels all remaining registered tasks and waits for tasks that are\n            // already running. This disallows subsequent Register calls.\n            void CancelAndWait();\n\n            // Returns true of the task manager has been cancelled.\n            bool canceled() const { return canceled_; }\n\n            private:\n            // Only called by {Cancelable} destructor. The task is done with executing,\n            // but needs to be removed.\n            void RemoveFinishedTask(Id id);\n\n            // To mitigate the ABA problem, the api refers to tasks through an id.\n            Id task_id_counter_;\n\n            // A set of cancelable tasks that are currently registered.\n            std::unordered_map<Id, Cancelable*> cancelable_tasks_;\n\n            // Mutex and condition variable enabling concurrent register and removing, as\n            // well as waiting for background tasks on {CancelAndWait}.\n            base::ConditionVariable cancelable_tasks_barrier_;\n            base::Mutex mutex_;\n\n            bool canceled_;\n\n            friend class Cancelable;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"canceled\",\n            \"parent\": \"CancelableTaskManager\",\n            \"about\": \"Returns true if the task manager has been canceled.\",\n            \"logic\": \"Returns the value of the `canceled_` boolean member.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the task manager has been canceled, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool canceled() const { return canceled_; }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Cancelable\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Base class for tasks that can be canceled. It manages the task's state (waiting, running, canceled) and provides a mechanism to cancel the task.\",\n            \"attributes\": [\n                {\n                    \"name\": \"parent_\",\n                    \"type\": \"CancelableTaskManager*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A pointer to the CancelableTaskManager that manages this task.\"\n                },\n                {\n                    \"name\": \"status_\",\n                    \"type\": \"std::atomic<Status>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"An atomic variable representing the task's current status (waiting, running, or canceled).\"\n                },\n                {\n                    \"name\": \"id_\",\n                    \"type\": \"CancelableTaskManager::Id\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The unique ID of the task, assigned by the CancelableTaskManager.\"\n                }\n            ],\n            \"dependencies\": [\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE Cancelable {\n            public:\n            explicit Cancelable(CancelableTaskManager* parent)\n                : parent_(parent), id_(parent->Register(this)) {}\n\n            virtual ~Cancelable();\n            Cancelable(const Cancelable&) = delete;\n            Cancelable& operator=(const Cancelable&) = delete;\n\n            // Never invoke after handing over the task to the platform! The reason is\n            // that {Cancelable} is used in combination with {v8::Task} and handed to\n            // a platform. This step transfers ownership to the platform, which destroys\n            // the task after running it. Since the exact time is not known, we cannot\n            // access the object after handing it to a platform.\n            CancelableTaskManager::Id id() { return id_; }\n\n            protected:\n            // Identifies the state a cancelable task is in:\n            // |kWaiting|: The task is scheduled and waiting to be executed. {TryRun} will\n            //   succeed.\n            // |kCanceled|: The task has been canceled. {TryRun} will fail.\n            // |kRunning|: The task is currently running and cannot be canceled anymore.\n            enum Status { kWaiting, kCanceled, kRunning };\n\n            bool TryRun(Status* previous = nullptr) {\n                return CompareExchangeStatus(kWaiting, kRunning, previous);\n            }\n\n            private:\n            friend class CancelableTaskManager;\n\n            // Use {CancelableTaskManager} to abort a task that has not yet been\n            // executed.\n            bool Cancel() { return CompareExchangeStatus(kWaiting, kCanceled); }\n\n            bool CompareExchangeStatus(Status expected, Status desired,\n                                    Status* previous = nullptr) {\n                // {compare_exchange_strong} updates {expected}.\n                bool success = status_.compare_exchange_strong(expected, desired,\n                                                            std::memory_order_acq_rel,\n                                                            std::memory_order_acquire);\n                if (previous) *previous = expected;\n                return success;\n            }\n\n            CancelableTaskManager* const parent_;\n            std::atomic<Status> status_{kWaiting};\n            const CancelableTaskManager::Id id_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"id\",\n            \"parent\": \"Cancelable\",\n            \"about\": \"Returns the ID of the cancelable task.\",\n            \"logic\": \"Returns the value of the `id_` member.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"CancelableTaskManager::Id\",\n                \"description\": \"The ID of the cancelable task.\"\n            },\n            \"dependencies\": [\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            CancelableTaskManager::Id id() { return id_; }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CancelableTask\",\n            \"extends\": \"Cancelable\",\n            \"implements\": [\n                \"Task\"\n            ],\n            \"about\": \"A cancelable task that inherits from both Cancelable and Task, allowing it to be managed by the CancelableTaskManager and executed by the V8 platform.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Cancelable\",\n                \"Task\",\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE CancelableTask : public Cancelable,\n                                            NON_EXPORTED_BASE(public Task) {\n            public:\n            explicit CancelableTask(Isolate* isolate);\n            explicit CancelableTask(CancelableTaskManager* manager);\n            CancelableTask(const CancelableTask&) = delete;\n            CancelableTask& operator=(const CancelableTask&) = delete;\n\n            // Task overrides.\n            void Run() final {\n                if (TryRun()) {\n                RunInternal();\n                }\n            }\n\n            virtual void RunInternal() = 0;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Run\",\n            \"parent\": \"CancelableTask\",\n            \"about\": \"Overrides the Task::Run method to provide cancelability.  It attempts to run the task, and if successful, executes the internal task logic.\",\n            \"logic\": \"Calls `TryRun` to attempt to transition the task to the `kRunning` state. If successful, it then calls the abstract `RunInternal` method.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TryRun\",\n                \"RunInternal\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Run() final {\n                if (TryRun()) {\n                RunInternal();\n                }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RunInternal\",\n            \"parent\": \"CancelableTask\",\n            \"about\": \"Abstract method that contains the internal logic of the task to be executed.\",\n            \"logic\": \"This method must be implemented by derived classes to perform the actual task logic.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            virtual void RunInternal() = 0;\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CancelableIdleTask\",\n            \"extends\": \"Cancelable\",\n            \"implements\": [\n                \"IdleTask\"\n            ],\n            \"about\": \"A cancelable idle task that inherits from both Cancelable and IdleTask, allowing it to be managed by the CancelableTaskManager and executed during idle periods by the V8 platform.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Cancelable\",\n                \"IdleTask\",\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CancelableIdleTask : public Cancelable, public IdleTask {\n            public:\n            explicit CancelableIdleTask(Isolate* isolate);\n            explicit CancelableIdleTask(CancelableTaskManager* manager);\n            CancelableIdleTask(const CancelableIdleTask&) = delete;\n            CancelableIdleTask& operator=(const CancelableIdleTask&) = delete;\n\n            // IdleTask overrides.\n            void Run(double deadline_in_seconds) final {\n                if (TryRun()) {\n                RunInternal(deadline_in_seconds);\n                }\n            }\n\n            virtual void RunInternal(double deadline_in_seconds) = 0;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Run\",\n            \"parent\": \"CancelableIdleTask\",\n            \"about\": \"Overrides the IdleTask::Run method to provide cancelability.  It attempts to run the task, and if successful, executes the internal idle task logic.\",\n            \"logic\": \"Calls `TryRun` to attempt to transition the task to the `kRunning` state. If successful, it then calls the abstract `RunInternal` method, passing the deadline.\",\n            \"parameters\": [\n                {\n                    \"name\": \"deadline_in_seconds\",\n                    \"type\": \"double\",\n                    \"purpose\": \"The deadline for the idle task to complete.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TryRun\",\n                \"RunInternal\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void Run(double deadline_in_seconds) final {\n                if (TryRun()) {\n                RunInternal(deadline_in_seconds);\n                }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RunInternal\",\n            \"parent\": \"CancelableIdleTask\",\n            \"about\": \"Abstract method that contains the internal logic of the idle task to be executed.\",\n            \"logic\": \"This method must be implemented by derived classes to perform the actual idle task logic, using the provided deadline.\",\n            \"parameters\": [\n                {\n                    \"name\": \"deadline_in_seconds\",\n                    \"type\": \"double\",\n                    \"purpose\": \"The deadline for the idle task to complete.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            virtual void RunInternal(double deadline_in_seconds) = 0;\n        ]]></code>\n    </func>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"TryAbortResult\",\n            \"about\": \"Represents the possible results of attempting to abort a task.\",\n            \"values\": [\n                \"kTaskRemoved\",\n                \"kTaskRunning\",\n                \"kTaskAborted\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class TryAbortResult { kTaskRemoved, kTaskRunning, kTaskAborted };\n        ]]></code>\n    </enum>\n\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"Status\",\n            \"parent\": \"Cancelable\",\n            \"about\": \"Represents the possible states of a cancelable task.\",\n            \"values\": [\n                \"kWaiting\",\n                \"kCanceled\",\n                \"kRunning\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            enum Status { kWaiting, kCanceled, kRunning };\n        ]]></code>\n    </enum>\n</file>\n```"
}