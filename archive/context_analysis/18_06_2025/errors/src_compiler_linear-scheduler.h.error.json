{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/linear-scheduler.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 44, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/linear-scheduler.h\",\n            \"file_name\": \"linear-scheduler.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines a linear-time scheduler for determining if two nodes are in the same basic block and for finding a node's earliest possible schedule position within a graph.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for base flags, global definitions, node representation, opcodes, zone statistics, and zone containers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/flags.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/zone-stats.h\"\n#include \"src/zone/zone-containers.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LinearScheduler\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"A simple, linear-time scheduler to check whether two nodes are in a same basic block without actually building basic block.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the TFGraph being scheduled.\"\n                    },\n                    {\n                        \"name\": \"control_level_\",\n                        \"type\": \"ZoneMap<Node*, int>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map from a control node to the control level of the corresponding basic block.\"\n                    },\n                    {\n                        \"name\": \"early_schedule_position_\",\n                        \"type\": \"ZoneMap<Node*, Node*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A map from a non-control node to its early schedule position.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Zone\",\n                    \"TFGraph\",\n                    \"Node\",\n                    \"ZoneMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE LinearScheduler {\n public:\n  explicit LinearScheduler(Zone* zone, TFGraph* graph);\n  bool SameBasicBlock(Node* node0, Node* node1);\n  // Get a node's early schedule position. It is the earliest block (represented\n  // by a control node) where a node could be scheduled.\n  Node* GetEarlySchedulePosition(Node* node);\n\n private:\n  // Compute the level of each control node. The level is defined by the\n  // shortest control path from the start node.\n  void ComputeControlLevel();\n\n  struct NodeState {\n    Node* node;\n    Node* early_schedule_position;\n    int input_index;\n  };\n\n  int GetControlLevel(Node* control) const {\n    auto it = control_level_.find(control);\n    DCHECK(it != control_level_.end());\n    return it->second;\n  }\n\n  void SetControlLevel(Node* control, int level) {\n    DCHECK(control_level_.find(control) == control_level_.end());\n    control_level_[control] = level;\n  }\n\n  void SetEarlySchedulePosition(Node* node, Node* early_schedule_position) {\n    early_schedule_position_[node] = early_schedule_position;\n  }\n\n  TFGraph* graph_;\n  // A map from a control node to the control level of the corresponding basic\n  // block.\n  ZoneMap<Node*, int> control_level_;\n  // A map from a non-control node to its early schedule position.\n  ZoneMap<Node*, Node*> early_schedule_position_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"LinearScheduler\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Constructor for the LinearScheduler class.\",\n                \"logic\": \"Initializes the LinearScheduler with a Zone and a TFGraph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The zone to allocate memory from.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The TFGraph to schedule.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Zone\",\n                    \"TFGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  explicit LinearScheduler(Zone* zone, TFGraph* graph);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SameBasicBlock\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Checks if two nodes are in the same basic block.\",\n                \"logic\": \"Uses a linear-time algorithm to determine if two nodes belong to the same basic block without explicitly building basic blocks.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node0\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The first node to check.\"\n                    },\n                    {\n                        \"name\": \"node1\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The second node to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the nodes are in the same basic block, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  bool SameBasicBlock(Node* node0, Node* node1);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetEarlySchedulePosition\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Gets a node's early schedule position.\",\n                \"logic\": \"Determines the earliest block (represented by a control node) where a node can be scheduled.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to find the early schedule position for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"The control node representing the early schedule position.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  Node* GetEarlySchedulePosition(Node* node);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ComputeControlLevel\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Computes the level of each control node.\",\n                \"logic\": \"Calculates the control level of each control node based on the shortest control path from the start node. This is used to determine the scheduling order.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void ComputeControlLevel();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetControlLevel\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Gets the control level of a given control node.\",\n                \"logic\": \"Retrieves the control level from the control_level_ map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"control\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The control node whose level is to be retrieved.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The control level of the node.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  int GetControlLevel(Node* control) const {\n    auto it = control_level_.find(control);\n    DCHECK(it != control_level_.end());\n    return it->second;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetControlLevel\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Sets the control level of a given control node.\",\n                \"logic\": \"Sets the control level in the control_level_ map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"control\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The control node whose level is to be set.\"\n                    },\n                    {\n                        \"name\": \"level\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The control level to set.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void SetControlLevel(Node* control, int level) {\n    DCHECK(control_level_.find(control) == control_level_.end());\n    control_level_[control] = level;\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"SetEarlySchedulePosition\",\n                \"parent\": \"LinearScheduler\",\n                \"about\": \"Sets the early schedule position for a node.\",\n                \"logic\": \"Stores the early schedule position in the early_schedule_position_ map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node whose early schedule position is to be set.\"\n                    },\n                    {\n                        \"name\": \"early_schedule_position\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The early schedule position to set for the node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  void SetEarlySchedulePosition(Node* node, Node* early_schedule_position) {\n    early_schedule_position_[node] = early_schedule_position;\n  }\n        ]]></code>\n    </func>\n</file>\n```"
}