{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/heap.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 259, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/heap.h\",\n        \"file_name\": \"heap.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the Heap interface for the cppgc garbage collection library.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers and cppgc specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <cstddef>\n            #include <cstdint>\n            #include <memory>\n            #include <vector>\n\n            #include \"cppgc/common.h\"\n            #include \"cppgc/custom-space.h\"\n            #include \"cppgc/platform.h\"\n            #include \"v8config.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Heap\",\n            \"about\": \"The main interface for interacting with the C++ garbage collector (cppgc).  It provides methods for creating heaps, forcing garbage collections, and accessing handles for object allocation.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"EmbedderStackState\",\n                \"Platform\",\n                \"CustomSpaceBase\",\n                \"AllocationHandle\",\n                \"HeapHandle\",\n                \"internal::Heap\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT Heap {\n            public:\n              /**\n               * Specifies the stack state the embedder is in.\n               */\n              using StackState = EmbedderStackState;\n\n              /**\n               * Specifies whether conservative stack scanning is supported.\n               */\n              enum class StackSupport : uint8_t {\n                /**\n                 * Conservative stack scan is supported.\n                 */\n                kSupportsConservativeStackScan,\n                /**\n                 * Conservative stack scan is not supported. Embedders may use this option\n                 * when using custom infrastructure that is unsupported by the library.\n                 */\n                kNoConservativeStackScan,\n              };\n\n              /**\n               * Specifies supported marking types.\n               */\n              enum class MarkingType : uint8_t {\n                /**\n                 * Atomic stop-the-world marking. This option does not require any write\n                 * barriers but is the most intrusive in terms of jank.\n                 */\n                kAtomic,\n                /**\n                 * Incremental marking interleaves marking with the rest of the application\n                 * workload on the same thread.\n                 */\n                kIncremental,\n                /**\n                 * Incremental and concurrent marking.\n                 */\n                kIncrementalAndConcurrent\n              };\n\n              /**\n               * Specifies supported sweeping types.\n               */\n              enum class SweepingType : uint8_t {\n                /**\n                 * Atomic stop-the-world sweeping. All of sweeping is performed at once.\n                 */\n                kAtomic,\n                /**\n                 * Incremental sweeping interleaves sweeping with the rest of the\n                 * application workload on the same thread.\n                 */\n                kIncremental,\n                /**\n                 * Incremental and concurrent sweeping. Sweeping is split and interleaved\n                 * with the rest of the application.\n                 */\n                kIncrementalAndConcurrent\n              };\n\n              /**\n               * Constraints for a Heap setup.\n               */\n              struct ResourceConstraints {\n                /**\n                 * Allows the heap to grow to some initial size in bytes before triggering\n                 * garbage collections. This is useful when it is known that applications\n                 * need a certain minimum heap to run to avoid repeatedly invoking the\n                 * garbage collector when growing the heap.\n                 */\n                size_t initial_heap_size_bytes = 0;\n              };\n\n              /**\n               * Options specifying Heap properties (e.g. custom spaces) when initializing a\n               * heap through `Heap::Create()`.\n               */\n              struct HeapOptions {\n                /**\n                 * Creates reasonable defaults for instantiating a Heap.\n                 *\n                 * \\returns the HeapOptions that can be passed to `Heap::Create()`.\n                 */\n                static HeapOptions Default() { return {}; }\n\n                /**\n                 * Custom spaces added to heap are required to have indices forming a\n                 * numbered sequence starting at 0, i.e., their `kSpaceIndex` must\n                 * correspond to the index they reside in the vector.\n                 */\n                std::vector<std::unique_ptr<CustomSpaceBase>> custom_spaces;\n\n                /**\n                 * Specifies whether conservative stack scan is supported. When conservative\n                 * stack scan is not supported, the collector may try to invoke\n                 * garbage collections using non-nestable task, which are guaranteed to have\n                 * no interesting stack, through the provided Platform. If such tasks are\n                 * not supported by the Platform, the embedder must take care of invoking\n                 * the GC through `ForceGarbageCollectionSlow()`.\n                 */\n                StackSupport stack_support = StackSupport::kSupportsConservativeStackScan;\n\n                /**\n                 * Specifies which types of marking are supported by the heap.\n                 */\n                MarkingType marking_support = MarkingType::kIncrementalAndConcurrent;\n\n                /**\n                 * Specifies which types of sweeping are supported by the heap.\n                 */\n                SweepingType sweeping_support = SweepingType::kIncrementalAndConcurrent;\n\n                /**\n                 * Resource constraints specifying various properties that the internal\n                 * GC scheduler follows.\n                 */\n                ResourceConstraints resource_constraints;\n              };\n\n              /**\n               * Creates a new heap that can be used for object allocation.\n               *\n               * \\param platform implemented and provided by the embedder.\n               * \\param options HeapOptions specifying various properties for the Heap.\n               * \\returns a new Heap instance.\n               */\n              static std::unique_ptr<Heap> Create(\n                  std::shared_ptr<Platform> platform,\n                  HeapOptions options = HeapOptions::Default());\n\n              virtual ~Heap() = default;\n\n              /**\n               * Forces garbage collection.\n               *\n               * \\param source String specifying the source (or caller) triggering a\n               *   forced garbage collection.\n               * \\param reason String specifying the reason for the forced garbage\n               *   collection.\n               * \\param stack_state The embedder stack state, see StackState.\n               */\n              void ForceGarbageCollectionSlow(\n                  const char* source, const char* reason,\n                  StackState stack_state = StackState::kMayContainHeapPointers);\n\n              /**\n               * \\returns the opaque handle for allocating objects using\n               * `MakeGarbageCollected()`.\n               */\n              AllocationHandle& GetAllocationHandle();\n\n              /**\n               * \\returns the opaque heap handle which may be used to refer to this heap in\n               *   other APIs. Valid as long as the underlying `Heap` is alive.\n               */\n              HeapHandle& GetHeapHandle();\n\n             private:\n              Heap() = default;\n\n              friend class internal::Heap;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"Heap::ResourceConstraints\",\n            \"parent\": \"Heap\",\n            \"about\": \"Defines constraints for the Heap setup, such as initial heap size.\",\n            \"attributes\": [\n                {\n                    \"name\": \"initial_heap_size_bytes\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The initial size of the heap in bytes.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct ResourceConstraints {\n                /**\n                 * Allows the heap to grow to some initial size in bytes before triggering\n                 * garbage collections. This is useful when it is known that applications\n                 * need a certain minimum heap to run to avoid repeatedly invoking the\n                 * garbage collector when growing the heap.\n                 */\n                size_t initial_heap_size_bytes = 0;\n              };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"Heap::HeapOptions\",\n            \"parent\": \"Heap\",\n            \"about\": \"Defines options for initializing a Heap, including custom spaces and stack support.\",\n            \"attributes\": [\n                {\n                    \"name\": \"custom_spaces\",\n                    \"type\": \"std::vector<std::unique_ptr<CustomSpaceBase>>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"A vector of custom spaces to be added to the heap.\"\n                },\n                {\n                    \"name\": \"stack_support\",\n                    \"type\": \"StackSupport\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Specifies whether conservative stack scan is supported.\"\n                },\n                {\n                    \"name\": \"marking_support\",\n                    \"type\": \"MarkingType\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Specifies the supported marking types.\"\n                },\n                {\n                    \"name\": \"sweeping_support\",\n                    \"type\": \"SweepingType\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Specifies the supported sweeping types.\"\n                },\n                {\n                    \"name\": \"resource_constraints\",\n                    \"type\": \"ResourceConstraints\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Resource constraints specifying various properties that the internal GC scheduler follows.\"\n                }\n            ],\n            \"dependencies\": [\n                \"CustomSpaceBase\",\n                \"StackSupport\",\n                \"MarkingType\",\n                \"SweepingType\",\n                \"ResourceConstraints\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct HeapOptions {\n                /**\n                 * Creates reasonable defaults for instantiating a Heap.\n                 *\n                 * \\returns the HeapOptions that can be passed to `Heap::Create()`.\n                 */\n                static HeapOptions Default() { return {}; }\n\n                /**\n                 * Custom spaces added to heap are required to have indices forming a\n                 * numbered sequence starting at 0, i.e., their `kSpaceIndex` must\n                 * correspond to the index they reside in the vector.\n                 */\n                std::vector<std::unique_ptr<CustomSpaceBase>> custom_spaces;\n\n                /**\n                 * Specifies whether conservative stack scan is supported. When conservative\n                 * stack scan is not supported, the collector may try to invoke\n                 * garbage collections using non-nestable task, which are guaranteed to have\n                 * no interesting stack, through the provided Platform. If such tasks are\n                 * not supported by the Platform, the embedder must take care of invoking\n                 * the GC through `ForceGarbageCollectionSlow()`.\n                 */\n                StackSupport stack_support = StackSupport::kSupportsConservativeStackScan;\n\n                /**\n                 * Specifies which types of marking are supported by the heap.\n                 */\n                MarkingType marking_support = MarkingType::kIncrementalAndConcurrent;\n\n                /**\n                 * Specifies which types of sweeping are supported by the heap.\n                 */\n                SweepingType sweeping_support = SweepingType::kIncrementalAndConcurrent;\n\n                /**\n                 * Resource constraints specifying various properties that the internal\n                 * GC scheduler follows.\n                 */\n                ResourceConstraints resource_constraints;\n              };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"HeapOptions::Default\",\n            \"parent\": \"Heap::HeapOptions\",\n            \"about\": \"Returns default HeapOptions.\",\n            \"logic\": \"Returns an empty HeapOptions struct which initializes members to their default values.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"Heap::HeapOptions\",\n                \"description\": \"A HeapOptions object with default settings.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static HeapOptions Default() { return {}; }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Heap::Create\",\n            \"parent\": \"Heap\",\n            \"about\": \"Creates a new Heap instance.\",\n            \"logic\": \"Creates a new Heap instance using the provided Platform and HeapOptions.  The implementation details are likely within the internal::Heap class.\",\n            \"parameters\": [\n                {\n                    \"name\": \"platform\",\n                    \"type\": \"std::shared_ptr<Platform>\",\n                    \"purpose\": \"The platform implementation provided by the embedder.\"\n                },\n                {\n                    \"name\": \"options\",\n                    \"type\": \"Heap::HeapOptions\",\n                    \"purpose\": \"HeapOptions specifying various properties for the Heap.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<Heap>\",\n                \"description\": \"A unique pointer to a newly created Heap instance.\"\n            },\n            \"dependencies\": [\n                \"Platform\",\n                \"HeapOptions\",\n                \"internal::Heap\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static std::unique_ptr<Heap> Create(\n                  std::shared_ptr<Platform> platform,\n                  HeapOptions options = HeapOptions::Default());\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Heap::~Heap\",\n            \"parent\": \"Heap\",\n            \"about\": \"Virtual destructor for the Heap class.\",\n            \"logic\": \"Default virtual destructor to ensure proper cleanup of derived classes.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n              virtual ~Heap() = default;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Heap::ForceGarbageCollectionSlow\",\n            \"parent\": \"Heap\",\n            \"about\": \"Forces a garbage collection cycle.\",\n            \"logic\": \"Triggers a garbage collection. The 'Slow' suffix likely indicates that this is a more heavyweight operation than other potential GC triggers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"source\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"String specifying the source (or caller) triggering a forced garbage collection.\"\n                },\n                {\n                    \"name\": \"reason\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"String specifying the reason for the forced garbage collection.\"\n                },\n                {\n                    \"name\": \"stack_state\",\n                    \"type\": \"StackState\",\n                    \"purpose\": \"The embedder stack state.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StackState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n              void ForceGarbageCollectionSlow(\n                  const char* source, const char* reason,\n                  StackState stack_state = StackState::kMayContainHeapPointers);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Heap::GetAllocationHandle\",\n            \"parent\": \"Heap\",\n            \"about\": \"Returns the allocation handle for the heap.\",\n            \"logic\": \"The AllocationHandle is used for allocating garbage collected objects. The function returns a reference to the handle.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"AllocationHandle&\",\n                \"description\": \"A reference to the AllocationHandle.\"\n            },\n            \"dependencies\": [\n                \"AllocationHandle\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n              AllocationHandle& GetAllocationHandle();\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Heap::GetHeapHandle\",\n            \"parent\": \"Heap\",\n            \"about\": \"Returns the heap handle.\",\n            \"logic\": \"Returns a reference to an opaque HeapHandle object used to identify the heap in other cppgc APIs.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"HeapHandle&\",\n                \"description\": \"A reference to the HeapHandle.\"\n            },\n            \"dependencies\": [\n                \"HeapHandle\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n              HeapHandle& GetHeapHandle();\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"EmbedderStackState\",\n                \"about\": \"An enum defining the stack state for the embedder\"\n            }\n            </metadata>\n            <code><![CDATA[\n                enum class EmbedderStackState {\n                    kMayContainHeapPointers,\n                    kNoHeapPointers\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Platform\",\n                \"about\": \"Abstract interface for platform-specific functionality required by cppgc (e.g., task scheduling, memory allocation).\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Platform {\n                public:\n                    virtual ~Platform() = default;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CustomSpaceBase\",\n                \"about\": \"Base class for custom memory spaces managed by the garbage collector.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class CustomSpaceBase {\n                public:\n                    virtual ~CustomSpaceBase() = default;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AllocationHandle\",\n                \"about\": \"Handle for allocating garbage collected objects.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class AllocationHandle {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"HeapHandle\",\n                \"about\": \"Opaque handle for referring to a heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class HeapHandle {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"internal::Heap\",\n                \"about\": \"Internal implementation details of the Heap class.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Heap {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}