{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-initialization.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-initialization.h\",\n        \"file_name\": \"v8-initialization.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the v8 namespace and the V8 class, which provides static methods for initializing and managing the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"v8-callbacks.h\"  // NOLINT(build/include_directory)\n#include \"v8-internal.h\"   // NOLINT(build/include_directory)\n#include \"v8-isolate.h\"    // NOLINT(build/include_directory)\n#include \"v8-platform.h\"   // NOLINT(build/include_directory)\n#include \"v8config.h\"      // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <interface>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"interface\",\n            \"name\": \"EntropySource\",\n            \"about\": \"Callback function type for providing entropy to V8's random number generators.\",\n            \"methods\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nusing EntropySource = bool (*)(unsigned char* buffer, size_t length);\n        ]]></code>\n    </interface>\n    <interface>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"interface\",\n            \"name\": \"ReturnAddressLocationResolver\",\n            \"about\": \"Callback function type for resolving return address locations on the stack, used by profilers.\",\n            \"methods\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nusing ReturnAddressLocationResolver =\n    uintptr_t (*)(uintptr_t return_addr_location);\n        ]]></code>\n    </interface>\n    <interface>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"interface\",\n            \"name\": \"DcheckErrorCallback\",\n            \"about\": \"Callback function type for handling Dcheck failures.\",\n            \"methods\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nusing DcheckErrorCallback = void (*)(const char* file, int line,\n                                     const char* message);\n        ]]></code>\n    </interface>\n    <interface>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"interface\",\n            \"name\": \"V8FatalErrorCallback\",\n            \"about\": \"Callback function type for handling fatal errors in V8.\",\n            \"methods\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nusing V8FatalErrorCallback = void (*)(const char* file, int line,\n                                      const char* message);\n        ]]></code>\n    </interface>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"V8\",\n            \"about\": \"Container class for static utility functions to initialize and manage the V8 JavaScript engine.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"StartupData\",\n                \"Platform\",\n                \"EntropySource\",\n                \"ReturnAddressLocationResolver\",\n                \"DcheckErrorCallback\",\n                \"V8FatalErrorCallback\",\n                \"OOMErrorCallback\",\n                \"SharedMemoryStatistics\",\n                \"VirtualAddressSpace\",\n                \"UnhandledExceptionCallback\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT V8 {\n public:\n  /**\n   * Hand startup data to V8, in case the embedder has chosen to build\n   * V8 with external startup data.\n   *\n   * Note:\n   * - By default the startup data is linked into the V8 library, in which\n   *   case this function is not meaningful.\n   * - If this needs to be called, it needs to be called before V8\n   *   tries to make use of its built-ins.\n   * - To avoid unnecessary copies of data, V8 will point directly into the\n   *   given data blob, so pretty please keep it around until V8 exit.\n   * - Compression of the startup blob might be useful, but needs to\n   *   handled entirely on the embedders' side.\n   * - The call will abort if the data is invalid.\n   */\n  static void SetSnapshotDataBlob(StartupData* startup_blob);\n\n  /** Set the callback to invoke in case of Dcheck failures. */\n  static void SetDcheckErrorHandler(DcheckErrorCallback that);\n\n  /** Set the callback to invoke in the case of CHECK failures or fatal\n   * errors. This is distinct from Isolate::SetFatalErrorHandler, which\n   * is invoked in response to API usage failures.\n   * */\n  static void SetFatalErrorHandler(V8FatalErrorCallback that);\n\n  /**\n   * Sets V8 flags from a string.\n   */\n  static void SetFlagsFromString(const char* str);\n  static void SetFlagsFromString(const char* str, size_t length);\n\n  /**\n   * Sets V8 flags from the command line.\n   */\n  static void SetFlagsFromCommandLine(int* argc, char** argv,\n                                      bool remove_flags);\n\n  /** Get the version string. */\n  static const char* GetVersion();\n\n  /**\n   * Initializes V8. This function needs to be called before the first Isolate\n   * is created. It always returns true.\n   */\n  V8_INLINE static bool Initialize() {\n#ifdef V8_TARGET_OS_ANDROID\n    const bool kV8TargetOsIsAndroid = true;\n#else\n    const bool kV8TargetOsIsAndroid = false;\n#endif\n\n#ifdef V8_ENABLE_CHECKS\n    const bool kV8EnableChecks = true;\n#else\n    const bool kV8EnableChecks = false;\n#endif\n\n    const int kBuildConfiguration =\n        (internal::PointerCompressionIsEnabled() ? kPointerCompression : 0) |\n        (internal::SmiValuesAre31Bits() ? k31BitSmis : 0) |\n        (internal::SandboxIsEnabled() ? kSandbox : 0) |\n        (kV8TargetOsIsAndroid ? kTargetOsIsAndroid : 0) |\n        (kV8EnableChecks ? kEnableChecks : 0);\n    return Initialize(kBuildConfiguration);\n  }\n\n  /**\n   * Allows the host application to provide a callback which can be used\n   * as a source of entropy for random number generators.\n   */\n  static void SetEntropySource(EntropySource source);\n\n  /**\n   * Allows the host application to provide a callback that allows v8 to\n   * cooperate with a profiler that rewrites return addresses on stack.\n   */\n  static void SetReturnAddressLocationResolver(\n      ReturnAddressLocationResolver return_address_resolver);\n\n  /**\n   * Releases any resources used by v8 and stops any utility threads\n   * that may be running.  Note that disposing v8 is permanent, it\n   * cannot be reinitialized.\n   *\n   * It should generally not be necessary to dispose v8 before exiting\n   * a process, this should happen automatically.  It is only necessary\n   * to use if the process needs the resources taken up by v8.\n   */\n  static bool Dispose();\n\n  /**\n   * Initialize the ICU library bundled with V8. The embedder should only\n   * invoke this method when using the bundled ICU. Returns true on success.\n   *\n   * If V8 was compiled with the ICU data in an external file, the location\n   * of the data file has to be provided.\n   */\n  static bool InitializeICU(const char* icu_data_file = nullptr);\n\n  /**\n   * Initialize the ICU library bundled with V8. The embedder should only\n   * invoke this method when using the bundled ICU. If V8 was compiled with\n   * the ICU data in an external file and when the default location of that\n   * file should be used, a path to the executable must be provided.\n   * Returns true on success.\n   *\n   * The default is a file called icudtl.dat side-by-side with the executable.\n   *\n   * Optionally, the location of the data file can be provided to override the\n   * default.\n   */\n  static bool InitializeICUDefaultLocation(const char* exec_path,\n                                           const char* icu_data_file = nullptr);\n\n  /**\n   * Initialize the external startup data. The embedder only needs to\n   * invoke this method when external startup data was enabled in a build.\n   *\n   * If V8 was compiled with the startup data in an external file, then\n   * V8 needs to be given those external files during startup. There are\n   * three ways to do this:\n   * - InitializeExternalStartupData(const char*)\n   *   This will look in the given directory for the file \"snapshot_blob.bin\".\n   * - InitializeExternalStartupDataFromFile(const char*)\n   *   As above, but will directly use the given file name.\n   * - Call SetSnapshotDataBlob.\n   *   This will read the blobs from the given data structure and will\n   *   not perform any file IO.\n   */\n  static void InitializeExternalStartupData(const char* directory_path);\n  static void InitializeExternalStartupDataFromFile(const char* snapshot_blob);\n\n  /**\n   * Sets the v8::Platform to use. This should be invoked before V8 is\n   * initialized.\n   */\n  static void InitializePlatform(Platform* platform);\n\n  /**\n   * Clears all references to the v8::Platform. This should be invoked after\n   * V8 was disposed.\n   */\n  static void DisposePlatform();\n\n#if defined(V8_ENABLE_SANDBOX)\n  /**\n   * Returns true if the sandbox is configured securely.\n   *\n   * If V8 cannot create a regular sandbox during initialization, for example\n   * because not enough virtual address space can be reserved, it will instead\n   * create a fallback sandbox that still allows it to function normally but\n   * does not have the same security properties as a regular sandbox. This API\n   * can be used to determine if such a fallback sandbox is being used, in\n   * which case it will return false.\n   */\n  static bool IsSandboxConfiguredSecurely();\n\n  /**\n   * Provides access to the virtual address subspace backing the sandbox.\n   *\n   * This can be used to allocate pages inside the sandbox, for example to\n   * obtain virtual memory for ArrayBuffer backing stores, which must be\n   * located inside the sandbox.\n   *\n   * It should be assumed that an attacker can corrupt data inside the sandbox,\n   * and so in particular the contents of pages allocagted in this virtual\n   * address space, arbitrarily and concurrently. Due to this, it is\n   * recommended to to only place pure data buffers in them.\n   */\n  static VirtualAddressSpace* GetSandboxAddressSpace();\n\n  /**\n   * Returns the size of the sandbox in bytes.\n   *\n   * This represents the size of the address space that V8 can directly address\n   * and in which it allocates its objects.\n   */\n  static size_t GetSandboxSizeInBytes();\n\n  /**\n   * Returns the size of the address space reservation backing the sandbox.\n   *\n   * This may be larger than the sandbox (i.e. |GetSandboxSizeInBytes()|) due\n   * to surrounding guard regions, or may be smaller than the sandbox in case a\n   * fallback sandbox is being used, which will use a smaller virtual address\n   * space reservation. In the latter case this will also be different from\n   * |GetSandboxAddressSpace()->size()| as that will cover a larger part of the\n   * address space than what has actually been reserved.\n   */\n  static size_t GetSandboxReservationSizeInBytes();\n#endif  // V8_ENABLE_SANDBOX\n\n  /**\n   * Activate trap-based bounds checking for WebAssembly.\n   *\n   * \\param use_v8_signal_handler Whether V8 should install its own signal\n   * handler or rely on the embedder's.\n   */\n  static bool EnableWebAssemblyTrapHandler(bool use_v8_signal_handler);\n\n#if defined(V8_OS_WIN)\n  /**\n   * On Win64, by default V8 does not emit unwinding data for jitted code,\n   * which means the OS cannot walk the stack frames and the system Structured\n   * Exception Handling (SEH) cannot unwind through V8-generated code:\n   * https://code.google.com/p/v8/issues/detail?id=3598.\n   *\n   * This function allows embedders to register a custom exception handler for\n   * exceptions in V8-generated code.\n   */\n  static void SetUnhandledExceptionCallback(\n      UnhandledExceptionCallback callback);\n#endif\n\n  /**\n   * Allows the host application to provide a callback that will be called when\n   * v8 has encountered a fatal failure to allocate memory and is about to\n   * terminate.\n   */\n  static void SetFatalMemoryErrorCallback(OOMErrorCallback callback);\n\n  /**\n   * Get statistics about the shared memory usage.\n   */\n  static void GetSharedMemoryStatistics(SharedMemoryStatistics* statistics);\n\n private:\n  V8();\n\n  enum BuildConfigurationFeatures {\n    kPointerCompression = 1 << 0,\n    k31BitSmis = 1 << 1,\n    kSandbox = 1 << 2,\n    kTargetOsIsAndroid = 1 << 3,\n    kEnableChecks = 1 << 4,\n  };\n\n  /**\n   * Checks that the embedder build configuration is compatible with\n   * the V8 binary and if so initializes V8.\n   */\n  static bool Initialize(int build_config);\n\n  friend class Context;\n  template <class K, class V, class T>\n  friend class PersistentValueMapBase;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetSnapshotDataBlob\",\n            \"parent\": \"V8\",\n            \"about\": \"Sets the snapshot data blob for V8.\",\n            \"logic\": \"Provides startup data to V8, especially when V8 is built with external startup data. The data must remain valid until V8 exits.\",\n            \"parameters\": [\n                {\n                    \"name\": \"startup_blob\",\n                    \"type\": \"StartupData*\",\n                    \"purpose\": \"Pointer to the startup data blob.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StartupData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void SetSnapshotDataBlob(StartupData* startup_blob);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetDcheckErrorHandler\",\n            \"parent\": \"V8\",\n            \"about\": \"Sets the callback to invoke in case of Dcheck failures.\",\n            \"logic\": \"Registers a callback function to be invoked when a Dcheck (debug check) fails within V8. This allows embedders to customize error handling in debug builds.\",\n            \"parameters\": [\n                {\n                    \"name\": \"that\",\n                    \"type\": \"DcheckErrorCallback\",\n                    \"purpose\": \"The callback function to be invoked.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DcheckErrorCallback\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void SetDcheckErrorHandler(DcheckErrorCallback that);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetFatalErrorHandler\",\n            \"parent\": \"V8\",\n            \"about\": \"Sets the callback to invoke in the case of CHECK failures or fatal errors.\",\n            \"logic\": \"Registers a callback function to be invoked when a fatal error occurs within V8 (excluding API usage failures).  This allows embedders to customize error handling.\",\n            \"parameters\": [\n                {\n                    \"name\": \"that\",\n                    \"type\": \"V8FatalErrorCallback\",\n                    \"purpose\": \"The callback function to be invoked.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"V8FatalErrorCallback\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void SetFatalErrorHandler(V8FatalErrorCallback that);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetFlagsFromString\",\n            \"parent\": \"V8\",\n            \"about\": \"Sets V8 flags from a string.\",\n            \"logic\": \"Parses a string for V8 command-line flags and applies them. This allows for runtime configuration of V8's behavior.\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The string containing the flags.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  static void SetFlagsFromString(const char* str);\n  static void SetFlagsFromString(const char* str, size_t length);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetFlagsFromCommandLine\",\n            \"parent\": \"V8\",\n            \"about\": \"Sets V8 flags from the command line.\",\n            \"logic\": \"Parses the command-line arguments for V8-specific flags and applies them. The `remove_flags` parameter controls whether the V8 flags are removed from the argument list.\",\n            \"parameters\": [\n                {\n                    \"name\": \"argc\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"Pointer to the argument count.\"\n                },\n                {\n                    \"name\": \"argv\",\n                    \"type\": \"char**\",\n                    \"purpose\": \"Pointer to the argument vector.\"\n                },\n                {\n                    \"name\": \"remove_flags\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether to remove the V8 flags from the argument list.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  static void SetFlagsFromCommandLine(int* argc, char** argv,\n                                      bool remove_flags);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetVersion\",\n            \"parent\": \"V8\",\n            \"about\": \"Gets the version string.\",\n            \"logic\": \"Returns the version string of the V8 engine.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"const char*\",\n                \"description\": \"The V8 version string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  static const char* GetVersion();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Initialize\",\n            \"parent\": \"V8\",\n            \"about\": \"Initializes V8.\",\n            \"logic\": \"Initializes the V8 engine. This function must be called before creating any isolates. It checks the build configuration and then calls the internal Initialize method.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Always returns true.\"\n            },\n            \"dependencies\": [\n                \"internal::PointerCompressionIsEnabled\",\n                \"internal::SmiValuesAre31Bits\",\n                \"internal::SandboxIsEnabled\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  V8_INLINE static bool Initialize() {\n#ifdef V8_TARGET_OS_ANDROID\n    const bool kV8TargetOsIsAndroid = true;\n#else\n    const bool kV8TargetOsIsAndroid = false;\n#endif\n\n#ifdef V8_ENABLE_CHECKS\n    const bool kV8EnableChecks = true;\n#else\n    const bool kV8EnableChecks = false;\n#endif\n\n    const int kBuildConfiguration =\n        (internal::PointerCompressionIsEnabled() ? kPointerCompression : 0) |\n        (internal::SmiValuesAre31Bits() ? k31BitSmis : 0) |\n        (internal::SandboxIsEnabled() ? kSandbox : 0) |\n        (kV8TargetOsIsAndroid ? kTargetOsIsAndroid : 0) |\n        (kV8EnableChecks ? kEnableChecks : 0);\n    return Initialize(kBuildConfiguration);\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetEntropySource\",\n            \"parent\": \"V8\",\n            \"about\": \"Allows the host application to provide a callback which can be used as a source of entropy for random number generators.\",\n            \"logic\": \"Registers a callback function to be used as a source of entropy for V8's random number generators.  This is crucial for security-sensitive applications.\",\n            \"parameters\": [\n                {\n                    \"name\": \"source\",\n                    \"type\": \"EntropySource\",\n                    \"purpose\": \"The callback function to be used as the entropy source.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"EntropySource\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void SetEntropySource(EntropySource source);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetReturnAddressLocationResolver\",\n            \"parent\": \"V8\",\n            \"about\": \"Allows the host application to provide a callback that allows v8 to cooperate with a profiler that rewrites return addresses on stack.\",\n            \"logic\": \"Registers a callback function that allows V8 to cooperate with profilers that rewrite return addresses on the stack. This ensures accurate stack traces in the presence of such profilers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"return_address_resolver\",\n                    \"type\": \"ReturnAddressLocationResolver\",\n                    \"purpose\": \"The callback function to resolve return address locations.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReturnAddressLocationResolver\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void SetReturnAddressLocationResolver(\n      ReturnAddressLocationResolver return_address_resolver);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Dispose\",\n            \"parent\": \"V8\",\n            \"about\": \"Releases any resources used by v8 and stops any utility threads that may be running.\",\n            \"logic\": \"Releases all resources held by the V8 engine and stops any background threads. This operation is permanent, and V8 cannot be reinitialized after disposal.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true on success.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  static bool Dispose();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeICU\",\n            \"parent\": \"V8\",\n            \"about\": \"Initialize the ICU library bundled with V8.\",\n            \"logic\": \"Initializes the International Components for Unicode (ICU) library that is bundled with V8. This method is used when V8 is configured to use its own copy of ICU. Optionally takes a path to the ICU data file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"icu_data_file\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The path to the ICU data file (optional).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true on success.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  static bool InitializeICU(const char* icu_data_file = nullptr);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeICUDefaultLocation\",\n            \"parent\": \"V8\",\n            \"about\": \"Initialize the ICU library bundled with V8 using the default file location.\",\n            \"logic\": \"Initializes the ICU library bundled with V8, using the default file location which is side-by-side with the executable, named `icudtl.dat`. Optionally, the location of the data file can be explicitly provided.\",\n            \"parameters\": [\n                {\n                    \"name\": \"exec_path\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The path to the executable.\"\n                },\n                {\n                    \"name\": \"icu_data_file\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The path to the ICU data file (optional).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true on success.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  static bool InitializeICUDefaultLocation(const char* exec_path,\n                                           const char* icu_data_file = nullptr);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeExternalStartupData\",\n            \"parent\": \"V8\",\n            \"about\": \"Initialize the external startup data.\",\n            \"logic\": \"Initializes V8 with external startup data (snapshot and context snapshot) if V8 was built to load these from external files. This version looks for the files in the specified directory.\",\n            \"parameters\": [\n                {\n                    \"name\": \"directory_path\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The directory containing the snapshot data files.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  static void InitializeExternalStartupData(const char* directory_path);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializeExternalStartupDataFromFile\",\n            \"parent\": \"V8\",\n            \"about\": \"Initialize the external startup data from a specific file.\",\n            \"logic\": \"Initializes V8 with external startup data (snapshot and context snapshot) if V8 was built to load these from an external file. This version uses the specified file path.\",\n            \"parameters\": [\n                {\n                    \"name\": \"snapshot_blob\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The path to the snapshot data file.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  static void InitializeExternalStartupDataFromFile(const char* snapshot_blob);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InitializePlatform\",\n            \"parent\": \"V8\",\n            \"about\": \"Sets the v8::Platform to use.\",\n            \"logic\": \"Sets the platform to be used by V8. This needs to be invoked before V8 is initialized. The Platform provides OS-level functionality.\",\n            \"parameters\": [\n                {\n                    \"name\": \"platform\",\n                    \"type\": \"Platform*\",\n                    \"purpose\": \"The v8::Platform to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Platform\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void InitializePlatform(Platform* platform);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"DisposePlatform\",\n            \"parent\": \"V8\",\n            \"about\": \"Clears all references to the v8::Platform.\",\n            \"logic\": \"Clears all references to the v8::Platform. This should be invoked after V8 was disposed.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Platform\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  static void DisposePlatform();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsSandboxConfiguredSecurely\",\n            \"parent\": \"V8\",\n            \"about\": \"Returns true if the sandbox is configured securely.\",\n            \"logic\": \"Checks if the V8 sandbox is configured securely. A fallback sandbox is used if a regular sandbox cannot be created due to insufficient virtual address space. This method returns false if a fallback sandbox is in use.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the sandbox is configured securely, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#if defined(V8_ENABLE_SANDBOX)\n  /**\n   * Returns true if the sandbox is configured securely.\n   *\n   * If V8 cannot create a regular sandbox during initialization, for example\n   * because not enough virtual address space can be reserved, it will instead\n   * create a fallback sandbox that still allows it to function normally but\n   * does not have the same security properties as a regular sandbox. This API\n   * can be used to determine if such a fallback sandbox is being used, in\n   * which case it will return false.\n   */\n  static bool IsSandboxConfiguredSecurely();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetSandboxAddressSpace\",\n            \"parent\": \"V8\",\n            \"about\": \"Provides access to the virtual address subspace backing the sandbox.\",\n            \"logic\": \"Provides access to the virtual address subspace that backs the V8 sandbox. Allows allocation of pages within the sandbox, for example, for ArrayBuffer backing stores.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"VirtualAddressSpace*\",\n                \"description\": \"Pointer to the VirtualAddressSpace backing the sandbox.\"\n            },\n            \"dependencies\": [\n                \"VirtualAddressSpace\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  /**\n   * Provides access to the virtual address subspace backing the sandbox.\n   *\n   * This can be used to allocate pages inside the sandbox, for example to\n   * obtain virtual memory for ArrayBuffer backing stores, which must be\n   * located inside the sandbox.\n   *\n   * It should be assumed that an attacker can corrupt data inside the sandbox,\n   * and so in particular the contents of pages allocagted in this virtual\n   * address space, arbitrarily and concurrently. Due to this, it is\n   * recommended to to only place pure data buffers in them.\n   */\n  static VirtualAddressSpace* GetSandboxAddressSpace();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetSandboxSizeInBytes\",\n            \"parent\": \"V8\",\n            \"about\": \"Returns the size of the sandbox in bytes.\",\n            \"logic\": \"Returns the size of the V8 sandbox in bytes. This is the address space that V8 can directly address.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The size of the sandbox in bytes.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  /**\n   * Returns the size of the sandbox in bytes.\n   *\n   * This represents the size of the address space that V8 can directly address\n   * and in which it allocates its objects.\n   */\n  static size_t GetSandboxSizeInBytes();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetSandboxReservationSizeInBytes\",\n            \"parent\": \"V8\",\n            \"about\": \"Returns the size of the address space reservation backing the sandbox.\",\n            \"logic\": \"Returns the size of the address space reservation backing the V8 sandbox. This may be larger or smaller than the actual sandbox size depending on whether a fallback sandbox"
}