{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/cpp-builder.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 95, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/cpp-builder.h\",\n        \"file_name\": \"cpp-builder.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides classes and utilities for generating C++ code, including classes for managing classes, functions, and files with features like include guards and namespaces.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard library headers for stack and string manipulation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stack>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Torque specific headers for AST and type definitions.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/torque/ast.h\"\n            #include \"src/torque/types.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"TemplateParameter\",\n            \"about\": \"Represents a template parameter with optional type information.\",\n            \"attributes\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"std::string\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Name of the template parameter\"\n                },\n                {\n                    \"name\": \"type\",\n                    \"type\": \"std::string\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Type of the template parameter (optional)\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct TemplateParameter {\n            explicit TemplateParameter(std::string name) : name(std::move(name)) {}\n            TemplateParameter(std::string type, std::string name)\n                : name(std::move(name)), type(std::move(type)) {}\n\n            std::string name;\n            std::string type;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Class\",\n            \"about\": \"Represents a C++ class with template parameters and name.\",\n            \"attributes\": [\n                {\n                    \"name\": \"template_parameters_\",\n                    \"type\": \"std::vector<TemplateParameter>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"List of template parameters for the class.\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Name of the class.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TemplateParameter\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Class {\n            public:\n            explicit Class(std::string name) : name_(std::move(name)) {}\n            Class(std::vector<TemplateParameter> template_parameters, std::string name)\n                : template_parameters_(std::move(template_parameters)),\n                name_(std::move(name)) {}\n\n            std::string GetName() const { return name_; }\n            std::vector<TemplateParameter> GetTemplateParameters() const {\n                return template_parameters_;\n            }\n\n            private:\n            std::vector<TemplateParameter> template_parameters_;\n            std::string name_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Function\",\n            \"about\": \"Represents a C++ function with various attributes like flags, parameters, and return type.\",\n            \"attributes\": [\n                {\n                    \"name\": \"pos_\",\n                    \"type\": \"SourcePosition\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Source position of the function definition.\"\n                },\n                {\n                    \"name\": \"owning_class_\",\n                    \"type\": \"Class*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the class that owns this function (nullptr for global functions).\"\n                },\n                {\n                    \"name\": \"description_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Description of the function.\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Name of the function.\"\n                },\n                {\n                    \"name\": \"return_type_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Return type of the function.\"\n                },\n                {\n                    \"name\": \"parameters_\",\n                    \"type\": \"std::vector<Parameter>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"List of parameters for the function.\"\n                },\n                {\n                    \"name\": \"flags_\",\n                    \"type\": \"base::Flags<FunctionFlag>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flags indicating properties of the function (e.g., inline, const).\"\n                }\n            ],\n            \"dependencies\": [\n                \"Class\",\n                \"SourcePosition\",\n                \"Parameter\",\n                \"base::Flags\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Function {\n            public:\n            enum FunctionFlag {\n        #define ENTRY(name, value) k##name = value,\n            FUNCTION_FLAG_LIST(ENTRY)\n        #undef ENTRY\n            };\n\n            struct Parameter {\n                std::string type;\n                std::string name;\n                std::string default_value;\n\n                Parameter(std::string type, std::string name,\n                        std::string default_value = {})\n                    : type(std::move(type)),\n                    name(std::move(name)),\n                    default_value(std::move(default_value)) {}\n            };\n\n            explicit Function(std::string name)\n                : pos_(CurrentSourcePosition::Get()),\n                owning_class_(nullptr),\n                name_(std::move(name)) {}\n            Function(Class* owning_class, std::string name)\n                : pos_(CurrentSourcePosition::Get()),\n                owning_class_(owning_class),\n                name_(std::move(name)) {}\n            ~Function() = default;\n\n            static Function DefaultGetter(std::string return_type, Class* owner,\n                                            std::string name) {\n                Function getter(owner, std::move(name));\n                getter.SetReturnType(std::move(return_type));\n                getter.SetInline();\n                getter.SetConst();\n                return getter;\n            }\n\n            static Function DefaultSetter(Class* owner, std::string name,\n                                            std::string parameter_type,\n                                            std::string parameter_name) {\n                Function setter(owner, std::move(name));\n                setter.SetReturnType(\"void\");\n                setter.AddParameter(std::move(parameter_type), std::move(parameter_name));\n                setter.SetInline();\n                return setter;\n            }\n\n            void SetFlag(FunctionFlag flag, bool value = true) {\n                if (value) {\n                flags_ = flags_ | flag;\n                } else {\n                flags_ = flags_.without(flag);\n                }\n            }\n            void SetFlags(base::Flags<FunctionFlag> flags, bool value = true) {\n                if (value) {\n                flags_ |= flags;\n                } else {\n                flags_ &= ~flags;\n                }\n            }\n            bool HasFlag(FunctionFlag flag) const { return (flags_ & flag) == flag; }\n        #define ACCESSOR(name, value)                            \\\n            void Set##name(bool v = true) { SetFlag(k##name, v); } \\\n            bool Is##name() const { return HasFlag(k##name); }\n            FUNCTION_FLAG_LIST(ACCESSOR)\n        #undef ACCESSOR\n\n            void SetDescription(std::string description) {\n                description_ = std::move(description);\n            }\n            void SetName(std::string name) { name_ = std::move(name); }\n            void SetReturnType(std::string return_type) {\n                return_type_ = std::move(return_type);\n            }\n            void AddParameter(std::string type, std::string name = {},\n                                std::string default_value = {}) {\n                parameters_.emplace_back(std::move(type), std::move(name),\n                                        std::move(default_value));\n            }\n            void InsertParameter(int index, std::string type, std::string name = {},\n                            std::string default_value = {}) {\n                DCHECK_GE(index, 0);\n                DCHECK_LE(index, parameters_.size());\n                parameters_.insert(\n                    parameters_.begin() + index,\n                    Parameter(std::move(type), std::move(name), std::move(default_value)));\n            }\n            std::vector<Parameter> GetParameters() const { return parameters_; }\n            std::vector<std::string> GetParameterNames() const {\n                std::vector<std::string> names;\n                std::transform(parameters_.begin(), parameters_.end(),\n                                std::back_inserter(names),\n                                [](const Parameter& p) { return p.name; });\n                return names;\n            }\n\n            static constexpr int kAutomaticIndentation = -1;\n            void PrintDeclaration(std::ostream& stream,\n                                int indentation = kAutomaticIndentation) const;\n            void PrintDefinition(std::ostream& stream,\n                                const std::function<void(std::ostream&)>& builder,\n                                int indentation = 0) const;\n            void PrintInlineDefinition(std::ostream& stream,\n                                    const std::function<void(std::ostream&)>& builder,\n                                    int indentation = 2) const;\n            void PrintBeginDefinition(std::ostream& stream, int indentation = 0) const;\n            void PrintEndDefinition(std::ostream& stream, int indentation = 0) const;\n\n            protected:\n            void PrintDeclarationHeader(std::ostream& stream, int indentation) const;\n\n            private:\n            SourcePosition pos_;\n            Class* owning_class_;\n            std::string description_;\n            std::string name_;\n            std::string return_type_;\n            std::vector<Parameter> parameters_;\n            base::Flags<FunctionFlag> flags_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"File\",\n            \"about\": \"Represents a C++ file and provides utilities for writing to it, including include guards and namespaces.\",\n            \"attributes\": [\n                {\n                    \"name\": \"stream_\",\n                    \"type\": \"std::ostream*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the output stream.\"\n                },\n                {\n                    \"name\": \"includes_\",\n                    \"type\": \"std::set<std::string>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Set of include files to be added to the file.\"\n                },\n                {\n                    \"name\": \"namespaces_\",\n                    \"type\": \"std::stack<std::string>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stack of namespaces to be opened and closed in the file.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class File {\n            public:\n            explicit File(std::ostream& stream) : stream_(&stream) {}\n\n            void BeginIncludeGuard(const std::string& name);\n            void EndIncludeGuard(const std::string& name);\n            void BeginNamespace(std::string name);\n            void BeginNamespace(std::string name0, std::string name1);\n            void EndNamespace(const std::string& name);\n            void EndNamespace(const std::string& name0, const std::string& name1);\n\n            void AddInclude(std::string include) { includes_.insert(std::move(include)); }\n\n            template <typename T>\n            File& operator<<(const T& value) {\n                s() << value;\n                return *this;\n            }\n\n            protected:\n            std::ostream& s() { return *stream_; }\n\n            private:\n            std::ostream* stream_;\n            std::set<std::string> includes_;\n            std::stack<std::string> namespaces_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IncludeGuardScope\",\n            \"about\": \"RAII class for managing include guards in a C++ file.\",\n            \"attributes\": [\n                {\n                    \"name\": \"file_\",\n                    \"type\": \"File*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the File object to manage.\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"std::string\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Name of the include guard.\"\n                }\n            ],\n            \"dependencies\": [\n                \"File\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class IncludeGuardScope {\n            public:\n            explicit IncludeGuardScope(File* file, std::string name)\n                : file_(file), name_(std::move(name)) {\n                file_->BeginIncludeGuard(name_);\n            }\n            IncludeGuardScope(const IncludeGuardScope&) = delete;\n            IncludeGuardScope(IncludeGuardScope&& other) V8_NOEXCEPT : file_(nullptr),\n                                                                        name_() {\n                std::swap(file_, other.file_);\n                std::swap(name_, other.name_);\n            }\n            ~IncludeGuardScope() {\n                if (file_) {\n                file_->EndIncludeGuard(name_);\n                }\n            }\n            IncludeGuardScope& operator=(const IncludeGuardScope&) = delete;\n            IncludeGuardScope& operator=(IncludeGuardScope&& other) V8_NOEXCEPT {\n                if (this != &other) {\n                DCHECK_NULL(file_);\n                DCHECK(name_.empty());\n                std::swap(file_, other.file_);\n                std::swap(name_, other.name_);\n                }\n                return *this;\n            }\n\n            private:\n            File* file_;\n            std::string name_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DEFINE_OPERATORS_FOR_FLAGS\",\n            \"about\": \"Macro defining operators for a flags class.\",\n            \"logic\": \"The macro `DEFINE_OPERATORS_FOR_FLAGS` is used to define operators for the `base::Flags<Function::FunctionFlag>` class.  The implementation of the macro is not in this file.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"base::Flags\",\n                \"Function::FunctionFlag\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            DEFINE_OPERATORS_FOR_FLAGS(base::Flags<Function::FunctionFlag>)\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SourcePosition\",\n                \"about\": \"Represents a source code position.\",\n                \"attributes\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class SourcePosition {\n                public:\n                    static SourcePosition Get();\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"base::Flags\",\n                \"about\": \"Represents a set of flags.\",\n                \"attributes\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base {\n                    template <typename EnumType>\n                    class Flags {\n                    public:\n                        Flags& operator|=(const Flags& other);\n                        Flags& operator&=(const Flags& other);\n                    };\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n    <dependencies>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DCHECK_GE\",\n                \"about\": \"A debug check macro.\",\n                \"parameters\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                #define DCHECK_GE(a, b)\n            ]]></code>\n        </func>\n    </dependencies>\n    <dependencies>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DCHECK_LE\",\n                \"about\": \"A debug check macro.\",\n                \"parameters\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                #define DCHECK_LE(a, b)\n            ]]></code>\n        </func>\n    </dependencies>\n    <dependencies>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DCHECK_NULL\",\n                \"about\": \"A debug check macro.\",\n                \"parameters\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                #define DCHECK_NULL(a)\n            ]]></code>\n        </func>\n    </dependencies>\n    <dependencies>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"V8_NOEXCEPT\",\n                \"about\": \"Indicates that function doesn't throw exceptions.\",\n                \"parameters\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                #define V8_NOEXCEPT noexcept\n            ]]></code>\n        </func>\n    </dependencies>\n</file>\n```"
}