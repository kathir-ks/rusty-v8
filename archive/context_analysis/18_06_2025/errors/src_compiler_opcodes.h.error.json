{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/opcodes.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 667, column 30",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/opcodes.h\",\n        \"file_name\": \"opcodes.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines opcodes used in the V8 compiler pipeline.  Includes opcodes for control flow, constants, JavaScript operations, simplified operations, and machine operations. Uses macros to define lists of opcodes for different categories.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides forward declarations for iostream objects.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <iosfwd>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides global definitions used throughout V8.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/common/globals.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"IrOpcode\",\n            \"about\": \"Declares an enumeration with all the opcodes at all levels so that they can be globally, uniquely numbered.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        class V8_EXPORT_PRIVATE IrOpcode {\n        public:\n            enum Value {\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Mnemonic\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns the mnemonic name of an opcode.\",\n            \"logic\": \"Retrieves the string representation of an IrOpcode::Value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to retrieve the mnemonic for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"char const*\",\n                \"description\": \"A pointer to a constant character array (string) representing the mnemonic.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static char const* Mnemonic(Value value);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsCommonOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns true if opcode for common operator.\",\n            \"logic\": \"Checks if the provided IrOpcode::Value falls within the range of common opcodes, which are defined by their enumeration values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode is a common opcode, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool IsCommonOpcode(Value value) {\n                return kStart <= value && value <= kStaticAssert;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsControlOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns true if opcode for control operator.\",\n            \"logic\": \"Checks if the provided IrOpcode::Value falls within the range of control opcodes, which are defined by their enumeration values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode is a control opcode, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool IsControlOpcode(Value value) {\n                return kStart <= value && value <= kEnd;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsJsOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns true if opcode for JavaScript operator.\",\n            \"logic\": \"Checks if the provided IrOpcode::Value falls within the range of JS opcodes, which are defined by their enumeration values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode is a JavaScript opcode, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool IsJsOpcode(Value value) {\n                return kJSEqual <= value && value <= kJSDebugger;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsMachineOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns true if opcode for machine operator.\",\n            \"logic\": \"Checks if the provided IrOpcode::Value falls within the range of machine opcodes, which are defined by their enumeration values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode is a machine opcode, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool IsMachineOpcode(Value value) {\n                return kWord32Clz <= value && value <= kTraceInstruction;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsMachineConstantOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns true iff opcode is a machine-level constant.\",\n            \"logic\": \"Uses a switch statement to check if the opcode is one of the defined MACHINE_LEVEL_CONSTANT_OP_LIST opcodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode is a machine-level constant, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool IsMachineConstantOpcode(Value value) {\n                switch (value) {\n        #define CASE(name) \\\n          case k##name:    \\\n            return true;\n                  MACHINE_LEVEL_CONSTANT_OP_LIST(CASE)\n        #undef CASE\n              default:\n                return false;\n            }\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsConstantOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns true if opcode for constant operator.\",\n            \"logic\": \"Uses a switch statement to check if the opcode is one of the defined CONSTANT_OP_LIST opcodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode is a constant opcode, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static bool IsConstantOpcode(Value value) {\n        #define CASE(Name) \\\n          case k##Name:    \\\n            return true;\n            switch (value) {\n              CONSTANT_OP_LIST(CASE);\n              default:\n                return false;\n            }\n        #undef CASE\n            UNREACHABLE();\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsPhiOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Checks if the given opcode is a Phi or EffectPhi opcode.\",\n            \"logic\": \"Compares the input opcode value against the kPhi and kEffectPhi opcodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true if the opcode is a Phi or EffectPhi opcode; otherwise, returns false.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n          static bool IsPhiOpcode(Value value) {\n            return value == kPhi || value == kEffectPhi;\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsMergeOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Checks if the given opcode is a Merge or Loop opcode.\",\n            \"logic\": \"Compares the input opcode value against the kMerge and kLoop opcodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true if the opcode is a Merge or Loop opcode; otherwise, returns false.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n          static bool IsMergeOpcode(Value value) {\n            return value == kMerge || value == kLoop;\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsIfProjectionOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Checks if the given opcode is an IfTrue, IfFalse, IfSuccess, IfException, IfValue, or IfDefault opcode.\",\n            \"logic\": \"Compares the input opcode value against the kIfTrue, kIfFalse, kIfSuccess, kIfException, kIfValue, and kIfDefault opcodes using a range check.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true if the opcode is an IfTrue, IfFalse, IfSuccess, IfException, IfValue, or IfDefault opcode; otherwise, returns false.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n          static bool IsIfProjectionOpcode(Value value) {\n            return kIfTrue <= value && value <= kIfDefault;\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsGraphTerminator\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns true if opcode terminates control flow in a graph (i.e. respective nodes are expected to have control uses by the graphs {End} node only).\",\n            \"logic\": \"Checks if the provided IrOpcode::Value is one of the graph terminator opcodes (kDeoptimize, kReturn, kTailCall, kTerminate, kThrow).\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode is a graph terminator, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n          static bool IsGraphTerminator(Value value) {\n            return value == kDeoptimize || value == kReturn || value == kTailCall ||\n                   value == kTerminate || value == kThrow;\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsInlineeOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns true if opcode can be inlined.\",\n            \"logic\": \"Checks if the provided IrOpcode::Value is one of the inlinee opcodes (kJSConstruct, kJSCall).\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode can be inlined, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n          static bool IsInlineeOpcode(Value value) {\n            return value == kJSConstruct || value == kJSCall;\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsComparisonOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Returns true if opcode for comparison operator.\",\n            \"logic\": \"Uses a switch statement and predefined lists to check if the opcode is a comparison operator from JS, Simplified, or Machine levels.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode is a comparison operator, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n          static bool IsComparisonOpcode(Value value) {\n        #define CASE(Name, ...) \\\n          case k##Name:         \\\n            return true;\n            switch (value) {\n              JS_COMPARE_BINOP_LIST(CASE);\n              SIMPLIFIED_COMPARE_BINOP_LIST(CASE);\n              MACHINE_COMPARE_BINOP_LIST(CASE);\n              default:\n                return false;\n            }\n        #undef CASE\n            UNREACHABLE();\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsContextChainExtendingOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Checks if the given opcode is a context chain extending opcode.\",\n            \"logic\": \"Compares the input opcode value against the range of context chain extending opcodes, from kJSCreateFunctionContext to kJSCreateBlockContext.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true if the opcode is a context chain extending opcode; otherwise, returns false.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n          static bool IsContextChainExtendingOpcode(Value value) {\n            return kJSCreateFunctionContext <= value && value <= kJSCreateBlockContext;\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsFeedbackCollectingOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Checks if the given opcode is a feedback collecting opcode, meaning it takes the feedback vector as input and implements feedback-collecting logic in generic lowering.\",\n            \"logic\": \"Uses a switch statement and predefined lists to check if the opcode is a feedback collecting operator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true if the opcode is a feedback collecting opcode; otherwise, returns false.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n          static bool IsFeedbackCollectingOpcode(Value value) {\n        #define CASE(Name, ...) \\\n          case k##Name:         \\\n            return true;\n            switch (value) {\n              JS_ARITH_BINOP_LIST(CASE)\n              JS_ARITH_UNOP_LIST(CASE)\n              JS_BITWISE_BINOP_LIST(CASE)\n              JS_BITWISE_UNOP_LIST(CASE)\n              JS_COMPARE_BINOP_LIST(CASE)\n              case kJSCall:\n              case kJSCallWithArrayLike:\n              case kJSCallWithSpread:\n              case kJSCloneObject:\n              case kJSConstruct:\n              case kJSConstructWithArrayLike:\n              case kJSConstructWithSpread:\n              case kJSCreateEmptyLiteralArray:\n              case kJSCreateLiteralArray:\n              case kJSCreateLiteralObject:\n              case kJSCreateLiteralRegExp:\n              case kJSDefineKeyedOwnProperty:\n              case kJSForInNext:\n              case kJSForInPrepare:\n              case kJSGetIterator:\n              case kJSGetTemplateObject:\n              case kJSHasProperty:\n              case kJSInstanceOf:\n              case kJSLoadGlobal:\n              case kJSLoadNamed:\n              case kJSLoadNamedFromSuper:\n              case kJSLoadProperty:\n              case kJSDefineKeyedOwnPropertyInLiteral:\n              case kJSStoreGlobal:\n              case kJSStoreInArrayLiteral:\n              case kJSSetNamedProperty:\n              case kJSDefineNamedOwnProperty:\n              case kJSSetKeyedProperty:\n                return true;\n              default:\n                return false;\n            }\n        #undef CASE\n            UNREACHABLE();\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsFeedbackCollectingOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Overload of IsFeedbackCollectingOpcode that takes int16_t\",\n            \"logic\": \"Same logic as other overload, but casts the int16_t to Value\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int16_t\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true if the opcode is a feedback collecting opcode; otherwise, returns false.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n          static bool IsFeedbackCollectingOpcode(int16_t value) {\n            DCHECK(0 <= value && value <= kLast);\n            return IsFeedbackCollectingOpcode(static_cast<IrOpcode::Value>(value));\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"isAtomicOpOpcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Checks if the given opcode is an atomic operation opcode.\",\n            \"logic\": \"Uses a switch statement and the MACHINE_ATOMIC_OP_LIST macro to determine if the opcode is an atomic operation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true if the opcode is an atomic operation opcode; otherwise, returns false.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        static bool isAtomicOpOpcode(Value value) {\n            switch (value) {\n            #define CASE(Name, ...) \\\n              case k##Name:         \\\n                return true;\n              MACHINE_ATOMIC_OP_LIST(CASE)\n              default:\n                return false;\n            #undef CASE\n            }\n            UNREACHABLE();\n          }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"IsSimd128Opcode\",\n            \"parent\": \"IrOpcode\",\n            \"about\": \"Checks if the given opcode is a SIMD128 opcode.\",\n            \"logic\": \"Uses a switch statement and the MACHINE_SIMD128_OP_LIST macro to determine if the opcode is a SIMD128 opcode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Value\",\n                    \"purpose\": \"The opcode value to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"Returns true if the opcode is a SIMD128 opcode; otherwise, returns false.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        #if V8_ENABLE_WEBASSEMBLY\n          static bool IsSimd128Opcode(Value value) {\n        #define CASE(Name, ...) case k##Name:\n            switch (value) {\n              MACHINE_SIMD128_OP_LIST(CASE)\n              return true;\n              default:\n                return false;\n            }\n        #undef CASE\n            UNREACHABLE();\n          }\n        #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"free_function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the << operator for IrOpcode::Value to allow printing of opcodes to an output stream.\",\n            \"logic\": \"The actual implementation is not present in this header file; it's assumed to be defined elsewhere. It converts the IrOpcode::Value to a string representation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream to write to.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"IrOpcode::Value\",\n                    \"purpose\": \"The opcode value to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"Returns the modified output stream.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream&, IrOpcode::Value);\n        ]]></code>\n    </func>\n    <code><![CDATA[\n        };\n\n        V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream&, IrOpcode::Value);\n\n        }  // namespace compiler\n        }  // namespace internal\n        }  // namespace v8\n\n        #endif  // V8_COMPILER_OPCODES_H_\n    ]]></code>\n</file>\n```"
}