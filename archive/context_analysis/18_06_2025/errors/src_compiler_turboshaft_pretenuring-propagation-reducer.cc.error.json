{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/pretenuring-propagation-reducer.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 33, column 37",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/pretenuring-propagation-reducer.cc\",\n      \"file_name\": \"pretenuring-propagation-reducer.cc\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Implements the PretenuringPropagationAnalyzer which analyzes the Turboshaft graph to propagate allocation types (Young or Old) based on stores and phi nodes, with the goal of promoting Young allocations to Old.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes the header file for the PretenuringPropagationReducer class.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/compiler/turboshaft/pretenuring-propagation-reducer.h\"\n    ]]></code>\n  </imports>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"CouldBeAllocate\",\n        \"parent\": null,\n        \"about\": \"Checks if an operation could potentially be an allocation (either a Phi or an AllocateOp).\",\n        \"logic\": \"Returns true if the operation is a PhiOp or an AllocateOp, false otherwise.\",\n        \"parameters\": [\n          {\n            \"name\": \"base\",\n            \"type\": \"const Operation&\",\n            \"purpose\": \"The operation to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the operation could be an allocation, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"PhiOp\",\n          \"AllocateOp\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nnamespace {\n\nbool CouldBeAllocate(const Operation& base) {\n  return base.Is<PhiOp>() || base.Is<AllocateOp>();\n}\n\n}  // namespace\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"ProcessStore\",\n        \"parent\": \"PretenuringPropagationAnalyzer\",\n        \"about\": \"Processes a StoreOp to determine if the stored value (if it's a potential allocation) should be associated with the base object (if it's also a potential allocation).\",\n        \"logic\": \"If both the base and the value of the store could be allocations, and the value is not already an old allocation (or a phi of allocations that could be promoted to old), records the value as being stored in the base. This is used later to track which allocations are contained within other allocations.\",\n        \"parameters\": [\n          {\n            \"name\": \"store\",\n            \"type\": \"const StoreOp&\",\n            \"purpose\": \"The StoreOp to process.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"OpIndex\",\n          \"Operation\",\n          \"PhiOp\",\n          \"AllocateOp\",\n          \"AllocationType\",\n          \"FindOrCreate\",\n          \"TryFind\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid PretenuringPropagationAnalyzer::ProcessStore(const StoreOp& store) {\n  OpIndex base_idx = store.base();\n  OpIndex value_idx = store.value();\n  const Operation& base = input_graph_.Get(base_idx);\n  const Operation& value = input_graph_.Get(value_idx);\n\n  if (!CouldBeAllocate(base) || !CouldBeAllocate(value)) {\n    return;\n  }\n\n  if (value.Is<AllocateOp>() &&\n      value.Cast<AllocateOp>().type == AllocationType::kOld) {\n    // {value} is already Old, and we don't care about new-to-old and old-to-old\n    // stores.\n    return;\n  }\n\n  if (value.Is<PhiOp>() && TryFind(value_idx) == nullptr) {\n    // {value} is not worth being recorded, as it's not an Allocation (or a Phi\n    // of Allocations) that could be promoted to Old.\n    return;\n  }\n\n  ZoneVector<OpIndex>* stored_in_base = FindOrCreate(base_idx);\n  stored_in_base->push_back(value_idx);\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"ProcessPhi\",\n        \"parent\": \"PretenuringPropagationAnalyzer\",\n        \"about\": \"Processes a PhiOp to record the potential dependencies between the phi and its inputs, for pretenuring propagation.\",\n        \"logic\": \"For each input to the phi, if the input could be an allocation (either an AllocateOp or a PhiOp already tracked), records the input as being 'stored' in the phi. This allows the pretenuring propagation to follow phi nodes and treat them as potential storage points.\",\n        \"parameters\": [\n          {\n            \"name\": \"phi\",\n            \"type\": \"const PhiOp&\",\n            \"purpose\": \"The PhiOp to process.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"OpIndex\",\n          \"Operation\",\n          \"AllocateOp\",\n          \"PhiOp\",\n          \"TryFind\",\n          \"Create\",\n          \"SmallVector\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid PretenuringPropagationAnalyzer::ProcessPhi(const PhiOp& phi) {\n  // Phis act as storing all of their inputs. It's not how they work in\n  // practice, but if a Phi has a Young input, and is stored in an Old object,\n  // it makes sense to Oldify the phi input.\n\n  // For better performance, we only record inputs that could be an allocation:\n  // Phis with an entry in {store_graph_} or AllocateOp.\n  // Note that this is slightly imprecise for loop Phis (since if the backedge\n  // is a Phi itself, it won't have an entry in {store_graph_} yet), but it\n  // should still be good enough for most cases.\n\n  base::SmallVector<OpIndex, 16> interesting_inputs;\n  for (OpIndex input : phi.inputs()) {\n    const Operation& op = input_graph_.Get(input);\n    if (op.Is<AllocateOp>()) {\n      interesting_inputs.push_back(input);\n    } else if (op.Is<PhiOp>() && TryFind(input) != nullptr) {\n      interesting_inputs.push_back(input);\n    }\n  }\n  if (interesting_inputs.empty()) return;\n\n  ZoneVector<OpIndex>* stored_in_phi = Create(input_graph_.Index(phi));\n  for (OpIndex input : interesting_inputs) {\n    stored_in_phi->push_back(input);\n  }\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"ProcessAllocate\",\n        \"parent\": \"PretenuringPropagationAnalyzer\",\n        \"about\": \"Processes an AllocateOp to record old allocations.\",\n        \"logic\": \"If the allocate op is of type 'kOld', it's added to a list of known old allocations, which will later be used as starting points for pretenuring propagation.\",\n        \"parameters\": [\n          {\n            \"name\": \"allocate\",\n            \"type\": \"const AllocateOp&\",\n            \"purpose\": \"The AllocateOp to process.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"AllocationType\",\n          \"OpIndex\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid PretenuringPropagationAnalyzer::ProcessAllocate(\n    const AllocateOp& allocate) {\n  if (allocate.type == AllocationType::kOld) {\n    // We could be a bit more lazy in storing old AllocateOp into {old_allocs_}\n    // (by waiting for a Store or a Phi to use the AllocateOp), but there is\n    // usually very few old allocation, so it makes sense to do it eagerly.\n    old_allocs_.push_back(input_graph_.Index(allocate));\n  }\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"PushContainedValues\",\n        \"parent\": \"PretenuringPropagationAnalyzer\",\n        \"about\": \"Adds the 'contained' values to the queue for processing.  'Contained' means values stored into an allocation or inputs to a phi node.\",\n        \"logic\": \"Looks up the values 'contained' within the given base (either values stored to it or inputs if it's a phi).  If there are contained values, they are added to the queue for later processing during allocation type propagation.\",\n        \"parameters\": [\n          {\n            \"name\": \"base\",\n            \"type\": \"OpIndex\",\n            \"purpose\": \"The index of the base operation (either an allocation or a phi).\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if any contained values were found and pushed to the queue, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"OpIndex\",\n          \"TryFind\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool PretenuringPropagationAnalyzer::PushContainedValues(OpIndex base) {\n  // Push into {queue_} all of the values that are \"contained\" into {base}:\n  // values that are stored to {base} if {base} is an AllocateOp, or Phi inputs\n  // if {base} is a Phi.\n  ZoneVector<OpIndex>* contained = TryFind(base);\n  if (contained == nullptr) return false;\n  for (OpIndex index : *contained) {\n    queue_.push_back(index);\n  }\n  return true;\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"OldifySubgraph\",\n        \"parent\": \"PretenuringPropagationAnalyzer\",\n        \"about\": \"Performs a depth-first search (DFS) from a given old allocation and marks all reachable allocations and phis as Old.  This is the core pretenuring propagation logic.\",\n        \"logic\": \"Starts from a known old allocation.  Iteratively processes the queue, marking allocations as old, adding their contained values (either stored values or phi inputs) to the queue. Stops when the queue is empty or when it reaches a node that is already Old.\",\n        \"parameters\": [\n          {\n            \"name\": \"old_alloc\",\n            \"type\": \"OpIndex\",\n            \"purpose\": \"The index of the old allocation to start the DFS from.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"OpIndex\",\n          \"Operation\",\n          \"AllocateOp\",\n          \"PhiOp\",\n          \"AllocationType\",\n          \"PushContainedValues\",\n          \"TryCast\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n// Performs a DFS from {old_alloc} and mark everything it finds as Old. The DFS\n// stops on already-Old nodes.\nvoid PretenuringPropagationAnalyzer::OldifySubgraph(OpIndex old_alloc) {\n  queue_.clear();\n  if (!PushContainedValues(old_alloc)) return;\n\n  while (!queue_.empty()) {\n    OpIndex idx = queue_.back();\n    queue_.pop_back();\n    Operation& op = input_graph_.Get(idx);\n    if (AllocateOp* alloc = op.TryCast<AllocateOp>()) {\n      if (alloc->type == AllocationType::kOld) continue;\n      alloc->type = AllocationType::kOld;\n      PushContainedValues(idx);\n    } else {\n      DCHECK(op.Is<PhiOp>());\n      if (old_phis_.find(idx) != old_phis_.end()) continue;\n      old_phis_.insert(idx);\n      PushContainedValues(idx);\n    }\n  }\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"PropagateAllocationTypes\",\n        \"parent\": \"PretenuringPropagationAnalyzer\",\n        \"about\": \"Iterates through the list of known old allocations and propagates the allocation type by calling OldifySubgraph for each.\",\n        \"logic\": \"For each old allocation, calls OldifySubgraph to perform the depth-first search and mark all reachable allocations and phis as Old.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"OpIndex\",\n          \"OldifySubgraph\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid PretenuringPropagationAnalyzer::PropagateAllocationTypes() {\n  for (OpIndex old_alloc : old_allocs_) {\n    OldifySubgraph(old_alloc);\n  }\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"BuildStoreInputGraph\",\n        \"parent\": \"PretenuringPropagationAnalyzer\",\n        \"about\": \"Builds a graph of store and phi relationships, used for propagation.\",\n        \"logic\": \"Iterates through all operations in the input graph.  For each StoreOp, AllocateOp, and PhiOp, calls the corresponding Process method to record the dependencies between operations. This builds the data structures necessary for the subsequent pretenuring propagation.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"Operation\",\n          \"StoreOp\",\n          \"AllocateOp\",\n          \"PhiOp\",\n          \"Opcode\",\n          \"ProcessStore\",\n          \"ProcessAllocate\",\n          \"ProcessPhi\",\n          \"ShouldSkipOperation\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid PretenuringPropagationAnalyzer::BuildStoreInputGraph() {\n  for (auto& op : input_graph_.AllOperations()) {\n    if (ShouldSkipOperation(op)) {\n      continue;\n    }\n    switch (op.opcode) {\n      case Opcode::kStore:\n        ProcessStore(op.Cast<StoreOp>());\n        break;\n      case Opcode::kAllocate:\n        ProcessAllocate(op.Cast<AllocateOp>());\n        break;\n      case Opcode::kPhi:\n        ProcessPhi(op.Cast<PhiOp>());\n        break;\n      default:\n        break;\n    }\n  }\n}\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"Run\",\n        \"parent\": \"PretenuringPropagationAnalyzer\",\n        \"about\": \"Runs the pretenuring propagation analysis.\",\n        \"logic\": \"First builds the store input graph by analyzing store and phi relationships. Then, propagates the allocation types (Young to Old) based on the built graph.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"BuildStoreInputGraph\",\n          \"PropagateAllocationTypes\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid PretenuringPropagationAnalyzer::Run() {\n  BuildStoreInputGraph();\n\n  PropagateAllocationTypes();\n}\n    ]]></code>\n  </func>\n</file>\n```"
}