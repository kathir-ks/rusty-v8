{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-origin-table.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 118, column 46",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-origin-table.h\",\n        \"file_name\": \"node-origin-table.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the NodeOrigin and NodeOriginTable classes for tracking the origin of nodes in the compiler graph, aiding debugging and optimization.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library and V8-specific headers for various functionalities like limits, compiler specifics, and node auxiliary data.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <limits>\n\n#include \"src/base/compiler-specific.h\"\n#include \"src/compiler/node-aux-data.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NodeOrigin\",\n            \"about\": \"Represents the origin of a node, including the phase and reducer that created it.\",\n            \"attributes\": [\n                {\n                    \"name\": \"phase_name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Name of the compiler phase.\"\n                },\n                {\n                    \"name\": \"reducer_name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Name of the reducer.\"\n                },\n                {\n                    \"name\": \"origin_kind_\",\n                    \"type\": \"OriginKind\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Kind of origin (Wasm, Graph, JS).\"\n                },\n                {\n                    \"name\": \"created_from_\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Node ID or bytecode offset from which the node was created.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass NodeOrigin {\n public:\n  enum OriginKind { kWasmBytecode, kGraphNode, kJSBytecode };\n  NodeOrigin(const char* phase_name, const char* reducer_name,\n             NodeId created_from)\n      : phase_name_(phase_name),\n        reducer_name_(reducer_name),\n        origin_kind_(kGraphNode),\n        created_from_(created_from) {}\n\n  NodeOrigin(const char* phase_name, const char* reducer_name,\n             OriginKind origin_kind, uint64_t created_from)\n      : phase_name_(phase_name),\n        reducer_name_(reducer_name),\n        origin_kind_(origin_kind),\n        created_from_(created_from) {}\n\n  NodeOrigin(const NodeOrigin& other) V8_NOEXCEPT = default;\n  NodeOrigin& operator=(const NodeOrigin& other) V8_NOEXCEPT = default;\n  static NodeOrigin Unknown() { return NodeOrigin(); }\n\n  bool IsKnown() { return created_from_ >= 0; }\n  int64_t created_from() const { return created_from_; }\n  const char* reducer_name() const { return reducer_name_; }\n  const char* phase_name() const { return phase_name_; }\n\n  OriginKind origin_kind() const { return origin_kind_; }\n\n  bool operator==(const NodeOrigin& o) const {\n    return reducer_name_ == o.reducer_name_ && created_from_ == o.created_from_;\n  }\n\n  void PrintJson(std::ostream& out) const;\n\n private:\n  NodeOrigin()\n      : phase_name_(\"\"),\n        reducer_name_(\"\"),\n        created_from_(std::numeric_limits<int64_t>::min()) {}\n  const char* phase_name_;\n  const char* reducer_name_;\n  OriginKind origin_kind_;\n  int64_t created_from_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Defines the inequality operator for NodeOrigin objects.\",\n            \"logic\": \"Delegates to the equality operator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"const NodeOrigin&\",\n                    \"purpose\": \"Left-hand side NodeOrigin.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"const NodeOrigin&\",\n                    \"purpose\": \"Right-hand side NodeOrigin.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the NodeOrigins are not equal, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ninline bool operator!=(const NodeOrigin& lhs, const NodeOrigin& rhs) {\n  return !(lhs == rhs);\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NodeOriginTable\",\n            \"extends\": \"NON_EXPORTED_BASE(ZoneObject)\",\n            \"about\": \"Table that stores the origin of each node in the graph.  Uses NodeAuxData for storage.\",\n            \"attributes\": [\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"TFGraph* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the graph.\"\n                },\n                {\n                    \"name\": \"decorator_\",\n                    \"type\": \"Decorator*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Decorator object for adding/removing node origin information.\"\n                },\n                {\n                    \"name\": \"current_origin_\",\n                    \"type\": \"NodeOrigin\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current NodeOrigin being tracked.\"\n                },\n                {\n                    \"name\": \"current_bytecode_position_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current bytecode position being tracked.\"\n                },\n                {\n                    \"name\": \"current_phase_name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The name of the current phase.\"\n                },\n                {\n                    \"name\": \"table_\",\n                    \"type\": \"NodeAuxData<NodeOrigin, UnknownNodeOrigin>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The table storing NodeOrigin information.\"\n                }\n            ],\n            \"dependencies\": [\n                \"NodeOrigin\",\n                \"ZoneObject\",\n                \"TFGraph\",\n                \"NodeAuxData\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE NodeOriginTable final\n    : public NON_EXPORTED_BASE(ZoneObject) {\n public:\n  class V8_NODISCARD Scope final {\n   public:\n    Scope(NodeOriginTable* origins, const char* reducer_name, Node* node)\n        : origins_(origins), prev_origin_(NodeOrigin::Unknown()) {\n      if (origins) {\n        prev_origin_ = origins->current_origin_;\n        origins->current_origin_ =\n            NodeOrigin(origins->current_phase_name_, reducer_name, node->id());\n      }\n    }\n\n    ~Scope() {\n      if (origins_) origins_->current_origin_ = prev_origin_;\n    }\n\n    Scope(const Scope&) = delete;\n    Scope& operator=(const Scope&) = delete;\n\n   private:\n    NodeOriginTable* const origins_;\n    NodeOrigin prev_origin_;\n  };\n\n  class V8_NODISCARD PhaseScope final {\n   public:\n    PhaseScope(NodeOriginTable* origins, const char* phase_name)\n        : origins_(origins) {\n      if (origins != nullptr) {\n        prev_phase_name_ = origins->current_phase_name_;\n        origins->current_phase_name_ =\n            phase_name == nullptr ? \"unnamed\" : phase_name;\n      }\n    }\n\n    ~PhaseScope() {\n      if (origins_) origins_->current_phase_name_ = prev_phase_name_;\n    }\n\n    PhaseScope(const PhaseScope&) = delete;\n    PhaseScope& operator=(const PhaseScope&) = delete;\n\n   private:\n    NodeOriginTable* const origins_;\n    const char* prev_phase_name_;\n  };\n\n  explicit NodeOriginTable(TFGraph* graph);\n  explicit NodeOriginTable(Zone* zone);\n  NodeOriginTable(const NodeOriginTable&) = delete;\n  NodeOriginTable& operator=(const NodeOriginTable&) = delete;\n\n  void AddDecorator();\n  void RemoveDecorator();\n\n  NodeOrigin GetNodeOrigin(Node* node) const;\n  NodeOrigin GetNodeOrigin(NodeId id) const;\n  void SetNodeOrigin(Node* node, const NodeOrigin& no);\n  void SetNodeOrigin(NodeId id, NodeId origin);\n  void SetNodeOrigin(NodeId id, NodeOrigin::OriginKind kind, NodeId origin);\n\n  void SetCurrentPosition(const NodeOrigin& no) { current_origin_ = no; }\n\n  void SetCurrentBytecodePosition(int offset) {\n    current_bytecode_position_ = offset;\n  }\n\n  int GetCurrentBytecodePosition() { return current_bytecode_position_; }\n\n  void PrintJson(std::ostream& os) const;\n\n private:\n  class Decorator;\n\n  TFGraph* const graph_;\n  Decorator* decorator_;\n  NodeOrigin current_origin_;\n  int current_bytecode_position_;\n\n  const char* current_phase_name_;\n  static NodeOrigin UnknownNodeOrigin(Zone* zone) {\n    return NodeOrigin::Unknown();\n  }\n  NodeAuxData<NodeOrigin, UnknownNodeOrigin> table_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Scope\",\n            \"about\": \"A helper class for tracking the origin of nodes within a specific reducer.\",\n            \"attributes\": [\n                {\n                    \"name\": \"origins_\",\n                    \"type\": \"NodeOriginTable* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the NodeOriginTable.\"\n                },\n                {\n                    \"name\": \"prev_origin_\",\n                    \"type\": \"NodeOrigin\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The previous NodeOrigin.\"\n                }\n            ],\n            \"dependencies\": [\n                \"NodeOriginTable\",\n                \"Node\",\n                \"NodeOrigin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class V8_NODISCARD Scope final {\n   public:\n    Scope(NodeOriginTable* origins, const char* reducer_name, Node* node)\n        : origins_(origins), prev_origin_(NodeOrigin::Unknown()) {\n      if (origins) {\n        prev_origin_ = origins->current_origin_;\n        origins->current_origin_ =\n            NodeOrigin(origins->current_phase_name_, reducer_name, node->id());\n      }\n    }\n\n    ~Scope() {\n      if (origins_) origins_->current_origin_ = prev_origin_;\n    }\n\n    Scope(const Scope&) = delete;\n    Scope& operator=(const Scope&) = delete;\n\n   private:\n    NodeOriginTable* const origins_;\n    NodeOrigin prev_origin_;\n  };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PhaseScope\",\n            \"about\": \"A helper class for tracking the current compiler phase.\",\n            \"attributes\": [\n                {\n                    \"name\": \"origins_\",\n                    \"type\": \"NodeOriginTable* const\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the NodeOriginTable.\"\n                },\n                {\n                    \"name\": \"prev_phase_name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The previous phase name.\"\n                }\n            ],\n            \"dependencies\": [\n                \"NodeOriginTable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class V8_NODISCARD PhaseScope final {\n   public:\n    PhaseScope(NodeOriginTable* origins, const char* phase_name)\n        : origins_(origins) {\n      if (origins != nullptr) {\n        prev_phase_name_ = origins->current_phase_name_;\n        origins->current_phase_name_ =\n            phase_name == nullptr ? \"unnamed\" : phase_name;\n      }\n    }\n\n    ~PhaseScope() {\n      if (origins_) origins_->current_phase_name_ = prev_phase_name_;\n    }\n\n    PhaseScope(const PhaseScope&) = delete;\n    PhaseScope& operator=(const PhaseScope&) = delete;\n\n   private:\n    NodeOriginTable* const origins_;\n    const char* prev_phase_name_;\n  };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ZoneObject\",\n                \"about\": \"Base class for objects allocated in a Zone.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class ZoneObject {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TFGraph\",\n                \"about\": \"Represents the Turbofan graph.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class TFGraph {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Node\",\n                \"about\": \"Represents a node in the Turbofan graph.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class Node {\n                public:\n                    NodeId id() const { return NodeId(); }\n                private:\n                    NodeId id_;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"NodeAuxData\",\n                \"about\": \"Auxiliary data associated with a Node\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T, typename F>\n                class NodeAuxData {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"type\",\n                \"name\": \"NodeId\",\n                \"about\": \"Represents ID of Node.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                typedef int NodeId;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Zone\",\n                \"about\": \"Memory allocation zone.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class Zone {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}