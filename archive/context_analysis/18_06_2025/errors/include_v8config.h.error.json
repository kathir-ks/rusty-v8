{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8config.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8config.h\",\n            \"file_name\": \"v8config.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Configuration header file for the V8 JavaScript engine. Defines various macros for OS, compiler, architecture detection, and feature detection.\"\n        }\n    </metadata>\n\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard memory header for std::unique_ptr, and platform specific headers for feature detection.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <memory>\n        ]]></code>\n    </imports>\n    \n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes platform-specific headers for operating system and compiler feature detection.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #if defined(__ANDROID__)\n            # include <sys/cdefs.h>\n            #elif defined(__APPLE__)\n            # include <TargetConditionals.h>\n            #elif defined(__linux__)\n            # include <features.h>\n            #elif defined(__MVS__)\n            # include \"zos-base.h\"\n            #endif\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"V8_GN_HEADER\",\n                \"about\": \"Placeholder for GN build system integration. Provides configuration from v8-gn.h if defined.\",\n                \"dependencies\": [\n                    \"v8-gn.h\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_GN_HEADER\n            #if !__has_include(\"v8-gn.h\")\n            #error Missing v8-gn.h. The configuration for v8 is missing from the include \\\n            path. Add it with -I<path> to the command line\n            #endif\n            #include \"v8-gn.h\"  // NOLINT(build/include_directory)\n            #endif\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_GLIBC_PREREQ\",\n                \"about\": \"Tests for the version of the GNU C library (or a compatible C library).\",\n                \"logic\": \"Compares the major and minor version numbers of the GNU C library against the specified values.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"major\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The major version number.\"\n                    },\n                    {\n                        \"name\": \"minor\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The minor version number.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"1 if the GNU C library version is greater than or equal to the specified version, 0 otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if defined(__GLIBC__) && defined(__GLIBC_MINOR__)\n            # define V8_GLIBC_PREREQ(major, minor)                                    \\\n                ((__GLIBC__ * 100 + __GLIBC_MINOR__) >= ((major) * 100 + (minor)))\n            #else\n            # define V8_GLIBC_PREREQ(major, minor) 0\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_GNUC_PREREQ\",\n                \"about\": \"Tests for the version of the GNU C++ compiler.\",\n                \"logic\": \"Compares the major, minor, and patchlevel version numbers of the GNU C++ compiler against the specified values.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"major\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The major version number.\"\n                    },\n                    {\n                        \"name\": \"minor\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The minor version number.\"\n                    },\n                    {\n                        \"name\": \"patchlevel\",\n                        \"type\": \"int\",\n                        \"purpose\": \"The patchlevel version number.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"1 if the GNU C++ compiler version is greater than or equal to the specified version, 0 otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)\n            # define V8_GNUC_PREREQ(major, minor, patchlevel)                         \\\n                ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) >=   \\\n                 ((major) * 10000 + (minor) * 100 + (patchlevel)))\n            #elif defined(__GNUC__) && defined(__GNUC_MINOR__)\n            # define V8_GNUC_PREREQ(major, minor, patchlevel)      \\\n                ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100) >=      \\\n                 ((major) * 10000 + (minor) * 100 + (patchlevel)))\n            #else\n            # define V8_GNUC_PREREQ(major, minor, patchlevel) 0\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"Operating system detection macros\",\n                \"about\": \"Macros that detect the operating system the code is being compiled on.\",\n                \"logic\": \"Uses preprocessor directives to check for the presence of specific macros defined by the compiler or build system to determine the operating system. Defines V8_OS_* macros and V8_OS_STRING.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"macros\",\n                    \"description\": \"Defines various V8_OS_* macros (e.g., V8_OS_LINUX, V8_OS_WIN) and V8_OS_STRING (e.g., 'linux', 'windows').\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if defined(__ANDROID__)\n            # define V8_OS_ANDROID 1\n            # define V8_OS_LINUX 1\n            # define V8_OS_POSIX 1\n            # define V8_OS_STRING \"android\"\n\n            #elif defined(__APPLE__)\n            # define V8_OS_POSIX 1\n            # define V8_OS_BSD 1\n            # define V8_OS_DARWIN 1\n            # if defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE\n            #  define V8_OS_IOS 1\n            #  define V8_OS_STRING \"ios\"\n            # else\n            #  define V8_OS_MACOS 1\n            #  define V8_OS_STRING \"macos\"\n            # endif  // defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE\n\n            #elif defined(__CYGWIN__)\n            # define V8_OS_CYGWIN 1\n            # define V8_OS_POSIX 1\n            # define V8_OS_STRING \"cygwin\"\n\n            #elif defined(__linux__)\n            # define V8_OS_LINUX 1\n            # define V8_OS_POSIX 1\n            # define V8_OS_STRING \"linux\"\n\n            #elif defined(__sun)\n            # define V8_OS_POSIX 1\n            # define V8_OS_SOLARIS 1\n            # define V8_OS_STRING \"sun\"\n\n            #elif defined(STARBOARD)\n            # define V8_OS_STARBOARD 1\n            # define V8_OS_STRING \"starboard\"\n\n            #elif defined(_AIX)\n            # define V8_OS_POSIX 1\n            # define V8_OS_AIX 1\n            # define V8_OS_STRING \"aix\"\n\n            #elif defined(__FreeBSD__)\n            # define V8_OS_BSD 1\n            # define V8_OS_FREEBSD 1\n            # define V8_OS_POSIX 1\n            # define V8_OS_STRING \"freebsd\"\n\n            #elif defined(__Fuchsia__)\n            # define V8_OS_FUCHSIA 1\n            # define V8_OS_POSIX 1\n            # define V8_OS_STRING \"fuchsia\"\n\n            #elif defined(__DragonFly__)\n            # define V8_OS_BSD 1\n            # define V8_OS_DRAGONFLYBSD 1\n            # define V8_OS_POSIX 1\n            # define V8_OS_STRING \"dragonflybsd\"\n\n            #elif defined(__NetBSD__)\n            # define V8_OS_BSD 1\n            # define V8_OS_NETBSD 1\n            # define V8_OS_POSIX 1\n            # define V8_OS_STRING \"netbsd\"\n\n            #elif defined(__OpenBSD__)\n            # define V8_OS_BSD 1\n            # define V8_OS_OPENBSD 1\n            # define V8_OS_POSIX 1\n            # define V8_OS_STRING \"openbsd\"\n\n            #elif defined(__QNXNTO__)\n            # define V8_OS_POSIX 1\n            # define V8_OS_QNX 1\n            # define V8_OS_STRING \"qnx\"\n\n            #elif defined(_WIN32)\n            # define V8_OS_WIN 1\n            # define V8_OS_STRING \"windows\"\n\n            #elif defined(__MVS__)\n            # define V8_OS_POSIX 1\n            # define V8_OS_ZOS 1\n            # define V8_OS_STRING \"zos\"\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"Target operating system detection macros\",\n                \"about\": \"Macros that detect the target operating system for cross-compilation.\",\n                \"logic\": \"Uses preprocessor directives to check for the presence of specific macros defined by the compiler or build system to determine the target operating system.  If V8_HAVE_TARGET_OS is defined, uses explicit target OS definitions.  Otherwise falls back to detected host OS values.  Defines V8_TARGET_OS_* macros and V8_TARGET_OS_STRING.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"macros\",\n                    \"description\": \"Defines various V8_TARGET_OS_* macros (e.g., V8_TARGET_OS_LINUX, V8_TARGET_OS_WIN) and V8_TARGET_OS_STRING (e.g., 'linux', 'windows').\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_HAVE_TARGET_OS\n\n            // The target OS is provided, just check that at least one known value is set.\n            # if !defined(V8_TARGET_OS_ANDROID) \\\n              && !defined(V8_TARGET_OS_FUCHSIA) \\\n              && !defined(V8_TARGET_OS_IOS) \\\n              && !defined(V8_TARGET_OS_LINUX) \\\n              && !defined(V8_TARGET_OS_MACOS) \\\n              && !defined(V8_TARGET_OS_WIN) \\\n              && !defined(V8_TARGET_OS_CHROMEOS)\n            #  error No known target OS defined.\n            # endif\n\n            #else  // V8_HAVE_TARGET_OS\n\n            # if defined(V8_TARGET_OS_ANDROID) \\\n              || defined(V8_TARGET_OS_FUCHSIA) \\\n              || defined(V8_TARGET_OS_IOS) \\\n              || defined(V8_TARGET_OS_LINUX) \\\n              || defined(V8_TARGET_OS_MACOS) \\\n              || defined(V8_TARGET_OS_WIN) \\\n              || defined(V8_TARGET_OS_CHROMEOS)\n            #  error A target OS is defined but V8_HAVE_TARGET_OS is unset.\n            # endif\n\n            // Fall back to the detected host OS.\n            #ifdef V8_OS_ANDROID\n            # define V8_TARGET_OS_ANDROID\n            #endif\n\n            #ifdef V8_OS_FUCHSIA\n            # define V8_TARGET_OS_FUCHSIA\n            #endif\n\n            #ifdef V8_OS_IOS\n            # define V8_TARGET_OS_IOS\n            #endif\n\n            #ifdef V8_OS_LINUX\n            # define V8_TARGET_OS_LINUX\n            #endif\n\n            #ifdef V8_OS_MACOS\n            # define V8_TARGET_OS_MACOS\n            #endif\n\n            #ifdef V8_OS_WIN\n            # define V8_TARGET_OS_WIN\n            #endif\n\n            #endif  // V8_HAVE_TARGET_OS\n\n            #if defined(V8_TARGET_OS_ANDROID)\n            # define V8_TARGET_OS_STRING \"android\"\n            #elif defined(V8_TARGET_OS_FUCHSIA)\n            # define V8_TARGET_OS_STRING \"fuchsia\"\n            #elif defined(V8_TARGET_OS_IOS)\n            # define V8_TARGET_OS_STRING \"ios\"\n            #elif defined(V8_TARGET_OS_LINUX)\n            # define V8_TARGET_OS_STRING \"linux\"\n            #elif defined(V8_TARGET_OS_MACOS)\n            # define V8_TARGET_OS_STRING \"macos\"\n            #elif defined(V8_TARGET_OS_WINDOWS)\n            # define V8_TARGET_OS_STRING \"windows\"\n            #else\n            # define V8_TARGET_OS_STRING \"unknown\"\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"C library detection macros\",\n                \"about\": \"Macros that detect the C library being used.\",\n                \"logic\": \"Uses preprocessor directives to check for the presence of specific macros defined by the compiler or build system to determine the C library. Defines V8_LIBC_* macros.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"macros\",\n                    \"description\": \"Defines various V8_LIBC_* macros (e.g., V8_LIBC_MSVCRT, V8_LIBC_GLIBC).\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if defined (_MSC_VER)\n            # define V8_LIBC_MSVCRT 1\n            #elif defined(__BIONIC__)\n            # define V8_LIBC_BIONIC 1\n            # define V8_LIBC_BSD 1\n            #elif defined(__UCLIBC__)\n            // Must test for UCLIBC before GLIBC, as UCLIBC pretends to be GLIBC.\n            # define V8_LIBC_UCLIBC 1\n            #elif defined(__GLIBC__) || defined(__GNU_LIBRARY__)\n            # define V8_LIBC_GLIBC 1\n            #else\n            # define V8_LIBC_BSD V8_OS_BSD\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"Compiler detection macros\",\n                \"about\": \"Macros that detect the compiler being used.\",\n                \"logic\": \"Uses preprocessor directives to check for the presence of specific macros defined by the compiler. Defines V8_CC_* macros and feature detection macros like V8_HAS_ATTRIBUTE_* and V8_HAS_BUILTIN_*.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"macros\",\n                    \"description\": \"Defines various V8_CC_* macros (e.g., V8_CC_GNU, V8_CC_MSVC) and feature detection macros.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if defined(__has_cpp_attribute)\n            #define V8_HAS_CPP_ATTRIBUTE(FEATURE) __has_cpp_attribute(FEATURE)\n            #else\n            #define V8_HAS_CPP_ATTRIBUTE(FEATURE) 0\n            #endif\n\n            #if defined(__clang__)\n\n            #if defined(__GNUC__)  // Clang in gcc mode.\n            # define V8_CC_GNU 1\n            #endif\n\n            # define V8_HAS_ATTRIBUTE_ALWAYS_INLINE (__has_attribute(always_inline))\n            # define V8_HAS_ATTRIBUTE_CONSTINIT \\\n                (__has_attribute(require_constant_initialization))\n            # define V8_HAS_ATTRIBUTE_CONST (__has_attribute(const))\n            # define V8_HAS_ATTRIBUTE_NONNULL (__has_attribute(nonnull))\n            # define V8_HAS_ATTRIBUTE_NOINLINE (__has_attribute(noinline))\n            # define V8_HAS_ATTRIBUTE_UNUSED (__has_attribute(unused))\n            # define V8_HAS_ATTRIBUTE_USED (__has_attribute(used))\n            # define V8_HAS_ATTRIBUTE_RETAIN (__has_attribute(retain))\n            # define V8_HAS_ATTRIBUTE_OPTNONE (__has_attribute(optnone))\n            // Support for the \"preserve_most\" attribute is limited:\n            // - 32-bit platforms do not implement it,\n            // - component builds fail because _dl_runtime_resolve clobbers registers,\n            // - we see crashes on arm64 on Windows (https://crbug.com/1409934), which can\n            //   hopefully be fixed in the future.\n            // Additionally, the initial implementation in clang <= 16 overwrote the return\n            // register(s) in the epilogue of a preserve_most function, so we only use\n            // preserve_most in clang >= 17 (see https://reviews.llvm.org/D143425).\n            #if (defined(_M_X64) || defined(__x86_64__)            /* x64 (everywhere) */  \\\n                 || ((defined(__AARCH64EL__) || defined(_M_ARM64)) /* arm64, but ... */    \\\n                     && !defined(_WIN32)))                         /* not on windows */    \\\n                 && !defined(COMPONENT_BUILD)                      /* no component build */\\\n                 && __clang_major__ >= 17                          /* clang >= 17 */\n            # define V8_HAS_ATTRIBUTE_PRESERVE_MOST (__has_attribute(preserve_most))\n            #endif\n            # define V8_HAS_ATTRIBUTE_VISIBILITY (__has_attribute(visibility))\n            # define V8_HAS_ATTRIBUTE_WARN_UNUSED_RESULT \\\n                (__has_attribute(warn_unused_result))\n            # define V8_HAS_ATTRIBUTE_WEAK (__has_attribute(weak))\n\n            # define V8_HAS_CPP_ATTRIBUTE_NODISCARD (V8_HAS_CPP_ATTRIBUTE(nodiscard))\n            #if defined(V8_CC_MSVC)\n            # define V8_HAS_CPP_ATTRIBUTE_NO_UNIQUE_ADDRESS       \\\n                (V8_HAS_CPP_ATTRIBUTE(msvc::no_unique_address) || \\\n                 V8_HAS_CPP_ATTRIBUTE(no_unique_address))\n            #else\n            # define V8_HAS_CPP_ATTRIBUTE_NO_UNIQUE_ADDRESS \\\n                (V8_HAS_CPP_ATTRIBUTE(no_unique_address))\n            #endif\n\n            # define V8_HAS_BUILTIN_ADD_OVERFLOW (__has_builtin(__builtin_add_overflow))\n            # define V8_HAS_BUILTIN_ASSUME (__has_builtin(__builtin_assume))\n            # define V8_HAS_BUILTIN_ASSUME_ALIGNED (__has_builtin(__builtin_assume_aligned))\n            # define V8_HAS_BUILTIN_BIT_CAST (__has_builtin(__builtin_bit_cast))\n            # define V8_HAS_BUILTIN_BSWAP16 (__has_builtin(__builtin_bswap16))\n            # define V8_HAS_BUILTIN_BSWAP32 (__has_builtin(__builtin_bswap32))\n            # define V8_HAS_BUILTIN_BSWAP64 (__has_builtin(__builtin_bswap64))\n            # define V8_HAS_BUILTIN_CLZ (__has_builtin(__builtin_clz))\n            # define V8_HAS_BUILTIN_CTZ (__has_builtin(__builtin_ctz))\n            # define V8_HAS_BUILTIN_EXPECT (__has_builtin(__builtin_expect))\n            # define V8_HAS_BUILTIN_FRAME_ADDRESS (__has_builtin(__builtin_frame_address))\n            # define V8_HAS_BUILTIN_MUL_OVERFLOW (__has_builtin(__builtin_mul_overflow))\n            # define V8_HAS_BUILTIN_POPCOUNT (__has_builtin(__builtin_popcount))\n            # define V8_HAS_BUILTIN_SADD_OVERFLOW (__has_builtin(__builtin_sadd_overflow))\n            # define V8_HAS_BUILTIN_SMUL_OVERFLOW (__has_builtin(__builtin_smul_overflow))\n            # define V8_HAS_BUILTIN_SSUB_OVERFLOW (__has_builtin(__builtin_ssub_overflow))\n            # define V8_HAS_BUILTIN_SUB_OVERFLOW (__has_builtin(__builtin_sub_overflow))\n            # define V8_HAS_BUILTIN_UADD_OVERFLOW (__has_builtin(__builtin_uadd_overflow))\n            # define V8_HAS_BUILTIN_UNREACHABLE (__has_builtin(__builtin_unreachable))\n\n            // Clang has no __has_feature for computed gotos.\n            // GCC doc: https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html\n            # define V8_HAS_COMPUTED_GOTO 1\n\n            #elif defined(__GNUC__)\n\n            # define V8_CC_GNU 1\n            # if defined(__INTEL_COMPILER)  // Intel C++ also masquerades as GCC 3.2.0\n            #  define V8_CC_INTEL 1\n            # endif\n            # if defined(__MINGW32__)\n            #  define V8_CC_MINGW32 1\n            # endif\n            # if defined(__MINGW64__)\n            #  define V8_CC_MINGW64 1\n            # endif\n            # define V8_CC_MINGW (V8_CC_MINGW32 || V8_CC_MINGW64)\n\n            // FYI: __has_builtin is only available with GCC 10 and later, so explicitly\n            // check GCC version numbers to enable features. TODO(leszeks): Merge feature\n            // enabling for GCC 10 and later into the Clang section above, and leave this\n            // section for GCC 9 and earlier.\n\n            // always_inline is available in gcc 4.0 but not very reliable until 4.4.\n            // Works around \"sorry, unimplemented: inlining failed\" build errors with\n            // older compilers.\n            # define V8_HAS_ATTRIBUTE_ALWAYS_INLINE 1\n            # define V8_HAS_ATTRIBUTE_NOINLINE 1\n            # define V8_HAS_ATTRIBUTE_UNUSED 1\n            # define V8_HAS_ATTRIBUTE_VISIBILITY 1\n            # define V8_HAS_ATTRIBUTE_WARN_UNUSED_RESULT (!V8_CC_INTEL)\n            # define V8_HAS_ATTRIBUTE_WEAK 1\n\n            // [[nodiscard]] does not work together with with\n            // __attribute__((visibility(\"\"))) on GCC 7.4 which is why there is no define\n            // for V8_HAS_CPP_ATTRIBUTE_NODISCARD. See https://crbug.com/v8/11707.\n\n            # define V8_HAS_BUILTIN_ASSUME_ALIGNED 1\n            # if __GNUC__ >= 11\n            #  define V8_HAS_BUILTIN_BIT_CAST 1\n            # endif\n            # define V8_HAS_BUILTIN_CLZ 1\n            # define V8_HAS_BUILTIN_CTZ 1\n            # define V8_HAS_BUILTIN_EXPECT 1\n            # define V8_HAS_BUILTIN_FRAME_ADDRESS 1\n            # define V8_HAS_BUILTIN_POPCOUNT 1\n            # define V8_HAS_BUILTIN_UNREACHABLE 1\n\n            // GCC doc: https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html\n            #define V8_HAS_COMPUTED_GOTO 1\n\n            #endif\n\n            #if defined(_MSC_VER)\n            # define V8_CC_MSVC 1\n\n            # define V8_HAS_DECLSPEC_NOINLINE 1\n            # define V8_HAS_DECLSPEC_SELECTANY 1\n\n            # define V8_HAS___FORCEINLINE 1\n\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_INLINE\",\n                \"about\": \"Macro for inline function declaration based on compiler and build configuration.\",\n                \"logic\": \"Chooses the appropriate inlining mechanism based on compiler support for `__attribute__((always_inline))` or `__forceinline`, falling back to a regular `inline` declaration. In debug mode, no forced inlining is used.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"keyword\",\n                    \"description\": \"Expands to `inline __attribute__((always_inline))`, `__forceinline`, or `inline`, depending on the compiler and build settings.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if !defined(DEBUG) && V8_HAS_ATTRIBUTE_ALWAYS_INLINE\n            # define V8_INLINE inline __attribute__((always_inline))\n            #elif !defined(DEBUG) && V8_HAS___FORCEINLINE\n            # define V8_INLINE __forceinline\n            #else\n            # define V8_INLINE inline\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_INLINE_STATEMENT\",\n                \"about\": \"Macro for inlining a function call within a statement, specific to Clang.\",\n                \"logic\": \"Uses the `[[clang::always_inline]]` attribute to force inlining of a function call in a statement when using Clang. In debug mode, no forced inlining is used.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"attribute\",\n                    \"description\": \"Expands to `[[clang::always_inline]]` when using Clang in a non-debug build, otherwise expands to nothing.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if !defined(DEBUG) && defined(__clang__) && V8_HAS_ATTRIBUTE_ALWAYS_INLINE\n            # define V8_INLINE_STATEMENT [[clang::always_inline]]\n            #else\n            # define V8_INLINE_STATEMENT\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_ASSUME\",\n                \"about\": \"Macro for expressing assumptions to the compiler, which may aid optimization.\",\n                \"logic\": \"Uses `__builtin_assume` or `__builtin_unreachable` to inform the compiler of conditions that are expected to be true. In debug mode, `DCHECK` is also used to verify the assumption at runtime.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"condition\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"The condition that is assumed to be true.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"compiler directive\",\n                    \"description\": \"Expands to `__builtin_assume(condition)` or `__builtin_unreachable()` depending on compiler support. In debug builds it also evaluates a `DCHECK(condition)`\"\n                },\n                \"dependencies\": [\n                    \"DCHECK\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_HAS_BUILTIN_ASSUME\n            #ifdef DEBUG\n            // In debug mode, check assumptions in addition to adding annotations.\n            // This helps GCC (and maybe other compilers) figure out that certain\n            // situations are unreachable.\n            # define V8_ASSUME(condition)    \\\n              do {                           \\\n                DCHECK(condition);           \\\n                __builtin_assume(condition); \\\n              } while (false)\n            #else  // DEBUG\n            # define V8_ASSUME __builtin_assume\n            #endif  // DEBUG\n            #elif V8_HAS_BUILTIN_UNREACHABLE\n            # define V8_ASSUME(condition)                  \\\n              do {                                         \\\n                DCHECK(condition);                         \\\n                if (!(condition)) __builtin_unreachable(); \\\n              } while (false)\n            #else\n            # define V8_ASSUME USE\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_ASSUME_ALIGNED\",\n                \"about\": \"Macro to inform the compiler about the alignment of a pointer.\",\n                \"logic\": \"Uses `std::assume_aligned` (C++20) or `__builtin_assume_aligned` if available. Otherwise, it does nothing.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"ptr\",\n                        \"type\": \"void*\",\n                        \"purpose\": \"The pointer whose alignment is being assumed.\"\n                    },\n                    {\n                        \"name\": \"alignment\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The assumed alignment of the pointer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"pointer\",\n                    \"description\": \"Returns the input pointer, potentially with alignment information for the compiler.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if __cplusplus >= 202002L && defined(__cpp_lib_assume_aligned) && !V8_CC_MSVC\n            # define V8_ASSUME_ALIGNED(ptr, alignment) \\\n              std::assume_aligned<(alignment)>(ptr)\n            #elif V8_HAS_BUILTIN_ASSUME_ALIGNED\n            # define V8_ASSUME_ALIGNED(ptr, alignment) \\\n              __builtin_assume_aligned((ptr), (alignment))\n            #else\n            # define V8_ASSUME_ALIGNED(ptr, alignment) (ptr)\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_CONST\",\n                \"about\": \"Macro for marking functions whose return values don't change across calls.\",\n                \"logic\": \"Adds the `__attribute__((const))` attribute if supported by the compiler.  This allows the compiler to hoist and fold multiple calls to the function together.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"attribute\",\n                    \"description\": \"Expands to `__attribute__((const))` if supported by the compiler, otherwise expands to nothing.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_HAS_ATTRIBUTE_CONST\n            # define V8_CONST __attribute__((const))\n            #else\n            # define V8_CONST\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_CONSTINIT\",\n                \"about\": \"Macro for marking a declaration as requiring constant initialization.\",\n                \"logic\": \"Adds the `__attribute__((require_constant_initialization))` attribute if supported by the compiler.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"attribute\",\n                    \"description\": \"Expands to `__attribute__((require_constant_initialization))` if supported by the compiler, otherwise expands to nothing.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_HAS_ATTRIBUTE_CONSTINIT\n            # define V8_CONSTINIT __attribute__((require_constant_initialization))\n            #else\n            # define V8_CONSTINIT\n            #endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"V8_NONNULL\",\n                \"about\": \"Macro for marking specific function arguments as non-null.\",\n                \"logic\": \"Adds the `__attribute__((nonnull(__VA_ARGS__)))` attribute if supported by the compiler.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"attribute\",\n                    \"description\": \"Expands to `__attribute__((nonnull(__VA_ARGS__)))` if supported by the compiler, otherwise expands to nothing.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_HAS_ATTRIBUTE"
}