{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/machine-graph-verifier.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/machine-graph-verifier.cc\",\n        \"file_name\": \"machine-graph-verifier.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Verifies the machine graph for correctness, ensuring that node representations are consistent with their usages.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for compiler components, data structures, and zone management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/machine-graph-verifier.h\"\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/schedule.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MachineRepresentationInferrer\",\n            \"about\": \"Infers the machine representation of each node in the graph based on its opcode and usage.\",\n            \"attributes\": [\n                {\n                    \"name\": \"schedule_\",\n                    \"type\": \"Schedule const*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The schedule of basic blocks in the graph.\"\n                },\n                {\n                    \"name\": \"linkage_\",\n                    \"type\": \"Linkage*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Provides information about the function's linkage, including parameter and return types.\"\n                },\n                {\n                    \"name\": \"representation_vector_\",\n                    \"type\": \"ZoneVector<MachineRepresentation>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the inferred machine representation for each node in the graph.\"\n                },\n                {\n                    \"name\": \"current_block_\",\n                    \"type\": \"BasicBlock*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The basic block that is currently being processed\"\n                }\n            ],\n            \"dependencies\": [\n                \"Schedule\",\n                \"TFGraph\",\n                \"Linkage\",\n                \"Zone\",\n                \"ZoneVector\",\n                \"BasicBlock\",\n                \"Node\",\n                \"CallDescriptor\",\n                \"MachineRepresentation\",\n                \"IrOpcode\",\n                \"NodeProperties\",\n                \"MachineType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass MachineRepresentationInferrer {\n public:\n  MachineRepresentationInferrer(Schedule const* schedule, TFGraph const* graph,\n                                Linkage* linkage, Zone* zone)\n      : schedule_(schedule),\n        linkage_(linkage),\n        representation_vector_(graph->NodeCount(), MachineRepresentation::kNone,\n                               zone) {\n    Run();\n  }\n\n  CallDescriptor* call_descriptor() const {\n    return linkage_->GetIncomingDescriptor();\n  }\n\n  MachineRepresentation GetRepresentation(Node const* node) const {\n    return representation_vector_.at(node->id());\n  }\n\n private:\n  MachineRepresentation PromoteRepresentation(MachineRepresentation rep) {\n    switch (rep) {\n      case MachineRepresentation::kWord8:\n      case MachineRepresentation::kWord16:\n      case MachineRepresentation::kWord32:\n        return MachineRepresentation::kWord32;\n      case MachineRepresentation::kSandboxedPointer:\n        // A sandboxed pointer is a Word64 that uses an encoded representation\n        // when stored on the heap.\n        return MachineRepresentation::kWord64;\n      default:\n        break;\n    }\n    return rep;\n  }\n\n  void Run() {\n    auto blocks = schedule_->all_blocks();\n    for (BasicBlock* block : *blocks) {\n      current_block_ = block;\n      for (size_t i = 0; i <= block->NodeCount(); ++i) {\n        Node const* node =\n            i < block->NodeCount() ? block->NodeAt(i) : block->control_input();\n        if (node == nullptr) {\n          DCHECK_EQ(block->NodeCount(), i);\n          break;\n        }\n        switch (node->opcode()) {\n          case IrOpcode::kParameter:\n            representation_vector_[node->id()] =\n                linkage_->GetParameterType(ParameterIndexOf(node->op()))\n                    .representation();\n            break;\n          case IrOpcode::kReturn: {\n            representation_vector_[node->id()] = PromoteRepresentation(\n                linkage_->GetReturnType().representation());\n            break;\n          }\n          case IrOpcode::kProjection: {\n            representation_vector_[node->id()] =\n                NodeProperties::GetProjectionType(node);\n          } break;\n          case IrOpcode::kTypedStateValues:\n            representation_vector_[node->id()] = MachineRepresentation::kNone;\n            break;\n          case IrOpcode::kWord32AtomicLoad:\n          case IrOpcode::kWord64AtomicLoad:\n            representation_vector_[node->id()] =\n                PromoteRepresentation(AtomicLoadParametersOf(node->op())\n                                          .representation()\n                                          .representation());\n            break;\n          case IrOpcode::kLoad:\n          case IrOpcode::kLoadImmutable:\n          case IrOpcode::kProtectedLoad:\n          case IrOpcode::kLoadTrapOnNull:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                LoadRepresentationOf(node->op()).representation());\n            break;\n          case IrOpcode::kLoadFramePointer:\n          case IrOpcode::kLoadParentFramePointer:\n          case IrOpcode::kStackSlot:\n          case IrOpcode::kLoadRootRegister:\n#if V8_ENABLE_WEBASSEMBLY\n          case IrOpcode::kLoadStackPointer:\n#endif  // V8_ENABLE_WEBASSEMBLY\n            representation_vector_[node->id()] =\n                MachineType::PointerRepresentation();\n            break;\n          case IrOpcode::kUnalignedLoad:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                LoadRepresentationOf(node->op()).representation());\n            break;\n          case IrOpcode::kPhi:\n            representation_vector_[node->id()] =\n                PhiRepresentationOf(node->op());\n            break;\n          case IrOpcode::kCall: {\n            auto call_descriptor = CallDescriptorOf(node->op());\n            if (call_descriptor->ReturnCount() > 0) {\n              representation_vector_[node->id()] =\n                  call_descriptor->GetReturnType(0).representation();\n            } else {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kTagged;\n            }\n            break;\n          }\n          case IrOpcode::kWord32AtomicStore:\n          case IrOpcode::kWord64AtomicStore:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                AtomicStoreParametersOf(node->op()).representation());\n            break;\n          case IrOpcode::kWord32AtomicPairLoad:\n          case IrOpcode::kWord32AtomicPairStore:\n          case IrOpcode::kWord32AtomicPairAdd:\n          case IrOpcode::kWord32AtomicPairSub:\n          case IrOpcode::kWord32AtomicPairAnd:\n          case IrOpcode::kWord32AtomicPairOr:\n          case IrOpcode::kWord32AtomicPairXor:\n          case IrOpcode::kWord32AtomicPairExchange:\n          case IrOpcode::kWord32AtomicPairCompareExchange:\n            representation_vector_[node->id()] = MachineRepresentation::kWord32;\n            break;\n          case IrOpcode::kWord32AtomicExchange:\n          case IrOpcode::kWord32AtomicCompareExchange:\n          case IrOpcode::kWord32AtomicAdd:\n          case IrOpcode::kWord32AtomicSub:\n          case IrOpcode::kWord32AtomicAnd:\n          case IrOpcode::kWord32AtomicOr:\n          case IrOpcode::kWord32AtomicXor:\n          case IrOpcode::kWord64AtomicExchange:\n          case IrOpcode::kWord64AtomicCompareExchange:\n          case IrOpcode::kWord64AtomicAdd:\n          case IrOpcode::kWord64AtomicSub:\n          case IrOpcode::kWord64AtomicAnd:\n          case IrOpcode::kWord64AtomicOr:\n          case IrOpcode::kWord64AtomicXor:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                AtomicOpType(node->op()).representation());\n            break;\n          case IrOpcode::kStore:\n          case IrOpcode::kProtectedStore:\n          case IrOpcode::kStoreTrapOnNull:\n          case IrOpcode::kStoreIndirectPointer:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                StoreRepresentationOf(node->op()).representation());\n            break;\n          case IrOpcode::kUnalignedStore:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                UnalignedStoreRepresentationOf(node->op()));\n            break;\n          case IrOpcode::kHeapConstant:\n            representation_vector_[node->id()] =\n                MachineRepresentation::kTaggedPointer;\n            break;\n          case IrOpcode::kNumberConstant:\n          case IrOpcode::kChangeBitToTagged:\n          case IrOpcode::kIfException:\n          case IrOpcode::kOsrValue:\n          case IrOpcode::kChangeInt32ToTagged:\n          case IrOpcode::kChangeUint32ToTagged:\n          case IrOpcode::kBitcastWordToTagged:\n          case IrOpcode::kTaggedIndexConstant:\n            representation_vector_[node->id()] = MachineRepresentation::kTagged;\n            break;\n          case IrOpcode::kCompressedHeapConstant:\n            representation_vector_[node->id()] =\n                MachineRepresentation::kCompressedPointer;\n            break;\n          case IrOpcode::kExternalConstant:\n            representation_vector_[node->id()] =\n                MachineType::PointerRepresentation();\n            break;\n          case IrOpcode::kBitcastTaggedToWord:\n          case IrOpcode::kBitcastTaggedToWordForTagAndSmiBits:\n            representation_vector_[node->id()] =\n                MachineType::PointerRepresentation();\n            break;\n          case IrOpcode::kBitcastWordToTaggedSigned:\n            representation_vector_[node->id()] =\n                MachineRepresentation::kTaggedSigned;\n            break;\n          case IrOpcode::kWord32Equal:\n          case IrOpcode::kInt32LessThan:\n          case IrOpcode::kInt32LessThanOrEqual:\n          case IrOpcode::kUint32LessThan:\n          case IrOpcode::kUint32LessThanOrEqual:\n          case IrOpcode::kWord64Equal:\n          case IrOpcode::kInt64LessThan:\n          case IrOpcode::kInt64LessThanOrEqual:\n          case IrOpcode::kUint64LessThan:\n          case IrOpcode::kUint64LessThanOrEqual:\n          case IrOpcode::kFloat32Equal:\n          case IrOpcode::kFloat32LessThan:\n          case IrOpcode::kFloat32LessThanOrEqual:\n          case IrOpcode::kFloat64Equal:\n          case IrOpcode::kFloat64LessThan:\n          case IrOpcode::kFloat64LessThanOrEqual:\n          case IrOpcode::kChangeTaggedToBit:\n          case IrOpcode::kStackPointerGreaterThan:\n            representation_vector_[node->id()] = MachineRepresentation::kBit;\n            break;\n#define LABEL(opcode) case IrOpcode::k##opcode:\n          case IrOpcode::kTruncateInt64ToInt32:\n          case IrOpcode::kTruncateFloat32ToInt32:\n          case IrOpcode::kTruncateFloat32ToUint32:\n          case IrOpcode::kBitcastFloat32ToInt32:\n#if V8_ENABLE_WEBASSEMBLY\n          case IrOpcode::kI32x4ExtractLane:\n          case IrOpcode::kI16x8ExtractLaneU:\n          case IrOpcode::kI16x8ExtractLaneS:\n          case IrOpcode::kI8x16ExtractLaneU:\n          case IrOpcode::kI8x16ExtractLaneS:\n          case IrOpcode::kI8x16BitMask:\n#endif  // V8_ENABLE_WEBASSEMBLY\n          case IrOpcode::kInt32Constant:\n          case IrOpcode::kRelocatableInt32Constant:\n          case IrOpcode::kTruncateFloat64ToWord32:\n          case IrOpcode::kTruncateFloat64ToUint32:\n          case IrOpcode::kChangeFloat64ToInt32:\n          case IrOpcode::kChangeFloat64ToUint32:\n          case IrOpcode::kRoundFloat64ToInt32:\n          case IrOpcode::kFloat64ExtractLowWord32:\n          case IrOpcode::kFloat64ExtractHighWord32:\n          case IrOpcode::kWord32Popcnt:\n            MACHINE_UNOP_32_LIST(LABEL)\n            MACHINE_BINOP_32_LIST(LABEL) {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kWord32;\n            }\n            break;\n          case IrOpcode::kChangeInt32ToInt64:\n          case IrOpcode::kChangeUint32ToUint64:\n          case IrOpcode::kBitcastWord32ToWord64:\n          case IrOpcode::kInt64Constant:\n          case IrOpcode::kRelocatableInt64Constant:\n          case IrOpcode::kBitcastFloat64ToInt64:\n          case IrOpcode::kChangeFloat64ToInt64:\n          case IrOpcode::kChangeFloat64ToUint64:\n          case IrOpcode::kTruncateFloat64ToInt64:\n          case IrOpcode::kWord64Popcnt:\n          case IrOpcode::kWord64Ctz:\n          case IrOpcode::kWord64Clz:\n            MACHINE_BINOP_64_LIST(LABEL) {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kWord64;\n            }\n            break;\n          case IrOpcode::kRoundInt32ToFloat32:\n          case IrOpcode::kRoundUint32ToFloat32:\n          case IrOpcode::kRoundInt64ToFloat32:\n          case IrOpcode::kRoundUint64ToFloat32:\n          case IrOpcode::kBitcastInt32ToFloat32:\n          case IrOpcode::kFloat32Constant:\n          case IrOpcode::kTruncateFloat64ToFloat32:\n            MACHINE_FLOAT32_BINOP_LIST(LABEL)\n            MACHINE_FLOAT32_UNOP_LIST(LABEL) {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kFloat32;\n            }\n            break;\n          case IrOpcode::kRoundInt64ToFloat64:\n          case IrOpcode::kRoundUint64ToFloat64:\n          case IrOpcode::kBitcastInt64ToFloat64:\n          case IrOpcode::kChangeFloat32ToFloat64:\n          case IrOpcode::kChangeInt32ToFloat64:\n          case IrOpcode::kChangeUint32ToFloat64:\n          case IrOpcode::kFloat64InsertLowWord32:\n          case IrOpcode::kFloat64InsertHighWord32:\n          case IrOpcode::kFloat64Constant:\n          case IrOpcode::kFloat64SilenceNaN:\n            MACHINE_FLOAT64_BINOP_LIST(LABEL)\n            MACHINE_FLOAT64_UNOP_LIST(LABEL) {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kFloat64;\n            }\n            break;\n#if V8_ENABLE_WEBASSEMBLY\n          case IrOpcode::kI32x4ReplaceLane:\n          case IrOpcode::kI32x4Splat:\n          case IrOpcode::kI8x16Splat:\n          case IrOpcode::kI8x16Eq:\n            representation_vector_[node->id()] =\n                MachineRepresentation::kSimd128;\n            break;\n#endif  // V8_ENABLE_WEBASSEMBLY\n#undef LABEL\n          default:\n            break;\n        }\n      }\n    }\n  }\n\n  Schedule const* const schedule_;\n  Linkage const* const linkage_;\n  ZoneVector<MachineRepresentation> representation_vector_;\n  BasicBlock* current_block_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PromoteRepresentation\",\n            \"parent\": \"MachineRepresentationInferrer\",\n            \"about\": \"Promotes certain machine representations to wider types.\",\n            \"logic\": \"Specifically, promotes Word8, Word16, and Word32 to Word32, and SandboxedPointer to Word64. Other types are returned unchanged.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rep\",\n                    \"type\": \"MachineRepresentation\",\n                    \"purpose\": \"The machine representation to potentially promote.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MachineRepresentation\",\n                \"description\": \"The promoted or original machine representation.\"\n            },\n            \"dependencies\": [\n                \"MachineRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  MachineRepresentation PromoteRepresentation(MachineRepresentation rep) {\n    switch (rep) {\n      case MachineRepresentation::kWord8:\n      case MachineRepresentation::kWord16:\n      case MachineRepresentation::kWord32:\n        return MachineRepresentation::kWord32;\n      case MachineRepresentation::kSandboxedPointer:\n        // A sandboxed pointer is a Word64 that uses an encoded representation\n        // when stored on the heap.\n        return MachineRepresentation::kWord64;\n      default:\n        break;\n    }\n    return rep;\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Run\",\n            \"parent\": \"MachineRepresentationInferrer\",\n            \"about\": \"Main loop of the inference process, iterating through basic blocks and nodes to determine the machine representation of each node.\",\n            \"logic\": \"Iterates through each basic block in the schedule. For each node, it determines the machine representation based on the node's opcode and properties, updating the representation_vector_.  Handles special cases for different opcodes like Parameters, Returns, Loads, Stores, Phis, and Calls.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Schedule\",\n                \"BasicBlock\",\n                \"Node\",\n                \"IrOpcode\",\n                \"Linkage\",\n                \"MachineRepresentation\",\n                \"NodeProperties\",\n                \"CallDescriptor\",\n                \"MachineType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void Run() {\n    auto blocks = schedule_->all_blocks();\n    for (BasicBlock* block : *blocks) {\n      current_block_ = block;\n      for (size_t i = 0; i <= block->NodeCount(); ++i) {\n        Node const* node =\n            i < block->NodeCount() ? block->NodeAt(i) : block->control_input();\n        if (node == nullptr) {\n          DCHECK_EQ(block->NodeCount(), i);\n          break;\n        }\n        switch (node->opcode()) {\n          case IrOpcode::kParameter:\n            representation_vector_[node->id()] =\n                linkage_->GetParameterType(ParameterIndexOf(node->op()))\n                    .representation();\n            break;\n          case IrOpcode::kReturn: {\n            representation_vector_[node->id()] = PromoteRepresentation(\n                linkage_->GetReturnType().representation());\n            break;\n          }\n          case IrOpcode::kProjection: {\n            representation_vector_[node->id()] =\n                NodeProperties::GetProjectionType(node);\n          } break;\n          case IrOpcode::kTypedStateValues:\n            representation_vector_[node->id()] = MachineRepresentation::kNone;\n            break;\n          case IrOpcode::kWord32AtomicLoad:\n          case IrOpcode::kWord64AtomicLoad:\n            representation_vector_[node->id()] =\n                PromoteRepresentation(AtomicLoadParametersOf(node->op())\n                                          .representation()\n                                          .representation());\n            break;\n          case IrOpcode::kLoad:\n          case IrOpcode::kLoadImmutable:\n          case IrOpcode::kProtectedLoad:\n          case IrOpcode::kLoadTrapOnNull:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                LoadRepresentationOf(node->op()).representation());\n            break;\n          case IrOpcode::kLoadFramePointer:\n          case IrOpcode::kLoadParentFramePointer:\n          case IrOpcode::kStackSlot:\n          case IrOpcode::kLoadRootRegister:\n#if V8_ENABLE_WEBASSEMBLY\n          case IrOpcode::kLoadStackPointer:\n#endif  // V8_ENABLE_WEBASSEMBLY\n            representation_vector_[node->id()] =\n                MachineType::PointerRepresentation();\n            break;\n          case IrOpcode::kUnalignedLoad:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                LoadRepresentationOf(node->op()).representation());\n            break;\n          case IrOpcode::kPhi:\n            representation_vector_[node->id()] =\n                PhiRepresentationOf(node->op());\n            break;\n          case IrOpcode::kCall: {\n            auto call_descriptor = CallDescriptorOf(node->op());\n            if (call_descriptor->ReturnCount() > 0) {\n              representation_vector_[node->id()] =\n                  call_descriptor->GetReturnType(0).representation();\n            } else {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kTagged;\n            }\n            break;\n          }\n          case IrOpcode::kWord32AtomicStore:\n          case IrOpcode::kWord64AtomicStore:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                AtomicStoreParametersOf(node->op()).representation());\n            break;\n          case IrOpcode::kWord32AtomicPairLoad:\n          case IrOpcode::kWord32AtomicPairStore:\n          case IrOpcode::kWord32AtomicPairAdd:\n          case IrOpcode::kWord32AtomicPairSub:\n          case IrOpcode::kWord32AtomicPairAnd:\n          case IrOpcode::kWord32AtomicPairOr:\n          case IrOpcode::kWord32AtomicPairXor:\n          case IrOpcode::kWord32AtomicPairExchange:\n          case IrOpcode::kWord32AtomicPairCompareExchange:\n            representation_vector_[node->id()] = MachineRepresentation::kWord32;\n            break;\n          case IrOpcode::kWord32AtomicExchange:\n          case IrOpcode::kWord32AtomicCompareExchange:\n          case IrOpcode::kWord32AtomicAdd:\n          case IrOpcode::kWord32AtomicSub:\n          case IrOpcode::kWord32AtomicAnd:\n          case IrOpcode::kWord32AtomicOr:\n          case IrOpcode::kWord32AtomicXor:\n          case IrOpcode::kWord64AtomicExchange:\n          case IrOpcode::kWord64AtomicCompareExchange:\n          case IrOpcode::kWord64AtomicAdd:\n          case IrOpcode::kWord64AtomicSub:\n          case IrOpcode::kWord64AtomicAnd:\n          case IrOpcode::kWord64AtomicOr:\n          case IrOpcode::kWord64AtomicXor:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                AtomicOpType(node->op()).representation());\n            break;\n          case IrOpcode::kStore:\n          case IrOpcode::kProtectedStore:\n          case IrOpcode::kStoreTrapOnNull:\n          case IrOpcode::kStoreIndirectPointer:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                StoreRepresentationOf(node->op()).representation());\n            break;\n          case IrOpcode::kUnalignedStore:\n            representation_vector_[node->id()] = PromoteRepresentation(\n                UnalignedStoreRepresentationOf(node->op()));\n            break;\n          case IrOpcode::kHeapConstant:\n            representation_vector_[node->id()] =\n                MachineRepresentation::kTaggedPointer;\n            break;\n          case IrOpcode::kNumberConstant:\n          case IrOpcode::kChangeBitToTagged:\n          case IrOpcode::kIfException:\n          case IrOpcode::kOsrValue:\n          case IrOpcode::kChangeInt32ToTagged:\n          case IrOpcode::kChangeUint32ToTagged:\n          case IrOpcode::kBitcastWordToTagged:\n          case IrOpcode::kTaggedIndexConstant:\n            representation_vector_[node->id()] = MachineRepresentation::kTagged;\n            break;\n          case IrOpcode::kCompressedHeapConstant:\n            representation_vector_[node->id()] =\n                MachineRepresentation::kCompressedPointer;\n            break;\n          case IrOpcode::kExternalConstant:\n            representation_vector_[node->id()] =\n                MachineType::PointerRepresentation();\n            break;\n          case IrOpcode::kBitcastTaggedToWord:\n          case IrOpcode::kBitcastTaggedToWordForTagAndSmiBits:\n            representation_vector_[node->id()] =\n                MachineType::PointerRepresentation();\n            break;\n          case IrOpcode::kBitcastWordToTaggedSigned:\n            representation_vector_[node->id()] =\n                MachineRepresentation::kTaggedSigned;\n            break;\n          case IrOpcode::kWord32Equal:\n          case IrOpcode::kInt32LessThan:\n          case IrOpcode::kInt32LessThanOrEqual:\n          case IrOpcode::kUint32LessThan:\n          case IrOpcode::kUint32LessThanOrEqual:\n          case IrOpcode::kWord64Equal:\n          case IrOpcode::kInt64LessThan:\n          case IrOpcode::kInt64LessThanOrEqual:\n          case IrOpcode::kUint64LessThan:\n          case IrOpcode::kUint64LessThanOrEqual:\n          case IrOpcode::kFloat32Equal:\n          case IrOpcode::kFloat32LessThan:\n          case IrOpcode::kFloat32LessThanOrEqual:\n          case IrOpcode::kFloat64Equal:\n          case IrOpcode::kFloat64LessThan:\n          case IrOpcode::kFloat64LessThanOrEqual:\n          case IrOpcode::kChangeTaggedToBit:\n          case IrOpcode::kStackPointerGreaterThan:\n            representation_vector_[node->id()] = MachineRepresentation::kBit;\n            break;\n#define LABEL(opcode) case IrOpcode::k##opcode:\n          case IrOpcode::kTruncateInt64ToInt32:\n          case IrOpcode::kTruncateFloat32ToInt32:\n          case IrOpcode::kTruncateFloat32ToUint32:\n          case IrOpcode::kBitcastFloat32ToInt32:\n#if V8_ENABLE_WEBASSEMBLY\n          case IrOpcode::kI32x4ExtractLane:\n          case IrOpcode::kI16x8ExtractLaneU:\n          case IrOpcode::kI16x8ExtractLaneS:\n          case IrOpcode::kI8x16ExtractLaneU:\n          case IrOpcode::kI8x16ExtractLaneS:\n          case IrOpcode::kI8x16BitMask:\n#endif  // V8_ENABLE_WEBASSEMBLY\n          case IrOpcode::kInt32Constant:\n          case IrOpcode::kRelocatableInt32Constant:\n          case IrOpcode::kTruncateFloat64ToWord32:\n          case IrOpcode::kTruncateFloat64ToUint32:\n          case IrOpcode::kChangeFloat64ToInt32:\n          case IrOpcode::kChangeFloat64ToUint32:\n          case IrOpcode::kRoundFloat64ToInt32:\n          case IrOpcode::kFloat64ExtractLowWord32:\n          case IrOpcode::kFloat64ExtractHighWord32:\n          case IrOpcode::kWord32Popcnt:\n            MACHINE_UNOP_32_LIST(LABEL)\n            MACHINE_BINOP_32_LIST(LABEL) {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kWord32;\n            }\n            break;\n          case IrOpcode::kChangeInt32ToInt64:\n          case IrOpcode::kChangeUint32ToUint64:\n          case IrOpcode::kBitcastWord32ToWord64:\n          case IrOpcode::kInt64Constant:\n          case IrOpcode::kRelocatableInt64Constant:\n          case IrOpcode::kBitcastFloat64ToInt64:\n          case IrOpcode::kChangeFloat64ToInt64:\n          case IrOpcode::kChangeFloat64ToUint64:\n          case IrOpcode::kTruncateFloat64ToInt64:\n          case IrOpcode::kWord64Popcnt:\n          case IrOpcode::kWord64Ctz:\n          case IrOpcode::kWord64Clz:\n            MACHINE_BINOP_64_LIST(LABEL) {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kWord64;\n            }\n            break;\n          case IrOpcode::kRoundInt32ToFloat32:\n          case IrOpcode::kRoundUint32ToFloat32:\n          case IrOpcode::kRoundInt64ToFloat32:\n          case IrOpcode::kRoundUint64ToFloat32:\n          case IrOpcode::kBitcastInt32ToFloat32:\n          case IrOpcode::kFloat32Constant:\n          case IrOpcode::kTruncateFloat64ToFloat32:\n            MACHINE_FLOAT32_BINOP_LIST(LABEL)\n            MACHINE_FLOAT32_UNOP_LIST(LABEL) {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kFloat32;\n            }\n            break;\n          case IrOpcode::kRoundInt64ToFloat64:\n          case IrOpcode::kRoundUint64ToFloat64:\n          case IrOpcode::kBitcastInt64ToFloat64:\n          case IrOpcode::kChangeFloat32ToFloat64:\n          case IrOpcode::kChangeInt32ToFloat64:\n          case IrOpcode::kChangeUint32ToFloat64:\n          case IrOpcode::kFloat64InsertLowWord32:\n          case IrOpcode::kFloat64InsertHighWord32:\n          case IrOpcode::kFloat64Constant:\n          case IrOpcode::kFloat64SilenceNaN:\n            MACHINE_FLOAT64_BINOP_LIST(LABEL)\n            MACHINE_FLOAT64_UNOP_LIST(LABEL) {\n              representation_vector_[node->id()] =\n                  MachineRepresentation::kFloat64;\n            }\n            break;\n#if V8_ENABLE_WEBASSEMBLY\n          case IrOpcode::kI32x4ReplaceLane:\n          case IrOpcode::kI32x4Splat:\n          case IrOpcode::kI8x16Splat:\n          case IrOpcode::kI8x16Eq:\n            representation_vector_[node->id()] =\n                MachineRepresentation::kSimd128;\n            break;\n#endif  // V8_ENABLE_WEBASSEMBLY\n#undef LABEL\n          default:\n            break;\n        }\n      }\n    }\n  }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MachineRepresentationChecker\",\n            \"about\": \"Checks that the inferred machine representations are consistent with the expected types for each node's inputs.\",\n            \"attributes\": [\n                {\n                    \"name\": \"schedule_\",\n                    \"type\": \"Schedule const*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The schedule of basic blocks in the graph.\"\n                },\n                {\n                    \"name\": \"inferrer_\",\n                    \"type\": \"MachineRepresentationInferrer const*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The inferrer used to obtain the machine representations of nodes.\"\n                },\n                {\n                    \"name\": \"is_stub_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the graph being checked is part of a stub.\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The name of the graph being checked (for debugging purposes).\"\n                },\n                {\n                    \"name\": \"current_block_\",\n                    \"type\": \"BasicBlock*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The basic block that is currently being processed.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Schedule\",\n                \"MachineRepresentationInferrer\",\n                \"BasicBlock\",\n                \"Node\",\n                \"IrOpcode\",\n                \"CallDescriptor\",\n                \"MachineRepresentation\",\n                \"MachineType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass MachineRepresentationChecker {\n public:\n  MachineRepresentationChecker(\n      Schedule const* const schedule,\n      MachineRepresentationInferrer const* const inferrer, bool is_stub,"
}