{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/torque-parser.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/torque-parser.cc\",\n            \"file_name\": \"torque-parser.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Parses Torque source files and builds the AST (Abstract Syntax Tree).\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and Torque-specific headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/torque-parser.h\"\n\n#include <algorithm>\n#include <cctype>\n#include <optional>\n#include <set>\n#include <stdexcept>\n#include <unordered_map>\n\n#include \"include/v8config.h\"\n#include \"src/common/globals.h\"\n#include \"src/flags/flags.h\"\n#include \"src/torque/ast.h\"\n#include \"src/torque/constants.h\"\n#include \"src/torque/declarations.h\"\n#include \"src/torque/earley-parser.h\"\n#include \"src/torque/global-context.h\"\n#include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BuildFlags\",\n                \"extends\": \"base::ContextualClass<BuildFlags>\",\n                \"about\": \"Manages build flags used in Torque compilation.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"build_flags_\",\n                        \"type\": \"std::unordered_map<std::string, bool>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the build flags and their corresponding boolean values.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"V8_EXTERNAL_CODE_SPACE_BOOL\",\n                    \"TargetArchitecture\",\n                    \"V8_EXPERIMENTAL_UNDEFINED_DOUBLE_BOOL\",\n                    \"V8_INTL_SUPPORT\",\n                    \"V8_ENABLE_SWISS_NAME_DICTIONARY_BOOL\",\n                    \"V8_ENABLE_JAVASCRIPT_PROMISE_HOOKS\",\n                    \"V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\",\n                    \"V8_SCRIPTORMODULE_LEGACY_LIFETIME\",\n                    \"V8_ENABLE_WEBASSEMBLY\",\n                    \"V8_ENABLE_SANDBOX\",\n                    \"V8_ENABLE_LEAPTIERING\",\n                    \"DEBUG_BOOL\",\n                    \"V8_ENABLE_DRUMBRAKE\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass BuildFlags : public base::ContextualClass<BuildFlags> {\n public:\n  BuildFlags() {\n    build_flags_[\"V8_EXTERNAL_CODE_SPACE\"] = V8_EXTERNAL_CODE_SPACE_BOOL;\n    build_flags_[\"TAGGED_SIZE_8_BYTES\"] = TargetArchitecture::TaggedSize() == 8;\n    build_flags_[\"V8_ENABLE_EXPERIMENTAL_UNDEFINED_DOUBLE\"] =\n        V8_EXPERIMENTAL_UNDEFINED_DOUBLE_BOOL;\n#ifdef V8_INTL_SUPPORT\n    build_flags_[\"V8_INTL_SUPPORT\"] = true;\n#else\n    build_flags_[\"V8_INTL_SUPPORT\"] = false;\n#endif\n    build_flags_[\"V8_ENABLE_SWISS_NAME_DICTIONARY\"] =\n        V8_ENABLE_SWISS_NAME_DICTIONARY_BOOL;\n#ifdef V8_ENABLE_JAVASCRIPT_PROMISE_HOOKS\n    build_flags_[\"V8_ENABLE_JAVASCRIPT_PROMISE_HOOKS\"] = true;\n#else\n    build_flags_[\"V8_ENABLE_JAVASCRIPT_PROMISE_HOOKS\"] = false;\n#endif\n#ifdef V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\n    build_flags_[\"V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\"] = true;\n#else\n    build_flags_[\"V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA\"] = false;\n#endif\n    build_flags_[\"TRUE_FOR_TESTING\"] = true;\n    build_flags_[\"FALSE_FOR_TESTING\"] = false;\n#ifdef V8_SCRIPTORMODULE_LEGACY_LIFETIME\n    build_flags_[\"V8_SCRIPTORMODULE_LEGACY_LIFETIME\"] = true;\n#else\n    build_flags_[\"V8_SCRIPTORMODULE_LEGACY_LIFETIME\"] = false;\n#endif\n#ifdef V8_ENABLE_WEBASSEMBLY\n    build_flags_[\"V8_ENABLE_WEBASSEMBLY\"] = true;\n    build_flags_[\"WASM_CODE_POINTER_NEEDS_PADDING\"] =\n        TargetArchitecture::TaggedSize() == 8;\n#else\n    build_flags_[\"V8_ENABLE_WEBASSEMBLY\"] = false;\n#endif\n    build_flags_[\"V8_ENABLE_SANDBOX\"] = V8_ENABLE_SANDBOX_BOOL;\n    build_flags_[\"V8_ENABLE_LEAPTIERING\"] = V8_ENABLE_LEAPTIERING_BOOL;\n    build_flags_[\"V8_ENABLE_LEAPTIERING_TAGGED_SIZE_8_BYTES\"] =\n        V8_ENABLE_LEAPTIERING_BOOL && build_flags_[\"TAGGED_SIZE_8_BYTES\"];\n    build_flags_[\"DEBUG\"] = DEBUG_BOOL;\n#ifdef V8_ENABLE_DRUMBRAKE\n    build_flags_[\"V8_ENABLE_DRUMBRAKE\"] = true;\n#else\n    build_flags_[\"V8_ENABLE_DRUMBRAKE\"] = false;\n#endif\n  }\n  static bool GetFlag(const std::string& name, const char* production) {\n    auto it = Get().build_flags_.find(name);\n    if (it == Get().build_flags_.end()) {\n      ReportError(\"Unknown flag used in \", production, \": \", name,\n                  \". Please add it to the list in BuildFlags.\");\n    }\n    return it->second;\n  }\n\n private:\n  std::unordered_map<std::string, bool> build_flags_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"NamingConventionError\",\n                \"about\": \"Reports a lint error if a name does not follow the specified naming convention.\",\n                \"logic\": \"Formats a lint message and reports it using ReportError.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The type of the element (e.g., 'class', 'variable').\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The name of the element that is being checked.\"\n                    },\n                    {\n                        \"name\": \"convention\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The naming convention that should be followed (e.g., 'UpperCamelCase').\"\n                    },\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"SourcePosition\",\n                        \"purpose\": \"The source code position of the element.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Lint\",\n                    \"CurrentSourcePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid NamingConventionError(const std::string& type, const std::string& name,\n                           const std::string& convention,\n                           SourcePosition pos = CurrentSourcePosition::Get()) {\n  Lint(type, \" \\\"\", name, \"\\\" does not follow \\\"\", convention,\n       \"\\\" naming convention.\")\n      .Position(pos);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"NamingConventionError\",\n                \"about\": \"Reports a lint error if an Identifier's value does not follow the specified naming convention.\",\n                \"logic\": \"Delegates to the other NamingConventionError function, extracting the identifier's value and position.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The type of the element (e.g., 'class', 'variable').\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const Identifier*\",\n                        \"purpose\": \"The Identifier of the element that is being checked.\"\n                    },\n                    {\n                        \"name\": \"convention\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The naming convention that should be followed (e.g., 'UpperCamelCase').\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NamingConventionError\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid NamingConventionError(const std::string& type, const Identifier* name,\n                           const std::string& convention) {\n  NamingConventionError(type, name->value, convention, name->pos);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"LintGenericParameters\",\n                \"about\": \"Checks that generic parameters follow the UpperCamelCase naming convention.\",\n                \"logic\": \"Iterates through the generic parameters and reports a lint error if any parameter's name does not follow UpperCamelCase.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"parameters\",\n                        \"type\": \"const GenericParameters&\",\n                        \"purpose\": \"The list of generic parameters to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IsUpperCamelCase\",\n                    \"NamingConventionError\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid LintGenericParameters(const GenericParameters& parameters) {\n  for (auto parameter : parameters) {\n    if (!IsUpperCamelCase(parameter.name->value)) {\n      NamingConventionError(\"Generic parameter\", parameter.name,\n                            \"UpperCamelCase\");\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ConcatList\",\n                \"about\": \"Concatenates a list of lists into a single list.\",\n                \"logic\": \"Iterates through the list of lists and inserts all elements into a result list.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"Parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The concatenated list.\"\n                }\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> ConcatList(ParseResultIterator* child_results) {\n  auto list_of_lists =\n      child_results->NextAs<std::vector<std::vector<Declaration*>>>();\n  std::vector<Declaration*> result;\n  for (auto& list : list_of_lists) {\n    result.insert(result.end(), list.begin(), list.end());\n  }\n  return ParseResult{std::move(result)};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"CheckNotDeferredStatement\",\n                \"about\": \"Checks if a statement is a BlockStatement with 'deferred' set to true, and issues a lint warning if so.\",\n                \"logic\": \"Casts the statement to a BlockStatement and checks the 'deferred' flag. If both are true, issues a lint warning that 'deferred' has no effect.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"statement\",\n                        \"type\": \"Statement*\",\n                        \"purpose\": \"The statement to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"BlockStatement\",\n                    \"Lint\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid CheckNotDeferredStatement(Statement* statement) {\n  CurrentSourcePosition::Scope source_position(statement->pos);\n  if (BlockStatement* block = BlockStatement::DynamicCast(statement)) {\n    if (block->deferred) {\n      Lint(\n          \"cannot use deferred with a statement block here, it will have no \"\n          \"effect\");\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"AddConstexpr\",\n                \"about\": \"Adds 'constexpr' prefix to basic type expression name.\",\n                \"logic\": \"Creates a new BasicTypeExpression with the name prefixed with CONSTEXPR_TYPE_PREFIX\",\n                \"parameters\": [\n                    {\n                        \"name\": \"type\",\n                        \"type\": \"TypeExpression*\",\n                        \"purpose\": \"Type expression to convert.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"TypeExpression*\",\n                    \"description\": \"A new type expression with constexpr prefix.\"\n                },\n                \"dependencies\": [\n                    \"BasicTypeExpression\",\n                    \"CONSTEXPR_TYPE_PREFIX\",\n                    \"MakeNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nTypeExpression* AddConstexpr(TypeExpression* type) {\n  BasicTypeExpression* basic = BasicTypeExpression::DynamicCast(type);\n  if (!basic) Error(\"Unsupported extends clause.\").Throw();\n  return MakeNode<BasicTypeExpression>(\n      basic->namespace_qualification,\n      MakeNode<Identifier>(CONSTEXPR_TYPE_PREFIX + basic->name->value),\n      basic->generic_arguments);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeCall\",\n                \"about\": \"Constructs a CallExpression or CallMethodExpression node.\",\n                \"logic\": \"Builds try-label expressions to handle labels in otherwise statements. Creates a CallExpression or CallMethodExpression based on the presence of a target.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"callee\",\n                        \"type\": \"IdentifierExpression*\",\n                        \"purpose\": \"The function to call.\"\n                    },\n                    {\n                        \"name\": \"target\",\n                        \"type\": \"std::optional<Expression*>\",\n                        \"purpose\": \"The target of the method call (optional).\"\n                    },\n                    {\n                        \"name\": \"arguments\",\n                        \"type\": \"std::vector<Expression*>\",\n                        \"purpose\": \"Arguments to the call.\"\n                    },\n                    {\n                        \"name\": \"otherwise\",\n                        \"type\": \"const std::vector<Statement*>&\",\n                        \"purpose\": \"List of statements executed if the call reaches a specified label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Expression*\",\n                    \"description\": \"The constructed call expression.\"\n                },\n                \"dependencies\": [\n                    \"CallExpression\",\n                    \"CallMethodExpression\",\n                    \"IdentifierExpression\",\n                    \"TryLabelExpression\",\n                    \"TryHandler\",\n                    \"MakeNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nExpression* MakeCall(IdentifierExpression* callee,\n                     std::optional<Expression*> target,\n                     std::vector<Expression*> arguments,\n                     const std::vector<Statement*>& otherwise) {\n  std::vector<Identifier*> labels;\n\n  // All IdentifierExpressions are treated as label names and can be directly\n  // used as labels identifiers. All other statements in a call's otherwise\n  // must create intermediate Labels for the otherwise's statement code.\n  size_t label_id_count = 0;\n  std::vector<TryHandler*> temp_labels;\n  for (auto* statement : otherwise) {\n    if (auto* e = ExpressionStatement::DynamicCast(statement)) {\n      if (auto* id = IdentifierExpression::DynamicCast(e->expression)) {\n        if (!id->generic_arguments.empty()) {\n          ReportError(\"An otherwise label cannot have generic parameters\");\n        }\n        labels.push_back(id->name);\n        continue;\n      }\n    }\n    auto label_name = std::string(\"__label\") + std::to_string(label_id_count++);\n    auto label_id = MakeNode<Identifier>(label_name);\n    label_id->pos = SourcePosition::Invalid();\n    labels.push_back(label_id);\n    auto* handler =\n        MakeNode<TryHandler>(TryHandler::HandlerKind::kLabel, label_id,\n                             ParameterList::Empty(), statement);\n    temp_labels.push_back(handler);\n  }\n\n  // Create nested try-label expression for all of the temporary Labels that\n  // were created.\n  Expression* result = nullptr;\n  if (target) {\n    result = MakeNode<CallMethodExpression>(\n        *target, callee, std::move(arguments), std::move(labels));\n  } else {\n    result = MakeNode<CallExpression>(callee, std::move(arguments),\n                                      std::move(labels));\n  }\n\n  for (auto* label : temp_labels) {\n    result = MakeNode<TryLabelExpression>(result, label);\n  }\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeCall\",\n                \"about\": \"Overload for Constructing a CallExpression or CallMethodExpression node.\",\n                \"logic\": \"Builds try-label expressions to handle labels in otherwise statements. Creates a CallExpression or CallMethodExpression based on the presence of a target.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"callee\",\n                        \"type\": \"Identifier*\",\n                        \"purpose\": \"The function to call.\"\n                    },\n                                        {\n                        \"name\": \"generic_arguments\",\n                        \"type\": \"const std::vector<TypeExpression*>&\",\n                        \"purpose\": \"Generic type arguments.\"\n                    },\n                    {\n                        \"name\": \"arguments\",\n                        \"type\": \"std::vector<Expression*>\",\n                        \"purpose\": \"Arguments to the call.\"\n                    },\n                    {\n                        \"name\": \"otherwise\",\n                        \"type\": \"const std::vector<Statement*>&\",\n                        \"purpose\": \"List of statements executed if the call reaches a specified label.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Expression*\",\n                    \"description\": \"The constructed call expression.\"\n                },\n                \"dependencies\": [\n                    \"MakeNode\",\n                    \"IdentifierExpression\",\n                    \"MakeCall\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nExpression* MakeCall(Identifier* callee,\n                     const std::vector<TypeExpression*>& generic_arguments,\n                     const std::vector<Expression*>& arguments,\n                     const std::vector<Statement*>& otherwise) {\n  return MakeCall(MakeNode<IdentifierExpression>(callee, generic_arguments),\n                  std::nullopt, arguments, otherwise);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeCall\",\n                \"about\": \"Makes a call expression from a parse result iterator.\",\n                \"logic\": \"Extracts the callee, arguments, and otherwise statements from the parse result iterator and calls the main MakeCall function.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"The parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The resulting parse result.\"\n                },\n                \"dependencies\": [\n                    \"IdentifierExpression\",\n                    \"MakeCall\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> MakeCall(ParseResultIterator* child_results) {\n  auto callee = child_results->NextAs<Expression*>();\n  auto args = child_results->NextAs<std::vector<Expression*>>();\n  auto otherwise = child_results->NextAs<std::vector<Statement*>>();\n  IdentifierExpression* target = IdentifierExpression::cast(callee);\n  return ParseResult{\n      MakeCall(target, std::nullopt, std::move(args), otherwise)};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeMethodCall\",\n                \"about\": \"Makes a method call expression from a parse result iterator.\",\n                \"logic\": \"Extracts the 'this' argument, callee identifier, arguments, and otherwise statements from the parse result iterator and calls the main MakeCall function with the appropriate target.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"The parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The resulting parse result.\"\n                },\n                \"dependencies\": [\n                    \"MakeNode\",\n                    \"IdentifierExpression\",\n                    \"MakeCall\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> MakeMethodCall(ParseResultIterator* child_results) {\n  auto this_arg = child_results->NextAs<Expression*>();\n  auto callee = child_results->NextAs<Identifier*>();\n  auto args = child_results->NextAs<std::vector<Expression*>>();\n  auto otherwise = child_results->NextAs<std::vector<Statement*>>();\n  return ParseResult{MakeCall(MakeNode<IdentifierExpression>(callee), this_arg,\n                              std::move(args), otherwise)};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeNewExpression\",\n                \"about\": \"Constructs a NewExpression node.\",\n                \"logic\": \"Extracts the pretenured flag, clear_padding flag, type expression and initializers. Creates a NewExpression.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"The parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The resulting parse result.\"\n                },\n                \"dependencies\": [\n                    \"NewExpression\",\n                    \"MakeNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> MakeNewExpression(\n    ParseResultIterator* child_results) {\n  bool pretenured = child_results->NextAs<bool>();\n  bool clear_padding = child_results->NextAs<bool>();\n\n  auto type = child_results->NextAs<TypeExpression*>();\n  auto initializers = child_results->NextAs<std::vector<NameAndExpression>>();\n\n  Expression* result = MakeNode<NewExpression>(type, std::move(initializers),\n                                               pretenured, clear_padding);\n  return ParseResult{result};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeBinaryOperator\",\n                \"about\": \"Constructs a CallExpression for a binary operator.\",\n                \"logic\": \"Extracts the left operand, operator identifier, and right operand, then calls MakeCall to create a call expression for the operator.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"The parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The resulting parse result.\"\n                },\n                \"dependencies\": [\n                    \"MakeCall\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> MakeBinaryOperator(\n    ParseResultIterator* child_results) {\n  auto left = child_results->NextAs<Expression*>();\n  auto op = child_results->NextAs<Identifier*>();\n  auto right = child_results->NextAs<Expression*>();\n  return ParseResult{MakeCall(op, TypeList{},\n                              std::vector<Expression*>{left, right},\n                              std::vector<Statement*>{})};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeIntrinsicCallExpression\",\n                \"about\": \"Constructs an IntrinsicCallExpression node.\",\n                \"logic\": \"Extracts the callee identifier, generic arguments, and arguments. Creates an IntrinsicCallExpression.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"The parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The resulting parse result.\"\n                },\n                \"dependencies\": [\n                    \"IntrinsicCallExpression\",\n                    \"MakeNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> MakeIntrinsicCallExpression(\n    ParseResultIterator* child_results) {\n  auto callee = child_results->NextAs<Identifier*>();\n  auto generic_arguments =\n      child_results->NextAs<std::vector<TypeExpression*>>();\n  auto args = child_results->NextAs<std::vector<Expression*>>();\n  Expression* result = MakeNode<IntrinsicCallExpression>(\n      callee, std::move(generic_arguments), std::move(args));\n  return ParseResult{result};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeUnaryOperator\",\n                \"about\": \"Constructs a CallExpression for a unary operator.\",\n                \"logic\": \"Extracts the operator identifier and the operand expression, then calls MakeCall to create a call expression for the operator.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"The parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The resulting parse result.\"\n                },\n                \"dependencies\": [\n                    \"MakeCall\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> MakeUnaryOperator(\n    ParseResultIterator* child_results) {\n  auto op = child_results->NextAs<Identifier*>();\n  auto e = child_results->NextAs<Expression*>();\n  return ParseResult{MakeCall(op, TypeList{}, std::vector<Expression*>{e},\n                              std::vector<Statement*>{})};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeSpreadExpression\",\n                \"about\": \"Constructs a SpreadExpression node.\",\n                \"logic\": \"Extracts the expression to be spread. Creates a SpreadExpression.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"The parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The resulting parse result.\"\n                },\n                \"dependencies\": [\n                    \"SpreadExpression\",\n                    \"MakeNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> MakeSpreadExpression(\n    ParseResultIterator* child_results) {\n  auto spreadee = child_results->NextAs<Expression*>();\n  Expression* result = MakeNode<SpreadExpression>(spreadee);\n  return ParseResult{result};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeImplicitParameterList\",\n                \"about\": \"Constructs a struct to hold the information about implicit parameters.\",\n                \"logic\": \"Extracts the kind and parameters. Creates a struct representing the implicit parameter list.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"The parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The resulting parse result.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::optional<ParseResult> MakeImplicitParameterList(\n    ParseResultIterator* child_results) {\n  auto kind = child_results->NextAs<Identifier*>();\n  auto parameters = child_results->NextAs<std::vector<NameAndTypeExpression>>();\n  return ParseResult{ImplicitParameters{kind, std::move(parameters)}};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"AddParameter\",\n                \"about\": \"Adds a parameter to a ParameterList, performing naming convention checks.\",\n                \"logic\": \"Checks the naming convention of the parameter name and adds the name and type to the provided ParameterList.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"parameter_list\",\n                        \"type\": \"ParameterList*\",\n                        \"purpose\": \"The parameter list to add to.\"\n                    },\n                    {\n                        \"name\": \"param\",\n                        \"type\": \"const NameAndTypeExpression&\",\n                        \"purpose\": \"The parameter to add.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"IsLowerCamelCase\",\n                    \"NamingConventionError\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid AddParameter(ParameterList* parameter_list,\n                  const NameAndTypeExpression& param) {\n  if (!IsLowerCamelCase(param.name->value)) {\n    NamingConventionError(\"Parameter\", param.name, \"lowerCamelCase\");\n  }\n  parameter_list->names.push_back(param.name);\n  parameter_list->types.push_back(param.type);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeParameterList\",\n                \"about\": \"Constructs a ParameterList node from different types of parameters. Template argument toggles parameters being optional\",\n                \"logic\": \"Creates ParameterList and extracts/sets the arguments, including those passed implicitly\",\n                \"parameters\": [\n                    {\n                        \"name\": \"child_results\",\n                        \"type\": \"ParseResultIterator*\",\n                        \"purpose\": \"The parse result iterator.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::optional<ParseResult>\",\n                    \"description\": \"The resulting parse result.\"\n                },\n                \"dependencies\": [\n                    \"ImplicitParameters\",\n                    \"AddParameter\",\n                    \"NameAndTypeExpression\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <bool has_varargs, bool has_explicit_parameter_names>\nstd::optional<ParseResult> MakeParameterList(\n    ParseResultIterator* child_results) {\n  auto implicit_params =\n      child_results->NextAs<std::optional<ImplicitParameters>>();\n  ParameterList result;\n  result.has_varargs = has_varargs;\n  result.implicit_count = 0;\n  result.implicit_kind = ImplicitKind::kNoImplicit;\n  if (implicit_params) {\n    result.implicit_count = implicit_params->parameters.size();\n    if (implicit_params->kind->value == \"implicit\") {\n      result.implicit_kind = ImplicitKind::kImplicit;\n    } else {\n      DCHECK_EQ(implicit_params->kind->value, \"js-implicit\");\n      result.implicit_kind = ImplicitKind::kJSImplicit;\n    }\n    result.implicit_kind_pos = implicit_params->kind->pos;\n    for (NameAndTypeExpression& implicit_param : implicit_params->parameters) {\n      AddParameter(&result, implicit_param);\n    }\n  }\n  if (has_explicit_parameter_names) {\n    auto explicit_params =\n        child_results->NextAs<std::vector<NameAndTypeExpression>>();\n    std::string arguments_variable = \"\";\n    if (has_varargs) {\n      arguments_variable = child_results->NextAs<std::string>();\n    }\n    for (NameAndTypeExpression& param : explicit_params) {\n      AddParameter(&result, param);\n    }\n    result.arguments_variable = arguments_variable;\n  } else {\n    auto explicit_types = child"
}