{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/baseline-compiler.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/baseline-compiler.cc\",\n        \"file_name\": \"baseline-compiler.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the BaselineCompiler class, which generates baseline code from bytecode for the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for compiler implementation, data structures, and architecture-specific code.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/baseline/baseline-compiler.h\"\n\n#include <algorithm>\n#include <optional>\n#include <type_traits>\n\n#include \"src/base/bits.h\"\n#include \"src/baseline/baseline-assembler-inl.h\"\n#include \"src/baseline/baseline-assembler.h\"\n#include \"src/builtins/builtins-constructor.h\"\n#include \"src/builtins/builtins-descriptors.h\"\n#include \"src/builtins/builtins.h\"\n#include \"src/codegen/assembler.h\"\n#include \"src/codegen/compiler.h\"\n#include \"src/codegen/interface-descriptors-inl.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/codegen/macro-assembler-inl.h\"\n#include \"src/common/globals.h\"\n#include \"src/execution/frame-constants.h\"\n#include \"src/heap/local-factory-inl.h\"\n#include \"src/interpreter/bytecode-array-iterator.h\"\n#include \"src/interpreter/bytecode-flags-and-tokens.h\"\n#include \"src/logging/runtime-call-stats-scope.h\"\n#include \"src/objects/code.h\"\n#include \"src/objects/heap-object.h\"\n#include \"src/objects/instance-type.h\"\n#include \"src/objects/literal-objects-inl.h\"\n#include \"src/objects/shared-function-info-inl.h\"\n#include \"src/roots/roots.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include architecture-specific baseline compiler implementations based on target architecture.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#if V8_TARGET_ARCH_X64\n#include \"src/baseline/x64/baseline-compiler-x64-inl.h\"\n#elif V8_TARGET_ARCH_ARM64\n#include \"src/baseline/arm64/baseline-compiler-arm64-inl.h\"\n#elif V8_TARGET_ARCH_IA32\n#include \"src/baseline/ia32/baseline-compiler-ia32-inl.h\"\n#elif V8_TARGET_ARCH_ARM\n#include \"src/baseline/arm/baseline-compiler-arm-inl.h\"\n#elif V8_TARGET_ARCH_PPC64\n#include \"src/baseline/ppc/baseline-compiler-ppc-inl.h\"\n#elif V8_TARGET_ARCH_S390X\n#include \"src/baseline/s390/baseline-compiler-s390-inl.h\"\n#elif V8_TARGET_ARCH_RISCV64\n#include \"src/baseline/riscv/baseline-compiler-riscv-inl.h\"\n#elif V8_TARGET_ARCH_RISCV32\n#include \"src/baseline/riscv/baseline-compiler-riscv-inl.h\"\n#elif V8_TARGET_ARCH_MIPS64\n#include \"src/baseline/mips64/baseline-compiler-mips64-inl.h\"\n#elif V8_TARGET_ARCH_LOONG64\n#include \"src/baseline/loong64/baseline-compiler-loong64-inl.h\"\n#else\n#error Unsupported target architecture.\n#endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BytecodeOffsetTableBuilder\",\n            \"about\": \"Builds a table that maps bytecode offsets to instruction offsets within the generated baseline code.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename IsolateT>\nHandle<TrustedByteArray> BytecodeOffsetTableBuilder::ToBytecodeOffsetTable(\n    IsolateT* isolate) {\n  if (bytes_.empty()) return isolate->factory()->empty_trusted_byte_array();\n  Handle<TrustedByteArray> table =\n      isolate->factory()->NewTrustedByteArray(static_cast<int>(bytes_.size()));\n  MemCopy(table->begin(), bytes_.data(), bytes_.size());\n  return table;\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Clobbers\",\n            \"about\": \"DEBUG function that checks if Register target is clobbered by argument\",\n            \"logic\": \"The functions are used during DEBUG builds to verify that registers are not being overwritten unexpectedly during argument setup for builtin calls.\",\n            \"parameters\": [\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"target register\"\n                },\n                {\n                    \"name\": \"reg\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"register to check\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"true if target is clobbered by reg, else false\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n#ifdef DEBUG\nbool Clobbers(Register target, Register reg) { return target == reg; }\nbool Clobbers(Register target, DirectHandle<Object> handle) { return false; }\nbool Clobbers(Register target, Tagged<Smi> smi) { return false; }\nbool Clobbers(Register target, Tagged<TaggedIndex> index) { return false; }\nbool Clobbers(Register target, int32_t imm) { return false; }\nbool Clobbers(Register target, RootIndex index) { return false; }\nbool Clobbers(Register target, interpreter::Register reg) { return false; }\nbool Clobbers(Register target, interpreter::RegisterList list) { return false; }\n\n// We don't know what's inside machine registers or operands, so assume they\n// match.\nbool MachineTypeMatches(MachineType type, Register reg) { return true; }\nbool MachineTypeMatches(MachineType type, MemOperand reg) { return true; }\nbool MachineTypeMatches(MachineType type, DirectHandle<HeapObject> handle) {\n  return type.IsTagged() && !type.IsTaggedSigned();\n}\nbool MachineTypeMatches(MachineType type, Tagged<Smi> handle) {\n  return type.IsTagged() && !type.IsTaggedPointer();\n}\nbool MachineTypeMatches(MachineType type, Tagged<TaggedIndex> handle) {\n  // Tagged<TaggedIndex> doesn't have a separate type, so check for the same\n  // type as for Smis.\n  return type.IsTagged() && !type.IsTaggedPointer();\n}\nbool MachineTypeMatches(MachineType type, int32_t imm) {\n  // 32-bit immediates can be used for 64-bit params -- they'll be\n  // zero-extended.\n  return type.representation() == MachineRepresentation::kWord32 ||\n         type.representation() == MachineRepresentation::kWord64;\n}\nbool MachineTypeMatches(MachineType type, RootIndex index) {\n  return type.IsTagged() && !type.IsTaggedSigned();\n}\nbool MachineTypeMatches(MachineType type, interpreter::Register reg) {\n  return type.IsTagged();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CheckArgs\",\n            \"about\": \"DEBUG function that checks argument types match expected types for builtin call\",\n            \"logic\": \"Recursively checks if the provided arguments match the expected machine types according to the given descriptor.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"no return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Descriptor, typename... Args>\nstruct CheckArgsHelper;\n\ntemplate <typename Descriptor>\nstruct CheckArgsHelper<Descriptor> {\n  static void Check(BaselineAssembler* masm, int i) {\n    if (Descriptor::AllowVarArgs()) {\n      CHECK_GE(i, Descriptor::GetParameterCount());\n    } else {\n      CHECK_EQ(i, Descriptor::GetParameterCount());\n    }\n  }\n};\n\ntemplate <typename Descriptor, typename Arg, typename... Args>\nstruct CheckArgsHelper<Descriptor, Arg, Args...> {\n  static void Check(BaselineAssembler* masm, int i, Arg arg, Args... args) {\n    if (i >= Descriptor::GetParameterCount()) {\n      CHECK(Descriptor::AllowVarArgs());\n      return;\n    }\n    CHECK(MachineTypeMatches(Descriptor().GetParameterType(i), arg));\n    CheckArgsHelper<Descriptor, Args...>::Check(masm, i + 1, args...);\n  }\n};\n\ntemplate <typename Descriptor, typename... Args>\nstruct CheckArgsHelper<Descriptor, interpreter::RegisterList, Args...> {\n  static void Check(BaselineAssembler* masm, int i,\n                    interpreter::RegisterList list, Args... args) {\n    for (int reg_index = 0; reg_index < list.register_count();\n         ++reg_index, ++i) {\n      if (i >= Descriptor::GetParameterCount()) {\n        CHECK(Descriptor::AllowVarArgs());\n        return;\n      }\n      CHECK(MachineTypeMatches(Descriptor().GetParameterType(i),\n                               list[reg_index]));\n    }\n    CheckArgsHelper<Descriptor, Args...>::Check(masm, i, args...);\n  }\n};\n\ntemplate <typename Descriptor, typename... Args>\nvoid CheckArgs(BaselineAssembler* masm, Args... args) {\n  CheckArgsHelper<Descriptor, Args...>::Check(masm, 0, args...);\n}\n\nvoid CheckSettingDoesntClobber(Register target) {}\ntemplate <typename Arg, typename... Args>\nvoid CheckSettingDoesntClobber(Register target, Arg arg, Args... args) {\n  DCHECK(!Clobbers(target, arg));\n  CheckSettingDoesntClobber(target, args...);\n}\n\n#else  // DEBUG\n\ntemplate <typename Descriptor, typename... Args>\nvoid CheckArgs(Args... args) {}\n\ntemplate <typename... Args>\nvoid CheckSettingDoesntClobber(Register target, Args... args) {}\n\n#endif  // DEBUG\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MoveArgumentsForBuiltin\",\n            \"about\": \"Moves arguments into the registers and stack slots expected by a given builtin.\",\n            \"logic\": \"Uses template metaprogramming to iterate through arguments and place them in appropriate registers or on the stack according to the builtin's descriptor.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"no return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename Descriptor, int ArgIndex, bool kIsRegister, typename... Args>\nstruct ArgumentSettingHelper;\n\ntemplate <typename Descriptor, int ArgIndex, bool kIsRegister>\nstruct ArgumentSettingHelper<Descriptor, ArgIndex, kIsRegister> {\n  static void Set(BaselineAssembler* masm) {\n    // Should only ever be called for the end of register arguments.\n    static_assert(ArgIndex == Descriptor::GetRegisterParameterCount());\n  }\n};\n\ntemplate <typename Descriptor, int ArgIndex, typename Arg, typename... Args>\nstruct ArgumentSettingHelper<Descriptor, ArgIndex, true, Arg, Args...> {\n  static void Set(BaselineAssembler* masm, Arg arg, Args... args) {\n    static_assert(ArgIndex < Descriptor::GetRegisterParameterCount());\n    Register target = Descriptor::GetRegisterParameter(ArgIndex);\n    CheckSettingDoesntClobber(target, args...);\n    masm->Move(target, arg);\n    ArgumentSettingHelper<Descriptor, ArgIndex + 1,\n                          (ArgIndex + 1 <\n                           Descriptor::GetRegisterParameterCount()),\n                          Args...>::Set(masm, args...);\n  }\n};\n\ntemplate <typename Descriptor, int ArgIndex>\nstruct ArgumentSettingHelper<Descriptor, ArgIndex, true,\n                             interpreter::RegisterList> {\n  static void Set(BaselineAssembler* masm, interpreter::RegisterList list) {\n    static_assert(ArgIndex < Descriptor::GetRegisterParameterCount());\n    DCHECK_EQ(ArgIndex + list.register_count(),\n              Descriptor::GetRegisterParameterCount());\n    for (int i = 0; ArgIndex + i < Descriptor::GetRegisterParameterCount();\n         ++i) {\n      Register target = Descriptor::GetRegisterParameter(ArgIndex + i);\n      masm->Move(target, masm->RegisterFrameOperand(list[i]));\n    }\n  }\n};\n\ntemplate <typename Descriptor, int ArgIndex, typename Arg, typename... Args>\nstruct ArgumentSettingHelper<Descriptor, ArgIndex, false, Arg, Args...> {\n  static void Set(BaselineAssembler* masm, Arg arg, Args... args) {\n    if (Descriptor::kStackArgumentOrder == StackArgumentOrder::kDefault) {\n      masm->Push(arg, args...);\n    } else {\n      masm->PushReverse(arg, args...);\n    }\n  }\n};\n\ntemplate <Builtin kBuiltin, typename... Args>\nvoid MoveArgumentsForBuiltin(BaselineAssembler* masm, Args... args) {\n  using Descriptor = typename CallInterfaceDescriptorFor<kBuiltin>::type;\n  CheckArgs<Descriptor>(masm, args...);\n  ArgumentSettingHelper<Descriptor, 0,\n                        (0 < Descriptor::GetRegisterParameterCount()),\n                        Args...>::Set(masm, args...);\n  if (Descriptor::HasContextParameter()) {\n    masm->LoadContext(Descriptor::ContextRegister());\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"BaselineAssemblerOptions\",\n            \"about\": \"Creates and configures AssemblerOptions for BaselineCompiler\",\n            \"logic\": \"Defines the options to be used by the assembler, including the jump mode for builtin calls.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"V8 isolate\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AssemblerOptions\",\n                \"description\": \"Assembler options\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nAssemblerOptions BaselineAssemblerOptions(Isolate* isolate) {\n  AssemblerOptions options = AssemblerOptions::Default(isolate);\n  options.builtin_call_jump_mode =\n      isolate->is_short_builtin_calls_enabled()\n          ? BuiltinCallJumpMode::kPCRelative\n          : kFallbackBuiltinCallJumpModeForBaseline;\n  return options;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"AllocateBuffer\",\n            \"about\": \"Allocates an assembler buffer for code generation\",\n            \"logic\": \"Estimates the required buffer size based on bytecode length and allocates a buffer of that size.\",\n            \"parameters\": [\n                {\n                    \"name\": \"bytecodes\",\n                    \"type\": \"DirectHandle<BytecodeArray>\",\n                    \"purpose\": \"bytecode array\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<AssemblerBuffer>\",\n                \"description\": \"pointer to assembler buffer\"\n            },\n            \"dependencies\": [\n                \"BaselineCompiler::EstimateInstructionSize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Rough upper-bound estimate. Copying the data is most likely more expensive\n// than pre-allocating a large enough buffer.\n#ifdef V8_TARGET_ARCH_IA32\nconst int kAverageBytecodeToInstructionRatio = 5;\n#else\nconst int kAverageBytecodeToInstructionRatio = 7;\n#endif\nstd::unique_ptr<AssemblerBuffer> AllocateBuffer(\n    DirectHandle<BytecodeArray> bytecodes) {\n  int estimated_size;\n  {\n    DisallowHeapAllocation no_gc;\n    estimated_size = BaselineCompiler::EstimateInstructionSize(*bytecodes);\n  }\n  return NewAssemblerBuffer(RoundUp(estimated_size, 4 * KB));\n}\n}  // namespace\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BaselineCompiler\",\n            \"about\": \"Compiles bytecode into baseline code for a given function.\",\n            \"attributes\": [\n                {\n                    \"name\": \"local_isolate_\",\n                    \"type\": \"LocalIsolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Local isolate\"\n                },\n                {\n                    \"name\": \"stats_\",\n                    \"type\": \"RuntimeCallStats*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Runtime call stats\"\n                },\n                {\n                    \"name\": \"shared_function_info_\",\n                    \"type\": \"Handle<SharedFunctionInfo>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Shared function info\"\n                },\n                {\n                    \"name\": \"bytecode_\",\n                    \"type\": \"Handle<BytecodeArray>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Bytecode array\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Memory zone\"\n                },\n                {\n                    \"name\": \"masm_\",\n                    \"type\": \"MacroAssembler\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Macro assembler\"\n                },\n                {\n                    \"name\": \"basm_\",\n                    \"type\": \"BaselineAssembler\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Baseline assembler\"\n                },\n                {\n                    \"name\": \"iterator_\",\n                    \"type\": \"BytecodeArrayIterator\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Bytecode array iterator\"\n                },\n                {\n                    \"name\": \"labels_\",\n                    \"type\": \"Label*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of labels\"\n                },\n                {\n                    \"name\": \"label_tags_\",\n                    \"type\": \"ZoneVector<bool>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"boolean flags indicating whether a specific position in the bytecode array is the target of an indirect jump.\"\n                },\n                {\n                    \"name\": \"bytecode_offset_table_builder_\",\n                    \"type\": \"BytecodeOffsetTableBuilder\",\n                    \"access\": \"private\",\n                    \"purpose\": \"offset table builder\"\n                }\n            ],\n            \"dependencies\": [\n                \"LocalIsolate\",\n                \"Handle\",\n                \"SharedFunctionInfo\",\n                \"BytecodeArray\",\n                \"Zone\",\n                \"MacroAssembler\",\n                \"BaselineAssembler\",\n                \"BytecodeArrayIterator\",\n                \"Label\",\n                \"BytecodeOffsetTableBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nBaselineCompiler::BaselineCompiler(\n    LocalIsolate* local_isolate,\n    Handle<SharedFunctionInfo> shared_function_info,\n    Handle<BytecodeArray> bytecode)\n    : local_isolate_(local_isolate),\n      stats_(local_isolate->runtime_call_stats()),\n      shared_function_info_(shared_function_info),\n      bytecode_(bytecode),\n      zone_(local_isolate->allocator(), ZONE_NAME),\n      masm_(\n          local_isolate->GetMainThreadIsolateUnsafe(), &zone_,\n          BaselineAssemblerOptions(local_isolate->GetMainThreadIsolateUnsafe()),\n          CodeObjectRequired::kNo, AllocateBuffer(bytecode)),\n      basm_(&masm_),\n      iterator_(bytecode_),\n      labels_(zone_.AllocateArray<Label>(bytecode_->length())),\n      label_tags_(2 * bytecode_->length(), &zone_) {\n  // Empirically determined expected size of the offset table at the 95th %ile,\n  // based on the size of the bytecode, to be:\n  //\n  //   16 + (bytecode size) / 4\n  bytecode_offset_table_builder_.Reserve(\n      base::bits::RoundUpToPowerOfTwo(16 + bytecode_->Size() / 4));\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GenerateCode\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Generates the baseline code from bytecode.\",\n            \"logic\": \"Iterates through the bytecode array, pre-visiting to mark jump targets and then visiting each bytecode to generate the corresponding assembly code.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"no return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineCompiler::GenerateCode() {\n  {\n    RCS_BASELINE_SCOPE(PreVisit);\n    // Mark exception handlers as valid indirect jump targets. This is required\n    // when CFI is enabled, to allow indirect jumps into baseline code.\n    HandlerTable table(*bytecode_);\n    for (int i = 0; i < table.NumberOfRangeEntries(); ++i) {\n      MarkIndirectJumpTarget(table.GetRangeHandler(i));\n    }\n    for (; !iterator_.done(); iterator_.Advance()) {\n      PreVisitSingleBytecode();\n    }\n    iterator_.Reset();\n  }\n\n  // No code generated yet.\n  DCHECK_EQ(__ pc_offset(), 0);\n  __ CodeEntry();\n\n  {\n    RCS_BASELINE_SCOPE(Visit);\n    Prologue();\n    AddPosition();\n    for (; !iterator_.done(); iterator_.Advance()) {\n      VisitSingleBytecode();\n      AddPosition();\n    }\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Build\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Builds the code object from the generated assembly.\",\n            \"logic\": \"Finalizes the code generation, allocates the bytecode offset table, and creates a Code object.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"MaybeHandle<Code>\",\n                \"description\": \"Code object\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nMaybeHandle<Code> BaselineCompiler::Build() {\n  RCS_BASELINE_SCOPE(Build);\n  CodeDesc desc;\n  __ GetCode(local_isolate_, &desc);\n\n  // Allocate the bytecode offset table.\n  Handle<TrustedByteArray> bytecode_offset_table =\n      bytecode_offset_table_builder_.ToBytecodeOffsetTable(local_isolate_);\n\n  Factory::CodeBuilder code_builder(local_isolate_, desc, CodeKind::BASELINE);\n  code_builder.set_bytecode_offset_table(bytecode_offset_table);\n  if (shared_function_info_->HasInterpreterData(local_isolate_)) {\n    code_builder.set_interpreter_data(\n        handle(shared_function_info_->interpreter_data(local_isolate_),\n               local_isolate_));\n  } else {\n    code_builder.set_interpreter_data(bytecode_);\n  }\n  code_builder.set_parameter_count(bytecode_->parameter_count());\n  return code_builder.TryBuild();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EstimateInstructionSize\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Estimates the instruction size\",\n            \"logic\": \"Estimates the instruction size by multiplying the length of bytecode array with a fixed ratio.\",\n            \"parameters\": [\n                {\n                    \"name\": \"bytecode\",\n                    \"type\": \"Tagged<BytecodeArray>\",\n                    \"purpose\": \"bytecode array\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"size of the instruction\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nint BaselineCompiler::EstimateInstructionSize(Tagged<BytecodeArray> bytecode) {\n  return bytecode->length() * kAverageBytecodeToInstructionRatio;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterOperand\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Gets the register operand at the given operand index\",\n            \"logic\": \"Gets the register operand at the given operand index from the bytecode array iterator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"operand_index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"index of the operand\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"interpreter::Register\",\n                \"description\": \"register operand\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ninterpreter::Register BaselineCompiler::RegisterOperand(int operand_index) {\n  return iterator().GetRegisterOperand(operand_index);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LoadRegister\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Loads a register with value from RegisterOperand.\",\n            \"logic\": \"Loads a register with value from RegisterOperand.\",\n            \"parameters\": [\n                {\n                    \"name\": \"output\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"output register\"\n                },\n                {\n                    \"name\": \"operand_index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"index of the operand\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"no return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineCompiler::LoadRegister(Register output, int operand_index) {\n  __ LoadRegister(output, RegisterOperand(operand_index));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"StoreRegister\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Stores a register value into memory location referenced by an operand.\",\n            \"logic\": \"StoreRegister implements the general store instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"operand_index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"Index to the operand from bytecode\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"Register to store in memory\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineCompiler::StoreRegister(int operand_index, Register value) {\n#ifdef DEBUG\n  effect_state_.CheckEffect();\n#endif\n  __ Move(RegisterOperand(operand_index), value);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddPosition\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Adds the current program counter offset to the bytecode offset table.\",\n            \"logic\": \"This method is called to keep track of the mapping between bytecode offsets and generated machine code offsets.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineCompiler::AddPosition() {\n  bytecode_offset_table_builder_.AddPosition(__ pc_offset());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CallBuiltin\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Calls a builtin function.\",\n            \"logic\": \"Moves arguments into the expected registers/stack slots, then calls the specified builtin. Includes DEBUG assertions to ensure that no registers are unexpectedly clobbered.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"detail::MoveArgumentsForBuiltin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <Builtin kBuiltin, typename... Args>\nvoid BaselineCompiler::CallBuiltin(Args... args) {\n#ifdef DEBUG\n  effect_state_.CheckEffect();\n  if (BuiltinMayDeopt(kBuiltin)) {\n    effect_state_.MayDeopt();\n  }\n#endif\n  ASM_CODE_COMMENT(&masm_);\n  detail::MoveArgumentsForBuiltin<kBuiltin>(&basm_, args...);\n  __ CallBuiltin(kBuiltin);\n#ifdef V8_ENABLE_CET_SHADOW_STACK\n  if (BuiltinMayDeopt(kBuiltin)) {\n    __ MaybeEmitPlaceHolderForDeopt();\n  }\n#endif  // V8_ENABLE_CET_SHADOW_STACK\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitLdaZero\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Visit the LdaZero bytecode.\",\n            \"logic\": \"Loads the accumulator register with the Smi value 0.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"no return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineCompiler::VisitLdaZero() {\n  __ Move(kInterpreterAccumulatorRegister, Smi::FromInt(0));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitReturn\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Visit the Return bytecode.\",\n            \"logic\": \"Emits code to leave the baseline frame and return to the caller.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineCompiler::VisitReturn() {\n  ASM_CODE_COMMENT_STRING(&masm_, \"Return\");\n  int profiling_weight = iterator().current_offset() +\n                         iterator().current_bytecode_size_without_prefix();\n  int parameter_count = bytecode_->parameter_count();\n\n  TailCallBuiltin<Builtin::kBaselineLeaveFrame>(parameter_count,\n                                                -profiling_weight);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitJumpLoop\",\n            \"parent\": \"BaselineCompiler\",\n            \"about\": \"Visit the JumpLoop bytecode.\",\n            \"logic\": \"Updates interrupt budget and jumps to the target label. Includes OSR (On-Stack Replacement) checks in non-JITLESS builds.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineCompiler::VisitJumpLoop() {\n#ifndef V8_JITLESS\n  Label osr_armed, osr_not_armed;\n  using D = OnStackReplacementDescriptor;\n  Register feedback_vector = Register::no_reg();\n  Register osr_state = Register::no_reg();\n  const int loop_depth = iterator().GetImmediateOperand(1);\n  {\n    ASM_CODE_COMMENT_STRING(&masm_, \"OSR Check Armed\");\n    BaselineAssembler::ScratchRegisterScope temps(&basm_);\n    feedback_vector = temps.AcquireScratch();\n    osr_state = temps.AcquireScratch();\n    LoadFeedbackVector(feedback_vector);\n    __ LoadWord8Field(osr_state, feedback_vector,\n                      FeedbackVector::kOsrStateOffset);\n    static_assert(FeedbackVector::MaybeHasMaglevOsrCodeBit::encode(true) >\n                  FeedbackVector::kMaxOsrUrgency);\n    static_assert(FeedbackVector::MaybeHasTurbofanOsrCodeBit::encode(true) >\n                  FeedbackVector::kMaxOsrUrgency);\n    __ JumpIfByte(kUnsignedGreaterThan, osr_state, loop_depth, &osr_armed,\n                  Label::kNear);\n"
}