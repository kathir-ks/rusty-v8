{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/loong64/simulator-loong64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/loong64/simulator-loong64.cc\",\n        \"file_name\": \"simulator-loong64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the LOONG64 simulator for the V8 JavaScript engine.  Provides instruction decoding, register and memory access, and debugging support for emulating LOONG64 architecture when running on other platforms.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for simulator functionality like standard library, platform definitions, assembler, disassembler, heap, runtime, and webassembly support.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/loong64/simulator-loong64.h\"\n\n// Only build the simulator if not compiling for real LOONG64 hardware.\n#if defined(USE_SIMULATOR)\n\n#include <limits.h>\n#include <stdarg.h>\n#include <stdlib.h>\n\n#include <cmath>\n\n#include \"src/base/bits.h\"\n#include \"src/base/platform/memory.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/base/strings.h\"\n#include \"src/base/vector.h\"\n#include \"src/codegen/assembler-inl.h\"\n#include \"src/codegen/loong64/constants-loong64.h\"\n#include \"src/codegen/macro-assembler.h\"\n#include \"src/diagnostics/disasm.h\"\n#include \"src/heap/combined-heap.h\"\n#include \"src/runtime/runtime-utils.h\"\n#include \"src/utils/ostreams.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/trap-handler/trap-handler-simulator.h\"\n#endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Simulator::GlobalMonitor\",\n            \"about\": \"A global monitor used for synchronization between threads in the simulator.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nDEFINE_LAZY_LEAKY_OBJECT_GETTER(Simulator::GlobalMonitor,\n                                Simulator::GlobalMonitor::Get)\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"HaveSameSign\",\n            \"about\": \"Checks if two 64-bit integers have the same sign.\",\n            \"logic\": \"Uses bitwise XOR to determine if the sign bits are the same.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"First integer\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"Second integer\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the integers have the same sign, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ninline bool HaveSameSign(int64_t a, int64_t b) { return ((a ^ b) >= 0); }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"get_fcsr_condition_bit\",\n            \"about\": \"Gets the floating-point control and status register (FCSR) bit corresponding to a condition code.\",\n            \"logic\": \"Maps the condition code (cc) to a specific bit in the FCSR.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"Condition code (0-7)\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"uint32_t\",\n                \"description\": \"The bit number in the FCSR corresponding to the condition code.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nuint32_t get_fcsr_condition_bit(uint32_t cc) {\n  if (cc == 0) {\n    return 23;\n  } else {\n    return 24 + cc;\n  }\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Loong64Debugger\",\n            \"about\": \"Provides debugging functionality for the LOONG64 simulator, including breakpoints, register inspection, and disassembly.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Simulator\",\n                \"Instruction\",\n                \"Registers\",\n                \"FPURegisters\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// The Loong64Debugger class is used by the simulator while debugging simulated\n// code.\nclass Loong64Debugger {\n public:\n  explicit Loong64Debugger(Simulator* sim) : sim_(sim) {}\n\n  void Stop(Instruction* instr);\n  void Debug();\n  // Print all registers with a nice formatting.\n  void PrintAllRegs();\n  void PrintAllRegsIncludingFPU();\n\n private:\n  // We set the breakpoint code to 0xFFFF to easily recognize it.\n  static const Instr kBreakpointInstr = BREAK | 0xFFFF;\n  static const Instr kNopInstr = 0x0;\n\n  Simulator* sim_;\n\n  int64_t GetRegisterValue(int regnum);\n  int64_t GetFPURegisterValue(int regnum);\n  float GetFPURegisterValueFloat(int regnum);\n  double GetFPURegisterValueDouble(int regnum);\n  bool GetValue(const char* desc, int64_t* value);\n\n  // Set or delete a breakpoint. Returns true if successful.\n  bool SetBreakpoint(Instruction* breakpc);\n  bool DeleteBreakpoint(Instruction* breakpc);\n\n  // Undo and redo all breakpoints. This is needed to bracket disassembly and\n  // execution to skip past breakpoints when run from the debugger.\n  void UndoBreakpoints();\n  void RedoBreakpoints();\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Loong64Debugger::Stop\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Stops the simulator execution and enters the debugging mode.\",\n            \"logic\": \"Retrieves the stop code from the instruction and calls the Debug method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instr\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction that caused the stop.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Debug\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Loong64Debugger::Stop(Instruction* instr) {\n  // Get the stop code.\n  uint32_t code = instr->Bits(25, 6);\n  PrintF(\"Simulator hit (%u)\\n\", code);\n  Debug();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::GetRegisterValue\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Retrieves the value of a given general-purpose register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"regnum\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The register number.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int64_t\",\n                \"description\": \"The value of the register.\"\n            },\n            \"dependencies\": [\n                \"Simulator::get_register\",\n                \"Simulator::get_pc\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint64_t Loong64Debugger::GetRegisterValue(int regnum) {\n  if (regnum == kNumSimuRegisters) {\n    return sim_->get_pc();\n  } else {\n    return sim_->get_register(regnum);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::GetFPURegisterValue\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Retrieves the value of a given floating-point register as an int64_t.\",\n            \"parameters\": [\n                {\n                    \"name\": \"regnum\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The register number.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int64_t\",\n                \"description\": \"The value of the register.\"\n            },\n            \"dependencies\": [\n                \"Simulator::get_fpu_register\",\n                \"Simulator::get_pc\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint64_t Loong64Debugger::GetFPURegisterValue(int regnum) {\n  if (regnum == kNumFPURegisters) {\n    return sim_->get_pc();\n  } else {\n    return sim_->get_fpu_register(regnum);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::GetFPURegisterValueFloat\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Retrieves the value of a given floating-point register as a float.\",\n            \"parameters\": [\n                {\n                    \"name\": \"regnum\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The register number.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float\",\n                \"description\": \"The value of the register.\"\n            },\n            \"dependencies\": [\n                \"Simulator::get_fpu_register_float\",\n                \"Simulator::get_pc\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nfloat Loong64Debugger::GetFPURegisterValueFloat(int regnum) {\n  if (regnum == kNumFPURegisters) {\n    return sim_->get_pc();\n  } else {\n    return sim_->get_fpu_register_float(regnum);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::GetFPURegisterValueDouble\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Retrieves the value of a given floating-point register as a double.\",\n            \"parameters\": [\n                {\n                    \"name\": \"regnum\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The register number.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"double\",\n                \"description\": \"The value of the register.\"\n            },\n            \"dependencies\": [\n                \"Simulator::get_fpu_register_double\",\n                \"Simulator::get_pc\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ndouble Loong64Debugger::GetFPURegisterValueDouble(int regnum) {\n  if (regnum == kNumFPURegisters) {\n    return sim_->get_pc();\n  } else {\n    return sim_->get_fpu_register_double(regnum);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::GetValue\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Retrieves the value represented by a register name or hexadecimal address.\",\n            \"parameters\": [\n                {\n                    \"name\": \"desc\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The register name or hexadecimal address as a string.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int64_t*\",\n                    \"purpose\": \"Pointer to store the retrieved value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the value was successfully retrieved, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Registers::Number\",\n                \"FPURegisters::Number\",\n                \"GetRegisterValue\",\n                \"GetFPURegisterValue\",\n                \"SScanF\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Loong64Debugger::GetValue(const char* desc, int64_t* value) {\n  int regnum = Registers::Number(desc);\n  int fpuregnum = FPURegisters::Number(desc);\n\n  if (regnum != kInvalidRegister) {\n    *value = GetRegisterValue(regnum);\n    return true;\n  } else if (fpuregnum != kInvalidFPURegister) {\n    *value = GetFPURegisterValue(fpuregnum);\n    return true;\n  } else if (strncmp(desc, \"0x\", 2) == 0) {\n    return SScanF(desc + 2, \"%\" SCNx64, reinterpret_cast<uint64_t*>(value)) ==\n           1;\n  } else {\n    return SScanF(desc, \"%\" SCNu64, reinterpret_cast<uint64_t*>(value)) == 1;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::SetBreakpoint\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Sets a breakpoint at a given instruction address.\",\n            \"parameters\": [\n                {\n                    \"name\": \"breakpc\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction address where the breakpoint is to be set.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the breakpoint was successfully set, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Simulator::break_pc_\",\n                \"Simulator::break_instr_\",\n                \"Instruction::InstructionBits\",\n                \"Instruction::SetInstructionBits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Loong64Debugger::SetBreakpoint(Instruction* breakpc) {\n  // Check if a breakpoint can be set. If not return without any side-effects.\n  if (sim_->break_pc_ != nullptr) {\n    return false;\n  }\n\n  // Set the breakpoint.\n  sim_->break_pc_ = breakpc;\n  sim_->break_instr_ = breakpc->InstructionBits();\n  // Not setting the breakpoint instruction in the code itself. It will be set\n  // when the debugger shell continues.\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::DeleteBreakpoint\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Deletes a breakpoint.\",\n            \"parameters\": [\n                {\n                    \"name\": \"breakpc\",\n                    \"type\": \"Instruction*\",\n                    \"purpose\": \"The instruction address where the breakpoint is to be deleted.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the breakpoint was successfully deleted, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"Simulator::break_pc_\",\n                \"Simulator::break_instr_\",\n                \"Instruction::SetInstructionBits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool Loong64Debugger::DeleteBreakpoint(Instruction* breakpc) {\n  if (sim_->break_pc_ != nullptr) {\n    sim_->break_pc_->SetInstructionBits(sim_->break_instr_);\n  }\n\n  sim_->break_pc_ = nullptr;\n  sim_->break_instr_ = 0;\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::UndoBreakpoints\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Temporarily removes breakpoints to allow disassembly and execution to proceed without triggering them.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Simulator::break_pc_\",\n                \"Simulator::break_instr_\",\n                \"Instruction::SetInstructionBits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Loong64Debugger::UndoBreakpoints() {\n  if (sim_->break_pc_ != nullptr) {\n    sim_->break_pc_->SetInstructionBits(sim_->break_instr_);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::RedoBreakpoints\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Reinstalls breakpoints after they have been temporarily removed.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Simulator::break_pc_\",\n                \"Instruction::SetInstructionBits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Loong64Debugger::RedoBreakpoints() {\n  if (sim_->break_pc_ != nullptr) {\n    sim_->break_pc_->SetInstructionBits(kBreakpointInstr);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::PrintAllRegs\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Prints the values of all general-purpose registers.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Registers::Name\",\n                \"GetRegisterValue\",\n                \"PrintF\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Loong64Debugger::PrintAllRegs() {\n#define REG_INFO(n) Registers::Name(n), GetRegisterValue(n), GetRegisterValue(n)\n\n  PrintF(\"\\n\");\n  // at, v0, a0.\n  PrintF(\"%3s: 0x%016\" PRIx64 \" %14\" PRId64 \"\\t%3s: 0x%016\" PRIx64 \" %14\" PRId64\n         \"\\t%3s: 0x%016\" PRIx64 \" %14\" PRId64 \"\\n\",\n         REG_INFO(1), REG_INFO(2), REG_INFO(4));\n  // v1, a1.\n  PrintF(\"%34s\\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\n\",\n         \"\", REG_INFO(3), REG_INFO(5));\n  // a2.\n  PrintF(\"%34s\\t%34s\\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\", \"\", \"\",\n         REG_INFO(6));\n  // a3.\n  PrintF(\"%34s\\t%34s\\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\", \"\", \"\",\n         REG_INFO(7));\n  PrintF(\"\\n\");\n  // a4-t3, s0-s7\n  for (int i = 0; i < 8; i++) {\n    PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n           \"  %14\" PRId64 \" \\n\",\n           REG_INFO(8 + i), REG_INFO(16 + i));\n  }\n  PrintF(\"\\n\");\n  // t8, k0, LO.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\",\n         REG_INFO(24), REG_INFO(26), REG_INFO(32));\n  // t9, k1, HI.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\",\n         REG_INFO(25), REG_INFO(27), REG_INFO(33));\n  // sp, fp, gp.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\n\",\n         REG_INFO(29), REG_INFO(30), REG_INFO(28));\n  // pc.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %14\" PRId64 \" \\t%3s: 0x%016\" PRIx64\n         \"  %14\" PRId64 \" \\n\",\n         REG_INFO(31), REG_INFO(34));\n\n#undef REG_INFO\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::PrintAllRegsIncludingFPU\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Prints the values of all general-purpose and floating-point registers.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PrintAllRegs\",\n                \"FPURegisters::Name\",\n                \"GetFPURegisterValue\",\n                \"GetFPURegisterValueDouble\",\n                \"PrintF\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Loong64Debugger::PrintAllRegsIncludingFPU() {\n#define FPU_REG_INFO(n) \\\n  FPURegisters::Name(n), GetFPURegisterValue(n), GetFPURegisterValueDouble(n)\n\n  PrintAllRegs();\n\n  PrintF(\"\\n\\n\");\n  // f0, f1, f2, ... f31.\n  // TODO(plind): consider printing 2 columns for space efficiency.\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(0));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(1));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(2));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(3));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(4));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(5));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(6));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(7));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(8));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(9));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(10));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(11));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(12));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(13));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(14));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(15));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(16));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(17));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(18));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(19));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(20));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(21));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(22));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(23));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(24));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(25));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(26));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(27));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(28));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(29));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(30));\n  PrintF(\"%3s: 0x%016\" PRIx64 \"  %16.4e\\n\", FPU_REG_INFO(31));\n\n#undef FPU_REG_INFO\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Loong64Debugger::Debug\",\n            \"parent\": \"Loong64Debugger\",\n            \"about\": \"Enters an interactive debugging shell for the simulator.\",\n            \"logic\": \"Provides a command-line interface for inspecting registers, memory, and disassembling code.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"v8_flags.correctness_fuzzer_suppressions\",\n                \"disasm::NameConverter\",\n                \"disasm::Disassembler\",\n                \"v8::base::EmbeddedVector\",\n                \"ReadLine\",\n                \"strcmp\",\n                \"sim_->last_debugger_input\",\n                \"sim_->set_last_debugger_input\",\n                \"SScanF\",\n                \"Instruction::IsTrap\",\n                \"sim_->InstructionDecode\",\n                \"sim_->set_pc\",\n                \"PrintAllRegs\",\n                \"PrintAllRegsIncludingFPU\",\n                \"Registers::Number\",\n                \"FPURegisters::Number\",\n                \"GetValue\",\n                \"Tagged<Object>\",\n                \"Heap*\",\n                \"IsSmi\",\n                \"IsValidHeapObject\",\n                \"ShortPrint\",\n                \"SetBreakpoint\",\n                \"DeleteBreakpoint\",\n                \"v8::base::OS::DebugBreak\",\n                \"IsEnabledStop\",\n                \"RedoBreakpoints\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Loong64Debugger::Debug() {\n  if (v8_flags.correctness_fuzzer_suppressions) {\n    PrintF(\"Debugger disabled for differential fuzzing.\\n\");\n    return;\n  }\n  intptr_t last_pc = -1;\n  bool done = false;\n\n#define COMMAND_SIZE 63\n#define ARG_SIZE 255\n\n#define STR(a) #a\n#define XSTR(a) STR(a)\n\n  char cmd[COMMAND_SIZE + 1];\n  char arg1[ARG_SIZE + 1];\n  char arg2[ARG_SIZE + 1];\n  char* argv[3] = {cmd, arg1, arg2};\n\n  // Make sure to have a proper terminating character if reaching the limit.\n  cmd[COMMAND_SIZE] = 0;\n  arg1[ARG_SIZE] = 0;\n  arg2[ARG_SIZE] = 0;\n\n  // Undo all set breakpoints while running in the debugger shell. This will\n  // make them invisible to all commands.\n  UndoBreakpoints();\n\n  while (!done && (sim_->get_pc() != Simulator::end_sim_pc)) {\n    if (last_pc != sim_->get_pc()) {\n      disasm::NameConverter converter;\n      disasm::Disassembler dasm(converter);\n      // Use a reasonably large buffer.\n      v8::base::EmbeddedVector<char, 256> buffer;\n      dasm.InstructionDecode(buffer,\n                             reinterpret_cast<uint8_t*>(sim_->get_pc()));\n      PrintF(\"  0x%016\" PRIx64 \"   %s\\n\", sim_->get_pc(), buffer.begin());\n      last_pc = sim_->get_pc();\n    }\n    char* line = ReadLine(\"sim> \");\n    if (line == nullptr) {\n      break;\n    } else {\n      char* last_input = sim_->last_debugger_input();\n      if (strcmp(line, \"\\n\") == 0 && last_input != nullptr) {\n        line = last_input;"
}