{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/register-allocator.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/register-allocator.cc\",\n        \"file_name\": \"register-allocator.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements register allocation algorithms for the V8 compiler backend.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for register allocation, data structures, code generation, and other utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/backend/register-allocator.h\"\n\n            #include <iomanip>\n            #include <optional>\n\n            #include \"src/base/iterator.h\"\n            #include \"src/base/small-vector.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/codegen/assembler-inl.h\"\n            #include \"src/codegen/register-configuration.h\"\n            #include \"src/codegen/tick-counter.h\"\n            #include \"src/compiler/backend/register-allocation.h\"\n            #include \"src/compiler/backend/spill-placer.h\"\n            #include \"src/compiler/linkage.h\"\n            #include \"src/strings/string-stream.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetContainingLoop\",\n            \"about\": \"Retrieves the InstructionBlock representing the containing loop of a given block.\",\n            \"logic\": \"Checks if the block has a valid loop header index. If it does, it returns the corresponding InstructionBlock. Otherwise, it returns nullptr.\",\n            \"parameters\": [\n                {\n                    \"name\": \"sequence\",\n                    \"type\": \"const InstructionSequence*\",\n                    \"purpose\": \"The InstructionSequence being processed.\"\n                },\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const InstructionBlock*\",\n                    \"purpose\": \"The InstructionBlock whose containing loop is to be found.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const InstructionBlock*\",\n                \"description\": \"The InstructionBlock representing the containing loop, or nullptr if the block is not inside a loop.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            const InstructionBlock* GetContainingLoop(const InstructionSequence* sequence,\n                                                    const InstructionBlock* block) {\n              RpoNumber index = block->loop_header();\n              if (!index.IsValid()) return nullptr;\n              return sequence->InstructionBlockAt(index);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetInstructionBlock\",\n            \"about\": \"Retrieves the InstructionBlock for a given LifetimePosition.\",\n            \"logic\": \"Converts the LifetimePosition to an instruction index and returns the corresponding InstructionBlock from the InstructionSequence.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code\",\n                    \"type\": \"const InstructionSequence*\",\n                    \"purpose\": \"The InstructionSequence being processed.\"\n                },\n                {\n                    \"name\": \"pos\",\n                    \"type\": \"LifetimePosition\",\n                    \"purpose\": \"The LifetimePosition for which to retrieve the InstructionBlock.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const InstructionBlock*\",\n                \"description\": \"The InstructionBlock corresponding to the LifetimePosition.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            const InstructionBlock* GetInstructionBlock(const InstructionSequence* code,\n                                                        LifetimePosition pos) {\n              return code->GetInstructionBlock(pos.ToInstructionIndex());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetLastInstruction\",\n            \"about\": \"Retrieves the last instruction of a given instruction block.\",\n            \"logic\": \"Returns the Instruction at the last instruction index of the given block in the instruction sequence.\",\n            \"parameters\": [\n                {\n                    \"name\": \"code\",\n                    \"type\": \"InstructionSequence*\",\n                    \"purpose\": \"The InstructionSequence being processed.\"\n                },\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const InstructionBlock*\",\n                    \"purpose\": \"The InstructionBlock whose last instruction is to be retrieved.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Instruction*\",\n                \"description\": \"The last instruction of the InstructionBlock.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            Instruction* GetLastInstruction(InstructionSequence* code,\n                                            const InstructionBlock* block) {\n              return code->InstructionAt(block->last_instruction_index());\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"UsePosition\",\n            \"about\": \"Represents a use of a virtual register in the instruction sequence.\",\n            \"attributes\": [\n                {\n                    \"name\": \"operand_\",\n                    \"type\": \"InstructionOperand*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The operand representing the use.\"\n                },\n                {\n                    \"name\": \"hint_\",\n                    \"type\": \"void*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A hint for register allocation.\"\n                },\n                {\n                    \"name\": \"pos_\",\n                    \"type\": \"LifetimePosition\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The position in the instruction sequence where the use occurs.\"\n                },\n                {\n                    \"name\": \"flags_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flags associated with the use position (type, hint type, etc.).\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct UsePosition {\n              enum class UsePositionType {\n                kRequiresSlot,\n                kRequiresRegister,\n                kRegisterOrSlot,\n                kRegisterOrSlotOrConstant\n              };\n\n              enum class UsePositionHintType { kNone, kUnresolved, kUsePos, kOperand, kPhi };\n              // Other parts of UsePosition are defined inline.\n              UsePosition(LifetimePosition pos, InstructionOperand* operand, void* hint,\n                          UsePositionHintType hint_type);\n              bool HasHint() const;\n              bool HintRegister(int* register_code) const;\n              static UsePositionHintType HintTypeForOperand(const InstructionOperand& op);\n              void SetHint(UsePosition* use_pos);\n              void ResolveHint(UsePosition* use_pos);\n              void set_type(UsePositionType type, bool register_beneficial);\n              // Flags layout:\n              //  31                                                        0\n              //  +---+---------------------+----------+----------+----------+\n              //  |   |    Hint Type    |    Type    |  Register| Assigned |\n              //  |   |                   |            |Beneficial| Register |\n              //  +---+---------------------+----------+----------+----------+\n              //      2 bits               2 bits      1 bit      20 bits\n\n              enum TypeField : BitField<UsePositionType, 0, 2> {};\n              enum HintTypeField : BitField<UsePositionHintType, 2, 2> {};\n              enum RegisterBeneficialField : BitField<bool, 4, 1> {};\n              enum AssignedRegisterField : BitField<int, 5, 20> {};\n\n              static const int kUnassignedRegister = 0;\n\n              bool IsResolved() const {\n                return HintTypeField::decode(flags_) !=\n                       UsePositionHintType::kUnresolved;\n              }\n\n              bool HasOperand() const { return operand_ != nullptr; }\n              InstructionOperand* operand() const { return operand_; }\n              LifetimePosition pos() const { return pos_; }\n              UsePositionType type() const { return TypeField::decode(flags_); }\n              UsePositionHintType hint_type() const {\n                return HintTypeField::decode(flags_);\n              }\n              void set_assigned_register(int assigned_register) {\n                DCHECK_EQ(kUnassignedRegister, AssignedRegisterField::decode(flags_));\n                flags_ = AssignedRegisterField::update(flags_, assigned_register);\n              }\n              bool RegisterIsBeneficial() const {\n                return RegisterBeneficialField::decode(flags_);\n              }\n              // Use this method to indicate that this UsePosition requires a register,\n              // and that backward spilling to a slot is not possible, even if spilling\n              // is enabled.\n              void set_spill_detrimental() {\n                flags_ |= TypeField::encode(UsePositionType::kRequiresRegister);\n                flags_ |= RegisterBeneficialField::encode(true);\n              }\n              bool SpillDetrimental() const {\n                return RegisterBeneficialField::decode(flags_);\n              }\n              static std::less<UsePosition*> Ordering() {\n                return [](const UsePosition* a, const UsePosition* b) {\n                  return a->pos() < b->pos();\n                };\n              }\n            private:\n              InstructionOperand* operand_;\n              void* hint_;\n              LifetimePosition pos_;\n              int flags_;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UsePosition::UsePosition\",\n            \"parent\": \"UsePosition\",\n            \"about\": \"Constructor for the UsePosition class.\",\n            \"logic\": \"Initializes the UsePosition object with the given parameters and determines the UsePositionType based on the operand's policy.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pos\",\n                    \"type\": \"LifetimePosition\",\n                    \"purpose\": \"The position of the use.\"\n                },\n                {\n                    \"name\": \"operand\",\n                    \"type\": \"InstructionOperand*\",\n                    \"purpose\": \"The operand being used.\"\n                },\n                {\n                    \"name\": \"hint\",\n                    \"type\": \"void*\",\n                    \"purpose\": \"A hint for register allocation.\"\n                },\n                {\n                    \"name\": \"hint_type\",\n                    \"type\": \"UsePositionHintType\",\n                    \"purpose\": \"The type of the hint.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            UsePosition::UsePosition(LifetimePosition pos, InstructionOperand* operand,\n                                     void* hint, UsePositionHintType hint_type)\n                : operand_(operand), hint_(hint), pos_(pos), flags_(0) {\n              DCHECK_IMPLIES(hint == nullptr, hint_type == UsePositionHintType::kNone);\n              bool register_beneficial = true;\n              UsePositionType type = UsePositionType::kRegisterOrSlot;\n              if (operand_ != nullptr && operand_->IsUnallocated()) {\n                const UnallocatedOperand* unalloc = UnallocatedOperand::cast(operand_);\n                if (unalloc->HasRegisterPolicy()) {\n                  type = UsePositionType::kRequiresRegister;\n                } else if (unalloc->HasSlotPolicy()) {\n                  type = UsePositionType::kRequiresSlot;\n                  register_beneficial = false;\n                } else if (unalloc->HasRegisterOrSlotOrConstantPolicy()) {\n                  type = UsePositionType::kRegisterOrSlotOrConstant;\n                  register_beneficial = false;\n                } else {\n                  register_beneficial = !unalloc->HasRegisterOrSlotPolicy();\n                }\n              }\n              flags_ = TypeField::encode(type) | HintTypeField::encode(hint_type) |\n                       RegisterBeneficialField::encode(register_beneficial) |\n                       AssignedRegisterField::encode(kUnassignedRegister);\n              DCHECK(pos_.IsValid());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UsePosition::HasHint\",\n            \"parent\": \"UsePosition\",\n            \"about\": \"Checks if the UsePosition has a register allocation hint.\",\n            \"logic\": \"Checks if the hint_ is null. Return false if it's null, true otherwise\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if hint exist. False if it's null.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool UsePosition::HasHint() const {\n              int hint_register;\n              return HintRegister(&hint_register);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UsePosition::HintRegister\",\n            \"parent\": \"UsePosition\",\n            \"about\": \"Retrieves the register code from the register allocation hint, if present.\",\n            \"logic\": \"Checks the type of hint and then casts it to extract the register code, if present.\",\n            \"parameters\": [\n                {\n                    \"name\": \"register_code\",\n                    \"type\": \"int*\",\n                    \"purpose\": \"Output parameter to store the register code.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if a register hint is present and the register code was successfully retrieved, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool UsePosition::HintRegister(int* register_code) const {\n              if (hint_ == nullptr) return false;\n              switch (HintTypeField::decode(flags_)) {\n                case UsePositionHintType::kNone:\n                case UsePositionHintType::kUnresolved:\n                  return false;\n                case UsePositionHintType::kUsePos: {\n                  UsePosition* use_pos = reinterpret_cast<UsePosition*>(hint_);\n                  int assigned_register = AssignedRegisterField::decode(use_pos->flags_);\n                  if (assigned_register == kUnassignedRegister) return false;\n                  *register_code = assigned_register;\n                  return true;\n                }\n                case UsePositionHintType::kOperand: {\n                  InstructionOperand* operand =\n                      reinterpret_cast<InstructionOperand*>(hint_);\n                  *register_code = LocationOperand::cast(operand)->register_code();\n                  return true;\n                }\n                case UsePositionHintType::kPhi: {\n                  RegisterAllocationData::PhiMapValue* phi =\n                      reinterpret_cast<RegisterAllocationData::PhiMapValue*>(hint_);\n                  int assigned_register = phi->assigned_register();\n                  if (assigned_register == kUnassignedRegister) return false;\n                  *register_code = assigned_register;\n                  return true;\n                }\n              }\n              UNREACHABLE();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UsePosition::HintTypeForOperand\",\n            \"parent\": \"UsePosition\",\n            \"about\": \"Determines the UsePositionHintType based on the kind of InstructionOperand.\",\n            \"logic\": \"Checks the kind of operand, returns the appropriate hint type.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const InstructionOperand&\",\n                    \"purpose\": \"The operand to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"UsePositionHintType\",\n                \"description\": \"The UsePositionHintType corresponding to the operand kind.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            UsePositionHintType UsePosition::HintTypeForOperand(\n                const InstructionOperand& op) {\n              switch (op.kind()) {\n                case InstructionOperand::CONSTANT:\n                case InstructionOperand::IMMEDIATE:\n                  return UsePositionHintType::kNone;\n                case InstructionOperand::UNALLOCATED:\n                  return UsePositionHintType::kUnresolved;\n                case InstructionOperand::ALLOCATED:\n                  if (op.IsRegister() || op.IsFPRegister()) {\n                    return UsePositionHintType::kOperand;\n                  } else {\n                    DCHECK(op.IsStackSlot() || op.IsFPStackSlot());\n                    return UsePositionHintType::kNone;\n                  }\n                case InstructionOperand::PENDING:\n                case InstructionOperand::INVALID:\n                  break;\n              }\n              UNREACHABLE();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UsePosition::SetHint\",\n            \"parent\": \"UsePosition\",\n            \"about\": \"Sets the register allocation hint for the UsePosition.\",\n            \"logic\": \"Updates the hint_ and flags_ fields to store the register hint. The hint type is set as UsePos.\",\n            \"parameters\": [\n                {\n                    \"name\": \"use_pos\",\n                    \"type\": \"UsePosition*\",\n                    \"purpose\": \"The UsePosition to use as a hint.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void UsePosition::SetHint(UsePosition* use_pos) {\n              DCHECK_NOT_NULL(use_pos);\n              hint_ = use_pos;\n              flags_ = HintTypeField::update(flags_, UsePositionHintType::kUsePos);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UsePosition::ResolveHint\",\n            \"parent\": \"UsePosition\",\n            \"about\": \"Resolves an unresolved register allocation hint by assigning an actual UsePosition as the hint.\",\n            \"logic\": \"Checks if the hint type is Unresolved and sets the hint_ and flags_ accordingly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"use_pos\",\n                    \"type\": \"UsePosition*\",\n                    \"purpose\": \"The UsePosition to use to resolve the hint.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void UsePosition::ResolveHint(UsePosition* use_pos) {\n              DCHECK_NOT_NULL(use_pos);\n              if (HintTypeField::decode(flags_) != UsePositionHintType::kUnresolved) return;\n              hint_ = use_pos;\n              flags_ = HintTypeField::update(flags_, UsePositionHintType::kUsePos);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UsePosition::set_type\",\n            \"parent\": \"UsePosition\",\n            \"about\": \"Sets the type and register beneficial flag for the UsePosition.\",\n            \"logic\": \"Updates the flags_ field with the specified UsePositionType and register beneficial flag.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"UsePositionType\",\n                    \"purpose\": \"The type of the use position.\"\n                },\n                {\n                    \"name\": \"register_beneficial\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether using a register is beneficial.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void UsePosition::set_type(UsePositionType type, bool register_beneficial) {\n              DCHECK_IMPLIES(type == UsePositionType::kRequiresSlot, !register_beneficial);\n              DCHECK_EQ(kUnassignedRegister, AssignedRegisterField::decode(flags_));\n              flags_ = TypeField::encode(type) |\n                       RegisterBeneficialField::encode(register_beneficial) |\n                       HintTypeField::encode(HintTypeField::decode(flags_)) |\n                       AssignedRegisterField::encode(kUnassignedRegister);\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LifetimePosition\",\n            \"about\": \"Represents a position within the instruction sequence, used for lifetime analysis.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct LifetimePosition {\n              enum class PositionType { kGap, kInstruction };\n              // Flags layout:\n              //  31                                                        0\n              //  +---+-----------------------------------------------------+\n              //  |   |                Instruction Index                    |\n              //  |   |                                                     |\n              //  +---+-----------------------------------------------------+\n              //      30 bits\n              enum InstructionIndexField : BitField<int, 0, 30> {};\n              enum TypeField : BitField<PositionType, 30, 1> {};\n              static constexpr int kMaxInt = InstructionIndexField::kMax;\n\n              bool IsValid() const { return value_ != kMaxInt; }\n              bool IsGapPosition() const { return TypeField::decode(value_) == PositionType::kGap; }\n              bool IsInstructionPosition() const {\n                return TypeField::decode(value_) == PositionType::kInstruction;\n              }\n              bool IsFullStart() const {\n                return !IsGapPosition() || ((value_ % 3) == 0);\n              }\n              bool IsStart() const { return !IsGapPosition() || ((value_ % 3) != 2); }\n              PositionType type() const { return TypeField::decode(value_); }\n\n              int ToInstructionIndex() const {\n                DCHECK(IsValid());\n                return InstructionIndexField::decode(value_);\n              }\n\n              LifetimePosition NextStart() const {\n                return IsGapPosition() ? LifetimePosition(value_ + 1)\n                                       : LifetimePosition(value_ + 2);\n              }\n\n              LifetimePosition End() const {\n                return IsGapPosition() ? LifetimePosition(value_ + 1)\n                                       : LifetimePosition(value_ + 1);\n              }\n\n              LifetimePosition Start() const {\n                return IsGapPosition() ? LifetimePosition(value_) : LifetimePosition(value_ - 1);\n              }\n\n              LifetimePosition PrevStart() const {\n                return IsGapPosition() ? LifetimePosition(value_ - 1)\n                                       : LifetimePosition(value_ - 2);\n              }\n\n              LifetimePosition NextFullStart() const {\n                return IsGapPosition() ? LifetimePosition((value_ + 3 - (value_ % 3)))\n                                       : LifetimePosition(value_ + 2);\n              }\n              // Get position of the gap for a given instruction. Each instruction\n              // can have the gap before (position 0), and the gap after (position 1).\n              static LifetimePosition GapFromInstructionIndex(int index) {\n                DCHECK_GE(index, 0);\n                return LifetimePosition(index * 3);\n              }\n              // Get the lifetime position for an instruction. Note that it can't\n              // be 0 (because lifetime positions must be either a gap, or\n              // an instruction with a gap either side).\n              static LifetimePosition InstructionFromInstructionIndex(int index) {\n                DCHECK_GE(index, 0);\n                return LifetimePosition(index * 3 + 1);\n              }\n\n              bool operator<(const LifetimePosition& other) const {\n                return value_ < other.value_;\n              }\n              bool operator<=(const LifetimePosition& other) const {\n                return value_ <= other.value_;\n              }\n              bool operator>(const LifetimePosition& other) const {\n                return value_ > other.value_;\n              }\n              bool operator>=(const LifetimePosition& other) const {\n                return value_ >= other.value_;\n              }\n              bool operator==(const LifetimePosition& other) const {\n                return value_ == other.value_;\n              }\n              bool operator!=(const LifetimePosition& other) const {\n                return value_ != other.value_;\n              }\n              int value() const { return value_; }\n\n              LifetimePosition NextStartBlock() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n              LifetimePosition NextStartEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 2);\n              }\n\n              LifetimePosition NextStartFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 3);\n              }\n              LifetimePosition NextStartEndFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 4);\n              }\n\n              LifetimePosition NextStart() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n              LifetimePosition InvalidValue() const {\n                return LifetimePosition(kMaxInt);\n              }\n\n              LifetimePosition NextStartFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 3);\n              }\n              LifetimePosition NextStartEndFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 4);\n              }\n\n              LifetimePosition NextStartEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 2);\n              }\n              LifetimePosition NextStartInstructionEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 3);\n              }\n              LifetimePosition NextStartNextStartInstructionEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 4);\n              }\n              LifetimePosition NextStartNextStartInstructionEndNextFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 5);\n              }\n              LifetimePosition NextEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 2);\n              }\n\n              LifetimePosition NextStart() const {\n                return LifetimePosition(ToInstructionIndex() + 2);\n              }\n              LifetimePosition NextEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 2);\n              }\n              LifetimePosition NextFullStart() const {\n                return LifetimePosition(ToInstructionIndex() + 3);\n              }\n\n              LifetimePosition NextStartNextFullStart() const {\n                return LifetimePosition(ToInstructionIndex() + 4);\n              }\n\n              LifetimePosition NextInstructionEndNextFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 5);\n              }\n              LifetimePosition NextFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 4);\n              }\n              LifetimePosition NextEndNextFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 5);\n              }\n              LifetimePosition PreviousInstruction() const {\n                return LifetimePosition(ToInstructionIndex() - 1);\n              }\n              LifetimePosition PreviousPreviousInstruction() const {\n                return LifetimePosition(ToInstructionIndex() - 2);\n              }\n\n              LifetimePosition NextEndInstructionPreviousStart() const {\n                return LifetimePosition(ToInstructionIndex() + 2);\n              }\n              LifetimePosition PreviousStartPreviousInstruction() const {\n                return LifetimePosition(ToInstructionIndex() - 2);\n              }\n\n              friend std::ostream& operator<<(std::ostream& os,\n                                              const LifetimePosition& pos) {\n                os << \"pos=\" << pos.value_;\n                if (pos.IsGapPosition()) {\n                  os << \"(gap)\";\n                } else {\n                  os << \"(instr)\";\n                }\n                return os;\n              }\n\n              LifetimePosition NextStartPrevFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n\n              LifetimePosition PreviousStartBlock() const {\n                return LifetimePosition(ToInstructionIndex() - 1);\n              }\n              LifetimePosition NextEndPrevFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 2);\n              }\n              LifetimePosition PrevFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n              LifetimePosition NextStartNextStart() const {\n                return LifetimePosition(ToInstructionIndex() + 3);\n              }\n              LifetimePosition PrevEnd() const {\n                return LifetimePosition(ToInstructionIndex() - 2);\n              }\n              LifetimePosition NextPrevPrevPrev() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n              LifetimePosition NextPrevPrevPrevPrev() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n              LifetimePosition NextPrevFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n              LifetimePosition NextFullPrevFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n              LifetimePosition PrevEndFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() - 2);\n              }\n              LifetimePosition NextInstructionPrevFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 2);\n              }\n              LifetimePosition InstructionPrevFullEnd() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n              LifetimePosition NextNextStart() const {\n                return LifetimePosition(ToInstructionIndex() + 4);\n              }\n              LifetimePosition PreviousStartInstructionEnd() const {\n                return LifetimePosition(ToInstructionIndex() - 1);\n              }\n              LifetimePosition NextGapPrevNext() const {\n                return LifetimePosition(ToInstructionIndex() + 1);\n              }\n              LifetimePosition PrevGapGap() const {\n                return LifetimePosition(ToInstructionIndex() - 3);\n              }\n              LifetimePosition PrevPrevGap() const {\n                return LifetimePosition(ToInstructionIndex() - 3);\n              }\n\n              static LifetimePosition Invalid() { return LifetimePosition(kMaxInt); }\n            private:\n              explicit LifetimePosition(int value) : value_(value) {}\n              int value_;\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"LifetimePosition::Print\",\n            \"parent\": \"LifetimePosition\",\n            \"about\": \"Prints a LifetimePosition to the standard output.\",\n            \"logic\": \"Prints the LifetimePosition object to the standard output stream.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void LifetimePosition::Print() const { StdoutStream{} << *this << std::endl; }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"LiveRange\",\n            \"about\": \"Represents the lifetime of a virtual register.\",\n            \"attributes\": [\n                {\n                    \"name\": \"relative_id_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Relative identifier of the live range.\"\n                },\n                {\n                    \"name\": \"bits_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Bitfield containing information about the live range.\"\n                },\n                {\n                    \"name\": \"intervals_\",\n                    \"type\": \"UseIntervalVector\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of UseIntervals representing the live range.\"\n                },\n                {\n                    \"name\": \"positions_span_\",\n                    \"type\": \"UsePositionVector::vector_type\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of UsePositions representing the uses of the live range.\"\n                },\n                {\n                    \"name\": \"top_level_\",\n                    \"type\": \"TopLevelLiveRange*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the top-level live range this live range belongs to.\"\n                },\n                {\n                    \"name\": \"next_\",\n                    \"type\": \"LiveRange*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the next live range in a chain (used for splitting).\"\n                },\n                {\n                    \"name\": \"current_interval_\",\n                    \"type\": \"UseIntervalVector::iterator\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Iterator for tracking the current interval during searches.\"\n                },\n                {\n                    \"name\": \"start_\",\n                    \"type\": \"LifetimePosition\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Start position of the live range. Is not always the same as the start of first use interval.\"\n                },\n                {\n                    \"name\": \"end_\",\n                    \"type\": \"LifetimePosition\",\n                    \"access\": \"private\",\n                    \"purpose\": \"End position of the live range.\"\n                },\n                {\n                    \"name\": \"current_hint_position_index_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Cached index in UsePosition list for faster hint lookups.\"\n                },\n                {\n                    \"name\": \"next_start_\",\n                    \"type\": \"LifetimePosition\",\n                    \"access\": \"mutable private\",\n                    \"purpose\": \"Cached next interval start for faster lookups.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class LiveRange {\n             public:\n              LiveRange(int relative_id, MachineRepresentation rep,\n                        TopLevelLiveRange* top_level);\n              static std::less<LiveRange*> LiveRangeOrdering() {\n                return [](const LiveRange* a, const LiveRange* b) {\n                  return a->Start() < b->Start();\n                };\n              }\n\n              ~LiveRange() = default;\n\n              // Flags layout:\n              //  31                                                                   0\n              //  +---+---------------------+----------+----------+----------+----------+\n              //  |   | Control Flow Hint   |  Spilled |Aliasing |    Rep   | Assigned |\n              //  |   |                     |          |   Kind   |          | Register |\n              //  +---+---------------------+----------+----------+----------+----------+\n              //      8 bits               1 bit      2"
}