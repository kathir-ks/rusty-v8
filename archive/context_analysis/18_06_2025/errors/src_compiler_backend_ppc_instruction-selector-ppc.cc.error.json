{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ppc/instruction-selector-ppc.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/ppc/instruction-selector-ppc.cc\",\n        \"file_name\": \"instruction-selector-ppc.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the PPC-specific instruction selector.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for the instruction selector implementation, base utilities, compiler components, turboshaft optimizations, execution frame constants, and root table access.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/iterator.h\"\n#include \"src/compiler/backend/instruction-selector-impl.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n#include \"src/execution/ppc/frame-constants-ppc.h\"\n#include \"src/roots/roots-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PPCOperandGeneratorT\",\n            \"extends\": \"OperandGeneratorT\",\n            \"about\": \"Adds PPC-specific methods for generating operands, including immediate value checks.\"\n        }\n        </metadata>\n        <code><![CDATA[\nclass PPCOperandGeneratorT final : public OperandGeneratorT {\n public:\n  explicit PPCOperandGeneratorT(InstructionSelectorT* selector)\n      : OperandGeneratorT(selector) {}\n\n  InstructionOperand UseOperand(OpIndex node, ImmediateMode mode) {\n    if (CanBeImmediate(node, mode)) {\n      return UseImmediate(node);\n    }\n    return UseRegister(node);\n  }\n\n  bool CanBeImmediate(OpIndex node, ImmediateMode mode) {\n    const ConstantOp* constant = selector()->Get(node).TryCast<ConstantOp>();\n    if (!constant) return false;\n    if (constant->kind == ConstantOp::Kind::kCompressedHeapObject) {\n      if (!COMPRESS_POINTERS_BOOL) return false;\n      // For builtin code we need static roots\n      if (selector()->isolate()->bootstrapper() && !V8_STATIC_ROOTS_BOOL) {\n        return false;\n      }\n      const RootsTable& roots_table = selector()->isolate()->roots_table();\n      RootIndex root_index;\n      Handle<HeapObject> value = constant->handle();\n      if (roots_table.IsRootHandle(value, &root_index)) {\n        if (!RootsTable::IsReadOnly(root_index)) return false;\n        return CanBeImmediate(MacroAssemblerBase::ReadOnlyRootPtr(\n                                  root_index, selector()->isolate()),\n                              mode);\n      }\n      return false;\n    }\n\n    int64_t value;\n    if (!selector()->MatchSignedIntegralConstant(node, &value)) return false;\n    return CanBeImmediate(value, mode);\n  }\n\n  bool CanBeImmediate(int64_t value, ImmediateMode mode) {\n    switch (mode) {\n      case kInt16Imm:\n        return is_int16(value);\n      case kInt16Imm_Unsigned:\n        return is_uint16(value);\n      case kInt16Imm_Negate:\n        return is_int16(-value);\n      case kInt16Imm_4ByteAligned:\n        return is_int16(value) && !(value & 3);\n      case kShift32Imm:\n        return 0 <= value && value < 32;\n      case kInt34Imm:\n        return is_int34(value);\n      case kShift64Imm:\n        return 0 <= value && value < 64;\n      case kNoImmediate:\n        return false;\n    }\n    return false;\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRR\",\n            \"about\": \"Emits an instruction with two register operands (RR format).\",\n            \"logic\": \"Generates operands for the destination and source registers and then emits the instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PPCOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRR(InstructionSelectorT* selector, InstructionCode opcode,\n             OpIndex node) {\n  PPCOperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRR\",\n            \"about\": \"Emits an instruction with three register operands (RRR format).\",\n            \"logic\": \"Generates operands for the destination and two source registers and emits the instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PPCOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRRR(InstructionSelectorT* selector, InstructionCode opcode,\n              OpIndex node) {\n  PPCOperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)),\n                 g.UseRegister(selector->input_at(node, 1)));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitRRO\",\n            \"about\": \"Emits an instruction with two register operands and one immediate operand (RRO format).\",\n            \"logic\": \"Generates operands for the destination register, source register, and immediate, and emits the instruction. Determines if the immediate is valid based on the provided mode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"operand_mode\",\n                    \"type\": \"ImmediateMode\",\n                    \"purpose\": \"The immediate mode to check for validity.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PPCOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitRRO(InstructionSelectorT* selector, InstructionCode opcode,\n              OpIndex node, ImmediateMode operand_mode) {\n  PPCOperandGeneratorT g(selector);\n  selector->Emit(opcode, g.DefineAsRegister(node),\n                 g.UseRegister(selector->input_at(node, 0)),\n                 g.UseOperand(selector->input_at(node, 1), operand_mode));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitTryTruncateDouble\",\n            \"about\": \"Emits an instruction for trying to truncate a double to an integer.\",\n            \"logic\": \"Handles optional success output based on a projection node, emitting the opcode with the correct input and output operands.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the truncate operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PPCOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitTryTruncateDouble(InstructionSelectorT* selector,\n                            InstructionCode opcode, OpIndex node) {\n  PPCOperandGeneratorT g(selector);\n  InstructionOperand inputs[] = {g.UseRegister(selector->input_at(node, 0))};\n  InstructionOperand outputs[2];\n  size_t output_count = 0;\n  outputs[output_count++] = g.DefineAsRegister(node);\n\n  OptionalOpIndex success_output = selector->FindProjection(node, 1);\n  if (success_output.valid()) {\n    outputs[output_count++] = g.DefineAsRegister(success_output.value());\n  }\n\n  selector->Emit(opcode, output_count, outputs, 1, inputs);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Shared routine for emitting binary operations, handling deoptimization.\",\n            \"logic\": \"Generates operands and emits the instruction with continuation. Handles cases where deoptimization is possible, ensuring correct input/output register assignments.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"operand_mode\",\n                    \"type\": \"ImmediateMode\",\n                    \"purpose\": \"The immediate mode for the second operand.\"\n                },\n                {\n                    \"name\": \"cont\",\n                    \"type\": \"FlagsContinuationT*\",\n                    \"purpose\": \"Flags continuation object\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PPCOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                InstructionCode opcode, ImmediateMode operand_mode,\n                FlagsContinuationT* cont) {\n  PPCOperandGeneratorT g(selector);\n  InstructionOperand inputs[4];\n  size_t input_count = 0;\n  InstructionOperand outputs[2];\n  size_t output_count = 0;\n\n  inputs[input_count++] = g.UseRegister(selector->input_at(node, 0));\n  inputs[input_count++] =\n      g.UseOperand(selector->input_at(node, 1), operand_mode);\n\n  if (cont->IsDeoptimize()) {\n    // If we can deoptimize as a result of the binop, we need to make sure that\n    // the deopt inputs are not overwritten by the binop result. One way\n    // to achieve that is to declare the output register as same-as-first.\n    outputs[output_count++] = g.DefineSameAsFirst(node);\n  } else {\n    outputs[output_count++] = g.DefineAsRegister(node);\n  }\n\n  DCHECK_NE(0u, input_count);\n  DCHECK_NE(0u, output_count);\n  DCHECK_GE(arraysize(inputs), input_count);\n  DCHECK_GE(arraysize(outputs), output_count);\n\n  selector->EmitWithContinuation(opcode, output_count, outputs, input_count,\n                                 inputs, cont);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitBinop\",\n            \"about\": \"Overloaded shared routine for emitting binary operations without flags continuation.\",\n            \"logic\": \"Calls the main VisitBinop function with a default FlagsContinuationT object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the operation.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction opcode.\"\n                },\n                {\n                    \"name\": \"operand_mode\",\n                    \"type\": \"ImmediateMode\",\n                    \"purpose\": \"The immediate mode for the second operand.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FlagsContinuationT\",\n                \"VisitBinop\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitBinop(InstructionSelectorT* selector, OpIndex node,\n                InstructionCode opcode, ImmediateMode operand_mode) {\n  FlagsContinuationT cont;\n  VisitBinop(selector, node, opcode, operand_mode, &cont);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitStackSlot\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for stack slot access.\",\n            \"logic\": \"Allocates a spill slot on the stack and emits an instruction to access it.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the stack slot.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitStackSlot(OpIndex node) {\n  const StackSlotOp& stack_slot = Cast<StackSlotOp>(node);\n  int slot = frame_->AllocateSpillSlot(stack_slot.size, stack_slot.alignment,\n                                       stack_slot.is_tagged);\n  OperandGenerator g(this);\n\n  Emit(kArchStackSlot, g.DefineAsRegister(node),\n       sequence()->AddImmediate(Constant(slot)), 0, nullptr);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitAbortCSADcheck\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for aborting a CSAD check.\",\n            \"logic\": \"Emits an instruction to abort a CSAD check.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the abort operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PPCOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitAbortCSADcheck(OpIndex node) {\n  PPCOperandGeneratorT g(this);\n  Emit(kArchAbortCSADcheck, g.NoOutput(),\n       g.UseFixed(this->input_at(node, 0), r4));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SelectLoadOpcode\",\n            \"about\": \"Selects the appropriate load opcode based on memory and register representations.\",\n            \"logic\": \"Determines the correct load instruction based on the data type being loaded from memory and the register type, adjusting the immediate mode as needed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"loaded_rep\",\n                    \"type\": \"MemoryRepresentation\",\n                    \"purpose\": \"The memory representation of the value being loaded.\"\n                },\n                {\n                    \"name\": \"result_rep\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The register representation of the value after loading.\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"ImmediateMode*\",\n                    \"purpose\": \"Pointer to the immediate mode to be used for addressing.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ArchOpcode\",\n                \"description\": \"The appropriate architecture opcode for the load operation.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nArchOpcode SelectLoadOpcode(MemoryRepresentation loaded_rep,\n                            RegisterRepresentation result_rep,\n                            ImmediateMode* mode) {\n  // NOTE: The meaning of `loaded_rep` = `MemoryRepresentation::AnyTagged()` is\n  // we are loading a compressed tagged field, while `result_rep` =\n  // `RegisterRepresentation::Tagged()` refers to an uncompressed tagged value.\n  if (CpuFeatures::IsSupported(PPC_10_PLUS)) {\n    *mode = kInt34Imm;\n  } else {\n    *mode = kInt16Imm;\n  }\n  switch (loaded_rep) {\n    case MemoryRepresentation::Int8():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kPPC_LoadWordS8;\n    case MemoryRepresentation::Uint8():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kPPC_LoadWordU8;\n    case MemoryRepresentation::Int16():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kPPC_LoadWordS16;\n    case MemoryRepresentation::Uint16():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kPPC_LoadWordU16;\n    case MemoryRepresentation::Int32():\n    case MemoryRepresentation::Uint32():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kPPC_LoadWordU32;\n    case MemoryRepresentation::Int64():\n    case MemoryRepresentation::Uint64():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word64());\n      if (*mode != kInt34Imm) *mode = kInt16Imm_4ByteAligned;\n      return kPPC_LoadWord64;\n    case MemoryRepresentation::Float16():\n      UNIMPLEMENTED();\n    case MemoryRepresentation::Float32():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Float32());\n      return kPPC_LoadFloat32;\n    case MemoryRepresentation::Float64():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Float64());\n      return kPPC_LoadDouble;\n#ifdef V8_COMPRESS_POINTERS\n    case MemoryRepresentation::AnyTagged():\n    case MemoryRepresentation::TaggedPointer():\n      if (result_rep == RegisterRepresentation::Compressed()) {\n        if (*mode != kInt34Imm) *mode = kInt16Imm_4ByteAligned;\n        return kPPC_LoadWordS32;\n      }\n      DCHECK_EQ(result_rep, RegisterRepresentation::Tagged());\n      return kPPC_LoadDecompressTagged;\n    case MemoryRepresentation::TaggedSigned():\n      if (result_rep == RegisterRepresentation::Compressed()) {\n        if (*mode != kInt34Imm) *mode = kInt16Imm_4ByteAligned;\n        return kPPC_LoadWordS32;\n      }\n      DCHECK_EQ(result_rep, RegisterRepresentation::Tagged());\n      return kPPC_LoadDecompressTaggedSigned;\n#else\n      USE(result_rep);\n    case MemoryRepresentation::AnyTagged():\n    case MemoryRepresentation::TaggedPointer():\n    case MemoryRepresentation::TaggedSigned():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Tagged());\n      if (*mode != kInt34Imm) *mode = kInt16Imm_4ByteAligned;\n      return kPPC_LoadWord64;\n#endif\n    case MemoryRepresentation::AnyUncompressedTagged():\n    case MemoryRepresentation::UncompressedTaggedPointer():\n    case MemoryRepresentation::UncompressedTaggedSigned():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Tagged());\n      if (*mode != kInt34Imm) *mode = kInt16Imm_4ByteAligned;\n      return kPPC_LoadWord64;\n    case MemoryRepresentation::SandboxedPointer():\n      return kPPC_LoadDecodeSandboxedPointer;\n    case MemoryRepresentation::Simd128():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Simd128());\n      // Vectors do not support MRI mode, only MRR is available.\n      *mode = kNoImmediate;\n      return kPPC_LoadSimd128;\n    case MemoryRepresentation::ProtectedPointer():\n    case MemoryRepresentation::IndirectPointer():\n    case MemoryRepresentation::Simd256():\n      UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SelectLoadOpcode\",\n            \"about\": \"Selects the appropriate load opcode based on load representation.\",\n            \"logic\": \"Similar to the previous overload but uses LoadRepresentation for type information.\",\n            \"parameters\": [\n                {\n                    \"name\": \"load_rep\",\n                    \"type\": \"LoadRepresentation\",\n                    \"purpose\": \"The load representation, describing the type of data being loaded.\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"ImmediateMode*\",\n                    \"purpose\": \"Pointer to the immediate mode to be used for addressing.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ArchOpcode\",\n                \"description\": \"The appropriate architecture opcode for the load operation.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nArchOpcode SelectLoadOpcode(LoadRepresentation load_rep, ImmediateMode* mode) {\n  if (CpuFeatures::IsSupported(PPC_10_PLUS)) {\n    *mode = kInt34Imm;\n  } else {\n    *mode = kInt16Imm;\n  }\n  switch (load_rep.representation()) {\n    case MachineRepresentation::kFloat32:\n      return kPPC_LoadFloat32;\n    case MachineRepresentation::kFloat64:\n      return kPPC_LoadDouble;\n    case MachineRepresentation::kBit:  // Fall through.\n    case MachineRepresentation::kWord8:\n      return load_rep.IsSigned() ? kPPC_LoadWordS8 : kPPC_LoadWordU8;\n    case MachineRepresentation::kWord16:\n      return load_rep.IsSigned() ? kPPC_LoadWordS16 : kPPC_LoadWordU16;\n    case MachineRepresentation::kWord32:\n      return kPPC_LoadWordU32;\n    case MachineRepresentation::kCompressedPointer:  // Fall through.\n    case MachineRepresentation::kCompressed:\n#ifdef V8_COMPRESS_POINTERS\n      if (*mode != kInt34Imm) *mode = kInt16Imm_4ByteAligned;\n      return kPPC_LoadWordS32;\n#else\n      UNREACHABLE();\n#endif\n      case MachineRepresentation::kIndirectPointer:\n        UNREACHABLE();\n      case MachineRepresentation::kSandboxedPointer:\n        return kPPC_LoadDecodeSandboxedPointer;\n#ifdef V8_COMPRESS_POINTERS\n      case MachineRepresentation::kTaggedSigned:\n        return kPPC_LoadDecompressTaggedSigned;\n      case MachineRepresentation::kTaggedPointer:\n        return kPPC_LoadDecompressTagged;\n      case MachineRepresentation::kTagged:\n        return kPPC_LoadDecompressTagged;\n#else\n      case MachineRepresentation::kTaggedSigned:   // Fall through.\n      case MachineRepresentation::kTaggedPointer:  // Fall through.\n      case MachineRepresentation::kTagged:         // Fall through.\n#endif\n      case MachineRepresentation::kWord64:\n        if (*mode != kInt34Imm) *mode = kInt16Imm_4ByteAligned;\n        return kPPC_LoadWord64;\n      case MachineRepresentation::kSimd128:\n        // Vectors do not support MRI mode, only MRR is available.\n        *mode = kNoImmediate;\n        return kPPC_LoadSimd128;\n      case MachineRepresentation::kFloat16:\n        UNIMPLEMENTED();\n      case MachineRepresentation::kProtectedPointer:  // Fall through.\n      case MachineRepresentation::kSimd256:  // Fall through.\n      case MachineRepresentation::kMapWord:  // Fall through.\n      case MachineRepresentation::kFloat16RawBits:  // Fall through.\n      case MachineRepresentation::kNone:\n        UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitLoadCommon\",\n            \"about\": \"Shared routine for emitting load instructions.\",\n            \"logic\": \"Handles the common parts of load instruction emission, including addressing mode selection (Root, MRI, MRR) and emitting the appropriate instruction based on whether the base and offset can be represented as immediates.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the load operation.\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"ImmediateMode\",\n                    \"purpose\": \"The immediate mode to check for validity.\"\n                },\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The base instruction opcode.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PPCOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic void VisitLoadCommon(InstructionSelectorT* selector, OpIndex node,\n                            ImmediateMode mode, InstructionCode opcode) {\n  PPCOperandGeneratorT g(selector);\n  auto load_view = selector->load_view(node);\n  OpIndex base = load_view.base();\n  OpIndex offset = load_view.index();\n\n  bool is_atomic = load_view.is_atomic();\n\n  if (selector->is_load_root_register(base)) {\n    selector->Emit(opcode |= AddressingModeField::encode(kMode_Root),\n                   g.DefineAsRegister(node), g.UseRegister(offset),\n                   g.UseImmediate(is_atomic));\n  } else if (g.CanBeImmediate(offset, mode)) {\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                   g.DefineAsRegister(node), g.UseRegister(base),\n                   g.UseImmediate(offset), g.UseImmediate(is_atomic));\n  } else if (g.CanBeImmediate(base, mode)) {\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRI),\n                   g.DefineAsRegister(node), g.UseRegister(offset),\n                   g.UseImmediate(base), g.UseImmediate(is_atomic));\n  } else {\n    selector->Emit(opcode | AddressingModeField::encode(kMode_MRR),\n                   g.DefineAsRegister(node), g.UseRegister(base),\n                   g.UseRegister(offset), g.UseImmediate(is_atomic));\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitLoad\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for regular load operations.\",\n            \"logic\": \"Retrieves load representation and result representation, determines the correct opcode, and calls VisitLoadCommon to emit the load instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the load operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"TurboshaftAdapter\",\n                \"SelectLoadOpcode\",\n                \"VisitLoadCommon\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitLoad(OpIndex node) {\n  TurboshaftAdapter::LoadView load_view = this->load_view(node);\n  ImmediateMode mode;\n    InstructionCode opcode = SelectLoadOpcode(load_view.ts_loaded_rep(),\n                                              load_view.ts_result_rep(), &mode);\n    VisitLoadCommon(this, node, mode, opcode);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitProtectedLoad\",\n            \"parent\": \"InstructionSelectorT\",\n            \"about\": \"Selects instructions for protected load operations (unimplemented).\",\n            \"logic\": \"Marks the operation as unimplemented.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the protected load operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid InstructionSelectorT::VisitProtectedLoad(OpIndex node) {\n  // TODO(eholk)\n  UNIMPLEMENTED();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"VisitStoreCommon\",\n            \"about\": \"Shared routine for emitting store instructions.\",\n            \"logic\": \"Handles the common parts of store instruction emission, including determining whether a write barrier is needed, selecting the addressing mode (Root, MRI, MRR), and emitting the appropriate instruction.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node representing the store operation.\"\n                },\n                {\n                    \"name\": \"store_rep\",\n                    \"type\": \"StoreRepresentation\",\n                    \"purpose\": \"The store representation, describing the type of data being stored and write barrier requirements.\"\n                },\n                {\n                    \"name\": \"atomic_order\",\n                    \"type\": \"std::optional<AtomicMemoryOrder>\",\n                    \"purpose\": \"Optional parameter for specifying atomic memory order\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"PPCOperandGeneratorT\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid VisitStoreCommon(InstructionSelectorT* selector, OpIndex node,\n                      StoreRepresentation store_rep,\n                      std::optional<AtomicMemoryOrder> atomic_order) {\n  PPCOperandGeneratorT g(selector);\n  auto store_view = selector->store_view(node);\n  OpIndex base = store_view.base();\n  OpIndex offset = selector->value(store_view.index());\n  OpIndex value = store_view.value();\n  bool is_atomic = store_view.is_atomic();\n\n  MachineRepresentation rep = store_rep.representation();\n  WriteBarrierKind write_barrier_kind = kNoWriteBarrier;\n\n  if (!is_atomic) {\n    write_barrier_kind = store_rep.write_barrier_kind();\n  }\n\n  if (v8_flags.enable_unconditional_write_barriers &&\n      CanBeTaggedOrCompressedOrIndirectPointer(rep)) {\n    write_barrier_kind = kFullWriteBarrier;\n  }\n\n  if (write_barrier_kind != kNoWriteBarrier &&\n      !v8_flags"
}