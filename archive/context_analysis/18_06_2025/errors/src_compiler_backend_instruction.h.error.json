{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/instruction.h\",\n            \"file_name\": \"instruction.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines data structures for representing machine instructions during compilation in the V8 JavaScript engine.  Includes operand types, instruction representations, and related classes for register allocation and code generation.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers and V8-specific headers for data structures, memory management, code generation, and compiler internals.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <iosfwd>\n            #include <map>\n            #include <optional>\n\n            #include \"src/base/compiler-specific.h\"\n            #include \"src/base/numbers/double.h\"\n            #include \"src/codegen/external-reference.h\"\n            #include \"src/codegen/register.h\"\n            #include \"src/codegen/source-position.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/compiler/backend/instruction-codes.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/feedback-source.h\"\n            #include \"src/compiler/frame.h\"\n            #include \"src/compiler/opcodes.h\"\n            #include \"src/zone/zone-allocator.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"InstructionOperand\",\n                \"about\": \"Represents an operand for an instruction.  Can be an unallocated register, a constant, an immediate value, or an allocated register/stack slot.\",\n                \"attributes\": [],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE INSTRUCTION_OPERAND_ALIGN InstructionOperand {\n            public:\n            static const int kInvalidVirtualRegister = -1;\n\n            enum Kind {\n                INVALID,\n                UNALLOCATED,\n                CONSTANT,\n                IMMEDIATE,\n                PENDING,\n                // Location operand kinds.\n                ALLOCATED,\n                FIRST_LOCATION_OPERAND_KIND = ALLOCATED\n                // Location operand kinds must be last.\n            };\n\n            InstructionOperand() : InstructionOperand(INVALID) {}\n\n            Kind kind() const { return KindField::decode(value_); }\n\n            #define INSTRUCTION_OPERAND_PREDICATE(name, type) \\\n            bool Is##name() const { return kind() == type; }\n            INSTRUCTION_OPERAND_PREDICATE(Invalid, INVALID)\n            // UnallocatedOperands are place-holder operands created before register\n            // allocation. They later are assigned registers and become AllocatedOperands.\n            INSTRUCTION_OPERAND_PREDICATE(Unallocated, UNALLOCATED)\n            // Constant operands participate in register allocation. They are allocated to\n            // registers but have a special \"spilling\" behavior. When a ConstantOperand\n            // value must be rematerialized, it is loaded from an immediate constant\n            // rather from an unspilled slot.\n            INSTRUCTION_OPERAND_PREDICATE(Constant, CONSTANT)\n            // ImmediateOperands do not participate in register allocation and are only\n            // embedded directly in instructions, e.g. small integers and on some\n            // platforms Objects.\n            INSTRUCTION_OPERAND_PREDICATE(Immediate, IMMEDIATE)\n            // PendingOperands are pending allocation during register allocation and\n            // shouldn't be seen elsewhere. They chain together multiple operators that\n            // will be replaced together with the same value when finalized.\n            INSTRUCTION_OPERAND_PREDICATE(Pending, PENDING)\n            // AllocatedOperands are registers or stack slots that are assigned by the\n            // register allocator and are always associated with a virtual register.\n            INSTRUCTION_OPERAND_PREDICATE(Allocated, ALLOCATED)\n            #undef INSTRUCTION_OPERAND_PREDICATE\n\n            inline bool IsAnyLocationOperand() const;\n            inline bool IsLocationOperand() const;\n            inline bool IsFPLocationOperand() const;\n            inline bool IsAnyRegister() const;\n            inline bool IsRegister() const;\n            inline bool IsFPRegister() const;\n            inline bool IsFloatRegister() const;\n            inline bool IsDoubleRegister() const;\n            inline bool IsSimd128Register() const;\n            inline bool IsSimd256Register() const;\n            inline bool IsAnyStackSlot() const;\n            inline bool IsStackSlot() const;\n            inline bool IsFPStackSlot() const;\n            inline bool IsFloatStackSlot() const;\n            inline bool IsDoubleStackSlot() const;\n            inline bool IsSimd128StackSlot() const;\n            inline bool IsSimd256StackSlot() const;\n\n            template <typename SubKindOperand>\n            static SubKindOperand* New(Zone* zone, const SubKindOperand& op) {\n                return zone->New<SubKindOperand>(op);\n            }\n\n            static void ReplaceWith(InstructionOperand* dest,\n                                    const InstructionOperand* src) {\n                *dest = *src;\n            }\n\n            bool Equals(const InstructionOperand& that) const {\n                if (IsPending()) {\n                // Pending operands are only equal if they are the same operand.\n                return this == &that;\n                }\n                return this->value_ == that.value_;\n            }\n\n            bool Compare(const InstructionOperand& that) const {\n                return this->value_ < that.value_;\n            }\n\n            bool EqualsCanonicalized(const InstructionOperand& that) const {\n                if (IsPending()) {\n                // Pending operands can't be canonicalized, so just compare for equality.\n                return Equals(that);\n                }\n                return this->GetCanonicalizedValue() == that.GetCanonicalizedValue();\n            }\n\n            bool CompareCanonicalized(const InstructionOperand& that) const {\n                DCHECK(!IsPending());\n                return this->GetCanonicalizedValue() < that.GetCanonicalizedValue();\n            }\n\n            bool InterferesWith(const InstructionOperand& other) const;\n\n            // APIs to aid debugging. For general-stream APIs, use operator<<.\n            void Print() const;\n\n            bool operator==(const InstructionOperand& other) const {\n                return Equals(other);\n            }\n            bool operator!=(const InstructionOperand& other) const {\n                return !Equals(other);\n            }\n\n            protected:\n            explicit InstructionOperand(Kind kind) : value_(KindField::encode(kind)) {}\n\n            inline uint64_t GetCanonicalizedValue() const;\n\n            using KindField = base::BitField64<Kind, 0, 3>;\n\n            uint64_t value_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the << operator for InstructionOperand to enable printing InstructionOperand objects to an output stream.\",\n                \"logic\": \"Uses the Print() method of the InstructionOperand class to generate a string representation of the object.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream.\"\n                    },\n                    {\n                        \"name\": \"operand\",\n                        \"type\": \"const InstructionOperand&\",\n                        \"purpose\": \"The InstructionOperand object to print.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream&, const InstructionOperand&);\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"UnallocatedOperand\",\n                \"extends\": \"InstructionOperand\",\n                \"about\": \"Represents an operand that has not yet been allocated to a physical register or stack slot.  Used during register allocation.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"InstructionOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class UnallocatedOperand final : public InstructionOperand {\n            public:\n            enum BasicPolicy { FIXED_SLOT, EXTENDED_POLICY };\n\n            enum ExtendedPolicy {\n                NONE,\n                REGISTER_OR_SLOT,\n                REGISTER_OR_SLOT_OR_CONSTANT,\n                FIXED_REGISTER,\n                FIXED_FP_REGISTER,\n                MUST_HAVE_REGISTER,\n                MUST_HAVE_SLOT,\n                SAME_AS_INPUT\n            };\n\n            // Lifetime of operand inside the instruction.\n            enum Lifetime {\n                // USED_AT_START operand is guaranteed to be live only at instruction start.\n                // The register allocator is free to assign the same register to some other\n                // operand used inside instruction (i.e. temporary or output).\n                USED_AT_START,\n\n                // USED_AT_END operand is treated as live until the end of instruction.\n                // This means that register allocator will not reuse its register for any\n                // other operand inside instruction.\n                USED_AT_END\n            };\n\n            UnallocatedOperand(ExtendedPolicy policy, int virtual_register)\n                : UnallocatedOperand(virtual_register) {\n                value_ |= BasicPolicyField::encode(EXTENDED_POLICY);\n                value_ |= ExtendedPolicyField::encode(policy);\n                value_ |= LifetimeField::encode(USED_AT_END);\n            }\n\n            UnallocatedOperand(int virtual_register, int input_index)\n                : UnallocatedOperand(virtual_register) {\n                value_ |= BasicPolicyField::encode(EXTENDED_POLICY);\n                value_ |= ExtendedPolicyField::encode(SAME_AS_INPUT);\n                value_ |= LifetimeField::encode(USED_AT_END);\n                value_ |= InputIndexField::encode(input_index);\n            }\n\n            UnallocatedOperand(BasicPolicy policy, int index, int virtual_register)\n                : UnallocatedOperand(virtual_register) {\n                DCHECK(policy == FIXED_SLOT);\n                value_ |= BasicPolicyField::encode(policy);\n                value_ |= static_cast<uint64_t>(static_cast<int64_t>(index))\n                            << FixedSlotIndexField::kShift;\n                DCHECK(this->fixed_slot_index() == index);\n            }\n\n            UnallocatedOperand(ExtendedPolicy policy, int index, int virtual_register)\n                : UnallocatedOperand(virtual_register) {\n                DCHECK(policy == FIXED_REGISTER || policy == FIXED_FP_REGISTER);\n                value_ |= BasicPolicyField::encode(EXTENDED_POLICY);\n                value_ |= ExtendedPolicyField::encode(policy);\n                value_ |= LifetimeField::encode(USED_AT_END);\n                value_ |= FixedRegisterField::encode(index);\n            }\n\n            UnallocatedOperand(ExtendedPolicy policy, Lifetime lifetime,\n                                int virtual_register)\n                : UnallocatedOperand(virtual_register) {\n                value_ |= BasicPolicyField::encode(EXTENDED_POLICY);\n                value_ |= ExtendedPolicyField::encode(policy);\n                value_ |= LifetimeField::encode(lifetime);\n            }\n\n            UnallocatedOperand(int reg_id, int slot_id, int virtual_register)\n                : UnallocatedOperand(FIXED_REGISTER, reg_id, virtual_register) {\n                value_ |= HasSecondaryStorageField::encode(true);\n                value_ |= SecondaryStorageField::encode(slot_id);\n            }\n\n            UnallocatedOperand(const UnallocatedOperand& other, int virtual_register) {\n                DCHECK_NE(kInvalidVirtualRegister, virtual_register);\n                value_ = VirtualRegisterField::update(\n                    other.value_, static_cast<uint32_t>(virtual_register));\n            }\n\n            // Predicates for the operand policy.\n            bool HasRegisterOrSlotPolicy() const {\n                return basic_policy() == EXTENDED_POLICY &&\n                    extended_policy() == REGISTER_OR_SLOT;\n            }\n            bool HasRegisterOrSlotOrConstantPolicy() const {\n                return basic_policy() == EXTENDED_POLICY &&\n                    extended_policy() == REGISTER_OR_SLOT_OR_CONSTANT;\n            }\n            bool HasFixedPolicy() const {\n                return basic_policy() == FIXED_SLOT ||\n                    extended_policy() == FIXED_REGISTER ||\n                    extended_policy() == FIXED_FP_REGISTER;\n            }\n            bool HasRegisterPolicy() const {\n                return basic_policy() == EXTENDED_POLICY &&\n                    extended_policy() == MUST_HAVE_REGISTER;\n            }\n            bool HasSlotPolicy() const {\n                return basic_policy() == EXTENDED_POLICY &&\n                    extended_policy() == MUST_HAVE_SLOT;\n            }\n            bool HasSameAsInputPolicy() const {\n                return basic_policy() == EXTENDED_POLICY &&\n                    extended_policy() == SAME_AS_INPUT;\n            }\n            bool HasFixedSlotPolicy() const { return basic_policy() == FIXED_SLOT; }\n            bool HasFixedRegisterPolicy() const {\n                return basic_policy() == EXTENDED_POLICY &&\n                    extended_policy() == FIXED_REGISTER;\n            }\n            bool HasFixedFPRegisterPolicy() const {\n                return basic_policy() == EXTENDED_POLICY &&\n                    extended_policy() == FIXED_FP_REGISTER;\n            }\n            bool HasSecondaryStorage() const {\n                return basic_policy() == EXTENDED_POLICY &&\n                    extended_policy() == FIXED_REGISTER &&\n                    HasSecondaryStorageField::decode(value_);\n            }\n            int GetSecondaryStorage() const {\n                DCHECK(HasSecondaryStorage());\n                return SecondaryStorageField::decode(value_);\n            }\n\n            // [basic_policy]: Distinguish between FIXED_SLOT and all other policies.\n            BasicPolicy basic_policy() const { return BasicPolicyField::decode(value_); }\n\n            // [extended_policy]: Only for non-FIXED_SLOT. The finer-grained policy.\n            ExtendedPolicy extended_policy() const {\n                DCHECK(basic_policy() == EXTENDED_POLICY);\n                return ExtendedPolicyField::decode(value_);\n            }\n\n            int input_index() const {\n                DCHECK(HasSameAsInputPolicy());\n                return InputIndexField::decode(value_);\n            }\n\n            // [fixed_slot_index]: Only for FIXED_SLOT.\n            int fixed_slot_index() const {\n                DCHECK(HasFixedSlotPolicy());\n                return static_cast<int>(static_cast<int64_t>(value_) >>\n                                        FixedSlotIndexField::kShift);\n            }\n\n            // [fixed_register_index]: Only for FIXED_REGISTER or FIXED_FP_REGISTER.\n            int fixed_register_index() const {\n                DCHECK(HasFixedRegisterPolicy() || HasFixedFPRegisterPolicy());\n                return FixedRegisterField::decode(value_);\n            }\n\n            // [virtual_register]: The virtual register ID for this operand.\n            int32_t virtual_register() const {\n                return static_cast<int32_t>(VirtualRegisterField::decode(value_));\n            }\n\n            // [lifetime]: Only for non-FIXED_SLOT.\n            bool IsUsedAtStart() const {\n                return basic_policy() == EXTENDED_POLICY &&\n                    LifetimeField::decode(value_) == USED_AT_START;\n            }\n\n            INSTRUCTION_OPERAND_CASTS(UnallocatedOperand, UNALLOCATED)\n\n            // The encoding used for UnallocatedOperand operands depends on the policy\n            // that is\n            // stored within the operand. The FIXED_SLOT policy uses a compact encoding\n            // because it accommodates a larger pay-load.\n            //\n            // For FIXED_SLOT policy:\n            //     +------------------------------------------------+\n            //     |      slot_index   | 0 | virtual_register | 001 |\n            //     +------------------------------------------------+\n            //\n            // For all other (extended) policies:\n            //     +-----------------------------------------------------+\n            //     |  reg_index  | L | PPP |  1 | virtual_register | 001 |\n            //     +-----------------------------------------------------+\n            //     L ... Lifetime\n            //     P ... Policy\n            //\n            // The slot index is a signed value which requires us to decode it manually\n            // instead of using the base::BitField utility class.\n\n            using VirtualRegisterField = KindField::Next<uint32_t, 32>;\n\n            // base::BitFields for all unallocated operands.\n            using BasicPolicyField = VirtualRegisterField::Next<BasicPolicy, 1>;\n\n            // BitFields specific to BasicPolicy::FIXED_SLOT.\n            using FixedSlotIndexField = BasicPolicyField::Next<int, 28>;\n            static_assert(FixedSlotIndexField::kLastUsedBit == 63);\n\n            // BitFields specific to BasicPolicy::EXTENDED_POLICY.\n            using ExtendedPolicyField = BasicPolicyField::Next<ExtendedPolicy, 3>;\n            using LifetimeField = ExtendedPolicyField::Next<Lifetime, 1>;\n            using HasSecondaryStorageField = LifetimeField::Next<bool, 1>;\n            using FixedRegisterField = HasSecondaryStorageField::Next<int, 6>;\n            using SecondaryStorageField = FixedRegisterField::Next<int, 3>;\n            using InputIndexField = SecondaryStorageField::Next<int, 3>;\n\n            private:\n            explicit UnallocatedOperand(int virtual_register)\n                : InstructionOperand(UNALLOCATED) {\n                value_ |=\n                    VirtualRegisterField::encode(static_cast<uint32_t>(virtual_register));\n            }\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ConstantOperand\",\n                \"extends\": \"InstructionOperand\",\n                \"about\": \"Represents an operand that is a constant value.  These operands participate in register allocation but are re-materialized instead of spilled to memory.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"InstructionOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class ConstantOperand : public InstructionOperand {\n            public:\n            explicit ConstantOperand(int virtual_register)\n                : InstructionOperand(CONSTANT) {\n                value_ |=\n                    VirtualRegisterField::encode(static_cast<uint32_t>(virtual_register));\n            }\n\n            int32_t virtual_register() const {\n                return static_cast<int32_t>(VirtualRegisterField::decode(value_));\n            }\n\n            static ConstantOperand* New(Zone* zone, int virtual_register) {\n                return InstructionOperand::New(zone, ConstantOperand(virtual_register));\n            }\n\n            INSTRUCTION_OPERAND_CASTS(ConstantOperand, CONSTANT)\n\n            using VirtualRegisterField = KindField::Next<uint32_t, 32>;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ImmediateOperand\",\n                \"extends\": \"InstructionOperand\",\n                \"about\": \"Represents an operand that is an immediate value (e.g., a small integer).  These operands do not participate in register allocation.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"InstructionOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class ImmediateOperand : public InstructionOperand {\n            public:\n            enum ImmediateType { INLINE_INT32, INLINE_INT64, INDEXED_RPO, INDEXED_IMM };\n\n            explicit ImmediateOperand(ImmediateType type, int32_t value)\n                : InstructionOperand(IMMEDIATE) {\n                value_ |= TypeField::encode(type);\n                value_ |= static_cast<uint64_t>(static_cast<int64_t>(value))\n                            << ValueField::kShift;\n            }\n\n            ImmediateType type() const { return TypeField::decode(value_); }\n\n            int32_t inline_int32_value() const {\n                DCHECK_EQ(INLINE_INT32, type());\n                return static_cast<int64_t>(value_) >> ValueField::kShift;\n            }\n\n            int64_t inline_int64_value() const {\n                DCHECK_EQ(INLINE_INT64, type());\n                return static_cast<int64_t>(value_) >> ValueField::kShift;\n            }\n\n            int32_t indexed_value() const {\n                DCHECK(type() == INDEXED_IMM || type() == INDEXED_RPO);\n                return static_cast<int64_t>(value_) >> ValueField::kShift;\n            }\n\n            static ImmediateOperand* New(Zone* zone, ImmediateType type, int32_t value) {\n                return InstructionOperand::New(zone, ImmediateOperand(type, value));\n            }\n\n            INSTRUCTION_OPERAND_CASTS(ImmediateOperand, IMMEDIATE)\n\n            using TypeField = KindField::Next<ImmediateType, 2>;\n            static_assert(TypeField::kLastUsedBit < 32);\n            using ValueField = base::BitField64<int32_t, 32, 32>;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PendingOperand\",\n                \"extends\": \"InstructionOperand\",\n                \"about\": \"Represents an operand that is pending allocation during register allocation.  Chains together multiple operators that will be replaced together with the same value when finalized.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"InstructionOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class PendingOperand : public InstructionOperand {\n            public:\n            PendingOperand() : InstructionOperand(PENDING) {}\n            explicit PendingOperand(PendingOperand* next_operand) : PendingOperand() {\n                set_next(next_operand);\n            }\n\n            void set_next(PendingOperand* next) {\n                DCHECK_NULL(this->next());\n                uintptr_t shifted_value =\n                    reinterpret_cast<uintptr_t>(next) >> kPointerShift;\n                DCHECK_EQ(reinterpret_cast<uintptr_t>(next),\n                        shifted_value << kPointerShift);\n                value_ |= NextOperandField::encode(static_cast<uint64_t>(shifted_value));\n            }\n\n            PendingOperand* next() const {\n                uintptr_t shifted_value =\n                    static_cast<uint64_t>(NextOperandField::decode(value_));\n                return reinterpret_cast<PendingOperand*>(shifted_value << kPointerShift);\n            }\n\n            static PendingOperand* New(Zone* zone, PendingOperand* previous_operand) {\n                return InstructionOperand::New(zone, PendingOperand(previous_operand));\n            }\n\n            INSTRUCTION_OPERAND_CASTS(PendingOperand, PENDING)\n\n            private:\n            // Operands are uint64_t values and so are aligned to 8 byte boundaries,\n            // therefore we can shift off the bottom three zeros without losing data.\n            static const uint64_t kPointerShift = 3;\n            static_assert(alignof(InstructionOperand) >= (1 << kPointerShift));\n\n            using NextOperandField = KindField::Next<uint64_t, 61>;\n            static_assert(NextOperandField::kLastUsedBit == 63);\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocationOperand\",\n                \"extends\": \"InstructionOperand\",\n                \"about\": \"Represents an operand that has a specific location (register or stack slot). Base class for AllocatedOperand.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"InstructionOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class LocationOperand : public InstructionOperand {\n            public:\n            enum LocationKind { REGISTER, STACK_SLOT };\n\n            LocationOperand(InstructionOperand::Kind operand_kind,\n                            LocationOperand::LocationKind location_kind,\n                            MachineRepresentation rep, int index)\n                : InstructionOperand(operand_kind) {\n                DCHECK_IMPLIES(location_kind == REGISTER, index >= 0);\n                DCHECK(IsSupportedRepresentation(rep));\n                value_ |= LocationKindField::encode(location_kind);\n                value_ |= RepresentationField::encode(rep);\n                value_ |= static_cast<uint64_t>(static_cast<int64_t>(index))\n                            << IndexField::kShift;\n            }\n\n            int index() const {\n                DCHECK(IsStackSlot() || IsFPStackSlot());\n                return static_cast<int64_t>(value_) >> IndexField::kShift;\n            }\n\n            int register_code() const {\n                DCHECK(IsRegister() || IsFPRegister());\n                return static_cast<int64_t>(value_) >> IndexField::kShift;\n            }\n\n            Register GetRegister() const {\n                DCHECK(IsRegister());\n                return Register::from_code(register_code());\n            }\n\n            FloatRegister GetFloatRegister() const {\n                DCHECK(IsFloatRegister());\n                return FloatRegister::from_code(register_code());\n            }\n\n            DoubleRegister GetDoubleRegister() const {\n                // On platforms where FloatRegister, DoubleRegister, and Simd128Register\n                // are all the same type, it's convenient to treat everything as a\n                // DoubleRegister, so be lax about type checking here.\n                DCHECK(IsFPRegister());\n                return DoubleRegister::from_code(register_code());\n            }\n\n            Simd128Register GetSimd128Register() const {\n                DCHECK(IsSimd128Register());\n                return Simd128Register::from_code(register_code());\n            }\n\n            #if defined(V8_TARGET_ARCH_X64)\n            // On x64, Simd256 and Simd128 share the identical register.\n            Simd128Register GetSimd256RegisterAsSimd128() const {\n                DCHECK(IsSimd256Register());\n                return Simd128Register::from_code(register_code());\n            }\n\n            Simd256Register GetSimd256Register() const {\n                DCHECK(IsSimd256Register());\n                return Simd256Register::from_code(register_code());\n            }\n            #endif\n\n            LocationKind location_kind() const {\n                return LocationKindField::decode(value_);\n            }\n\n            MachineRepresentation representation() const {\n                return RepresentationField::decode(value_);\n            }\n\n            static bool IsSupportedRepresentation(MachineRepresentation rep) {\n                switch (rep) {\n                case MachineRepresentation::kWord32:\n                case MachineRepresentation::kWord64:\n                case MachineRepresentation::kFloat32:\n                case MachineRepresentation::kFloat64:\n                case MachineRepresentation::kSimd128:\n                case MachineRepresentation::kSimd256:\n                case MachineRepresentation::kTaggedSigned:\n                case MachineRepresentation::kTaggedPointer:\n                case MachineRepresentation::kTagged:\n                case MachineRepresentation::kCompressedPointer:\n                case MachineRepresentation::kCompressed:\n                case MachineRepresentation::kProtectedPointer:\n                case MachineRepresentation::kSandboxedPointer:\n                    return true;\n                case MachineRepresentation::kBit:\n                case MachineRepresentation::kWord8:\n                case MachineRepresentation::kWord16:\n                case MachineRepresentation::kFloat16:\n                case MachineRepresentation::kNone:\n                    return false;\n                case MachineRepresentation::kMapWord:\n                case MachineRepresentation::kIndirectPointer:\n                case MachineRepresentation::kFloat16RawBits:\n                    UNREACHABLE();\n                }\n            }\n\n            // Return true if the locations can be moved to one another.\n            bool IsCompatible(LocationOperand* op);\n\n            static LocationOperand* cast(InstructionOperand* op) {\n                DCHECK(op->IsAnyLocationOperand());\n                return static_cast<LocationOperand*>(op);\n            }\n\n            static const LocationOperand* cast(const InstructionOperand* op) {\n                DCHECK(op->IsAnyLocationOperand());\n                return static_cast<const LocationOperand*>(op);\n            }\n\n            static LocationOperand cast(const InstructionOperand& op) {\n                DCHECK(op->IsAnyLocationOperand());\n                return *static_cast<const LocationOperand*>(&op);\n            }\n\n            using LocationKindField = KindField::Next<LocationKind, 1>;\n            using RepresentationField = LocationKindField::Next<MachineRepresentation, 8>;\n            static_assert(RepresentationField::kLastUsedBit < 32);\n            using IndexField = base::BitField64<int32_t, 32, 32>;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AllocatedOperand\",\n                \"extends\": \"LocationOperand\",\n                \"about\": \"Represents an operand that has been allocated to a specific register or stack slot.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"LocationOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class AllocatedOperand : public LocationOperand {\n            public:\n            AllocatedOperand(LocationKind kind, MachineRepresentation rep, int index)\n                : LocationOperand(ALLOCATED, kind, rep, index) {}\n\n            static AllocatedOperand* New(Zone* zone, LocationKind kind,\n                                        MachineRepresentation rep, int index) {\n                return InstructionOperand::New(zone, AllocatedOperand(kind, rep, index));\n            }\n\n            INSTRUCTION_OPERAND_CASTS(AllocatedOperand, ALLOCATED)\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsAnyLocationOperand\",\n                \"parent\": \"InstructionOperand\",\n                \"about\": \"Checks if the operand is any kind of location (register or stack slot).\",\n                \"logic\": \"Checks if the operand's kind is greater than or equal to FIRST_LOCATION_OPERAND_KIND.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the operand is a location, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            bool InstructionOperand::IsAnyLocationOperand() const {\n            return this->kind() >= FIRST_LOCATION_OPERAND_KIND;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsLocationOperand\",\n                \"parent\": \"InstructionOperand\",\n                \"about\": \"Checks if the operand is a non-floating-point location (register or stack slot).\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the operand is a non-floating-point location, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"LocationOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool InstructionOperand::IsLocationOperand() const {\n            return IsAnyLocationOperand() &&\n                    !IsFloatingPoint(LocationOperand::cast(this)->representation());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsFPLocationOperand\",\n                \"parent\": \"InstructionOperand\",\n                \"about\": \"Checks if the operand is a floating-point location (register or stack slot).\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the operand is a floating-point location, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"LocationOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool InstructionOperand::IsFPLocationOperand() const {\n            return IsAnyLocationOperand() &&\n                    IsFloatingPoint(LocationOperand::cast(this)->representation());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsAnyRegister\",\n                \"parent\": \"InstructionOperand\",\n                \"about\": \"Checks if the operand is any kind of register (integer or floating-point).\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the operand is a register, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"LocationOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool InstructionOperand::IsAnyRegister() const {\n            return IsAnyLocationOperand() &&\n                    LocationOperand::cast(this)->location_kind() ==\n                        LocationOperand::REGISTER;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsRegister\",\n                \"parent\": \"InstructionOperand\",\n                \"about\": \"Checks if the operand is an integer register.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the operand is an integer register, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"LocationOperand\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            bool InstructionOperand::IsRegister() const {\n            return IsAnyRegister() &&\n                    !IsFloatingPoint(LocationOperand::cast(this)->representation());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsFPRegister\",\n                \"parent\": \"InstructionOperand\",\n                \"about\": \"Checks if the operand is a floating-point register.\",\n                \"parameters\":"
}