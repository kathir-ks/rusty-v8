{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/raw-machine-assembler.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/raw-machine-assembler.cc\",\n        \"file_name\": \"raw-machine-assembler.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides a raw machine assembler for generating machine code within the V8 compiler, allowing direct manipulation of the underlying machine instructions and graph.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary header files for raw machine assembler functionality and dependencies.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/raw-machine-assembler.h\"\n\n#include <optional>\n\n#include \"src/base/small-vector.h\"\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/scheduler.h\"\n#include \"src/heap/factory-inl.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RawMachineAssembler\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A low-level assembler for constructing machine code graphs within the V8 compiler.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the V8 isolate.\"\n                },\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"TFGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the TurboFan graph.\"\n                },\n                {\n                    \"name\": \"schedule_\",\n                    \"type\": \"Schedule*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The scheduling information for the graph.\"\n                },\n                {\n                    \"name\": \"source_positions_\",\n                    \"type\": \"SourcePositionTable*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Table for storing source position information.\"\n                },\n                {\n                    \"name\": \"machine_\",\n                    \"type\": \"MachineOperatorBuilder\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Builder for machine operators.\"\n                },\n                {\n                    \"name\": \"common_\",\n                    \"type\": \"CommonOperatorBuilder\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Builder for common operators.\"\n                },\n                {\n                    \"name\": \"simplified_\",\n                    \"type\": \"SimplifiedOperatorBuilder\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Builder for simplified operators.\"\n                },\n                {\n                    \"name\": \"call_descriptor_\",\n                    \"type\": \"CallDescriptor*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Descriptor for function calls.\"\n                },\n                {\n                    \"name\": \"dynamic_js_parameter_count_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Node representing the dynamic JS parameter count.\"\n                },\n                {\n                    \"name\": \"target_parameter_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Node representing the target parameter.\"\n                },\n                {\n                    \"name\": \"parameters_\",\n                    \"type\": \"ZoneVector<Node*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of nodes representing parameters.\"\n                },\n                {\n                    \"name\": \"current_block_\",\n                    \"type\": \"BasicBlock*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current basic block being constructed.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"TFGraph\",\n                \"CallDescriptor\",\n                \"MachineRepresentation\",\n                \"MachineOperatorBuilder\",\n                \"AlignmentRequirements\",\n                \"Schedule\",\n                \"SourcePositionTable\",\n                \"CommonOperatorBuilder\",\n                \"SimplifiedOperatorBuilder\",\n                \"ZoneVector\",\n                \"BasicBlock\",\n                \"Linkage\",\n                \"IrOpcode\",\n                \"NodeProperties\",\n                \"Type\",\n                \"Scheduler\",\n                \"CommonOperatorBuilder\",\n                \"PhiRepresentationOf\",\n                \"IfValueParametersOf\",\n                \"BranchHintOf\",\n                \"BranchHint\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nRawMachineAssembler::RawMachineAssembler(\n    Isolate* isolate, TFGraph* graph, CallDescriptor* call_descriptor,\n    MachineRepresentation word, MachineOperatorBuilder::Flags flags,\n    MachineOperatorBuilder::AlignmentRequirements alignment_requirements)\n    : isolate_(isolate),\n      graph_(graph),\n      schedule_(zone()->New<Schedule>(zone())),\n      source_positions_(zone()->New<SourcePositionTable>(graph)),\n      machine_(zone(), word, flags, alignment_requirements),\n      common_(zone()),\n      simplified_(zone()),\n      call_descriptor_(call_descriptor),\n      dynamic_js_parameter_count_(nullptr),\n      target_parameter_(nullptr),\n      parameters_(parameter_count(), zone()),\n      current_block_(schedule()->start()) {\n  int param_count = static_cast<int>(parameter_count());\n  // Add an extra input for the JSFunction parameter to the start node.\n  graph->SetStart(graph->NewNode(common_.Start(param_count + 1)));\n  if (call_descriptor->IsJSFunctionCall()) {\n    target_parameter_ = AddNode(\n        common()->Parameter(Linkage::kJSCallClosureParamIndex), graph->start());\n  }\n  for (size_t i = 0; i < parameter_count(); ++i) {\n    parameters_[i] =\n        AddNode(common()->Parameter(static_cast<int>(i)), graph->start());\n  }\n  graph->SetEnd(graph->NewNode(common_.End(0)));\n  source_positions_->AddDecorator();\n}\n\nvoid RawMachineAssembler::SetCurrentExternalSourcePosition(\n    FileAndLine file_and_line) {\n  int file_id =\n      isolate()->LookupOrAddExternallyCompiledFilename(file_and_line.first);\n  SourcePosition p = SourcePosition::External(file_and_line.second, file_id);\n  DCHECK_EQ(p.ExternalLine(), file_and_line.second);\n  source_positions()->SetCurrentPosition(p);\n}\n\nFileAndLine RawMachineAssembler::GetCurrentExternalSourcePosition() const {\n  SourcePosition p = source_positions_->GetCurrentPosition();\n  if (!p.IsKnown()) return {nullptr, -1};\n  int file_id = p.ExternalFileId();\n  const char* file_name = isolate()->GetExternallyCompiledFilename(file_id);\n  int line = p.ExternalLine();\n  return {file_name, line};\n}\n\nNode* RawMachineAssembler::NullConstant() {\n  return HeapConstant(isolate()->factory()->null_value());\n}\n\nNode* RawMachineAssembler::UndefinedConstant() {\n  return HeapConstant(isolate()->factory()->undefined_value());\n}\n\nNode* RawMachineAssembler::RelocatableIntPtrConstant(intptr_t value,\n                                                     RelocInfo::Mode rmode) {\n  return kSystemPointerSize == 8\n             ? RelocatableInt64Constant(value, rmode)\n             : RelocatableInt32Constant(static_cast<int>(value), rmode);\n}\n\nNode* RawMachineAssembler::OptimizedAllocate(Node* size,\n                                             AllocationType allocation) {\n  return AddNode(simplified()->AllocateRaw(Type::Any(), allocation), size);\n}\n\nSchedule* RawMachineAssembler::ExportForTest() {\n  // Compute the correct codegen order.\n  DCHECK(schedule_->rpo_order()->empty());\n  if (v8_flags.trace_turbo_scheduler) {\n    PrintF(\"--- RAW SCHEDULE -------------------------------------------\\n\");\n    StdoutStream{} << *schedule_;\n  }\n  schedule_->EnsureCFGWellFormedness();\n  Scheduler::ComputeSpecialRPO(zone(), schedule_);\n  Scheduler::GenerateDominatorTree(schedule_);\n  schedule_->PropagateDeferredMark();\n  if (v8_flags.trace_turbo_scheduler) {\n    PrintF(\"--- EDGE SPLIT AND PROPAGATED DEFERRED SCHEDULE ------------\\n\");\n    StdoutStream{} << *schedule_;\n  }\n  // Invalidate RawMachineAssembler.\n  source_positions_->RemoveDecorator();\n  Schedule* schedule = schedule_;\n  schedule_ = nullptr;\n  return schedule;\n}\n\nTFGraph* RawMachineAssembler::ExportForOptimization() {\n  // Compute the correct codegen order.\n  DCHECK(schedule_->rpo_order()->empty());\n  if (v8_flags.trace_turbo_scheduler) {\n    PrintF(\"--- RAW SCHEDULE -------------------------------------------\\n\");\n    StdoutStream{} << *schedule_;\n  }\n  schedule_->EnsureCFGWellFormedness();\n  OptimizeControlFlow(schedule_, graph(), common());\n  Scheduler::ComputeSpecialRPO(zone(), schedule_);\n  if (v8_flags.trace_turbo_scheduler) {\n    PrintF(\"--- SCHEDULE BEFORE GRAPH CREATION -------------------------\\n\");\n    StdoutStream{} << *schedule_;\n  }\n  MakeReschedulable();\n  // Invalidate RawMachineAssembler.\n  schedule_ = nullptr;\n  return graph();\n}\n\nvoid RawMachineAssembler::OptimizeControlFlow(Schedule* schedule,\n                                              TFGraph* graph,\n                                              CommonOperatorBuilder* common) {\n  for (bool changed = true; changed;) {\n    changed = false;\n    for (size_t i = 0; i < schedule->all_blocks()->size(); ++i) {\n      BasicBlock* block = (*schedule->all_blocks())[i];\n      if (block == nullptr) continue;\n\n      // Short-circuit a goto if the succeeding block is not a control-flow\n      // merge. This is not really useful on it's own since graph construction\n      // has the same effect, but combining blocks improves the pattern-match on\n      // their structure below.\n      if (block->control() == BasicBlock::kGoto) {\n        DCHECK_EQ(block->SuccessorCount(), 1);\n        BasicBlock* successor = block->SuccessorAt(0);\n        if (successor->PredecessorCount() == 1) {\n          DCHECK_EQ(successor->PredecessorAt(0), block);\n          for (Node* node : *successor) {\n            schedule->SetBlockForNode(nullptr, node);\n            schedule->AddNode(block, node);\n          }\n          block->set_control(successor->control());\n          Node* control_input = successor->control_input();\n          block->set_control_input(control_input);\n          if (control_input) {\n            schedule->SetBlockForNode(block, control_input);\n          }\n          if (successor->deferred()) block->set_deferred(true);\n          block->ClearSuccessors();\n          schedule->MoveSuccessors(successor, block);\n          schedule->ClearBlockById(successor->id());\n          changed = true;\n          --i;\n          continue;\n        }\n      }\n      // Block-cloning in the simple case where a block consists only of a phi\n      // node and a branch on that phi. This just duplicates the branch block\n      // for each predecessor, replacing the phi node with the corresponding phi\n      // input.\n      if (block->control() == BasicBlock::kBranch && block->NodeCount() == 1) {\n        Node* phi = block->NodeAt(0);\n        if (phi->opcode() != IrOpcode::kPhi) continue;\n        Node* branch = block->control_input();\n        DCHECK_EQ(branch->opcode(), IrOpcode::kBranch);\n        if (NodeProperties::GetValueInput(branch, 0) != phi) continue;\n        if (phi->UseCount() != 1) continue;\n        DCHECK_EQ(phi->op()->ValueInputCount(), block->PredecessorCount());\n\n        // Turn projection blocks into normal blocks.\n        DCHECK_EQ(block->SuccessorCount(), 2);\n        BasicBlock* true_block = block->SuccessorAt(0);\n        BasicBlock* false_block = block->SuccessorAt(1);\n        DCHECK_EQ(true_block->NodeAt(0)->opcode(), IrOpcode::kIfTrue);\n        DCHECK_EQ(false_block->NodeAt(0)->opcode(), IrOpcode::kIfFalse);\n        (*true_block->begin())->Kill();\n        true_block->RemoveNode(true_block->begin());\n        (*false_block->begin())->Kill();\n        false_block->RemoveNode(false_block->begin());\n        true_block->ClearPredecessors();\n        false_block->ClearPredecessors();\n\n        size_t arity = block->PredecessorCount();\n        for (size_t j = 0; j < arity; ++j) {\n          BasicBlock* predecessor = block->PredecessorAt(j);\n          predecessor->ClearSuccessors();\n          if (block->deferred()) predecessor->set_deferred(true);\n          Node* branch_clone = graph->CloneNode(branch);\n          int phi_input = static_cast<int>(j);\n          NodeProperties::ReplaceValueInput(\n              branch_clone, NodeProperties::GetValueInput(phi, phi_input), 0);\n          BasicBlock* new_true_block = schedule->NewBasicBlock();\n          BasicBlock* new_false_block = schedule->NewBasicBlock();\n          new_true_block->AddNode(\n              graph->NewNode(common->IfTrue(), branch_clone));\n          new_false_block->AddNode(\n              graph->NewNode(common->IfFalse(), branch_clone));\n          schedule->AddGoto(new_true_block, true_block);\n          schedule->AddGoto(new_false_block, false_block);\n          DCHECK_EQ(predecessor->control(), BasicBlock::kGoto);\n          predecessor->set_control(BasicBlock::kNone);\n          schedule->AddBranch(predecessor, branch_clone, new_true_block,\n                              new_false_block);\n        }\n        branch->Kill();\n        schedule->ClearBlockById(block->id());\n        changed = true;\n        continue;\n      }\n    }\n  }\n}\n\nvoid RawMachineAssembler::MakeReschedulable() {\n  std::vector<Node*> block_final_control(schedule_->all_blocks_.size());\n  std::vector<Node*> block_final_effect(schedule_->all_blocks_.size());\n\n  struct LoopHeader {\n    BasicBlock* block;\n    Node* loop_node;\n    Node* effect_phi;\n  };\n  std::vector<LoopHeader> loop_headers;\n\n  // These are hoisted outside of the loop to avoid re-allocation.\n  std::vector<Node*> merge_inputs;\n  std::vector<Node*> effect_phi_inputs;\n\n  for (BasicBlock* block : *schedule_->rpo_order()) {\n    Node* current_control;\n    Node* current_effect;\n    if (block == schedule_->start()) {\n      current_control = current_effect = graph()->start();\n    } else if (block == schedule_->end()) {\n      for (size_t i = 0; i < block->PredecessorCount(); ++i) {\n        NodeProperties::MergeControlToEnd(\n            graph(), common(), block->PredecessorAt(i)->control_input());\n      }\n    } else if (block->IsLoopHeader()) {\n      // The graph()->start() inputs are just placeholders until we computed the\n      // real back-edges and re-structure the control flow so the loop has\n      // exactly two predecessors.\n      current_control = graph()->NewNode(common()->Loop(2), graph()->start(),\n                                         graph()->start());\n      current_effect =\n          graph()->NewNode(common()->EffectPhi(2), graph()->start(),\n                           graph()->start(), current_control);\n\n      Node* terminate = graph()->NewNode(common()->Terminate(), current_effect,\n                                         current_control);\n      NodeProperties::MergeControlToEnd(graph(), common(), terminate);\n      loop_headers.push_back(\n          LoopHeader{block, current_control, current_effect});\n    } else if (block->PredecessorCount() == 1) {\n      BasicBlock* predecessor = block->PredecessorAt(0);\n      DCHECK_LT(predecessor->rpo_number(), block->rpo_number());\n      current_effect = block_final_effect[predecessor->id().ToSize()];\n      current_control = block_final_control[predecessor->id().ToSize()];\n    } else {\n      // Create control merge nodes and effect phis for all predecessor blocks.\n      merge_inputs.clear();\n      effect_phi_inputs.clear();\n      int predecessor_count = static_cast<int>(block->PredecessorCount());\n      for (int i = 0; i < predecessor_count; ++i) {\n        BasicBlock* predecessor = block->PredecessorAt(i);\n        DCHECK_LT(predecessor->rpo_number(), block->rpo_number());\n        merge_inputs.push_back(block_final_control[predecessor->id().ToSize()]);\n        effect_phi_inputs.push_back(\n            block_final_effect[predecessor->id().ToSize()]);\n      }\n      current_control = graph()->NewNode(common()->Merge(predecessor_count),\n                                         static_cast<int>(merge_inputs.size()),\n                                         merge_inputs.data());\n      effect_phi_inputs.push_back(current_control);\n      current_effect = graph()->NewNode(\n          common()->EffectPhi(predecessor_count),\n          static_cast<int>(effect_phi_inputs.size()), effect_phi_inputs.data());\n    }\n\n    auto update_current_control_and_effect = [&](Node* node) {\n      bool existing_effect_and_control =\n          IrOpcode::IsIfProjectionOpcode(node->opcode()) ||\n          IrOpcode::IsPhiOpcode(node->opcode());\n      if (node->op()->EffectInputCount() > 0) {\n        DCHECK_EQ(1, node->op()->EffectInputCount());\n        if (existing_effect_and_control) {\n          NodeProperties::ReplaceEffectInput(node, current_effect);\n        } else {\n          node->AppendInput(graph()->zone(), current_effect);\n        }\n      }\n      if (node->op()->ControlInputCount() > 0) {\n        DCHECK_EQ(1, node->op()->ControlInputCount());\n        if (existing_effect_and_control) {\n          NodeProperties::ReplaceControlInput(node, current_control);\n        } else {\n          node->AppendInput(graph()->zone(), current_control);\n        }\n      }\n      if (node->op()->EffectOutputCount() > 0) {\n        DCHECK_EQ(1, node->op()->EffectOutputCount());\n        current_effect = node;\n      }\n      if (node->op()->ControlOutputCount() > 0) {\n        current_control = node;\n      }\n    };\n\n    for (Node* node : *block) {\n      update_current_control_and_effect(node);\n    }\n    if (block->deferred()) MarkControlDeferred(current_control);\n\n    if (Node* block_terminator = block->control_input()) {\n      update_current_control_and_effect(block_terminator);\n    }\n\n    block_final_effect[block->id().ToSize()] = current_effect;\n    block_final_control[block->id().ToSize()] = current_control;\n  }\n\n  // Fix-up loop backedges and re-structure control flow so that loop nodes have\n  // exactly two control predecessors.\n  for (const LoopHeader& loop_header : loop_headers) {\n    BasicBlock* block = loop_header.block;\n    std::vector<BasicBlock*> loop_entries;\n    std::vector<BasicBlock*> loop_backedges;\n    for (size_t i = 0; i < block->PredecessorCount(); ++i) {\n      BasicBlock* predecessor = block->PredecessorAt(i);\n      if (block->LoopContains(predecessor)) {\n        loop_backedges.push_back(predecessor);\n      } else {\n        DCHECK(loop_backedges.empty());\n        loop_entries.push_back(predecessor);\n      }\n    }\n    DCHECK(!loop_entries.empty());\n    DCHECK(!loop_backedges.empty());\n\n    int entrance_count = static_cast<int>(loop_entries.size());\n    int backedge_count = static_cast<int>(loop_backedges.size());\n    Node* control_loop_entry = CreateNodeFromPredecessors(\n        loop_entries, block_final_control, common()->Merge(entrance_count), {});\n    Node* control_backedge =\n        CreateNodeFromPredecessors(loop_backedges, block_final_control,\n                                   common()->Merge(backedge_count), {});\n    Node* effect_loop_entry = CreateNodeFromPredecessors(\n        loop_entries, block_final_effect, common()->EffectPhi(entrance_count),\n        {control_loop_entry});\n    Node* effect_backedge = CreateNodeFromPredecessors(\n        loop_backedges, block_final_effect, common()->EffectPhi(backedge_count),\n        {control_backedge});\n\n    loop_header.loop_node->ReplaceInput(0, control_loop_entry);\n    loop_header.loop_node->ReplaceInput(1, control_backedge);\n    loop_header.effect_phi->ReplaceInput(0, effect_loop_entry);\n    loop_header.effect_phi->ReplaceInput(1, effect_backedge);\n\n    for (Node* node : *block) {\n      if (node->opcode() == IrOpcode::kPhi) {\n        MakePhiBinary(node, static_cast<int>(loop_entries.size()),\n                      control_loop_entry, control_backedge);\n      }\n    }\n  }\n}\n\nNode* RawMachineAssembler::CreateNodeFromPredecessors(\n    const std::vector<BasicBlock*>& predecessors,\n    const std::vector<Node*>& sidetable, const Operator* op,\n    const std::vector<Node*>& additional_inputs) {\n  if (predecessors.size() == 1) {\n    return sidetable[predecessors.front()->id().ToSize()];\n  }\n  std::vector<Node*> inputs;\n  inputs.reserve(predecessors.size());\n  for (BasicBlock* predecessor : predecessors) {\n    inputs.push_back(sidetable[predecessor->id().ToSize()]);\n  }\n  for (Node* additional_input : additional_inputs) {\n    inputs.push_back(additional_input);\n  }\n  return graph()->NewNode(op, static_cast<int>(inputs.size()), inputs.data());\n}\n\nvoid RawMachineAssembler::MakePhiBinary(Node* phi, int split_point,\n                                        Node* left_control,\n                                        Node* right_control) {\n  int value_count = phi->op()->ValueInputCount();\n  if (value_count == 2) return;\n  DCHECK_LT(split_point, value_count);\n  DCHECK_GT(split_point, 0);\n\n  MachineRepresentation rep = PhiRepresentationOf(phi->op());\n  int left_input_count = split_point;\n  int right_input_count = value_count - split_point;\n\n  Node* left_input;\n  if (left_input_count == 1) {\n    left_input = NodeProperties::GetValueInput(phi, 0);\n  } else {\n    std::vector<Node*> inputs;\n    inputs.reserve(left_input_count);\n    for (int i = 0; i < left_input_count; ++i) {\n      inputs.push_back(NodeProperties::GetValueInput(phi, i));\n    }\n    inputs.push_back(left_control);\n    left_input =\n        graph()->NewNode(common()->Phi(rep, static_cast<int>(left_input_count)),\n                         static_cast<int>(inputs.size()), inputs.data());\n  }\n\n  Node* right_input;\n  if (right_input_count == 1) {\n    right_input = NodeProperties::GetValueInput(phi, split_point);\n  } else {\n    std::vector<Node*> inputs;\n    for (int i = split_point; i < value_count; ++i) {\n      inputs.push_back(NodeProperties::GetValueInput(phi, i));\n    }\n    inputs.push_back(right_control);\n    right_input = graph()->NewNode(\n        common()->Phi(rep, static_cast<int>(right_input_count)),\n        static_cast<int>(inputs.size()), inputs.data());\n  }\n\n  Node* control = NodeProperties::GetControlInput(phi);\n  phi->TrimInputCount(3);\n  phi->ReplaceInput(0, left_input);\n  phi->ReplaceInput(1, right_input);\n  phi->ReplaceInput(2, control);\n  NodeProperties::ChangeOp(phi, common()->Phi(rep, 2));\n}\n\nvoid RawMachineAssembler::MarkControlDeferred(Node* control_node) {\n  BranchHint new_branch_hint;\n  Node* responsible_branch = nullptr;\n  while (responsible_branch == nullptr) {\n    switch (control_node->opcode()) {\n      case IrOpcode::kIfException:\n        // IfException projections are deferred by default.\n        return;\n      case IrOpcode::kIfSuccess:\n        control_node = NodeProperties::GetControlInput(control_node);\n        continue;\n      case IrOpcode::kIfValue: {\n        IfValueParameters parameters = IfValueParametersOf(control_node->op());\n        if (parameters.hint() != BranchHint::kFalse) {\n          NodeProperties::ChangeOp(\n              control_node, common()->IfValue(parameters.value(),\n                                              parameters.comparison_order(),\n                                              BranchHint::kFalse));\n        }\n        return;\n      }\n      case IrOpcode::kIfDefault:\n        if (BranchHintOf(control_node->op()) != BranchHint::kFalse) {\n          NodeProperties::ChangeOp(control_node,\n                                   common()->IfDefault(BranchHint::kFalse));\n        }\n        return;\n      case IrOpcode::kIfTrue: {\n        Node* branch = NodeProperties::GetControlInput(control_node);\n        BranchHint hint = BranchHintOf(branch->op());\n        if (hint == BranchHint::kTrue) {\n          // The other possibility is also deferred, so the responsible branch\n          // has to be before.\n          control_node = NodeProperties::GetControlInput(branch);\n          continue;\n        }\n        new_branch_hint = BranchHint::kFalse;\n        responsible_branch = branch;\n        break;\n      }\n      case IrOpcode::kIfFalse: {\n        Node* branch = NodeProperties::GetControlInput(control_node);\n        BranchHint hint = BranchHintOf(branch->op());\n        if (hint == BranchHint::kFalse) {\n          // The other possibility is also deferred, so the responsible branch\n          // has to be before.\n          control_node = NodeProperties::GetControlInput(branch);\n          continue;\n        }\n        new_branch_hint = BranchHint::kTrue;\n        responsible_branch = branch;\n        break;\n      }\n      case IrOpcode::kMerge:\n        for (int i = 0; i < control_node->op()->ControlInputCount(); ++i) {\n          MarkControlDeferred(NodeProperties::GetControlInput(control_node, i));\n        }\n        return;\n      case IrOpcode::kLoop:\n        control_node = NodeProperties::GetControlInput(control_node, 0);\n        continue;\n      case IrOpcode::kBranch:\n      case IrOpcode::kSwitch:\n        UNREACHABLE();\n      case IrOpcode::kStart:\n        return;\n      default:\n        DCHECK_EQ(1, control_node->op()->ControlInputCount());\n        control_node = NodeProperties::GetControlInput(control_node);\n        continue;\n    }\n  }\n\n  BranchHint hint = BranchHintOf(responsible_branch->op());\n  if (hint == new_branch_hint) return;\n  NodeProperties::ChangeOp(responsible_branch,\n                           common()->Branch(new_branch_hint));\n}\n\nNode* RawMachineAssembler::TargetParameter() {\n  DCHECK_NOT_NULL(target_parameter_);\n  return target_parameter_;\n}\n\nNode* RawMachineAssembler::Parameter(size_t index) {\n  DCHECK_LT(index, parameter_count());\n  return parameters_[index];\n}\n\n\nvoid RawMachineAssembler::Goto(RawMachineLabel* label) {\n  DCHECK(current_block_ != schedule()->end());\n  schedule()->AddGoto(CurrentBlock(), Use(label));\n  current_block_ = nullptr;\n}\n\nvoid RawMachineAssembler::Branch(Node* condition, RawMachineLabel* true_val,\n                                 RawMachineLabel* false_val,\n                                 BranchHint branch_hint) {\n  DCHECK(current_block_ != schedule()->end());\n  Node* branch = MakeNode(common()->Branch(branch_hint), 1, &condition);\n  BasicBlock* true_block = schedule()->NewBasicBlock();\n  BasicBlock* false_block = schedule()->NewBasicBlock();\n  schedule()->AddBranch(CurrentBlock(), branch, true_block, false_block);\n\n  true_block->AddNode(MakeNode(common()->IfTrue(), 1, &branch));\n  schedule()->AddGoto(true_block, Use(true_val));\n\n  false_block->AddNode(MakeNode(common()->IfFalse(), 1, &branch));\n  schedule()->AddGoto(false_block, Use(false_val));\n\n  current_block_ = nullptr;\n}\n\nvoid RawMachineAssembler::Continuations(Node* call, RawMachineLabel* if_success,\n                                        RawMachineLabel* if_exception) {\n  DCHECK_NOT_NULL(schedule_);\n  DCHECK_NOT_NULL(current_block_);\n  schedule()->AddCall(CurrentBlock(), call, Use(if_success), Use(if_exception));\n  current_block_ = nullptr;\n}\n\nvoid RawMachineAssembler::Switch(Node* index, RawMachineLabel* default_label,\n                                 const int32_t* case_values,\n                                 RawMachineLabel** case_labels,\n                                 size_t case_count) {\n  DCHECK_NE(schedule()->end(), current_block_);\n  size_t succ_count = case_count + 1;\n  Node* switch_node = MakeNode(common()->Switch(succ_count), 1, &index);\n  BasicBlock** succ_blocks = zone()->AllocateArray<BasicBlock*>(succ_count);\n  for (size_t i = 0; i < case_count; ++i) {\n    int32_t case_value = case_values[i];\n    BasicBlock* case_block = schedule()->NewBasicBlock();\n    Node* case_node =\n        graph()->NewNode(common()->IfValue(case_value), switch_node);\n    schedule()->AddNode(case_block, case_node);\n    schedule()->AddGoto(case_block, Use(case_labels[i]));\n    succ_blocks[i] = case_block;\n  }\n  BasicBlock* default_block = schedule()->NewBasicBlock();\n  Node* default_node = graph()->NewNode(common()->IfDefault(), switch_node);\n  schedule()->AddNode(default_block, default_node);\n  schedule()->AddGoto(default_block, Use(default_label));\n  succ_blocks[case_count] = default_block;\n  schedule()->AddSwitch(CurrentBlock(), switch_node, succ_blocks, succ_count);\n  current_block_ = nullptr;\n}\n\nvoid RawMachineAssembler::Return(Node* value) {\n  Node* values[] = {Int32Constant(0), value};\n  Node* ret = MakeNode(common()->Return(1), 2, values);\n  schedule()->AddReturn(CurrentBlock(), ret);\n  current_block_ = nullptr;\n}\n\nvoid RawMachineAssembler::Return(Node* v1, Node* v2) {\n  Node* values[] = {Int32Constant(0), v1, v2};\n  Node* ret = MakeNode(common()->Return(2), 3, values);\n  schedule()->AddReturn(CurrentBlock(), ret);\n  current_block_ = nullptr;\n}\n\nvoid RawMachineAssembler::Return(Node* v1, Node* v2, Node* v3) {\n  Node* values[] = {Int32Constant(0), v1, v2, v3};\n  Node* ret = MakeNode(common()->Return(3), 4, values);\n  schedule()->AddReturn(CurrentBlock(), ret);\n  current_block_ = nullptr;\n}\n\nvoid RawMachineAssembler::Return(Node* v1, Node* v2, Node* v3, Node* v4) {\n  Node* values[] = {Int32Constant(0), v1, v2, v3, v4};\n  Node* ret = MakeNode(common()->Return(4), 5, values);\n  schedule()->AddReturn(CurrentBlock(), ret);\n  current_block_ = nullptr;\n}\n\nvoid RawMachineAssembler::Return(int count, Node* vs[]) {\n  using Node_ptr = Node*;\n  Node** values = new Node_ptr[count + 1];\n  values[0] = Int32Constant(0);\n  for (int i = 0; i < count; ++i) values[i + 1] = vs[i];\n  Node* ret = MakeNode(common()->Return(count), count + 1, values);\n  schedule()->AddReturn(CurrentBlock(), ret);\n  current_block_ = nullptr;\n  delete[] values;\n}\n\nvoid RawMachineAssembler::PopAndReturn(Node* pop, Node* value) {\n  // PopAndReturn is supposed to be used ONLY in CSA/Torque builtins for\n  // dropping ALL JS arguments that are currently located on"
}