{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/d8/async-hooks-wrapper.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 43, column 43",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/d8/async-hooks-wrapper.h\",\n        \"file_name\": \"async-hooks-wrapper.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines classes and structures for wrapping and managing asynchronous hooks in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ libraries and V8 headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <stack>\n#include <vector>\n\n#include \"include/v8-function-callback.h\"\n#include \"include/v8-local-handle.h\"\n#include \"include/v8-promise.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsyncHooksWrap\",\n            \"about\": \"Wraps the async hooks functionality, managing the enabled state and function handles.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the V8 isolate.\"\n                },\n                {\n                    \"name\": \"init_function_\",\n                    \"type\": \"Persistent<v8::Function>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the init function.\"\n                },\n                {\n                    \"name\": \"before_function_\",\n                    \"type\": \"Persistent<v8::Function>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the before function.\"\n                },\n                {\n                    \"name\": \"after_function_\",\n                    \"type\": \"Persistent<v8::Function>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the after function.\"\n                },\n                {\n                    \"name\": \"promiseResolve_function_\",\n                    \"type\": \"Persistent<v8::Function>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the promiseResolve function.\"\n                },\n                {\n                    \"name\": \"enabled_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether async hooks are enabled.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Function\",\n                \"Persistent\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass AsyncHooksWrap {\n public:\n  static constexpr internal::ExternalPointerTag kManagedTag =\n      internal::kGenericManagedTag;\n\n  explicit AsyncHooksWrap(Isolate* isolate)\n      : isolate_(isolate), enabled_(false) {}\n  void Enable();\n  void Disable();\n  bool IsEnabled() const { return enabled_; }\n\n  inline v8::Local<v8::Function> init_function() const;\n  inline void set_init_function(v8::Local<v8::Function> value);\n  inline v8::Local<v8::Function> before_function() const;\n  inline void set_before_function(v8::Local<v8::Function> value);\n  inline v8::Local<v8::Function> after_function() const;\n  inline void set_after_function(v8::Local<v8::Function> value);\n  inline v8::Local<v8::Function> promiseResolve_function() const;\n  inline void set_promiseResolve_function(v8::Local<v8::Function> value);\n\n private:\n  Isolate* isolate_;\n\n  Persistent<v8::Function> init_function_;\n  Persistent<v8::Function> before_function_;\n  Persistent<v8::Function> after_function_;\n  Persistent<v8::Function> promiseResolve_function_;\n\n  bool enabled_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsyncHooks\",\n            \"about\": \"Manages a collection of AsyncHooksWrap instances and provides methods for interacting with async hooks.\",\n            \"attributes\": [\n                {\n                    \"name\": \"async_wraps_\",\n                    \"type\": \"std::vector<std::shared_ptr<AsyncHooksWrap>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector of shared pointers to AsyncHooksWrap objects.\"\n                },\n                {\n                    \"name\": \"v8_isolate_\",\n                    \"type\": \"v8::Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the V8 isolate.\"\n                },\n                {\n                    \"name\": \"async_hooks_templ\",\n                    \"type\": \"Persistent<ObjectTemplate>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the async hooks object template.\"\n                },\n                {\n                    \"name\": \"async_id_symbol\",\n                    \"type\": \"Persistent<Private>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the private symbol for async ID.\"\n                },\n                {\n                    \"name\": \"trigger_id_symbol\",\n                    \"type\": \"Persistent<Private>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Persistent handle to the private symbol for trigger ID.\"\n                },\n                {\n                    \"name\": \"asyncContexts\",\n                    \"type\": \"std::stack<AsyncContext>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stack to store asynchronous contexts.\"\n                },\n                {\n                    \"name\": \"current_async_id\",\n                    \"type\": \"async_id_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Current asynchronous ID.\"\n                },\n                {\n                    \"name\": \"skip_after_termination_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether to skip after termination.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"AsyncHooksWrap\",\n                \"FunctionTemplate\",\n                \"ObjectTemplate\",\n                \"Private\",\n                \"Local\",\n                \"Object\",\n                \"Promise\",\n                \"Value\",\n                \"AsyncContext\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass AsyncHooks {\n public:\n  explicit AsyncHooks(Isolate* isolate);\n  ~AsyncHooks();\n\n  async_id_t GetExecutionAsyncId() const;\n  async_id_t GetTriggerAsyncId() const;\n\n  Local<Object> CreateHook(const v8::FunctionCallbackInfo<v8::Value>& info);\n\n  Persistent<FunctionTemplate> async_hook_ctor;\n\n private:\n  std::vector<std::shared_ptr<AsyncHooksWrap>> async_wraps_;\n  v8::Isolate* v8_isolate_;\n  Persistent<ObjectTemplate> async_hooks_templ;\n  Persistent<Private> async_id_symbol;\n  Persistent<Private> trigger_id_symbol;\n\n  static void ShellPromiseHook(PromiseHookType type, Local<Promise> promise,\n                               Local<Value> parent);\n  static void PromiseHookDispatch(PromiseHookType type, Local<Promise> promise,\n                                  Local<Value> parent,\n                                  const AsyncHooksWrap& wrap,\n                                  AsyncHooks* hooks);\n\n  std::stack<AsyncContext> asyncContexts;\n  async_id_t current_async_id;\n  // We might end up in an invalid state after skipping steps due to\n  // terminations.\n  bool skip_after_termination_ = false;\n};\n        ]]></code>\n    </class>\n\n    <interface>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"AsyncContext\",\n            \"about\": \"Represents the context of an asynchronous operation.\",\n            \"methods\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstruct AsyncContext {\n  async_id_t execution_async_id;\n  async_id_t trigger_async_id;\n};\n        ]]></code>\n    </interface>\n\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"async_id_t\",\n            \"type\": \"alias\",\n            \"target_type\": \"double\",\n            \"purpose\": \"Defines a type alias for the asynchronous ID.\"\n        }\n        </metadata>\n        <code><![CDATA[\nusing async_id_t = double;\n        ]]></code>\n    </typedef>\n\n</file>\n```"
}