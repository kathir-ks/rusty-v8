{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/property-access-builder.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/property-access-builder.cc\",\n      \"file_name\": \"property-access-builder.cc\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Provides utility functions to build graphs for property access operations in the V8 compiler.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes necessary headers for property access building, graph manipulation, access information, and object representation.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/compiler/property-access-builder.h\"\n\n#include <optional>\n\n#include \"src/compiler/access-builder.h\"\n#include \"src/compiler/access-info.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/objects/heap-number.h\"\n#include \"src/objects/internal-index.h\"\n#include \"src/objects/js-function.h\"\n#include \"src/objects/map-inl.h\"\n#include \"src/objects/property-details.h\"\n]]></code>\n  </imports>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"PropertyAccessBuilder\",\n        \"about\": \"A helper class for building graph nodes related to property access operations.\",\n        \"attributes\": [],\n        \"dependencies\": [\n          \"TFGraph\",\n          \"Isolate\",\n          \"CommonOperatorBuilder\",\n          \"SimplifiedOperatorBuilder\",\n          \"JSGraph\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass PropertyAccessBuilder {\n public:\n  explicit PropertyAccessBuilder(JSGraph* jsgraph) : jsgraph_(jsgraph) {}\n\n  TFGraph* graph() const;\n  Isolate* isolate() const;\n  CommonOperatorBuilder* common() const;\n  SimplifiedOperatorBuilder* simplified() const;\n\n  bool TryBuildStringCheck(JSHeapBroker* broker, ZoneVector<MapRef> const& maps,\n                           Node** receiver, Effect* effect, Control control);\n  bool TryBuildNumberCheck(JSHeapBroker* broker, ZoneVector<MapRef> const& maps,\n                           Node** receiver, Effect* effect, Control control);\n  void BuildCheckMaps(Node* object, Effect* effect, Control control,\n                      ZoneVector<MapRef> const& maps,\n                      bool has_deprecated_map_without_migration_target);\n  Node* BuildCheckValue(Node* receiver, Effect* effect, Control control,\n                       ObjectRef value);\n  Node* BuildCheckSmi(Node* value, Effect* effect, Control control,\n                      FeedbackSource feedback_source);\n  Node* BuildCheckNumber(Node* value, Effect* effect, Control control,\n                       FeedbackSource feedback_source);\n  Node* BuildCheckNumberFitsInt32(Node* value, Effect* effect, Control control,\n                                  FeedbackSource feedback_source);\n  Node* ResolveHolder(PropertyAccessInfo const& access_info,\n                      Node* lookup_start_object);\n  MachineRepresentation ConvertRepresentation(Representation representation);\n\n  std::optional<Node*> FoldLoadDictPrototypeConstant(\n      PropertyAccessInfo const& access_info);\n\n  Node* TryFoldLoadConstantDataField(NameRef name,\n                                      PropertyAccessInfo const& access_info,\n                                      Node* lookup_start_object);\n\n  Node* BuildLoadDataField(NameRef name, PropertyAccessInfo const& access_info,\n                            Node* lookup_start_object, Node** effect,\n                            Node** control);\n  Node* BuildLoadDataField(NameRef name, Node* holder, FieldAccess&& field_access,\n                            bool is_inobject, Node** effect, Node** control);\n\n private:\n  JSGraph* jsgraph() const { return jsgraph_; }\n  JSHeapBroker* broker() const { return jsgraph_->broker(); }\n  CompilationDependencies* dependencies() const {\n    return jsgraph_->dependencies();\n  }\n\n  JSGraph* const jsgraph_;\n};\n\n]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::graph\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Returns the TFGraph associated with this builder.\",\n        \"logic\": \"Simply returns the member jsgraph's graph.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"TFGraph*\",\n          \"description\": \"The TFGraph pointer.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nTFGraph* PropertyAccessBuilder::graph() const { return jsgraph()->graph(); }\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::isolate\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Returns the Isolate associated with this builder.\",\n        \"logic\": \"Simply returns the member jsgraph's isolate.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"Isolate*\",\n          \"description\": \"The Isolate pointer.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nIsolate* PropertyAccessBuilder::isolate() const { return jsgraph()->isolate(); }\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::common\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Returns the CommonOperatorBuilder associated with this builder.\",\n        \"logic\": \"Simply returns the member jsgraph's common operator builder.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"CommonOperatorBuilder*\",\n          \"description\": \"The CommonOperatorBuilder pointer.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nCommonOperatorBuilder* PropertyAccessBuilder::common() const {\n  return jsgraph()->common();\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::simplified\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Returns the SimplifiedOperatorBuilder associated with this builder.\",\n        \"logic\": \"Simply returns the member jsgraph's simplified operator builder.\",\n        \"parameters\": [],\n        \"return\": {\n          \"type\": \"SimplifiedOperatorBuilder*\",\n          \"description\": \"The SimplifiedOperatorBuilder pointer.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nSimplifiedOperatorBuilder* PropertyAccessBuilder::simplified() const {\n  return jsgraph()->simplified();\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"HasOnlyStringMaps\",\n        \"about\": \"Checks if a vector of maps contains only string maps.\",\n        \"logic\": \"Iterates through the maps and returns false if any map is not a string map.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"The JSHeapBroker used for accessing heap objects.\"\n          },\n          {\n            \"name\": \"maps\",\n            \"type\": \"ZoneVector<MapRef> const&\",\n            \"purpose\": \"The vector of maps to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if all maps are string maps, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"MapRef\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool HasOnlyStringMaps(JSHeapBroker* broker, ZoneVector<MapRef> const& maps) {\n  for (MapRef map : maps) {\n    if (!map.IsStringMap()) return false;\n  }\n  return true;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"HasOnlyStringWrapperMaps\",\n        \"about\": \"Checks if a vector of maps contains only string wrapper maps.\",\n        \"logic\": \"Iterates through the maps and returns false if any map is not a string wrapper map or has an invalid elements kind.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"The JSHeapBroker used for accessing heap objects.\"\n          },\n          {\n            \"name\": \"maps\",\n            \"type\": \"ZoneVector<MapRef> const&\",\n            \"purpose\": \"The vector of maps to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if all maps are string wrapper maps, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"MapRef\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool HasOnlyStringWrapperMaps(JSHeapBroker* broker,\n                              ZoneVector<MapRef> const& maps) {\n  for (MapRef map : maps) {\n    if (!map.IsJSPrimitiveWrapperMap()) return false;\n    auto elements_kind = map.elements_kind();\n    if (elements_kind != FAST_STRING_WRAPPER_ELEMENTS &&\n        elements_kind != SLOW_STRING_WRAPPER_ELEMENTS) {\n      return false;\n    }\n  }\n  return true;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"HasOnlyNonResizableTypedArrayMaps\",\n        \"about\": \"Checks if a vector of maps contains only non-resizable typed array maps.\",\n        \"logic\": \"Iterates through the maps and returns false if any map is not a typed array map or if it's a resizable or growable shared array buffer typed array map.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"The JSHeapBroker used for accessing heap objects.\"\n          },\n          {\n            \"name\": \"maps\",\n            \"type\": \"ZoneVector<MapRef> const&\",\n            \"purpose\": \"The vector of maps to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if all maps are non-resizable typed array maps, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"MapRef\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool HasOnlyNonResizableTypedArrayMaps(JSHeapBroker* broker,\n                                       ZoneVector<MapRef> const& maps) {\n  for (MapRef map : maps) {\n    if (!map.IsJSTypedArrayMap()) return false;\n    if (IsRabGsabTypedArrayElementsKind(map.elements_kind())) {\n      return false;\n    }\n  }\n  return true;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"HasOnlyNumberMaps\",\n        \"about\": \"Checks if a vector of maps contains only number maps.\",\n        \"logic\": \"Iterates through the maps and returns false if any map is not a number map.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"The JSHeapBroker used for accessing heap objects.\"\n          },\n          {\n            \"name\": \"maps\",\n            \"type\": \"ZoneVector<MapRef> const&\",\n            \"purpose\": \"The vector of maps to check.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if all maps are number maps, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"MapRef\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nnamespace {\n\nbool HasOnlyNumberMaps(JSHeapBroker* broker, ZoneVector<MapRef> const& maps) {\n  for (MapRef map : maps) {\n    if (map.instance_type() != HEAP_NUMBER_TYPE) return false;\n  }\n  return true;\n}\n\n}  // namespace\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::TryBuildStringCheck\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Builds a string check node if the maps contain only string maps.\",\n        \"logic\": \"If the maps contain only string maps, it creates a CheckString node and updates the receiver and effect.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"The JSHeapBroker used for accessing heap objects.\"\n          },\n          {\n            \"name\": \"maps\",\n            \"type\": \"ZoneVector<MapRef> const&\",\n            \"purpose\": \"The vector of maps to check.\"\n          },\n          {\n            \"name\": \"receiver\",\n            \"type\": \"Node**\",\n            \"purpose\": \"Pointer to the receiver node.\"\n          },\n          {\n            \"name\": \"effect\",\n            \"type\": \"Effect*\",\n            \"purpose\": \"Pointer to the effect node.\"\n          },\n          {\n            \"name\": \"control\",\n            \"type\": \"Control\",\n            \"purpose\": \"The control node.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the check was built, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"HasOnlyStringMaps\",\n          \"CheckString\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool PropertyAccessBuilder::TryBuildStringCheck(JSHeapBroker* broker,\n                                                ZoneVector<MapRef> const& maps,\n                                                Node** receiver, Effect* effect,\n                                                Control control) {\n  if (HasOnlyStringMaps(broker, maps)) {\n    // Monormorphic string access (ignoring the fact that there are multiple\n    // String maps).\n    *receiver = *effect =\n        graph()->NewNode(simplified()->CheckString(FeedbackSource()), *receiver,\n                         *effect, control);\n    return true;\n  }\n  return false;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::TryBuildNumberCheck\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Builds a number check node if the maps contain only number maps.\",\n        \"logic\": \"If the maps contain only number maps, it creates a CheckNumber node and updates the receiver and effect.\",\n        \"parameters\": [\n          {\n            \"name\": \"broker\",\n            \"type\": \"JSHeapBroker*\",\n            \"purpose\": \"The JSHeapBroker used for accessing heap objects.\"\n          },\n          {\n            \"name\": \"maps\",\n            \"type\": \"ZoneVector<MapRef> const&\",\n            \"purpose\": \"The vector of maps to check.\"\n          },\n          {\n            \"name\": \"receiver\",\n            \"type\": \"Node**\",\n            \"purpose\": \"Pointer to the receiver node.\"\n          },\n          {\n            \"name\": \"effect\",\n            \"type\": \"Effect*\",\n            \"purpose\": \"Pointer to the effect node.\"\n          },\n          {\n            \"name\": \"control\",\n            \"type\": \"Control\",\n            \"purpose\": \"The control node.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"bool\",\n          \"description\": \"True if the check was built, false otherwise.\"\n        },\n        \"dependencies\": [\n          \"HasOnlyNumberMaps\",\n          \"CheckNumber\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nbool PropertyAccessBuilder::TryBuildNumberCheck(JSHeapBroker* broker,\n                                                ZoneVector<MapRef> const& maps,\n                                                Node** receiver, Effect* effect,\n                                                Control control) {\n  if (HasOnlyNumberMaps(broker, maps)) {\n    // Monomorphic number access (we also deal with Smis here).\n    *receiver = *effect =\n        graph()->NewNode(simplified()->CheckNumber(FeedbackSource()), *receiver,\n                         *effect, control);\n    return true;\n  }\n  return false;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::BuildCheckMaps\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Builds a check maps node to verify the object's map against a set of expected maps.\",\n        \"logic\": \"Creates a CheckMaps node with the provided maps and flags. It also handles stable map dependencies.\",\n        \"parameters\": [\n          {\n            \"name\": \"object\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The object node to check.\"\n          },\n          {\n            \"name\": \"effect\",\n            \"type\": \"Effect*\",\n            \"purpose\": \"Pointer to the effect node.\"\n          },\n          {\n            \"name\": \"control\",\n            \"type\": \"Control\",\n            \"purpose\": \"The control node.\"\n          },\n          {\n            \"name\": \"maps\",\n            \"type\": \"ZoneVector<MapRef> const&\",\n            \"purpose\": \"The vector of expected maps.\"\n          },\n          {\n            \"name\": \"has_deprecated_map_without_migration_target\",\n            \"type\": \"bool\",\n            \"purpose\": \"Indicates if there's a deprecated map without a migration target.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"void\",\n          \"description\": \"No return value.\"\n        },\n        \"dependencies\": [\n          \"HeapObjectMatcher\",\n          \"MapRef\",\n          \"DependOnStableMap\",\n          \"CheckMaps\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nvoid PropertyAccessBuilder::BuildCheckMaps(\n    Node* object, Effect* effect, Control control,\n    ZoneVector<MapRef> const& maps,\n    bool has_deprecated_map_without_migration_target) {\n  HeapObjectMatcher m(object);\n  if (m.HasResolvedValue()) {\n    MapRef object_map = m.Ref(broker()).map(broker());\n    if (object_map.is_stable()) {\n      for (MapRef map : maps) {\n        if (map.equals(object_map)) {\n          dependencies()->DependOnStableMap(object_map);\n          return;\n        }\n      }\n    }\n  }\n  ZoneRefSet<Map> map_set;\n  bool has_migration_target = false;\n  for (MapRef map : maps) {\n    map_set.insert(map, graph()->zone());\n    if (map.is_migration_target()) {\n      has_migration_target = true;\n    }\n  }\n  CheckMapsFlags flags = CheckMapsFlag::kNone;\n  if (has_migration_target) {\n    flags = CheckMapsFlag::kTryMigrateInstance;\n  } else if (has_deprecated_map_without_migration_target) {\n    flags = CheckMapsFlag::kTryMigrateInstanceAndDeopt;\n  }\n  *effect = graph()->NewNode(simplified()->CheckMaps(flags, map_set), object,\n                             *effect, control);\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::BuildCheckValue\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Builds a check value node to verify if the receiver matches the expected value.\",\n        \"logic\": \"Creates a ReferenceEqual node and a CheckIf node to deoptimize if the values don't match.\",\n        \"parameters\": [\n          {\n            \"name\": \"receiver\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The receiver node to check.\"\n          },\n          {\n            \"name\": \"effect\",\n            \"type\": \"Effect*\",\n            \"purpose\": \"Pointer to the effect node.\"\n          },\n          {\n            \"name\": \"control\",\n            \"type\": \"Control\",\n            \"purpose\": \"The control node.\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"ObjectRef\",\n            \"purpose\": \"The expected value.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Node*\",\n          \"description\": \"The expected value node.\"\n        },\n        \"dependencies\": [\n          \"HeapObjectMatcher\",\n          \"ReferenceEqual\",\n          \"CheckIf\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nNode* PropertyAccessBuilder::BuildCheckValue(Node* receiver, Effect* effect,\n                                             Control control, ObjectRef value) {\n  if (value.IsHeapObject()) {\n    HeapObjectMatcher m(receiver);\n    if (m.Is(value.AsHeapObject().object())) return receiver;\n  }\n  Node* expected = jsgraph()->ConstantNoHole(value, broker());\n  Node* check =\n      graph()->NewNode(simplified()->ReferenceEqual(), receiver, expected);\n  *effect =\n      graph()->NewNode(simplified()->CheckIf(DeoptimizeReason::kWrongValue),\n                       check, *effect, control);\n  return expected;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::BuildCheckSmi\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Builds a check smi node to verify if a value is a smi.\",\n        \"logic\": \"Creates a CheckSmi node.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The value node to check.\"\n          },\n          {\n            \"name\": \"effect\",\n            \"type\": \"Effect*\",\n            \"purpose\": \"Pointer to the effect node.\"\n          },\n          {\n            \"name\": \"control\",\n            \"type\": \"Control\",\n            \"purpose\": \"The control node.\"\n          },\n          {\n            \"name\": \"feedback_source\",\n            \"type\": \"FeedbackSource\",\n            \"purpose\": \"The feedback source.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Node*\",\n          \"description\": \"The smi value node.\"\n        },\n        \"dependencies\": [\n          \"CheckSmi\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nNode* PropertyAccessBuilder::BuildCheckSmi(Node* value, Effect* effect,\n                                           Control control,\n                                           FeedbackSource feedback_source) {\n  Node* smi_value = *effect = graph()->NewNode(\n      simplified()->CheckSmi(feedback_source), value, *effect, control);\n  return smi_value;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::BuildCheckNumber\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Builds a check number node to verify if a value is a number.\",\n        \"logic\": \"Creates a CheckNumber node.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The value node to check.\"\n          },\n          {\n            \"name\": \"effect\",\n            \"type\": \"Effect*\",\n            \"purpose\": \"Pointer to the effect node.\"\n          },\n          {\n            \"name\": \"control\",\n            \"type\": \"Control\",\n            \"purpose\": \"The control node.\"\n          },\n          {\n            \"name\": \"feedback_source\",\n            \"type\": \"FeedbackSource\",\n            \"purpose\": \"The feedback source.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Node*\",\n          \"description\": \"The number node.\"\n        },\n        \"dependencies\": [\n          \"CheckNumber\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nNode* PropertyAccessBuilder::BuildCheckNumber(Node* value, Effect* effect,\n                                              Control control,\n                                              FeedbackSource feedback_source) {\n  Node* number = *effect = graph()->NewNode(\n      simplified()->CheckNumber(feedback_source), value, *effect, control);\n  return number;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::BuildCheckNumberFitsInt32\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Builds a check number fits int32 node to verify if a value is a number that fits in int32.\",\n        \"logic\": \"Creates a CheckNumberFitsInt32 node.\",\n        \"parameters\": [\n          {\n            \"name\": \"value\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The value node to check.\"\n          },\n          {\n            \"name\": \"effect\",\n            \"type\": \"Effect*\",\n            \"purpose\": \"Pointer to the effect node.\"\n          },\n          {\n            \"name\": \"control\",\n            \"type\": \"Control\",\n            \"purpose\": \"The control node.\"\n          },\n          {\n            \"name\": \"feedback_source\",\n            \"type\": \"FeedbackSource\",\n            \"purpose\": \"The feedback source.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Node*\",\n          \"description\": \"The number node.\"\n        },\n        \"dependencies\": [\n          \"CheckNumberFitsInt32\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\nNode* PropertyAccessBuilder::BuildCheckNumberFitsInt32(\n    Node* value, Effect* effect, Control control,\n    FeedbackSource feedback_source) {\n  Node* number = *effect =\n      graph()->NewNode(simplified()->CheckNumberFitsInt32(feedback_source),\n                       value, *effect, control);\n  return number;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::ResolveHolder\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Resolves the holder object for property access.\",\n        \"logic\": \"If the access info has a holder, it returns a constant node for the holder. Otherwise, it returns the lookup start object.\",\n        \"parameters\": [\n          {\n            \"name\": \"access_info\",\n            \"type\": \"PropertyAccessInfo const&\",\n            \"purpose\": \"The property access information.\"\n          },\n          {\n            \"name\": \"lookup_start_object\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The lookup start object node.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Node*\",\n          \"description\": \"The holder object node.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nNode* PropertyAccessBuilder::ResolveHolder(\n    PropertyAccessInfo const& access_info, Node* lookup_start_object) {\n  OptionalJSObjectRef holder = access_info.holder();\n  if (holder.has_value()) {\n    return jsgraph()->ConstantNoHole(holder.value(), broker());\n  }\n  return lookup_start_object;\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::ConvertRepresentation\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Converts a Representation to a MachineRepresentation.\",\n        \"logic\": \"Uses a switch statement to convert between the enum types.\",\n        \"parameters\": [\n          {\n            \"name\": \"representation\",\n            \"type\": \"Representation\",\n            \"purpose\": \"The representation to convert.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"MachineRepresentation\",\n          \"description\": \"The converted machine representation.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nMachineRepresentation PropertyAccessBuilder::ConvertRepresentation(\n    Representation representation) {\n  switch (representation.kind()) {\n    case Representation::kSmi:\n      return MachineRepresentation::kTaggedSigned;\n    case Representation::kDouble:\n      return MachineRepresentation::kFloat64;\n    case Representation::kHeapObject:\n      return MachineRepresentation::kTaggedPointer;\n    case Representation::kTagged:\n      return MachineRepresentation::kTagged;\n    default:\n      UNREACHABLE();\n  }\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::FoldLoadDictPrototypeConstant\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Folds loading a constant from the dictionary prototype chain.\",\n        \"logic\": \"If V8_DICT_PROPERTY_CONST_TRACKING_BOOL is enabled and the access info indicates a dictionary prototype data constant, it retrieves the constant from the holder and returns it as a ConstantNoHole node.  It also adds a dependency on the constant in the dictionary prototype chain.\",\n        \"parameters\": [\n          {\n            \"name\": \"access_info\",\n            \"type\": \"PropertyAccessInfo const&\",\n            \"purpose\": \"The property access information.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"std::optional<Node*>\",\n          \"description\": \"The constant node if folding was successful, std::nullopt otherwise.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nstd::optional<Node*> PropertyAccessBuilder::FoldLoadDictPrototypeConstant(\n    PropertyAccessInfo const& access_info) {\n  DCHECK(V8_DICT_PROPERTY_CONST_TRACKING_BOOL);\n  DCHECK(access_info.IsDictionaryProtoDataConstant());\n\n  InternalIndex index = access_info.dictionary_index();\n  OptionalObjectRef value = access_info.holder()->GetOwnDictionaryProperty(\n      broker(), index, dependencies());\n  if (!value) return {};\n\n  for (MapRef map : access_info.lookup_start_object_maps()) {\n    DirectHandle<Map> map_handle = map.object();\n    // Non-JSReceivers that passed AccessInfoFactory::ComputePropertyAccessInfo\n    // must have different lookup start map.\n    if (!IsJSReceiverMap(*map_handle)) {\n      // Perform the implicit ToObject for primitives here.\n      // Implemented according to ES6 section 7.3.2 GetV (V, P).\n      Tagged<JSFunction> constructor =\n          Map::GetConstructorFunction(\n              *map_handle, *broker()->target_native_context().object())\n              .value();\n      // {constructor.initial_map()} is loaded/stored with acquire-release\n      // semantics for constructors.\n      map = MakeRefAssumeMemoryFence(broker(), constructor->initial_map());\n      DCHECK(IsJSObjectMap(*map.object()));\n    }\n    dependencies()->DependOnConstantInDictionaryPrototypeChain(\n        map, access_info.name(), value.value(), PropertyKind::kData);\n  }\n\n  return jsgraph()->ConstantNoHole(value.value(), broker());\n}\n]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"function\",\n        \"name\": \"PropertyAccessBuilder::TryFoldLoadConstantDataField\",\n        \"parent\": \"PropertyAccessBuilder\",\n        \"about\": \"Tries to fold loading a constant data field.\",\n        \"logic\": \"If the access info indicates a fast data constant, it retrieves the constant from the holder and returns it as a ConstantNoHole node.\",\n        \"parameters\": [\n          {\n            \"name\": \"name\",\n            \"type\": \"NameRef\",\n            \"purpose\": \"The name of the property.\"\n          },\n          {\n            \"name\": \"access_info\",\n            \"type\": \"PropertyAccessInfo const&\",\n            \"purpose\": \"The property access information.\"\n          },\n          {\n            \"name\": \"lookup_start_object\",\n            \"type\": \"Node*\",\n            \"purpose\": \"The lookup start object node.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"Node*\",\n          \"description\": \"The constant node if folding was successful, nullptr otherwise.\"\n        },\n        \"dependencies\": []\n      }\n    </metadata>\n    <code><![CDATA[\nNode* PropertyAccessBuilder::TryFoldLoadConstantDataField(\n    NameRef name, PropertyAccessInfo const& access_info,\n    Node* lookup_start_object) {\n  if (!access_info.IsFastDataConstant()) return nullptr;\n\n  // First, determine if we have a constant holder to load from.\n  OptionalJSObjectRef holder = access_info.holder();\n\n  // If {access_info} has a holder, just use it.\n  if (!holder.has_value()) {\n    // Otherwise, try to match the {lookup_start_object} as a constant.\n    if (lookup_start_object->opcode() == IrOpcode::kCheckString ||\n        lookup_start_object->opcode() ==\n            IrOpcode::kCheckStringOrString"
}