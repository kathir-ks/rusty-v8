{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/flags/flags-impl.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 148, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/flags/flags-impl.h\",\n        \"file_name\": \"flags-impl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares internal implementation details and data structures for the V8 flag system.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for various utilities and data structures.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <optional>\n            #include <unordered_set>\n\n            #include \"src/base/macros.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/flags/flags.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FlagHelpers\",\n            \"about\": \"Provides helper functions for flag name normalization and comparison.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE FlagHelpers {\n            public:\n                static char NormalizeChar(char ch);\n\n                static int FlagNamesCmp(const char* a, const char* b);\n\n                static bool EqualNames(const char* a, const char* b);\n                static bool EqualNameWithSuffix(const char* a, const char* b);\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FindFlagByPointer\",\n            \"about\": \"Finds a flag by its memory address.\",\n            \"logic\": \"Iterates through the global flag list to find a flag with a matching address.\",\n            \"parameters\": [\n                {\n                    \"name\": \"ptr\",\n                    \"type\": \"const void*\",\n                    \"purpose\": \"The memory address of the flag's variable.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Flag*\",\n                \"description\": \"A pointer to the Flag object, or nullptr if not found.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct Flag;\n            Flag* FindFlagByPointer(const void* ptr);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FindFlagByName\",\n            \"about\": \"Finds a flag by its name.\",\n            \"logic\": \"Iterates through the global flag list to find a flag with a matching name.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the flag to find.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Flag*\",\n                \"description\": \"A pointer to the Flag object, or nullptr if not found.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE Flag* FindFlagByName(const char* name);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FindImplicationFlagByName\",\n            \"about\": \"Finds a flag that is used for implication by its name.\",\n            \"logic\": \"Iterates through a specific implication flag list to find a flag with a matching name.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the implication flag to find.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Flag*\",\n                \"description\": \"A pointer to the Flag object, or nullptr if not found.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE Flag* FindImplicationFlagByName(const char* name);\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Flags\",\n            \"about\": \"Returns a vector containing all registered flags.\",\n            \"logic\": \"Accesses an internal global list of flags.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"base::Vector<Flag>\",\n                \"description\": \"A vector of Flag objects.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT_PRIVATE base::Vector<Flag> Flags();\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"FlagName\",\n            \"about\": \"Helper struct for printing normalized flag names, handles negated flag names.\",\n            \"attributes\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const char*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The name of the flag.\"\n                },\n                {\n                    \"name\": \"negated\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates if the flag is negated (e.g., '--no-flag').\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            // Helper struct for printing normalized flag names.\n            struct FlagName {\n            const char* name;\n            bool negated;\n\n            constexpr FlagName(const char* name, bool negated)\n                : name(name), negated(negated) {\n                DCHECK_NE('\\0', name[0]);\n                DCHECK_NE('!', name[0]);\n            }\n\n            constexpr explicit FlagName(const char* name)\n                : FlagName(name[0] == '!' ? name + 1 : name, name[0] == '!') {}\n            };\n        ]]></code>\n    </struct>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the output stream operator to print FlagName objects.\",\n            \"logic\": \"Prints the flag name, potentially with a 'no-' prefix if negated.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream.\"\n                },\n                {\n                    \"name\": \"flag_name\",\n                    \"type\": \"FlagName\",\n                    \"purpose\": \"The FlagName object to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The output stream.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            std::ostream& operator<<(std::ostream& os, FlagName flag_name);\n        ]]></code>\n    </func>\n\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"Flag\",\n            \"about\": \"Represents a single flag with its type, name, value, default value, and comment.\",\n            \"attributes\": [\n                {\n                    \"name\": \"type_\",\n                    \"type\": \"FlagType\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The data type of the flag (e.g., bool, int, string).\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The name of the flag.\"\n                },\n                {\n                    \"name\": \"valptr_\",\n                    \"type\": \"void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"A pointer to the memory location where the flag's value is stored.\"\n                },\n                {\n                    \"name\": \"defptr_\",\n                    \"type\": \"const void*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"A pointer to the memory location where the flag's default value is stored.\"\n                },\n                {\n                    \"name\": \"cmt_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"A comment describing the flag's purpose.\"\n                },\n                {\n                    \"name\": \"owns_ptr_\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates if the flag owns the memory pointed to by `valptr_` (used for strings).\"\n                },\n                {\n                    \"name\": \"set_by_\",\n                    \"type\": \"SetBy\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates how the flag was set (e.g., default, command line).\"\n                },\n                {\n                    \"name\": \"implied_by_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The name of the flag that implied this flag's value.\"\n                }\n            ],\n            \"dependencies\": [\n                \"std::unordered_set\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            // This structure represents a single entry in the flag system, with a pointer\n            // to the actual flag, default value, comment, etc.  This is designed to be POD\n            // initialized as to avoid requiring static constructors.\n            struct Flag {\n            enum FlagType {\n                TYPE_BOOL,\n                TYPE_MAYBE_BOOL,\n                TYPE_INT,\n                TYPE_UINT,\n                TYPE_UINT64,\n                TYPE_FLOAT,\n                TYPE_SIZE_T,\n                TYPE_STRING,\n            };\n\n            enum class SetBy { kDefault, kWeakImplication, kImplication, kCommandLine };\n\n            constexpr bool IsAnyImplication(Flag::SetBy set_by) {\n                return set_by == SetBy::kWeakImplication || set_by == SetBy::kImplication;\n            }\n\n            FlagType type_;       // What type of flag, bool, int, or string.\n            const char* name_;    // Name of the flag, ex \"my_flag\".\n            void* valptr_;        // Pointer to the global flag variable.\n            const void* defptr_;  // Pointer to the default value.\n            const char* cmt_;     // A comment about the flags purpose.\n            bool owns_ptr_;       // Does the flag own its string value?\n            SetBy set_by_ = SetBy::kDefault;\n            // Name of the flag implying this flag, if any.\n            const char* implied_by_ = nullptr;\n#ifdef DEBUG\n            // Pointer to the flag implying this flag, if any.\n            const Flag* implied_by_ptr_ = nullptr;\n#endif\n\n            FlagType type() const { return type_; }\n\n            const char* name() const { return name_; }\n\n            const char* comment() const { return cmt_; }\n\n            bool PointsTo(const void* ptr) const { return valptr_ == ptr; }\n\n#ifdef DEBUG\n            bool ImpliedBy(const void* ptr) const {\n                const Flag* current = this->implied_by_ptr_;\n                std::unordered_set<const Flag*> visited_flags;\n                while (current != nullptr) {\n                visited_flags.insert(current);\n                if (current->PointsTo(ptr)) return true;\n                current = current->implied_by_ptr_;\n                if (visited_flags.contains(current)) break;\n                }\n                return false;\n            }\n#endif\n\n            bool bool_variable() const { return GetValue<TYPE_BOOL, bool>(); }\n\n            void set_bool_variable(bool value, SetBy set_by) {\n                SetValue<TYPE_BOOL, bool>(value, set_by);\n            }\n\n            std::optional<bool> maybe_bool_variable() const {\n                return GetValue<TYPE_MAYBE_BOOL, std::optional<bool>>();\n            }\n\n            void set_maybe_bool_variable(std::optional<bool> value, SetBy set_by) {\n                SetValue<TYPE_MAYBE_BOOL, std::optional<bool>>(value, set_by);\n            }\n\n            int int_variable() const { return GetValue<TYPE_INT, int>(); }\n\n            void set_int_variable(int value, SetBy set_by) {\n                SetValue<TYPE_INT, int>(value, set_by);\n            }\n\n            unsigned int uint_variable() const {\n                return GetValue<TYPE_UINT, unsigned int>();\n            }\n\n            void set_uint_variable(unsigned int value, SetBy set_by) {\n                SetValue<TYPE_UINT, unsigned int>(value, set_by);\n            }\n\n            uint64_t uint64_variable() const { return GetValue<TYPE_UINT64, uint64_t>(); }\n\n            void set_uint64_variable(uint64_t value, SetBy set_by) {\n                SetValue<TYPE_UINT64, uint64_t>(value, set_by);\n            }\n\n            double float_variable() const { return GetValue<TYPE_FLOAT, double>(); }\n\n            void set_float_variable(double value, SetBy set_by) {\n                SetValue<TYPE_FLOAT, double>(value, set_by);\n            }\n\n            size_t size_t_variable() const { return GetValue<TYPE_SIZE_T, size_t>(); }\n\n            void set_size_t_variable(size_t value, SetBy set_by) {\n                SetValue<TYPE_SIZE_T, size_t>(value, set_by);\n            }\n\n            const char* string_value() const {\n                return GetValue<TYPE_STRING, const char*>();\n            }\n\n            void set_string_value(const char* new_value, bool owns_new_value,\n                                SetBy set_by);\n\n            template <typename T>\n            T GetDefaultValue() const {\n                return *reinterpret_cast<const T*>(defptr_);\n            }\n\n            bool bool_default() const {\n                DCHECK_EQ(TYPE_BOOL, type_);\n                return GetDefaultValue<bool>();\n            }\n\n            int int_default() const {\n                DCHECK_EQ(TYPE_INT, type_);\n                return GetDefaultValue<int>();\n            }\n\n            unsigned int uint_default() const {\n                DCHECK_EQ(TYPE_UINT, type_);\n                return GetDefaultValue<unsigned int>();\n            }\n\n            uint64_t uint64_default() const {\n                DCHECK_EQ(TYPE_UINT64, type_);\n                return GetDefaultValue<uint64_t>();\n            }\n\n            double float_default() const {\n                DCHECK_EQ(TYPE_FLOAT, type_);\n                return GetDefaultValue<double>();\n            }\n\n            size_t size_t_default() const {\n                DCHECK_EQ(TYPE_SIZE_T, type_);\n                return GetDefaultValue<size_t>();\n            }\n\n            const char* string_default() const {\n                DCHECK_EQ(TYPE_STRING, type_);\n                return GetDefaultValue<const char*>();\n            }\n\n            static bool ShouldCheckFlagContradictions();\n\n            // {change_flag} indicates if we're going to change the flag value.\n            // Returns an updated value for {change_flag}, which is changed to false if a\n            // weak implication is being ignored beause a flag is already set by a normal\n            // implication or from the command-line.\n            bool CheckFlagChange(SetBy new_set_by, bool change_flag,\n                                const char* implied_by = nullptr);\n\n            bool IsReadOnly() const {\n                // See the FLAG_READONLY definition for FLAG_MODE_META.\n                return valptr_ == nullptr;\n            }\n\n            template <FlagType flag_type, typename T>\n            T GetValue() const {\n                DCHECK_EQ(flag_type, type_);\n                if (IsReadOnly()) return GetDefaultValue<T>();\n                return *reinterpret_cast<const FlagValue<T>*>(valptr_);\n            }\n\n            template <FlagType flag_type, typename T>\n            void SetValue(T new_value, SetBy set_by) {\n                DCHECK_EQ(flag_type, type_);\n                bool change_flag = GetValue<flag_type, T>() != new_value;\n                change_flag = CheckFlagChange(set_by, change_flag);\n                if (change_flag) {\n                DCHECK(!IsReadOnly());\n                *reinterpret_cast<FlagValue<T>*>(valptr_) = new_value;\n                }\n            }\n\n            // Compare this flag's current value against the default.\n            bool IsDefault() const;\n\n            void ReleaseDynamicAllocations();\n\n            // Set a flag back to its default value.\n            V8_EXPORT_PRIVATE void Reset();\n\n            void AllowOverwriting() { set_by_ = SetBy::kDefault; }\n            };\n        ]]></code>\n    </struct>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"base::Vector\",\n                \"about\": \"A dynamically sized array (vector) from the V8 base library.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace base {\n                    template <typename T>\n                    class Vector {};\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}