{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-function-callback.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-function-callback.h\",\n            \"file_name\": \"v8-function-callback.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the API for function callback invocation and argument handling in V8.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ headers for integer types and limits.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <cstdint>\n            #include <limits>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes V8 internal headers for low-level access and configuration.  These are typically only accessible within the V8 codebase.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"v8-internal.h\"      // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n            #include \"v8-primitive.h\"     // NOLINT(build/include_directory)\n            #include \"v8config.h\"         // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReturnValue\",\n                \"about\": \"Represents the return value of a function callback.  Provides methods for setting the return value with different types.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"value_\",\n                        \"type\": \"internal::Address*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the memory location where the return value is stored.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Global\",\n                    \"BasicTracedReference\",\n                    \"Local\",\n                    \"Value\",\n                    \"Boolean\",\n                    \"Integer\",\n                    \"Number\",\n                    \"String\",\n                    \"Primitive\",\n                    \"Isolate\",\n                    \"internal::Internals\",\n                    \"internal::Address\",\n                    \"FunctionCallbackInfo\",\n                    \"PropertyCallbackInfo\",\n                    \"PersistentValueMapBase\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class ReturnValue {\n            public:\n            template <class S>\n            V8_INLINE ReturnValue(const ReturnValue<S>& that) : value_(that.value_) {\n                static_assert(std::is_base_of<T, S>::value, \"type check\");\n            }\n            // Handle-based setters.\n            template <typename S>\n            V8_INLINE void Set(const Global<S>& handle);\n            template <typename S>\n            V8_INLINE void SetNonEmpty(const Global<S>& handle);\n            template <typename S>\n            V8_INLINE void Set(const BasicTracedReference<S>& handle);\n            template <typename S>\n            V8_INLINE void SetNonEmpty(const BasicTracedReference<S>& handle);\n            template <typename S>\n            V8_INLINE void Set(const Local<S> handle);\n            template <typename S>\n            V8_INLINE void SetNonEmpty(const Local<S> handle);\n            // Fast primitive number setters.\n            V8_INLINE void Set(bool value);\n            V8_INLINE void Set(double i);\n            V8_INLINE void Set(int16_t i);\n            V8_INLINE void Set(int32_t i);\n            V8_INLINE void Set(int64_t i);\n            V8_INLINE void Set(uint16_t i);\n            V8_INLINE void Set(uint32_t i);\n            V8_INLINE void Set(uint64_t i);\n            // Fast JS primitive setters\n            V8_INLINE void SetNull();\n            V8_INLINE void SetUndefined();\n            V8_INLINE void SetFalse();\n            V8_INLINE void SetEmptyString();\n            // Convenience getter for Isolate\n            V8_INLINE Isolate* GetIsolate() const;\n\n            // Pointer setter: Uncompilable to prevent inadvertent misuse.\n            template <typename S>\n            V8_INLINE void Set(S* whatever);\n\n            // Getter. Creates a new Local<> so it comes with a certain performance\n            // hit. If the ReturnValue was not yet set, this will return the undefined\n            // value.\n            V8_INLINE Local<Value> Get() const;\n\n            private:\n            template <class F>\n            friend class ReturnValue;\n            template <class F>\n            friend class FunctionCallbackInfo;\n            template <class F>\n            friend class PropertyCallbackInfo;\n            template <class F, class G, class H>\n            friend class PersistentValueMapBase;\n            V8_INLINE void SetInternal(internal::Address value);\n            // Default value depends on <T>:\n            //  - <void> -> true_value,\n            //  - <v8::Boolean> -> true_value,\n            //  - <v8::Integer> -> 0,\n            //  - <v8::Value> -> undefined_value,\n            //  - <v8::Array> -> undefined_value.\n            V8_INLINE void SetDefaultValue();\n            V8_INLINE explicit ReturnValue(internal::Address* slot);\n\n            // See FunctionCallbackInfo.\n            static constexpr int kIsolateValueIndex = -2;\n\n            internal::Address* value_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FunctionCallbackInfo\",\n                \"about\": \"Provides access to information about the context of a function call callback, including arguments, receiver, and function holder.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"implicit_args_\",\n                        \"type\": \"internal::Address*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to implicit arguments passed to the callback.\"\n                    },\n                    {\n                        \"name\": \"values_\",\n                        \"type\": \"internal::Address*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the array of argument values.\"\n                    },\n                    {\n                        \"name\": \"length_\",\n                        \"type\": \"internal::Address\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Length of the arguments array.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Value\",\n                    \"Object\",\n                    \"Isolate\",\n                    \"ReturnValue\",\n                    \"internal::FunctionCallbackArguments\",\n                    \"internal::CustomArguments\",\n                    \"debug::ConsoleCallArguments\",\n                    \"internal::Address\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class FunctionCallbackInfo {\n            public:\n            /** The number of available arguments. */\n            V8_INLINE int Length() const;\n            /**\n             * Accessor for the available arguments. Returns `undefined` if the index\n             * is out of bounds.\n             */\n            V8_INLINE Local<Value> operator[](int i) const;\n            /** Returns the receiver. This corresponds to the \"this\" value. */\n            V8_INLINE Local<Object> This() const;\n            /** For construct calls, this returns the \"new.target\" value. */\n            V8_INLINE Local<Value> NewTarget() const;\n            /** Indicates whether this is a regular call or a construct call. */\n            V8_INLINE bool IsConstructCall() const;\n            /** The data argument specified when creating the callback. */\n            V8_INLINE Local<Value> Data() const;\n            /** The current Isolate. */\n            V8_INLINE Isolate* GetIsolate() const;\n            /** The ReturnValue for the call. */\n            V8_INLINE ReturnValue<T> GetReturnValue() const;\n\n            private:\n            friend class internal::FunctionCallbackArguments;\n            friend class internal::CustomArguments<FunctionCallbackInfo>;\n            friend class debug::ConsoleCallArguments;\n            friend void internal::PrintFunctionCallbackInfo(void*);\n\n            // TODO(ishell, http://crbug.com/326505377): in case of non-constructor\n            // call, don't pass kNewTarget and kUnused. Add IsConstructCall flag to\n            // kIsolate field.\n            static constexpr int kUnusedIndex = 0;\n            static constexpr int kIsolateIndex = 1;\n            static constexpr int kContextIndex = 2;\n            static constexpr int kReturnValueIndex = 3;\n            static constexpr int kTargetIndex = 4;\n            static constexpr int kNewTargetIndex = 5;\n            static constexpr int kArgsLength = 6;\n\n            static constexpr int kArgsLengthWithReceiver = kArgsLength + 1;\n\n            // Codegen constants:\n            static constexpr int kSize = 3 * internal::kApiSystemPointerSize;\n            static constexpr int kImplicitArgsOffset = 0;\n            static constexpr int kValuesOffset =\n                kImplicitArgsOffset + internal::kApiSystemPointerSize;\n            static constexpr int kLengthOffset =\n                kValuesOffset + internal::kApiSystemPointerSize;\n\n            static constexpr int kThisValuesIndex = -1;\n            static_assert(ReturnValue<Value>::kIsolateValueIndex ==\n                        kIsolateIndex - kReturnValueIndex);\n\n            V8_INLINE FunctionCallbackInfo(internal::Address* implicit_args,\n                                            internal::Address* values, int length);\n\n            // TODO(https://crbug.com/326505377): flatten the v8::FunctionCallbackInfo\n            // object to avoid indirect loads through values_ and implicit_args_ and\n            // reduce the number of instructions in the CallApiCallback builtin.\n            internal::Address* implicit_args_;\n            internal::Address* values_;\n            internal::Address length_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"PropertyCallbackInfo\",\n                \"about\": \"Provides information about the context of a property access callback, including the receiver, holder, and return value.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"args_\",\n                        \"type\": \"internal::Address\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of arguments passed to the property callback.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Value\",\n                    \"Object\",\n                    \"Isolate\",\n                    \"ReturnValue\",\n                    \"internal::PropertyCallbackArguments\",\n                    \"internal::CustomArguments\",\n                    \"internal::Address\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class PropertyCallbackInfo {\n            public:\n            /**\n             * \\return The isolate of the property access.\n             */\n            V8_INLINE Isolate* GetIsolate() const;\n\n            /**\n             * \\return The data set in the configuration, i.e., in\n             * `NamedPropertyHandlerConfiguration` or\n             * `IndexedPropertyHandlerConfiguration.`\n             */\n            V8_INLINE Local<Value> Data() const;\n\n            /**\n             * \\return The receiver. In many cases, this is the object on which the\n             * property access was intercepted. When using\n             * `Reflect.get`, `Function.prototype.call`, or similar functions, it is the\n             * object passed in as receiver or thisArg.\n             *\n             * \\code\n             *  void GetterCallback(Local<Name> name,\n             *                      const v8::PropertyCallbackInfo<v8::Value>& info) {\n             *     auto context = info.GetIsolate()->GetCurrentContext();\n             *\n             *     v8::Local<v8::Value> a_this =\n             *         info.This()\n             *             ->GetRealNamedProperty(context, v8_str(\"a\"))\n             *             .ToLocalChecked();\n             *     v8::Local<v8::Value> a_holder =\n             *         info.Holder()\n             *             ->GetRealNamedProperty(context, v8_str(\"a\"))\n             *             .ToLocalChecked();\n             *\n             *    CHECK(v8_str(\"r\")->Equals(context, a_this).FromJust());\n             *    CHECK(v8_str(\"obj\")->Equals(context, a_holder).FromJust());\n             *\n             *    info.GetReturnValue().Set(name);\n             *  }\n             *\n             *  v8::Local<v8::FunctionTemplate> templ =\n             *  v8::FunctionTemplate::New(isolate);\n             *  templ->InstanceTemplate()->SetHandler(\n             *      v8::NamedPropertyHandlerConfiguration(GetterCallback));\n             *  LocalContext env;\n             *  env->Global()\n             *      ->Set(env.local(), v8_str(\"obj\"), templ->GetFunction(env.local())\n             *                                           .ToLocalChecked()\n             *                                           ->NewInstance(env.local())\n             *                                           .ToLocalChecked())\n             *      .FromJust();\n             *\n             *  CompileRun(\"obj.a = 'obj'; var r = {a: 'r'}; Reflect.get(obj, 'x', r)\");\n             * \\endcode\n             */\n            V8_INLINE Local<Object> This() const;\n\n            /**\n             * \\return The object in the prototype chain of the receiver that has the\n             * interceptor. Suppose you have `x` and its prototype is `y`, and `y`\n             * has an interceptor. Then `info.This()` is `x` and `info.Holder()` is `y`.\n             * The Holder() could be a hidden object (the global object, rather\n             * than the global proxy).\n             *\n             * \\note For security reasons, do not pass the object back into the runtime.\n             */\n            V8_DEPRECATE_SOON(\n                \"V8 will stop providing access to hidden prototype (i.e. \"\n                \"JSGlobalObject). Use HolderV2() instead. \\n\"\n                \"DO NOT try to workaround this by accessing JSGlobalObject via \"\n                \"v8::Object::GetPrototype() - it'll be deprecated soon too. \\n\"\n                \"See http://crbug.com/333672197. \")\n            V8_INLINE Local<Object> Holder() const;\n\n            /**\n             * \\return The object in the prototype chain of the receiver that has the\n             * interceptor. Suppose you have `x` and its prototype is `y`, and `y`\n             * has an interceptor. Then `info.This()` is `x` and `info.Holder()` is `y`.\n             * In case the property is installed on the global object the Holder()\n             * would return the global proxy.\n             */\n            V8_INLINE Local<Object> HolderV2() const;\n\n            /**\n             * \\return The return value of the callback.\n             * Can be changed by calling Set().\n             * \\code\n             * info.GetReturnValue().Set(...)\n             * \\endcode\n             *\n             */\n            V8_INLINE ReturnValue<T> GetReturnValue() const;\n\n            /**\n             * \\return True if the intercepted function should throw if an error occurs.\n             * Usually, `true` corresponds to `'use strict'`.\n             *\n             * \\note Always `false` when intercepting `Reflect.set()`\n             * independent of the language mode.\n             */\n            V8_INLINE bool ShouldThrowOnError() const;\n\n            private:\n            template <typename U>\n            friend class PropertyCallbackInfo;\n            friend class MacroAssembler;\n            friend class internal::PropertyCallbackArguments;\n            friend class internal::CustomArguments<PropertyCallbackInfo>;\n            friend void internal::PrintPropertyCallbackInfo(void*);\n\n            static constexpr int kPropertyKeyIndex = 0;\n            static constexpr int kShouldThrowOnErrorIndex = 1;\n            static constexpr int kHolderIndex = 2;\n            static constexpr int kIsolateIndex = 3;\n            static constexpr int kHolderV2Index = 4;\n            static constexpr int kReturnValueIndex = 5;\n            static constexpr int kDataIndex = 6;\n            static constexpr int kThisIndex = 7;\n            static constexpr int kArgsLength = 8;\n\n            static constexpr int kSize = kArgsLength * internal::kApiSystemPointerSize;\n\n            PropertyCallbackInfo() = default;\n\n            mutable internal::Address args_[kArgsLength];\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetFunctionTemplateData\",\n                \"parent\": \"api_internal\",\n                \"about\": \"Retrieves the data associated with a function template.\",\n                \"logic\": \"This function is likely used to access data stored within a FunctionTemplate object, which can then be used within a function callback.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"v8::Isolate*\",\n                        \"purpose\": \"The isolate the function template belongs to.\"\n                    },\n                    {\n                        \"name\": \"raw_target\",\n                        \"type\": \"v8::Local<v8::Data>\",\n                        \"purpose\": \"The function template.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"v8::Local<v8::Value>\",\n                    \"description\": \"The data associated with the function template.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace api_internal {\n            V8_EXPORT v8::Local<v8::Value> GetFunctionTemplateData(\n                v8::Isolate* isolate, v8::Local<v8::Data> raw_target);\n            }  // namespace api_internal\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ConvertToJSGlobalProxyIfNecessary\",\n                \"parent\": \"api_internal\",\n                \"about\": \"Conditionally converts a holder address to the JSGlobalProxy if it represents the JSGlobalObject.\",\n                \"logic\": \"Used to ensure that property lookups on the global object are correctly routed through the global proxy, especially in contexts where the raw JSGlobalObject might be exposed.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"holder\",\n                        \"type\": \"internal::Address\",\n                        \"purpose\": \"The address of the holder object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"internal::Address\",\n                    \"description\": \"The address of the JSGlobalProxy or the original holder if no conversion is needed.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace api_internal {\n            // Returns JSGlobalProxy if holder is JSGlobalObject or unmodified holder\n            // otherwise.\n            V8_EXPORT internal::Address ConvertToJSGlobalProxyIfNecessary(\n                internal::Address holder);\n            }  // namespace api_internal\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"using\",\n                \"name\": \"FunctionCallback\",\n                \"about\": \"Defines a type alias for the function callback signature.\",\n                \"logic\": \"This alias simplifies the declaration of function callbacks used in V8's API.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"FunctionCallbackInfo\",\n                    \"Value\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            using FunctionCallback = void (*)(const FunctionCallbackInfo<Value>& info);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReturnValue::ReturnValue\",\n                \"parent\": \"ReturnValue\",\n                \"about\": \"Constructor for the ReturnValue class.\",\n                \"logic\": \"Initializes the value_ member with the provided slot address.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"slot\",\n                        \"type\": \"internal::Address*\",\n                        \"purpose\": \"Pointer to the memory location for the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"internal::Address\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            ReturnValue<T>::ReturnValue(internal::Address* slot) : value_(slot) {}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReturnValue::SetInternal\",\n                \"parent\": \"ReturnValue\",\n                \"about\": \"Sets the internal address of the return value.\",\n                \"logic\": \"Sets the value in the `value_` slot. The implementation uses `I::DecompressTaggedField` and `I::CompressTagged` to handle memory compression. The compiler should optimize this to a store of a lower 32-bits of the value, as only JavaScript values can be returned.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"internal::Address\",\n                        \"purpose\": \"The address to set as the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"internal::Address\",\n                    \"internal::Internals\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ReturnValue<T>::SetInternal(internal::Address value) {\n            #if V8_STATIC_ROOTS_BOOL\n            using I = internal::Internals;\n            // Ensure that the upper 32-bits are not modified. Compiler should be\n            // able to optimize this to a store of a lower 32-bits of the value.\n            // This is fine since the callback can return only JavaScript values which\n            // are either Smis or heap objects allocated in the main cage.\n            *value_ = I::DecompressTaggedField(*value_, I::CompressTagged(value));\n            #else\n            *value_ = value;\n            #endif  // V8_STATIC_ROOTS_BOOL\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReturnValue::Set\",\n                \"parent\": \"ReturnValue\",\n                \"about\": \"Sets the return value using a Global handle.\",\n                \"logic\": \"If the handle is empty, the default value is set. Otherwise, the internal address of the handle is used.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"const Global<S>&\",\n                        \"purpose\": \"The Global handle to set as the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Global\",\n                    \"SetDefaultValue\",\n                    \"SetInternal\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            template <typename S>\n            void ReturnValue<T>::Set(const Global<S>& handle) {\n            static_assert(std::is_base_of<T, S>::value, \"type check\");\n            if (V8_UNLIKELY(handle.IsEmpty())) {\n                SetDefaultValue();\n            } else {\n                SetInternal(handle.ptr());\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReturnValue::SetNonEmpty\",\n                \"parent\": \"ReturnValue\",\n                \"about\": \"Sets the return value using a Global handle, asserting that the handle is not empty.\",\n                \"logic\": \"The internal address of the handle is set as the return value after an assertion on handle emptiness.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"const Global<S>&\",\n                        \"purpose\": \"The Global handle to set as the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Global\",\n                    \"SetInternal\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            template <typename S>\n            void ReturnValue<T>::SetNonEmpty(const Global<S>& handle) {\n            static_assert(std::is_base_of<T, S>::value, \"type check\");\n            #ifdef V8_ENABLE_CHECKS\n            internal::VerifyHandleIsNonEmpty(handle.IsEmpty());\n            #endif  // V8_ENABLE_CHECKS\n            SetInternal(handle.ptr());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReturnValue::Set\",\n                \"parent\": \"ReturnValue\",\n                \"about\": \"Sets the return value using a BasicTracedReference.\",\n                \"logic\": \"If the handle is empty, the default value is set. Otherwise, the internal address of the handle is used.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"const BasicTracedReference<S>&\",\n                        \"purpose\": \"The BasicTracedReference to set as the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"BasicTracedReference\",\n                    \"SetDefaultValue\",\n                    \"SetInternal\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            template <typename S>\n            void ReturnValue<T>::Set(const BasicTracedReference<S>& handle) {\n            static_assert(std::is_base_of<T, S>::value, \"type check\");\n            if (V8_UNLIKELY(handle.IsEmpty())) {\n                SetDefaultValue();\n            } else {\n                SetInternal(handle.ptr());\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReturnValue::SetNonEmpty\",\n                \"parent\": \"ReturnValue\",\n                \"about\": \"Sets the return value using a BasicTracedReference, asserting that the handle is not empty.\",\n                \"logic\": \"The internal address of the handle is set as the return value after an assertion on handle emptiness.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"const BasicTracedReference<S>&\",\n                        \"purpose\": \"The BasicTracedReference to set as the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"BasicTracedReference\",\n                    \"SetInternal\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            template <typename S>\n            void ReturnValue<T>::SetNonEmpty(const BasicTracedReference<S>& handle) {\n            static_assert(std::is_base_of<T, S>::value, \"type check\");\n            #ifdef V8_ENABLE_CHECKS\n            internal::VerifyHandleIsNonEmpty(handle.IsEmpty());\n            #endif  // V8_ENABLE_CHECKS\n            SetInternal(handle.ptr());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReturnValue::Set\",\n                \"parent\": \"ReturnValue\",\n                \"about\": \"Sets the return value using a Local handle.\",\n                \"logic\": \"If the handle is empty, the default value is set.  Otherwise, sets the internal representation.  If T is void, simulates old behavior by setting the return value to a boolean representation of the handle.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"const Local<S>\",\n                        \"purpose\": \"The Local handle to set as the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Local\",\n                    \"SetDefaultValue\",\n                    \"SetInternal\",\n                    \"GetIsolate\",\n                    \"BooleanValue\",\n                    \"Boolean\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            template <typename S>\n            void ReturnValue<T>::Set(const Local<S> handle) {\n            // \"V8_DEPRECATE_SOON\" this method if |T| is |void|.\n            #ifdef V8_IMMINENT_DEPRECATION_WARNINGS\n            static constexpr bool is_allowed_void = false;\n            static_assert(!std::is_void<T>::value,\n                        \"ReturnValue<void>::Set(const Local<S>) is deprecated. \"\n                        \"Do nothing to indicate that the operation succeeded or use \"\n                        \"SetFalse() to indicate that the operation failed (don't \"\n                        \"forget to handle info.ShouldThrowOnError()). \"\n                        \"See http://crbug.com/348660658 for details.\");\n            #else\n            static constexpr bool is_allowed_void = std::is_void<T>::value;\n            #endif  // V8_IMMINENT_DEPRECATION_WARNINGS\n            static_assert(is_allowed_void || std::is_base_of<T, S>::value, \"type check\");\n            if (V8_UNLIKELY(handle.IsEmpty())) {\n                SetDefaultValue();\n            } else if constexpr (is_allowed_void) {\n                // Simulate old behaviour for \"v8::AccessorSetterCallback\" for which\n                // it was possible to set the return value even for ReturnValue<void>.\n                Set(handle->BooleanValue(GetIsolate()));\n            } else {\n                SetInternal(handle.ptr());\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReturnValue::SetNonEmpty\",\n                \"parent\": \"ReturnValue\",\n                \"about\": \"Sets the return value using a Local handle, asserting that the handle is not empty.\",\n                \"logic\": \"The internal address of the handle is set as the return value after an assertion on handle emptiness. If T is void, simulates old behavior by setting the return value to a boolean representation of the handle.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"handle\",\n                        \"type\": \"const Local<S>\",\n                        \"purpose\": \"The Local handle to set as the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Local\",\n                    \"SetInternal\",\n                    \"GetIsolate\",\n                    \"BooleanValue\",\n                    \"Boolean\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            template <typename S>\n            void ReturnValue<T>::SetNonEmpty(const Local<S> handle) {\n            // \"V8_DEPRECATE_SOON\" this method if |T| is |void|.\n            #ifdef V8_IMMINENT_DEPRECATION_WARNINGS\n            static constexpr bool is_allowed_void = false;\n            static_assert(!std::is_void<T>::value,\n                        \"ReturnValue<void>::SetNonEmpty(const Local<S>) is deprecated. \"\n                        \"Do nothing to indicate that the operation succeeded or use \"\n                        \"SetFalse() to indicate that the operation failed (don't \"\n                        \"forget to handle info.ShouldThrowOnError()). \"\n                        \"See http://crbug.com/348660658 for details.\");\n            #else\n            static constexpr bool is_allowed_void = std::is_void<T>::value;\n            #endif  // V8_IMMINENT_DEPRECATION_WARNINGS\n            static_assert(is_allowed_void || std::is_base_of<T, S>::value, \"type check\");\n            #ifdef V8_ENABLE_CHECKS\n            internal::VerifyHandleIsNonEmpty(handle.IsEmpty());\n            #endif  // V8_ENABLE_CHECKS\n            if constexpr (is_allowed_void) {\n                // Simulate old behaviour for \"v8::AccessorSetterCallback\" for which\n                // it was possible to set the return value even for ReturnValue<void>.\n                Set(handle->BooleanValue(GetIsolate()));\n            } else {\n                SetInternal(handle.ptr());\n            }\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReturnValue::Set\",\n                \"parent\": \"ReturnValue\",\n                \"about\": \"Sets the return value using a double.\",\n                \"logic\": \"Creates a new Number object and sets its internal address.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"i\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The double value to set as the return value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Number\",\n                    \"SetNonEmpty\",\n                    \"GetIsolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void ReturnValue<T"
}