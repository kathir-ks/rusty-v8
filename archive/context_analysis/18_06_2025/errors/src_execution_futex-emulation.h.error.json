{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/futex-emulation.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 139, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/futex-emulation.h\",\n            \"file_name\": \"futex-emulation.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the FutexEmulation class, which provides an emulation of futexes (fast user-space mutexes) for platforms that don't natively support them. Used for SharedArrayBuffer synchronization.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Standard library includes\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <stdint.h>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"V8 includes for persistent handles, atomic operations, macros, condition variables, time, tasks, and allocation utilities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"include/v8-persistent-handle.h\"\n#include \"src/base/atomicops.h\"\n#include \"src/base/macros.h\"\n#include \"src/base/platform/condition-variable.h\"\n#include \"src/base/platform/time.h\"\n#include \"src/tasks/cancelable-task.h\"\n#include \"src/utils/allocation.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AtomicsWaitWakeHandle\",\n                \"about\": \"Handles waking up threads waiting on an atomic operation.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"stopped_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the handle has been stopped.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass AtomicsWaitWakeHandle {\n public:\n  explicit AtomicsWaitWakeHandle(Isolate* isolate) : isolate_(isolate) {}\n\n  void Wake();\n  inline bool has_stopped() const { return stopped_; }\n\n private:\n  Isolate* isolate_;\n  bool stopped_ = false;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FutexWaitListNode\",\n                \"about\": \"Represents a node in the wait list for a futex.  Can be either synchronous or asynchronous.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"cond_\",\n                        \"type\": \"base::ConditionVariable\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Condition variable used for waiting.\"\n                    },\n                    {\n                        \"name\": \"prev_\",\n                        \"type\": \"FutexWaitListNode*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the previous node in the wait list.\"\n                    },\n                    {\n                        \"name\": \"next_\",\n                        \"type\": \"FutexWaitListNode*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the next node in the wait list.\"\n                    },\n                    {\n                        \"name\": \"wait_location_\",\n                        \"type\": \"void*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The memory location the FutexWaitListNode is waiting on.\"\n                    },\n                    {\n                        \"name\": \"waiting_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the node is currently waiting.\"\n                    },\n                    {\n                        \"name\": \"interrupted_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the wait has been interrupted.\"\n                    },\n                    {\n                        \"name\": \"async_state_\",\n                        \"type\": \"std::unique_ptr<AsyncState>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"State used for an async wait; nullptr on sync waits.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BackingStore\",\n                    \"JSObject\",\n                    \"Isolate\",\n                    \"TaskRunner\",\n                    \"base::ConditionVariable\",\n                    \"base::TimeTicks\",\n                    \"CancelableTaskManager\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass FutexWaitListNode {\n public:\n  // Create a sync FutexWaitListNode.\n  FutexWaitListNode() = default;\n\n  // Create an async FutexWaitListNode.\n  FutexWaitListNode(std::weak_ptr<BackingStore> backing_store,\n                    void* wait_location,\n                    DirectHandle<JSObject> promise_capability,\n                    Isolate* isolate);\n\n  // Disallow copying nodes.\n  FutexWaitListNode(const FutexWaitListNode&) = delete;\n  FutexWaitListNode& operator=(const FutexWaitListNode&) = delete;\n\n  void NotifyWake();\n\n  bool IsAsync() const { return async_state_ != nullptr; }\n\n  // Returns false if the cancelling failed, true otherwise.\n  bool CancelTimeoutTask();\n\n private:\n  friend class FutexEmulation;\n  friend class FutexWaitList;\n\n  // Async wait requires substantially more information than synchronous wait.\n  // Hence store that additional information in a heap-allocated struct to make\n  // it more obvious that this will only be needed for the async case.\n  struct AsyncState {\n    AsyncState(Isolate* isolate, std::shared_ptr<TaskRunner> task_runner,\n               std::weak_ptr<BackingStore> backing_store,\n               v8::Global<v8::Promise> promise,\n               v8::Global<v8::Context> native_context)\n        : isolate_for_async_waiters(isolate),\n          task_runner(std::move(task_runner)),\n          backing_store(std::move(backing_store)),\n          promise(std::move(promise)),\n          native_context(std::move(native_context)) {\n      DCHECK(this->promise.IsWeak());\n      DCHECK(this->native_context.IsWeak());\n    }\n\n    ~AsyncState() {\n      // Assert that the timeout task was cancelled.\n      DCHECK_EQ(CancelableTaskManager::kInvalidTaskId, timeout_task_id);\n    }\n\n    Isolate* const isolate_for_async_waiters;\n    std::shared_ptr<TaskRunner> const task_runner;\n\n    // The backing store on which we are waiting might die in an async wait.\n    // We keep a weak_ptr to verify during a wake operation that the original\n    // backing store is still mapped to that address.\n    std::weak_ptr<BackingStore> const backing_store;\n\n    // Weak Global handle. Must not be synchronously resolved by a non-owner\n    // Isolate.\n    v8::Global<v8::Promise> const promise;\n\n    // Weak Global handle.\n    v8::Global<v8::Context> const native_context;\n\n    // If timeout_time_ is base::TimeTicks(), this async waiter doesn't have a\n    // timeout or has already been notified. Values other than base::TimeTicks()\n    // are used for async waiters with an active timeout.\n    base::TimeTicks timeout_time;\n\n    // The task ID of the timeout task.\n    CancelableTaskManager::Id timeout_task_id =\n        CancelableTaskManager::kInvalidTaskId;\n  };\n\n  base::ConditionVariable cond_;\n  // prev_ and next_ are protected by FutexEmulationGlobalState::mutex.\n  FutexWaitListNode* prev_ = nullptr;\n  FutexWaitListNode* next_ = nullptr;\n\n  // The memory location the FutexWaitListNode is waiting on. Equals\n  // backing_store_->buffer_start() + wait_addr at FutexWaitListNode creation\n  // time. This address is used find the node in the per-location list, or to\n  // remove it.\n  // Note that during an async wait the BackingStore might get deleted while\n  // this node is alive.\n  void* wait_location_ = nullptr;\n\n  // waiting_ and interrupted_ are protected by FutexEmulationGlobalState::mutex\n  // if this node is currently contained in FutexEmulationGlobalState::wait_list\n  // or an AtomicsWaitWakeHandle has access to it.\n  bool waiting_ = false;\n  bool interrupted_ = false;\n\n  // State used for an async wait; nullptr on sync waits.\n  const std::unique_ptr<AsyncState> async_state_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FutexEmulation\",\n                \"about\": \"Provides an emulation of futexes (fast user-space mutexes) for platforms that don't natively support them.\",\n                \"dependencies\": [\n                    \"JSArrayBuffer\",\n                    \"Isolate\",\n                    \"FutexWaitListNode\",\n                    \"Tagged<Object>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass FutexEmulation : public AllStatic {\n public:\n  enum WaitMode { kSync = 0, kAsync };\n  enum class CallType { kIsNotWasm = 0, kIsWasm };\n\n  // Pass to Wake() to wake all waiters.\n  static const uint32_t kWakeAll = UINT32_MAX;\n\n  // Check that array_buffer[addr] == value, and return \"not-equal\" if not. If\n  // they are equal, block execution on |isolate|'s thread until woken via\n  // |Wake|, or when the time given in |rel_timeout_ms| elapses. Note that\n  // |rel_timeout_ms| can be Infinity.\n  // If woken, return \"ok\", otherwise return \"timed-out\". The initial check and\n  // the decision to wait happen atomically.\n  static Tagged<Object> WaitJs32(Isolate* isolate, WaitMode mode,\n                                 DirectHandle<JSArrayBuffer> array_buffer,\n                                 size_t addr, int32_t value,\n                                 double rel_timeout_ms);\n\n  // An version of WaitJs32 for int64_t values.\n  static Tagged<Object> WaitJs64(Isolate* isolate, WaitMode mode,\n                                 DirectHandle<JSArrayBuffer> array_buffer,\n                                 size_t addr, int64_t value,\n                                 double rel_timeout_ms);\n\n  // Same as WaitJs above except it returns 0 (ok), 1 (not equal) and 2 (timed\n  // out) as expected by Wasm.\n  V8_EXPORT_PRIVATE static Tagged<Object> WaitWasm32(\n      Isolate* isolate, DirectHandle<JSArrayBuffer> array_buffer, size_t addr,\n      int32_t value, int64_t rel_timeout_ns);\n\n  // Same as Wait32 above except it checks for an int64_t value in the\n  // array_buffer.\n  V8_EXPORT_PRIVATE static Tagged<Object> WaitWasm64(\n      Isolate* isolate, DirectHandle<JSArrayBuffer> array_buffer, size_t addr,\n      int64_t value, int64_t rel_timeout_ns);\n\n  // Wake |num_waiters_to_wake| threads that are waiting on the given |addr|.\n  // |num_waiters_to_wake| can be kWakeAll, in which case all waiters are\n  // woken. The rest of the waiters will continue to wait. The return value is\n  // the number of woken waiters.\n  // Variant 1: Compute the wait address from the |array_buffer| and |addr|.\n  V8_EXPORT_PRIVATE static int Wake(Tagged<JSArrayBuffer> array_buffer,\n                                    size_t addr, uint32_t num_waiters_to_wake);\n  // Variant 2: Pass raw |addr| (used for WebAssembly atomic.notify).\n  static int Wake(void* addr, uint32_t num_waiters_to_wake);\n\n  // Called before |isolate| dies. Removes async waiters owned by |isolate|.\n  static void IsolateDeinit(Isolate* isolate);\n\n  // Return the number of threads or async waiters waiting on |addr|. Should\n  // only be used for testing.\n  static int NumWaitersForTesting(Tagged<JSArrayBuffer> array_buffer,\n                                  size_t addr);\n\n  // Return the number of async waiters which were waiting for |addr| and are\n  // now waiting for the Promises to be resolved. Should only be used for\n  // testing.\n  static int NumUnresolvedAsyncPromisesForTesting(\n      Tagged<JSArrayBuffer> array_buffer, size_t addr);\n\n private:\n  friend class FutexWaitListNode;\n  friend class AtomicsWaitWakeHandle;\n  friend class ResolveAsyncWaiterPromisesTask;\n  friend class AsyncWaiterTimeoutTask;\n\n  template <typename T>\n  static Tagged<Object> Wait(Isolate* isolate, WaitMode mode,\n                             DirectHandle<JSArrayBuffer> array_buffer,\n                             size_t addr, T value, double rel_timeout_ms);\n\n  template <typename T>\n  static Tagged<Object> Wait(Isolate* isolate, WaitMode mode,\n                             DirectHandle<JSArrayBuffer> array_buffer,\n                             size_t addr, T value, bool use_timeout,\n                             int64_t rel_timeout_ns,\n                             CallType call_type = CallType::kIsNotWasm);\n\n  template <typename T>\n  static Tagged<Object> WaitSync(Isolate* isolate,\n                                 DirectHandle<JSArrayBuffer> array_buffer,\n                                 size_t addr, T value, bool use_timeout,\n                                 int64_t rel_timeout_ns, CallType call_type);\n\n  template <typename T>\n  static Tagged<Object> WaitAsync(Isolate* isolate,\n                                  DirectHandle<JSArrayBuffer> array_buffer,\n                                  size_t addr, T value, bool use_timeout,\n                                  int64_t rel_timeout_ns, CallType call_type);\n\n  // Resolve the Promises of the async waiters which belong to |isolate|.\n  static void ResolveAsyncWaiterPromises(Isolate* isolate);\n\n  static void ResolveAsyncWaiterPromise(FutexWaitListNode* node);\n\n  static void HandleAsyncWaiterTimeout(FutexWaitListNode* node);\n\n  static void NotifyAsyncWaiter(FutexWaitListNode* node);\n\n  // Remove the node's Promise from the NativeContext's Promise set.\n  static void CleanupAsyncWaiterPromise(FutexWaitListNode* node);\n};\n        ]]></code>\n    </class>\n</file>\n```"
}