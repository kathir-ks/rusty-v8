{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler-dispatcher/lazy-compile-dispatcher.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 110, column 48",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler-dispatcher/lazy-compile-dispatcher.h\",\n            \"file_name\": \"lazy-compile-dispatcher.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the LazyCompileDispatcher class, which manages lazy parsing and compilation of functions using idle and background tasks.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard C++ and V8 headers for various functionalities like data structures, memory management, threading, and compiler tools.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <cstdint>\n#include <memory>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#include \"src/base/atomic-utils.h\"\n#include \"src/base/macros.h\"\n#include \"src/base/platform/condition-variable.h\"\n#include \"src/base/platform/mutex.h\"\n#include \"src/base/platform/semaphore.h\"\n#include \"src/common/globals.h\"\n#include \"src/utils/identity-map.h\"\n#include \"testing/gtest/include/gtest/gtest_prod.h\"  // nogncheck\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LazyCompileDispatcher\",\n                \"about\": \"Manages lazy compilation of functions using idle-time and background tasks. It maintains queues of jobs, schedules tasks, and handles finalization.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the V8 isolate.\"\n                    },\n                    {\n                        \"name\": \"worker_thread_runtime_call_stats_\",\n                        \"type\": \"WorkerThreadRuntimeCallStats*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Statistics for worker thread runtime calls.\"\n                    },\n                    {\n                        \"name\": \"background_compile_timer_\",\n                        \"type\": \"TimedHistogram*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Timer for measuring background compilation time.\"\n                    },\n                    {\n                        \"name\": \"taskrunner_\",\n                        \"type\": \"std::shared_ptr<TaskRunner>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Shared pointer to the TaskRunner for scheduling tasks.\"\n                    },\n                    {\n                        \"name\": \"platform_\",\n                        \"type\": \"Platform*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the platform interface.\"\n                    },\n                    {\n                        \"name\": \"max_stack_size_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maximum stack size for compilation tasks.\"\n                    },\n                    {\n                        \"name\": \"job_handle_\",\n                        \"type\": \"std::unique_ptr<JobHandle>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Unique pointer to the JobHandle.\"\n                    },\n                    {\n                        \"name\": \"trace_compiler_dispatcher_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Copy of v8_flags.trace_compiler_dispatcher to allow for access from any thread.\"\n                    },\n                    {\n                        \"name\": \"idle_task_manager_\",\n                        \"type\": \"std::unique_ptr<CancelableTaskManager>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Manages idle tasks.\"\n                    },\n                    {\n                        \"name\": \"mutex_\",\n                        \"type\": \"base::Mutex\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mutex to protect shared data structures.\"\n                    },\n                    {\n                        \"name\": \"idle_task_scheduled_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether an idle task is scheduled.\"\n                    },\n                    {\n                        \"name\": \"pending_background_jobs_\",\n                        \"type\": \"std::vector<Job*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of jobs pending execution on a background thread.\"\n                    },\n                    {\n                        \"name\": \"finalizable_jobs_\",\n                        \"type\": \"std::vector<Job*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of jobs ready to be finalized on the main thread.\"\n                    },\n                    {\n                        \"name\": \"num_jobs_for_background_\",\n                        \"type\": \"std::atomic<size_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Atomic counter for the number of jobs ready to execute on a background thread.\"\n                    },\n                    {\n                        \"name\": \"all_jobs_\",\n                        \"type\": \"std::unordered_set<Job*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of all allocated jobs (DEBUG only).\"\n                    },\n                    {\n                        \"name\": \"jobs_to_dispose_\",\n                        \"type\": \"std::vector<Job*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of jobs to be deleted on the background thread(s).\"\n                    },\n                    {\n                        \"name\": \"main_thread_blocking_on_job_\",\n                        \"type\": \"Job*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The main thread waits for the task processing this job\"\n                    },\n                    {\n                        \"name\": \"main_thread_blocking_signal_\",\n                        \"type\": \"base::ConditionVariable\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Used to signal the main thread when a background job finishes.\"\n                    },\n                    {\n                        \"name\": \"block_for_testing_\",\n                        \"type\": \"base::AtomicValue<bool>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Test support: blocks the worker thread.\"\n                    },\n                    {\n                        \"name\": \"semaphore_for_testing_\",\n                        \"type\": \"base::Semaphore\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Test support: semaphore to sync with the main thread.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Platform\",\n                    \"SharedFunctionInfo\",\n                    \"Utf16CharacterStream\",\n                    \"JobDelegate\",\n                    \"BackgroundCompileTask\",\n                    \"CancelableTaskManager\",\n                    \"JobHandle\",\n                    \"IdentityMap\",\n                    \"TimedHistogram\",\n                    \"WorkerThreadRuntimeCallStats\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE LazyCompileDispatcher {\n public:\n  using JobId = uintptr_t;\n\n  LazyCompileDispatcher(Isolate* isolate, Platform* platform,\n                        size_t max_stack_size);\n  LazyCompileDispatcher(const LazyCompileDispatcher&) = delete;\n  LazyCompileDispatcher& operator=(const LazyCompileDispatcher&) = delete;\n  ~LazyCompileDispatcher();\n\n  void Enqueue(LocalIsolate* isolate, Handle<SharedFunctionInfo> shared_info,\n               std::unique_ptr<Utf16CharacterStream> character_stream);\n\n  // Returns true if there is a pending job registered for the given function.\n  bool IsEnqueued(DirectHandle<SharedFunctionInfo> function) const;\n\n  // Blocks until the given function is compiled (and does so as fast as\n  // possible). Returns true if the compile job was successful.\n  bool FinishNow(DirectHandle<SharedFunctionInfo> function);\n\n  // Aborts compilation job for the given function.\n  void AbortJob(DirectHandle<SharedFunctionInfo> function);\n\n  // Aborts all jobs, blocking until all jobs are aborted.\n  void AbortAll();\n\n private:\n  FRIEND_TEST(LazyCompileDispatcherTest, IdleTaskNoIdleTime);\n  FRIEND_TEST(LazyCompileDispatcherTest, IdleTaskSmallIdleTime);\n  FRIEND_TEST(LazyCompileDispatcherTest, FinishNowWithWorkerTask);\n  FRIEND_TEST(LazyCompileDispatcherTest, AbortJobNotStarted);\n  FRIEND_TEST(LazyCompileDispatcherTest, AbortJobAlreadyStarted);\n  FRIEND_TEST(LazyCompileDispatcherTest, AsyncAbortAllPendingWorkerTask);\n  FRIEND_TEST(LazyCompileDispatcherTest, AsyncAbortAllRunningWorkerTask);\n  FRIEND_TEST(LazyCompileDispatcherTest, CompileMultipleOnBackgroundThread);\n\n  // JobTask for PostJob API.\n  class JobTask;\n\n  struct Job {\n    enum class State {\n      // Background thread states (Enqueue + DoBackgroundWork)\n      // ---\n\n      // In the pending task queue.\n      kPending,\n      // Currently running on a background thread.\n      kRunning,\n      kAbortRequested,  // ... but we want to drop the result.\n      // In the finalizable task queue.\n      kReadyToFinalize,\n      kAborted,\n\n      // Main thread states (FinishNow and FinalizeSingleJob)\n      // ---\n\n      // Popped off the pending task queue.\n      kPendingToRunOnForeground,\n      // Popped off the finalizable task queue.\n      kFinalizingNow,\n      kAbortingNow,  // ... and we want to abort\n\n      // Finished finalizing, ready for deletion.\n      kFinalized,\n    };\n\n    explicit Job(std::unique_ptr<BackgroundCompileTask> task);\n    ~Job();\n\n    bool is_running_on_background() const {\n      return state == State::kRunning || state == State::kAbortRequested;\n    }\n\n    std::unique_ptr<BackgroundCompileTask> task;\n    State state = State::kPending;\n  };\n\n  using SharedToJobMap = IdentityMap<Job*, FreeStoreAllocationPolicy>;\n\n  void WaitForJobIfRunningOnBackground(Job* job, const base::MutexGuard&);\n  Job* GetJobFor(DirectHandle<SharedFunctionInfo> shared,\n                 const base::MutexGuard&) const;\n  Job* PopSingleFinalizeJob();\n  void ScheduleIdleTaskFromAnyThread(const base::MutexGuard&);\n  bool FinalizeSingleJob();\n  void DoBackgroundWork(JobDelegate* delegate);\n  void DoIdleWork(double deadline_in_seconds);\n\n  // DeleteJob without the mutex held.\n  void DeleteJob(Job* job);\n  // DeleteJob with the mutex already held.\n  void DeleteJob(Job* job, const base::MutexGuard&);\n\n  void NotifyAddedBackgroundJob(const base::MutexGuard& lock) {\n    ++num_jobs_for_background_;\n    VerifyBackgroundTaskCount(lock);\n  }\n  void NotifyRemovedBackgroundJob(const base::MutexGuard& lock) {\n    --num_jobs_for_background_;\n    VerifyBackgroundTaskCount(lock);\n  }\n\n#ifdef DEBUG\n  void VerifyBackgroundTaskCount(const base::MutexGuard&);\n#else\n  void VerifyBackgroundTaskCount(const base::MutexGuard&) {}\n#endif\n\n  Isolate* isolate_;\n  WorkerThreadRuntimeCallStats* worker_thread_runtime_call_stats_;\n  TimedHistogram* background_compile_timer_;\n  std::shared_ptr<TaskRunner> taskrunner_;\n  Platform* platform_;\n  size_t max_stack_size_;\n\n  std::unique_ptr<JobHandle> job_handle_;\n\n  // Copy of v8_flags.trace_compiler_dispatcher to allow for access from any\n  // thread.\n  bool trace_compiler_dispatcher_;\n\n  std::unique_ptr<CancelableTaskManager> idle_task_manager_;\n\n  // The following members can be accessed from any thread. Methods need to hold\n  // the mutex |mutex_| while accessing them.\n  mutable base::Mutex mutex_;\n\n  // True if an idle task is scheduled to be run.\n  bool idle_task_scheduled_;\n\n  // The set of jobs that can be run on a background thread.\n  std::vector<Job*> pending_background_jobs_;\n\n  // The set of jobs that can be finalized on the main thread.\n  std::vector<Job*> finalizable_jobs_;\n\n  // The total number of jobs ready to execute on background, both those pending\n  // and those currently running.\n  std::atomic<size_t> num_jobs_for_background_;\n\n#ifdef DEBUG\n  // The set of all allocated jobs, used for verification of the various queues\n  // and counts.\n  std::unordered_set<Job*> all_jobs_;\n#endif\n\n  // A queue of jobs to delete on the background thread(s). Jobs in this queue\n  // are considered dead as far as the rest of the system is concerned, so they\n  // won't be pointed to by any SharedFunctionInfo and won't be in the all_jobs\n  // set above.\n  std::vector<Job*> jobs_to_dispose_;\n\n  // If not nullptr, then the main thread waits for the task processing\n  // this job, and blocks on the ConditionVariable main_thread_blocking_signal_.\n  Job* main_thread_blocking_on_job_;\n  base::ConditionVariable main_thread_blocking_signal_;\n\n  // Test support.\n  base::AtomicValue<bool> block_for_testing_;\n  base::Semaphore semaphore_for_testing_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JobTask\",\n                \"parent\": \"LazyCompileDispatcher\",\n                \"about\": \"JobTask for PostJob API. Defined inside LazyCompileDispatcher.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n  class JobTask;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"Job\",\n                \"parent\": \"LazyCompileDispatcher\",\n                \"about\": \"Represents a single compilation job.  Tracks its state and the associated BackgroundCompileTask.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"task\",\n                        \"type\": \"std::unique_ptr<BackgroundCompileTask>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The background compilation task associated with this job.\"\n                    },\n                    {\n                        \"name\": \"state\",\n                        \"type\": \"State\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The current state of the job.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BackgroundCompileTask\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n  struct Job {\n    enum class State {\n      // Background thread states (Enqueue + DoBackgroundWork)\n      // ---\n\n      // In the pending task queue.\n      kPending,\n      // Currently running on a background thread.\n      kRunning,\n      kAbortRequested,  // ... but we want to drop the result.\n      // In the finalizable task queue.\n      kReadyToFinalize,\n      kAborted,\n\n      // Main thread states (FinishNow and FinalizeSingleJob)\n      // ---\n\n      // Popped off the pending task queue.\n      kPendingToRunOnForeground,\n      // Popped off the finalizable task queue.\n      kFinalizingNow,\n      kAbortingNow,  // ... and we want to abort\n\n      // Finished finalizing, ready for deletion.\n      kFinalized,\n    };\n\n    explicit Job(std::unique_ptr<BackgroundCompileTask> task);\n    ~Job();\n\n    bool is_running_on_background() const {\n      return state == State::kRunning || state == State::kAbortRequested;\n    }\n\n    std::unique_ptr<BackgroundCompileTask> task;\n    State state = State::kPending;\n  };\n        ]]></code>\n    </class>\n</file>\n```"
}