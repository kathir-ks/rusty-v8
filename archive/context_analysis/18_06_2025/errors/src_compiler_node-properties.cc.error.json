{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-properties.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node-properties.cc\",\n        \"file_name\": \"node-properties.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides utility functions for querying and manipulating properties of nodes in the Turbofan graph.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for node properties, common operators, JS heap broker, map inference, node matchers, operator properties, simplified operators, turbofan graph, and verifier.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/node-properties.h\"\n\n#include <optional>\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/map-inference.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/compiler/verifier.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"IsValueEdge\",\n            \"about\": \"Checks if an edge is a value edge.\",\n            \"logic\": \"Determines if the given edge represents a value input to the node by checking if the edge index falls within the range of value inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"edge\",\n                    \"type\": \"Edge\",\n                    \"purpose\": \"The edge to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the edge is a value edge, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"FirstValueIndex\",\n                \"node->op()->ValueInputCount\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nbool NodeProperties::IsValueEdge(Edge edge) {\n  Node* const node = edge.from();\n  return IsInputRange(edge, FirstValueIndex(node),\n                      node->op()->ValueInputCount());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"IsContextEdge\",\n            \"about\": \"Checks if an edge is a context edge.\",\n            \"logic\": \"Determines if the given edge represents a context input to the node by checking if the edge index falls within the range of context inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"edge\",\n                    \"type\": \"Edge\",\n                    \"purpose\": \"The edge to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the edge is a context edge, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"FirstContextIndex\",\n                \"OperatorProperties::GetContextInputCount\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nbool NodeProperties::IsContextEdge(Edge edge) {\n  Node* const node = edge.from();\n  return IsInputRange(edge, FirstContextIndex(node),\n                      OperatorProperties::GetContextInputCount(node->op()));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"IsFrameStateEdge\",\n            \"about\": \"Checks if an edge is a frame state edge.\",\n            \"logic\": \"Determines if the given edge represents a frame state input to the node by checking if the edge index falls within the range of frame state inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"edge\",\n                    \"type\": \"Edge\",\n                    \"purpose\": \"The edge to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the edge is a frame state edge, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"FirstFrameStateIndex\",\n                \"OperatorProperties::GetFrameStateInputCount\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nbool NodeProperties::IsFrameStateEdge(Edge edge) {\n  Node* const node = edge.from();\n  return IsInputRange(edge, FirstFrameStateIndex(node),\n                      OperatorProperties::GetFrameStateInputCount(node->op()));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"IsEffectEdge\",\n            \"about\": \"Checks if an edge is an effect edge.\",\n            \"logic\": \"Determines if the given edge represents an effect input to the node by checking if the edge index falls within the range of effect inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"edge\",\n                    \"type\": \"Edge\",\n                    \"purpose\": \"The edge to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the edge is an effect edge, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"FirstEffectIndex\",\n                \"node->op()->EffectInputCount\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nbool NodeProperties::IsEffectEdge(Edge edge) {\n  Node* const node = edge.from();\n  return IsInputRange(edge, FirstEffectIndex(node),\n                      node->op()->EffectInputCount());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"IsControlEdge\",\n            \"about\": \"Checks if an edge is a control edge.\",\n            \"logic\": \"Determines if the given edge represents a control input to the node by checking if the edge index falls within the range of control inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"edge\",\n                    \"type\": \"Edge\",\n                    \"purpose\": \"The edge to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the edge is a control edge, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"FirstControlIndex\",\n                \"node->op()->ControlInputCount\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nbool NodeProperties::IsControlEdge(Edge edge) {\n  Node* const node = edge.from();\n  return IsInputRange(edge, FirstControlIndex(node),\n                      node->op()->ControlInputCount());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"IsExceptionalCall\",\n            \"about\": \"Checks if a node represents an exceptional call (a call that might throw an exception).\",\n            \"logic\": \"Iterates through the use edges of the node, looking for control edges that originate from an IfException node. If such an edge is found, it means that the call might throw an exception.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to check.\"\n                },\n                {\n                    \"name\": \"out_exception\",\n                    \"type\": \"Node**\",\n                    \"purpose\": \"Optional output parameter to store the IfException node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the node represents an exceptional call, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"node->op()->HasProperty\",\n                \"Operator::kNoThrow\",\n                \"IsControlEdge\",\n                \"edge.from()->opcode\",\n                \"IrOpcode::kIfException\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nbool NodeProperties::IsExceptionalCall(Node* node, Node** out_exception) {\n  if (node->op()->HasProperty(Operator::kNoThrow)) return false;\n  for (Edge const edge : node->use_edges()) {\n    if (!NodeProperties::IsControlEdge(edge)) continue;\n    if (edge.from()->opcode() == IrOpcode::kIfException) {\n      if (out_exception != nullptr) *out_exception = edge.from();\n      return true;\n    }\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"FindSuccessfulControlProjection\",\n            \"about\": \"Finds the control projection for a successful execution of a node.\",\n            \"logic\": \"Iterates through the use edges of the node, looking for control edges that originate from an IfSuccess node. If such an edge is found, it is returned.  If no IfSuccess node is found and the node can't throw it returns the original node. Otherwise the original node is returned\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The IfSuccess node if found, otherwise the original node.\"\n            },\n            \"dependencies\": [\n                \"node->op()->ControlOutputCount\",\n                \"node->op()->HasProperty\",\n                \"Operator::kNoThrow\",\n                \"IsControlEdge\",\n                \"edge.from()->opcode\",\n                \"IrOpcode::kIfSuccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nNode* NodeProperties::FindSuccessfulControlProjection(Node* node) {\n  CHECK_GT(node->op()->ControlOutputCount(), 0);\n  if (node->op()->HasProperty(Operator::kNoThrow)) return node;\n  for (Edge const edge : node->use_edges()) {\n    if (!NodeProperties::IsControlEdge(edge)) continue;\n    if (edge.from()->opcode() == IrOpcode::kIfSuccess) {\n      return edge.from();\n    }\n  }\n  return node;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"ReplaceValueInput\",\n            \"about\": \"Replaces a specific value input of a node.\",\n            \"logic\": \"Replaces the input at the given index with the provided value node.  Checks are included to ensure that the index is within the valid range for value inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose input is to be replaced.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The new value node.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the value input to replace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FirstValueIndex\",\n                \"node->op()->ValueInputCount\",\n                \"node->ReplaceInput\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::ReplaceValueInput(Node* node, Node* value, int index) {\n  CHECK_LE(0, index);\n  CHECK_LT(index, node->op()->ValueInputCount());\n  node->ReplaceInput(FirstValueIndex(node) + index, value);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"ReplaceValueInputs\",\n            \"about\": \"Replaces all value inputs of a node with a single value.\",\n            \"logic\": \"Replaces the first input with the provided value node and then removes the remaining value inputs. Asserts that there is at least one value input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose value inputs are to be replaced.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The new value node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"node->op()->ValueInputCount\",\n                \"node->ReplaceInput\",\n                \"node->RemoveInput\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::ReplaceValueInputs(Node* node, Node* value) {\n  int value_input_count = node->op()->ValueInputCount();\n  CHECK_GT(value_input_count, 0);\n  node->ReplaceInput(0, value);\n  while (--value_input_count > 0) {\n    node->RemoveInput(value_input_count);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"ReplaceContextInput\",\n            \"about\": \"Replaces the context input of a node.\",\n            \"logic\": \"Replaces the context input with the provided context node. Asserts that the node has a context input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose context input is to be replaced.\"\n                },\n                {\n                    \"name\": \"context\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The new context node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"OperatorProperties::HasContextInput\",\n                \"FirstContextIndex\",\n                \"node->ReplaceInput\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::ReplaceContextInput(Node* node, Node* context) {\n  CHECK(OperatorProperties::HasContextInput(node->op()));\n  node->ReplaceInput(FirstContextIndex(node), context);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"ReplaceControlInput\",\n            \"about\": \"Replaces a specific control input of a node.\",\n            \"logic\": \"Replaces the input at the given index with the provided control node.  Checks are included to ensure that the index is within the valid range for control inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose input is to be replaced.\"\n                },\n                {\n                    \"name\": \"control\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The new control node.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the control input to replace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FirstControlIndex\",\n                \"node->op()->ControlInputCount\",\n                \"node->ReplaceInput\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::ReplaceControlInput(Node* node, Node* control, int index) {\n  CHECK_LE(0, index);\n  CHECK_LT(index, node->op()->ControlInputCount());\n  node->ReplaceInput(FirstControlIndex(node) + index, control);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"ReplaceEffectInput\",\n            \"about\": \"Replaces a specific effect input of a node.\",\n            \"logic\": \"Replaces the input at the given index with the provided effect node. Checks are included to ensure that the index is within the valid range for effect inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose input is to be replaced.\"\n                },\n                {\n                    \"name\": \"effect\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The new effect node.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the effect input to replace.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FirstEffectIndex\",\n                \"node->op()->EffectInputCount\",\n                \"node->ReplaceInput\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::ReplaceEffectInput(Node* node, Node* effect, int index) {\n  CHECK_LE(0, index);\n  CHECK_LT(index, node->op()->EffectInputCount());\n  return node->ReplaceInput(FirstEffectIndex(node) + index, effect);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"ReplaceFrameStateInput\",\n            \"about\": \"Replaces the frame state input of a node.\",\n            \"logic\": \"Replaces the frame state input with the provided frame state node. Asserts that the node has a frame state input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose frame state input is to be replaced.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The new frame state node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"OperatorProperties::HasFrameStateInput\",\n                \"FirstFrameStateIndex\",\n                \"node->ReplaceInput\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::ReplaceFrameStateInput(Node* node, Node* frame_state) {\n  CHECK(OperatorProperties::HasFrameStateInput(node->op()));\n  node->ReplaceInput(FirstFrameStateIndex(node), frame_state);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"RemoveNonValueInputs\",\n            \"about\": \"Removes all non-value inputs from a node.\",\n            \"logic\": \"Trims the input count of the node to the number of value inputs, effectively removing all context, effect, control, and frame state inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to modify.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"node->op()->ValueInputCount\",\n                \"node->TrimInputCount\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::RemoveNonValueInputs(Node* node) {\n  node->TrimInputCount(node->op()->ValueInputCount());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"RemoveValueInputs\",\n            \"about\": \"Removes all value inputs from a node.\",\n            \"logic\": \"Iteratively removes value inputs from the node, starting from the last value input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to modify.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"node->op()->ValueInputCount\",\n                \"node->RemoveInput\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::RemoveValueInputs(Node* node) {\n  int value_input_count = node->op()->ValueInputCount();\n  while (--value_input_count >= 0) {\n    node->RemoveInput(value_input_count);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MergeControlToEnd\",\n            \"about\": \"Merges a control node to the end of the graph.\",\n            \"logic\": \"Appends the given control node to the graph's end node and updates the end node's operator to reflect the increased number of control inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"TFGraph*\",\n                    \"purpose\": \"The Turbofan graph.\"\n                },\n                {\n                    \"name\": \"common\",\n                    \"type\": \"CommonOperatorBuilder*\",\n                    \"purpose\": \"The common operator builder.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The control node to merge.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"graph->end()->AppendInput\",\n                \"graph->zone()\",\n                \"node\",\n                \"graph->end()->set_op\",\n                \"common->End\",\n                \"graph->end()->InputCount\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid NodeProperties::MergeControlToEnd(TFGraph* graph,\n                                       CommonOperatorBuilder* common,\n                                       Node* node) {\n  graph->end()->AppendInput(graph->zone(), node);\n  graph->end()->set_op(common->End(graph->end()->InputCount()));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"RemoveControlFromEnd\",\n            \"about\": \"Removes a control node from the end of the graph.\",\n            \"logic\": \"Searches for the given control node among the graph's end node's inputs, removes it, and updates the end node's operator to reflect the decreased number of control inputs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"TFGraph*\",\n                    \"purpose\": \"The Turbofan graph.\"\n                },\n                {\n                    \"name\": \"common\",\n                    \"type\": \"CommonOperatorBuilder*\",\n                    \"purpose\": \"The common operator builder.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The control node to remove.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties::FirstControlIndex\",\n                \"graph->end()\",\n                \"graph->end()->op()->ControlInputCount\",\n                \"graph->end()->InputAt\",\n                \"graph->end()->RemoveInput\",\n                \"graph->end()->set_op\",\n                \"common->End\",\n                \"graph->end()->InputCount\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid NodeProperties::RemoveControlFromEnd(TFGraph* graph,\n                                          CommonOperatorBuilder* common,\n                                          Node* node) {\n  int index_to_remove = -1;\n  for (int i = 0; i < graph->end()->op()->ControlInputCount(); i++) {\n    int index = NodeProperties::FirstControlIndex(graph->end()) + i;\n    if (graph->end()->InputAt(index) == node) {\n      index_to_remove = index;\n      break;\n    }\n  }\n  CHECK_NE(-1, index_to_remove);\n  graph->end()->RemoveInput(index_to_remove);\n  graph->end()->set_op(common->End(graph->end()->InputCount()));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"ReplaceUses\",\n            \"about\": \"Replaces all uses of a node with specified value, effect, success, and exception nodes based on the edge type.\",\n            \"logic\": \"Iterates through the use edges of the node. Replaces value edges with 'value', effect edges with 'effect', control edges from IfSuccess nodes with 'success', and control edges from IfException nodes with 'exception'. Other control edges are replaced with 'success'.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose uses are to be replaced.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace value uses.\"\n                },\n                {\n                    \"name\": \"effect\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace effect uses.\"\n                },\n                {\n                    \"name\": \"success\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace successful control uses.\"\n                },\n                {\n                    \"name\": \"exception\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace exceptional control uses.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"IsControlEdge\",\n                \"edge.from()->opcode\",\n                \"IrOpcode::kIfSuccess\",\n                \"IrOpcode::kIfException\",\n                \"IsEffectEdge\",\n                \"edge.UpdateTo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::ReplaceUses(Node* node, Node* value, Node* effect,\n                                 Node* success, Node* exception) {\n  // Requires distinguishing between value, effect and control edges.\n  for (Edge edge : node->use_edges()) {\n    if (IsControlEdge(edge)) {\n      if (edge.from()->opcode() == IrOpcode::kIfSuccess) {\n        DCHECK_NOT_NULL(success);\n        edge.UpdateTo(success);\n      } else if (edge.from()->opcode() == IrOpcode::kIfException) {\n        DCHECK_NOT_NULL(exception);\n        edge.UpdateTo(exception);\n      } else {\n        DCHECK_NOT_NULL(success);\n        edge.UpdateTo(success);\n      }\n    } else if (IsEffectEdge(edge)) {\n      DCHECK_NOT_NULL(effect);\n      edge.UpdateTo(effect);\n    } else {\n      DCHECK_NOT_NULL(value);\n      edge.UpdateTo(value);\n    }\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"ChangeOp\",\n            \"about\": \"Changes the operator of a node and verifies the node.\",\n            \"logic\": \"Sets the node's operator to the new operator and then calls Verifier::VerifyNode to ensure the node is still valid after the change.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to modify.\"\n                },\n                {\n                    \"name\": \"new_op\",\n                    \"type\": \"const Operator*\",\n                    \"purpose\": \"The new operator for the node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"node->set_op\",\n                \"Verifier::VerifyNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::ChangeOp(Node* node, const Operator* new_op) {\n  node->set_op(new_op);\n  Verifier::VerifyNode(node);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"ChangeOpUnchecked\",\n            \"about\": \"Changes the operator of a node without verification.\",\n            \"logic\": \"Sets the node's operator to the new operator. Does not perform any verification, so it should be used with caution.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to modify.\"\n                },\n                {\n                    \"name\": \"new_op\",\n                    \"type\": \"const Operator*\",\n                    \"purpose\": \"The new operator for the node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"node->set_op\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nvoid NodeProperties::ChangeOpUnchecked(Node* node, const Operator* new_op) {\n  node->set_op(new_op);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"FindFrameStateBefore\",\n            \"about\": \"Finds the frame state node before a given node by traversing the effect chain backwards.\",\n            \"logic\": \"Starts from the given node's effect input and traverses backwards along the effect chain until it finds a Checkpoint node. The frame state input of the Checkpoint node is then returned.  If a Dead or Unreachable node is encountered, returns unreachable_sentinel. Asserts that intermediate nodes have the kNoWrite property and a single effect input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The starting node for the search.\"\n                },\n                {\n                    \"name\": \"unreachable_sentinel\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to return if an unreachable state is encountered.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The frame state node, or unreachable_sentinel if an unreachable state is encountered.\"\n            },\n            \"dependencies\": [\n                \"NodeProperties::GetEffectInput\",\n                \"effect->opcode\",\n                \"IrOpcode::kCheckpoint\",\n                \"IrOpcode::kDead\",\n                \"IrOpcode::kUnreachable\",\n                \"effect->op()->HasProperty\",\n                \"Operator::kNoWrite\",\n                \"effect->op()->EffectInputCount\",\n                \"GetFrameStateInput\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nNode* NodeProperties::FindFrameStateBefore(Node* node,\n                                           Node* unreachable_sentinel) {\n  Node* effect = NodeProperties::GetEffectInput(node);\n  while (effect->opcode() != IrOpcode::kCheckpoint) {\n    if (effect->opcode() == IrOpcode::kDead ||\n        effect->opcode() == IrOpcode::kUnreachable) {\n      return unreachable_sentinel;\n    }\n    DCHECK(effect->op()->HasProperty(Operator::kNoWrite));\n    DCHECK_EQ(1, effect->op()->EffectInputCount());\n    effect = NodeProperties::GetEffectInput(effect);\n  }\n  Node* frame_state = GetFrameStateInput(effect);\n  return frame_state;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"static function\",\n            \"name\": \"FindProjection\",\n            \"about\": \"Finds a projection node for a given node at a specific index.\",\n            \"logic\": \"Iterates through the uses of the node, looking for a Projection node with the specified projection index. If found, the projection node is returned; otherwise, nullptr is returned.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node whose projections are to be searched.\"\n                },\n                {\n                    \"name\": \"projection_index\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The index of the desired projection.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The projection node if found, otherwise nullptr.\"\n            },\n            \"dependencies\": [\n                \"node->uses\",\n                \"use->opcode\",\n                \"IrOpcode::kProjection\",\n                \"ProjectionIndexOf\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// static\nNode* NodeProperties::FindProjection(Node* node, size_t projection_index) {\n  for (auto use : node->uses())"
}