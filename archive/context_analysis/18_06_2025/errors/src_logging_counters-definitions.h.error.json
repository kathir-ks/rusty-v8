{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/logging/counters-definitions.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/logging/counters-definitions.h\",\n            \"file_name\": \"counters-definitions.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines macros for declaring various histograms and stats counters used for logging and performance monitoring in V8.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes the v8-internal header, providing access to internal V8 definitions and functionalities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"include/v8-internal.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"v8\",\n                \"about\": \"V8 namespace\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace v8 {\n            }\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"internal\",\n                \"about\": \"V8 internal namespace\",\n                \"dependencies\": [\n                    \"v8\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n            }\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"HISTOGRAM_RANGE_LIST\",\n                \"about\": \"Defines a list of range histograms using the HR macro.\",\n                \"logic\": \"This macro takes another macro (HR) as input and expands to a series of HR macro calls, each defining a range histogram with specific parameters like name, caption, min, max, and number of buckets.  The \\\\ characters allow line continuation for readability.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"HR\",\n                        \"type\": \"macro\",\n                        \"purpose\": \"The macro to be applied to each histogram definition.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"None\",\n                    \"description\": \"Macro definition\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #define HISTOGRAM_RANGE_LIST(HR)                                               \\\n              HR(code_cache_reject_reason, V8.CodeCacheRejectReason, 1, 9, 9)              \\\n              HR(errors_thrown_per_context, V8.ErrorsThrownPerContext, 0, 200, 20)         \\\n              HR(incremental_marking_reason, V8.GCIncrementalMarkingReason, 0,             \\\n                 kGarbageCollectionReasonMaxValue, kGarbageCollectionReasonMaxValue + 1)   \\\n              HR(incremental_marking_sum, V8.GCIncrementalMarkingSum, 0, 10000, 101)       \\\n              HR(mark_compact_reason, V8.GCMarkCompactReason, 0,                           \\\n                 kGarbageCollectionReasonMaxValue, kGarbageCollectionReasonMaxValue + 1)   \\\n              HR(gc_finalize_clear, V8.GCFinalizeMC.Clear, 0, 10000, 101)                  \\\n              HR(gc_finalize_epilogue, V8.GCFinalizeMC.Epilogue, 0, 10000, 101)            \\\n              HR(gc_finalize_evacuate, V8.GCFinalizeMC.Evacuate, 0, 10000, 101)            \\\n              HR(gc_finalize_finish, V8.GCFinalizeMC.Finish, 0, 10000, 101)                \\\n              HR(gc_finalize_mark, V8.GCFinalizeMC.Mark, 0, 10000, 101)                    \\\n              HR(gc_finalize_prologue, V8.GCFinalizeMC.Prologue, 0, 10000, 101)            \\\n              HR(gc_finalize_sweep, V8.GCFinalizeMC.Sweep, 0, 10000, 101)                  \\\n              HR(gc_scavenger_scavenge_main, V8.GCScavenger.ScavengeMain, 0, 10000, 101)   \\\n              HR(gc_scavenger_scavenge_roots, V8.GCScavenger.ScavengeRoots, 0, 10000, 101) \\\n              /* Asm/Wasm. */                                                              \\\n              HR(wasm_functions_per_asm_module, V8.WasmFunctionsPerModule.asm, 1, 1000000, \\\n                 51)                                                                       \\\n              HR(wasm_functions_per_wasm_module, V8.WasmFunctionsPerModule.wasm, 1,        \\\n                 1000000, 51)                                                              \\\n              HR(array_buffer_big_allocations, V8.ArrayBufferLargeAllocations, 0, 4096,    \\\n                 13)                                                                       \\\n              HR(array_buffer_new_size_failures, V8.ArrayBufferNewSizeFailures, 0, 4096,   \\\n                 13)                                                                       \\\n              HR(shared_array_allocations, V8.SharedArrayAllocationSizes, 0, 4096, 13)     \\\n              HR(wasm_asm_huge_function_size_bytes, V8.WasmHugeFunctionSizeBytes.asm,      \\\n                 100 * KB, GB, 51)                                                         \\\n              HR(wasm_wasm_huge_function_size_bytes, V8.WasmHugeFunctionSizeBytes.wasm,    \\\n                 100 * KB, GB, 51)                                                         \\\n              HR(wasm_asm_module_size_bytes, V8.WasmModuleSizeBytes.asm, 1, GB, 51)        \\\n              HR(wasm_wasm_module_size_bytes, V8.WasmModuleSizeBytes.wasm, 1, GB, 51)      \\\n              HR(wasm_compile_huge_function_peak_memory_bytes,                             \\\n                 V8.WasmCompileHugeFunctionPeakMemoryBytes, 1, GB, 51)                     \\\n              HR(asm_module_size_bytes, V8.AsmModuleSizeBytes, 1, GB, 51)                  \\\n              HR(compile_script_cache_behaviour, V8.CompileScript.CacheBehaviour, 0, 21,   \\\n                 22)                                                                       \\\n              HR(wasm_memory_allocation_result, V8.WasmMemoryAllocationResult, 0, 3, 4)    \\\n              /* Committed code size per module, collected on GC. */                       \\\n              /* Older histogram, in MiB (0..1024MB). */                                   \\\n              HR(wasm_module_code_size_mb, V8.WasmModuleCodeSizeMiB, 0, 1024, 64)          \\\n              /* Newer histogram, in KiB (0..100MB). */                                    \\\n              HR(wasm_module_code_size_kb, V8.WasmModuleCodeSizeKiB, 0, 1024 * 100, 101)   \\\n              /* Metadata size per module, collected on GC. */                             \\\n              HR(wasm_module_metadata_size_kb, V8.WasmModuleMetadataSizeKiB, 0,            \\\n                 1024 * 100, 101)                                                          \\\n              /* Metadata of the whole Wasm engine, collected on GC. */                    \\\n              HR(wasm_engine_metadata_size_kb, V8.WasmEngineMetadataSizeKiB, 0,            \\\n                 1024 * 100, 101)                                                          \\\n              /* Percent of freed code size per module, collected on GC. */                \\\n              HR(wasm_module_freed_code_size_percent, V8.WasmModuleCodeSizePercentFreed,   \\\n                 0, 100, 32)                                                               \\\n              /* Number of code GCs triggered per native module, collected on code GC. */  \\\n              HR(wasm_module_num_triggered_code_gcs,                                       \\\n                 V8.WasmModuleNumberOfCodeGCsTriggered, 1, 128, 20)                        \\\n              /* The amount of executable Liftoff code flushed on emergency GCs for */     \\\n              /* allocations and on memory pressure. */                                    \\\n              HR(wasm_flushed_liftoff_code_size_bytes, V8.WasmFlushedLiftoffCodeSizeBytes, \\\n                 0, GB, 101)                                                               \\\n              /* The size of flushed Liftoff meta data on emergency GCs for allocations */ \\\n              /* and on memory pressure. */                                                \\\n              HR(wasm_flushed_liftoff_metadata_size_bytes,                                 \\\n                 V8.WasmFlushedLiftoffMetadataSizeBytes, 0, GB, 101)                       \\\n              /* Number of code spaces reserved per wasm module. */                        \\\n              HR(wasm_module_num_code_spaces, V8.WasmModuleNumberOfCodeSpaces, 1, 128, 20) \\\n              /* Number of deopts triggered in webassembly code. */                        \\\n              HR(wasm_deopts_executed, V8.WasmDeoptsExecutedCount, 0, 10000, 51)           \\\n              HR(wasm_deopts_per_function, V8.WasmDeoptsPerFunction, 0, 500, 21)           \\\n              /* Number of live modules per isolate. */                                    \\\n              HR(wasm_modules_per_isolate, V8.WasmModulesPerIsolate, 1, 1024, 30)          \\\n              /* Number of live modules per engine (i.e. whole process). */                \\\n              HR(wasm_modules_per_engine, V8.WasmModulesPerEngine, 1, 1024, 30)            \\\n              /* Bailout reason if Liftoff failed, or {kSuccess} (per function). */        \\\n              HR(liftoff_bailout_reasons, V8.LiftoffBailoutReasons, 0, 20, 21)             \\\n              /* Support for PKEYs/PKU by testing result of pkey_alloc(). */               \\\n              HR(wasm_memory_protection_keys_support, V8.WasmMemoryProtectionKeysSupport,  \\\n                 0, 1, 2)                                                                  \\\n              /* Ticks observed in a single Turbofan compilation, in 1K. */                \\\n              HR(turbofan_ticks, V8.TurboFan1KTicks, 0, 100000, 200)                       \\\n              /* Backtracks observed in a single regexp interpreter execution. */          \\\n              /* The maximum of 100M backtracks takes roughly 2 seconds on my machine. */  \\\n              HR(regexp_backtracks, V8.RegExpBacktracks, 1, 100000000, 50)                 \\\n              /* Number of times a cache event is triggered for a wasm module. */          \\\n              HR(wasm_cache_count, V8.WasmCacheCount, 0, 100, 101)                         \\\n              /* Number of in-use external pointers in the external pointer table. */      \\\n              /* Counted after sweeping the table at the end of mark-compact GC. */        \\\n              HR(external_pointers_count, V8.SandboxedExternalPointersCount, 0,            \\\n                 kMaxExternalPointers, 101)                                                \\\n              HR(code_pointers_count, V8.SandboxedCodePointersCount, 0, kMaxCodePointers,  \\\n                 101)                                                                      \\\n              HR(trusted_pointers_count, V8.SandboxedTrustedPointersCount, 0,              \\\n                 kMaxTrustedPointers, 101)                                                 \\\n              HR(cppheap_pointers_count, V8.SandboxedCppHeapPointersCount, 0,              \\\n                 kMaxCppHeapPointers, 101)                                                 \\\n              HR(js_dispatch_table_entries_count, V8.JSDispatchTableEntriesCount, 0,       \\\n                 kMaxJSDispatchEntries, 101)                                               \\\n              /* Outcome of external pointer table compaction: kSuccess, */                \\\n              /* kPartialSuccessor kAbortedDuringSweeping. See */                          \\\n              /* ExternalPointerTable::TableCompactionOutcome enum for more details. */    \\\n              HR(external_pointer_table_compaction_outcome,                                \\\n                 V8.ExternalPointerTableCompactionOutcome, 0, 2, 3)                        \\\n              HR(wasm_compilation_method, V8.WasmCompilationMethod, 0, 4, 5)               \\\n              HR(asmjs_instantiate_result, V8.AsmjsInstantiateResult, 0, 1, 2)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"HISTOGRAM_RANGE_LIST_SLOW\",\n                \"about\": \"Defines a list of range histograms specifically intended for slow operations (Drumbrake enabled).\",\n                \"logic\": \"Similar to HISTOGRAM_RANGE_LIST, but these histograms are intended to capture slower operations, which are relevant when Drumbrake is enabled. Drumbrake is a V8 feature that allows slowing down execution for debugging purposes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"HR\",\n                        \"type\": \"macro\",\n                        \"purpose\": \"The macro to be applied to each histogram definition.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"None\",\n                    \"description\": \"Macro definition\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #if V8_ENABLE_DRUMBRAKE\n            #define HISTOGRAM_RANGE_LIST_SLOW(HR)                                         \\\n              /* Percentage (*1000) of time spent running Wasm jitted code. */            \\\n              HR(wasm_jit_execution_ratio, V8.JitWasmExecutionPercentage, 0, 100000, 101) \\\n              HR(wasm_jit_execution_too_slow, V8.JitWasmExecutionTooSlow, 0, 100000, 101) \\\n              /* Percentage (*1000) of time spent running in the Wasm interpreter. */     \\\n              HR(wasm_jitless_execution_ratio, V8.JitlessWasmExecutionPercentage, 0,      \\\n                 100000, 101)                                                             \\\n              HR(wasm_jitless_execution_too_slow, V8.JitlessWasmExecutionTooSlow, 0,      \\\n                 100000, 101)\n            #endif  // V8_ENABLE_DRUMBRAKE\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"NESTED_TIMED_HISTOGRAM_LIST\",\n                \"about\": \"Defines a list of nested timed histograms using the HT macro.\",\n                \"logic\": \"This macro works like HISTOGRAM_RANGE_LIST, but it defines *timed* histograms. These histograms are designed to measure the duration of specific operations. NestedTimedHistogramScope is allowed with these. The unit parameter specifies the time unit (e.g., MILLISECOND, MICROSECOND).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"HT\",\n                        \"type\": \"macro\",\n                        \"purpose\": \"The macro to be applied to each histogram definition.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"None\",\n                    \"description\": \"Macro definition\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #define NESTED_TIMED_HISTOGRAM_LIST(HT)                                       \\\n              /* Garbage collection timers. */                                            \\\n              HT(gc_incremental_marking, V8.GCIncrementalMarking, 10000, MILLISECOND)     \\\n              HT(gc_incremental_marking_start, V8.GCIncrementalMarkingStart, 10000,       \\\n                 MILLISECOND)                                                             \\\n              HT(gc_minor_incremental_marking_start, V8.GCMinorIncrementalMarkingStart,   \\\n                 10000, MILLISECOND)                                                      \\\n              HT(gc_low_memory_notification, V8.GCLowMemoryNotification, 10000,           \\\n                 MILLISECOND)                                                             \\\n              /* Compilation times. */                                                    \\\n              HT(collect_source_positions, V8.CollectSourcePositions, 1000000,            \\\n                 MICROSECOND)                                                             \\\n              HT(compile, V8.CompileMicroSeconds, 1000000, MICROSECOND)                   \\\n              HT(compile_eval, V8.CompileEvalMicroSeconds, 1000000, MICROSECOND)          \\\n              /* Serialization as part of compilation (code caching). */                  \\\n              HT(compile_serialize, V8.CompileSerializeMicroSeconds, 100000, MICROSECOND) \\\n              HT(compile_deserialize, V8.CompileDeserializeMicroSeconds, 1000000,         \\\n                 MICROSECOND)                                                             \\\n              /* Snapshot. */                                                             \\\n              HT(snapshot_decompress, V8.SnapshotDecompressMicroSeconds, 1000000,         \\\n                 MICROSECOND)                                                             \\\n              HT(snapshot_deserialize_rospace, V8.SnapshotDeserializeRoSpaceMicroSeconds, \\\n                 1000000, MICROSECOND)                                                    \\\n              HT(snapshot_deserialize_isolate, V8.SnapshotDeserializeIsolateMicroSeconds, \\\n                 1000000, MICROSECOND)                                                    \\\n              HT(snapshot_deserialize_context, V8.SnapshotDeserializeContextMicroSeconds, \\\n                 1000000, MICROSECOND)                                                    \\\n              /* ... and also see compile_deserialize above. */                           \\\n              /* Total compilation time incl. caching/parsing. */                         \\\n              HT(compile_script, V8.CompileScriptMicroSeconds, 1000000, MICROSECOND)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"NESTED_TIMED_HISTOGRAM_LIST_SLOW\",\n                \"about\": \"Defines a list of nested timed histograms for slow operations.\",\n                \"logic\": \"Similar to NESTED_TIMED_HISTOGRAM_LIST, but for slow operations.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"HT\",\n                        \"type\": \"macro\",\n                        \"purpose\": \"The macro to be applied to each histogram definition.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"None\",\n                    \"description\": \"Macro definition\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #define NESTED_TIMED_HISTOGRAM_LIST_SLOW(HT)                                \\\n              /* Total V8 time (including JS and runtime calls, exluding callbacks). */ \\\n              HT(execute, V8.ExecuteMicroSeconds, 1000000, MICROSECOND)\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"TIMED_HISTOGRAM_LIST\",\n                \"about\": \"Defines a list of thread-safe timer histograms using the HT macro.\",\n                \"logic\": \"This macro defines timed histograms that are thread-safe. This is important for collecting timing data from multiple threads without introducing race conditions.  The unit parameter specifies the time unit (e.g., MILLISECOND, MICROSECOND).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"HT\",\n                        \"type\": \"macro\",\n                        \"purpose\": \"The macro to be applied to each histogram definition.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"None\",\n                    \"description\": \"Macro definition\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            #define TIMED_HISTOGRAM_LIST(HT)                                               \\\n              /* Garbage collection timers. */                                             \\\n              HT(gc_finalize_incremental_regular,                                          \\\n                 V8.GC.Event.MainThread.Full.Finalize.Incremental.Regular, 10000,          \\\n                 MILLISECOND)                                                              \\\n              HT(gc_finalize_incremental_regular_foreground,                               \\\n                 V8.GC.Event.MainThread.Full.Finalize.Incremental.Regular.Foreground,      \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_incremental_regular_background,                               \\\n                 V8.GC.Event.MainThread.Full.Finalize.Incremental.Regular.Background,      \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_incremental_memory_reducing,                                  \\\n                 V8.GC.Event.MainThread.Full.Finalize.Incremental.ReduceMemory, 10000,     \\\n                 MILLISECOND)                                                              \\\n              HT(gc_finalize_incremental_memory_reducing_foreground,                       \\\n                 V8.GC.Event.MainThread.Full.Finalize.Incremental.ReduceMemory.Foreground, \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_incremental_memory_reducing_background,                       \\\n                 V8.GC.Event.MainThread.Full.Finalize.Incremental.ReduceMemory.Background, \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_incremental_memory_measure,                                   \\\n                 V8.GC.Event.MainThread.Full.Finalize.Incremental.MeasureMemory, 10000,    \\\n                 MILLISECOND)                                                              \\\n              HT(gc_finalize_incremental_memory_measure_foreground,                        \\\n                 V8.GC.Event.MainThread.Full.Finalize.Incremental.MeasureMemory            \\\n                     .Foreground,                                                          \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_incremental_memory_measure_background,                        \\\n                 V8.GC.Event.MainThread.Full.Finalize.Incremental.MeasureMemory            \\\n                     .Background,                                                          \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_non_incremental_regular,                                      \\\n                 V8.GC.Event.MainThread.Full.Finalize.NonIncremental.Regular, 10000,       \\\n                 MILLISECOND)                                                              \\\n              HT(gc_finalize_non_incremental_regular_foreground,                           \\\n                 V8.GC.Event.MainThread.Full.Finalize.NonIncremental.Regular.Foreground,   \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_non_incremental_regular_background,                           \\\n                 V8.GC.Event.MainThread.Full.Finalize.NonIncremental.Regular.Background,   \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_non_incremental_memory_reducing,                              \\\n                 V8.GC.Event.MainThread.Full.Finalize.NonIncremental.ReduceMemory, 10000,  \\\n                 MILLISECOND)                                                              \\\n              HT(gc_finalize_non_incremental_memory_reducing_foreground,                   \\\n                 V8.GC.Event.MainThread.Full.Finalize.NonIncremental.ReduceMemory          \\\n                     .Foreground,                                                          \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_non_incremental_memory_reducing_background,                   \\\n                 V8.GC.Event.MainThread.Full.Finalize.NonIncremental.ReduceMemory          \\\n                     .Background,                                                          \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_non_incremental_memory_measure,                               \\\n                 V8.GC.Event.MainThread.Full.Finalize.NonIncremental.MeasureMemory, 10000, \\\n                 MILLISECOND)                                                              \\\n              HT(gc_finalize_non_incremental_memory_measure_foreground,                    \\\n                 V8.GC.Event.MainThread.Full.Finalize.NonIncremental.MeasureMemory         \\\n                     .Foreground,                                                          \\\n                 10000, MILLISECOND)                                                       \\\n              HT(gc_finalize_non_incremental_memory_measure_background,                    \\\n                 V8.GC.Event.MainThread.Full.Finalize.NonIncremental.MeasureMemory         \\\n                     .Background,                                                          \\\n                 10000, MILLISECOND)                                                       \\\n              HT(measure_memory_delay_ms, V8.MeasureMemoryDelayMilliseconds, 100000,       \\\n                 MILLISECOND)                                                              \\\n              HT(gc_time_to_global_safepoint, V8.GC.TimeToGlobalSafepoint, 10000000,       \\\n                 MICROSECOND)                                                              \\\n              HT(gc_time_to_safepoint, V8.GC.TimeToSafepoint, 10000000, MICROSECOND)       \\\n              HT(gc_time_to_collection_on_background, V8.GC.TimeToCollectionOnBackground,  \\\n                 10000000, MICROSECOND)                                                    \\\n              /* Maglev timers. */                                                         \\\n              HT(maglev_optimize_prepare, V8.MaglevOptimizePrepare, 100000, MICROSECOND)   \\\n              HT(maglev_optimize_execute, V8.MaglevOptimizeExecute, 100000, MICROSECOND)   \\\n              HT(maglev_optimize_finalize, V8.MaglevOptimizeFinalize, 100000, MICROSECOND) \\\n              HT(maglev_optimize_total_time, V8.MaglevOptimizeTotalTime, 1000000,          \\\n                 MICROSECOND)                                                              \\\n              /* TurboFan timers. */                                                       \\\n              HT(turbofan_optimize_prepare, V8.TurboFanOptimizePrepare, 1000000,           \\\n                 MICROSECOND)                                                              \\\n              HT(turbofan_optimize_execute, V8.TurboFanOptimizeExecute, 1000000,           \\\n                 MICROSECOND)                                                              \\\n              HT(turbofan_optimize_finalize, V8.TurboFanOptimizeFinalize, 1000000,         \\\n                 MICROSECOND)                                                              \\\n              HT(turbofan_optimize_total_foreground, V8.TurboFanOptimizeTotalForeground,   \\\n                 10000000, MICROSECOND)                                                    \\\n              HT(turbofan_optimize_total_background, V8.TurboFanOptimizeTotalBackground,   \\\n                 10000000, MICROSECOND)                                                    \\\n              HT(turbofan_optimize_total_time, V8.TurboFanOptimizeTotalTime, 10000000,     \\\n                 MICROSECOND)                                                              \\\n              HT(turbofan_optimize_non_concurrent_total_time,                              \\\n                 V8.TurboFanOptimizeNonConcurrentTotalTime, 10000000, MICROSECOND)         \\\n              HT(turbofan_optimize_concurrent_total_time,                                  \\\n                 V8.TurboFanOptimizeConcurrentTotalTime, 10000000, MICROSECOND)            \\\n              HT(turbofan_osr_prepare, V8.TurboFanOptimizeForOnStackReplacementPrepare,    \\\n                 1000000, MICROSECOND)                                                     \\\n              HT(turbofan_osr_execute, V8.TurboFanOptimizeForOnStackReplacementExecute,    \\\n                 1000000, MICROSECOND)                                                     \\\n              HT(turbofan_osr_finalize, V8.TurboFanOptimizeForOnStackReplacementFinalize,  \\\n                 1000000, MICROSECOND)                                                     \\\n              HT(turbofan_osr_total_time,                                                  \\\n                 V8.TurboFanOptimizeForOnStackReplacementTotalTime, 10000000, MICROSECOND) \\\n              /* Wasm timers. */                                                           \\\n              HT(wasm_compile_asm_module_time, V8.WasmCompileModuleMicroSeconds.asm,       \\\n                 10000000, MICROSECOND)                                                    \\\n              HT(wasm_compile_wasm_module_time, V8.WasmCompileModuleMicroSeconds.wasm,     \\\n                 10000000, MICROSECOND)                                                    \\\n              HT(wasm_async_compile_wasm_module_time,                                      \\\n                 V8.WasmCompileModuleAsyncMicroSeconds, 100000000, MICROSECOND)            \\\n              HT(wasm_streaming_compile_wasm_module_time,                                  \\\n                 V8.WasmCompileModuleStreamingMicroSeconds, 100000000, MICROSECOND)        \\\n              HT(wasm_streaming_finish_wasm_module_time,                                   \\\n                 V8.WasmFinishModuleStreamingMicroSeconds, 100000000, MICROSECOND)         \\\n              HT(wasm_deserialization_time, V8.WasmDeserializationTimeMilliSeconds, 10000, \\\n                 MILLISECOND)                                                              \\\n              HT(wasm_compile_asm_function_time, V8.WasmCompileFunctionMicroSeconds.asm,   \\\n                 1000000, MICROSECOND)                                                     \\\n              HT(wasm_compile_wasm_function_time, V8.WasmCompileFunctionMicroSeconds.wasm, \\\n                 1000000, MICROSECOND)                                                     \\\n              HT(wasm_compile_huge_function_time, V8.WasmCompileHugeFunctionMilliSeconds,  \\\n                 100000, MILLISECOND)                                                      \\\n              HT(wasm_instantiate_wasm_module_time,                                        \\\n                 V8.WasmInstantiateModuleMicroSeconds.wasm, 10000000, MICROSECOND)         \\\n              HT(wasm_instantiate_asm_module_time,                                         \\\n                 V8.WasmInstantiateModuleMicroSeconds.asm, 10000000, MICROSECOND)          \\\n              HT(wasm_lazy_compile_time, V8.WasmLazyCompileTimeMicroSeconds, 100000000,    \\\n                 MICROSECOND)                                                              \\\n              HT(wasm_compile_after_deserialize,                                           \\\n                 V8.WasmCompileAfterDeserializeMilliSeconds, 1000000, MILLISECOND)         \\\n              /* Total compilation time incl. caching/parsing for various cache states. */ \\\n              HT(compile_script_with_produce_cache,                                        \\\n                 V8.CompileScriptMicroSeconds.ProduceCache, 1000000, MICROSECOND)          \\\n              HT(compile_script_with_isolate_cache_hit,                                    \\\n                 V8.CompileScriptMicroSeconds.IsolateCacheHit, 1000000, MICROSECOND)       \\\n              HT(compile_script_with_consume_cache,                                        \\\n                 V8.CompileScriptMicroSeconds.ConsumeCache, 1000000, MICROSECOND)          \\\n              HT(compile_script_consume_failed,                                            \\\n                 V8.CompileScriptMicroSeconds.ConsumeCache.Failed, 1000000, MICROSECOND)   \\\n              HT(compile_script_no_cache_other,                                            \\\n                 V8.CompileScriptMicroSeconds.NoCache.Other, 1000000, MICROSECOND)         \\\n              HT(compile_script_no_cache_because_inline_script,                            \\\n                 V8.CompileScriptMicroSeconds.NoCache.InlineScript, 1000000, MICROSECOND)  \\\n              HT(compile_script_no_cache_because_script_too_small,                         \\\n                 V8.CompileScriptMicroSeconds.NoCache.ScriptTooSmall, 1000000,             \\\n                 MICROSECOND)                                                              \\\n              HT(compile_script_no_cache_because_cache_too_cold,                           \\\n                 V8.CompileScriptMicroSeconds.NoCache.CacheTooCold, 1000000, MICROSECOND)  \\\n              HT(compile_script_streaming_finalization,                                    \\\n                 V8.CompileScriptMicroSeconds.StreamingFinalization, 1000000, MICROSECOND) \\\n              HT(compile_script_on_background,                                             \\\n                 V8.CompileScriptMicroSeconds.BackgroundThread, 1000000, MICROSECOND)      \\\n              HT(compile_function_on_background,                                           \\\n                 V8.CompileFunctionMicroSeconds.BackgroundThread, 1000000, MICROSECOND)    \\\n              HT(deserialize_script_on_background,                                         \\\n                 V8.CompileScriptMicroSeconds.ConsumeCache.BackgroundThread, 1000000,      \\\n                 MICROSECOND)                                                              \\\n              /* Debugger timers. */                                                       \\\n              HT(debug_pause_to_paused_event, V8.DebugPauseToPausedEventMilliSeconds,      \\\n                 1000000, MILLISECOND)\n        ]]></code>\n    </func>\n    <func>\n        <"
}