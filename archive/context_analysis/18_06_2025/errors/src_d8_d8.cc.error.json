{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8.cc\",\n        \"file_name\": \"d8.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implementation of the d8 command-line tool, which is a JavaScript shell for V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C/C++ libraries for various functionalities like input/output, string manipulation, system calls, and data structures.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <errno.h>\n            #include <fcntl.h>\n            #include <stdlib.h>\n            #include <string.h>\n            #include <sys/stat.h>\n\n            #include <algorithm>\n            #include <fstream>\n            #include <iomanip>\n            #include <iterator>\n            #include <string>\n            #include <tuple>\n            #include <type_traits>\n            #include <unordered_map>\n            #include <utility>\n            #include <vector>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes V8 public API headers, libplatform headers, and V8 internal headers for accessing V8's functionalities and data structures.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef ENABLE_VTUNE_JIT_INTERFACE\n            #include \"third_party/vtune/v8-vtune.h\"\n            #endif\n\n            #include \"include/libplatform/libplatform.h\"\n            #include \"include/libplatform/v8-tracing.h\"\n            #include \"include/v8-function.h\"\n            #include \"include/v8-initialization.h\"\n            #include \"include/v8-inspector.h\"\n            #include \"include/v8-isolate.h\"\n            #include \"include/v8-json.h\"\n            #include \"include/v8-locker.h\"\n            #include \"include/v8-profiler.h\"\n            #include \"include/v8-wasm.h\"\n            #include \"src/api/api-inl.h\"\n            #include \"src/base/cpu.h\"\n            #include \"src/base/fpu.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/base/platform/memory.h\"\n            #include \"src/base/platform/platform.h\"\n            #include \"src/base/platform/time.h\"\n            #include \"src/base/platform/wrappers.h\"\n            #include \"src/base/sanitizer/msan.h\"\n            #include \"src/base/sys-info.h\"\n            #include \"src/base/utils/random-number-generator.h\"\n            #include \"src/compiler-dispatcher/optimizing-compile-dispatcher.h\"\n            #include \"src/d8/d8-console.h\"\n            #include \"src/d8/d8-platforms.h\"\n            #include \"src/d8/d8.h\"\n            #include \"src/debug/debug-interface.h\"\n            #include \"src/deoptimizer/deoptimizer.h\"\n            #include \"src/diagnostics/basic-block-profiler.h\"\n            #include \"src/execution/microtask-queue.h\"\n            #include \"src/execution/v8threads.h\"\n            #include \"src/flags/flags.h\"\n            #include \"src/handles/maybe-handles.h\"\n            #include \"src/heap/parked-scope-inl.h\"\n            #include \"src/init/v8.h\"\n            #include \"src/interpreter/interpreter.h\"\n            #include \"src/logging/counters.h\"\n            #include \"src/logging/log-file.h\"\n            #include \"src/objects/js-array.h\"\n            #include \"src/objects/managed-inl.h\"\n            #include \"src/objects/objects-inl.h\"\n            #include \"src/objects/objects.h\"\n            #include \"src/parsing/parse-info.h\"\n            #include \"src/parsing/parsing.h\"\n            #include \"src/parsing/scanner-character-streams.h\"\n            #include \"src/profiler/profile-generator.h\"\n            #include \"src/snapshot/snapshot.h\"\n            #include \"src/tasks/cancelable-task.h\"\n            #include \"src/utils/ostreams.h\"\n            #include \"src/utils/utils.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes platform-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_OS_DARWIN\n            #include <mach/mach.h>\n            #include <mach/task_policy.h>\n            #endif\n\n            #ifdef V8_ENABLE_MAGLEV\n            #include \"src/maglev/maglev-concurrent-dispatcher.h\"\n            #endif  // V8_ENABLE_MAGLEV\n\n            #ifdef V8_ENABLE_PARTITION_ALLOC\n            #include <partition_alloc/shim/allocator_shim_default_dispatch_to_partition_alloc.h>\n            #endif  // V8_ENABLE_PARTITION_ALLOC\n\n            #if V8_OS_POSIX\n            #include <signal.h>\n            #endif  // V8_OS_POSIX\n\n            #ifdef V8_FUZZILLI\n            #include \"src/fuzzilli/cov.h\"\n            #include \"src/fuzzilli/fuzzilli.h\"\n            #endif  // V8_FUZZILLI\n\n            #ifdef V8_USE_PERFETTO\n            #include \"perfetto/tracing/track_event.h\"\n            #include \"perfetto/tracing/track_event_legacy.h\"\n            #endif  // V8_USE_PERFETTO\n\n            #ifdef V8_INTL_SUPPORT\n            #include \"unicode/locid.h\"\n            #endif  // V8_INTL_SUPPORT\n\n            #ifdef V8_OS_LINUX\n            #include <sys/mman.h>  // For MultiMappedAllocator.\n            #endif\n\n            #if defined(V8_OS_WIN)\n            #include <windows.h>\n            #else\n            #include <unistd.h>\n            #endif  // defined(V8_OS_WIN)\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/trap-handler/trap-handler.h\"\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines CHECK and DCHECK macros if they are not already defined.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifndef DCHECK\n            #define DCHECK(condition) assert(condition)\n            #endif\n\n            #ifndef CHECK\n            #define CHECK(condition) assert(condition)\n            #endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ArrayBufferAllocatorBase\",\n            \"extends\": \"v8::ArrayBuffer::Allocator\",\n            \"about\": \"Base class for shell ArrayBuffer allocators. Forwards operations to the default V8 allocator.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class ArrayBufferAllocatorBase : public v8::ArrayBuffer::Allocator {\n            public:\n                void* Allocate(size_t length) override {\n                return allocator_->Allocate(length);\n                }\n\n                void* AllocateUninitialized(size_t length) override {\n                return allocator_->AllocateUninitialized(length);\n                }\n\n                void Free(void* data, size_t length) override {\n                allocator_->Free(data, length);\n                }\n\n                PageAllocator* GetPageAllocator() override {\n                return allocator_->GetPageAllocator();\n                }\n\n            private:\n                std::unique_ptr<Allocator> allocator_ =\n                    std::unique_ptr<Allocator>(NewDefaultAllocator());\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ShellArrayBufferAllocator\",\n            \"extends\": \"ArrayBufferAllocatorBase\",\n            \"about\": \"ArrayBuffer allocator that can use virtual memory to improve performance.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ArrayBufferAllocatorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class ShellArrayBufferAllocator : public ArrayBufferAllocatorBase {\n            public:\n                void* Allocate(size_t length) override {\n                if (length >= kVMThreshold) return AllocateVM(length);\n                return ArrayBufferAllocatorBase::Allocate(length);\n                }\n\n                void* AllocateUninitialized(size_t length) override {\n                if (length >= kVMThreshold) return AllocateVM(length);\n                return ArrayBufferAllocatorBase::AllocateUninitialized(length);\n                }\n\n                void Free(void* data, size_t length) override {\n                if (length >= kVMThreshold) {\n                    FreeVM(data, length);\n                } else {\n                    ArrayBufferAllocatorBase::Free(data, length);\n                }\n                }\n\n            private:\n                static constexpr size_t kVMThreshold = 65536;\n\n                void* AllocateVM(size_t length) {\n                DCHECK_LE(kVMThreshold, length);\n                v8::PageAllocator* page_allocator = GetPageAllocator();\n                size_t page_size = page_allocator->AllocatePageSize();\n                size_t allocated = RoundUp(length, page_size);\n                return i::AllocatePages(page_allocator, nullptr, allocated, page_size,\n                                        PageAllocator::kReadWrite);\n                }\n\n                void FreeVM(void* data, size_t length) {\n                v8::PageAllocator* page_allocator = GetPageAllocator();\n                size_t page_size = page_allocator->AllocatePageSize();\n                size_t allocated = RoundUp(length, page_size);\n                i::FreePages(page_allocator, data, allocated);\n                }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MockArrayBufferAllocator\",\n            \"extends\": \"ArrayBufferAllocatorBase\",\n            \"about\": \"ArrayBuffer allocator that never allocates over 10MB.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"ArrayBufferAllocatorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class MockArrayBufferAllocator : public ArrayBufferAllocatorBase {\n            protected:\n                void* Allocate(size_t length) override {\n                return ArrayBufferAllocatorBase::Allocate(Adjust(length));\n                }\n\n                void* AllocateUninitialized(size_t length) override {\n                return ArrayBufferAllocatorBase::AllocateUninitialized(Adjust(length));\n                }\n\n                void Free(void* data, size_t length) override {\n                return ArrayBufferAllocatorBase::Free(data, length);\n                }\n\n            private:\n                size_t Adjust(size_t length) {\n                const size_t kAllocationLimit = 10 * i::MB;\n                return length > kAllocationLimit ? i::AllocatePageSize() : length;\n                }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MockArrayBufferAllocatiorWithLimit\",\n            \"extends\": \"MockArrayBufferAllocator\",\n            \"about\": \"ArrayBuffer allocator that can be equipped with a limit to simulate system OOM.\",\n            \"attributes\": [\n                {\n                    \"name\": \"limit_\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The maximum allocation limit.\"\n                },\n                {\n                    \"name\": \"space_left_\",\n                    \"type\": \"std::atomic<size_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The amount of space left for allocation.\"\n                }\n            ],\n            \"dependencies\": [\n                \"MockArrayBufferAllocator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class MockArrayBufferAllocatiorWithLimit : public MockArrayBufferAllocator {\n            public:\n                explicit MockArrayBufferAllocatiorWithLimit(size_t allocation_limit)\n                    : limit_(allocation_limit), space_left_(allocation_limit) {}\n\n            protected:\n                void* Allocate(size_t length) override {\n                if (length > space_left_) {\n                    return nullptr;\n                }\n                space_left_ -= length;\n                return MockArrayBufferAllocator::Allocate(length);\n                }\n\n                void* AllocateUninitialized(size_t length) override {\n                if (length > space_left_) {\n                    return nullptr;\n                }\n                space_left_ -= length;\n                return MockArrayBufferAllocator::AllocateUninitialized(length);\n                }\n\n                void Free(void* data, size_t length) override {\n                space_left_ += length;\n                return MockArrayBufferAllocator::Free(data, length);\n                }\n\n                size_t MaxAllocationSize() const override { return limit_; }\n\n            private:\n                size_t limit_;\n                std::atomic<size_t> space_left_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MultiMappedAllocator\",\n            \"extends\": \"ArrayBufferAllocatorBase\",\n            \"about\": \"Mock allocator for testing huge arrays by aliasing memory.\",\n            \"attributes\": [\n                {\n                    \"name\": \"regions_\",\n                    \"type\": \"std::unordered_map<void*, void*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mapping between virtual and real allocations.\"\n                },\n                {\n                    \"name\": \"regions_mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mutex to protect the regions_ map.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ArrayBufferAllocatorBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            #ifdef V8_OS_LINUX\n\n            // This is a mock allocator variant that provides a huge virtual allocation\n            // backed by a small real allocation that is repeatedly mapped. If you create an\n            // array on memory allocated by this allocator, you will observe that elements\n            // will alias each other as if their indices were modulo-divided by the real\n            // allocation length.\n            // The purpose is to allow stability-testing of huge (typed) arrays without\n            // actually consuming huge amounts of physical memory.\n            // This is currently only available on Linux because it relies on {mremap}.\n            class MultiMappedAllocator : public ArrayBufferAllocatorBase {\n            protected:\n                void* Allocate(size_t length) override {\n                if (length < kChunkSize) {\n                    return ArrayBufferAllocatorBase::Allocate(length);\n                }\n                // We use mmap, which initializes pages to zero anyway.\n                return AllocateUninitialized(length);\n                }\n\n                void* AllocateUninitialized(size_t length) override {\n                if (length < kChunkSize) {\n                    return ArrayBufferAllocatorBase::AllocateUninitialized(length);\n                }\n                size_t rounded_length = RoundUp(length, kChunkSize);\n                int prot = PROT_READ | PROT_WRITE;\n                // We have to specify MAP_SHARED to make {mremap} below do what we want.\n                int flags = MAP_SHARED | MAP_ANONYMOUS;\n                void* real_alloc = mmap(nullptr, kChunkSize, prot, flags, -1, 0);\n                if (reinterpret_cast<intptr_t>(real_alloc) == -1) {\n                    // If we ran into some limit (physical or virtual memory, or number\n                    // of mappings, etc), return {nullptr}, which callers can handle.\n                    if (errno == ENOMEM) {\n                    return nullptr;\n                    }\n                    // Other errors may be bugs which we want to learn about.\n                    FATAL(\"mmap (real) failed with error %d: %s\", errno, strerror(errno));\n                }\n            #ifdef V8_ENABLE_SANDBOX\n                // The backing memory must be allocated inside the sandbox as it will be\n                // used for array buffer contents.\n                // Here we go into somewhat less-well-defined territory by using the\n                // sandbox's virtual address space to essentially just reserve a number of\n                // OS pages inside the sandbox, but then using mremap to replace these\n                // pages directly afterwards. In practice, this works fine however.\n                VirtualAddressSpace* vas = i::Sandbox::current()->address_space();\n                i::Address in_sandbox_page_reservation = vas->AllocatePages(\n                    VirtualAddressSpace::kNoHint, rounded_length,\n                    vas->allocation_granularity(), PagePermissions::kNoAccess);\n                void* virtual_alloc =\n                    in_sandbox_page_reservation != 0\n                        ? reinterpret_cast<void*>(in_sandbox_page_reservation)\n                        : reinterpret_cast<void*>(-1);\n            #else\n                void* virtual_alloc =\n                    mmap(nullptr, rounded_length, prot, flags | MAP_NORESERVE, -1, 0);\n            #endif\n                if (reinterpret_cast<intptr_t>(virtual_alloc) == -1) {\n                    if (errno == ENOMEM) {\n                    // Undo earlier, successful mappings.\n                    munmap(real_alloc, kChunkSize);\n                    return nullptr;\n                    }\n                    FATAL(\"mmap (virtual) failed with error %d: %s\", errno, strerror(errno));\n                }\n                i::Address virtual_base = reinterpret_cast<i::Address>(virtual_alloc);\n                i::Address virtual_end = virtual_base + rounded_length;\n                for (i::Address to_map = virtual_base; to_map < virtual_end;\n                    to_map += kChunkSize) {\n                    // Specifying 0 as the \"old size\" causes the existing map entry to not\n                    // get deleted, which is important so that we can remap it again in the\n                    // next iteration of this loop.\n                    void* result =\n                        mremap(real_alloc, 0, kChunkSize, MREMAP_MAYMOVE | MREMAP_FIXED,\n                            reinterpret_cast<void*>(to_map));\n                    if (reinterpret_cast<intptr_t>(result) == -1) {\n                    if (errno == ENOMEM) {\n                        // Undo earlier, successful mappings.\n                        munmap(real_alloc, kChunkSize);\n            #ifdef V8_ENABLE_SANDBOX\n                        vas->FreePages(in_sandbox_page_reservation, rounded_length);\n            #else\n                        munmap(virtual_alloc, rounded_length);\n            #endif\n                        return nullptr;\n                    }\n                    FATAL(\"mremap failed with error %d: %s\", errno, strerror(errno));\n                    }\n                }\n                base::MutexGuard lock_guard(&regions_mutex_);\n                regions_[virtual_alloc] = real_alloc;\n                return virtual_alloc;\n                }\n\n                void Free(void* data, size_t length) override {\n                if (length < kChunkSize) {\n                    return ArrayBufferAllocatorBase::Free(data, length);\n                }\n                base::MutexGuard lock_guard(&regions_mutex_);\n                void* real_alloc = regions_[data];\n                munmap(real_alloc, kChunkSize);\n                size_t rounded_length = RoundUp(length, kChunkSize);\n            #ifdef V8_ENABLE_SANDBOX\n                VirtualAddressSpace* vas = i::Sandbox::current()->address_space();\n                vas->FreePages(reinterpret_cast<i::Address>(data), rounded_length);\n            #else\n                munmap(data, rounded_length);\n            #endif\n                regions_.erase(data);\n                }\n\n            private:\n                // Aiming for a \"Huge Page\" (2M on Linux x64) to go easy on the TLB.\n                static constexpr size_t kChunkSize = 2 * 1024 * 1024;\n\n                std::unordered_map<void*, void*> regions_;\n                base::Mutex regions_mutex_;\n            };\n\n            #endif  // V8_OS_LINUX\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ThrowError\",\n            \"about\": \"Throws a JavaScript error with the given message.\",\n            \"logic\": \"If execution is terminating, the function returns. Otherwise, it throws a JavaScript error using the provided message.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate to throw the error in.\"\n                },\n                {\n                    \"name\": \"message\",\n                    \"type\": \"const char (&)[N]\",\n                    \"purpose\": \"The error message to throw.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <int N>\n            void ThrowError(Isolate* isolate, const char (&message)[N]) {\n            if (isolate->IsExecutionTerminating()) return;\n            isolate->ThrowError(message);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ThrowError\",\n            \"about\": \"Throws a JavaScript error with the given Local<String> message.\",\n            \"logic\": \"If execution is terminating, the function returns. Otherwise, it throws a JavaScript error using the provided Local<String> message.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate to throw the error in.\"\n                },\n                {\n                    \"name\": \"message\",\n                    \"type\": \"Local<String>\",\n                    \"purpose\": \"The error message to throw.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void ThrowError(Isolate* isolate, Local<String> message) {\n            if (isolate->IsExecutionTerminating()) return;\n            isolate->ThrowError(message);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ThrowException\",\n            \"about\": \"Throws a JavaScript exception with the given Local<Value> exception.\",\n            \"logic\": \"If execution is terminating, the function returns. Otherwise, it throws a JavaScript exception using the provided Local<Value> exception.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate to throw the exception in.\"\n                },\n                {\n                    \"name\": \"exception\",\n                    \"type\": \"Local<Value>\",\n                    \"purpose\": \"The exception to throw.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void ThrowException(Isolate* isolate, Local<Value> exception) {\n            if (isolate->IsExecutionTerminating()) return;\n            isolate->ThrowException(exception);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryGetValue\",\n            \"about\": \"Safely gets a value from a V8 object by property name.\",\n            \"logic\": \"Tries to retrieve a property from a V8 object using its name. Returns an empty MaybeLocal if the property cannot be found.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"v8::Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"context\",\n                    \"type\": \"Local<Context>\",\n                    \"purpose\": \"The V8 context.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Local<v8::Object>\",\n                    \"purpose\": \"The V8 object to retrieve the property from.\"\n                },\n                {\n                    \"name\": \"property\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the property to retrieve.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MaybeLocal<Value>\",\n                \"description\": \"The value of the property, or an empty MaybeLocal if the property is not found.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            static MaybeLocal<Value> TryGetValue(v8::Isolate* isolate,\n                                                Local<Context> context,\n                                                Local<v8::Object> object,\n                                                const char* property) {\n            MaybeLocal<String> v8_str = String::NewFromUtf8(isolate, property);\n            if (v8_str.IsEmpty()) return {};\n            return object->Get(context, v8_str.ToLocalChecked());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetValue\",\n            \"about\": \"Gets a value from a V8 object by property name.\",\n            \"logic\": \"Retrieves a property from a V8 object using its name. Throws an error if retrieval fails.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"v8::Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"context\",\n                    \"type\": \"Local<Context>\",\n                    \"purpose\": \"The V8 context.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Local<v8::Object>\",\n                    \"purpose\": \"The V8 object to retrieve the property from.\"\n                },\n                {\n                    \"name\": \"property\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the property to retrieve.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Local<Value>\",\n                \"description\": \"The value of the property.\"\n            },\n            \"dependencies\": [\n                \"TryGetValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static Local<Value> GetValue(v8::Isolate* isolate, Local<Context> context,\n                                        Local<v8::Object> object, const char* property) {\n            return TryGetValue(isolate, context, object, property).ToLocalChecked();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetWorkerFromInternalField\",\n            \"about\": \"Retrieves a Worker object from a V8 object's internal field.\",\n            \"logic\": \"Checks if the provided object has the expected internal field count and retrieves the Worker object from the internal field. Throws an error if the object is not a Worker or if the worker is defunct.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Local<Object>\",\n                    \"purpose\": \"The V8 object containing the Worker.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::shared_ptr<Worker>\",\n                \"description\": \"The shared pointer to the Worker object.\"\n            },\n            \"dependencies\": [\n                \"ThrowError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::shared_ptr<Worker> GetWorkerFromInternalField(Isolate* isolate,\n                                                            Local<Object> object) {\n            if (object->InternalFieldCount() != 1) {\n                ThrowError(isolate, \"this is not a Worker\");\n                return nullptr;\n            }\n\n            i::DirectHandle<i::Object> handle =\n                Utils::OpenDirectHandle(*object->GetInternalField(0));\n            if (IsSmi(*handle)) {\n                ThrowError(isolate, \"Worker is defunct because main thread is terminating\");\n                return nullptr;\n            }\n            auto managed = i::Cast<i::Managed<Worker>>(handle);\n            return managed->get();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetThreadOptions\",\n            \"about\": \"Configures the options for a new thread.\",\n            \"logic\": \"Returns a base::Thread::Options object with a specified stack size. The stack size is set to 2MB, which is sufficient for parsing large literal expressions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name of the thread.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"base::Thread::Options\",\n                \"description\": \"The thread options with the specified stack size.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            base::Thread::Options GetThreadOptions(const char* name) {\n            // On some systems (OSX 10.6) the stack size default is 0.5Mb or less\n            // which is not enough to parse the big literal expressions used in tests.\n            // The stack size should be at least StackGuard::kLimitSize + some\n            // OS-specific padding for thread startup code.  2Mbytes seems to be enough.\n            return base::Thread::Options(name, 2 * i::MB);\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TraceConfigParser\",\n            \"about\": \"Parses a JSON string to fill a platform::tracing::TraceConfig object.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class TraceConfigParser {\n            public:\n                static void FillTraceConfig(v8::Isolate* isolate,\n                                            platform::tracing::TraceConfig* trace_config,\n                                            const char* json_str) {\n                HandleScope outer_scope(isolate);\n                Local<Context> context = Context::New(isolate);\n                Context::Scope context_scope(context);\n                HandleScope inner_scope(isolate);\n\n                Local<String> source =\n                    String::NewFromUtf8(isolate, json_str).ToLocalChecked();\n                Local<Value> result = JSON::Parse(context, source).ToLocalChecked();\n                Local<v8::Object> trace_config_object = result.As<v8::Object>();\n                // Try reading 'trace_config' property from a full chrome trace config.\n                // https://chromium.googlesource.com/chromium/src/+/master/docs/memory-infra/memory_infra_startup_tracing.md#the-advanced-way\n                Local<Value> maybe_trace_config_object =\n                    GetValue(isolate, context, trace_config_object, kTraceConfigParam);\n                if (maybe_trace_config_object->IsObject()) {\n                    trace_config_object = maybe_trace_config_object.As<Object>();\n                }\n\n                UpdateIncludedCategoriesList(isolate, context, trace_config_object,\n                                            trace_config);\n                }\n\n            private:\n                static int UpdateIncludedCategoriesList(\n                    v8::Isolate* isolate, Local<Context> context, Local<v8::Object> object,\n                    platform::tracing::TraceConfig* trace_config) {\n                Local<Value> value =\n                    GetValue(isolate, context, object, kIncludedCategoriesParam);\n                if (value->IsArray()) {\n                    Local<Array> v8_array = value.As<Array>();\n                    for (int i = 0, length = v8_array->Length(); i < length; ++i) {\n                    Local<Value> v = v8_array->Get(context, i)\n                                        .ToLocalChecked()\n                                        ->ToString(context)\n                                        .ToLocalChecked();\n                    String::Utf8Value str(isolate, v->ToString(context).ToLocalChecked());\n                    trace_config->AddIncludedCategory(*str);\n                    }\n                    return v8_array->Length();\n                }\n                return 0;\n                }\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CreateTraceConfigFromJSON\",\n            \"about\": \"Creates a platform::tracing::TraceConfig object from a JSON string.\",\n            \"logic\": \"Allocates a new TraceConfig, populates it using TraceConfigParser::FillTraceConfig, and returns the pointer.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"v8::Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"json_str\",\n                    \"type"
}