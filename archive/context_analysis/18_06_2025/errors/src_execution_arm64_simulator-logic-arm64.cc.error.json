{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm64/simulator-logic-arm64.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/arm64/simulator-logic-arm64.cc\",\n        \"file_name\": \"simulator-logic-arm64.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the logic for simulating ARM64 instructions, including floating-point and vector operations, within the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for simulator functionality, standard library components, number conversions, and fp16 support.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/arm64/simulator-arm64.h\"\n\n#if defined(USE_SIMULATOR)\n\n#include <cmath>\n\n#include \"src/numbers/conversions-inl.h\"\n#include \"third_party/fp16/src/include/fp16.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"half\",\n            \"about\": \"Represents a half-precision (16-bit) floating-point number, providing conversion to and from single-precision floats and doubles.\",\n            \"attributes\": [\n                {\n                    \"name\": \"bits_\",\n                    \"type\": \"uint16_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the 16-bit representation of the half-precision float.\"\n                }\n            ],\n            \"dependencies\": [\n                \"fp16_ieee_from_fp32_value\",\n                \"DoubleToFloat16\",\n                \"fp16_ieee_to_fp32_value\",\n                \"kFP16DefaultNaN\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass half {\n public:\n  half() : bits_(0) {}\n  half(float f) : bits_(fp16_ieee_from_fp32_value(f)) {}\n  explicit half(double d) : bits_(DoubleToFloat16(d)) {}\n  explicit half(uint16_t b) : bits_(b) {}\n  operator float() const { return fp16_ieee_to_fp32_value(bits_); }\n\n  uint16_t bits() const { return bits_; }\n\n private:\n  uint16_t bits_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FPDefaultNaN\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Provides a default NaN value for half-precision floats in the simulator.\",\n            \"logic\": \"Returns the kFP16DefaultNaN value as a half-precision float.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"half\",\n                \"description\": \"The default NaN value for half-precision floats.\"\n            },\n            \"dependencies\": [\n                \"half\",\n                \"kFP16DefaultNaN\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nhalf Simulator::FPDefaultNaN<half>() {\n  return half(kFP16DefaultNaN);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ToQuietNaN\",\n            \"about\": \"Converts a half-precision floating-point number to its quiet NaN representation.\",\n            \"logic\": \"Sets the most significant bit of the mantissa to 1, ensuring the result is a quiet NaN.\",\n            \"parameters\": [\n                {\n                    \"name\": \"num\",\n                    \"type\": \"half\",\n                    \"purpose\": \"The half-precision floating-point number to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"half\",\n                \"description\": \"The quiet NaN representation of the input number.\"\n            },\n            \"dependencies\": [\n                \"half\",\n                \"kHQuietNanMask\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ninline half ToQuietNaN(half num) {\n  return half(static_cast<uint16_t>(num.bits() | kHQuietNanMask));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"isnormal\",\n            \"about\": \"Checks if a floating-point number is normal.\",\n            \"logic\": \"Uses std::isnormal for standard floats and doubles; uses float16classify for half-precision floats.\",\n            \"parameters\": [\n                {\n                    \"name\": \"f\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The floating-point number to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the number is normal; false otherwise.\"\n            },\n            \"dependencies\": [\n                \"std::isnormal\",\n                \"float16classify\",\n                \"FP_NORMAL\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nbool isnormal(T f) {\n  return std::isnormal(f);\n}\n\ntemplate <>\nbool isnormal(half f) {\n  return float16classify(f.bits()) == FP_NORMAL;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"copysign\",\n            \"about\": \"Copies the sign of one floating-point number to another.\",\n            \"logic\": \"Uses std::copysign for standard floats and doubles; casts double to float for half-precision floats.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"double\",\n                    \"purpose\": \"The number to which the sign will be applied.\"\n                },\n                {\n                    \"name\": \"f\",\n                    \"type\": \"double/float/half\",\n                    \"purpose\": \"The number whose sign will be copied.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"double/float/half\",\n                \"description\": \"The number with the sign copied.\"\n            },\n            \"dependencies\": [\n                \"std::copysign\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ndouble copysign(double a, double f) { return std::copysign(a, f); }\nfloat copysign(double a, float f) { return std::copysign(a, f); }\nhalf copysign(double a, half f) {\n  return std::copysign(static_cast<float>(a), f);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FPRoundToDouble\",\n            \"about\": \"Rounds a floating-point number (represented as sign, exponent, and mantissa) to a double.\",\n            \"logic\": \"Calls FPRound to perform the rounding operation and then converts the result to a double using bit_cast.\",\n            \"parameters\": [\n                {\n                    \"name\": \"sign\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The sign bit of the floating-point number.\"\n                },\n                {\n                    \"name\": \"exponent\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The exponent of the floating-point number.\"\n                },\n                {\n                    \"name\": \"mantissa\",\n                    \"type\": \"uint64_t\",\n                    \"purpose\": \"The mantissa of the floating-point number.\"\n                },\n                {\n                    \"name\": \"round_mode\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"double\",\n                \"description\": \"The rounded double value.\"\n            },\n            \"dependencies\": [\n                \"FPRound\",\n                \"kDoubleExponentBits\",\n                \"kDoubleMantissaBits\",\n                \"base::bit_cast\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ninline double FPRoundToDouble(int64_t sign, int64_t exponent, uint64_t mantissa,\n                              FPRounding round_mode) {\n  uint64_t bits = FPRound<uint64_t, kDoubleExponentBits, kDoubleMantissaBits>(\n      sign, exponent, mantissa, round_mode);\n  return base::bit_cast<double>(bits);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FPRoundToFloat\",\n            \"about\": \"Rounds a floating-point number (represented as sign, exponent, and mantissa) to a float.\",\n            \"logic\": \"Calls FPRound to perform the rounding operation and then converts the result to a float using bit_cast.\",\n            \"parameters\": [\n                {\n                    \"name\": \"sign\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The sign bit of the floating-point number.\"\n                },\n                {\n                    \"name\": \"exponent\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The exponent of the floating-point number.\"\n                },\n                {\n                    \"name\": \"mantissa\",\n                    \"type\": \"uint64_t\",\n                    \"purpose\": \"The mantissa of the floating-point number.\"\n                },\n                {\n                    \"name\": \"round_mode\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float\",\n                \"description\": \"The rounded float value.\"\n            },\n            \"dependencies\": [\n                \"FPRound\",\n                \"kFloatExponentBits\",\n                \"kFloatMantissaBits\",\n                \"base::bit_cast\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ninline float FPRoundToFloat(int64_t sign, int64_t exponent, uint64_t mantissa,\n                            FPRounding round_mode) {\n  uint32_t bits = FPRound<uint32_t, kFloatExponentBits, kFloatMantissaBits>(\n      sign, exponent, mantissa, round_mode);\n  return base::bit_cast<float>(bits);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FPRoundToFloat16\",\n            \"about\": \"Rounds a floating-point number (represented as sign, exponent, and mantissa) to a float16.\",\n            \"logic\": \"Calls FPRound to perform the rounding operation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"sign\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The sign bit of the floating-point number.\"\n                },\n                {\n                    \"name\": \"exponent\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The exponent of the floating-point number.\"\n                },\n                {\n                    \"name\": \"mantissa\",\n                    \"type\": \"uint64_t\",\n                    \"purpose\": \"The mantissa of the floating-point number.\"\n                },\n                {\n                    \"name\": \"round_mode\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float16\",\n                \"description\": \"The rounded float16 value.\"\n            },\n            \"dependencies\": [\n                \"FPRound\",\n                \"kFloat16ExponentBits\",\n                \"kFloat16MantissaBits\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ninline float16 FPRoundToFloat16(int64_t sign, int64_t exponent,\n                                uint64_t mantissa, FPRounding round_mode) {\n  return FPRound<float16, kFloat16ExponentBits, kFloat16MantissaBits>(\n      sign, exponent, mantissa, round_mode);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FixedToDouble\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Converts a fixed-point number to a double-precision floating-point number.\",\n            \"logic\": \"Handles negative and positive numbers by calling UFixedToDouble and negating the result if necessary.  Handles INT64_MIN as a special case to avoid overflow.\",\n            \"parameters\": [\n                {\n                    \"name\": \"src\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The fixed-point number to convert.\"\n                },\n                {\n                    \"name\": \"fbits\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of fractional bits in the fixed-point representation.\"\n                },\n                {\n                    \"name\": \"round\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"double\",\n                \"description\": \"The double-precision floating-point representation of the fixed-point number.\"\n            },\n            \"dependencies\": [\n                \"UFixedToDouble\",\n                \"INT64_MIN\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ndouble Simulator::FixedToDouble(int64_t src, int fbits, FPRounding round) {\n  if (src >= 0) {\n    return UFixedToDouble(src, fbits, round);\n  } else if (src == INT64_MIN) {\n    return -UFixedToDouble(src, fbits, round);\n  } else {\n    return -UFixedToDouble(-src, fbits, round);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UFixedToDouble\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Converts an unsigned fixed-point number to a double-precision floating-point number.\",\n            \"logic\": \"Calculates the exponent and uses FPRoundToDouble to perform the conversion. Handles zero as a special subnormal case.\",\n            \"parameters\": [\n                {\n                    \"name\": \"src\",\n                    \"type\": \"uint64_t\",\n                    \"purpose\": \"The unsigned fixed-point number to convert.\"\n                },\n                {\n                    \"name\": \"fbits\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of fractional bits in the fixed-point representation.\"\n                },\n                {\n                    \"name\": \"round\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"double\",\n                \"description\": \"The double-precision floating-point representation of the fixed-point number.\"\n            },\n            \"dependencies\": [\n                \"FPRoundToDouble\",\n                \"CountLeadingZeros\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ndouble Simulator::UFixedToDouble(uint64_t src, int fbits, FPRounding round) {\n  // An input of 0 is a special case because the result is effectively\n  // subnormal: The exponent is encoded as 0 and there is no implicit 1 bit.\n  if (src == 0) {\n    return 0.0;\n  }\n\n  // Calculate the exponent. The highest significant bit will have the value\n  // 2^exponent.\n  const int highest_significant_bit = 63 - CountLeadingZeros(src, 64);\n  const int64_t exponent = highest_significant_bit - fbits;\n\n  return FPRoundToDouble(0, exponent, src, round);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FixedToFloat\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Converts a fixed-point number to a single-precision floating-point number.\",\n            \"logic\": \"Handles negative and positive numbers by calling UFixedToFloat and negating the result if necessary. Handles INT64_MIN as a special case to avoid overflow.\",\n            \"parameters\": [\n                {\n                    \"name\": \"src\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The fixed-point number to convert.\"\n                },\n                {\n                    \"name\": \"fbits\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of fractional bits in the fixed-point representation.\"\n                },\n                {\n                    \"name\": \"round\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float\",\n                \"description\": \"The single-precision floating-point representation of the fixed-point number.\"\n            },\n            \"dependencies\": [\n                \"UFixedToFloat\",\n                \"INT64_MIN\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nfloat Simulator::FixedToFloat(int64_t src, int fbits, FPRounding round) {\n  if (src >= 0) {\n    return UFixedToFloat(src, fbits, round);\n  } else if (src == INT64_MIN) {\n    return -UFixedToFloat(src, fbits, round);\n  } else {\n    return -UFixedToFloat(-src, fbits, round);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UFixedToFloat\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Converts an unsigned fixed-point number to a single-precision floating-point number.\",\n            \"logic\": \"Calculates the exponent and uses FPRoundToFloat to perform the conversion. Handles zero as a special subnormal case.\",\n            \"parameters\": [\n                {\n                    \"name\": \"src\",\n                    \"type\": \"uint64_t\",\n                    \"purpose\": \"The unsigned fixed-point number to convert.\"\n                },\n                {\n                    \"name\": \"fbits\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of fractional bits in the fixed-point representation.\"\n                },\n                {\n                    \"name\": \"round\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float\",\n                \"description\": \"The single-precision floating-point representation of the fixed-point number.\"\n            },\n            \"dependencies\": [\n                \"FPRoundToFloat\",\n                \"CountLeadingZeros\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nfloat Simulator::UFixedToFloat(uint64_t src, int fbits, FPRounding round) {\n  // An input of 0 is a special case because the result is effectively\n  // subnormal: The exponent is encoded as 0 and there is no implicit 1 bit.\n  if (src == 0) {\n    return 0.0f;\n  }\n\n  // Calculate the exponent. The highest significant bit will have the value\n  // 2^exponent.\n  const int highest_significant_bit = 63 - CountLeadingZeros(src, 64);\n  const int32_t exponent = highest_significant_bit - fbits;\n\n  return FPRoundToFloat(0, exponent, src, round);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FixedToFloat16\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Converts a fixed-point number to a half-precision floating-point number.\",\n            \"logic\": \"Handles negative and positive numbers by calling UFixedToFloat16 and negating the result if necessary.  Handles INT64_MIN as a special case to avoid overflow.\",\n            \"parameters\": [\n                {\n                    \"name\": \"src\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The fixed-point number to convert.\"\n                },\n                {\n                    \"name\": \"fbits\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of fractional bits in the fixed-point representation.\"\n                },\n                {\n                    \"name\": \"round\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float16\",\n                \"description\": \"The half-precision floating-point representation of the fixed-point number.\"\n            },\n            \"dependencies\": [\n                \"UFixedToFloat16\",\n                \"INT64_MIN\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nfloat16 Simulator::FixedToFloat16(int64_t src, int fbits, FPRounding round) {\n  if (src >= 0) {\n    return UFixedToFloat16(src, fbits, round);\n  } else if (src == INT64_MIN) {\n    return -UFixedToFloat16(src, fbits, round);\n  } else {\n    return -UFixedToFloat16(-src, fbits, round);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UFixedToFloat16\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Converts an unsigned fixed-point number to a half-precision floating-point number.\",\n            \"logic\": \"Calculates the exponent and uses FPRoundToFloat16 to perform the conversion. Handles zero as a special subnormal case.\",\n            \"parameters\": [\n                {\n                    \"name\": \"src\",\n                    \"type\": \"uint64_t\",\n                    \"purpose\": \"The unsigned fixed-point number to convert.\"\n                },\n                {\n                    \"name\": \"fbits\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of fractional bits in the fixed-point representation.\"\n                },\n                {\n                    \"name\": \"round\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float16\",\n                \"description\": \"The half-precision floating-point representation of the fixed-point number.\"\n            },\n            \"dependencies\": [\n                \"FPRoundToFloat16\",\n                \"CountLeadingZeros\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nfloat16 Simulator::UFixedToFloat16(uint64_t src, int fbits, FPRounding round) {\n  // An input of 0 is a special case because the result is effectively\n  // subnormal: The exponent is encoded as 0 and there is no implicit 1 bit.\n  if (src == 0) {\n    return static_cast<float16>(0);\n  }\n\n  // Calculate the exponent. The highest significant bit will have the value\n  // 2^exponent.\n  const int highest_significant_bit = 63 - CountLeadingZeros(src, 64);\n  const int16_t exponent = highest_significant_bit - fbits;\n\n  return FPRoundToFloat16(0, exponent, src, round);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FPToDouble\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Converts a single-precision floating-point number to a double-precision floating-point number, handling special cases like NaN, zero, normal, subnormal, and infinite values according to IEEE-754 standards.\",\n            \"logic\": \"For NaN values, it propagates the sign, transfers the mantissa (with the top bit forced to '1' for quiet NaNs), and sets unused bits to 0. For other cases (zero, normal, subnormal, infinite), it performs a standard cast, which preserves the value due to representability in IEEE-754 double format.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"float\",\n                    \"purpose\": \"The single-precision floating-point number to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"double\",\n                \"description\": \"The double-precision floating-point representation of the input value.\"\n            },\n            \"dependencies\": [\n                \"std::fpclassify\",\n                \"FP_NAN\",\n                \"IsSignallingNaN\",\n                \"FPProcessException\",\n                \"DN\",\n                \"kFP64DefaultNaN\",\n                \"base::bit_cast\",\n                \"unsigned_bitextract_64\",\n                \"kDoubleExponentBits\",\n                \"kFloatMantissaBits\",\n                \"kDoubleMantissaBits\",\n                \"double_pack\",\n                \"FP_ZERO\",\n                \"FP_NORMAL\",\n                \"FP_SUBNORMAL\",\n                \"FP_INFINITE\",\n                \"UNREACHABLE\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ndouble Simulator::FPToDouble(float value) {\n  switch (std::fpclassify(value)) {\n    case FP_NAN: {\n      if (IsSignallingNaN(value)) {\n        FPProcessException();\n      }\n      if (DN()) return kFP64DefaultNaN;\n\n      // Convert NaNs as the processor would:\n      //  - The sign is propagated.\n      //  - The mantissa is transferred entirely, except that the top bit is\n      //    forced to '1', making the result a quiet NaN. The unused (low-order)\n      //    mantissa bits are set to 0.\n      uint32_t raw = base::bit_cast<uint32_t>(value);\n\n      uint64_t sign = raw >> 31;\n      uint64_t exponent = (1 << kDoubleExponentBits) - 1;\n      uint64_t mantissa = unsigned_bitextract_64(21, 0, raw);\n\n      // Unused low-order bits remain zero.\n      mantissa <<= (kDoubleMantissaBits - kFloatMantissaBits);\n\n      // Force a quiet NaN.\n      mantissa |= (UINT64_C(1) << (kDoubleMantissaBits - 1));\n\n      return double_pack(sign, exponent, mantissa);\n    }\n\n    case FP_ZERO:\n    case FP_NORMAL:\n    case FP_SUBNORMAL:\n    case FP_INFINITE: {\n      // All other inputs are preserved in a standard cast, because every value\n      // representable using an IEEE-754 float is also representable using an\n      // IEEE-754 double.\n      return static_cast<double>(value);\n    }\n  }\n\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FPToFloat\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Converts a half-precision floating-point number to a single-precision floating-point number, handling special cases according to IEEE-754 standards.\",\n            \"logic\": \"Handles zero, infinity, subnormal, NaN, and normal values, converting them to the corresponding single-precision representations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"float16\",\n                    \"purpose\": \"The half-precision floating-point number to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float\",\n                \"description\": \"The single-precision floating-point representation of the input value.\"\n            },\n            \"dependencies\": [\n                \"float16classify\",\n                \"FP_ZERO\",\n                \"kFP32PositiveInfinity\",\n                \"kFP32NegativeInfinity\",\n                \"FP_INFINITE\",\n                \"FP_SUBNORMAL\",\n                \"CountLeadingZeros\",\n                \"kFloatMantissaBits\",\n                \"kFloat16MantissaBits\",\n                \"kFloatExponentBias\",\n                \"kFloat16ExponentBias\",\n                \"FP_NAN\",\n                \"IsSignallingNaN\",\n                \"FPProcessException\",\n                \"DN\",\n                \"kFP32DefaultNaN\",\n                \"float_pack\",\n                \"FP_NORMAL\",\n                \"UNREACHABLE\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nfloat Simulator::FPToFloat(float16 value) {\n  uint32_t sign = value >> 15;\n  uint32_t exponent =\n      unsigned_bitextract_32(kFloat16MantissaBits + kFloat16ExponentBits - 1,\n                             kFloat16MantissaBits, value);\n  uint32_t mantissa =\n      unsigned_bitextract_32(kFloat16MantissaBits - 1, 0, value);\n\n  switch (float16classify(value)) {\n    case FP_ZERO:\n      return (sign == 0) ? 0.0f : -0.0f;\n\n    case FP_INFINITE:\n      return (sign == 0) ? kFP32PositiveInfinity : kFP32NegativeInfinity;\n\n    case FP_SUBNORMAL: {\n      // Calculate shift required to put mantissa into the most-significant bits\n      // of the destination mantissa.\n      int shift = CountLeadingZeros(mantissa << (32 - 10), 32);\n\n      // Shift mantissa and discard implicit '1'.\n      mantissa <<= (kFloatMantissaBits - kFloat16MantissaBits) + shift + 1;\n      mantissa &= (1 << kFloatMantissaBits) - 1;\n\n      // Adjust the exponent for the shift applied, and rebias.\n      exponent = exponent - shift + (kFloatExponentBias - kFloat16ExponentBias);\n      break;\n    }\n\n    case FP_NAN: {\n      if (IsSignallingNaN(value)) {\n        FPProcessException();\n      }\n      if (DN()) return kFP32DefaultNaN;\n\n      // Convert NaNs as the processor would:\n      //  - The sign is propagated.\n      //  - The mantissa is transferred entirely, except that the top bit is\n      //    forced to '1', making the result a quiet NaN. The unused (low-order)\n      //    mantissa bits are set to 0.\n      exponent = (1 << kFloatExponentBits) - 1;\n\n      // Increase bits in mantissa, making low-order bits 0.\n      mantissa <<= (kFloatMantissaBits - kFloat16MantissaBits);\n      mantissa |= 1 << (kFloatMantissaBits - 1);  // Force a quiet NaN.\n      break;\n    }\n\n    case FP_NORMAL: {\n      // Increase bits in mantissa, making low-order bits 0.\n      mantissa <<= (kFloatMantissaBits - kFloat16MantissaBits);\n\n      // Change exponent bias.\n      exponent += (kFloatExponentBias - kFloat16ExponentBias);\n      break;\n    }\n\n    default:\n      UNREACHABLE();\n  }\n  return float_pack(sign, exponent, mantissa);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FPToFloat16\",\n            \"parent\": \"Simulator\",\n            \"about\": \"Converts a single-precision floating-point number to a half-precision floating-point number, handling special cases like NaN, zero, and infinite values according to IEEE-754 standards. Only FPTieEven rounding mode is supported.\",\n            \"logic\": \"The function handles various floating-point categories (NaN, zero, infinite, normal, and subnormal) according to IEEE-754. For NaN values, it sets the most significant bit of the mantissa to 1 for quiet NaNs. For normal and subnormal numbers, it converts the float-to-half as the processor would, adding the implicit '1' bit and calling FPRoundToFloat16. The round_mode is only FPTieEven.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"float\",\n                    \"purpose\": \"The single-precision floating-point number to convert.\"\n                },\n                {\n                    \"name\": \"round_mode\",\n                    \"type\": \"FPRounding\",\n                    \"purpose\": \"The rounding mode to use (only FPTieEven is supported).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"float16\",\n                \"description\": \"The half-precision floating-point representation of the input value.\"\n            },\n            \"dependencies\": [\n                \"DCHECK_EQ\",\n                \"FPTieEven\",\n                \"USE\",\n                \"float_sign\",\n                \"float_exp\",\n                \"kFloatExponentBias\",\n                \"float_mantissa\",\n                \"std::fpclassify\",\n                \"FP_NAN\",\n                \"IsSignallingNaN\",\n                \"FPProcessException\",\n                \"DN\",\n                \"kFP16DefaultNaN\",\n                \"kFP16PositiveInfinity\",\n                "
}