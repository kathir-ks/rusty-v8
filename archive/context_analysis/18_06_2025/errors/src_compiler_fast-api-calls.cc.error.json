{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/fast-api-calls.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/fast-api-calls.cc\",\n        \"file_name\": \"fast-api-calls.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements fast API calls for the V8 JavaScript engine, optimizing calls to C++ functions from JavaScript.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for fast API call implementation, code generation, and CPU feature detection.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/fast-api-calls.h\"\n\n#include \"src/codegen/cpu-features.h\"\n#include \"src/compiler/globals.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FastApiCallBuilder\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Builds the graph nodes for a fast API call.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"graph_\",\n                    \"type\": \"TFGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Turbofan graph.\"\n                },\n                {\n                    \"name\": \"graph_assembler_\",\n                    \"type\": \"GraphAssembler*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Turbofan graph assembler.\"\n                },\n                {\n                    \"name\": \"get_parameter_\",\n                    \"type\": \"const GetParameter&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A function to get the parameters for the fast API call.\"\n                },\n                {\n                    \"name\": \"convert_return_value_\",\n                    \"type\": \"const ConvertReturnValue&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A function to convert the return value of the fast API call.\"\n                },\n                {\n                    \"name\": \"initialize_options_\",\n                    \"type\": \"const InitializeOptions&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A function to initialize the options for the fast API call.\"\n                },\n                {\n                    \"name\": \"generate_slow_api_call_\",\n                    \"type\": \"const GenerateSlowApiCall&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A function to generate the slow API call in case the fast call fails.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"TFGraph\",\n                \"GraphAssembler\",\n                \"GetParameter\",\n                \"ConvertReturnValue\",\n                \"InitializeOptions\",\n                \"GenerateSlowApiCall\",\n                \"FastApiCallFunction\",\n                \"CallDescriptor\",\n                \"CFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass FastApiCallBuilder {\n public:\n  FastApiCallBuilder(Isolate* isolate, TFGraph* graph,\n                     GraphAssembler* graph_assembler,\n                     const GetParameter& get_parameter,\n                     const ConvertReturnValue& convert_return_value,\n                     const InitializeOptions& initialize_options,\n                     const GenerateSlowApiCall& generate_slow_api_call)\n      : isolate_(isolate),\n        graph_(graph),\n        graph_assembler_(graph_assembler),\n        get_parameter_(get_parameter),\n        convert_return_value_(convert_return_value),\n        initialize_options_(initialize_options),\n        generate_slow_api_call_(generate_slow_api_call) {}\n\n  Node* Build(FastApiCallFunction c_function, Node* data_argument);\n\n private:\n  Node* WrapFastCall(const CallDescriptor* call_descriptor, int inputs_size,\n                     Node** inputs, Node* target,\n                     const CFunctionInfo* c_signature, int c_arg_count,\n                     Node* stack_slot);\n  void PropagateException();\n\n  Isolate* isolate() const { return isolate_; }\n  TFGraph* graph() const { return graph_; }\n  GraphAssembler* gasm() const { return graph_assembler_; }\n  Isolate* isolate_;\n  TFGraph* graph_;\n  GraphAssembler* graph_assembler_;\n  const GetParameter& get_parameter_;\n  const ConvertReturnValue& convert_return_value_;\n  const InitializeOptions& initialize_options_;\n  const GenerateSlowApiCall& generate_slow_api_call_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetTypedArrayElementsKind\",\n            \"parent\": null,\n            \"about\": \"Maps a CTypeInfo::Type to the corresponding ElementsKind for TypedArrays.\",\n            \"logic\": \"A switch statement maps the CTypeInfo::Type enum to the corresponding ElementsKind enum.\",\n            \"parameters\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"CTypeInfo::Type\",\n                    \"purpose\": \"The CTypeInfo::Type to map.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ElementsKind\",\n                \"description\": \"The corresponding ElementsKind.\"\n            },\n            \"dependencies\": [\n                \"CTypeInfo\",\n                \"ElementsKind\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nElementsKind GetTypedArrayElementsKind(CTypeInfo::Type type) {\n  switch (type) {\n    case CTypeInfo::Type::kUint8:\n      return UINT8_ELEMENTS;\n    case CTypeInfo::Type::kInt32:\n      return INT32_ELEMENTS;\n    case CTypeInfo::Type::kUint32:\n      return UINT32_ELEMENTS;\n    case CTypeInfo::Type::kInt64:\n      return BIGINT64_ELEMENTS;\n    case CTypeInfo::Type::kUint64:\n      return BIGUINT64_ELEMENTS;\n    case CTypeInfo::Type::kFloat32:\n      return FLOAT32_ELEMENTS;\n    case CTypeInfo::Type::kFloat64:\n      return FLOAT64_ELEMENTS;\n    case CTypeInfo::Type::kVoid:\n    case CTypeInfo::Type::kSeqOneByteString:\n    case CTypeInfo::Type::kBool:\n    case CTypeInfo::Type::kPointer:\n    case CTypeInfo::Type::kV8Value:\n    case CTypeInfo::Type::kApiObject:\n    case CTypeInfo::Type::kAny:\n      UNREACHABLE();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CanOptimizeFastSignature\",\n            \"parent\": null,\n            \"about\": \"Determines if a C function signature can be optimized for fast API calls.\",\n            \"logic\": \"Checks for various conditions that would prevent optimization, such as argument count limitations on certain architectures, the presence of floating-point parameters when they are disabled, and the usage of clamp lowering on architectures without SSE4.2 support.  Also checks 64 bit types on 32 bit architectures. Architecture-specific configurations are taken into account.\",\n            \"parameters\": [\n                {\n                    \"name\": \"c_signature\",\n                    \"type\": \"const CFunctionInfo*\",\n                    \"purpose\": \"The C function signature to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the signature can be optimized, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"CFunctionInfo\",\n                \"CpuFeatures\",\n                \"v8_flags\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool CanOptimizeFastSignature(const CFunctionInfo* c_signature) {\n  USE(c_signature);\n\n#if defined(V8_OS_MACOS) && defined(V8_TARGET_ARCH_ARM64)\n  // On MacArm64 hardware we don't support passing of arguments on the stack.\n  if (c_signature->ArgumentCount() > 8) {\n    return false;\n  }\n#endif  // defined(V8_OS_MACOS) && defined(V8_TARGET_ARCH_ARM64)\n\n#ifndef V8_ENABLE_FP_PARAMS_IN_C_LINKAGE\n  if (c_signature->ReturnInfo().GetType() == CTypeInfo::Type::kFloat32 ||\n      c_signature->ReturnInfo().GetType() == CTypeInfo::Type::kFloat64) {\n    return false;\n  }\n#endif\n\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n  if (!v8_flags.fast_api_allow_float_in_sim &&\n      (c_signature->ReturnInfo().GetType() == CTypeInfo::Type::kFloat32 ||\n       c_signature->ReturnInfo().GetType() == CTypeInfo::Type::kFloat64)) {\n    return false;\n  }\n#endif\n\n#ifndef V8_TARGET_ARCH_64_BIT\n  if (c_signature->ReturnInfo().GetType() == CTypeInfo::Type::kInt64 ||\n      c_signature->ReturnInfo().GetType() == CTypeInfo::Type::kUint64) {\n    return false;\n  }\n#endif\n\n  for (unsigned int i = 0; i < c_signature->ArgumentCount(); ++i) {\n    USE(i);\n\n#ifdef V8_TARGET_ARCH_X64\n    // Clamp lowering in EffectControlLinearizer uses rounding.\n    uint8_t flags = uint8_t(c_signature->ArgumentInfo(i).GetFlags());\n    if (flags & uint8_t(CTypeInfo::Flags::kClampBit)) {\n      return CpuFeatures::IsSupported(SSE4_2);\n    }\n#endif  // V8_TARGET_ARCH_X64\n\n#ifndef V8_ENABLE_FP_PARAMS_IN_C_LINKAGE\n    if (c_signature->ArgumentInfo(i).GetType() == CTypeInfo::Type::kFloat32 ||\n        c_signature->ArgumentInfo(i).GetType() == CTypeInfo::Type::kFloat64) {\n      return false;\n    }\n#endif\n\n#ifdef V8_USE_SIMULATOR_WITH_GENERIC_C_CALLS\n    if (!v8_flags.fast_api_allow_float_in_sim &&\n        (c_signature->ArgumentInfo(i).GetType() == CTypeInfo::Type::kFloat32 ||\n         c_signature->ArgumentInfo(i).GetType() == CTypeInfo::Type::kFloat64)) {\n      return false;\n    }\n#endif\n\n#ifndef V8_TARGET_ARCH_64_BIT\n    if (c_signature->ArgumentInfo(i).GetType() == CTypeInfo::Type::kInt64 ||\n        c_signature->ArgumentInfo(i).GetType() == CTypeInfo::Type::kUint64) {\n      return false;\n    }\n#endif\n  }\n\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WrapFastCall\",\n            \"parent\": \"FastApiCallBuilder\",\n            \"about\": \"Wraps the generated fast call with CPU profiler support and updates effect and control nodes in the graph.\",\n            \"logic\": \"Stores the target address for CPU profiling, creates the call node, resets the CPU profiler target address, and updates the effect and control nodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"call_descriptor\",\n                    \"type\": \"const CallDescriptor*\",\n                    \"purpose\": \"The call descriptor for the fast call.\"\n                },\n                {\n                    \"name\": \"inputs_size\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of inputs to the call node.\"\n                },\n                {\n                    \"name\": \"inputs\",\n                    \"type\": \"Node**\",\n                    \"purpose\": \"The array of input nodes to the call node.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The target node for the fast call.\"\n                },\n                {\n                    \"name\": \"c_signature\",\n                    \"type\": \"const CFunctionInfo*\",\n                    \"purpose\": \"The C function signature.\"\n                },\n                {\n                    \"name\": \"c_arg_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of arguments to the C function.\"\n                },\n                {\n                    \"name\": \"stack_slot\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The stack slot for options, or nullptr if there are no options.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The call node.\"\n            },\n            \"dependencies\": [\n                \"CallDescriptor\",\n                \"CFunctionInfo\",\n                \"Node\",\n                \"IsolateFieldId\",\n                \"MachineType\",\n                \"StoreRepresentation\",\n                \"GraphAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* FastApiCallBuilder::WrapFastCall(const CallDescriptor* call_descriptor,\n                                       int inputs_size, Node** inputs,\n                                       Node* target,\n                                       const CFunctionInfo* c_signature,\n                                       int c_arg_count, Node* stack_slot) {\n  // CPU profiler support\n  Node* target_address = __ IsolateField(IsolateFieldId::kFastApiCallTarget);\n  __ Store(StoreRepresentation(MachineType::PointerRepresentation(),\n                               kNoWriteBarrier),\n           target_address, 0, __ BitcastTaggedToWord(target));\n\n  // Update effect and control\n  if (stack_slot != nullptr) {\n    inputs[c_arg_count + 1] = stack_slot;\n    inputs[c_arg_count + 2] = __ effect();\n    inputs[c_arg_count + 3] = __ control();\n  } else {\n    inputs[c_arg_count + 1] = __ effect();\n    inputs[c_arg_count + 2] = __ control();\n  }\n\n  // Create the fast call\n  Node* call = __ Call(call_descriptor, inputs_size, inputs);\n\n  // Reset the CPU profiler target address.\n  __ Store(StoreRepresentation(MachineType::PointerRepresentation(),\n                               kNoWriteBarrier),\n           target_address, 0, __ IntPtrConstant(0));\n\n  return call;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"PropagateException\",\n            \"parent\": \"FastApiCallBuilder\",\n            \"about\": \"Propagates an exception from the fast API call.\",\n            \"logic\": \"Calls the kPropagateException runtime function to propagate the exception to JavaScript.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Runtime\",\n                \"CallDescriptor\",\n                \"Linkage\",\n                \"Node\",\n                \"IsolateData\",\n                \"Builtin\",\n                \"ExternalReference\",\n                \"MachineType\",\n                \"IsolateAddressId\",\n                \"RootIndex\",\n                \"GraphAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid FastApiCallBuilder::PropagateException() {\n  Runtime::FunctionId fun_id = Runtime::FunctionId::kPropagateException;\n  const Runtime::Function* fun = Runtime::FunctionForId(fun_id);\n  auto call_descriptor = Linkage::GetRuntimeCallDescriptor(\n      graph()->zone(), fun_id, fun->nargs, Operator::kNoProperties,\n      CallDescriptor::kNoFlags);\n  // The CEntryStub is loaded from the IsolateRoot so that generated code is\n  // Isolate independent. At the moment this is only done for CEntryStub(1).\n  Node* isolate_root = __ LoadRootRegister();\n  DCHECK_EQ(1, fun->result_size);\n  auto centry_id = Builtin::kWasmCEntry;\n  int builtin_slot_offset = IsolateData::BuiltinSlotOffset(centry_id);\n  Node* centry_stub =\n      __ Load(MachineType::Pointer(), isolate_root, builtin_slot_offset);\n  const int kInputCount = 6;\n  Node* inputs[kInputCount];\n  int count = 0;\n  inputs[count++] = centry_stub;\n  inputs[count++] = __ ExternalConstant(ExternalReference::Create(fun_id));\n  inputs[count++] = __ Int32Constant(fun->nargs);\n  inputs[count++] = __ IntPtrConstant(0);\n  inputs[count++] = __ effect();\n  inputs[count++] = __ control();\n  DCHECK_EQ(kInputCount, count);\n\n  __ Call(call_descriptor, count, inputs);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Build\",\n            \"parent\": \"FastApiCallBuilder\",\n            \"about\": \"Builds the graph nodes for the fast API call, including the fast call itself and a fallback slow call.\",\n            \"logic\": \"Generates the fast call and a fallback to the slow call in case of failure. It also handles exception propagation and return value conversion.\",\n            \"parameters\": [\n                {\n                    \"name\": \"c_function\",\n                    \"type\": \"FastApiCallFunction\",\n                    \"purpose\": \"The C function to call.\"\n                },\n                {\n                    \"name\": \"data_argument\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The data argument to pass to the C function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The resulting node representing the fast API call.\"\n            },\n            \"dependencies\": [\n                \"FastApiCallFunction\",\n                \"CFunctionInfo\",\n                \"Node\",\n                \"GetParameter\",\n                \"ConvertReturnValue\",\n                \"InitializeOptions\",\n                \"GenerateSlowApiCall\",\n                \"ExternalReference\",\n                \"MachineSignature\",\n                \"CTypeInfo\",\n                \"CallDescriptor\",\n                \"Linkage\",\n                \"MachineType\",\n                \"StoreRepresentation\",\n                \"IsolateAddressId\",\n                \"RootIndex\",\n                \"GraphAssembler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* FastApiCallBuilder::Build(FastApiCallFunction c_function,\n                                Node* data_argument) {\n  const CFunctionInfo* c_signature = c_function.signature;\n  const int c_arg_count = c_signature->ArgumentCount();\n\n  // Hint to fast path.\n  auto if_success = __ MakeLabel();\n  auto if_error = __ MakeDeferredLabel();\n\n  // Generate fast call.\n\n  const int kFastTargetAddressInputIndex = 0;\n  const int kFastTargetAddressInputCount = 1;\n\n  const int kEffectAndControlInputCount = 2;\n\n  int extra_input_count =\n      kEffectAndControlInputCount + (c_signature->HasOptions() ? 1 : 0);\n\n  Node** const inputs = graph()->zone()->AllocateArray<Node*>(\n      kFastTargetAddressInputCount + c_arg_count + extra_input_count);\n\n  ExternalReference::Type ref_type = ExternalReference::FAST_C_CALL;\n\n  // The inputs to {Call} node for the fast call look like:\n  // [fast callee, receiver, ... C arguments, [optional Options], effect,\n  //  control].\n  //\n  // The first input node represents the target address for the fast call.\n  // If the function is not overloaded (c_functions.size() == 1) this is the\n  // address associated to the first and only element in the c_functions vector.\n  // If there are multiple overloads the value of this input will be set later\n  // with a Phi node created by AdaptOverloadedFastCallArgument.\n  inputs[kFastTargetAddressInputIndex] = __ ExternalConstant(\n      ExternalReference::Create(c_function.address, ref_type));\n\n  for (int i = 0; i < c_arg_count; ++i) {\n    inputs[i + kFastTargetAddressInputCount] = get_parameter_(i, &if_error);\n  }\n  DCHECK_NOT_NULL(inputs[kFastTargetAddressInputIndex]);\n\n  MachineSignature::Builder builder(\n      graph()->zone(), 1, c_arg_count + (c_signature->HasOptions() ? 1 : 0));\n  MachineType return_type =\n      MachineType::TypeForCType(c_signature->ReturnInfo());\n  builder.AddReturn(return_type);\n  for (int i = 0; i < c_arg_count; ++i) {\n    CTypeInfo type = c_signature->ArgumentInfo(i);\n    START_ALLOW_USE_DEPRECATED()\n    MachineType machine_type =\n        type.GetSequenceType() == CTypeInfo::SequenceType::kScalar\n            ? MachineType::TypeForCType(type)\n            : MachineType::AnyTagged();\n    END_ALLOW_USE_DEPRECATED()\n    builder.AddParam(machine_type);\n  }\n\n  Node* stack_slot = nullptr;\n  if (c_signature->HasOptions()) {\n    const int kAlign = alignof(v8::FastApiCallbackOptions);\n    const int kSize = sizeof(v8::FastApiCallbackOptions);\n    // If this check fails, you've probably added new fields to\n    // v8::FastApiCallbackOptions, which means you'll need to write code\n    // that initializes and reads from them too.\n    static_assert(kSize == sizeof(uintptr_t) * 2);\n    stack_slot = __ StackSlot(kSize, kAlign);\n\n    __ Store(StoreRepresentation(MachineType::PointerRepresentation(),\n                                 kNoWriteBarrier),\n             stack_slot,\n             static_cast<int>(offsetof(v8::FastApiCallbackOptions, isolate)),\n             __ ExternalConstant(ExternalReference::isolate_address()));\n\n    Node* data_argument_to_pass = __ AdaptLocalArgument(data_argument);\n\n    __ Store(StoreRepresentation(MachineType::PointerRepresentation(),\n                                 kNoWriteBarrier),\n             stack_slot,\n             static_cast<int>(offsetof(v8::FastApiCallbackOptions, data)),\n             data_argument_to_pass);\n\n    initialize_options_(stack_slot);\n\n    builder.AddParam(MachineType::Pointer());  // stack_slot\n  }\n\n  CallDescriptor* call_descriptor =\n      Linkage::GetSimplifiedCDescriptor(graph()->zone(), builder.Get());\n\n  Node* c_call_result =\n      WrapFastCall(call_descriptor, c_arg_count + extra_input_count + 1, inputs,\n                   inputs[0], c_signature, c_arg_count, stack_slot);\n\n  Node* exception = __ Load(MachineType::IntPtr(),\n                            __ ExternalConstant(ExternalReference::Create(\n                                IsolateAddressId::kExceptionAddress, isolate_)),\n                            0);\n\n  Node* the_hole =\n      __ Load(MachineType::IntPtr(), __ LoadRootRegister(),\n              IsolateData::root_slot_offset(RootIndex::kTheHoleValue));\n\n  auto throw_label = __ MakeDeferredLabel();\n  auto done = __ MakeLabel();\n  __ GotoIfNot(__ IntPtrEqual(exception, the_hole), &throw_label);\n  __ Goto(&done);\n\n  __ Bind(&throw_label);\n  PropagateException();\n  __ Unreachable();\n\n  __ Bind(&done);\n  Node* fast_call_result = convert_return_value_(c_signature, c_call_result);\n\n  auto merge = __ MakeLabel(MachineRepresentation::kTagged);\n  __ Goto(&if_success);\n\n  // We need to generate a fallback (both fast and slow call) in case\n  // the generated code might fail, in case e.g. a Smi was passed where\n  // a JSObject was expected and an error must be thrown\n  if (if_error.IsUsed()) {\n    // Generate direct slow call.\n    __ Bind(&if_error);\n    {\n      Node* slow_call_result = generate_slow_api_call_();\n      __ Goto(&merge, slow_call_result);\n    }\n  }\n\n  __ Bind(&if_success);\n  __ Goto(&merge, fast_call_result);\n\n  __ Bind(&merge);\n  return merge.PhiAt(0);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"BuildFastApiCall\",\n            \"parent\": null,\n            \"about\": \"A wrapper function that instantiates the FastApiCallBuilder and calls its Build method.\",\n            \"logic\": \"This function serves as an entry point, constructing the FastApiCallBuilder and delegating the actual graph construction to the builder's Build method.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"graph\",\n                    \"type\": \"TFGraph*\",\n                    \"purpose\": \"The Turbofan graph.\"\n                },\n                {\n                    \"name\": \"graph_assembler\",\n                    \"type\": \"GraphAssembler*\",\n                    \"purpose\": \"The Turbofan graph assembler.\"\n                },\n                {\n                    \"name\": \"c_function\",\n                    \"type\": \"FastApiCallFunction\",\n                    \"purpose\": \"The C function to call.\"\n                },\n                {\n                    \"name\": \"data_argument\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The data argument to pass to the C function.\"\n                },\n                {\n                    \"name\": \"get_parameter\",\n                    \"type\": \"const GetParameter&\",\n                    \"purpose\": \"A function to get the parameters for the fast API call.\"\n                },\n                {\n                    \"name\": \"convert_return_value\",\n                    \"type\": \"const ConvertReturnValue&\",\n                    \"purpose\": \"A function to convert the return value of the fast API call.\"\n                },\n                {\n                    \"name\": \"initialize_options\",\n                    \"type\": \"const InitializeOptions&\",\n                    \"purpose\": \"A function to initialize the options for the fast API call.\"\n                },\n                {\n                    \"name\": \"generate_slow_api_call\",\n                    \"type\": \"const GenerateSlowApiCall&\",\n                    \"purpose\": \"A function to generate the slow API call in case the fast call fails.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The resulting node representing the fast API call.\"\n            },\n            \"dependencies\": [\n                \"FastApiCallBuilder\",\n                \"Isolate\",\n                \"TFGraph\",\n                \"GraphAssembler\",\n                \"FastApiCallFunction\",\n                \"GetParameter\",\n                \"ConvertReturnValue\",\n                \"InitializeOptions\",\n                \"GenerateSlowApiCall\",\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* BuildFastApiCall(Isolate* isolate, TFGraph* graph,\n                       GraphAssembler* graph_assembler,\n                       FastApiCallFunction c_function, Node* data_argument,\n                       const GetParameter& get_parameter,\n                       const ConvertReturnValue& convert_return_value,\n                       const InitializeOptions& initialize_options,\n                       const GenerateSlowApiCall& generate_slow_api_call) {\n  FastApiCallBuilder builder(isolate, graph, graph_assembler, get_parameter,\n                             convert_return_value, initialize_options,\n                             generate_slow_api_call);\n  return builder.Build(c_function, data_argument);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetFastApiCallTarget\",\n            \"parent\": null,\n            \"about\": \"Retrieves the target address and signature for a fast API call based on the function template info and argument count.\",\n            \"logic\": \"Iterates through the C function signatures associated with the function template info, checking if the argument count matches and if the signature can be optimized for a fast API call. It also performs architecture-specific checks, such as enforcing range bits on 64-bit architectures. Returns the function address and signature if a suitable fast API call target is found; otherwise, returns a null function address.\",\n            \"parameters\": [\n                {\n                    \"name\": \"broker\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"purpose\": \"The JS heap broker.\"\n                },\n                {\n                    \"name\": \"function_template_info\",\n                    \"type\": \"FunctionTemplateInfoRef\",\n                    \"purpose\": \"The function template information.\"\n                },\n                {\n                    \"name\": \"arg_count\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The number of arguments to the function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"FastApiCallFunction\",\n                \"description\": \"The target address and signature for the fast API call, or a null function address if no suitable target is found.\"\n            },\n            \"dependencies\": [\n                \"JSHeapBroker\",\n                \"FunctionTemplateInfoRef\",\n                \"CFunctionInfo\",\n                \"CanOptimizeFastSignature\",\n                \"FastApiCallFunction\",\n                \"v8_flags\",\n                \"CTypeInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nFastApiCallFunction GetFastApiCallTarget(\n    JSHeapBroker* broker, FunctionTemplateInfoRef function_template_info,\n    size_t arg_count) {\n  if (!v8_flags.turbo_fast_api_calls) return {0, nullptr};\n\n  static constexpr int kReceiver = 1;\n\n  const ZoneVector<const CFunctionInfo*>& signatures =\n      function_template_info.c_signatures(broker);\n  const size_t overloads_count = signatures.size();\n\n  // Only considers entries whose type list length matches arg_count.\n  for (size_t i = 0; i < overloads_count; i++) {\n    const CFunctionInfo* c_signature = signatures[i];\n    const size_t len = c_signature->ArgumentCount() - kReceiver;\n    bool optimize_to_fast_call =\n        (len == arg_count) &&\n        fast_api_call::CanOptimizeFastSignature(c_signature);\n\n    if (optimize_to_fast_call) {\n      // TODO(nicohartmann@): {Flags::kEnforceRangeBit} is currently only\n      // supported on 64 bit architectures. We should support this on 32 bit\n      // architectures.\n#if defined(V8_TARGET_ARCH_32_BIT)\n      for (unsigned int j = 0; j < c_signature->ArgumentCount(); ++j) {\n        const uint8_t flags =\n            static_cast<uint8_t>(c_signature->ArgumentInfo(j).GetFlags());\n        if (flags & static_cast<uint8_t>(CTypeInfo::Flags::kEnforceRangeBit)) {\n          // Bailout\n          return {0, nullptr};\n        }\n      }\n#endif\n      return {function_template_info.c_functions(broker)[i], c_signature};\n    }\n  }\n\n  return {0, nullptr};\n}\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TFGraph\",\n                \"about\": \"Represents the Turbofan graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TFGraph;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"GraphAssembler\",\n                \"about\": \"Assembler for building the Turbofan graph.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class GraphAssembler;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CFunctionInfo\",\n                \"about\": \"Holds information about C function signatures.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class CFunctionInfo;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"JSHeapBroker\",\n                \"about\": \"Provides access to the JavaScript heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class JSHeapBroker;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FunctionTemplateInfoRef\",\n                \"about\": \"A reference to function template information.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class FunctionTemplateInfoRef;\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"ElementsKind\",\n                \"about\": \"Enumeration representing different kinds of elements in a JavaScript array.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                enum class ElementsKind;\n            ]]></code>"
}