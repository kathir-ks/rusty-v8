{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/pipeline-data-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/pipeline-data-inl.h\",\n            \"file_name\": \"pipeline-data-inl.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the TFPipelineData class, which holds data used throughout the Turbofan compilation pipeline. This includes the graph, zones, compilation info, and various builders and helpers.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for data structures, compilation phases, code generation, and other compiler-related functionality.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/builtins/profile-data-reader.h\"\n#include \"src/codegen/assembler.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/backend/code-generator.h\"\n#include \"src/compiler/backend/instruction-selector.h\"\n#include \"src/compiler/backend/instruction.h\"\n#include \"src/compiler/backend/register-allocator.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/js-context-specialization.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/js-inlining.h\"\n#include \"src/compiler/js-operator.h\"\n#include \"src/compiler/machine-graph.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node-observer.h\"\n#include \"src/compiler/node-origin-table.h\"\n#include \"src/compiler/phase.h\"\n#include \"src/compiler/pipeline-statistics.h\"\n#include \"src/compiler/schedule.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/turbofan-typer.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/turboshaft/zone-with-name.h\"\n#include \"src/compiler/zone-stats.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/objects/objects-inl.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-engine.h\"\n#endif\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"GetModuleContext\",\n                \"about\": \"Retrieves the module context from the given OptimizedCompilationInfo, traversing the context chain until a module context is found or a native context is reached.\",\n                \"logic\": \"Iterates through the context chain of the closure's context, checking if each context is a ModuleContext.  Returns the OuterContext if found. Returns Nothing if a NativeContext is reached without finding a ModuleContext.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"info\",\n                        \"type\": \"OptimizedCompilationInfo*\",\n                        \"purpose\": \"Provides access to the compilation information, including the closure and its context.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Maybe<OuterContext>\",\n                    \"description\": \"A Maybe containing the OuterContext of the module, or Nothing if no module context is found.\"\n                },\n                \"dependencies\": [\n                    \"OuterContext\",\n                    \"OptimizedCompilationInfo\",\n                    \"Context\",\n                    \"IsNativeContext\",\n                    \"IsModuleContext\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ninline Maybe<OuterContext> GetModuleContext(OptimizedCompilationInfo* info) {\n  Tagged<Context> current = info->closure()->context();\n  size_t distance = 0;\n  while (!IsNativeContext(*current)) {\n    if (current->IsModuleContext()) {\n      return Just(OuterContext(\n          info->CanonicalHandle(current, current->GetIsolate()), distance));\n    }\n    current = current->previous();\n    distance++;\n  }\n  return Nothing<OuterContext>();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TFPipelineData\",\n                \"about\": \"Stores data used throughout the Turbofan compilation pipeline, providing access to the graph, zones, compilation info, and various builders and helpers.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The isolate associated with the compilation.\"\n                    },\n                    {\n                        \"name\": \"allocator_\",\n                        \"type\": \"AccountingAllocator*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The allocator used for memory management during compilation.\"\n                    },\n                    {\n                        \"name\": \"info_\",\n                        \"type\": \"OptimizedCompilationInfo*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Information about the compilation being performed.\"\n                    },\n                    {\n                        \"name\": \"debug_name_\",\n                        \"type\": \"std::unique_ptr<char[]>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Debug name for the compilation.\"\n                    },\n                    {\n                        \"name\": \"zone_stats_\",\n                        \"type\": \"ZoneStats*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Statistics for memory zones.\"\n                    },\n                    {\n                        \"name\": \"pipeline_statistics_\",\n                        \"type\": \"TurbofanPipelineStatistics*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Statistics for the Turbofan pipeline.\"\n                    },\n                    {\n                        \"name\": \"graph_zone_\",\n                        \"type\": \"turboshaft::ZoneWithName<kGraphZoneName>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating graph-related data.\"\n                    },\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The Turbofan graph being compiled.\"\n                    },\n                    {\n                        \"name\": \"source_positions_\",\n                        \"type\": \"SourcePositionTable*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Table mapping nodes to source positions.\"\n                    },\n                    {\n                        \"name\": \"node_origins_\",\n                        \"type\": \"NodeOriginTable*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Table mapping nodes to their origins.\"\n                    },\n                    {\n                        \"name\": \"simplified_\",\n                        \"type\": \"SimplifiedOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builder for simplified operators.\"\n                    },\n                    {\n                        \"name\": \"machine_\",\n                        \"type\": \"MachineOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builder for machine operators.\"\n                    },\n                    {\n                        \"name\": \"common_\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builder for common operators.\"\n                    },\n                    {\n                        \"name\": \"javascript_\",\n                        \"type\": \"JSOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builder for JavaScript operators.\"\n                    },\n                    {\n                        \"name\": \"jsgraph_\",\n                        \"type\": \"JSGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The JavaScript graph representation.\"\n                    },\n                    {\n                        \"name\": \"mcgraph_\",\n                        \"type\": \"MachineGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The Machine Graph (only used for wasm).\"\n                    },\n                    {\n                        \"name\": \"schedule_\",\n                        \"type\": \"Schedule*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The scheduling of nodes in the graph.\"\n                    },\n                    {\n                        \"name\": \"instruction_zone_scope_\",\n                        \"type\": \"ZoneStats::Scope\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Scope for instruction zone stats.\"\n                    },\n                    {\n                        \"name\": \"instruction_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating instruction-related data.\"\n                    },\n                    {\n                        \"name\": \"sequence_\",\n                        \"type\": \"InstructionSequence*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The sequence of instructions.\"\n                    },\n                    {\n                        \"name\": \"codegen_zone_scope_\",\n                        \"type\": \"ZoneStats::Scope\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Scope for codegen zone stats.\"\n                    },\n                    {\n                        \"name\": \"codegen_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating code generation-related data.\"\n                    },\n                    {\n                        \"name\": \"dependencies_\",\n                        \"type\": \"CompilationDependencies*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Dependencies of the compilation.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"std::shared_ptr<JSHeapBroker>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Broker for accessing the JavaScript heap.\"\n                    },\n                    {\n                        \"name\": \"frame_\",\n                        \"type\": \"Frame*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The stack frame being built.\"\n                    },\n                    {\n                        \"name\": \"register_allocation_zone_scope_\",\n                        \"type\": \"ZoneStats::Scope\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Scope for register allocation zone stats.\"\n                    },\n                    {\n                        \"name\": \"register_allocation_zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Memory zone for allocating register allocation-related data.\"\n                    },\n                    {\n                        \"name\": \"register_allocation_data_\",\n                        \"type\": \"RegisterAllocationData*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Data used during register allocation.\"\n                    },\n                    {\n                        \"name\": \"source_position_output_\",\n                        \"type\": \"std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"String for source position output during tracing.\"\n                    },\n                    {\n                        \"name\": \"jump_optimization_info_\",\n                        \"type\": \"JumpOptimizationInfo*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Information for jump optimization.\"\n                    },\n                    {\n                        \"name\": \"assembler_options_\",\n                        \"type\": \"AssemblerOptions\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Options for the assembler.\"\n                    },\n                    {\n                        \"name\": \"specialization_context_\",\n                        \"type\": \"Maybe<OuterContext>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Context for specialization.\"\n                    },\n                    {\n                        \"name\": \"max_unoptimized_frame_height_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maximal combined height of unoptimized frames.\"\n                    },\n                    {\n                        \"name\": \"max_pushed_argument_count_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maximal number of arguments pushed during calls.\"\n                    },\n                    {\n                        \"name\": \"runtime_call_stats_\",\n                        \"type\": \"RuntimeCallStats*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Runtime call statistics (available only during job execution).\"\n                    },\n                    {\n                        \"name\": \"profile_data_\",\n                        \"type\": \"const ProfileDataFromFile*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Profile data loaded from a file.\"\n                    },\n                    {\n                        \"name\": \"wasm_module_for_inlining_\",\n                        \"type\": \"const wasm::WasmModule*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The WebAssembly module to use for inlining.\",\n                        \"conditional\": \"V8_ENABLE_WEBASSEMBLY\"\n                    },\n                    {\n                        \"name\": \"js_wasm_calls_sidetable_\",\n                        \"type\": \"JsWasmCallsSidetable*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Information about calls to WebAssembly functions for inlining.\",\n                        \"conditional\": \"V8_ENABLE_WEBASSEMBLY\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneStats\",\n                    \"Isolate\",\n                    \"OptimizedCompilationInfo\",\n                    \"TurbofanPipelineStatistics\",\n                    \"TFGraph\",\n                    \"SourcePositionTable\",\n                    \"NodeOriginTable\",\n                    \"SimplifiedOperatorBuilder\",\n                    \"MachineOperatorBuilder\",\n                    \"CommonOperatorBuilder\",\n                    \"JSOperatorBuilder\",\n                    \"JSGraph\",\n                    \"Schedule\",\n                    \"InstructionSequence\",\n                    \"CompilationDependencies\",\n                    \"JSHeapBroker\",\n                    \"Frame\",\n                    \"RegisterAllocationData\",\n                    \"AssemblerOptions\",\n                    \"Maybe\",\n                    \"OuterContext\",\n                    \"CodeGenerator\",\n                    \"OsrHelper\",\n                    \"Typer\",\n                    \"Zone\",\n                    \"InstructionBlocks\",\n                    \"CallDescriptor\",\n                    \"RegisterConfiguration\",\n                    \"CodeTracer\",\n                    \"RuntimeCallStats\",\n                    \"wasm::WasmModule\",\n                    \"JsWasmCallsSidetable\",\n                    \"AccountingAllocator\",\n                    \"MachineGraph\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass TFPipelineData {\n public:\n  // For main entry point.\n  TFPipelineData(ZoneStats* zone_stats, Isolate* isolate,\n                 OptimizedCompilationInfo* info,\n                 TurbofanPipelineStatistics* pipeline_statistics)\n      : isolate_(isolate),\n        allocator_(isolate->allocator()),\n        info_(info),\n        debug_name_(info_->GetDebugName()),\n        may_have_unverifiable_graph_(v8_flags.turboshaft),\n        zone_stats_(zone_stats),\n        pipeline_statistics_(pipeline_statistics),\n        graph_zone_(zone_stats_, kGraphZoneName, kCompressGraphZone),\n        instruction_zone_scope_(zone_stats_, kInstructionZoneName),\n        instruction_zone_(instruction_zone_scope_.zone()),\n        codegen_zone_scope_(zone_stats_, kCodegenZoneName),\n        codegen_zone_(codegen_zone_scope_.zone()),\n        broker_(new JSHeapBroker(isolate_, info_->zone(),\n                                 info_->trace_heap_broker(),\n                                 info->code_kind())),\n        register_allocation_zone_scope_(zone_stats_,\n                                        kRegisterAllocationZoneName),\n        register_allocation_zone_(register_allocation_zone_scope_.zone()),\n        assembler_options_(AssemblerOptions::Default(isolate)) {\n    PhaseScope scope(pipeline_statistics, \"V8.TFInitPipelineData\");\n    graph_ = graph_zone_->New<TFGraph>(graph_zone_);\n    source_positions_ = graph_zone_->New<SourcePositionTable>(graph_);\n    node_origins_ = info->trace_turbo_json()\n                        ? graph_zone_->New<NodeOriginTable>(graph_)\n                        : nullptr;\n#if V8_ENABLE_WEBASSEMBLY\n    js_wasm_calls_sidetable_ =\n        graph_zone_->New<JsWasmCallsSidetable>(graph_zone_);\n#endif  // V8_ENABLE_WEBASSEMBLY\n    simplified_ = graph_zone_->New<SimplifiedOperatorBuilder>(graph_zone_);\n    machine_ = graph_zone_->New<MachineOperatorBuilder>(\n        graph_zone_, MachineType::PointerRepresentation(),\n        InstructionSelector::SupportedMachineOperatorFlags(),\n        InstructionSelector::AlignmentRequirements());\n    common_ = graph_zone_->New<CommonOperatorBuilder>(graph_zone_);\n    javascript_ = graph_zone_->New<JSOperatorBuilder>(graph_zone_);\n    jsgraph_ = graph_zone_->New<JSGraph>(isolate_, graph_, common_, javascript_,\n                                         simplified_, machine_);\n    observe_node_manager_ =\n        info->node_observer()\n            ? graph_zone_->New<ObserveNodeManager>(graph_zone_)\n            : nullptr;\n    dependencies_ = info_->zone()->New<CompilationDependencies>(broker_.get(),\n                                                                info_->zone());\n  }\n\n#if V8_ENABLE_WEBASSEMBLY\n  // For WebAssembly compile entry point.\n  TFPipelineData(ZoneStats* zone_stats, wasm::WasmEngine* wasm_engine,\n                 OptimizedCompilationInfo* info, MachineGraph* mcgraph,\n                 TurbofanPipelineStatistics* pipeline_statistics,\n                 SourcePositionTable* source_positions,\n                 NodeOriginTable* node_origins,\n                 const AssemblerOptions& assembler_options)\n      : isolate_(nullptr),\n        allocator_(wasm_engine->allocator()),\n        info_(info),\n        debug_name_(info_->GetDebugName()),\n        may_have_unverifiable_graph_(true),\n        zone_stats_(zone_stats),\n        pipeline_statistics_(pipeline_statistics),\n        graph_zone_(zone_stats_, kGraphZoneName, kCompressGraphZone),\n        graph_(mcgraph->graph()),\n        source_positions_(source_positions),\n        node_origins_(node_origins),\n        machine_(mcgraph->machine()),\n        common_(mcgraph->common()),\n        mcgraph_(mcgraph),\n        instruction_zone_scope_(zone_stats_, kInstructionZoneName),\n        instruction_zone_(instruction_zone_scope_.zone()),\n        codegen_zone_scope_(zone_stats_, kCodegenZoneName),\n        codegen_zone_(codegen_zone_scope_.zone()),\n        register_allocation_zone_scope_(zone_stats_,\n                                        kRegisterAllocationZoneName),\n        register_allocation_zone_(register_allocation_zone_scope_.zone()),\n        assembler_options_(assembler_options) {\n    simplified_ = graph_zone_->New<SimplifiedOperatorBuilder>(graph_zone_);\n    javascript_ = graph_zone_->New<JSOperatorBuilder>(graph_zone_);\n    jsgraph_ = graph_zone_->New<JSGraph>(isolate_, graph_, common_, javascript_,\n                                         simplified_, machine_);\n  }\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n  // For CodeStubAssembler and machine graph testing entry point.\n  TFPipelineData(ZoneStats* zone_stats, OptimizedCompilationInfo* info,\n                 Isolate* isolate, AccountingAllocator* allocator,\n                 TFGraph* graph, JSGraph* jsgraph, Schedule* schedule,\n                 SourcePositionTable* source_positions,\n                 NodeOriginTable* node_origins, JumpOptimizationInfo* jump_opt,\n                 const AssemblerOptions& assembler_options,\n                 const ProfileDataFromFile* profile_data)\n      : isolate_(isolate),\n        allocator_(allocator),\n        info_(info),\n        debug_name_(info_->GetDebugName()),\n        zone_stats_(zone_stats),\n        graph_zone_(zone_stats_, kGraphZoneName, kCompressGraphZone),\n        graph_(graph),\n        source_positions_(source_positions),\n        node_origins_(node_origins),\n        schedule_(schedule),\n        instruction_zone_scope_(zone_stats_, kInstructionZoneName),\n        instruction_zone_(instruction_zone_scope_.zone()),\n        codegen_zone_scope_(zone_stats_, kCodegenZoneName),\n        codegen_zone_(codegen_zone_scope_.zone()),\n        register_allocation_zone_scope_(zone_stats_,\n                                        kRegisterAllocationZoneName),\n        register_allocation_zone_(register_allocation_zone_scope_.zone()),\n        jump_optimization_info_(jump_opt),\n        assembler_options_(assembler_options),\n        profile_data_(profile_data) {\n    if (jsgraph) {\n      jsgraph_ = jsgraph;\n      simplified_ = jsgraph->simplified();\n      machine_ = jsgraph->machine();\n      common_ = jsgraph->common();\n      javascript_ = jsgraph->javascript();\n    } else if (graph_) {\n      simplified_ = graph_zone_->New<SimplifiedOperatorBuilder>(graph_zone_);\n      machine_ = graph_zone_->New<MachineOperatorBuilder>(\n          graph_zone_, MachineType::PointerRepresentation(),\n          InstructionSelector::SupportedMachineOperatorFlags(),\n          InstructionSelector::AlignmentRequirements());\n      common_ = graph_zone_->New<CommonOperatorBuilder>(graph_zone_);\n      javascript_ = graph_zone_->New<JSOperatorBuilder>(graph_zone_);\n      jsgraph_ = graph_zone_->New<JSGraph>(isolate_, graph_, common_,\n                                           javascript_, simplified_, machine_);\n    }\n  }\n\n  // For register allocation testing entry point.\n  TFPipelineData(ZoneStats* zone_stats, OptimizedCompilationInfo* info,\n                 Isolate* isolate, InstructionSequence* sequence)\n      : isolate_(isolate),\n        allocator_(isolate->allocator()),\n        info_(info),\n        debug_name_(info_->GetDebugName()),\n        zone_stats_(zone_stats),\n        graph_zone_(zone_stats_, kGraphZoneName, kCompressGraphZone),\n        instruction_zone_scope_(zone_stats_, kInstructionZoneName),\n        instruction_zone_(sequence->zone()),\n        sequence_(sequence),\n        codegen_zone_scope_(zone_stats_, kCodegenZoneName),\n        codegen_zone_(codegen_zone_scope_.zone()),\n        register_allocation_zone_scope_(zone_stats_,\n                                        kRegisterAllocationZoneName),\n        register_allocation_zone_(register_allocation_zone_scope_.zone()),\n        assembler_options_(AssemblerOptions::Default(isolate)) {}\n\n  ~TFPipelineData() {\n    // Must happen before zones are destroyed.\n    delete code_generator_;\n    code_generator_ = nullptr;\n    DeleteTyper();\n    DeleteRegisterAllocationZone();\n    DeleteInstructionZone();\n    DeleteCodegenZone();\n    DeleteGraphZone();\n  }\n\n  TFPipelineData(const TFPipelineData&) = delete;\n  TFPipelineData& operator=(const TFPipelineData&) = delete;\n\n  Isolate* isolate() const { return isolate_; }\n  AccountingAllocator* allocator() const { return allocator_; }\n  OptimizedCompilationInfo* info() const { return info_; }\n  ZoneStats* zone_stats() const { return zone_stats_; }\n  CompilationDependencies* dependencies() const { return dependencies_; }\n  TurbofanPipelineStatistics* pipeline_statistics() {\n    return pipeline_statistics_;\n  }\n  OsrHelper* osr_helper() { return osr_helper_.get(); }\n  std::shared_ptr<OsrHelper> osr_helper_ptr() const { return osr_helper_; }\n\n  bool verify_graph() const { return verify_graph_; }\n  void set_verify_graph(bool value) { verify_graph_ = value; }\n\n  MaybeIndirectHandle<Code> code() { return code_; }\n  void set_code(MaybeIndirectHandle<Code> code) {\n    DCHECK(code_.is_null());\n    code_ = code;\n  }\n\n  CodeGenerator* code_generator() const { return code_generator_; }\n\n  // RawMachineAssembler generally produces graphs which cannot be verified.\n  bool MayHaveUnverifiableGraph() const { return may_have_unverifiable_graph_; }\n\n  Zone* graph_zone() { return graph_zone_; }\n  TFGraph* graph() const { return graph_; }\n  void set_graph(TFGraph* graph) { graph_ = graph; }\n  template <typename T>\n  using GraphZonePointer = turboshaft::ZoneWithNamePointer<T, kGraphZoneName>;\n  void InitializeWithGraphZone(\n      turboshaft::ZoneWithName<kGraphZoneName> graph_zone,\n      GraphZonePointer<SourcePositionTable> source_positions,\n      GraphZonePointer<NodeOriginTable> node_origins,\n      size_t node_count_hint = 0) {\n    // Delete the old zone first.\n    DeleteGraphZone();\n\n    // Take ownership of the new zone and the existing pointers.\n    graph_zone_ = std::move(graph_zone);\n    source_positions_ = source_positions;\n    node_origins_ = node_origins;\n\n    // Allocate a new graph and schedule.\n    graph_ = graph_zone_.New<TFGraph>(graph_zone_);\n    schedule_ = graph_zone_.New<Schedule>(graph_zone_, node_count_hint);\n\n    // Initialize node builders.\n    javascript_ = graph_zone_.New<JSOperatorBuilder>(graph_zone_);\n    common_ = graph_zone_.New<CommonOperatorBuilder>(graph_zone_);\n    simplified_ = graph_zone_.New<SimplifiedOperatorBuilder>(graph_zone_);\n    machine_ = graph_zone_.New<MachineOperatorBuilder>(\n        graph_zone_, MachineType::PointerRepresentation(),\n        InstructionSelector::SupportedMachineOperatorFlags(),\n        InstructionSelector::AlignmentRequirements());\n  }\n  turboshaft::ZoneWithName<kGraphZoneName> ReleaseGraphZone() {\n    turboshaft::ZoneWithName<kGraphZoneName> temp = std::move(graph_zone_);\n    // Call `DeleteGraphZone` to reset all pointers. The actual zone is not\n    // released because we moved it away.\n    DeleteGraphZone();\n    return temp;\n  }\n  SourcePositionTable* source_positions() const { return source_positions_; }\n  void set_source_positions(SourcePositionTable* source_positions) {\n    source_positions_ = source_positions;\n  }\n  NodeOriginTable* node_origins() const { return node_origins_; }\n  void set_node_origins(NodeOriginTable* node_origins) {\n    node_origins_ = node_origins;\n  }\n  MachineOperatorBuilder* machine() const { return machine_; }\n  SimplifiedOperatorBuilder* simplified() const { return simplified_; }\n  CommonOperatorBuilder* common() const { return common_; }\n  JSOperatorBuilder* javascript() const { return javascript_; }\n  JSGraph* jsgraph() const { return jsgraph_; }\n  MachineGraph* mcgraph() const { return mcgraph_; }\n  DirectHandle<NativeContext> native_context() const {\n    return direct_handle(info()->native_context(), isolate());\n  }\n  DirectHandle<JSGlobalObject> global_object() const {\n    return direct_handle(info()->global_object(), isolate());\n  }\n\n  JSHeapBroker* broker() const { return broker_.get(); }\n  std::shared_ptr<JSHeapBroker> broker_ptr() { return broker_; }\n\n  Schedule* schedule() const { return schedule_; }\n  void set_schedule(Schedule* schedule) {\n    DCHECK(!schedule_);\n    schedule_ = schedule;\n  }\n  void reset_schedule() { schedule_ = nullptr; }\n\n  ObserveNodeManager* observe_node_manager() const {\n    return observe_node_manager_;\n  }\n\n  Zone* instruction_zone() const { return instruction_zone_; }\n  Zone* codegen_zone() const { return codegen_zone_; }\n  InstructionSequence* sequence() const { return sequence_; }\n  Frame* frame() const { return frame_; }\n\n  Zone* register_allocation_zone() const { return register_allocation_zone_; }\n\n  RegisterAllocationData* register_allocation_data() const {\n    return register_allocation_data_;\n  }\n\n  std::string const& source_position_output() const {\n    return source_position_output_;\n  }\n  void set_source_position_output(std::string const& source_position_output) {\n    source_position_output_ = source_position_output;\n  }\n\n  JumpOptimizationInfo* jump_optimization_info() const {\n    return jump_optimization_info_;\n  }\n\n  const AssemblerOptions& assembler_options() const {\n    return assembler_options_;\n  }\n\n  void ChooseSpecializationContext() {\n    if (info()->function_context_specializing()) {\n      DCHECK(info()->has_context());\n      specialization_context_ = Just(OuterContext(\n          info()->CanonicalHandle(info()->context(), isolate()), 0));\n    } else {\n      specialization_context_ = GetModuleContext(info());\n    }\n  }\n\n  Maybe<OuterContext> specialization_context() const {\n    return specialization_context_;\n  }\n\n  size_t* address_of_max_unoptimized_frame_height() {\n    return &max_unoptimized_frame_height_;\n  }\n  size_t max_unoptimized_frame_height() const {\n    return max_unoptimized_frame_height_;\n  }\n  size_t* address_of_max_pushed_argument_count() {\n    return &max_pushed_argument_count_;\n  }\n  size_t max_pushed_argument_count() const {\n    return max_pushed_argument_count_;\n  }\n\n  CodeTracer* GetCodeTracer() const {\n#if V8_ENABLE_WEBASSEMBLY\n    if (info_->IsWasm() || info_->IsWasmBuiltin()) {\n      return wasm::GetWasmEngine()->GetCodeTracer();\n    }\n#endif  // V8_ENABLE_WEBASSEMBLY\n    return isolate_->GetCodeTracer();\n  }\n\n  Typer* CreateTyper() {\n    DCHECK_NULL(typer_);\n    typer_ =\n        new Typer(broker(), typer_flags_, graph(), &info()->tick_counter());\n    return typer_;\n  }\n\n  void AddTyperFlag(Typer::Flag flag) {\n    DCHECK_NULL(typer_);\n    typer_flags_ |= flag;\n  }\n\n  void DeleteTyper() {\n    delete typer_;\n    typer_ = nullptr;\n  }\n\n  void DeleteGraphZone() {\n#ifdef V8_ENABLE_WEBASSEMBLY\n    js_wasm_calls_sidetable_ = nullptr;\n#endif  // V8_ENABLE_WEBASSEMBLY\n    graph_ = nullptr;\n    source_positions_ = nullptr;\n    node_origins_ = nullptr;\n    simplified_ = nullptr;\n    machine_ = nullptr;\n    common_ = nullptr;\n    javascript_ = nullptr;\n    jsgraph_ = nullptr;\n    mcgraph_ = nullptr;\n    schedule_ = nullptr;\n    graph_zone_.Destroy();\n  }\n\n  void DeleteInstructionZone() {\n    if (instruction_zone_ == nullptr) return;\n    instruction_zone_scope_.Destroy();\n    instruction_zone_ = nullptr;\n    sequence_ = nullptr;\n  }\n\n  void DeleteCodegenZone() {\n    if (codegen_zone_ == nullptr) return;\n    codegen_zone_scope_.Destroy();\n    codegen_zone_ = nullptr;\n    dependencies_ = nullptr;\n    broker_.reset();\n    broker_ = nullptr;\n    frame_ = nullptr;\n  }\n\n  void DeleteRegisterAllocationZone() {\n    if (register_allocation_zone_ == nullptr) return;\n    register_allocation_zone_scope_.Destroy();\n    register_allocation_zone_ = nullptr;\n    register_allocation_data_ = nullptr;\n  }\n\n  void InitializeInstructionSequence(const CallDescriptor* call_descriptor) {\n    DCHECK_NULL(sequence_);\n    InstructionBlocks* instruction_blocks =\n        InstructionSequence::InstructionBlocksFor(instruction_zone(),\n                                                  schedule());\n    sequence_ = instruction_zone()->New<InstructionSequence>(\n        isolate(), instruction_zone(), instruction_blocks);\n    if (call_descriptor && call_descriptor->RequiresFrameAsIncoming()) {\n      sequence_->instruction_blocks()[0]->mark_needs_frame();\n    } else {\n      DCHECK(call_descriptor->CalleeSavedFPRegisters().is_empty());\n    }\n  }\n\n  void InitializeFrameData(CallDescriptor* call_descriptor) {\n    DCHECK_NULL(frame_);\n    int fixed_frame_size = 0;\n    if (call_descriptor != nullptr) {\n      fixed_frame_size =\n          call_descriptor->CalculateFixedFrameSize(info()->code_kind());\n    }\n    frame_ = codegen_zone()->New<Frame>(fixed_frame_size, codegen_zone());\n    if (osr_helper_) osr_helper()->SetupFrame(frame());\n  }\n\n  void InitializeRegisterAllocationData(const RegisterConfiguration* config,\n                                        CallDescriptor* call_descriptor) {\n    DCHECK_NULL(register_allocation_data_);\n    register_allocation_data_ =\n        register_allocation_zone()->New<RegisterAllocationData>(\n            config, register_allocation_zone(), frame(), sequence(),\n            &info()->tick_counter(), debug_name());\n  }\n\n  void InitializeOsrHelper() {\n    DCHECK_NULL(osr_helper_);\n    osr_helper_ = std::make_shared<OsrHelper>(info());\n  }\n\n  void set_start_source_position(int position) {\n    DCHECK_EQ(start_source_position_, kNoSourcePosition);\n    start_source_position_ = position;\n  }\n\n  int start_source_position() const { return start_source_position_; }\n\n  void InitializeCodeGenerator(Linkage* linkage) {\n    DCHECK_NULL(code_generator_);\n#if V8_ENABLE_WEBASSEMBLY\n    assembler_options_.is_wasm =\n        this->info()->IsWasm() || this->info()->IsWasmBuiltin();\n#endif\n    std::optional<OsrHelper> osr_helper;\n    if (osr_helper_) osr_helper = *osr_helper_;\n    code_generator_ = new CodeGenerator(\n        codegen_zone(), frame(), linkage, sequence(), info(), isolate(),\n        std::move(osr_helper), start_source_position_, jump_optimization_info_,\n        assembler_options(), info_->builtin(), max_unoptimized_frame_height(),\n        max_pushed_argument_count(),\n        v8_flags.trace_turbo_stack_accesses ? debug_name_.get() : nullptr);\n  }\n\n  void BeginPhaseKind(const char* phase_kind_name) {\n    if (pipeline_statistics() != nullptr) {\n      pipeline_statistics()->BeginPhaseKind(phase_kind_name);\n    }\n  }\n\n  void EndPhaseKind() {\n    if (pipeline_statistics() != nullptr) {\n      pipeline_statistics()->EndPhaseKind();\n    }\n  }\n\n  const char* debug_name() const { return debug_name_.get(); }\n\n  const ProfileData"
}