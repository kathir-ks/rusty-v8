{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/libplatform/v8-tracing.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 179, column 52",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/libplatform/v8-tracing.h\",\n            \"file_name\": \"v8-tracing.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the tracing infrastructure for V8, including interfaces and classes for trace objects, writers, buffers, configurations, and the tracing controller.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8 specific headers needed for tracing functionality.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include <atomic>\n#include <fstream>\n#include <memory>\n#include <unordered_set>\n#include <vector>\n\n#include \"libplatform/libplatform-export.h\"\n#include \"v8-platform.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Mutex\",\n                    \"about\": \"A mutex class for thread synchronization.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace base {\n                    class Mutex;\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ConvertableToTraceFormat\",\n                    \"about\": \"Interface for objects that can be converted to trace format.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 {\n                    class ConvertableToTraceFormat;\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TracingController\",\n                    \"about\": \"Abstract base class for tracing controllers.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 {\n                    class TracingController {\n                        public:\n                            class TraceStateObserver;\n                    };\n                }\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TraceEventListener\",\n                    \"about\": \"Interface for listening to trace events.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                namespace platform {\n                    namespace tracing {\n                        class TraceEventListener;\n                    }\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TraceObject\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents a single trace event.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"pid_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Process ID.\"\n                    },\n                    {\n                        \"name\": \"tid_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Thread ID.\"\n                    },\n                    {\n                        \"name\": \"phase_\",\n                        \"type\": \"char\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Trace event phase character (B, E, I, etc.).\"\n                    },\n                    {\n                        \"name\": \"name_\",\n                        \"type\": \"const char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Trace event name.\"\n                    },\n                    {\n                        \"name\": \"scope_\",\n                        \"type\": \"const char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Trace event scope.\"\n                    },\n                    {\n                        \"name\": \"category_enabled_flag_\",\n                        \"type\": \"const uint8_t*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the category enabled flag.\"\n                    },\n                    {\n                        \"name\": \"id_\",\n                        \"type\": \"uint64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Trace event ID.\"\n                    },\n                    {\n                        \"name\": \"bind_id_\",\n                        \"type\": \"uint64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Trace event bind ID.\"\n                    },\n                    {\n                        \"name\": \"num_args_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of arguments for the trace event.\"\n                    },\n                    {\n                        \"name\": \"arg_names_\",\n                        \"type\": \"const char**\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of argument names.\"\n                    },\n                    {\n                        \"name\": \"arg_types_\",\n                        \"type\": \"uint8_t*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of argument types.\"\n                    },\n                    {\n                        \"name\": \"arg_values_\",\n                        \"type\": \"ArgValue*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of argument values.\"\n                    },\n                    {\n                        \"name\": \"arg_convertables_\",\n                        \"type\": \"std::unique_ptr<v8::ConvertableToTraceFormat>*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of unique pointers to convertable objects.\"\n                    },\n                    {\n                        \"name\": \"parameter_copy_storage_\",\n                        \"type\": \"char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to storage for parameter copies.\"\n                    },\n                    {\n                        \"name\": \"flags_\",\n                        \"type\": \"unsigned int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flags for the trace event.\"\n                    },\n                    {\n                        \"name\": \"ts_\",\n                        \"type\": \"int64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Timestamp of the trace event.\"\n                    },\n                    {\n                        \"name\": \"tts_\",\n                        \"type\": \"int64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"CPU timestamp of the trace event.\"\n                    },\n                    {\n                        \"name\": \"duration_\",\n                        \"type\": \"uint64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Duration of the trace event.\"\n                    },\n                    {\n                        \"name\": \"cpu_duration_\",\n                        \"type\": \"uint64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"CPU duration of the trace event.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"v8::ConvertableToTraceFormat\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_PLATFORM_EXPORT TraceObject {\n public:\n  union ArgValue {\n    uint64_t as_uint;\n    int64_t as_int;\n    double as_double;\n    const void* as_pointer;\n    const char* as_string;\n  };\n\n  TraceObject() = default;\n  ~TraceObject();\n  void Initialize(\n      char phase, const uint8_t* category_enabled_flag, const char* name,\n      const char* scope, uint64_t id, uint64_t bind_id, int num_args,\n      const char** arg_names, const uint8_t* arg_types,\n      const uint64_t* arg_values,\n      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,\n      unsigned int flags, int64_t timestamp, int64_t cpu_timestamp);\n  void UpdateDuration(int64_t timestamp, int64_t cpu_timestamp);\n  void InitializeForTesting(\n      char phase, const uint8_t* category_enabled_flag, const char* name,\n      const char* scope, uint64_t id, uint64_t bind_id, int num_args,\n      const char** arg_names, const uint8_t* arg_types,\n      const uint64_t* arg_values,\n      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,\n      unsigned int flags, int pid, int tid, int64_t ts, int64_t tts,\n      uint64_t duration, uint64_t cpu_duration);\n\n  int pid() const { return pid_; }\n  int tid() const { return tid_; }\n  char phase() const { return phase_; }\n  const uint8_t* category_enabled_flag() const {\n    return category_enabled_flag_;\n  }\n  const char* name() const { return name_; }\n  const char* scope() const { return scope_; }\n  uint64_t id() const { return id_; }\n  uint64_t bind_id() const { return bind_id_; }\n  int num_args() const { return num_args_; }\n  const char** arg_names() { return arg_names_; }\n  uint8_t* arg_types() { return arg_types_; }\n  ArgValue* arg_values() { return arg_values_; }\n  std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables() {\n    return arg_convertables_;\n  }\n  unsigned int flags() const { return flags_; }\n  int64_t ts() { return ts_; }\n  int64_t tts() { return tts_; }\n  uint64_t duration() { return duration_; }\n  uint64_t cpu_duration() { return cpu_duration_; }\n\n private:\n  int pid_;\n  int tid_;\n  char phase_;\n  const char* name_;\n  const char* scope_;\n  const uint8_t* category_enabled_flag_;\n  uint64_t id_;\n  uint64_t bind_id_;\n  int num_args_ = 0;\n  const char* arg_names_[kTraceMaxNumArgs];\n  uint8_t arg_types_[kTraceMaxNumArgs];\n  ArgValue arg_values_[kTraceMaxNumArgs];\n  std::unique_ptr<v8::ConvertableToTraceFormat>\n      arg_convertables_[kTraceMaxNumArgs];\n  char* parameter_copy_storage_ = nullptr;\n  unsigned int flags_;\n  int64_t ts_;\n  int64_t tts_;\n  uint64_t duration_;\n  uint64_t cpu_duration_;\n\n  // Disallow copy and assign\n  TraceObject(const TraceObject&) = delete;\n  void operator=(const TraceObject&) = delete;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TraceWriter\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Abstract base class for writing trace events to a destination.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"TraceObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_PLATFORM_EXPORT TraceWriter {\n public:\n  TraceWriter() = default;\n  virtual ~TraceWriter() = default;\n  virtual void AppendTraceEvent(TraceObject* trace_event) = 0;\n  virtual void Flush() = 0;\n\n  static TraceWriter* CreateJSONTraceWriter(std::ostream& stream);\n  static TraceWriter* CreateJSONTraceWriter(std::ostream& stream,\n                                            const std::string& tag);\n\n  static TraceWriter* CreateSystemInstrumentationTraceWriter();\n\n private:\n  // Disallow copy and assign\n  TraceWriter(const TraceWriter&) = delete;\n  void operator=(const TraceWriter&) = delete;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TraceBufferChunk\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Represents a chunk of the trace buffer.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"next_free_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Index of the next free slot in the chunk.\"\n                    },\n                    {\n                        \"name\": \"chunk_\",\n                        \"type\": \"TraceObject*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of trace objects in the chunk.\"\n                    },\n                    {\n                        \"name\": \"seq_\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Sequence number of the chunk.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"TraceObject\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_PLATFORM_EXPORT TraceBufferChunk {\n public:\n  explicit TraceBufferChunk(uint32_t seq);\n\n  void Reset(uint32_t new_seq);\n  bool IsFull() const { return next_free_ == kChunkSize; }\n  TraceObject* AddTraceEvent(size_t* event_index);\n  TraceObject* GetEventAt(size_t index) { return &chunk_[index]; }\n\n  uint32_t seq() const { return seq_; }\n  size_t size() const { return next_free_; }\n\n  static const size_t kChunkSize = 64;\n\n private:\n  size_t next_free_ = 0;\n  TraceObject chunk_[kChunkSize];\n  uint32_t seq_;\n\n  // Disallow copy and assign\n  TraceBufferChunk(const TraceBufferChunk&) = delete;\n  void operator=(const TraceBufferChunk&) = delete;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TraceBuffer\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Abstract base class for a trace buffer.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"TraceObject\",\n                    \"TraceWriter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass V8_PLATFORM_EXPORT TraceBuffer {\n public:\n  TraceBuffer() = default;\n  virtual ~TraceBuffer() = default;\n\n  virtual TraceObject* AddTraceEvent(uint64_t* handle) = 0;\n  virtual TraceObject* GetEventByHandle(uint64_t handle) = 0;\n  virtual bool Flush() = 0;\n\n  static const size_t kRingBufferChunks = 1024;\n\n  static TraceBuffer* CreateTraceBufferRingBuffer(size_t max_chunks,\n                                                  TraceWriter* trace_writer);\n\n private:\n  // Disallow copy and assign\n  TraceBuffer(const TraceBuffer&) = delete;\n  void operator=(const TraceBuffer&) = delete;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TraceConfig\",\n                \"extends\": null,\n                \"implements\": [],\n                \"about\": \"Configuration for tracing.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"record_mode_\",\n                        \"type\": \"TraceRecordMode\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Specifies the recording mode.\"\n                    },\n                    {\n                        \"name\": \"enable_systrace_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether systrace is enabled.\"\n                    },\n                    {\n                        \"name\": \"enable_argument_filter_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether argument filtering is enabled.\"\n                    },\n                    {\n                        \"name\": \"included_categories_\",\n                        \"type\": \"StringList\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of included category names.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n// Options determines how the trace buffer stores data.\nenum TraceRecordMode {\n  // Record until the trace buffer is full.\n  RECORD_UNTIL_FULL,\n\n  // Record until the user ends the trace. The trace buffer is a fixed size\n  // and we use it as a ring buffer during recording.\n  RECORD_CONTINUOUSLY,\n\n  // Record until the trace buffer is full, but with a huge buffer size.\n  RECORD_AS_MUCH_AS_POSSIBLE,\n\n  // Echo to console. Events are discarded.\n  ECHO_TO_CONSOLE,\n};\n\nclass V8_PLATFORM_EXPORT TraceConfig {\n public:\n  typedef std::vector<std::string> StringList;\n\n  static TraceConfig* CreateDefaultTraceConfig();\n\n  TraceConfig() : enable_systrace_(false), enable_argument_filter_(false) {}\n  TraceRecordMode GetTraceRecordMode() const { return record_mode_; }\n  const StringList& GetEnabledCategories() const {\n    return included_categories_;\n  }\n  bool IsSystraceEnabled() const { return enable_systrace_; }\n  bool IsArgumentFilterEnabled() const { return enable_argument_filter_; }\n\n  void SetTraceRecordMode(TraceRecordMode mode) { record_mode_ = mode; }\n  void EnableSystrace() { enable_systrace_ = true; }\n  void EnableArgumentFilter() { enable_argument_filter_ = true; }\n\n  void AddIncludedCategory(const char* included_category);\n\n  bool IsCategoryGroupEnabled(const char* category_group) const;\n\n private:\n  TraceRecordMode record_mode_;\n  bool enable_systrace_ : 1;\n  bool enable_argument_filter_ : 1;\n  StringList included_categories_;\n\n  // Disallow copy and assign\n  TraceConfig(const TraceConfig&) = delete;\n  void operator=(const TraceConfig&) = delete;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TracingController\",\n                \"extends\": \"v8::TracingController\",\n                \"implements\": [],\n                \"about\": \"Controls the tracing process, including starting, stopping, and managing trace events.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"mutex_\",\n                        \"type\": \"std::unique_ptr<base::Mutex>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Mutex for thread safety.\"\n                    },\n                    {\n                        \"name\": \"trace_config_\",\n                        \"type\": \"std::unique_ptr<TraceConfig>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Current trace configuration.\"\n                    },\n                    {\n                        \"name\": \"recording_\",\n                        \"type\": \"std::atomic_bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Atomic boolean indicating whether tracing is in progress.\"\n                    },\n                    {\n                        \"name\": \"output_stream_\",\n                        \"type\": \"std::ostream*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Output stream for trace data (Perfetto).\"\n                    },\n                    {\n                        \"name\": \"trace_processor_\",\n                        \"type\": \"std::unique_ptr<perfetto::trace_processor::TraceProcessorStorage>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Trace processor storage (Perfetto).\"\n                    },\n                    {\n                        \"name\": \"listener_for_testing_\",\n                        \"type\": \"TraceEventListener*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Trace event listener for testing (Perfetto).\"\n                    },\n                    {\n                        \"name\": \"tracing_session_\",\n                        \"type\": \"std::unique_ptr<perfetto::TracingSession>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracing session object (Perfetto).\"\n                    },\n                    {\n                        \"name\": \"observers_\",\n                        \"type\": \"std::unordered_set<v8::TracingController::TraceStateObserver*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of trace state observers.\"\n                    },\n                    {\n                        \"name\": \"trace_buffer_\",\n                        \"type\": \"std::unique_ptr<TraceBuffer>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Trace buffer for storing trace events.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"v8::TracingController\",\n                    \"base::Mutex\",\n                    \"TraceConfig\",\n                    \"perfetto::trace_processor::TraceProcessorStorage\",\n                    \"TraceEventListener\",\n                    \"perfetto::TracingSession\",\n                    \"TraceBuffer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#if defined(_MSC_VER)\n#define V8_PLATFORM_NON_EXPORTED_BASE(code) \\\n  __pragma(warning(suppress : 4275)) code\n#else\n#define V8_PLATFORM_NON_EXPORTED_BASE(code) code\n#endif  // defined(_MSC_VER)\n\nclass V8_PLATFORM_EXPORT TracingController\n    : public V8_PLATFORM_NON_EXPORTED_BASE(v8::TracingController) {\n public:\n  TracingController();\n  ~TracingController() override;\n\n#if defined(V8_USE_PERFETTO)\n  // Must be called before StartTracing() if V8_USE_PERFETTO is true. Provides\n  // the output stream for the JSON trace data.\n  void InitializeForPerfetto(std::ostream* output_stream);\n  // Provide an optional listener for testing that will receive trace events.\n  // Must be called before StartTracing().\n  void SetTraceEventListenerForTesting(TraceEventListener* listener);\n#else   // defined(V8_USE_PERFETTO)\n  // The pointer returned from GetCategoryGroupEnabled() points to a value with\n  // zero or more of the following bits. Used in this class only. The\n  // TRACE_EVENT macros should only use the value as a bool. These values must\n  // be in sync with macro values in TraceEvent.h in Blink.\n  enum CategoryGroupEnabledFlags {\n    // Category group enabled for the recording mode.\n    ENABLED_FOR_RECORDING = 1 << 0,\n    // Category group enabled by SetEventCallbackEnabled().\n    ENABLED_FOR_EVENT_CALLBACK = 1 << 2,\n    // Category group enabled to export events to ETW.\n    ENABLED_FOR_ETW_EXPORT = 1 << 3\n  };\n\n  // Takes ownership of |trace_buffer|.\n  void Initialize(TraceBuffer* trace_buffer);\n\n  // v8::TracingController implementation.\n  const uint8_t* GetCategoryGroupEnabled(const char* category_group) override;\n  uint64_t AddTraceEvent(\n      char phase, const uint8_t* category_enabled_flag, const char* name,\n      const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,\n      const char** arg_names, const uint8_t* arg_types,\n      const uint64_t* arg_values,\n      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,\n      unsigned int flags) override;\n  uint64_t AddTraceEventWithTimestamp(\n      char phase, const uint8_t* category_enabled_flag, const char* name,\n      const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,\n      const char** arg_names, const uint8_t* arg_types,\n      const uint64_t* arg_values,\n      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,\n      unsigned int flags, int64_t timestamp) override;\n  void UpdateTraceEventDuration(const uint8_t* category_enabled_flag,\n                                const char* name, uint64_t handle) override;\n\n  static const char* GetCategoryGroupName(const uint8_t* category_enabled_flag);\n\n  void AddTraceStateObserver(\n      v8::TracingController::TraceStateObserver* observer) override;\n  void RemoveTraceStateObserver(\n      v8::TracingController::TraceStateObserver* observer) override;\n#endif  // !defined(V8_USE_PERFETTO)\n\n  void StartTracing(TraceConfig* trace_config);\n  void StopTracing();\n\n protected:\n#if !defined(V8_USE_PERFETTO)\n  virtual int64_t CurrentTimestampMicroseconds();\n  virtual int64_t CurrentCpuTimestampMicroseconds();\n#endif  // !defined(V8_USE_PERFETTO)\n\n private:\n#if !defined(V8_USE_PERFETTO)\n  void UpdateCategoryGroupEnabledFlag(size_t category_index);\n  void UpdateCategoryGroupEnabledFlags();\n#endif  // !defined(V8_USE_PERFETTO)\n\n  std::unique_ptr<base::Mutex> mutex_;\n  std::unique_ptr<TraceConfig> trace_config_;\n  std::atomic_bool recording_{false};\n\n#if defined(V8_USE_PERFETTO)\n  std::ostream* output_stream_ = nullptr;\n  std::unique_ptr<perfetto::trace_processor::TraceProcessorStorage>\n      trace_processor_;\n  TraceEventListener* listener_for_testing_ = nullptr;\n  std::unique_ptr<perfetto::TracingSession> tracing_session_;\n#else   // !defined(V8_USE_PERFETTO)\n  std::unordered_set<v8::TracingController::TraceStateObserver*> observers_;\n  std::unique_ptr<TraceBuffer> trace_buffer_;\n#endif  // !defined(V8_USE_PERFETTO)\n\n  // Disallow copy and assign\n  TracingController(const TracingController&) = delete;\n  void operator=(const TracingController&) = delete;\n};\n\n#undef V8_PLATFORM_NON_EXPORTED_BASE\n        ]]></code>\n    </class>\n</file>\n```"
}