{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8-platforms.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 64, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/d8/d8-platforms.cc\",\n        \"file_name\": \"d8-platforms.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides custom Platform implementations for the d8 command-line tool, specifically for predictable and delayed task execution.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for platform abstraction, memory management, threading, and other utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/d8/d8-platforms.h\"\n\n#include <memory>\n#include <unordered_map>\n\n#include \"include/libplatform/libplatform.h\"\n#include \"include/v8-platform.h\"\n#include \"src/base/logging.h\"\n#include \"src/base/macros.h\"\n#include \"src/base/platform/mutex.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/base/platform/time.h\"\n#include \"src/base/utils/random-number-generator.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PredictablePlatform\",\n            \"extends\": \"Platform\",\n            \"about\": \"A Platform implementation that forces all tasks to execute on the main thread in a predictable order.  Useful for testing.\",\n            \"attributes\": [\n                {\n                    \"name\": \"synthetic_time_\",\n                    \"type\": \"std::atomic<uint64_t>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A monotonically increasing time value, used to simulate time in predictable mode.\"\n                },\n                {\n                    \"name\": \"platform_\",\n                    \"type\": \"std::unique_ptr<Platform>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying platform to which calls are delegated.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Platform\",\n                \"Task\",\n                \"TaskRunner\",\n                \"Isolate\",\n                \"SourceLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass PredictablePlatform final : public Platform {\n public:\n  explicit PredictablePlatform(std::unique_ptr<Platform> platform)\n      : platform_(std::move(platform)) {\n    DCHECK_NOT_NULL(platform_);\n  }\n\n  PredictablePlatform(const PredictablePlatform&) = delete;\n  PredictablePlatform& operator=(const PredictablePlatform&) = delete;\n\n  PageAllocator* GetPageAllocator() override {\n    return platform_->GetPageAllocator();\n  }\n\n  void OnCriticalMemoryPressure() override {\n    platform_->OnCriticalMemoryPressure();\n  }\n\n  std::shared_ptr<TaskRunner> GetForegroundTaskRunner(\n      v8::Isolate* isolate, TaskPriority priority) override {\n    return platform_->GetForegroundTaskRunner(isolate, priority);\n  }\n\n  int NumberOfWorkerThreads() override {\n    // The predictable platform executes everything on the main thread, but we\n    // still pretend to have the default number of worker threads to not\n    // unnecessarily change behaviour of the platform.\n    return platform_->NumberOfWorkerThreads();\n  }\n\n  void PostTaskOnWorkerThreadImpl(TaskPriority priority,\n                                  std::unique_ptr<Task> task,\n                                  const SourceLocation& location) override {\n    // We post worker tasks on the foreground task runner of the\n    // {kProcessGlobalPredictablePlatformWorkerTaskQueue} isolate. The task\n    // queue of the {kProcessGlobalPredictablePlatformWorkerTaskQueue} isolate\n    // is then executed on the main thread to achieve predictable behavior.\n    //\n    // In this context here it is okay to call {GetForegroundTaskRunner} from a\n    // background thread. The reason is that code is executed sequentially with\n    // the PredictablePlatform, and that the {DefaultPlatform} does not access\n    // the isolate but only uses it as the key in a HashMap.\n    platform_\n        ->GetForegroundTaskRunner(\n            kProcessGlobalPredictablePlatformWorkerTaskQueue, priority)\n        ->PostTask(std::move(task));\n  }\n\n  void PostDelayedTaskOnWorkerThreadImpl(\n      TaskPriority priority, std::unique_ptr<Task> task,\n      double delay_in_seconds, const SourceLocation& location) override {\n    // Never run delayed tasks.\n  }\n\n  bool IdleTasksEnabled(Isolate* isolate) override { return false; }\n\n  std::unique_ptr<JobHandle> CreateJobImpl(\n      TaskPriority priority, std::unique_ptr<JobTask> job_task,\n      const SourceLocation& location) override {\n    // Do not call {platform_->PostJob} here, as this would create a job that\n    // posts tasks directly to the underlying default platform.\n    return platform::NewDefaultJobHandle(this, priority, std::move(job_task),\n                                         NumberOfWorkerThreads());\n  }\n\n  double MonotonicallyIncreasingTime() override {\n    // In predictable mode, there should be no (observable) concurrency, but we\n    // still run some tests that explicitly specify '--predictable' in the\n    // '--isolates' variant, where several threads run the same test in\n    // different isolates. To avoid TSan issues in that scenario we use atomic\n    // increments here.\n    uint64_t synthetic_time =\n        synthetic_time_.fetch_add(1, std::memory_order_relaxed);\n    return 1e-5 * synthetic_time;\n  }\n\n  double CurrentClockTimeMillis() override {\n    return MonotonicallyIncreasingTime() * base::Time::kMillisecondsPerSecond;\n  }\n\n  v8::TracingController* GetTracingController() override {\n    return platform_->GetTracingController();\n  }\n\n  Platform* platform() const { return platform_.get(); }\n\n private:\n  std::atomic<uint64_t> synthetic_time_{0};\n  std::unique_ptr<Platform> platform_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MakePredictablePlatform\",\n            \"about\": \"Creates a new PredictablePlatform instance.\",\n            \"logic\": \"Wraps an existing Platform in a PredictablePlatform.\",\n            \"parameters\": [\n                {\n                    \"name\": \"platform\",\n                    \"type\": \"std::unique_ptr<Platform>\",\n                    \"purpose\": \"The platform to wrap.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<Platform>\",\n                \"description\": \"A unique pointer to the new PredictablePlatform.\"\n            },\n            \"dependencies\": [\n                \"PredictablePlatform\",\n                \"Platform\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<Platform> MakePredictablePlatform(\n    std::unique_ptr<Platform> platform) {\n  return std::make_unique<PredictablePlatform>(std::move(platform));\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DelayedTasksPlatform\",\n            \"extends\": \"Platform\",\n            \"about\": \"A Platform implementation that introduces random delays into task execution, simulating real-world conditions.  Useful for stress testing.\",\n            \"attributes\": [\n                {\n                    \"name\": \"platform_\",\n                    \"type\": \"std::unique_ptr<Platform>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying platform to which calls are delegated.\"\n                },\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Protects the RNG and the delayed_task_runners_ map from concurrent access.\"\n                },\n                {\n                    \"name\": \"rng_\",\n                    \"type\": \"base::RandomNumberGenerator\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A random number generator used to determine the delay for each task.\"\n                },\n                {\n                    \"name\": \"delayed_task_runners_\",\n                    \"type\": \"std::unordered_map<TaskRunner*, std::weak_ptr<DelayedTaskRunner>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A map of TaskRunners to their DelayedTaskRunner wrappers.  Uses weak pointers to avoid memory leaks.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Platform\",\n                \"Task\",\n                \"TaskRunner\",\n                \"Isolate\",\n                \"Mutex\",\n                \"RandomNumberGenerator\",\n                \"DelayedTaskRunner\",\n                \"DelayedTask\",\n                \"DelayedIdleTask\",\n                \"JobTask\",\n                \"DelayedJob\",\n                \"SourceLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass DelayedTasksPlatform final : public Platform {\n public:\n  explicit DelayedTasksPlatform(std::unique_ptr<Platform> platform)\n      : platform_(std::move(platform)) {\n    DCHECK_NOT_NULL(platform_);\n  }\n\n  explicit DelayedTasksPlatform(std::unique_ptr<Platform> platform,\n                                int64_t random_seed)\n      : platform_(std::move(platform)), rng_(random_seed) {\n    DCHECK_NOT_NULL(platform_);\n  }\n\n  DelayedTasksPlatform(const DelayedTasksPlatform&) = delete;\n  DelayedTasksPlatform& operator=(const DelayedTasksPlatform&) = delete;\n\n  ~DelayedTasksPlatform() override {\n    // When the platform shuts down, all task runners must be freed.\n    DCHECK_EQ(0, delayed_task_runners_.size());\n  }\n\n  PageAllocator* GetPageAllocator() override {\n    return platform_->GetPageAllocator();\n  }\n\n  void OnCriticalMemoryPressure() override {\n    platform_->OnCriticalMemoryPressure();\n  }\n\n  std::shared_ptr<TaskRunner> GetForegroundTaskRunner(\n      v8::Isolate* isolate, TaskPriority priority) override {\n    std::shared_ptr<TaskRunner> runner =\n        platform_->GetForegroundTaskRunner(isolate, priority);\n\n    base::MutexGuard lock_guard(&mutex_);\n    // Check if we can re-materialize the weak ptr in our map.\n    std::weak_ptr<DelayedTaskRunner>& weak_delayed_runner =\n        delayed_task_runners_[runner.get()];\n    std::shared_ptr<DelayedTaskRunner> delayed_runner =\n        weak_delayed_runner.lock();\n\n    if (!delayed_runner) {\n      // Create a new {DelayedTaskRunner} and keep a weak reference in our map.\n      delayed_runner = std::make_shared<DelayedTaskRunner>(runner, this);\n      weak_delayed_runner = delayed_runner;\n    }\n\n    return std::move(delayed_runner);\n  }\n\n  int NumberOfWorkerThreads() override {\n    return platform_->NumberOfWorkerThreads();\n  }\n\n  void PostTaskOnWorkerThreadImpl(TaskPriority priority,\n                                  std::unique_ptr<Task> task,\n                                  const SourceLocation& location) override {\n    platform_->PostTaskOnWorkerThread(\n        priority, MakeDelayedTask(std::move(task)), location);\n  }\n\n  void PostDelayedTaskOnWorkerThreadImpl(\n      TaskPriority priority, std::unique_ptr<Task> task,\n      double delay_in_seconds, const SourceLocation& location) override {\n    platform_->PostDelayedTaskOnWorkerThread(\n        priority, MakeDelayedTask(std::move(task)), delay_in_seconds, location);\n  }\n\n  bool IdleTasksEnabled(Isolate* isolate) override {\n    return platform_->IdleTasksEnabled(isolate);\n  }\n\n  std::unique_ptr<JobHandle> CreateJobImpl(\n      TaskPriority priority, std::unique_ptr<JobTask> job_task,\n      const SourceLocation& location) override {\n    return platform_->CreateJob(priority, MakeDelayedJob(std::move(job_task)),\n                                location);\n  }\n\n  double MonotonicallyIncreasingTime() override {\n    return platform_->MonotonicallyIncreasingTime();\n  }\n\n  double CurrentClockTimeMillis() override {\n    return platform_->CurrentClockTimeMillis();\n  }\n\n  v8::TracingController* GetTracingController() override {\n    return platform_->GetTracingController();\n  }\n\n private:\n  class DelayedTaskRunner final : public TaskRunner {\n   public:\n    DelayedTaskRunner(std::shared_ptr<TaskRunner> task_runner,\n                      DelayedTasksPlatform* platform)\n        : task_runner_(task_runner), platform_(platform) {}\n\n    ~DelayedTaskRunner() {\n      TaskRunner* original_runner = task_runner_.get();\n      base::MutexGuard lock_guard(&platform_->mutex_);\n      auto& delayed_task_runners = platform_->delayed_task_runners_;\n      DCHECK_EQ(1, delayed_task_runners.count(original_runner));\n      delayed_task_runners.erase(original_runner);\n    }\n\n    bool IdleTasksEnabled() final { return task_runner_->IdleTasksEnabled(); }\n\n    bool NonNestableTasksEnabled() const final {\n      return task_runner_->NonNestableTasksEnabled();\n    }\n\n   private:\n    void PostTaskImpl(std::unique_ptr<Task> task,\n                      const SourceLocation& location) final {\n      task_runner_->PostTask(platform_->MakeDelayedTask(std::move(task)),\n                             location);\n    }\n\n    void PostNonNestableTaskImpl(std::unique_ptr<Task> task,\n                                 const SourceLocation& location) final {\n      task_runner_->PostNonNestableTask(\n          platform_->MakeDelayedTask(std::move(task)), location);\n    }\n\n    void PostDelayedTaskImpl(std::unique_ptr<Task> task,\n                             double delay_in_seconds,\n                             const SourceLocation& location) final {\n      task_runner_->PostDelayedTask(platform_->MakeDelayedTask(std::move(task)),\n                                    delay_in_seconds, location);\n    }\n\n    void PostIdleTaskImpl(std::unique_ptr<IdleTask> task,\n                          const SourceLocation& location) final {\n      task_runner_->PostIdleTask(\n          platform_->MakeDelayedIdleTask(std::move(task)), location);\n    }\n\n   private:\n    std::shared_ptr<TaskRunner> task_runner_;\n    DelayedTasksPlatform* platform_;\n  };\n\n  class DelayedTask final : public Task {\n   public:\n    DelayedTask(std::unique_ptr<Task> task, int32_t delay_ms)\n        : task_(std::move(task)), delay_ms_(delay_ms) {}\n\n    void Run() override {\n      base::OS::Sleep(base::TimeDelta::FromMicroseconds(delay_ms_));\n      task_->Run();\n    }\n\n   private:\n    std::unique_ptr<Task> task_;\n    int32_t delay_ms_;\n  };\n\n  class DelayedIdleTask final : public IdleTask {\n   public:\n    DelayedIdleTask(std::unique_ptr<IdleTask> task, int32_t delay_ms)\n        : task_(std::move(task)), delay_ms_(delay_ms) {}\n\n    void Run(double deadline_in_seconds) override {\n      base::OS::Sleep(base::TimeDelta::FromMicroseconds(delay_ms_));\n      task_->Run(deadline_in_seconds);\n    }\n\n   private:\n    std::unique_ptr<IdleTask> task_;\n    int32_t delay_ms_;\n  };\n\n  class DelayedJob final : public JobTask {\n   public:\n    DelayedJob(std::unique_ptr<JobTask> job_task, int32_t delay_ms)\n        : job_task_(std::move(job_task)), delay_ms_(delay_ms) {}\n\n    void Run(JobDelegate* delegate) override {\n      // If this job is being executed via worker tasks (as e.g. the\n      // {DefaultJobHandle} implementation does it), the worker task would\n      // already include a delay. In order to not depend on that, we add our own\n      // delay here anyway.\n      base::OS::Sleep(base::TimeDelta::FromMicroseconds(delay_ms_));\n      job_task_->Run(delegate);\n    }\n\n    size_t GetMaxConcurrency(size_t worker_count) const override {\n      return job_task_->GetMaxConcurrency(worker_count);\n    }\n\n   private:\n    std::unique_ptr<JobTask> job_task_;\n    int32_t delay_ms_;\n  };\n\n  std::unique_ptr<Platform> platform_;\n\n  // The Mutex protects the RNG, which is used by foreground and background\n  // threads, and the {delayed_task_runners_} map might be accessed concurrently\n  // by the shared_ptr destructor.\n  base::Mutex mutex_;\n  base::RandomNumberGenerator rng_;\n  std::unordered_map<TaskRunner*, std::weak_ptr<DelayedTaskRunner>>\n      delayed_task_runners_;\n\n  int32_t GetRandomDelayInMilliseconds() {\n    base::MutexGuard lock_guard(&mutex_);\n    double delay_fraction = rng_.NextDouble();\n    // Sleep up to 100ms (100000us). Square {delay_fraction} to shift\n    // distribution towards shorter sleeps.\n    return 1e5 * (delay_fraction * delay_fraction);\n  }\n\n  std::unique_ptr<Task> MakeDelayedTask(std::unique_ptr<Task> task) {\n    return std::make_unique<DelayedTask>(std::move(task),\n                                         GetRandomDelayInMilliseconds());\n  }\n\n  std::unique_ptr<IdleTask> MakeDelayedIdleTask(\n      std::unique_ptr<IdleTask> task) {\n    return std::make_unique<DelayedIdleTask>(std::move(task),\n                                             GetRandomDelayInMilliseconds());\n  }\n\n  std::unique_ptr<JobTask> MakeDelayedJob(std::unique_ptr<JobTask> task) {\n    return std::make_unique<DelayedJob>(std::move(task),\n                                        GetRandomDelayInMilliseconds());\n  }\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MakeDelayedTasksPlatform\",\n            \"about\": \"Creates a new DelayedTasksPlatform instance.\",\n            \"logic\": \"Wraps an existing Platform in a DelayedTasksPlatform.  Optionally takes a random seed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"platform\",\n                    \"type\": \"std::unique_ptr<Platform>\",\n                    \"purpose\": \"The platform to wrap.\"\n                },\n                {\n                    \"name\": \"random_seed\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"An optional random seed to initialize the RNG with.  If zero, the RNG is seeded with a non-deterministic value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<Platform>\",\n                \"description\": \"A unique pointer to the new DelayedTasksPlatform.\"\n            },\n            \"dependencies\": [\n                \"DelayedTasksPlatform\",\n                \"Platform\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<Platform> MakeDelayedTasksPlatform(\n    std::unique_ptr<Platform> platform, int64_t random_seed) {\n  if (random_seed) {\n    return std::make_unique<DelayedTasksPlatform>(std::move(platform),\n                                                  random_seed);\n  }\n  return std::make_unique<DelayedTasksPlatform>(std::move(platform));\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DelayedTaskRunner\",\n            \"about\": \"Wraps a TaskRunner and adds random delays to all tasks posted to it.\",\n            \"attributes\": [\n                {\n                    \"name\": \"task_runner_\",\n                    \"type\": \"std::shared_ptr<TaskRunner>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying TaskRunner to which tasks are delegated.\"\n                },\n                {\n                    \"name\": \"platform_\",\n                    \"type\": \"DelayedTasksPlatform*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A pointer to the DelayedTasksPlatform that created this DelayedTaskRunner.  Used to access the RNG and mutex.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TaskRunner\",\n                \"Task\",\n                \"DelayedTasksPlatform\",\n                \"SourceLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class DelayedTaskRunner final : public TaskRunner {\n   public:\n    DelayedTaskRunner(std::shared_ptr<TaskRunner> task_runner,\n                      DelayedTasksPlatform* platform)\n        : task_runner_(task_runner), platform_(platform) {}\n\n    ~DelayedTaskRunner() {\n      TaskRunner* original_runner = task_runner_.get();\n      base::MutexGuard lock_guard(&platform_->mutex_);\n      auto& delayed_task_runners = platform_->delayed_task_runners_;\n      DCHECK_EQ(1, delayed_task_runners.count(original_runner));\n      delayed_task_runners.erase(original_runner);\n    }\n\n    bool IdleTasksEnabled() final { return task_runner_->IdleTasksEnabled(); }\n\n    bool NonNestableTasksEnabled() const final {\n      return task_runner_->NonNestableTasksEnabled();\n    }\n\n   private:\n    void PostTaskImpl(std::unique_ptr<Task> task,\n                      const SourceLocation& location) final {\n      task_runner_->PostTask(platform_->MakeDelayedTask(std::move(task)),\n                             location);\n    }\n\n    void PostNonNestableTaskImpl(std::unique_ptr<Task> task,\n                                 const SourceLocation& location) final {\n      task_runner_->PostNonNestableTask(\n          platform_->MakeDelayedTask(std::move(task)), location);\n    }\n\n    void PostDelayedTaskImpl(std::unique_ptr<Task> task,\n                             double delay_in_seconds,\n                             const SourceLocation& location) final {\n      task_runner_->PostDelayedTask(platform_->MakeDelayedTask(std::move(task)),\n                                    delay_in_seconds, location);\n    }\n\n    void PostIdleTaskImpl(std::unique_ptr<IdleTask> task,\n                          const SourceLocation& location) final {\n      task_runner_->PostIdleTask(\n          platform_->MakeDelayedIdleTask(std::move(task)), location);\n    }\n\n   private:\n    std::shared_ptr<TaskRunner> task_runner_;\n    DelayedTasksPlatform* platform_;\n  };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DelayedTask\",\n            \"about\": \"Wraps a Task and adds a random delay before running it.\",\n            \"attributes\": [\n                {\n                    \"name\": \"task_\",\n                    \"type\": \"std::unique_ptr<Task>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying Task to run.\"\n                },\n                {\n                    \"name\": \"delay_ms_\",\n                    \"type\": \"int32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The delay in milliseconds to wait before running the task.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Task\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class DelayedTask final : public Task {\n   public:\n    DelayedTask(std::unique_ptr<Task> task, int32_t delay_ms)\n        : task_(std::move(task)), delay_ms_(delay_ms) {}\n\n    void Run() override {\n      base::OS::Sleep(base::TimeDelta::FromMicroseconds(delay_ms_));\n      task_->Run();\n    }\n\n   private:\n    std::unique_ptr<Task> task_;\n    int32_t delay_ms_;\n  };\n        ]]></code>\n    </class>\n\n        <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DelayedIdleTask\",\n            \"about\": \"Wraps an IdleTask and adds a random delay before running it.\",\n            \"attributes\": [\n                {\n                    \"name\": \"task_\",\n                    \"type\": \"std::unique_ptr<IdleTask>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying IdleTask to run.\"\n                },\n                {\n                    \"name\": \"delay_ms_\",\n                    \"type\": \"int32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The delay in milliseconds to wait before running the task.\"\n                }\n            ],\n            \"dependencies\": [\n                \"IdleTask\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class DelayedIdleTask final : public IdleTask {\n   public:\n    DelayedIdleTask(std::unique_ptr<IdleTask> task, int32_t delay_ms)\n        : task_(std::move(task)), delay_ms_(delay_ms) {}\n\n    void Run(double deadline_in_seconds) override {\n      base::OS::Sleep(base::TimeDelta::FromMicroseconds(delay_ms_));\n      task_->Run(deadline_in_seconds);\n    }\n\n   private:\n    std::unique_ptr<IdleTask> task_;\n    int32_t delay_ms_;\n  };\n        ]]></code>\n    </class>\n\n        <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DelayedJob\",\n            \"about\": \"Wraps a JobTask and adds a random delay before running it.\",\n            \"attributes\": [\n                {\n                    \"name\": \"job_task_\",\n                    \"type\": \"std::unique_ptr<JobTask>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The underlying JobTask to run.\"\n                },\n                {\n                    \"name\": \"delay_ms_\",\n                    \"type\": \"int32_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The delay in milliseconds to wait before running the job.\"\n                }\n            ],\n            \"dependencies\": [\n                \"JobTask\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  class DelayedJob final : public JobTask {\n   public:\n    DelayedJob(std::unique_ptr<JobTask> job_task, int32_t delay_ms)\n        : job_task_(std::move(job_task)), delay_ms_(delay_ms) {}\n\n    void Run(JobDelegate* delegate) override {\n      // If this job is being executed via worker tasks (as e.g. the\n      // {DefaultJobHandle} implementation does it), the worker task would\n      // already include a delay. In order to not depend on that, we add our own\n      // delay here anyway.\n      base::OS::Sleep(base::TimeDelta::FromMicroseconds(delay_ms_));\n      job_task_->Run(delegate);\n    }\n\n    size_t GetMaxConcurrency(size_t worker_count) const override {\n      return job_task_->GetMaxConcurrency(worker_count);\n    }\n\n   private:\n    std::unique_ptr<JobTask> job_task_;\n    int32_t delay_ms_;\n  };\n        ]]></code>\n    </class>\n</file>\n```"
}