{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/startup-serializer.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 47, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/startup-serializer.cc\",\n            \"file_name\": \"startup-serializer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the StartupSerializer class for creating snapshots of the V8 heap at startup.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for serialization, heap management, object handling, and other V8 internals.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/startup-serializer.h\"\n\n#include \"src/execution/v8threads.h\"\n#include \"src/handles/global-handles-inl.h\"\n#include \"src/heap/heap-inl.h\"\n#include \"src/heap/read-only-heap.h\"\n#include \"src/objects/contexts.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/slots.h\"\n#include \"src/snapshot/read-only-serializer.h\"\n#include \"src/snapshot/shared-heap-serializer.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SanitizeIsolateScope\",\n                \"about\": \"Temporarily removes context-specific objects from the isolate roots during serialization.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Heap\",\n                    \"ReadOnlyRoots\",\n                    \"Tagged<Object>\",\n                    \"Tagged<WeakArrayList>\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\n// The isolate roots may not point at context-specific objects during\n// serialization.\nclass V8_NODISCARD SanitizeIsolateScope final {\n public:\n  SanitizeIsolateScope(Isolate* isolate, bool allow_active_isolate_for_testing,\n                       const DisallowGarbageCollection& no_gc)\n      : isolate_(isolate),\n        feedback_vectors_for_profiling_tools_(\n            isolate->heap()->feedback_vectors_for_profiling_tools()),\n        detached_contexts_(isolate->heap()->detached_contexts()) {\n#ifdef DEBUG\n    if (!allow_active_isolate_for_testing) {\n      // These should already be empty when creating a real snapshot.\n      DCHECK_EQ(feedback_vectors_for_profiling_tools_,\n                ReadOnlyRoots(isolate).undefined_value());\n      DCHECK_EQ(detached_contexts_,\n                ReadOnlyRoots(isolate).empty_weak_array_list());\n    }\n#endif\n\n    isolate->SetFeedbackVectorsForProfilingTools(\n        ReadOnlyRoots(isolate).undefined_value());\n    isolate->heap()->SetDetachedContexts(\n        ReadOnlyRoots(isolate).empty_weak_array_list());\n  }\n\n  ~SanitizeIsolateScope() {\n    // Restore saved fields.\n    isolate_->SetFeedbackVectorsForProfilingTools(\n        feedback_vectors_for_profiling_tools_);\n    isolate_->heap()->SetDetachedContexts(detached_contexts_);\n  }\n\n private:\n  Isolate* isolate_;\n  const Tagged<Object> feedback_vectors_for_profiling_tools_;\n  const Tagged<WeakArrayList> detached_contexts_;\n};\n\n}  // namespace\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"StartupSerializer\",\n                \"about\": \"Serializes the V8 heap at startup to create a snapshot.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Snapshot::SerializerFlags\",\n                    \"SharedHeapSerializer\",\n                    \"RootsSerializer\",\n                    \"ExternalReferenceTable\",\n                    \"ExternalReferenceEncoder\",\n                    \"Handle\",\n                    \"HeapObject\",\n                    \"AccessorInfo\",\n                    \"FunctionTemplateInfo\",\n                    \"Script\",\n                    \"SharedFunctionInfo\",\n                    \"ReadOnlyHeap\",\n                    \"ObjectSerializer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nStartupSerializer::StartupSerializer(\n    Isolate* isolate, Snapshot::SerializerFlags flags,\n    SharedHeapSerializer* shared_heap_serializer)\n    : RootsSerializer(isolate, flags, RootIndex::kFirstStrongRoot),\n      shared_heap_serializer_(shared_heap_serializer),\n      accessor_infos_(isolate->heap()),\n      function_template_infos_(isolate->heap()) {\n  InitializeCodeAddressMap();\n\n  // This serializes any external reference which don't encode to their own\n  // index. This is so that the deserializer can verify that any entries that\n  // were deduplicated during serialization are also deduplicated in the\n  // deserializing binary.\n  ExternalReferenceTable* table = isolate->external_reference_table();\n  for (uint32_t i = 0; i < ExternalReferenceTable::kSizeIsolateIndependent;\n       ++i) {\n    ExternalReferenceEncoder::Value encoded_reference =\n        EncodeExternalReference(table->address(i));\n    if (encoded_reference.index() != i) {\n      sink_.PutUint30(i, \"expected reference index\");\n      sink_.PutUint30(encoded_reference.index(), \"actual reference index\");\n    }\n  }\n  sink_.PutUint30(ExternalReferenceTable::kSizeIsolateIndependent,\n                  \"end of deduplicated reference indices\");\n}\n\nStartupSerializer::~StartupSerializer() {\n  for (DirectHandle<AccessorInfo> info : accessor_infos_) {\n    RestoreExternalReferenceRedirector(isolate(), *info);\n  }\n  for (DirectHandle<FunctionTemplateInfo> info : function_template_infos_) {\n    RestoreExternalReferenceRedirector(isolate(), *info);\n  }\n  OutputStatistics(\"StartupSerializer\");\n}\n\nvoid StartupSerializer::SerializeObjectImpl(Handle<HeapObject> obj,\n                                            SlotType slot_type) {\n  PtrComprCageBase cage_base(isolate());\n#ifdef DEBUG\n  if (IsJSFunction(*obj, cage_base)) {\n    v8::base::OS::PrintError(\"Reference stack:\\n\");\n    PrintStack(std::cerr);\n    Print(*obj, std::cerr);\n    FATAL(\n        \"JSFunction should be added through the context snapshot instead of \"\n        \"the isolate snapshot\");\n  }\n#endif  // DEBUG\n  {\n    DisallowGarbageCollection no_gc;\n    Tagged<HeapObject> raw = *obj;\n    DCHECK(!IsInstructionStream(raw));\n    if (SerializeHotObject(raw)) return;\n    if (IsRootAndHasBeenSerialized(raw) && SerializeRoot(raw)) return;\n  }\n\n  if (SerializeReadOnlyObjectReference(*obj, &sink_)) return;\n  if (SerializeUsingSharedHeapObjectCache(&sink_, obj)) return;\n  if (SerializeBackReference(*obj)) return;\n\n  if (USE_SIMULATOR_BOOL && IsAccessorInfo(*obj, cage_base)) {\n    // Wipe external reference redirects in the accessor info.\n    auto info = Cast<AccessorInfo>(obj);\n    info->remove_getter_redirection(isolate());\n    accessor_infos_.Push(*info);\n  } else if (USE_SIMULATOR_BOOL && IsFunctionTemplateInfo(*obj, cage_base)) {\n    auto info = Cast<FunctionTemplateInfo>(obj);\n    info->remove_callback_redirection(isolate());\n    function_template_infos_.Push(*info);\n  } else if (IsScript(*obj, cage_base) &&\n             Cast<Script>(obj)->IsUserJavaScript()) {\n    Cast<Script>(obj)->set_context_data(\n        ReadOnlyRoots(isolate()).uninitialized_symbol());\n  } else if (IsSharedFunctionInfo(*obj, cage_base)) {\n    // Clear inferred name for native functions.\n    auto shared = Cast<SharedFunctionInfo>(obj);\n    if (!shared->IsSubjectToDebugging() && shared->HasUncompiledData()) {\n      shared->uncompiled_data(isolate())->set_inferred_name(\n          ReadOnlyRoots(isolate()).empty_string());\n    }\n  }\n\n  CheckRehashability(*obj);\n\n  // Object has not yet been serialized.  Serialize it here.\n  DCHECK(!ReadOnlyHeap::Contains(*obj));\n  ObjectSerializer object_serializer(this, obj, &sink_);\n  object_serializer.Serialize(slot_type);\n}\n\nvoid StartupSerializer::SerializeWeakReferencesAndDeferred() {\n  // This comes right after serialization of the context snapshot, where we\n  // add entries to the startup object cache of the startup snapshot. Add\n  // one entry with 'undefined' to terminate the startup object cache.\n  Tagged<Object> undefined = ReadOnlyRoots(isolate()).undefined_value();\n  VisitRootPointer(Root::kStartupObjectCache, nullptr,\n                   FullObjectSlot(&undefined));\n\n  isolate()->heap()->IterateWeakRoots(\n      this, base::EnumSet<SkipRoot>{SkipRoot::kUnserializable});\n  SerializeDeferredObjects();\n  Pad();\n}\n\nvoid StartupSerializer::SerializeStrongReferences(\n    const DisallowGarbageCollection& no_gc) {\n  Isolate* isolate = this->isolate();\n  // No active threads.\n  CHECK_NULL(isolate->thread_manager()->FirstThreadStateInUse());\n\n  SanitizeIsolateScope sanitize_isolate(\n      isolate, allow_active_isolate_for_testing(), no_gc);\n\n  // Visit smi roots and immortal immovables first to make sure they end up in\n  // the first page.\n  isolate->heap()->IterateSmiRoots(this);\n  isolate->heap()->IterateRoots(\n      this, base::EnumSet<SkipRoot>{SkipRoot::kUnserializable, SkipRoot::kWeak,\n                                    SkipRoot::kTracedHandles});\n}\n\nbool StartupSerializer::SerializeUsingSharedHeapObjectCache(\n    SnapshotByteSink* sink, Handle<HeapObject> obj) {\n  return shared_heap_serializer_->SerializeUsingSharedHeapObjectCache(sink,\n                                                                      obj);\n}\n\nvoid StartupSerializer::SerializeUsingStartupObjectCache(\n    SnapshotByteSink* sink, Handle<HeapObject> obj) {\n  int cache_index = SerializeInObjectCache(obj);\n  sink->Put(kStartupObjectCache, \"StartupObjectCache\");\n  sink->PutUint30(cache_index, \"startup_object_cache_index\");\n}\n\nvoid StartupSerializer::CheckNoDirtyFinalizationRegistries() {\n  Isolate* isolate = this->isolate();\n  CHECK(IsUndefined(isolate->heap()->dirty_js_finalization_registries_list(),\n                    isolate));\n  CHECK(IsUndefined(\n      isolate->heap()->dirty_js_finalization_registries_list_tail(), isolate));\n}\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SerializedHandleChecker\",\n                \"about\": \"Checks if all global and eternal handles have been serialized.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Isolate\",\n                    \"Context\",\n                    \"FixedArray\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSerializedHandleChecker::SerializedHandleChecker(\n    Isolate* isolate, std::vector<Tagged<Context>>* contexts)\n    : isolate_(isolate) {\n  AddToSet(Cast<FixedArray>(isolate->heap()->serialized_objects()));\n  for (auto const& context : *contexts) {\n    AddToSet(Cast<FixedArray>(context->serialized_objects()));\n  }\n}\n\nvoid SerializedHandleChecker::AddToSet(Tagged<FixedArray> serialized) {\n  int length = serialized->length();\n  for (int i = 0; i < length; i++) serialized_.insert(serialized->get(i));\n}\n\nvoid SerializedHandleChecker::VisitRootPointers(Root root,\n                                                const char* description,\n                                                FullObjectSlot start,\n                                                FullObjectSlot end) {\n  for (FullObjectSlot p = start; p < end; ++p) {\n    if (serialized_.find(*p) != serialized_.end()) continue;\n    PrintF(\"%s handle not serialized: \",\n           root == Root::kGlobalHandles ? \"global\" : \"eternal\");\n    Print(*p);\n    PrintF(\"\\n\");\n    ok_ = false;\n  }\n}\n\nbool SerializedHandleChecker::CheckGlobalAndEternalHandles() {\n  isolate_->global_handles()->IterateAllRoots(this);\n  isolate_->traced_handles()->Iterate(this);\n  isolate_->eternal_handles()->IterateAllRoots(this);\n  return ok_;\n}\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"RootsSerializer\",\n                    \"about\": \"Base class for serializers that handle root objects.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class RootsSerializer {\n                    public:\n                        RootsSerializer(Isolate* isolate, Snapshot::SerializerFlags flags, RootIndex root_index);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SharedHeapSerializer\",\n                    \"about\": \"Serializes objects in the shared heap.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class SharedHeapSerializer {\n                    public:\n                        bool SerializeUsingSharedHeapObjectCache(SnapshotByteSink* sink, Handle<HeapObject> obj);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ExternalReferenceTable\",\n                    \"about\": \"Table of external references.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class ExternalReferenceTable {\n                    public:\n                        static const uint32_t kSizeIsolateIndependent;\n                        Address address(uint32_t i);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ExternalReferenceEncoder\",\n                    \"about\": \"Encodes external references.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class ExternalReferenceEncoder {\n                    public:\n                        struct Value {\n                            uint32_t index() const { return 0; }\n                        };\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"AccessorInfo\",\n                    \"about\": \"Information about an accessor.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class AccessorInfo {\n                    public:\n                        void remove_getter_redirection(Isolate* isolate);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"FunctionTemplateInfo\",\n                    \"about\": \"Information about a function template.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class FunctionTemplateInfo {\n                    public:\n                        void remove_callback_redirection(Isolate* isolate);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Script\",\n                    \"about\": \"Represents a JavaScript script.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class Script {\n                    public:\n                        bool IsUserJavaScript();\n                        void set_context_data(Tagged<Object> data);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"SharedFunctionInfo\",\n                    \"about\": \"Information shared between multiple functions.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class SharedFunctionInfo {\n                    public:\n                        bool IsSubjectToDebugging();\n                        bool HasUncompiledData();\n                        Tagged<UncompiledData> uncompiled_data(Isolate* isolate);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ObjectSerializer\",\n                    \"about\": \"Serializes a single object.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class ObjectSerializer {\n                    public:\n                        ObjectSerializer(StartupSerializer* serializer, Handle<HeapObject> obj, SnapshotByteSink* sink);\n                        void Serialize(SlotType slot_type);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Heap\",\n                    \"about\": \"The V8 heap.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class Heap {\n                    public:\n                        Tagged<Object> feedback_vectors_for_profiling_tools();\n                        void SetFeedbackVectorsForProfilingTools(Tagged<Object> value);\n                        Tagged<WeakArrayList> detached_contexts();\n                        void SetDetachedContexts(Tagged<WeakArrayList> value);\n                        void IterateWeakRoots(RootsVisitor* visitor, base::EnumSet<SkipRoot> skip_root);\n                        void IterateSmiRoots(RootsVisitor* visitor);\n                        void IterateRoots(RootsVisitor* visitor, base::EnumSet<SkipRoot> skip_root);\n                        Tagged<Object> serialized_objects();\n                        Tagged<Object> dirty_js_finalization_registries_list();\n                        Tagged<Object> dirty_js_finalization_registries_list_tail();\n\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Isolate\",\n                    \"about\": \"An isolated instance of the V8 engine.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {\n                    public:\n                        ExternalReferenceTable* external_reference_table();\n                        void SetFeedbackVectorsForProfilingTools(Tagged<Object> value);\n                        Heap* heap();\n                        ThreadManager* thread_manager();\n                        GlobalHandles* global_handles();\n                        TracedHandles* traced_handles();\n                        EternalHandles* eternal_handles();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ThreadManager\",\n                    \"about\": \"Manages threads in the V8 engine.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class ThreadManager {\n                    public:\n                        ThreadState* FirstThreadStateInUse();\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"GlobalHandles\",\n                    \"about\": \"Manages global handles.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class GlobalHandles {\n                    public:\n                        void IterateAllRoots(RootVisitor* visitor);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"TracedHandles\",\n                    \"about\": \"Manages traced handles.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class TracedHandles {\n                    public:\n                        void Iterate(RootVisitor* visitor);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"EternalHandles\",\n                    \"about\": \"Manages eternal handles.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class EternalHandles {\n                    public:\n                        void IterateAllRoots(RootVisitor* visitor);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ReadOnlyRoots\",\n                    \"about\": \"Provides access to read-only root objects.\",\n                    \"attributes\": []\n                }\n            </metadata>\n            <code><![CDATA[\n                class ReadOnlyRoots {\n                    public:\n                        Tagged<Object> undefined_value();\n                        Tagged<WeakArrayList> empty_weak_array_list();\n                        Tagged<String> empty_string();\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}