{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/utils.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/utils.h\",\n        \"file_name\": \"utils.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides utility functions and classes for the Torque language and compiler, including string manipulation, error reporting, and data structures.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers for various functionalities such as algorithms, optional values, input/output streams, queues, string manipulation, and unordered sets.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <algorithm>\n#include <optional>\n#include <ostream>\n#include <queue>\n#include <streambuf>\n#include <string>\n#include <unordered_set>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes V8's base contextual variable and hashing utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/base/contextual.h\"\n#include \"src/base/hashing.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes Torque's source position information.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/source-positions.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"StringLiteralUnquote\",\n            \"about\": \"Unquotes a string literal by removing surrounding quotes and handling escape sequences.\",\n            \"logic\": \"Removes the first and last characters (quotes) and handles escape sequences within the string.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string literal to unquote.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The unquoted string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string StringLiteralUnquote(const std::string& s);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"StringLiteralQuote\",\n            \"about\": \"Quotes a string literal by adding surrounding quotes and escaping special characters.\",\n            \"logic\": \"Adds quotes at the beginning and end of the string, and escapes special characters within the string.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to quote.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The quoted string literal.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string StringLiteralQuote(const std::string& s);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FileUriDecode\",\n            \"about\": \"Decodes 'file://' URIs into file paths.\",\n            \"logic\": \"Checks if the input string starts with 'file://' and, if so, extracts and returns the file path part. Returns an empty optional if the URI is invalid.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The URI to decode.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<std::string>\",\n                \"description\": \"The decoded file path, or an empty optional if decoding fails.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nV8_EXPORT_PRIVATE std::optional<std::string> FileUriDecode(\n    const std::string& s);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"TorqueMessage\",\n            \"about\": \"Represents a message (error or lint) generated by the Torque compiler, including the message text, source position, and message kind.\",\n            \"attributes\": [\n                {\n                    \"name\": \"message\",\n                    \"type\": \"std::string\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The text of the message.\"\n                },\n                {\n                    \"name\": \"position\",\n                    \"type\": \"std::optional<SourcePosition>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The source position where the message occurred.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"Kind\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The kind of message (error or lint).\"\n                }\n            ],\n            \"dependencies\": [\n                \"SourcePosition\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct TorqueMessage {\n  enum class Kind { kError, kLint };\n\n  std::string message;\n  std::optional<SourcePosition> position;\n  Kind kind;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"DECLARE_CONTEXTUAL_VARIABLE\",\n            \"about\": \"Declares a contextual variable using V8's base library.\",\n            \"logic\": \"This is a macro, so its exact behavior depends on the V8 base library implementation. It's used to define variables whose values are context-specific.\",\n            \"parameters\": [\n                {\n                    \"name\": \"TorqueMessages\",\n                    \"type\": \"identifier\",\n                    \"purpose\": \"Name of the contextual variable\"\n                },\n                {\n                    \"name\": \"std::vector<TorqueMessage>\",\n                    \"type\": \"type\",\n                    \"purpose\": \"Type of the contextual variable\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"N/A - Macro\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nDECLARE_CONTEXTUAL_VARIABLE(TorqueMessages, std::vector<TorqueMessage>);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ToString\",\n            \"about\": \"Converts arguments to a string using a stringstream.\",\n            \"logic\": \"Creates a stringstream, inserts the arguments into it using the << operator, and returns the resulting string.\",\n            \"parameters\": [\n                {\n                    \"name\": \"args\",\n                    \"type\": \"Args&&...\",\n                    \"purpose\": \"Variadic arguments to convert to a string.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The string representation of the arguments.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class... Args>\nstd::string ToString(Args&&... args) {\n  std::stringstream stream;\n  USE((stream << std::forward<Args>(args))...);\n  return stream.str();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MessageBuilder\",\n            \"about\": \"Builds Torque messages (errors or lint) and reports them.  Uses RAII to ensure messages are reported even if exceptions are thrown.\",\n            \"attributes\": [\n                {\n                    \"name\": \"message_\",\n                    \"type\": \"TorqueMessage\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Torque message being built.\"\n                },\n                {\n                    \"name\": \"extra_messages_\",\n                    \"type\": \"std::vector<TorqueMessage>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Additional messages to report.\"\n                }\n            ],\n            \"dependencies\": [\n                \"TorqueMessage\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT_PRIVATE MessageBuilder {\n public:\n  MessageBuilder() = delete;\n  MessageBuilder(const std::string& message, TorqueMessage::Kind kind);\n\n  MessageBuilder& Position(SourcePosition position) {\n    message_.position = position;\n    return *this;\n  }\n\n  [[noreturn]] void Throw() const;\n\n  ~MessageBuilder() {\n    // This will also get called in case the error is thrown.\n    Report();\n  }\n\n private:\n  void Report() const;\n\n  TorqueMessage message_;\n  std::vector<TorqueMessage> extra_messages_;\n};\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"TorqueAbortCompilation\",\n            \"about\": \"Used for throwing exceptions to abort Torque compilation.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n// Used for throwing exceptions. Retrieve TorqueMessage from the contextual\n// for specific error information.\nstruct TorqueAbortCompilation {};\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Message\",\n            \"about\": \"Creates a MessageBuilder object.\",\n            \"logic\": \"Constructs a MessageBuilder object with the specified message kind and arguments (converted to a string).\",\n            \"parameters\": [\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"TorqueMessage::Kind\",\n                    \"purpose\": \"The kind of message (error or lint).\"\n                },\n                {\n                    \"name\": \"args\",\n                    \"type\": \"Args&&...\",\n                    \"purpose\": \"Variadic arguments to include in the message.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MessageBuilder\",\n                \"description\": \"A MessageBuilder object.\"\n            },\n            \"dependencies\": [\n                \"MessageBuilder\",\n                \"ToString\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class... Args>\nstatic MessageBuilder Message(TorqueMessage::Kind kind, Args&&... args) {\n  return MessageBuilder(ToString(std::forward<Args>(args)...), kind);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Error\",\n            \"about\": \"Creates a MessageBuilder object for an error message.\",\n            \"logic\": \"Calls the Message function with TorqueMessage::Kind::kError and the provided arguments.\",\n            \"parameters\": [\n                {\n                    \"name\": \"args\",\n                    \"type\": \"Args&&...\",\n                    \"purpose\": \"Variadic arguments to include in the error message.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MessageBuilder\",\n                \"description\": \"A MessageBuilder object for an error message.\"\n            },\n            \"dependencies\": [\n                \"Message\",\n                \"MessageBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class... Args>\nMessageBuilder Error(Args&&... args) {\n  return Message(TorqueMessage::Kind::kError, std::forward<Args>(args)...);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Lint\",\n            \"about\": \"Creates a MessageBuilder object for a lint message.\",\n            \"logic\": \"Calls the Message function with TorqueMessage::Kind::kLint and the provided arguments.\",\n            \"parameters\": [\n                {\n                    \"name\": \"args\",\n                    \"type\": \"Args&&...\",\n                    \"purpose\": \"Variadic arguments to include in the lint message.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MessageBuilder\",\n                \"description\": \"A MessageBuilder object for a lint message.\"\n            },\n            \"dependencies\": [\n                \"Message\",\n                \"MessageBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class... Args>\nMessageBuilder Lint(Args&&... args) {\n  return Message(TorqueMessage::Kind::kLint, std::forward<Args>(args)...);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsLowerCamelCase\",\n            \"about\": \"Checks if a string is in lower camel case.\",\n            \"logic\": \"Checks if the string starts with a lowercase letter and then alternates between lowercase and uppercase letters.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is in lower camel case, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsLowerCamelCase(const std::string& s);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsUpperCamelCase\",\n            \"about\": \"Checks if a string is in upper camel case (PascalCase).\",\n            \"logic\": \"Checks if the string starts with an uppercase letter and then alternates between lowercase and uppercase letters.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is in upper camel case, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsUpperCamelCase(const std::string& s);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsSnakeCase\",\n            \"about\": \"Checks if a string is in snake case.\",\n            \"logic\": \"Checks if the string consists of lowercase letters and underscores.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is in snake case, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsSnakeCase(const std::string& s);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsValidNamespaceConstName\",\n            \"about\": \"Checks if a string is a valid name for a constant in a namespace.\",\n            \"logic\": \"Performs checks based on naming conventions within namespaces.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is a valid namespace constant name, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsValidNamespaceConstName(const std::string& s);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsValidTypeName\",\n            \"about\": \"Checks if a string is a valid type name.\",\n            \"parameters\": [\n                {\n                    \"name\": \"s\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string is a valid type name, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsValidTypeName(const std::string& s);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ReportError\",\n            \"about\": \"Reports an error and throws an exception to abort compilation.\",\n            \"logic\": \"Calls the Error function to create a MessageBuilder object and then calls the Throw method on the MessageBuilder to report the error and throw an exception.\",\n            \"parameters\": [\n                {\n                    \"name\": \"args\",\n                    \"type\": \"Args&&...\",\n                    \"purpose\": \"Variadic arguments to include in the error message.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"[[noreturn]] void\",\n                \"description\": \"This function never returns.\"\n            },\n            \"dependencies\": [\n                \"Error\",\n                \"MessageBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class... Args>\n[[noreturn]] void ReportError(Args&&... args) {\n  Error(std::forward<Args>(args)...).Throw();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CapifyStringWithUnderscores\",\n            \"about\": \"Converts a camellified string to a capified string with underscores.\",\n            \"parameters\": [\n                {\n                    \"name\": \"camellified_string\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The camellified string to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The capified string with underscores.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string CapifyStringWithUnderscores(const std::string& camellified_string);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CamelifyString\",\n            \"about\": \"Converts a string with underscores to camel case.\",\n            \"parameters\": [\n                {\n                    \"name\": \"underscore_string\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string with underscores to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The camel case string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string CamelifyString(const std::string& underscore_string);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SnakeifyString\",\n            \"about\": \"Converts a camel case string to snake case.\",\n            \"parameters\": [\n                {\n                    \"name\": \"camel_string\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The camel case string to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The snake case string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string SnakeifyString(const std::string& camel_string);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DashifyString\",\n            \"about\": \"Converts a string with underscores to a dash-separated string.\",\n            \"parameters\": [\n                {\n                    \"name\": \"underscore_string\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string with underscores to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The dash-separated string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string DashifyString(const std::string& underscore_string);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"UnderlinifyPath\",\n            \"about\": \"Replaces path separators in a string with underscores.\",\n            \"parameters\": [\n                {\n                    \"name\": \"path\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The path string to convert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::string\",\n                \"description\": \"The string with path separators replaced by underscores.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nstd::string UnderlinifyPath(std::string path);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"StartsWithSingleUnderscore\",\n            \"about\": \"Checks if a string starts with a single underscore.\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The string to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the string starts with a single underscore, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool StartsWithSingleUnderscore(const std::string& str);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ReplaceFileContentsIfDifferent\",\n            \"about\": \"Replaces the contents of a file only if the new contents are different.\",\n            \"parameters\": [\n                {\n                    \"name\": \"file_path\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The path to the file.\"\n                },\n                {\n                    \"name\": \"contents\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The new contents to write to the file.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid ReplaceFileContentsIfDifferent(const std::string& file_path,\n                                    const std::string& contents);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Deduplicator\",\n            \"about\": \"Deduplicates objects of type T using an unordered set.  Returns a pointer to the stored object.\",\n            \"attributes\": [\n                {\n                    \"name\": \"storage_\",\n                    \"type\": \"std::unordered_set<T, base::hash<T>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The storage for the deduplicated objects.\"\n                }\n            ],\n            \"dependencies\": [\n                \"base::hash\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nclass Deduplicator {\n public:\n  const T* Add(T x) { return &*(storage_.insert(std::move(x)).first); }\n\n private:\n  std::unordered_set<T, base::hash<T>> storage_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DereferenceIfPointer\",\n            \"about\": \"Dereferences a pointer if the input is a pointer type. Otherwise, returns the input as is.\",\n            \"logic\": \"Uses template specialization to handle pointer and non-pointer types differently.\",\n            \"parameters\": [\n                {\n                    \"name\": \"x\",\n                    \"type\": \"T*\",\n                    \"purpose\": \"The value to dereference or return.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T&\",\n                \"description\": \"The dereferenced value or the original value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nT& DereferenceIfPointer(T* x) {\n  return *x;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DereferenceIfPointer\",\n            \"about\": \"Dereferences a pointer if the input is a pointer type. Otherwise, returns the input as is. Handles rvalue references.\",\n            \"logic\": \"Uses template specialization to handle pointer and non-pointer types differently. This overload handles rvalue references.\",\n            \"parameters\": [\n                {\n                    \"name\": \"x\",\n                    \"type\": \"T&&\",\n                    \"purpose\": \"The value to dereference or return.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T&&\",\n                \"description\": \"The dereferenced value or the original value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nT&& DereferenceIfPointer(T&& x) {\n  return std::forward<T>(x);\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"ListPrintAdaptor\",\n            \"about\": \"Adapts a list for printing to an output stream, applying a transformer function to each element.\",\n            \"attributes\": [\n                {\n                    \"name\": \"list\",\n                    \"type\": \"const T&\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The list to print.\"\n                },\n                {\n                    \"name\": \"separator\",\n                    \"type\": \"const std::string&\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The separator string to insert between elements.\"\n                },\n                {\n                    \"name\": \"transformer\",\n                    \"type\": \"L\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The transformer function to apply to each element.\"\n                }\n            ],\n            \"dependencies\": [\n                \"DereferenceIfPointer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, class L>\nstruct ListPrintAdaptor {\n  const T& list;\n  const std::string& separator;\n  L transformer;\n\n  friend std::ostream& operator<<(std::ostream& os, const ListPrintAdaptor& l) {\n    bool first = true;\n    for (auto& e : l.list) {\n      if (first) {\n        first = false;\n      } else {\n        os << l.separator;\n      }\n      os << DereferenceIfPointer(l.transformer(e));\n    }\n    return os;\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PrintList\",\n            \"about\": \"Creates a ListPrintAdaptor object to print a list with a separator.\",\n            \"logic\": \"Creates a ListPrintAdaptor object with the specified list and separator, and an identity transformer function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"list\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The list to print.\"\n                },\n                {\n                    \"name\": \"separator\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The separator string to insert between elements. Defaults to ', '.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ListPrintAdaptor\",\n                \"description\": \"A ListPrintAdaptor object.\"\n            },\n            \"dependencies\": [\n                \"ListPrintAdaptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nauto PrintList(const T& list, const std::string& separator = \", \") {\n  using ElementType = decltype(*list.begin());\n  auto id = [](ElementType el) { return el; };\n  return ListPrintAdaptor<T, decltype(id)>{list, separator, id};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PrintList\",\n            \"about\": \"Creates a ListPrintAdaptor object to print a list with a separator and a transformer function.\",\n            \"logic\": \"Creates a ListPrintAdaptor object with the specified list, separator, and transformer function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"list\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The list to print.\"\n                },\n                {\n                    \"name\": \"separator\",\n                    \"type\": \"const std::string&\",\n                    \"purpose\": \"The separator string to insert between elements.\"\n                },\n                {\n                    \"name\": \"transformer\",\n                    \"type\": \"L&&\",\n                    \"purpose\": \"The transformer function to apply to each element.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ListPrintAdaptor\",\n                \"description\": \"A ListPrintAdaptor object.\"\n            },\n            \"dependencies\": [\n                \"ListPrintAdaptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T, class L>\nauto PrintList(const T& list, const std::string& separator, L&& transformer) {\n  return ListPrintAdaptor<T, L&&>{list, separator,\n                                  std::forward<L>(transformer)};\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PrintCommaSeparatedList\",\n            \"about\": \"Prints a comma-separated list to an output stream, applying a transformer function to each element.\",\n            \"logic\": \"Calls the PrintList function with a comma separator and the specified transformer function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream to print to.\"\n                },\n                {\n                    \"name\": \"list\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The list to print.\"\n                },\n                {\n                    \"name\": \"transform\",\n                    \"type\": \"C&&\",\n                    \"purpose\": \"The transformer function to apply to each element.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"PrintList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class C, class T>\nvoid PrintCommaSeparatedList(std::ostream& os, const T& list, C&& transform) {\n  os << PrintList(list, \", \", std::forward<C>(transform));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PrintCommaSeparatedList\",\n            \"about\": \"Prints a comma-separated list to an output stream.\",\n            \"logic\": \"Calls the PrintList function with a comma separator.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream to print to.\"\n                },\n                {\n                    \"name\": \"list\",\n                    \"type\": \"const T&\",\n                    \"purpose\": \"The list to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"None\"\n            },\n            \"dependencies\": [\n                \"PrintList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class T>\nvoid PrintCommaSeparatedList(std::ostream& os, const T& list) {\n  os << PrintList(list, \", \");\n}\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"BottomOffset\",\n            \"about\": \"Represents an offset from the bottom of a stack. Used instead of raw `size_t` values for type safety.\",\n            \"attributes\": [\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"size_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The offset value.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n"
}