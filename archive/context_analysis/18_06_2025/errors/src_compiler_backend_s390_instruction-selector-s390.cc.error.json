{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/s390/instruction-selector-s390.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/backend/s390/instruction-selector-s390.cc\",\n        \"file_name\": \"instruction-selector-s390.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"This file implements the S390-specific instruction selector.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Standard C++ and V8 headers for various functionalities like optional values, logging, compiler backend, turboshaft operations, execution frame constants.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <optional>\n\n#include \"src/base/logging.h\"\n#include \"src/compiler/backend/instruction-selector-adapter.h\"\n#include \"src/compiler/backend/instruction-selector-impl.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/opmasks.h\"\n#include \"src/execution/frame-constants.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"OperandMode\",\n            \"about\": \"Defines the different operand modes for instructions, specifying whether immediate values, registers, or memory operands are allowed.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nenum class OperandMode : uint32_t {\n  kNone = 0u,\n  // Immediate mode\n  kShift32Imm = 1u << 0,\n  kShift64Imm = 1u << 1,\n  kInt32Imm = 1u << 2,\n  kInt32Imm_Negate = 1u << 3,\n  kUint32Imm = 1u << 4,\n  kInt20Imm = 1u << 5,\n  kUint12Imm = 1u << 6,\n  // Instr format\n  kAllowRRR = 1u << 7,\n  kAllowRM = 1u << 8,\n  kAllowRI = 1u << 9,\n  kAllowRRI = 1u << 10,\n  kAllowRRM = 1u << 11,\n  // Useful combination\n  kAllowImmediate = kAllowRI | kAllowRRI,\n  kAllowMemoryOperand = kAllowRM | kAllowRRM,\n  kAllowDistinctOps = kAllowRRR | kAllowRRI | kAllowRRM,\n  kBitWiseCommonMode = kAllowRI,\n  kArithmeticCommonMode = kAllowRM | kAllowRI\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"using\",\n            \"name\": \"OperandModes\",\n            \"about\": \"Defines a type alias for flags based on the OperandMode enum class.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nusing OperandModes = base::Flags<OperandMode, uint32_t>;\nDEFINE_OPERATORS_FOR_FLAGS(OperandModes)\nOperandModes immediateModeMask =\n    OperandMode::kShift32Imm | OperandMode::kShift64Imm |\n    OperandMode::kInt32Imm | OperandMode::kInt32Imm_Negate |\n    OperandMode::kUint32Imm | OperandMode::kInt20Imm;\n        ]]></code>\n    </class>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"AndCommonMode\",\n            \"about\": \"Defines a macro for commonly used operand modes for AND operations, considering the DISTINCT_OPS CPU feature.\",\n            \"logic\": \"It uses CpuFeatures::IsSupported to conditionally enable OperandMode::kAllowRRR if DISTINCT_OPS is supported; otherwise, OperandMode::kNone.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"CpuFeatures\",\n                \"DISTINCT_OPS\",\n                \"OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define AndCommonMode                                                \\\n  ((OperandMode::kAllowRM |                                          \\\n    (CpuFeatures::IsSupported(DISTINCT_OPS) ? OperandMode::kAllowRRR \\\n                                            : OperandMode::kNone)))\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"And64OperandMode\",\n            \"about\": \"Defines a macro for the operand modes used by AND64 operations\",\n            \"logic\": \"Expand to AndCommonMode\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"AndCommonMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define And64OperandMode AndCommonMode\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"Or64OperandMode\",\n            \"about\": \"Defines a macro for the operand modes used by OR64 operations\",\n            \"logic\": \"Expand to AndCommonMode\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"AndCommonMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define Or64OperandMode And64OperandMode\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"Xor64OperandMode\",\n            \"about\": \"Defines a macro for the operand modes used by XOR64 operations\",\n            \"logic\": \"Expand to AndCommonMode\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"AndCommonMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define Xor64OperandMode And64OperandMode\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"And32OperandMode\",\n            \"about\": \"Defines the operand modes for 32-bit AND operations, including immediate and register modes.\",\n            \"logic\": \"Combines AndCommonMode with OperandMode::kAllowRI and OperandMode::kUint32Imm.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"AndCommonMode\",\n                \"OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define And32OperandMode \\\n  (AndCommonMode | OperandMode::kAllowRI | OperandMode::kUint32Imm)\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"Or32OperandMode\",\n            \"about\": \"Defines the operand modes for 32-bit OR operations, including immediate and register modes.\",\n            \"logic\": \"Expand to And32OperandMode\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"And32OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define Or32OperandMode And32OperandMode\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"Xor32OperandMode\",\n            \"about\": \"Defines the operand modes for 32-bit XOR operations, including immediate and register modes.\",\n            \"logic\": \"Expand to And32OperandMode\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"And32OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define Xor32OperandMode And32OperandMode\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"Shift32OperandMode\",\n            \"about\": \"Defines the operand modes for 32-bit shift operations, considering the DISTINCT_OPS CPU feature.\",\n            \"logic\": \"It uses CpuFeatures::IsSupported to conditionally enable OperandMode::kAllowRRR and OperandMode::kAllowRRI if DISTINCT_OPS is supported.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"CpuFeatures\",\n                \"DISTINCT_OPS\",\n                \"OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define Shift32OperandMode                                   \\\n  ((OperandMode::kAllowRI | OperandMode::kShift64Imm |       \\\n    (CpuFeatures::IsSupported(DISTINCT_OPS)                  \\\n         ? (OperandMode::kAllowRRR | OperandMode::kAllowRRI) \\\n         : OperandMode::kNone)))\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"Shift64OperandMode\",\n            \"about\": \"Defines the operand modes for 64-bit shift operations.\",\n            \"logic\": \"Allows register-register-register (RRR) and register-register-immediate (RRI) modes.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define Shift64OperandMode                             \\\n  ((OperandMode::kAllowRI | OperandMode::kShift64Imm | \\\n    OperandMode::kAllowRRR | OperandMode::kAllowRRI))\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"AddOperandMode\",\n            \"about\": \"Defines the operand modes for addition operations, considering the DISTINCT_OPS CPU feature.\",\n            \"logic\": \"It uses CpuFeatures::IsSupported to conditionally enable OperandMode::kAllowRRR and OperandMode::kAllowRRI if DISTINCT_OPS is supported; otherwise, it defaults to OperandMode::kArithmeticCommonMode.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"CpuFeatures\",\n                \"DISTINCT_OPS\",\n                \"OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define AddOperandMode                                            \\\n  ((OperandMode::kArithmeticCommonMode | OperandMode::kInt32Imm | \\\n    (CpuFeatures::IsSupported(DISTINCT_OPS)                       \\\n         ? (OperandMode::kAllowRRR | OperandMode::kAllowRRI)      \\\n         : OperandMode::kArithmeticCommonMode)))\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"SubOperandMode\",\n            \"about\": \"Defines the operand modes for subtraction operations, considering the DISTINCT_OPS CPU feature.\",\n            \"logic\": \"It uses CpuFeatures::IsSupported to conditionally enable OperandMode::kAllowRRR and OperandMode::kAllowRRI if DISTINCT_OPS is supported; otherwise, it defaults to OperandMode::kArithmeticCommonMode.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"CpuFeatures\",\n                \"DISTINCT_OPS\",\n                \"OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define SubOperandMode                                                   \\\n  ((OperandMode::kArithmeticCommonMode | OperandMode::kInt32Imm_Negate | \\\n    (CpuFeatures::IsSupported(DISTINCT_OPS)                              \\\n         ? (OperandMode::kAllowRRR | OperandMode::kAllowRRI)             \\\n         : OperandMode::kArithmeticCommonMode)))\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"MulOperandMode\",\n            \"about\": \"Defines the operand modes for multiplication operations.\",\n            \"logic\": \"Allows arithmetic common modes and Int32 immediate modes\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"OperandMode\"\n            },\n            \"dependencies\": [\n                \"OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define MulOperandMode \\\n  (OperandMode::kArithmeticCommonMode | OperandMode::kInt32Imm)\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"BaseWithScaledIndexAndDisplacementMatch\",\n            \"about\": \"Represents a match for base with scaled index and displacement addressing mode.\",\n            \"attributes\": [\n                {\n                    \"name\": \"base\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Base register of the memory access.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"OpIndex\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Index register of the memory access.\"\n                },\n                {\n                    \"name\": \"scale\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Scale factor for the index register.\"\n                },\n                {\n                    \"name\": \"displacement\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Displacement offset of the memory access.\"\n                },\n                {\n                    \"name\": \"displacement_mode\",\n                    \"type\": \"DisplacementMode\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Displacement mode (positive or negative).\"\n                }\n            ],\n            \"dependencies\": [\n                \"OpIndex\",\n                \"DisplacementMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct BaseWithScaledIndexAndDisplacementMatch {\n  OpIndex base = {};\n  OpIndex index = {};\n  int scale = 0;\n  int64_t displacement = 0;\n  DisplacementMode displacement_mode = kPositiveDisplacement;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"TryMatchBaseWithScaledIndexAndDisplacement64\",\n            \"about\": \"Attempts to match a base with scaled index and displacement addressing mode for 64-bit operations.\",\n            \"logic\": \"Canonicalizes the order of displacements and scale factors and checks for node clusters to find interesting cases like (S + (B + D)), (S + (B + B)), etc.\",\n            \"parameters\": [\n                {\n                    \"name\": \"selector\",\n                    \"type\": \"InstructionSelectorT*\",\n                    \"purpose\": \"The instruction selector.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"OpIndex\",\n                    \"purpose\": \"The node to match.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<BaseWithScaledIndexAndDisplacementMatch>\",\n                \"description\": \"An optional BaseWithScaledIndexAndDisplacementMatch if a match is found, std::nullopt otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionSelectorT\",\n                \"OpIndex\",\n                \"BaseWithScaledIndexAndDisplacementMatch\",\n                \"LoadOp\",\n                \"StoreOp\",\n                \"Simd128LaneMemoryOp\",\n                \"Simd128LoadTransformOp\",\n                \"Operation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::optional<BaseWithScaledIndexAndDisplacementMatch>\nTryMatchBaseWithScaledIndexAndDisplacement64(InstructionSelectorT* selector,\n                                             OpIndex node) {\n  // The BaseWithIndexAndDisplacementMatcher canonicalizes the order of\n  // displacements and scale factors that are used as inputs, so instead of\n  // enumerating all possible patterns by brute force, checking for node\n  // clusters using the following templates in the following order suffices\n  // to find all of the interesting cases (S = index * scale, B = base\n  // input, D = displacement input):\n  //\n  // (S + (B + D))\n  // (S + (B + B))\n  // (S + D)\n  // (S + B)\n  // ((S + D) + B)\n  // ((S + B) + D)\n  // ((B + D) + B)\n  // ((B + B) + D)\n  // (B + D)\n  // (B + B)\n  BaseWithScaledIndexAndDisplacementMatch result;\n  result.displacement_mode = kPositiveDisplacement;\n\n  const Operation& op = selector->Get(node);\n  if (const LoadOp* load = op.TryCast<LoadOp>()) {\n    result.base = load->base();\n    result.index = load->index().value_or_invalid();\n    result.scale = load->element_size_log2;\n    result.displacement = load->offset;\n    if (load->kind.tagged_base) result.displacement -= kHeapObjectTag;\n    return result;\n  } else if (const StoreOp* store = op.TryCast<StoreOp>()) {\n    result.base = store->base();\n    result.index = store->index().value_or_invalid();\n    result.scale = store->element_size_log2;\n    result.displacement = store->offset;\n    if (store->kind.tagged_base) result.displacement -= kHeapObjectTag;\n    return result;\n  } else if (op.Is<WordBinopOp>()) {\n    UNIMPLEMENTED();\n#ifdef V8_ENABLE_WEBASSEMBLY\n  } else if (const Simd128LaneMemoryOp* lane_op =\n                 op.TryCast<Simd128LaneMemoryOp>()) {\n    result.base = lane_op->base();\n    result.index = lane_op->index();\n    result.scale = 0;\n    result.displacement = 0;\n    if (lane_op->kind.tagged_base) result.displacement -= kHeapObjectTag;\n    return result;\n  } else if (const Simd128LoadTransformOp* load_transform =\n                 op.TryCast<Simd128LoadTransformOp>()) {\n    result.base = load_transform->base();\n    result.index = load_transform->index();\n    DCHECK_EQ(load_transform->offset, 0);\n    result.scale = 0;\n    result.displacement = 0;\n    DCHECK(!load_transform->load_kind.tagged_base);\n    return result;\n#endif  // V8_ENABLE_WEBASSEMBLY\n  }\n  return std::nullopt;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"S390OperandGeneratorT\",\n            \"extends\": \"OperandGeneratorT\",\n            \"about\": \"A S390-specific operand generator that extends the base OperandGeneratorT class.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OperandGeneratorT\",\n                \"InstructionOperand\",\n                \"OpIndex\",\n                \"OperandModes\",\n                \"ConstantOp\",\n                \"AddressingMode\",\n                \"InstructionCode\",\n                \"MachineRepresentation\",\n                \"RegisterUseKind\",\n                \"DisplacementMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n// Adds S390-specific methods for generating operands.\nclass S390OperandGeneratorT final : public OperandGeneratorT {\n public:\n  explicit S390OperandGeneratorT(InstructionSelectorT* selector)\n      : OperandGeneratorT(selector) {}\n\n  InstructionOperand UseOperand(OpIndex node, OperandModes mode) {\n    if (CanBeImmediate(node, mode)) {\n      return UseImmediate(node);\n    }\n    return UseRegister(node);\n  }\n\n  InstructionOperand UseAnyExceptImmediate(OpIndex node) {\n    int64_t value;\n    if (MatchSignedIntegralConstant(node, &value))\n      return UseRegister(node);\n    else\n      return this->Use(node);\n  }\n\n  int64_t GetImmediate(OpIndex node) {\n    ConstantOp* op =\n        this->turboshaft_graph()->Get(node).template TryCast<ConstantOp>();\n    switch (op->kind) {\n      case ConstantOp::Kind::kWord32:\n        return op->word32();\n      case ConstantOp::Kind::kWord64:\n        return op->word64();\n      default:\n        UNIMPLEMENTED();\n    }\n  }\n\n  bool CanBeImmediate(OpIndex node, OperandModes mode) {\n    int64_t value;\n    if (!selector()->MatchSignedIntegralConstant(node, &value)) return false;\n    return CanBeImmediate(value, mode);\n  }\n\n  bool CanBeImmediate(int64_t value, OperandModes mode) {\n    if (mode & OperandMode::kShift32Imm)\n      return 0 <= value && value < 32;\n    else if (mode & OperandMode::kShift64Imm)\n      return 0 <= value && value < 64;\n    else if (mode & OperandMode::kInt32Imm)\n      return is_int32(value);\n    else if (mode & OperandMode::kInt32Imm_Negate)\n      return is_int32(-value);\n    else if (mode & OperandMode::kUint32Imm)\n      return is_uint32(value);\n    else if (mode & OperandMode::kInt20Imm)\n      return is_int20(value);\n    else if (mode & OperandMode::kUint12Imm)\n      return is_uint12(value);\n    else\n      return false;\n  }\n\n  bool CanBeMemoryOperand(InstructionCode opcode, OpIndex user, OpIndex input,\n                          int effect_level) {\n    if (!this->IsLoadOrLoadImmutable(input)) return false;\n    if (!selector()->CanCover(user, input)) return false;\n    if (effect_level != selector()->GetEffectLevel(input)) {\n      return false;\n    }\n\n    MachineRepresentation rep =\n        this->load_view(input).loaded_rep().representation();\n    switch (opcode) {\n      case kS390_Cmp64:\n      case kS390_LoadAndTestWord64:\n        if (rep == MachineRepresentation::kWord64 ||\n            (!COMPRESS_POINTERS_BOOL && IsAnyTagged(rep))) {\n          DCHECK_EQ(ElementSizeInBits(rep), 64);\n          return true;\n        }\n        break;\n      case kS390_LoadAndTestWord32:\n      case kS390_Cmp32:\n        if (rep == MachineRepresentation::kWord32 ||\n            (COMPRESS_POINTERS_BOOL && IsAnyCompressed(rep))) {\n          DCHECK_EQ(ElementSizeInBits(rep), 32);\n          return true;\n        }\n        break;\n      default:\n        break;\n    }\n    return false;\n  }\n\n  AddressingMode GenerateMemoryOperandInputs(\n      OptionalOpIndex index, OpIndex base, int64_t displacement,\n      DisplacementMode displacement_mode, InstructionOperand inputs[],\n      size_t* input_count,\n      RegisterUseKind reg_kind = RegisterUseKind::kUseRegister) {\n    AddressingMode mode = kMode_MRI;\n    if (base.valid()) {\n      inputs[(*input_count)++] = UseRegister(base, reg_kind);\n      if (index.valid()) {\n        inputs[(*input_count)++] = UseRegister(this->value(index), reg_kind);\n        if (displacement != 0) {\n          inputs[(*input_count)++] = UseImmediate(\n              displacement_mode == kNegativeDisplacement ? -displacement\n                                                         : displacement);\n          mode = kMode_MRRI;\n        } else {\n          mode = kMode_MRR;\n        }\n      } else {\n        if (displacement == 0) {\n          mode = kMode_MR;\n        } else {\n          inputs[(*input_count)++] = UseImmediate(\n              displacement_mode == kNegativeDisplacement ? -displacement\n                                                         : displacement);\n          mode = kMode_MRI;\n        }\n      }\n    } else {\n      DCHECK(index.valid());\n      inputs[(*input_count)++] = UseRegister(this->value(index), reg_kind);\n      if (displacement != 0) {\n        inputs[(*input_count)++] = UseImmediate(\n            displacement_mode == kNegativeDisplacement ? -displacement\n                                                       : displacement);\n        mode = kMode_MRI;\n      } else {\n        mode = kMode_MR;\n      }\n    }\n    return mode;\n  }\n\n  AddressingMode GetEffectiveAddressMemoryOperand(\n      OpIndex operand, InstructionOperand inputs[], size_t* input_count,\n      OperandModes immediate_mode = OperandMode::kInt20Imm) {\n    auto m = TryMatchBaseWithScaledIndexAndDisplacement64(selector(), operand);\n    DCHECK(m.has_value());\n    if (m->base.valid() &&\n        this->Get(m->base).template Is<LoadRootRegisterOp>()) {\n      DCHECK(!m->index.valid());\n      DCHECK_EQ(m->scale, 0);\n      inputs[(*input_count)++] =\n          UseImmediate(static_cast<int>(m->displacement));\n      return kMode_Root;\n    } else if (CanBeImmediate(m->displacement, immediate_mode)) {\n      DCHECK_EQ(m->scale, 0);\n      return GenerateMemoryOperandInputs(m->index, m->base, m->displacement,\n                                         m->displacement_mode, inputs,\n                                         input_count);\n    } else {\n      DCHECK_EQ(m->displacement, 0);\n      inputs[(*input_count)++] = UseRegister(m->base);\n      inputs[(*input_count)++] = UseRegister(m->index);\n      return kMode_MRR;\n    }\n  }\n\n  bool CanBeBetterLeftOperand(OpIndex node) const {\n    return !selector()->IsLive(node);\n  }\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"S390OpcodeOnlySupport12BitDisp\",\n            \"about\": \"Checks if the given ArchOpcode only supports a 12-bit displacement.\",\n            \"logic\": \"Uses a switch statement to check a predetermined list of opcodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"opcode\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode only supports 12-bit displacement, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"ArchOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nbool S390OpcodeOnlySupport12BitDisp(ArchOpcode opcode) {\n  switch (opcode) {\n    case kS390_AddFloat:\n    case kS390_AddDouble:\n    case kS390_CmpFloat:\n    case kS390_CmpDouble:\n    case kS390_Float32ToDouble:\n      return true;\n    default:\n      return false;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"S390OpcodeOnlySupport12BitDisp\",\n            \"about\": \"Checks if the given InstructionCode only supports a 12-bit displacement by extracting the ArchOpcode.\",\n            \"logic\": \"Extracts the ArchOpcode using ArchOpcodeField::decode and calls the other S390OpcodeOnlySupport12BitDisp function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"InstructionCode\",\n                    \"purpose\": \"The instruction code to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the opcode only supports 12-bit displacement, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"InstructionCode\",\n                \"ArchOpcode\",\n                \"ArchOpcodeField\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool S390OpcodeOnlySupport12BitDisp(InstructionCode op) {\n  ArchOpcode opcode = ArchOpcodeField::decode(op);\n  return S390OpcodeOnlySupport12BitDisp(opcode);\n}\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"OpcodeImmMode\",\n            \"about\": \"Defines a macro to select the immediate mode based on whether the opcode supports only 12-bit displacements.\",\n            \"logic\": \"It uses S390OpcodeOnlySupport12BitDisp to choose between OperandMode::kUint12Imm and OperandMode::kInt20Imm.\",\n            \"parameters\": [\n                {\n                    \"name\": \"op\",\n                    \"type\": \"ArchOpcode\",\n                    \"purpose\": \"The opcode to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"OperandMode\",\n                \"description\": \"Either OperandMode::kUint12Imm or OperandMode::kInt20Imm\"\n            },\n            \"dependencies\": [\n                \"S390OpcodeOnlySupport12BitDisp\",\n                \"OperandMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#define OpcodeImmMode(op)                                       \\\n  (S390OpcodeOnlySupport12BitDisp(op) ? OperandMode::kUint12Imm \\\n                                      : OperandMode::kInt20Imm)\n        ]]></code>\n    </func>\n    \n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"SelectLoadOpcode\",\n            \"about\": \"Selects the appropriate load opcode based on the memory representation and result representation.\",\n            \"logic\": \"Uses a switch statement to determine the correct load opcode based on the loaded representation and result representation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"loaded_rep\",\n                    \"type\": \"MemoryRepresentation\",\n                    \"purpose\": \"The representation of the data in memory.\"\n                },\n                {\n                    \"name\": \"result_rep\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The representation of the result in the register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"ArchOpcode\",\n                \"description\": \"The selected load opcode.\"\n            },\n            \"dependencies\": [\n                \"MemoryRepresentation\",\n                \"RegisterRepresentation\",\n                \"ArchOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nArchOpcode SelectLoadOpcode(MemoryRepresentation loaded_rep,\n                            RegisterRepresentation result_rep) {\n  // NOTE: The meaning of `loaded_rep` = `MemoryRepresentation::AnyTagged()` is\n  // we are loading a compressed tagged field, while `result_rep` =\n  // `RegisterRepresentation::Tagged()` refers to an uncompressed tagged value.\n  switch (loaded_rep) {\n    case MemoryRepresentation::Int8():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kS390_LoadWordS8;\n    case MemoryRepresentation::Uint8():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kS390_LoadWordU8;\n    case MemoryRepresentation::Int16():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kS390_LoadWordS16;\n    case MemoryRepresentation::Uint16():\n      DCHECK_EQ(result_rep, RegisterRepresentation::Word32());\n      return kS390_LoadWordU16;\n    "
}