{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/deoptimizer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 172, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/deoptimizer.h\",\n            \"file_name\": \"deoptimizer.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares the Deoptimizer class, which handles the process of reverting optimized code back to unoptimized code during runtime when certain conditions are met (e.g., type mismatches, unhandled exceptions).\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and V8-specific headers for various functionalities such as optional values, dynamic arrays, built-in functions, code generation, deoptimization reasons, frame descriptions, translated state, diagnostics, JavaScript objects, and WebAssembly support.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <optional>\n            #include <vector>\n\n            #include \"src/builtins/builtins.h\"\n            #include \"src/codegen/source-position.h\"\n            #include \"src/deoptimizer/deoptimize-reason.h\"\n            #include \"src/deoptimizer/frame-description.h\"\n            #include \"src/deoptimizer/translated-state.h\"\n            #include \"src/diagnostics/code-tracer.h\"\n            #include \"src/objects/js-function.h\"\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/sandbox/hardware-support.h\"\n            #include \"src/wasm/value-type.h\"\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Deoptimizer\",\n                \"extends\": \"Malloced\",\n                \"about\": \"Handles deoptimization, the process of reverting from optimized code to unoptimized code. Manages the state, computes output frames, and handles materialization of heap objects.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the Isolate instance.\"\n                    },\n                    {\n                        \"name\": \"function_\",\n                        \"type\": \"Tagged<JSFunction>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The JavaScript function being deoptimized.\"\n                    },\n                    {\n                        \"name\": \"compiled_code_\",\n                        \"type\": \"Tagged<Code>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The optimized code that is being deoptimized.\"\n                    },\n                    {\n                        \"name\": \"deopt_exit_index_\",\n                        \"type\": \"unsigned\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Index of the deoptimization exit.\"\n                    },\n                    {\n                        \"name\": \"bytecode_offset_in_outermost_frame_\",\n                        \"type\": \"BytecodeOffset\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The bytecode offset in the outermost frame where deoptimization occurred.\"\n                    },\n                    {\n                        \"name\": \"deopt_kind_\",\n                        \"type\": \"DeoptimizeKind\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The kind of deoptimization.\"\n                    },\n                    {\n                        \"name\": \"from_\",\n                        \"type\": \"Address\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The address from where deoptimization is triggered.\"\n                    },\n                    {\n                        \"name\": \"fp_to_sp_delta_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The delta between frame pointer and stack pointer.\"\n                    },\n                    {\n                        \"name\": \"input_\",\n                        \"type\": \"FrameDescription*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Description of the input frame.\"\n                    },\n                    {\n                        \"name\": \"output_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Number of output frames.\"\n                    },\n                    {\n                        \"name\": \"output_\",\n                        \"type\": \"FrameDescription**\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Array of output frame descriptions.\"\n                    },\n                    {\n                        \"name\": \"caller_frame_top_\",\n                        \"type\": \"intptr_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Top of the caller's frame.\"\n                    },\n                    {\n                        \"name\": \"caller_fp_\",\n                        \"type\": \"intptr_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Caller's frame pointer.\"\n                    },\n                    {\n                        \"name\": \"caller_pc_\",\n                        \"type\": \"intptr_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Caller's program counter.\"\n                    },\n                    {\n                        \"name\": \"stack_fp_\",\n                        \"type\": \"intptr_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Frame pointer of the stack.\"\n                    },\n                    {\n                        \"name\": \"translated_state_\",\n                        \"type\": \"TranslatedState\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Represents the translated state of the frame.\"\n                    },\n                    {\n                        \"name\": \"values_to_materialize_\",\n                        \"type\": \"std::vector<ValueToMaterialize>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of values to materialize on the heap.\"\n                    },\n                    {\n                        \"name\": \"feedback_vector_to_materialize_\",\n                        \"type\": \"std::vector<ValueToMaterialize>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"List of feedback vectors to materialize.\"\n                    },\n                    {\n                        \"name\": \"trace_scope_\",\n                        \"type\": \"CodeTracer::Scope* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracing scope for debugging.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Malloced\",\n                    \"JSFunction\",\n                    \"Code\",\n                    \"DeoptimizeKind\",\n                    \"FrameDescription\",\n                    \"TranslatedState\",\n                    \"Builtin\",\n                    \"BytecodeOffset\",\n                    \"WasmCode\",\n                    \"SharedFunctionInfo\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class Deoptimizer : public Malloced {\n            public:\n                struct DeoptInfo {\n                    DeoptInfo(SourcePosition position, DeoptimizeReason deopt_reason,\n                              uint32_t node_id, int deopt_id)\n                        : position(position),\n                          deopt_reason(deopt_reason),\n                          node_id(node_id),\n                          deopt_id(deopt_id) {}\n\n                    const SourcePosition position;\n                    const DeoptimizeReason deopt_reason;\n                    const uint32_t node_id;\n                    const int deopt_id;\n                };\n\n                // Whether the deopt exit is contained by the outermost loop containing the\n                // osr'd loop. For example:\n                //\n                //  for (;;) {\n                //    for (;;) {\n                //    }  // OSR is triggered on this backedge.\n                //  }  // This is the outermost loop containing the osr'd loop.\n                static bool DeoptExitIsInsideOsrLoop(Isolate* isolate,\n                                                       Tagged<JSFunction> function,\n                                                       BytecodeOffset deopt_exit_offset,\n                                                       BytecodeOffset osr_offset);\n                static DeoptInfo GetDeoptInfo(Tagged<Code> code, Address from);\n                DeoptInfo GetDeoptInfo() const {\n                    return Deoptimizer::GetDeoptInfo(compiled_code_, from_);\n                }\n\n                static const char* MessageFor(DeoptimizeKind kind);\n\n                DirectHandle<JSFunction> function() const;\n                DirectHandle<Code> compiled_code() const;\n                DeoptimizeKind deopt_kind() const { return deopt_kind_; }\n                int output_count() const { return output_count_; }\n\n                // Where the deopt exit occurred *in the outermost frame*, i.e in the\n                // function we generated OSR'd code for. If the deopt occurred in an inlined\n                // function, this would point at the corresponding outermost Call bytecode.\n                BytecodeOffset bytecode_offset_in_outermost_frame() const {\n                    return bytecode_offset_in_outermost_frame_;\n                }\n\n                static Deoptimizer* New(Address raw_function, DeoptimizeKind kind,\n                                          Address from, int fp_to_sp_delta, Isolate* isolate);\n                static Deoptimizer* Grab(Isolate* isolate);\n\n                // Delete and deregister the deoptimizer from the current isolate. Returns the\n                // count of output (liftoff) frames that were constructed by the deoptimizer.\n                static size_t DeleteForWasm(Isolate* isolate);\n\n                // The returned object with information on the optimized frame needs to be\n                // freed before another one can be generated.\n                static DeoptimizedFrameInfo* DebuggerInspectableFrame(JavaScriptFrame* frame,\n                                                                        int jsframe_index,\n                                                                        Isolate* isolate);\n\n                // Deoptimize the function now. Its current optimized code will never be run\n                // again and any activations of the optimized code will get deoptimized when\n                // execution returns. If {code} is specified then the given code is targeted\n                // instead of the function code (e.g. OSR code not installed on function).\n                static void DeoptimizeFunction(Tagged<JSFunction> function,\n                                                LazyDeoptimizeReason reason,\n                                                Tagged<Code> code = {});\n\n                // Deoptimize all code in the given isolate.\n                V8_EXPORT_PRIVATE static void DeoptimizeAll(Isolate* isolate);\n\n                // Deoptimizes all optimized code that has been previously marked\n                // (via code->set_marked_for_deoptimization) and unlinks all functions that\n                // refer to that code.\n                static void DeoptimizeMarkedCode(Isolate* isolate);\n\n                // Deoptimizes all optimized code that implements the given function (whether\n                // directly or inlined).\n                static void DeoptimizeAllOptimizedCodeWithFunction(\n                    Isolate* isolate, DirectHandle<SharedFunctionInfo> function);\n\n                // Check the given address against a list of allowed addresses, to prevent a\n                // potential attacker from using the frame creation process in the\n                // deoptimizer, in particular the signing process, to gain control over the\n                // program.\n                // This function makes a crash if the address is not valid. If it's valid,\n                // it returns the given address.\n                static Address EnsureValidReturnAddress(Isolate* isolate, Address address);\n\n                ~Deoptimizer();\n\n                void MaterializeHeapObjects();\n\n                static void ComputeOutputFrames(Deoptimizer* deoptimizer);\n\n                V8_EXPORT_PRIVATE static Builtin GetDeoptimizationEntry(DeoptimizeKind kind);\n\n                // InstructionStream generation support.\n                static int input_offset() { return offsetof(Deoptimizer, input_); }\n                static int output_count_offset() {\n                    return offsetof(Deoptimizer, output_count_);\n                }\n                static int output_offset() { return offsetof(Deoptimizer, output_); }\n\n                static int caller_frame_top_offset() {\n                    return offsetof(Deoptimizer, caller_frame_top_);\n                }\n\n#ifdef V8_ENABLE_CET_SHADOW_STACK\n                static constexpr int shadow_stack_offset() {\n                    return offsetof(Deoptimizer, shadow_stack_);\n                }\n\n                static constexpr int shadow_stack_count_offset() {\n                    return offsetof(Deoptimizer, shadow_stack_count_);\n                }\n#endif  // V8_ENABLE_CET_SHADOW_STACK\n\n                Isolate* isolate() const { return isolate_; }\n\n                static constexpr int kMaxNumberOfEntries = 16384;\n\n                // This marker is passed to Deoptimizer::New as {deopt_exit_index} on\n                // platforms that have fixed deopt sizes. The actual deoptimization id is then\n                // calculated from the return address.\n                static constexpr unsigned kFixedExitSizeMarker = kMaxUInt32;\n\n                // Size of deoptimization exit sequence.\n                V8_EXPORT_PRIVATE static const int kEagerDeoptExitSize;\n                V8_EXPORT_PRIVATE static const int kLazyDeoptExitSize;\n\n                // The size of the call instruction to Builtins::kAdaptShadowStackForDeopt.\n                V8_EXPORT_PRIVATE static const int kAdaptShadowStackOffsetToSubtract;\n\n                // Tracing.\n                static void TraceMarkForDeoptimization(Isolate* isolate, Tagged<Code> code,\n                                                        LazyDeoptimizeReason reason);\n                static void TraceEvictFromOptimizedCodeCache(Isolate* isolate,\n                                                                Tagged<SharedFunctionInfo> sfi,\n                                                                const char* reason);\n\n                // Patch the generated code to jump to a safepoint entry. This is used only\n                // when Shadow Stack is enabled.\n                static void PatchToJump(Address pc, Address new_pc);\n\n            private:\n                void QueueValueForMaterialization(Address output_address, Tagged<Object> obj,\n                                                    const TranslatedFrame::iterator& iterator);\n                void QueueFeedbackVectorForMaterialization(\n                    Address output_address, const TranslatedFrame::iterator& iterator);\n\n                Deoptimizer(Isolate* isolate, Tagged<JSFunction> function,\n                            DeoptimizeKind kind, Address from, int fp_to_sp_delta);\n                void DeleteFrameDescriptions();\n\n                void DoComputeOutputFrames();\n\n#if V8_ENABLE_WEBASSEMBLY\n                void DoComputeOutputFramesWasmImpl();\n                FrameDescription* DoComputeWasmLiftoffFrame(\n                    TranslatedFrame& frame, wasm::NativeModule* native_module,\n                    Tagged<WasmTrustedInstanceData> wasm_trusted_instance, int frame_index,\n                    std::stack<intptr_t>& shadow_stack);\n\n                void GetWasmStackSlotsCounts(const wasm::FunctionSig* sig,\n                                                int* parameter_stack_slots,\n                                                int* return_stack_slots);\n#endif\n\n                void DoComputeUnoptimizedFrame(TranslatedFrame* translated_frame,\n                                                int frame_index, bool goto_catch_handler);\n                void DoComputeInlinedExtraArguments(TranslatedFrame* translated_frame,\n                                                    int frame_index);\n                void DoComputeConstructCreateStubFrame(TranslatedFrame* translated_frame,\n                                                        int frame_index);\n                void DoComputeConstructInvokeStubFrame(TranslatedFrame* translated_frame,\n                                                        int frame_index);\n\n                static Builtin TrampolineForBuiltinContinuation(BuiltinContinuationMode mode,\n                                                                  bool must_handle_result);\n\n#if V8_ENABLE_WEBASSEMBLY\n                TranslatedValue TranslatedValueForWasmReturnKind(\n                    std::optional<wasm::ValueKind> wasm_call_return_kind);\n#endif  // V8_ENABLE_WEBASSEMBLY\n\n                void DoComputeBuiltinContinuation(TranslatedFrame* translated_frame,\n                                                    int frame_index,\n                                                    BuiltinContinuationMode mode);\n\n                unsigned ComputeInputFrameAboveFpFixedSize() const;\n                unsigned ComputeInputFrameSize() const;\n\n                static unsigned ComputeIncomingArgumentSize(Tagged<Code> code);\n\n                // Tracing.\n                bool tracing_enabled() const { return trace_scope_ != nullptr; }\n                bool verbose_tracing_enabled() const {\n                    return v8_flags.trace_deopt_verbose && tracing_enabled();\n                }\n                CodeTracer::Scope* trace_scope() const { return trace_scope_; }\n                CodeTracer::Scope* verbose_trace_scope() const {\n                    return v8_flags.trace_deopt_verbose ? trace_scope() : nullptr;\n                }\n                void TraceDeoptBegin(int optimization_id, BytecodeOffset bytecode_offset);\n                void TraceDeoptEnd(double deopt_duration);\n#ifdef DEBUG\n                static void TraceFoundActivation(Isolate* isolate,\n                                                    Tagged<JSFunction> function);\n#endif\n                static void TraceDeoptAll(Isolate* isolate);\n\n                bool is_restart_frame() const { return restart_frame_index_ >= 0; }\n\n                Isolate* isolate_;\n                Tagged<JSFunction> function_;\n                Tagged<Code> compiled_code_;\n#if V8_ENABLE_WEBASSEMBLY\n                wasm::WasmCode* compiled_optimized_wasm_code_ = nullptr;\n#endif\n                unsigned deopt_exit_index_;\n                BytecodeOffset bytecode_offset_in_outermost_frame_ = BytecodeOffset::None();\n                DeoptimizeKind deopt_kind_;\n                Address from_;\n                int fp_to_sp_delta_;\n                bool deoptimizing_throw_;\n                int catch_handler_data_;\n                int catch_handler_pc_offset_;\n                int restart_frame_index_;\n\n                // Input frame description.\n                FrameDescription* input_;\n                // Number of output frames.\n                int output_count_;\n                // Array of output frame descriptions.\n                FrameDescription** output_;\n\n                // Caller frame details computed from input frame.\n                intptr_t caller_frame_top_;\n                intptr_t caller_fp_;\n                intptr_t caller_pc_;\n                intptr_t caller_constant_pool_;\n\n                // The argument count of the bottom most frame.\n                int actual_argument_count_;\n\n                // Key for lookup of previously materialized objects.\n                intptr_t stack_fp_;\n\n                TranslatedState translated_state_;\n                struct ValueToMaterialize {\n                    Address output_slot_address_;\n                    TranslatedFrame::iterator value_;\n                };\n                std::vector<ValueToMaterialize> values_to_materialize_;\n                std::vector<ValueToMaterialize> feedback_vector_to_materialize_;\n\n#ifdef V8_ENABLE_CET_SHADOW_STACK\n                intptr_t* shadow_stack_ = nullptr;\n                size_t shadow_stack_count_ = 0;\n#endif  // V8_ENABLE_CET_SHADOW_STACK\n\n#ifdef DEBUG\n                DisallowGarbageCollection* disallow_garbage_collection_;\n#endif  // DEBUG\n\n                // Note: This is intentionally not a unique_ptr s.t. the Deoptimizer\n                // satisfies is_standard_layout, needed for offsetof().\n                CodeTracer::Scope* const trace_scope_;\n\n#if V8_ENABLE_WEBASSEMBLY && V8_TARGET_ARCH_32_BIT\n                // Needed by webassembly for lowering signatures containing i64 types. Stored\n                // as members for reuse for multiple signatures during one de-optimization.\n                std::optional<AccountingAllocator> alloc_;\n                std::optional<Zone> zone_;\n#endif\n#if V8_ENABLE_WEBASSEMBLY && V8_ENABLE_SANDBOX\n                // Wasm deoptimizations should not access the heap at all. All deopt data is\n                // stored off-heap.\n                std::optional<SandboxHardwareSupport::BlockAccessScope>\n                    no_heap_access_during_wasm_deopt_;\n#endif\n\n                friend class DeoptimizedFrameInfo;\n                friend class FrameDescription;\n                friend class FrameWriter;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"DeoptInfo\",\n                \"about\": \"Structure to hold information about a deoptimization point, including its position in the source code, the reason for deoptimization, the node ID, and the deoptimization ID.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"position\",\n                        \"type\": \"SourcePosition\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The position in the source code where the deoptimization occurred.\"\n                    },\n                    {\n                        \"name\": \"deopt_reason\",\n                        \"type\": \"DeoptimizeReason\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The reason why the deoptimization occurred.\"\n                    },\n                    {\n                        \"name\": \"node_id\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The ID of the node in the abstract syntax tree (AST) where the deoptimization occurred.\"\n                    },\n                    {\n                        \"name\": \"deopt_id\",\n                        \"type\": \"int\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The ID of the deoptimization point.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"SourcePosition\",\n                    \"DeoptimizeReason\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct DeoptInfo {\n                DeoptInfo(SourcePosition position, DeoptimizeReason deopt_reason,\n                          uint32_t node_id, int deopt_id)\n                    : position(position),\n                      deopt_reason(deopt_reason),\n                      node_id(node_id),\n                      deopt_id(deopt_id) {}\n\n                const SourcePosition position;\n                const DeoptimizeReason deopt_reason;\n                const uint32_t node_id;\n                const int deopt_id;\n            };\n        ]]></code>\n    </class>\n</file>\n```"
}