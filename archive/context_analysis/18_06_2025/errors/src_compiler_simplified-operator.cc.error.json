{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-operator.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-operator.cc\",\n            \"file_name\": \"simplified-operator.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the Simplified operators used in the Turbofan compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for the compiler and other utilities\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/simplified-operator.h\"\n\n#include \"include/v8-fast-api-calls.h\"\n#include \"src/base/lazy-instance.h\"\n#include \"src/base/logging.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operator.h\"\n#include \"src/compiler/turbofan-types.h\"\n#include \"src/handles/handles-inl.h\"  // for operator<<\n#include \"src/objects/feedback-cell.h\"\n#include \"src/objects/map.h\"\n#include \"src/objects/name.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/compiler/wasm-compiler-definitions.h\"\n#endif\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"hash_value\",\n                \"about\": \"Specialization of std::hash for BaseTaggedness enum\",\n                \"logic\": \"Casts the enum to its underlying integer representation for hashing.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"base_taggedness\",\n                        \"type\": \"BaseTaggedness\",\n                        \"purpose\": \"The enum value to hash\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The hash value of the BaseTaggedness value\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nsize_t hash_value(BaseTaggedness base_taggedness) {\n  return static_cast<uint8_t>(base_taggedness);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the stream insertion operator for BaseTaggedness enum\",\n                \"logic\": \"Provides a string representation of the enum value for debugging purposes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream\"\n                    },\n                    {\n                        \"name\": \"base_taggedness\",\n                        \"type\": \"BaseTaggedness\",\n                        \"purpose\": \"The enum value to print\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, BaseTaggedness base_taggedness) {\n  switch (base_taggedness) {\n    case kUntaggedBase:\n      return os << \"untagged base\";\n    case kTaggedBase:\n      return os << \"tagged base\";\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the stream insertion operator for ConstFieldInfo struct\",\n                \"logic\": \"Prints the ConstFieldInfo. If the field is constant, it also prints the brief description of the owner map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream\"\n                    },\n                    {\n                        \"name\": \"const_field_info\",\n                        \"type\": \"ConstFieldInfo const&\",\n                        \"purpose\": \"The ConstFieldInfo struct to print\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream\"\n                },\n                \"dependencies\": [\n                    \"Brief\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os,\n                         ConstFieldInfo const& const_field_info) {\n  if (const_field_info.IsConst()) {\n    return os << \"const (field owner: \"\n              << Brief(*const_field_info.owner_map->object()) << \")\";\n  } else {\n    return os << \"mutable\";\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Overloads the equality operator for ConstFieldInfo struct\",\n                \"logic\": \"Compares two ConstFieldInfo structs based on their owner map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"ConstFieldInfo const&\",\n                        \"purpose\": \"The left-hand side ConstFieldInfo\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"ConstFieldInfo const&\",\n                        \"purpose\": \"The right-hand side ConstFieldInfo\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the ConstFieldInfo structs are equal, false otherwise\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool operator==(ConstFieldInfo const& lhs, ConstFieldInfo const& rhs) {\n  return lhs.owner_map == rhs.owner_map;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"hash_value\",\n                \"about\": \"Specialization of std::hash for ConstFieldInfo struct\",\n                \"logic\": \"Hashes the owner map of the ConstFieldInfo struct.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"const_field_info\",\n                        \"type\": \"ConstFieldInfo const&\",\n                        \"purpose\": \"The ConstFieldInfo struct to hash\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The hash value of the ConstFieldInfo struct\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nsize_t hash_value(ConstFieldInfo const& const_field_info) {\n  return hash_value(const_field_info.owner_map);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Overloads the equality operator for FieldAccess struct\",\n                \"logic\": \"Compares two FieldAccess structs based on their properties, excluding the write barrier kind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"FieldAccess const&\",\n                        \"purpose\": \"The left-hand side FieldAccess\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"FieldAccess const&\",\n                        \"purpose\": \"The right-hand side FieldAccess\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the FieldAccess structs are equal, false otherwise\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool operator==(FieldAccess const& lhs, FieldAccess const& rhs) {\n  // On purpose we don't include the write barrier kind here, as this method is\n  // really only relevant for eliminating loads and they don't care about the\n  // write barrier mode.\n  return lhs.base_is_tagged == rhs.base_is_tagged && lhs.offset == rhs.offset &&\n         lhs.map == rhs.map && lhs.machine_type == rhs.machine_type &&\n         lhs.const_field_info == rhs.const_field_info &&\n         lhs.is_store_in_literal == rhs.is_store_in_literal;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"hash_value\",\n                \"about\": \"Specialization of std::hash for FieldAccess struct\",\n                \"logic\": \"Hashes the properties of the FieldAccess struct, excluding the write barrier kind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"access\",\n                        \"type\": \"FieldAccess const&\",\n                        \"purpose\": \"The FieldAccess struct to hash\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The hash value of the FieldAccess struct\"\n                },\n                \"dependencies\": [\n                    \"base::hash_combine\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nsize_t hash_value(FieldAccess const& access) {\n  // On purpose we don't include the write barrier kind here, as this method is\n  // really only relevant for eliminating loads and they don't care about the\n  // write barrier mode.\n  return base::hash_combine(access.base_is_tagged, access.offset,\n                            access.machine_type, access.const_field_info,\n                            access.is_store_in_literal);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the stream insertion operator for FieldAccess struct\",\n                \"logic\": \"Prints detailed information about the FieldAccess struct, including flags and other properties\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream\"\n                    },\n                    {\n                        \"name\": \"access\",\n                        \"type\": \"FieldAccess const&\",\n                        \"purpose\": \"The FieldAccess struct to print\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream\"\n                },\n                \"dependencies\": [\n                    \"Brief\",\n                    \"Name::NamePrint\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, FieldAccess const& access) {\n  os << \"[\";\n  if (access.creator_mnemonic != nullptr) {\n    os << access.creator_mnemonic << \", \";\n  }\n  os << access.base_is_tagged << \", \" << access.offset << \", \";\n#ifdef OBJECT_PRINT\n  Handle<Name> name;\n  if (access.name.ToHandle(&name)) {\n    name->NamePrint(os);\n    os << \", \";\n  }\n  if (access.map.has_value()) {\n    os << Brief(*access.map->object()) << \", \";\n  }\n#endif\n  os << access.type << \", \" << access.machine_type << \", \"\n     << access.write_barrier_kind << \", \" << access.const_field_info;\n  if (access.is_store_in_literal) {\n    os << \" (store in literal)\";\n  }\n  if (access.maybe_initializing_or_transitioning_store) {\n    os << \" (initializing or transitioning store)\";\n  }\n  os << \"]\";\n  return os;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PrintParameter\",\n                \"parent\": \"Operator1<FieldAccess>\",\n                \"about\": \"Prints the field access parameter of an operator, either verbosely or with a short offset notation.\",\n                \"logic\": \"Prints the field access information, either the full information or just the offset.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"Output stream for printing\"\n                    },\n                    {\n                        \"name\": \"verbose\",\n                        \"type\": \"PrintVerbosity\",\n                        \"purpose\": \"Verbosity level for printing\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"parameter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <>\nvoid Operator1<FieldAccess>::PrintParameter(std::ostream& os,\n                                            PrintVerbosity verbose) const {\n  if (verbose == PrintVerbosity::kVerbose) {\n    os << parameter();\n  } else {\n    os << \"[+\" << parameter().offset << \"]\";\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Overloads the equality operator for ElementAccess struct\",\n                \"logic\": \"Compares two ElementAccess structs based on their properties, excluding the write barrier kind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"ElementAccess const&\",\n                        \"purpose\": \"The left-hand side ElementAccess\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"ElementAccess const&\",\n                        \"purpose\": \"The right-hand side ElementAccess\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the ElementAccess structs are equal, false otherwise\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool operator==(ElementAccess const& lhs, ElementAccess const& rhs) {\n  // On purpose we don't include the write barrier kind here, as this method is\n  // really only relevant for eliminating loads and they don't care about the\n  // write barrier mode.\n  return lhs.base_is_tagged == rhs.base_is_tagged &&\n         lhs.header_size == rhs.header_size &&\n         lhs.machine_type == rhs.machine_type;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"hash_value\",\n                \"about\": \"Specialization of std::hash for ElementAccess struct\",\n                \"logic\": \"Hashes the properties of the ElementAccess struct, excluding the write barrier kind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"access\",\n                        \"type\": \"ElementAccess const&\",\n                        \"purpose\": \"The ElementAccess struct to hash\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The hash value of the ElementAccess struct\"\n                },\n                \"dependencies\": [\n                    \"base::hash_combine\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nsize_t hash_value(ElementAccess const& access) {\n  // On purpose we don't include the write barrier kind here, as this method is\n  // really only relevant for eliminating loads and they don't care about the\n  // write barrier mode.\n  return base::hash_combine(access.base_is_tagged, access.header_size,\n                            access.machine_type);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the stream insertion operator for ElementAccess struct\",\n                \"logic\": \"Prints information about the ElementAccess struct.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream\"\n                    },\n                    {\n                        \"name\": \"access\",\n                        \"type\": \"ElementAccess const&\",\n                        \"purpose\": \"The ElementAccess struct to print\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, ElementAccess const& access) {\n  os << access.base_is_tagged << \", \" << access.header_size << \", \"\n     << access.type << \", \" << access.machine_type << \", \"\n     << access.write_barrier_kind;\n  return os;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Overloads the equality operator for ObjectAccess struct\",\n                \"logic\": \"Compares two ObjectAccess structs based on their machine type and write barrier kind.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"ObjectAccess const&\",\n                        \"purpose\": \"The left-hand side ObjectAccess\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"ObjectAccess const&\",\n                        \"purpose\": \"The right-hand side ObjectAccess\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the ObjectAccess structs are equal, false otherwise\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool operator==(ObjectAccess const& lhs, ObjectAccess const& rhs) {\n  return lhs.machine_type == rhs.machine_type &&\n         lhs.write_barrier_kind == rhs.write_barrier_kind;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"hash_value\",\n                \"about\": \"Specialization of std::hash for ObjectAccess struct\",\n                \"logic\": \"Hashes the machine type and write barrier kind of the ObjectAccess struct.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"access\",\n                        \"type\": \"ObjectAccess const&\",\n                        \"purpose\": \"The ObjectAccess struct to hash\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The hash value of the ObjectAccess struct\"\n                },\n                \"dependencies\": [\n                    \"base::hash_combine\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nsize_t hash_value(ObjectAccess const& access) {\n  return base::hash_combine(access.machine_type, access.write_barrier_kind);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the stream insertion operator for ObjectAccess struct\",\n                \"logic\": \"Prints information about the ObjectAccess struct.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream\"\n                    },\n                    {\n                        \"name\": \"access\",\n                        \"type\": \"ObjectAccess const&\",\n                        \"purpose\": \"The ObjectAccess struct to print\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& os, ObjectAccess const& access) {\n  os << access.machine_type << \", \" << access.write_barrier_kind;\n  return os;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Overloads the equality operator for WasmFieldInfo struct\",\n                \"logic\": \"Compares two WasmFieldInfo structs based on their field index, type, signedness and null check.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"WasmFieldInfo const&\",\n                        \"purpose\": \"The left-hand side WasmFieldInfo\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"WasmFieldInfo const&\",\n                        \"purpose\": \"The right-hand side WasmFieldInfo\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the WasmFieldInfo structs are equal, false otherwise\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\n\nV8_EXPORT_PRIVATE bool operator==(WasmFieldInfo const& lhs,\n                                  WasmFieldInfo const& rhs) {\n  return lhs.field_index == rhs.field_index && lhs.type == rhs.type &&\n         lhs.is_signed == rhs.is_signed && lhs.null_check == rhs.null_check;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"hash_value\",\n                \"about\": \"Specialization of std::hash for WasmFieldInfo struct\",\n                \"logic\": \"Hashes the field index, type, signedness and null check of the WasmFieldInfo struct.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"info\",\n                        \"type\": \"WasmFieldInfo const&\",\n                        \"purpose\": \"The WasmFieldInfo struct to hash\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The hash value of the WasmFieldInfo struct\"\n                },\n                \"dependencies\": [\n                    \"base::hash_combine\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nsize_t hash_value(WasmFieldInfo const& info) {\n  return base::hash_combine(info.field_index, info.type, info.is_signed,\n                            info.null_check);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the stream insertion operator for WasmFieldInfo struct\",\n                \"logic\": \"Prints information about the WasmFieldInfo struct.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream\"\n                    },\n                    {\n                        \"name\": \"info\",\n                        \"type\": \"WasmFieldInfo const&\",\n                        \"purpose\": \"The WasmFieldInfo struct to print\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nV8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os,\n                                           WasmFieldInfo const& info) {\n  return os << info.field_index << \", \"\n            << (info.is_signed ? \"signed\" : \"unsigned\") << \", \"\n            << (info.null_check == kWithNullCheck ? \"null check\"\n                                                  : \"no null check\");\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator==\",\n                \"about\": \"Overloads the equality operator for WasmElementInfo struct\",\n                \"logic\": \"Compares two WasmElementInfo structs based on their type and signedness.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"WasmElementInfo const&\",\n                        \"purpose\": \"The left-hand side WasmElementInfo\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"WasmElementInfo const&\",\n                        \"purpose\": \"The right-hand side WasmElementInfo\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the WasmElementInfo structs are equal, false otherwise\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nV8_EXPORT_PRIVATE bool operator==(WasmElementInfo const& lhs,\n                                  WasmElementInfo const& rhs) {\n  return lhs.type == rhs.type && lhs.is_signed == rhs.is_signed;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"hash_value\",\n                \"about\": \"Specialization of std::hash for WasmElementInfo struct\",\n                \"logic\": \"Hashes the type and signedness of the WasmElementInfo struct.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"info\",\n                        \"type\": \"WasmElementInfo const&\",\n                        \"purpose\": \"The WasmElementInfo struct to hash\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"size_t\",\n                    \"description\": \"The hash value of the WasmElementInfo struct\"\n                },\n                \"dependencies\": [\n                    \"base::hash_combine\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nsize_t hash_value(WasmElementInfo const& info) {\n  return base::hash_combine(info.type, info.is_signed);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"operator<<\",\n                \"about\": \"Overloads the stream insertion operator for WasmElementInfo struct\",\n                \"logic\": \"Prints information about the WasmElementInfo struct (signedness).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"os\",\n                        \"type\": \"std::ostream&\",\n                        \"purpose\": \"The output stream\"\n                    },\n                    {\n                        \"name\": \"info\",\n                        \"type\": \"WasmElementInfo const&\",\n                        \"purpose\": \"The WasmElementInfo struct to print\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"std::ostream&\",\n                    \"description\": \"The output stream\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nV8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os,\n                                           WasmElementInfo const& info) {\n  return os << (info.is_signed ? \"signed\" : \"unsigned\");\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"FieldAccessOf\",\n                \"about\": \"Retrieves the FieldAccess struct from an Operator\",\n                \"logic\": \"Ensures that the operator is a LoadField or StoreField, and returns the associated FieldAccess struct\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The operator from which to retrieve the FieldAccess\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const FieldAccess&\",\n                    \"description\": \"The FieldAccess struct associated with the Operator\"\n                },\n                \"dependencies\": [\n                    \"OpParameter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n#endif\n\nconst FieldAccess& FieldAccessOf(const Operator* op) {\n  DCHECK_NOT_NULL(op);\n  DCHECK(op->opcode() == IrOpcode::kLoadField ||\n         op->opcode() == IrOpcode::kStoreField);\n  return OpParameter<FieldAccess>(op);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ElementAccessOf\",\n                \"about\": \"Retrieves the ElementAccess struct from an Operator\",\n                \"logic\": \"Ensures that the operator is a LoadElement or StoreElement, and returns the associated ElementAccess struct\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The operator from which to retrieve the ElementAccess\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const ElementAccess&\",\n                    \"description\": \"The ElementAccess struct associated with the Operator\"\n                },\n                \"dependencies\": [\n                    \"OpParameter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconst ElementAccess& ElementAccessOf(const Operator* op) {\n  DCHECK_NOT_NULL(op);\n  DCHECK(op->opcode() == IrOpcode::kLoadElement ||\n         op->opcode() == IrOpcode::kStoreElement);\n  return OpParameter<ElementAccess>(op);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ObjectAccessOf\",\n                \"about\": \"Retrieves the ObjectAccess struct from an Operator\",\n                \"logic\": \"Ensures that the operator is a LoadFromObject, LoadImmutableFromObject, StoreToObject, or InitializeImmutableInObject, and returns the associated ObjectAccess struct\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The operator from which to retrieve the ObjectAccess\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"const ObjectAccess&\",\n                    \"description\": \"The ObjectAccess struct associated with the Operator\"\n                },\n                \"dependencies\": [\n                    \"OpParameter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nconst ObjectAccess& ObjectAccessOf(const Operator* op) {\n  DCHECK_NOT_NULL(op);\n  DCHECK(op->opcode() == IrOpcode::kLoadFromObject ||\n         op->opcode() == IrOpcode::kLoadImmutableFromObject ||\n         op->opcode() == IrOpcode::kStoreToObject ||\n         op->opcode() == IrOpcode::kInitializeImmutableInObject);\n  return OpParameter<ObjectAccess>(op);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ExternalArrayTypeOf\",\n                \"about\": \"Retrieves the ExternalArrayType enum value from an Operator\",\n                \"logic\": \"Ensures that the operator is a LoadTypedElement, LoadDataViewElement, StoreTypedElement or StoreDataViewElement, and returns the associated ExternalArrayType enum value\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The operator from which to retrieve the ExternalArrayType\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ExternalArrayType\",\n                    \"description\": \"The ExternalArrayType enum value associated with the Operator\"\n                },\n                \"dependencies\": [\n                    \"OpParameter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nExternalArrayType ExternalArrayTypeOf(const Operator* op) {\n  DCHECK(op->opcode() == IrOpcode::kLoadTypedElement ||\n         op->opcode() == IrOpcode::kLoadDataViewElement ||\n         op->opcode() == IrOpcode::kStoreTypedElement ||\n         op->opcode() == IrOpcode::kStoreDataViewElement);\n  return OpParameter<ExternalArrayType>(op);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ConvertReceiverModeOf\",\n                \"about\": \"Retrieves the ConvertReceiverMode enum value from an Operator\",\n                \"logic\": \"Ensures that the operator is a ConvertReceiver, and returns the associated ConvertReceiverMode enum value\",\n                \"parameters\": [\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"Operator const*\",\n                        \"purpose\": \"The operator from which to retrieve the ConvertReceiverMode\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"ConvertReceiverMode\",\n                    \"description\": \"The ConvertReceiverMode enum value associated with the Operator\"\n                },\n                \"dependencies\": [\n                    \"OpParameter\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nConvertReceiverMode ConvertReceiverModeOf(Operator const* op) {\n  DCHECK_EQ(IrOpcode::kConvertReceiver, op->opcode());\n  return OpParameter<ConvertReceiverMode>(op);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"hash_value\",\n                \"about\": \"Specialization of std::hash for CheckFloat64HoleMode enum"
}