{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/cc-generator.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/cc-generator.cc\",\n        \"file_name\": \"cc-generator.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Generates C++ code from Torque intermediate representation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for C++ code generation.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/torque/cc-generator.h\"\n\n            #include <optional>\n\n            #include \"src/common/globals.h\"\n            #include \"src/torque/global-context.h\"\n            #include \"src/torque/type-oracle.h\"\n            #include \"src/torque/types.h\"\n            #include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitGraph\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits the C++ code for a given control flow graph (CFG).\",\n            \"logic\": \"Iterates through the CFG blocks, emitting code for each block. It redirects output to a buffer initially to ensure declarations are printed first. Returns the stack if the end block exists, otherwise returns an empty optional.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parameters\",\n                    \"type\": \"Stack<std::string>\",\n                    \"purpose\": \"The initial stack of parameters for the graph.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::optional<Stack<std::string>>\",\n                \"description\": \"The stack at the end of the graph, if an end block exists, otherwise an empty optional.\"\n            },\n            \"dependencies\": [\n                \"Block\",\n                \"GotoInstruction\",\n                \"EmitInstruction\",\n                \"EmitBlock\",\n                \"SetDefinitionVariable\",\n                \"DefinitionLocation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::optional<Stack<std::string>> CCGenerator::EmitGraph(\n                Stack<std::string> parameters) {\n              for (BottomOffset i = {0}; i < parameters.AboveTop(); ++i) {\n                SetDefinitionVariable(DefinitionLocation::Parameter(i.offset),\n                                      parameters.Peek(i));\n              }\n\n              // Redirect the output of non-declarations into a buffer and only output\n              // declarations right away.\n              std::stringstream out_buffer;\n              std::ostream* old_out = out_;\n              out_ = &out_buffer;\n\n              EmitInstruction(GotoInstruction{cfg_.start()}, &parameters);\n\n              for (Block* block : cfg_.blocks()) {\n                if (cfg_.end() && *cfg_.end() == block) continue;\n                if (block->IsDead()) continue;\n                EmitBlock(block);\n              }\n\n              std::optional<Stack<std::string>> result;\n              if (cfg_.end()) {\n                result = EmitBlock(*cfg_.end());\n              }\n\n              // All declarations have been printed now, so we can append the buffered\n              // output and redirect back to the original output stream.\n              out_ = old_out;\n              out() << out_buffer.str();\n\n              return result;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitBlock\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a single block in the CFG.\",\n            \"logic\": \"Iterates through the instructions in the block, emitting code for each instruction. Manages a stack to track values.\",\n            \"parameters\": [\n                {\n                    \"name\": \"block\",\n                    \"type\": \"const Block*\",\n                    \"purpose\": \"The block to emit code for.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Stack<std::string>\",\n                \"description\": \"The stack at the end of the block.\"\n            },\n            \"dependencies\": [\n                \"TorqueCodeGenerator::EmitInstruction\",\n                \"BlockName\",\n                \"InputTypes\",\n                \"InputDefinitions\",\n                \"DefinitionToVariable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Stack<std::string> CCGenerator::EmitBlock(const Block* block) {\n              out() << \"\\n\";\n              out() << \"  \" << BlockName(block) << \":\\n\";\n\n              Stack<std::string> stack;\n\n              for (BottomOffset i = {0}; i < block->InputTypes().AboveTop(); ++i) {\n                const auto& def = block->InputDefinitions().Peek(i);\n                stack.Push(DefinitionToVariable(def));\n                if (def.IsPhiFromBlock(block)) {\n                  decls() << \"  \"\n                          << (is_cc_debug_ ? block->InputTypes().Peek(i)->GetDebugType()\n                                           : block->InputTypes().Peek(i)->GetRuntimeType())\n                          << \" \" << stack.Top() << \"{}; USE(\" << stack.Top() << \");\\n\";\n                }\n              }\n\n              for (const Instruction& instruction : block->instructions()) {\n                TorqueCodeGenerator::EmitInstruction(instruction, &stack);\n              }\n              return stack;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitSourcePosition\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits a source position marker in the C++ code.\",\n            \"logic\": \"Checks if the source position has changed since the last emitted position to avoid redundant output.\",\n            \"parameters\": [\n                {\n                    \"name\": \"pos\",\n                    \"type\": \"SourcePosition\",\n                    \"purpose\": \"The source position to emit.\"\n                },\n                {\n                    \"name\": \"always_emit\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether to always emit the position, even if it hasn't changed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"SourceFileMap::AbsolutePath\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitSourcePosition(SourcePosition pos, bool always_emit) {\n              const std::string& file = SourceFileMap::AbsolutePath(pos.source);\n              if (always_emit || !previous_position_.CompareStartIgnoreColumn(pos)) {\n                // Lines in Torque SourcePositions are zero-based, while the\n                // CodeStubAssembler and downwind systems are one-based.\n                out() << \"  // \" << file << \":\" << (pos.start.line + 1) << \"\\n\";\n                previous_position_ = pos;\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a PushUninitializedInstruction, which is not supported in C++ output.\",\n            \"logic\": \"Reports an error indicating that PushUninitialized is not supported.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const PushUninitializedInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(\n                const PushUninitializedInstruction& instruction,\n                Stack<std::string>* stack) {\n              ReportError(\"Not supported in C++ output: PushUninitialized\");\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a PushBuiltinPointerInstruction, which is not supported in C++ output.\",\n            \"logic\": \"Reports an error indicating that PushBuiltinPointer is not supported.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const PushBuiltinPointerInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(\n                const PushBuiltinPointerInstruction& instruction,\n                Stack<std::string>* stack) {\n              ReportError(\"Not supported in C++ output: PushBuiltinPointer\");\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a NamespaceConstantInstruction, which is not supported in C++ output.\",\n            \"logic\": \"Reports an error indicating that NamespaceConstantInstruction is not supported.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const NamespaceConstantInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(\n                const NamespaceConstantInstruction& instruction,\n                Stack<std::string>* stack) {\n              ReportError(\"Not supported in C++ output: NamespaceConstantInstruction\");\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ProcessArgumentsCommon\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Processes the arguments for a function call, handling both constexpr and non-constexpr arguments.\",\n            \"logic\": \"Iterates through the parameter types, popping values from the stack or the constexpr arguments vector as needed.  Constructs a vector of argument strings.\",\n            \"parameters\": [\n                {\n                    \"name\": \"parameter_types\",\n                    \"type\": \"const TypeVector&\",\n                    \"purpose\": \"The types of the parameters to the function.\"\n                },\n                {\n                    \"name\": \"constexpr_arguments\",\n                    \"type\": \"std::vector<std::string>\",\n                    \"purpose\": \"The constexpr arguments to the function.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::vector<std::string>\",\n                \"description\": \"A vector of argument strings.\"\n            },\n            \"dependencies\": [\n                \"LoweredSlotCount\",\n                \"VisitResult\",\n                \"EmitCCValue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::vector<std::string> CCGenerator::ProcessArgumentsCommon(\n                const TypeVector& parameter_types,\n                std::vector<std::string> constexpr_arguments, Stack<std::string>* stack) {\n              std::vector<std::string> args;\n              for (auto it = parameter_types.rbegin(); it != parameter_types.rend(); ++it) {\n                const Type* type = *it;\n                if (type->IsConstexpr()) {\n                  args.push_back(std::move(constexpr_arguments.back()));\n                  constexpr_arguments.pop_back();\n                } else {\n                  std::stringstream s;\n                  size_t slot_count = LoweredSlotCount(type);\n                  VisitResult arg = VisitResult(type, stack->TopRange(slot_count));\n                  EmitCCValue(arg, *stack, s);\n                  args.push_back(s.str());\n                  stack->PopMany(slot_count);\n                }\n              }\n              std::reverse(args.begin(), args.end());\n              return args;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a CallIntrinsicInstruction.\",\n            \"logic\": \"Processes arguments, prepares the call, and handles intrinsic-specific logic (e.g., %RawDownCast, %GetClassMapConstant, %FromConstexpr).\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const CallIntrinsicInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ProcessArgumentsCommon\",\n                \"LowerType\",\n                \"DefinitionToVariable\",\n                \"PrintCommaSeparatedList\",\n                \"TypeOracle::GetUninitializedHeapObjectType\",\n                \"TypeOracle::GetHeapObjectType\",\n                \"TypeOracle::GetSmiType\",\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(const CallIntrinsicInstruction& instruction,\n                                              Stack<std::string>* stack) {\n              TypeVector parameter_types =\n                  instruction.intrinsic->signature().parameter_types.types;\n              std::vector<std::string> args = ProcessArgumentsCommon(\n                  parameter_types, instruction.constexpr_arguments, stack);\n\n              Stack<std::string> pre_call_stack = *stack;\n              const Type* return_type = instruction.intrinsic->signature().return_type;\n              std::vector<std::string> results;\n\n              const auto lowered = LowerType(return_type);\n              for (std::size_t i = 0; i < lowered.size(); ++i) {\n                results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));\n                stack->Push(results.back());\n                decls() << \"  \"\n                        << (is_cc_debug_ ? lowered[i]->GetDebugType()\n                                         : lowered[i]->GetRuntimeType())\n                        << \" \" << stack->Top() << \"{}; USE(\" << stack->Top() << \");\\n\";\n              }\n\n              out() << \"  \";\n              if (return_type->StructSupertype()) {\n                out() << \"std::tie(\";\n                PrintCommaSeparatedList(out(), results);\n                out() << \") = \";\n              } else {\n                if (results.size() == 1) {\n                  out() << results[0] << \" = \";\n                }\n              }\n\n              if (instruction.intrinsic->ExternalName() == \"%RawDownCast\") {\n                if (parameter_types.size() != 1) {\n                  ReportError(\"%RawDownCast must take a single parameter\");\n                }\n                const Type* original_type = parameter_types[0];\n                bool is_subtype =\n                    return_type->IsSubtypeOf(original_type) ||\n                    (original_type == TypeOracle::GetUninitializedHeapObjectType() &&\n                     return_type->IsSubtypeOf(TypeOracle::GetHeapObjectType()));\n                if (!is_subtype) {\n                  ReportError(\"%RawDownCast error: \", *return_type, \" is not a subtype of \",\n                              *original_type);\n                }\n                if (!original_type->StructSupertype() &&\n                    return_type->GetRuntimeType() != original_type->GetRuntimeType()) {\n                  out() << \"static_cast<\" << return_type->GetRuntimeType() << \">\";\n                }\n              } else if (instruction.intrinsic->ExternalName() == \"%GetClassMapConstant\") {\n                ReportError(\"C++ generator doesn't yet support %GetClassMapConstant\");\n              } else if (instruction.intrinsic->ExternalName() == \"%FromConstexpr\") {\n                if (parameter_types.size() != 1 || !parameter_types[0]->IsConstexpr()) {\n                  ReportError(\n                      \"%FromConstexpr must take a single parameter with constexpr \"\n                      \"type\");\n                }\n                if (return_type->IsConstexpr()) {\n                  ReportError(\"%FromConstexpr must return a non-constexpr type\");\n                }\n                if (return_type->IsSubtypeOf(TypeOracle::GetSmiType())) {\n                  if (is_cc_debug_) {\n                    out() << \"Internals::IntToSmi\";\n                  } else {\n                    out() << \"Smi::FromInt\";\n                  }\n                }\n                // Wrap the raw constexpr value in a static_cast to ensure that\n                // enums get properly casted to their backing integral value.\n                out() << \"(CastToUnderlyingTypeIfEnum\";\n              } else {\n                ReportError(\"no built in intrinsic with name \" +\n                            instruction.intrinsic->ExternalName());\n              }\n\n              out() << \"(\";\n              PrintCommaSeparatedList(out(), args);\n              if (instruction.intrinsic->ExternalName() == \"%FromConstexpr\") {\n                out() << \")\";\n              }\n              out() << \");\\n\";\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a CallCsaMacroInstruction.\",\n            \"logic\": \"Processes arguments, prepares the call to a CSA macro, handles return values. Asserts that calls requiring complex control flow have been inlined.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const CallCsaMacroInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ProcessArgumentsCommon\",\n                \"LowerType\",\n                \"DefinitionToVariable\",\n                \"PrintCommaSeparatedList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(const CallCsaMacroInstruction& instruction,\n                                              Stack<std::string>* stack) {\n              TypeVector parameter_types =\n                  instruction.macro->signature().parameter_types.types;\n              std::vector<std::string> args = ProcessArgumentsCommon(\n                  parameter_types, instruction.constexpr_arguments, stack);\n\n              Stack<std::string> pre_call_stack = *stack;\n              const Type* return_type = instruction.macro->signature().return_type;\n              std::vector<std::string> results;\n\n              const auto lowered = LowerType(return_type);\n              for (std::size_t i = 0; i < lowered.size(); ++i) {\n                results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));\n                stack->Push(results.back());\n                decls() << \"  \"\n                        << (is_cc_debug_ ? lowered[i]->GetDebugType()\n                                         : lowered[i]->GetRuntimeType())\n                        << \" \" << stack->Top() << \"{}; USE(\" << stack->Top() << \");\\n\";\n              }\n\n              // We should have inlined any calls requiring complex control flow.\n              CHECK(!instruction.catch_block);\n              out() << (is_cc_debug_ ? \"  ASSIGN_OR_RETURN(\" : \"  \");\n              if (return_type->StructSupertype().has_value()) {\n                out() << \"std::tie(\";\n                PrintCommaSeparatedList(out(), results);\n                out() << (is_cc_debug_ ? \"), \" : \") = \");\n              } else {\n                if (results.size() == 1) {\n                  out() << results[0] << (is_cc_debug_ ? \", \" : \" = \");\n                } else {\n                  DCHECK_EQ(0, results.size());\n                }\n              }\n\n              if (is_cc_debug_) {\n                out() << instruction.macro->CCDebugName() << \"(accessor\";\n                if (!args.empty()) out() << \", \";\n              } else {\n                out() << instruction.macro->CCName() << \"(\";\n              }\n              PrintCommaSeparatedList(out(), args);\n              if (is_cc_debug_) {\n                out() << \"));\\n\";\n              } else {\n                out() << \");\\n\";\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a CallCsaMacroAndBranchInstruction, which is not supported in C++ output.\",\n            \"logic\": \"Reports an error indicating that CallCsaMacroAndBranch is not supported.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const CallCsaMacroAndBranchInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(\n                const CallCsaMacroAndBranchInstruction& instruction,\n                Stack<std::string>* stack) {\n              ReportError(\"Not supported in C++ output: CallCsaMacroAndBranch\");\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a MakeLazyNodeInstruction, which is not supported in C++ output.\",\n            \"logic\": \"Reports an error indicating that MakeLazyNode is not supported.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const MakeLazyNodeInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(const MakeLazyNodeInstruction& instruction,\n                                              Stack<std::string>* stack) {\n              ReportError(\"Not supported in C++ output: MakeLazyNode\");\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a CallBuiltinInstruction, which is not supported in C++ output.\",\n            \"logic\": \"Reports an error indicating that CallBuiltin is not supported.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const CallBuiltinInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(const CallBuiltinInstruction& instruction,\n                                              Stack<std::string>* stack) {\n              ReportError(\"Not supported in C++ output: CallBuiltin\");\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a CallBuiltinPointerInstruction, which is not supported in C++ output.\",\n            \"logic\": \"Reports an error indicating that CallBuiltinPointer is not supported.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const CallBuiltinPointerInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(\n                const CallBuiltinPointerInstruction& instruction,\n                Stack<std::string>* stack) {\n              ReportError(\"Not supported in C++ output: CallBuiltinPointer\");\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a CallRuntimeInstruction, which is not supported in C++ output.\",\n            \"logic\": \"Reports an error indicating that CallRuntime is not supported.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const CallRuntimeInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReportError\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(const CallRuntimeInstruction& instruction,\n                                              Stack<std::string>* stack) {\n              ReportError(\"Not supported in C++ output: CallRuntime\");\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a BranchInstruction.\",\n            \"logic\": \"Emits an `if` statement that branches to the `if_true` block if the condition on the stack is true, and to the `if_false` block otherwise.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const BranchInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"EmitGoto\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(const BranchInstruction& instruction,\n                                              Stack<std::string>* stack) {\n              out() << \"  if (\" << stack->Pop() << \") {\\n\";\n              EmitGoto(instruction.if_true, stack, \"    \");\n              out() << \"  } else {\\n\";\n              EmitGoto(instruction.if_false, stack, \"    \");\n              out() << \"  }\\n\";\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a ConstexprBranchInstruction.\",\n            \"logic\": \"Emits an `if` statement that branches to the `if_true` block if the constexpr condition is true, and to the `if_false` block otherwise.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const ConstexprBranchInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"EmitGoto\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(const ConstexprBranchInstruction& instruction,\n                                              Stack<std::string>* stack) {\n              out() << \"  if ((\" << instruction.condition << \")) {\\n\";\n              EmitGoto(instruction.if_true, stack, \"    \");\n              out() << \"  } else {\\n\";\n              EmitGoto(instruction.if_false, stack, \"    \");\n              out() << \"  }\\n\";\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitGoto\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a `goto` statement to a specific block.\",\n            \"logic\": \"Copies values from the current stack to the input definitions of the destination block for phi variables, then emits the `goto` statement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"destination\",\n                    \"type\": \"const Block*\",\n                    \"purpose\": \"The destination block to jump to.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                },\n                {\n                    \"name\": \"indentation\",\n                    \"type\": \"std::string\",\n                    \"purpose\": \"The indentation string to use.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DefinitionToVariable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitGoto(const Block* destination, Stack<std::string>* stack,\n                                       std::string indentation) {\n              const auto& destination_definitions = destination->InputDefinitions();\n              DCHECK_EQ(stack->Size(), destination_definitions.Size());\n              for (BottomOffset i = {0}; i < stack->AboveTop(); ++i) {\n                DefinitionLocation def = destination_definitions.Peek(i);\n                if (def.IsPhiFromBlock(destination)) {\n                  out() << indentation << DefinitionToVariable(def) << \" = \"\n                        << stack->Peek(i) << \";\\n\";\n                }\n              }\n              out() << indentation << \"goto \" << BlockName(destination) << \";\\n\";\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EmitInstruction\",\n            \"parent\": \"CCGenerator\",\n            \"about\": \"Emits C++ code for a GotoInstruction.\",\n            \"logic\": \"Calls `EmitGoto` to emit the goto statement to the destination block.\",\n            \"parameters\": [\n                {\n                    \"name\": \"instruction\",\n                    \"type\": \"const GotoInstruction&\",\n                    \"purpose\": \"The instruction to emit.\"\n                },\n                {\n                    \"name\": \"stack\",\n                    \"type\": \"Stack<std::string>*\",\n                    \"purpose\": \"The current stack of values.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"EmitGoto\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CCGenerator::EmitInstruction(const GotoInstruction& instruction,\n                                              Stack<std::string>* stack) {\n              EmitGoto(instruction.destination, stack, \"  \");\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        "
}