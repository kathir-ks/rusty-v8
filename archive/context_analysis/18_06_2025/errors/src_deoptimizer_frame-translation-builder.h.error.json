{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/frame-translation-builder.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 106, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/deoptimizer/frame-translation-builder.h\",\n            \"file_name\": \"frame-translation-builder.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the FrameTranslationBuilder class for constructing deoptimization frame translations.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary standard library and V8 headers.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <optional>\n\n            #include \"src/codegen/register.h\"\n            #include \"src/deoptimizer/translation-opcode.h\"\n            #include \"src/objects/deoptimization-data.h\"\n            #include \"src/zone/zone-containers.h\"\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/wasm/value-type.h\"\n            #endif  // V8_ENABLE_WEBASSEMBLY\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FrameTranslationBuilder\",\n                \"about\": \"Builds deoptimization frame translations, which describe the layout of stack frames at deoptimization points.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"contents_\",\n                        \"type\": \"ZoneVector<uint8_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the translation data as a vector of bytes.\"\n                    },\n                    {\n                        \"name\": \"contents_for_compression_\",\n                        \"type\": \"ZoneVector<int32_t>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores translation data as a vector of int32_t when compression is enabled.\"\n                    },\n                    {\n                        \"name\": \"basis_instructions_\",\n                        \"type\": \"ZoneVector<Instruction>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores instructions from the basis translation for compression purposes.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The zone allocator used for memory management.\"\n                    },\n                    {\n                        \"name\": \"matching_instructions_count_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Counts consecutive matching instructions for compression.\"\n                    },\n                    {\n                        \"name\": \"total_matching_instructions_in_current_translation_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Counts total matching instructions in current translation for compression.\"\n                    },\n                    {\n                        \"name\": \"instruction_index_within_translation_\",\n                        \"type\": \"size_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracks the current instruction index within a translation.\"\n                    },\n                    {\n                        \"name\": \"index_of_basis_translation_start_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the starting index of the basis translation.\"\n                    },\n                    {\n                        \"name\": \"match_previous_allowed_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates if matching previous translations is allowed.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"LocalFactory\",\n                    \"DeoptimizationFrameTranslation\",\n                    \"BytecodeOffset\",\n                    \"TranslationOpcode\",\n                    \"Register\",\n                    \"FloatRegister\",\n                    \"DoubleRegister\",\n                    \"Simd128Register\",\n                    \"wasm::ValueKind\",\n                    \"DeoptTranslationIterator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class FrameTranslationBuilder {\n            public:\n            explicit FrameTranslationBuilder(Zone* zone)\n                : contents_(zone),\n                contents_for_compression_(zone),\n                basis_instructions_(zone),\n                zone_(zone) {}\n\n            DirectHandle<DeoptimizationFrameTranslation> ToFrameTranslation(\n                LocalFactory* factory);\n            base::Vector<const uint8_t> ToFrameTranslationWasm();\n\n            int BeginTranslation(int frame_count, int jsframe_count,\n                                 bool update_feedback);\n\n            void BeginInterpretedFrame(BytecodeOffset bytecode_offset, int literal_id,\n                                     int bytecode_array_id, unsigned height,\n                                     int return_value_offset, int return_value_count);\n            void BeginInlinedExtraArguments(int literal_id, unsigned height,\n                                          uint32_t parameter_count);\n            void BeginConstructCreateStubFrame(int literal_id, unsigned height);\n            void BeginConstructInvokeStubFrame(int literal_id);\n            void BeginBuiltinContinuationFrame(BytecodeOffset bailout_id, int literal_id,\n                                                unsigned height);\n            #if V8_ENABLE_WEBASSEMBLY\n            void BeginJSToWasmBuiltinContinuationFrame(\n                BytecodeOffset bailout_id, int literal_id, unsigned height,\n                std::optional<wasm::ValueKind> return_kind);\n            void BeginWasmInlinedIntoJSFrame(BytecodeOffset bailout_id, int literal_id,\n                                            unsigned height);\n            void BeginLiftoffFrame(BytecodeOffset bailout_id, unsigned height,\n                                 uint32_t wasm_function_index);\n            #endif  // V8_ENABLE_WEBASSEMBLY\n            void BeginJavaScriptBuiltinContinuationFrame(BytecodeOffset bailout_id,\n                                                        int literal_id, unsigned height);\n            void BeginJavaScriptBuiltinContinuationWithCatchFrame(\n                BytecodeOffset bailout_id, int literal_id, unsigned height);\n            void ArgumentsElements(CreateArgumentsType type);\n            void ArgumentsLength();\n            void RestLength();\n            void BeginCapturedObject(int length);\n            void AddUpdateFeedback(int vector_literal, int slot);\n            void DuplicateObject(int object_index);\n            void StringConcat();\n            void StoreRegister(TranslationOpcode opcode, Register reg);\n            void StoreRegister(Register reg);\n            void StoreInt32Register(Register reg);\n            void StoreInt64Register(Register reg);\n            void StoreIntPtrRegister(Register reg);\n            void StoreSignedBigInt64Register(Register reg);\n            void StoreUnsignedBigInt64Register(Register reg);\n            void StoreUint32Register(Register reg);\n            void StoreBoolRegister(Register reg);\n            void StoreFloatRegister(FloatRegister reg);\n            void StoreDoubleRegister(DoubleRegister reg);\n            void StoreHoleyDoubleRegister(DoubleRegister reg);\n            void StoreSimd128Register(Simd128Register reg);\n            void StoreStackSlot(int index);\n            void StoreInt32StackSlot(int index);\n            void StoreInt64StackSlot(int index);\n            void StoreIntPtrStackSlot(int index);\n            void StoreSignedBigInt64StackSlot(int index);\n            void StoreUnsignedBigInt64StackSlot(int index);\n            void StoreUint32StackSlot(int index);\n            void StoreBoolStackSlot(int index);\n            void StoreFloatStackSlot(int index);\n            void StoreDoubleStackSlot(int index);\n            void StoreSimd128StackSlot(int index);\n            void StoreHoleyDoubleStackSlot(int index);\n            void StoreLiteral(int literal_id);\n            void StoreOptimizedOut();\n            void StoreJSFrameFunction();\n\n            private:\n            struct Instruction {\n                template <typename... T>\n                explicit Instruction(TranslationOpcode opcode, T... operands)\n                    : opcode(opcode),\n                    operands{operands.value()...}\n            #ifdef ENABLE_SLOW_DCHECKS\n                    ,\n                    is_operand_signed{operands.IsSigned()...}\n            #endif\n                {\n                }\n                TranslationOpcode opcode;\n                // The operands for the instruction. Signed values were static_casted to\n                // unsigned.\n                uint32_t operands[kMaxTranslationOperandCount];\n            #ifdef ENABLE_SLOW_DCHECKS\n                bool is_operand_signed[kMaxTranslationOperandCount];\n            #endif\n            };\n\n            // Either adds the instruction or increments matching_instructions_count_,\n            // depending on whether the instruction matches the corresponding instruction\n            // from the previous translation.\n            template <typename... T>\n            void Add(TranslationOpcode opcode, T... operands);\n\n            // Adds the instruction to contents_, without performing the other steps of\n            // Add(). Requires !v8_flags.turbo_compress_frame_translations.\n            template <typename... T>\n            void AddRawToContents(TranslationOpcode opcode, T... operands);\n\n            // Adds the instruction to contents_for_compression_, without performing the\n            // other steps of Add(). Requires v8_flags.turbo_compress_frame_translations.\n            template <typename... T>\n            void AddRawToContentsForCompression(TranslationOpcode opcode, T... operands);\n\n            // Adds a BEGIN instruction to contents_ or contents_for_compression_, but\n            // does not update other state. Used by BeginTranslation.\n            template <typename... T>\n            void AddRawBegin(bool update_feedback, T... operands);\n\n            int Size() const {\n                return V8_UNLIKELY(v8_flags.turbo_compress_frame_translations)\n                    ? static_cast<int>(contents_for_compression_.size())\n                    : static_cast<int>(contents_.size());\n            }\n            int SizeInBytes() const {\n                return V8_UNLIKELY(v8_flags.turbo_compress_frame_translations)\n                    ? Size() * kInt32Size\n                    : Size();\n            }\n\n            Zone* zone() const { return zone_; }\n\n            void FinishPendingInstructionIfNeeded();\n            void ValidateBytes(DeoptTranslationIterator& iter) const;\n\n            ZoneVector<uint8_t> contents_;\n            ZoneVector<int32_t> contents_for_compression_;\n            // If match_previous_allowed_ is false, then this vector contains the\n            // instructions written so far in the current translation (since the last\n            // BEGIN). If match_previous_allowed_ is true, then this vector contains the\n            // instructions from the basis translation (the one written with\n            // !match_previous_allowed_). This allows Add() to easily check whether a\n            // newly added instruction matches the corresponding one from the basis\n            // translation.\n            ZoneVector<Instruction> basis_instructions_;\n            #ifdef ENABLE_SLOW_DCHECKS\n            std::vector<Instruction> all_instructions_;\n            #endif\n            Zone* const zone_;\n            // How many consecutive instructions we've skipped writing because they match\n            // the basis translation.\n            size_t matching_instructions_count_ = 0;\n            size_t total_matching_instructions_in_current_translation_ = 0;\n            // The current index within basis_instructions_.\n            size_t instruction_index_within_translation_ = 0;\n            // The byte index within the contents_ array of the BEGIN instruction for the\n            // basis translation (the most recent translation which was fully written out,\n            // not using MATCH_PREVIOUS_TRANSLATION instructions).\n            int index_of_basis_translation_start_ = 0;\n            // Whether the builder can use MATCH_PREVIOUS_TRANSLATION in the current\n            // translation.\n            bool match_previous_allowed_ = true;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalFactory\",\n                \"about\": \"Abstract dependency of FrameTranslationBuilder. Only declaration is known\"\n            }\n        </metadata>\n        <code><![CDATA[\n            class LocalFactory;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DeoptimizationFrameTranslation\",\n                \"about\": \"Abstract dependency of FrameTranslationBuilder. Only declaration is known\"\n            }\n        </metadata>\n        <code><![CDATA[\n            class DeoptimizationFrameTranslation;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BytecodeOffset\",\n                \"about\": \"Abstract dependency of FrameTranslationBuilder. Only declaration is known\"\n            }\n        </metadata>\n        <code><![CDATA[\n            class BytecodeOffset;\n        ]]></code>\n    </class>\n    <enum>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"CreateArgumentsType\",\n                \"about\": \"Enum used in ArgumentsElements method. Only declaration is known\"\n            }\n        </metadata>\n        <code><![CDATA[\n            enum class CreateArgumentsType;\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DeoptTranslationIterator\",\n                \"about\": \"Abstract dependency of FrameTranslationBuilder. Only declaration is known\"\n            }\n        </metadata>\n        <code><![CDATA[\n            class DeoptTranslationIterator;\n        ]]></code>\n    </class>\n</file>\n```"
}