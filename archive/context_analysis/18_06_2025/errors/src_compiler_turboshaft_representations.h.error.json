{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/representations.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/representations.h\",\n        \"file_name\": \"representations.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines representations used in the Turboshaft compiler, including register and memory representations.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for data types, hashing, logging, machine types, and utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <cstdint>\n\n#include \"include/v8-internal.h\"\n#include \"src/base/hashing.h\"\n#include \"src/base/logging.h\"\n#include \"src/codegen/machine-type.h\"\n#include \"src/compiler/turboshaft/utils.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MaybeRegisterRepresentation\",\n            \"about\": \"Represents an optional register representation, which can be one of several types or none.\",\n            \"attributes\": [\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"Enum\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the register representation enum value.\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nclass MaybeRegisterRepresentation {\n public:\n  enum class Enum : uint8_t {\n    kWord32,\n    kWord64,\n    kFloat32,\n    kFloat64,\n    kTagged,\n    kCompressed,\n    kSimd128,\n    kSimd256,\n    kNone,  // No register representation.\n  };\n\n  explicit constexpr MaybeRegisterRepresentation(Enum value) : value_(value) {}\n  constexpr MaybeRegisterRepresentation() : value_(kInvalid) {}\n\n  constexpr bool is_valid() const { return value_ != kInvalid; }\n\n  constexpr Enum value() const {\n    DCHECK(is_valid());\n    return value_;\n  }\n\n  constexpr operator Enum() const { return value(); }\n\n  static constexpr MaybeRegisterRepresentation Word32() {\n    return MaybeRegisterRepresentation(Enum::kWord32);\n  }\n\n  static constexpr MaybeRegisterRepresentation Word64() {\n    return MaybeRegisterRepresentation(Enum::kWord64);\n  }\n\n  static constexpr MaybeRegisterRepresentation WordPtr() {\n    if constexpr (kSystemPointerSize == 4) {\n      return Word32();\n    } else {\n      DCHECK_EQ(kSystemPointerSize, 8);\n      return Word64();\n    }\n  }\n\n  static constexpr MaybeRegisterRepresentation Float32() {\n    return MaybeRegisterRepresentation(Enum::kFloat32);\n  }\n\n  static constexpr MaybeRegisterRepresentation Float64() {\n    return MaybeRegisterRepresentation(Enum::kFloat64);\n  }\n\n  static constexpr MaybeRegisterRepresentation Tagged() {\n    return MaybeRegisterRepresentation(Enum::kTagged);\n  }\n\n  static constexpr MaybeRegisterRepresentation Compressed() {\n    return MaybeRegisterRepresentation(Enum::kCompressed);\n  }\n\n  static constexpr MaybeRegisterRepresentation Simd128() {\n    return MaybeRegisterRepresentation(Enum::kSimd128);\n  }\n\n  static constexpr MaybeRegisterRepresentation Simd256() {\n    return MaybeRegisterRepresentation(Enum::kSimd256);\n  }\n\n  static constexpr MaybeRegisterRepresentation None() {\n    return MaybeRegisterRepresentation(Enum::kNone);\n  }\n\n  constexpr bool IsWord() const {\n    switch (*this) {\n      case Enum::kWord32:\n      case Enum::kWord64:\n        return true;\n      case Enum::kFloat32:\n      case Enum::kFloat64:\n      case Enum::kTagged:\n      case Enum::kCompressed:\n      case Enum::kSimd128:\n      case Enum::kSimd256:\n      case Enum::kNone:\n        return false;\n    }\n  }\n\n  constexpr bool IsFloat() const {\n    switch (*this) {\n      case Enum::kFloat32:\n      case Enum::kFloat64:\n        return true;\n      case Enum::kWord32:\n      case Enum::kWord64:\n      case Enum::kTagged:\n      case Enum::kCompressed:\n      case Enum::kSimd128:\n      case Enum::kSimd256:\n      case Enum::kNone:\n        return false;\n    }\n  }\n\n  constexpr bool IsTaggedOrCompressed() const {\n    switch (*this) {\n      case Enum::kTagged:\n      case Enum::kCompressed:\n        return true;\n      case Enum::kWord32:\n      case Enum::kWord64:\n      case Enum::kFloat32:\n      case Enum::kFloat64:\n      case Enum::kSimd128:\n      case Enum::kSimd256:\n      case Enum::kNone:\n        return false;\n    }\n  }\n\n  uint64_t MaxUnsignedValue() const {\n    switch (this->value()) {\n      case Word32():\n        return std::numeric_limits<uint32_t>::max();\n      case Word64():\n        return std::numeric_limits<uint64_t>::max();\n      case Enum::kFloat32:\n      case Enum::kFloat64:\n      case Enum::kTagged:\n      case Enum::kCompressed:\n      case Enum::kSimd128:\n      case Enum::kSimd256:\n      case Enum::kNone:\n        UNREACHABLE();\n    }\n  }\n\n  MachineRepresentation machine_representation() const {\n    switch (this->value()) {\n      case Word32():\n        return MachineRepresentation::kWord32;\n      case Word64():\n        return MachineRepresentation::kWord64;\n      case Float32():\n        return MachineRepresentation::kFloat32;\n      case Float64():\n        return MachineRepresentation::kFloat64;\n      case Tagged():\n        return MachineRepresentation::kTagged;\n      case Compressed():\n        return MachineRepresentation::kCompressed;\n      case Simd128():\n        return MachineRepresentation::kSimd128;\n      case Simd256():\n        return MachineRepresentation::kSimd256;\n      case None():\n        UNREACHABLE();\n    }\n  }\n\n  constexpr uint16_t bit_width() const {\n    switch (this->value()) {\n      case Word32():\n        return 32;\n      case Word64():\n        return 64;\n      case Float32():\n        return 32;\n      case Float64():\n        return 64;\n      case Tagged():\n        return kSystemPointerSize;\n      case Compressed():\n        return kSystemPointerSize;\n      case Simd128():\n        return 128;\n      case Simd256():\n        return 256;\n      case None():\n        UNREACHABLE();\n    }\n  }\n\n private:\n  Enum value_;\n\n  static constexpr Enum kInvalid = static_cast<Enum>(-1);\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"RegisterRepresentation\",\n            \"extends\": \"MaybeRegisterRepresentation\",\n            \"about\": \"Represents a valid register representation.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"MachineRepresentation\",\n                \"MachineType\",\n                \"CTypeInfo\",\n                \"CFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass RegisterRepresentation : public MaybeRegisterRepresentation {\n public:\n  enum class Enum : uint8_t {\n    kWord32 = static_cast<int>(MaybeRegisterRepresentation::Enum::kWord32),\n    kWord64 = static_cast<int>(MaybeRegisterRepresentation::Enum::kWord64),\n    kFloat32 = static_cast<int>(MaybeRegisterRepresentation::Enum::kFloat32),\n    kFloat64 = static_cast<int>(MaybeRegisterRepresentation::Enum::kFloat64),\n    kTagged = static_cast<int>(MaybeRegisterRepresentation::Enum::kTagged),\n    kCompressed =\n        static_cast<int>(MaybeRegisterRepresentation::Enum::kCompressed),\n    kSimd128 = static_cast<int>(MaybeRegisterRepresentation::Enum::kSimd128),\n    kSimd256 = static_cast<int>(MaybeRegisterRepresentation::Enum::kSimd256),\n  };\n\n  explicit constexpr RegisterRepresentation(Enum value)\n      : MaybeRegisterRepresentation(\n            static_cast<MaybeRegisterRepresentation::Enum>(value)) {}\n  RegisterRepresentation() = default;\n\n  explicit constexpr RegisterRepresentation(MaybeRegisterRepresentation rep)\n      : RegisterRepresentation(static_cast<Enum>(rep.value())) {}\n\n  constexpr operator Enum() const { return value(); }\n\n  constexpr Enum value() const {\n    return static_cast<Enum>(MaybeRegisterRepresentation::value());\n  }\n\n  static constexpr RegisterRepresentation Word32() {\n    return RegisterRepresentation(Enum::kWord32);\n  }\n  static constexpr RegisterRepresentation Word64() {\n    return RegisterRepresentation(Enum::kWord64);\n  }\n  // The equivalent of intptr_t/uintptr_t: An integral type with the same size\n  // as machine pointers.\n  static constexpr RegisterRepresentation WordPtr() {\n    return RegisterRepresentation(MaybeRegisterRepresentation::WordPtr());\n  }\n  static constexpr RegisterRepresentation Float32() {\n    return RegisterRepresentation(Enum::kFloat32);\n  }\n  static constexpr RegisterRepresentation Float64() {\n    return RegisterRepresentation(Enum::kFloat64);\n  }\n  // A tagged pointer stored in a register, in the case of pointer compression\n  // it is an uncompressed pointer or a Smi.\n  static constexpr RegisterRepresentation Tagged() {\n    return RegisterRepresentation(Enum::kTagged);\n  }\n  // A compressed tagged pointer stored in a register, the upper 32bit are\n  // unspecified.\n  static constexpr RegisterRepresentation Compressed() {\n    return RegisterRepresentation(Enum::kCompressed);\n  }\n  static constexpr RegisterRepresentation Simd128() {\n    return RegisterRepresentation(Enum::kSimd128);\n  }\n  static constexpr RegisterRepresentation Simd256() {\n    return RegisterRepresentation(Enum::kSimd256);\n  }\n\n  static constexpr RegisterRepresentation FromMachineRepresentation(\n      MachineRepresentation rep) {\n    switch (rep) {\n      case MachineRepresentation::kBit:\n      case MachineRepresentation::kWord8:\n      case MachineRepresentation::kWord16:\n      case MachineRepresentation::kWord32:\n        return Word32();\n      case MachineRepresentation::kWord64:\n        return Word64();\n      case MachineRepresentation::kTaggedSigned:\n      case MachineRepresentation::kTaggedPointer:\n      case MachineRepresentation::kTagged:\n      case MachineRepresentation::kProtectedPointer:\n        return Tagged();\n      case MachineRepresentation::kCompressedPointer:\n      case MachineRepresentation::kCompressed:\n        return Compressed();\n      case MachineRepresentation::kFloat16:\n      case MachineRepresentation::kFloat32:\n        return Float32();\n      case MachineRepresentation::kFloat64:\n        return Float64();\n      case MachineRepresentation::kSimd128:\n        return Simd128();\n      case MachineRepresentation::kSimd256:\n        return Simd256();\n      case MachineRepresentation::kMapWord:\n        // Turboshaft does not support map packing.\n        DCHECK(!V8_MAP_PACKING_BOOL);\n        return RegisterRepresentation::Tagged();\n      case MachineRepresentation::kIndirectPointer:\n      case MachineRepresentation::kSandboxedPointer:\n        // TODO(saelo/jkummerow): This is suspicious: after resolving the\n        // indirection, we have a Tagged pointer.\n        return WordPtr();\n      case MachineRepresentation::kNone:\n      case MachineRepresentation::kFloat16RawBits:\n        UNREACHABLE();\n    }\n  }\n\n  static constexpr RegisterRepresentation FromMachineType(MachineType type) {\n    return FromMachineRepresentation(type.representation());\n  }\n\n  static constexpr RegisterRepresentation FromCTypeInfo(\n      CTypeInfo t, CFunctionInfo::Int64Representation int64_repr) {\n    if (t.GetType() == CTypeInfo::Type::kVoid ||\n        t.GetType() == CTypeInfo::Type::kPointer) {\n      return RegisterRepresentation::Tagged();\n    } else if (t.GetType() == CTypeInfo::Type::kInt64 ||\n               t.GetType() == CTypeInfo::Type::kUint64) {\n      if (int64_repr == CFunctionInfo::Int64Representation::kBigInt) {\n        return RegisterRepresentation::Word64();\n      } else {\n        DCHECK_EQ(int64_repr, CFunctionInfo::Int64Representation::kNumber);\n        return RegisterRepresentation::Float64();\n      }\n    } else {\n      return RegisterRepresentation::FromMachineType(\n          MachineType::TypeForCType(t));\n    }\n  }\n\n  constexpr bool AllowImplicitRepresentationChangeTo(\n      RegisterRepresentation dst_rep, bool graph_created_from_turbofan) const;\n\n  constexpr RegisterRepresentation MapTaggedToWord() const {\n    if (this->value() == RegisterRepresentation::Tagged()) {\n      return COMPRESS_POINTERS_BOOL ? RegisterRepresentation::Word32()\n                                    : RegisterRepresentation::WordPtr();\n    }\n    return *this;\n  }\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AllowImplicitRepresentationChangeTo\",\n            \"parent\": \"RegisterRepresentation\",\n            \"about\": \"Determines if an implicit representation change is allowed from the current register representation to the destination register representation.\",\n            \"logic\": \"Checks if the representations are the same, or if certain tagged-to-untagged or untagged-to-tagged conversions are allowed, taking into account pointer compression and the origin of the graph (Turbofan or Turboshaft).\",\n            \"parameters\": [\n                {\n                    \"name\": \"dst_rep\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The destination register representation.\"\n                },\n                {\n                    \"name\": \"graph_created_from_turbofan\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the graph was created from Turbofan.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the implicit representation change is allowed, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"RegisterRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nconstexpr bool RegisterRepresentation::AllowImplicitRepresentationChangeTo(\n    RegisterRepresentation dst_rep, bool graph_created_from_turbofan) const {\n  if (*this == dst_rep) {\n    return true;\n  }\n  switch (dst_rep.value()) {\n    case RegisterRepresentation::Word32():\n      // We allow implicit tagged -> untagged conversions.\n      // Even without pointer compression, we use `Word32And` for Smi-checks on\n      // tagged values.\n      if (*this == any_of(RegisterRepresentation::Tagged(),\n                          RegisterRepresentation::Compressed())) {\n        return true;\n      }\n      if (graph_created_from_turbofan &&\n          *this == RegisterRepresentation::Word64()) {\n        // TODO(12783): Remove this once Turboshaft graphs are not constructed\n        // via Turbofan any more. Unfortunately Turbofan has many implicit\n        // truncations which are hard to fix. Still, for wasm it is required\n        // that truncations in Turboshaft are explicit.\n        return true;\n      }\n      break;\n    case RegisterRepresentation::Word64():\n      // We allow implicit tagged -> untagged conversions.\n      if (kTaggedSize == kInt64Size &&\n          *this == RegisterRepresentation::Tagged()) {\n        return true;\n      }\n      break;\n    case RegisterRepresentation::Tagged():\n      // We allow implicit untagged -> tagged conversions. This is only safe for\n      // Smi values.\n      if (*this == RegisterRepresentation::WordPtr()) {\n        return true;\n      }\n      break;\n    case RegisterRepresentation::Compressed():\n      // Compression is a no-op.\n      if (*this == any_of(RegisterRepresentation::Tagged(),\n                          RegisterRepresentation::WordPtr(),\n                          RegisterRepresentation::Word32())) {\n        return true;\n      }\n      break;\n    default:\n      break;\n  }\n  return false;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator==\",\n            \"about\": \"Equality operator for MaybeRegisterRepresentation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"MaybeRegisterRepresentation\",\n                    \"purpose\": \"Left-hand side operand.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"MaybeRegisterRepresentation\",\n                    \"purpose\": \"Right-hand side operand.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the two representations are equal, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE constexpr bool operator==(MaybeRegisterRepresentation a,\n                                    MaybeRegisterRepresentation b) {\n  return a.value() == b.value();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator!=\",\n            \"about\": \"Inequality operator for MaybeRegisterRepresentation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"a\",\n                    \"type\": \"MaybeRegisterRepresentation\",\n                    \"purpose\": \"Left-hand side operand.\"\n                },\n                {\n                    \"name\": \"b\",\n                    \"type\": \"MaybeRegisterRepresentation\",\n                    \"purpose\": \"Right-hand side operand.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the two representations are not equal, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE constexpr bool operator!=(MaybeRegisterRepresentation a,\n                                    MaybeRegisterRepresentation b) {\n  return a.value() != b.value();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"hash_value\",\n            \"about\": \"Calculates the hash value for a MaybeRegisterRepresentation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"rep\",\n                    \"type\": \"MaybeRegisterRepresentation\",\n                    \"purpose\": \"The register representation to hash.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The hash value of the representation.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nV8_INLINE size_t hash_value(MaybeRegisterRepresentation rep) {\n  return static_cast<size_t>(rep.value());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"operator<<\",\n            \"about\": \"Overloads the stream insertion operator for MaybeRegisterRepresentation to allow printing.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"The output stream.\"\n                },\n                {\n                    \"name\": \"rep\",\n                    \"type\": \"MaybeRegisterRepresentation\",\n                    \"purpose\": \"The register representation to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::ostream&\",\n                \"description\": \"The modified output stream.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nV8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os,\n                                           MaybeRegisterRepresentation rep);\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MultiSwitch\",\n            \"about\": \"Helper struct for encoding MaybeRegisterRepresentation values for use in switches.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"MaybeRegisterRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nstruct MultiSwitch<\n    T, std::enable_if_t<std::is_base_of_v<MaybeRegisterRepresentation, T>>> {\n  static constexpr uint64_t max_value = 8;\n  static constexpr uint64_t encode(T rep) {\n    const uint64_t value = static_cast<uint64_t>(rep.value());\n    DCHECK_LT(value, max_value);\n    return value;\n  }\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WordRepresentation\",\n            \"extends\": \"RegisterRepresentation\",\n            \"about\": \"Represents a word-sized register representation (32-bit or 64-bit).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"RegisterRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass WordRepresentation : public RegisterRepresentation {\n public:\n  enum class Enum : uint8_t {\n    kWord32 = static_cast<int>(RegisterRepresentation::Enum::kWord32),\n    kWord64 = static_cast<int>(RegisterRepresentation::Enum::kWord64)\n  };\n  explicit constexpr WordRepresentation(Enum value)\n      : RegisterRepresentation(\n            static_cast<RegisterRepresentation::Enum>(value)) {}\n  WordRepresentation() = default;\n  explicit constexpr WordRepresentation(RegisterRepresentation rep)\n      : WordRepresentation(static_cast<Enum>(rep.value())) {\n    DCHECK(rep.IsWord());\n  }\n\n  static constexpr WordRepresentation Word32() {\n    return WordRepresentation(Enum::kWord32);\n  }\n  static constexpr WordRepresentation Word64() {\n    return WordRepresentation(Enum::kWord64);\n  }\n\n  static constexpr WordRepresentation WordPtr() {\n    return WordRepresentation(RegisterRepresentation::WordPtr());\n  }\n\n  constexpr Enum value() const {\n    return static_cast<Enum>(RegisterRepresentation::value());\n  }\n  constexpr operator Enum() const { return value(); }\n\n  constexpr uint64_t MaxUnsignedValue() const {\n    switch (this->value()) {\n      case Word32():\n        return std::numeric_limits<uint32_t>::max();\n      case Word64():\n        return std::numeric_limits<uint64_t>::max();\n    }\n  }\n  constexpr int64_t MinSignedValue() const {\n    switch (this->value()) {\n      case Word32():\n        return std::numeric_limits<int32_t>::min();\n      case Word64():\n        return std::numeric_limits<int64_t>::min();\n    }\n  }\n  constexpr int64_t MaxSignedValue() const {\n    switch (this->value()) {\n      case Word32():\n        return std::numeric_limits<int32_t>::max();\n      case Word64():\n        return std::numeric_limits<int64_t>::max();\n    }\n  }\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FloatRepresentation\",\n            \"extends\": \"RegisterRepresentation\",\n            \"about\": \"Represents a floating-point register representation (32-bit or 64-bit).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"RegisterRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass FloatRepresentation : public RegisterRepresentation {\n public:\n  enum class Enum : uint8_t {\n    kFloat32 = static_cast<int>(RegisterRepresentation::Enum::kFloat32),\n    kFloat64 = static_cast<int>(RegisterRepresentation::Enum::kFloat64)\n  };\n\n  static constexpr FloatRepresentation Float32() {\n    return FloatRepresentation(Enum::kFloat32);\n  }\n  static constexpr FloatRepresentation Float64() {\n    return FloatRepresentation(Enum::kFloat64);\n  }\n\n  explicit constexpr FloatRepresentation(Enum value)\n      : RegisterRepresentation(\n            static_cast<RegisterRepresentation::Enum>(value)) {}\n  explicit constexpr FloatRepresentation(RegisterRepresentation rep)\n      : FloatRepresentation(static_cast<Enum>(rep.value())) {\n    DCHECK(rep.IsFloat());\n  }\n  FloatRepresentation() = default;\n\n  constexpr Enum value() const {\n    return static_cast<Enum>(RegisterRepresentation::value());\n  }\n  constexpr operator Enum() const { return value(); }\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MemoryRepresentation\",\n            \"about\": \"Represents the memory layout of data.\",\n            \"attributes\": [\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"Enum\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Holds the enum value representing the memory representation.\"\n                }\n            ],\n            \"dependencies\": [\n                \"MachineType\",\n                \"RegisterRepresentation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass MemoryRepresentation {\n public:\n  enum class Enum : uint8_t {\n    kInt8,\n    kUint8,\n    kInt16,\n    kUint16,\n    kInt32,\n    kUint32,\n    kInt64,\n    kUint64,\n    kFloat16,\n    kFloat32,\n    kFloat64,\n    kAnyTagged,\n    kTaggedPointer,\n    kTaggedSigned,\n    kAnyUncompressedTagged,\n    kUncompressedTaggedPointer,\n    kUncompressedTaggedSigned,\n    kProtectedPointer,\n    kIndirectPointer,\n    kSandboxedPointer,\n    kSimd128,\n    kSimd256\n  };\n\n  explicit constexpr MemoryRepresentation(Enum value) : value_(value) {}\n  constexpr MemoryRepresentation() : value_(kInvalid) {}\n\n  constexpr bool is_valid() const { return value_ != kInvalid; }\n\n  constexpr Enum value() const {\n    DCHECK(is_valid());\n    return value_;\n  }\n  constexpr operator Enum() const { return value(); }\n\n  static constexpr MemoryRepresentation Int8() {\n    return MemoryRepresentation(Enum::kInt8);\n  }\n  static constexpr MemoryRepresentation Uint8() {\n    return MemoryRepresentation(Enum::kUint8);\n  }\n  static constexpr MemoryRepresentation Int16() {\n    return MemoryRepresentation(Enum::kInt16);\n  }\n  static constexpr MemoryRepresentation Uint16() {\n    return MemoryRepresentation(Enum::kUint16);\n  }\n  static constexpr MemoryRepresentation Int32() {\n    return MemoryRepresentation(Enum::kInt32);\n  }\n  static constexpr MemoryRepresentation Uint32() {\n    return MemoryRepresentation(Enum::kUint32);\n  }\n  static constexpr MemoryRepresentation Int64() {\n    return MemoryRepresentation(Enum::kInt64);\n  }\n  static constexpr MemoryRepresentation Uint64() {\n    return MemoryRepresentation(Enum::kUint64);\n  }\n  static constexpr MemoryRepresentation UintPtr() {\n    if constexpr (Is64()) {\n      return Uint64();\n    } else {\n      return Uint32();\n    }\n  }\n  static constexpr MemoryRepresentation Float16() {\n    return MemoryRepresentation(Enum::kFloat16);\n  }\n  static constexpr MemoryRepresentation Float32() {\n    return MemoryRepresentation(Enum::kFloat32);\n  }\n  static constexpr MemoryRepresentation Float64() {\n    return MemoryRepresentation(Enum::kFloat64);\n  }\n  static constexpr MemoryRepresentation AnyTagged() {\n    return MemoryRepresentation(Enum::kAnyTagged);\n  }\n  static constexpr MemoryRepresentation TaggedPointer() {\n    return MemoryRepresentation(Enum::kTaggedPointer);\n  }\n  static constexpr MemoryRepresentation TaggedSigned() {\n    return MemoryRepresentation(Enum::kTaggedSigned);\n  }\n  static constexpr MemoryRepresentation AnyUncompressedTagged() {\n    return MemoryRepresentation(Enum::kAnyUncompressedTagged);\n  }\n  static constexpr MemoryRepresentation UncompressedTaggedPointer() {\n    return MemoryRepresentation(Enum::kUncompressedTaggedPointer);\n  }\n  static constexpr MemoryRepresentation UncompressedTaggedSigned() {\n    return MemoryRepresentation(Enum::kUncompressedTaggedSigned);\n  }\n  static constexpr MemoryRepresentation ProtectedPointer() {\n    return MemoryRepresentation(Enum::kProtectedPointer);\n  }\n  static constexpr MemoryRepresentation IndirectPointer() {\n    return MemoryRepresentation(Enum::kIndirectPointer);\n  }\n  static constexpr MemoryRepresentation SandboxedPointer() {\n    return MemoryRepresentation(Enum::kSandboxedPointer);\n  }\n  static constexpr MemoryRepresentation Simd128() {\n    return MemoryRepresentation(Enum::kSimd128);\n  }\n  static constexpr MemoryRepresentation Simd256() {\n    return MemoryRepresentation(Enum::kSimd256);\n  }\n\n  bool IsSigned() const {\n    switch (*this) {\n      case Int8():\n      case Int16():\n      case Int32():\n      case Int64():\n        return true;\n      case Uint8():\n      case Uint16():\n      case Uint32():\n      case Uint64():\n        return false;\n      case Float16():\n      case Float32():\n      case Float64():\n      case AnyTagged():\n      case TaggedPointer():\n      case TaggedSigned():\n      case AnyUncompressedTagged():\n      case UncompressedTaggedPointer():\n      case UncompressedTaggedSigned():\n      case ProtectedPointer():\n      case IndirectPointer():\n      case SandboxedPointer():\n      case Simd128():\n      case Simd256():\n        UNREACHABLE();\n    }\n  }\n\n  // This predicate is used in particular to decide which load/store ops\n  // have to deal with pointer compression. Indirect/sandboxed pointers,\n  // while they resolve to tagged pointers, return {false} because they\n  // use incompatible compression schemes.\n  bool IsCompressibleTagged() const {\n    switch (*this) {\n      case AnyTagged():\n      case TaggedPointer():\n      case TaggedSigned():\n        return true;\n      case Int8():\n      case Int16():\n      case Int32():\n      case Int64():\n      case Uint8():\n      case Uint16():\n      case Uint32():\n      case Uint64():\n      case Float16():\n      case Float32():\n      case Float64():\n      case AnyUncompressedTagged():\n      case UncompressedTaggedPointer():\n      case UncompressedTaggedSigned():\n      case IndirectPointer():\n      case ProtectedPointer():\n      case SandboxedPointer():\n      case Simd128():\n      case Simd256():\n        return false;\n    }\n  }\n\n  RegisterRepresentation ToRegisterRepresentation() const {\n    switch (*this) {\n      case Int8():\n      case Uint8():\n      case Int16():\n      case Uint16():\n      case Int32():\n      case Uint32():\n        return RegisterRepresentation::Word32();\n      case Int64():\n      case Uint64():\n        return RegisterRepresentation::Word64();\n      case Float16():\n      case Float32():\n        return RegisterRepresentation::Float32();\n      case Float64():\n        return RegisterRepresentation::Float64();\n      case AnyTagged():\n      case TaggedPointer():\n      case TaggedSigned():\n      case AnyUncompressedTagged():\n      case UncompressedTaggedPointer():\n      case UncompressedTaggedSigned():\n      case IndirectPointer():\n      case ProtectedPointer():\n        return RegisterRepresentation::Tagged();\n      case SandboxedPointer():\n        return RegisterRepresentation::Word64();\n      case Simd128():\n        return RegisterRepresentation::Simd128();\n      case Simd256():\n        return RegisterRepresentation::Simd256();\n    }\n  }\n\n  static MemoryRepresentation FromRegisterRepresentation(\n      RegisterRepresentation repr, bool is_signed) {\n    switch (repr.value()) {\n      case RegisterRepresentation::Word32():\n        return is_signed ? Int32() : Uint32();\n      case RegisterRepresentation::Word64():\n        return is_signed ? Int64() : Uint64();\n      case RegisterRepresentation::Float32():\n        return Float32();\n      case RegisterRepresentation::Float64():\n        return Float64();\n      case RegisterRepresentation::Tagged():\n        return AnyTagged();\n      case RegisterRepresentation::Simd128():\n        return Simd128();\n      case RegisterRepresentation::Simd256():\n        return Simd256();\n      case RegisterRepresentation::Compressed():\n        UNREACHABLE();\n    }\n  }\n\n  // The required register representation for storing a value. When pointer\n  // compression is enabled, we only store the lower 32bit of a tagged value,\n  // which we indicate as `RegisterRepresentation::Compressed()` here.\n  RegisterRepresentation ToRegisterRepresentationForStore() const {\n    RegisterRepresentation result = ToRegisterRepresentation();\n#ifdef V8_COMPRESS_POINTERS\n    if (result == RegisterRepresentation::Tagged()) {\n      result = Register"
}