{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/allocation.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 346, column 46",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/allocation.h\",\n        \"file_name\": \"allocation.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the allocation mechanisms for garbage-collected objects in cppgc.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and cppgc specific headers required for memory allocation, type traits, and other utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <atomic>\n            #include <cstddef>\n            #include <cstdint>\n            #include <new>\n            #include <type_traits>\n            #include <utility>\n\n            #include \"cppgc/custom-space.h\"\n            #include \"cppgc/internal/api-constants.h\"\n            #include \"cppgc/internal/gc-info.h\"\n            #include \"cppgc/type-traits.h\"\n            #include \"v8config.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <macro>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"CPPGC_DEFAULT_ALIGNED\",\n            \"purpose\": \"Defines an attribute to enforce default alignment for memory allocation if the compiler supports it.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #if defined(__has_attribute)\n            #if __has_attribute(assume_aligned)\n            #define CPPGC_DEFAULT_ALIGNED \\\n              __attribute__((assume_aligned(api_constants::kDefaultAlignment)))\n            #define CPPGC_DOUBLE_WORD_ALIGNED \\\n              __attribute__((assume_aligned(2 * api_constants::kDefaultAlignment)))\n            #endif  // __has_attribute(assume_aligned)\n            #endif  // defined(__has_attribute)\n\n            #if !defined(CPPGC_DEFAULT_ALIGNED)\n            #define CPPGC_DEFAULT_ALIGNED\n            #endif\n        ]]></code>\n    </macro>\n    <macro>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"macro\",\n            \"name\": \"CPPGC_DOUBLE_WORD_ALIGNED\",\n            \"purpose\": \"Defines an attribute to enforce double-word alignment for memory allocation if the compiler supports it.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #if !defined(CPPGC_DOUBLE_WORD_ALIGNED)\n            #define CPPGC_DOUBLE_WORD_ALIGNED\n            #endif\n        ]]></code>\n    </macro>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AllocationHandle\",\n            \"about\": \"Represents a handle used for allocating garbage-collected objects.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class AllocationHandle;\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MakeGarbageCollectedTraitInternal\",\n            \"about\": \"Internal class with utilities for garbage collected object allocation.\",\n            \"dependencies\": [\n                \"AlignVal\",\n                \"HeapObjectHeader\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n\n            using AlignVal = std::align_val_t;\n\n            class MakeGarbageCollectedTraitInternal {\n             protected:\n              static inline void MarkObjectAsFullyConstructed(const void* payload) {\n                // See api_constants for an explanation of the constants.\n                std::atomic<uint16_t>* atomic_mutable_bitfield =\n                    reinterpret_cast<std::atomic<uint16_t>*>(\n                        const_cast<uint16_t*>(reinterpret_cast<const uint16_t*>(\n                            reinterpret_cast<const uint8_t*>(payload) -\n                            api_constants::kFullyConstructedBitFieldOffsetFromPayload)));\n                // It's safe to split use load+store here (instead of a read-modify-write\n                // operation), since it's guaranteed that this 16-bit bitfield is only\n                // modified by a single thread. This is cheaper in terms of code bloat (on\n                // ARM) and performance.\n                uint16_t value = atomic_mutable_bitfield->load(std::memory_order_relaxed);\n                value |= api_constants::kFullyConstructedBitMask;\n                atomic_mutable_bitfield->store(value, std::memory_order_release);\n              }\n\n              // Dispatch based on compile-time information.\n              //\n              // Default implementation is for a custom space with >`kDefaultAlignment` byte\n              // alignment.\n              template <typename GCInfoType, typename CustomSpace, size_t alignment>\n              struct AllocationDispatcher final {\n                static void* Invoke(AllocationHandle& handle, size_t size) {\n                  static_assert(std::is_base_of<CustomSpaceBase, CustomSpace>::value,\n                                \"Custom space must inherit from CustomSpaceBase.\");\n                  static_assert(\n                      !CustomSpace::kSupportsCompaction,\n                      \"Custom spaces that support compaction do not support allocating \"\n                      \"objects with non-default (i.e. word-sized) alignment.\");\n                  return MakeGarbageCollectedTraitInternal::Allocate(\n                      handle, size, static_cast<AlignVal>(alignment),\n                      internal::GCInfoTrait<GCInfoType>::Index(), CustomSpace::kSpaceIndex);\n                }\n              };\n\n              // Fast path for regular allocations for the default space with\n              // `kDefaultAlignment` byte alignment.\n              template <typename GCInfoType>\n              struct AllocationDispatcher<GCInfoType, void,\n                                          api_constants::kDefaultAlignment>\n                  final {\n                static void* Invoke(AllocationHandle& handle, size_t size) {\n                  return MakeGarbageCollectedTraitInternal::Allocate(\n                      handle, size, internal::GCInfoTrait<GCInfoType>::Index());\n                }\n              };\n\n              // Default space with >`kDefaultAlignment` byte alignment.\n              template <typename GCInfoType, size_t alignment>\n              struct AllocationDispatcher<GCInfoType, void, alignment> final {\n                static void* Invoke(AllocationHandle& handle, size_t size) {\n                  return MakeGarbageCollectedTraitInternal::Allocate(\n                      handle, size, static_cast<AlignVal>(alignment),\n                      internal::GCInfoTrait<GCInfoType>::Index());\n                }\n              };\n\n              // Custom space with `kDefaultAlignment` byte alignment.\n              template <typename GCInfoType, typename CustomSpace>\n              struct AllocationDispatcher<GCInfoType, CustomSpace,\n                                          api_constants::kDefaultAlignment>\n                  final {\n                static void* Invoke(AllocationHandle& handle, size_t size) {\n                  static_assert(std::is_base_of<CustomSpaceBase, CustomSpace>::value,\n                                \"Custom space must inherit from CustomSpaceBase.\");\n                  return MakeGarbageCollectedTraitInternal::Allocate(\n                      handle, size, internal::GCInfoTrait<GCInfoType>::Index(),\n                      CustomSpace::kSpaceIndex);\n                }\n              };\n\n             private:\n              V8_EXPORT static void* CPPGC_DEFAULT_ALIGNED\n              Allocate(cppgc::AllocationHandle&, size_t, GCInfoIndex);\n              V8_EXPORT static void* CPPGC_DOUBLE_WORD_ALIGNED\n              Allocate(cppgc::AllocationHandle&, size_t, AlignVal, GCInfoIndex);\n              V8_EXPORT static void* CPPGC_DEFAULT_ALIGNED\n              Allocate(cppgc::AllocationHandle&, size_t, GCInfoIndex, CustomSpaceIndex);\n              V8_EXPORT static void* CPPGC_DOUBLE_WORD_ALIGNED\n              Allocate(cppgc::AllocationHandle&, size_t, AlignVal, GCInfoIndex,\n                       CustomSpaceIndex);\n\n              friend class HeapObjectHeader;\n            };\n\n            }  // namespace internal\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MakeGarbageCollectedTraitBase\",\n            \"about\": \"Base trait providing utilities for advanced users with custom allocation needs.\",\n            \"dependencies\": [\n                \"MakeGarbageCollectedTraitInternal\",\n                \"IsGarbageCollectedType\",\n                \"GarbageCollectedMixinTypeV\",\n                \"AllocationHandle\",\n                \"SpaceTrait\",\n                \"GCInfoFolding\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class MakeGarbageCollectedTraitBase\n                : private internal::MakeGarbageCollectedTraitInternal {\n             private:\n              static_assert(internal::IsGarbageCollectedType<T>::value,\n                            \"T needs to be a garbage collected object\");\n              static_assert(!IsGarbageCollectedWithMixinTypeV<T> ||\n                                  sizeof(T) <=\n                                      internal::api_constants::kLargeObjectSizeThreshold,\n                            \"GarbageCollectedMixin may not be a large object\");\n\n             protected:\n              /**\n               * Allocates memory for an object of type T.\n               *\n               * \\param handle AllocationHandle identifying the heap to allocate the object\n               *   on.\n               * \\param size The size that should be reserved for the object.\n               * \\returns the memory to construct an object of type T on.\n               */\n              V8_INLINE static void* Allocate(AllocationHandle& handle, size_t size) {\n                static_assert(\n                    std::is_base_of<typename T::ParentMostGarbageCollectedType, T>::value,\n                    \"U of GarbageCollected<U> must be a base of T. Check \"\n                    \"GarbageCollected<T> base class inheritance.\");\n                static constexpr size_t kWantedAlignment =\n                    alignof(T) < internal::api_constants::kDefaultAlignment\n                        ? internal::api_constants::kDefaultAlignment\n                        : alignof(T);\n                static_assert(\n                    kWantedAlignment <= internal::api_constants::kMaxSupportedAlignment,\n                    \"Requested alignment larger than alignof(std::max_align_t) bytes. \"\n                    \"Please file a bug to possibly get this restriction lifted.\");\n                return AllocationDispatcher<\n                    typename internal::GCInfoFolding<\n                        T, typename T::ParentMostGarbageCollectedType>::ResultType,\n                    typename SpaceTrait<T>::Space, kWantedAlignment>::Invoke(handle, size);\n              }\n\n              /**\n               * Marks an object as fully constructed, resulting in precise handling by the\n               * garbage collector.\n               *\n               * \\param payload The base pointer the object is allocated at.\n               */\n              V8_INLINE static void MarkObjectAsFullyConstructed(const void* payload) {\n                internal::MakeGarbageCollectedTraitInternal::MarkObjectAsFullyConstructed(\n                    payload);\n              }\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"AdditionalBytes\",\n            \"about\": \"Specifies how many bytes should be appended to the allocated object.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            struct AdditionalBytes {\n              constexpr explicit AdditionalBytes(size_t bytes) : value(bytes) {}\n              const size_t value;\n            };\n        ]]></code>\n    </struct>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MakeGarbageCollectedTrait\",\n            \"extends\": \"MakeGarbageCollectedTraitBase\",\n            \"about\": \"Default trait class specifying how to construct an object of type T.\",\n            \"dependencies\": [\n                \"AllocationHandle\",\n                \"AdditionalBytes\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            class MakeGarbageCollectedTrait : public MakeGarbageCollectedTraitBase<T> {\n             public:\n              template <typename... Args>\n              static T* Call(AllocationHandle& handle, Args&&... args) {\n                void* memory =\n                    MakeGarbageCollectedTraitBase<T>::Allocate(handle, sizeof(T));\n                T* object = ::new (memory) T(std::forward<Args>(args)...);\n                MakeGarbageCollectedTraitBase<T>::MarkObjectAsFullyConstructed(object);\n                return object;\n              }\n\n              template <typename... Args>\n              static T* Call(AllocationHandle& handle, AdditionalBytes additional_bytes,\n                             Args&&... args) {\n                void* memory = MakeGarbageCollectedTraitBase<T>::Allocate(\n                    handle, sizeof(T) + additional_bytes.value);\n                T* object = ::new (memory) T(std::forward<Args>(args)...);\n                MakeGarbageCollectedTraitBase<T>::MarkObjectAsFullyConstructed(object);\n                return object;\n              }\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"PostConstructionCallbackTrait\",\n            \"about\": \"Allows users to specify a post-construction callback for specific types.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename = void>\n            struct PostConstructionCallbackTrait {\n              static void Call(T*) {}\n            };\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MakeGarbageCollected\",\n            \"about\": \"Constructs a managed object of type T inheriting from GarbageCollected.\",\n            \"parameters\": [\n                {\n                    \"name\": \"handle\",\n                    \"type\": \"AllocationHandle&\",\n                    \"purpose\": \"The allocation handle.\"\n                },\n                {\n                    \"name\": \"args\",\n                    \"type\": \"Args&&...\",\n                    \"purpose\": \"Arguments for the T constructor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T*\",\n                \"description\": \"An instance of type T.\"\n            },\n            \"dependencies\": [\n                \"MakeGarbageCollectedTrait\",\n                \"PostConstructionCallbackTrait\",\n                \"AllocationHandle\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename... Args>\n            V8_INLINE T* MakeGarbageCollected(AllocationHandle& handle, Args&&... args) {\n              T* object =\n                  MakeGarbageCollectedTrait<T>::Call(handle, std::forward<Args>(args)...);\n              PostConstructionCallbackTrait<T>::Call(object);\n              return object;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"MakeGarbageCollected\",\n            \"about\": \"Constructs a managed object of type T inheriting from GarbageCollected with additional bytes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"handle\",\n                    \"type\": \"AllocationHandle&\",\n                    \"purpose\": \"The allocation handle.\"\n                },\n                {\n                    \"name\": \"additional_bytes\",\n                    \"type\": \"AdditionalBytes\",\n                    \"purpose\": \"How many bytes to append to T.\"\n                },\n                {\n                    \"name\": \"args\",\n                    \"type\": \"Args&&...\",\n                    \"purpose\": \"Arguments for the T constructor.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"T*\",\n                \"description\": \"An instance of type T.\"\n            },\n            \"dependencies\": [\n                \"MakeGarbageCollectedTrait\",\n                \"PostConstructionCallbackTrait\",\n                \"AllocationHandle\",\n                \"AdditionalBytes\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T, typename... Args>\n            V8_INLINE T* MakeGarbageCollected(AllocationHandle& handle,\n                                              AdditionalBytes additional_bytes,\n                                              Args&&... args) {\n              T* object = MakeGarbageCollectedTrait<T>::Call(handle, additional_bytes,\n                                                             std::forward<Args>(args)...);\n              PostConstructionCallbackTrait<T>::Call(object);\n              return object;\n            }\n        ]]></code>\n    </func>\n    <dependencies>\n        <typedef>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"GCInfoIndex\",\n                \"about\": \"Type alias for the GCInfo index.\",\n                \"purpose\": \"Used to represent the index of the GCInfo for a given type.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                using GCInfoIndex = size_t;\n            ]]></code>\n        </typedef>\n        <typedef>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"CustomSpaceIndex\",\n                \"about\": \"Type alias for the CustomSpace index.\",\n                \"purpose\": \"Used to represent the index of the custom space for allocation.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                using CustomSpaceIndex = size_t;\n            ]]></code>\n        </typedef>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CustomSpaceBase\",\n                \"about\": \"Base class for custom memory spaces.\",\n                \"purpose\": \"Defines the interface for custom memory spaces managed by the garbage collector.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class CustomSpaceBase {\n                public:\n                    static constexpr bool kSupportsCompaction = false;\n                    static constexpr size_t kSpaceIndex = 0;\n                };\n            ]]></code>\n        </class>\n        <struct>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"GCInfoTrait\",\n                \"about\": \"Provides the GCInfo index for a given type.\",\n                \"purpose\": \"Used to retrieve the GCInfo index at compile time.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                struct GCInfoTrait {\n                    static constexpr GCInfoIndex Index() { return 0; }\n                };\n            ]]></code>\n        </struct>\n        <struct>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"GCInfoFolding\",\n                \"about\": \"Selects the most parent garbage collected type.\",\n                \"purpose\": \"Folding of GCInfo based on ParentMostGarbageCollectedType.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename Derived, typename Parent>\n                struct GCInfoFolding {\n                  using ResultType = Parent;\n                };\n            ]]></code>\n        </struct>\n        <struct>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"SpaceTrait\",\n                \"about\": \"Provides the memory space for a given type.\",\n                \"purpose\": \"Used to retrieve the memory space type at compile time.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                struct SpaceTrait {\n                  using Space = void;\n                };\n            ]]></code>\n        </struct>\n        <struct>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"IsGarbageCollectedType\",\n                \"about\": \"Checks if a type is garbage collected.\",\n                \"purpose\": \"Used to determine if a given type is managed by the garbage collector.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                struct IsGarbageCollectedType : std::false_type {};\n            ]]></code>\n        </struct>\n        <variable>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"IsGarbageCollectedWithMixinTypeV\",\n                \"about\": \"Checks if a type is garbage collected with mixin.\",\n                \"purpose\": \"Used to determine if a given type uses the GarbageCollectedMixin.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                constexpr bool IsGarbageCollectedWithMixinTypeV = false;\n            ]]></code>\n        </variable>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"HeapObjectHeader\",\n                \"about\": \"Header of a heap object.\",\n                \"purpose\": \"Contains metadata about heap allocated objects.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class HeapObjectHeader {};\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}