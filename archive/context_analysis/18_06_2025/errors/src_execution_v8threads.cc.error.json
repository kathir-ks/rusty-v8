{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/v8threads.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/v8threads.cc\",\n            \"file_name\": \"v8threads.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements thread management and locking mechanisms for the V8 JavaScript engine.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for thread management, API, debugging, execution, isolates, stack guards, bootstrapping, objects, and regular expressions.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/v8threads.h\"\n\n#include \"include/v8-locker.h\"\n#include \"src/api/api.h\"\n#include \"src/debug/debug.h\"\n#include \"src/execution/execution.h\"\n#include \"src/execution/isolate-inl.h\"\n#include \"src/execution/stack-guard.h\"\n#include \"src/init/bootstrapper.h\"\n#include \"src/objects/visitors.h\"\n#include \"src/regexp/regexp-stack.h\"\n        ]]></code>\n    </imports>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8\",\n                \"purpose\": \"Groups V8-related code.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"\",\n                \"purpose\": \"Enclosing namespace for a global variable.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\n// Track whether this V8 instance has ever called v8::Locker. This allows the\n// API code to verify that the lock is always held when V8 is being entered.\nbase::AtomicWord g_locker_was_ever_used_ = 0;\n\n}  // namespace\n        ]]></code>\n    </namespace>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Initialize\",\n                \"parent\": \"Locker\",\n                \"about\": \"Initializes the Locker object, acquiring the lock for the given isolate if necessary.\",\n                \"logic\": \"Checks if the thread already has the lock. If not, acquires the lock and restores thread state if it was previously archived.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"v8::Isolate*\",\n                        \"purpose\": \"The isolate to associate the lock with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"i::Isolate\",\n                    \"IsLockedByCurrentThread\",\n                    \"Lock\",\n                    \"RestoreThread\",\n                    \"set_was_locker_ever_used\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Locker::Initialize(v8::Isolate* isolate) {\n  DCHECK_NOT_NULL(isolate);\n  has_lock_ = false;\n  top_level_ = true;\n  isolate_ = reinterpret_cast<i::Isolate*>(isolate);\n\n  // Record that the Locker has been used at least once.\n  base::Relaxed_Store(&g_locker_was_ever_used_, 1);\n  isolate_->set_was_locker_ever_used();\n\n  // Get the big lock if necessary.\n  if (!isolate_->thread_manager()->IsLockedByCurrentThread()) {\n    isolate_->thread_manager()->Lock();\n    has_lock_ = true;\n\n    // This may be a locker within an unlocker in which case we have to\n    // get the saved state for this thread and restore it.\n    if (isolate_->thread_manager()->RestoreThread()) {\n      top_level_ = false;\n    }\n  }\n  DCHECK(isolate_->thread_manager()->IsLockedByCurrentThread());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsLocked\",\n                \"parent\": \"Locker\",\n                \"about\": \"Checks if the current thread holds the lock for the given isolate.\",\n                \"logic\": \"Delegates the check to the isolate's thread manager.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"v8::Isolate*\",\n                        \"purpose\": \"The isolate to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the current thread holds the lock, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"i::Isolate\",\n                    \"IsLockedByCurrentThread\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Locker::IsLocked(v8::Isolate* isolate) {\n  DCHECK_NOT_NULL(isolate);\n  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n  return i_isolate->thread_manager()->IsLockedByCurrentThread();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"~Locker\",\n                \"parent\": \"Locker\",\n                \"about\": \"Releases the lock when the Locker object is destroyed.\",\n                \"logic\": \"Releases the lock held by the Locker, either freeing thread resources or archiving the thread state depending on whether it's a top-level locker.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"IsLockedByCurrentThread\",\n                    \"FreeThreadResources\",\n                    \"ArchiveThread\",\n                    \"Unlock\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nLocker::~Locker() {\n  DCHECK(isolate_->thread_manager()->IsLockedByCurrentThread());\n  if (has_lock_) {\n    if (top_level_) {\n      isolate_->thread_manager()->FreeThreadResources();\n    } else {\n      isolate_->thread_manager()->ArchiveThread();\n    }\n    isolate_->thread_manager()->Unlock();\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Initialize\",\n                \"parent\": \"Unlocker\",\n                \"about\": \"Initializes the Unlocker object, releasing the lock for the given isolate.\",\n                \"logic\": \"Archives the thread state and releases the lock.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"isolate\",\n                        \"type\": \"v8::Isolate*\",\n                        \"purpose\": \"The isolate to release the lock from.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"i::Isolate\",\n                    \"IsLockedByCurrentThread\",\n                    \"ArchiveThread\",\n                    \"Unlock\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid Unlocker::Initialize(v8::Isolate* isolate) {\n  DCHECK_NOT_NULL(isolate);\n  isolate_ = reinterpret_cast<i::Isolate*>(isolate);\n  DCHECK(isolate_->thread_manager()->IsLockedByCurrentThread());\n  isolate_->thread_manager()->ArchiveThread();\n  isolate_->thread_manager()->Unlock();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"~Unlocker\",\n                \"parent\": \"Unlocker\",\n                \"about\": \"Reacquires the lock when the Unlocker object is destroyed.\",\n                \"logic\": \"Reacquires the lock and restores the thread state.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"IsLockedByCurrentThread\",\n                    \"Lock\",\n                    \"RestoreThread\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nUnlocker::~Unlocker() {\n  DCHECK(!isolate_->thread_manager()->IsLockedByCurrentThread());\n  isolate_->thread_manager()->Lock();\n  isolate_->thread_manager()->RestoreThread();\n}\n        ]]></code>\n    </func>\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"internal\",\n                \"purpose\": \"Groups internal V8 implementation details.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace internal {\n        ]]></code>\n    </namespace>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"InitThread\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Initializes thread-local data for a new thread.\",\n                \"logic\": \"Initializes the thread-local storage for the isolate, stack guard, and debugger.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lock\",\n                        \"type\": \"const ExecutionAccess&\",\n                        \"purpose\": \"Execution access lock.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"InitializeThreadLocal\",\n                    \"InitThread\",\n                    \"debug::InitThread\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ThreadManager::InitThread(const ExecutionAccess& lock) {\n  isolate_->InitializeThreadLocal();\n  isolate_->stack_guard()->InitThread(lock);\n  isolate_->debug()->InitThread(lock);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RestoreThread\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Restores the state of a previously archived thread.\",\n                \"logic\": \"Restores the thread's handle scope, isolate state, relocatable state, stack guard, debugger state, regexp stack, and bootstrapper state.  Handles lazily archived threads and multi-cage pointer compression.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the thread was restored, false if it's a new thread.\"\n                },\n                \"dependencies\": [\n                    \"IsLockedByCurrentThread\",\n                    \"FindPerThreadDataForThisThread\",\n                    \"InitThread\",\n                    \"PtrComprCageAccessScope\",\n                    \"handle_scope_implementer()->RestoreThread\",\n                    \"RestoreThread\",\n                    \"Relocatable::RestoreState\",\n                    \"stack_guard()->RestoreStackGuard\",\n                    \"debug()->RestoreDebug\",\n                    \"regexp_stack()->RestoreStack\",\n                    \"bootstrapper()->RestoreState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool ThreadManager::RestoreThread() {\n  DCHECK(IsLockedByCurrentThread());\n  // First check whether the current thread has been 'lazily archived', i.e.\n  // not archived at all.  If that is the case we put the state storage we\n  // had prepared back in the free list, since we didn't need it after all.\n  if (lazily_archived_thread_ == ThreadId::Current()) {\n    lazily_archived_thread_ = ThreadId::Invalid();\n    Isolate::PerIsolateThreadData* per_thread =\n        isolate_->FindPerThreadDataForThisThread();\n    DCHECK_NOT_NULL(per_thread);\n    DCHECK(per_thread->thread_state() == lazily_archived_thread_state_);\n    lazily_archived_thread_state_->set_id(ThreadId::Invalid());\n    lazily_archived_thread_state_->LinkInto(ThreadState::FREE_LIST);\n    lazily_archived_thread_state_ = nullptr;\n    per_thread->set_thread_state(nullptr);\n    return true;\n  }\n\n  // Make sure that the preemption thread cannot modify the thread state while\n  // it is being archived or restored.\n  ExecutionAccess access(isolate_);\n\n  // If there is another thread that was lazily archived then we have to really\n  // archive it now.\n  if (lazily_archived_thread_.IsValid()) {\n    EagerlyArchiveThread();\n  }\n  Isolate::PerIsolateThreadData* per_thread =\n      isolate_->FindPerThreadDataForThisThread();\n  if (per_thread == nullptr || per_thread->thread_state() == nullptr) {\n    // This is a new thread.\n    InitThread(access);\n    return false;\n  }\n  // In case multi-cage pointer compression mode is enabled ensure that\n  // current thread's cage base values are properly initialized.\n  PtrComprCageAccessScope ptr_compr_cage_access_scope(isolate_);\n\n  ThreadState* state = per_thread->thread_state();\n  char* from = state->data();\n  from = isolate_->handle_scope_implementer()->RestoreThread(from);\n  from = isolate_->RestoreThread(from);\n  from = Relocatable::RestoreState(isolate_, from);\n  // Stack guard should be restored before Debug, etc. since Debug etc. might\n  // depend on a correct stack guard.\n  from = isolate_->stack_guard()->RestoreStackGuard(from);\n  from = isolate_->debug()->RestoreDebug(from);\n  from = isolate_->regexp_stack()->RestoreStack(from);\n  from = isolate_->bootstrapper()->RestoreState(from);\n  per_thread->set_thread_state(nullptr);\n  state->set_id(ThreadId::Invalid());\n  state->Unlink();\n  state->LinkInto(ThreadState::FREE_LIST);\n  return true;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Lock\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Acquires the mutex lock.\",\n                \"logic\": \"Locks the mutex and sets the owner to the current thread.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"IsLockedByCurrentThread\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ThreadManager::Lock() {\n  mutex_.Lock();\n  mutex_owner_.store(ThreadId::Current(), std::memory_order_relaxed);\n  DCHECK(IsLockedByCurrentThread());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Unlock\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Releases the mutex lock.\",\n                \"logic\": \"Unlocks the mutex and resets the owner.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                }\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ThreadManager::Unlock() {\n  mutex_owner_.store(ThreadId::Invalid(), std::memory_order_relaxed);\n  mutex_.Unlock();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"ArchiveSpacePerThread\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Calculates the amount of space required to archive a thread's state.\",\n                \"logic\": \"Sums the archive space requirements of the handle scope implementer, isolate, debugger, stack guard, regexp stack, bootstrapper and relocatable state.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"int\",\n                    \"description\": \"The total archive space per thread.\"\n                },\n                \"dependencies\": [\n                    \"HandleScopeImplementer::ArchiveSpacePerThread\",\n                    \"Isolate::ArchiveSpacePerThread\",\n                    \"Debug::ArchiveSpacePerThread\",\n                    \"StackGuard::ArchiveSpacePerThread\",\n                    \"RegExpStack::ArchiveSpacePerThread\",\n                    \"Bootstrapper::ArchiveSpacePerThread\",\n                    \"Relocatable::ArchiveSpacePerThread\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nstatic int ArchiveSpacePerThread() {\n  return HandleScopeImplementer::ArchiveSpacePerThread() +\n         Isolate::ArchiveSpacePerThread() + Debug::ArchiveSpacePerThread() +\n         StackGuard::ArchiveSpacePerThread() +\n         RegExpStack::ArchiveSpacePerThread() +\n         Bootstrapper::ArchiveSpacePerThread() +\n         Relocatable::ArchiveSpacePerThread();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ThreadState\",\n                \"about\": \"Represents the state of a thread that has been archived.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"id_\",\n                        \"type\": \"ThreadId\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The ID of the archived thread.\"\n                    },\n                    {\n                        \"name\": \"data_\",\n                        \"type\": \"char*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A pointer to the archived data.\"\n                    },\n                    {\n                        \"name\": \"next_\",\n                        \"type\": \"ThreadState*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the next ThreadState in a linked list.\"\n                    },\n                    {\n                        \"name\": \"previous_\",\n                        \"type\": \"ThreadState*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the previous ThreadState in a linked list.\"\n                    },\n                    {\n                        \"name\": \"thread_manager_\",\n                        \"type\": \"ThreadManager*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the ThreadManager which owns this ThreadState.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ThreadId\",\n                    \"ThreadManager\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nThreadState::ThreadState(ThreadManager* thread_manager)\n    : id_(ThreadId::Invalid()),\n      data_(nullptr),\n      next_(this),\n      previous_(this),\n      thread_manager_(thread_manager) {}\n\nThreadState::~ThreadState() { DeleteArray<char>(data_); }\n\nvoid ThreadState::AllocateSpace() {\n  data_ = NewArray<char>(ArchiveSpacePerThread());\n}\n\nvoid ThreadState::Unlink() {\n  next_->previous_ = previous_;\n  previous_->next_ = next_;\n}\n\nvoid ThreadState::LinkInto(List list) {\n  ThreadState* flying_anchor = list == FREE_LIST\n                                   ? thread_manager_->free_anchor_\n                                   : thread_manager_->in_use_anchor_;\n  next_ = flying_anchor->next_;\n  previous_ = flying_anchor;\n  flying_anchor->next_ = this;\n  next_->previous_ = this;\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"GetFreeThreadState\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Gets a free ThreadState object from the free list, allocating a new one if the list is empty.\",\n                \"logic\": \"Retrieves a ThreadState from the free list. If the list is empty, a new ThreadState is allocated and its space initialized.  Note that this implicitly depends on the ArchiveSpacePerThread() function via the AllocateSpace() call on a new object.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"ThreadState*\",\n                    \"description\": \"A pointer to a free ThreadState object.\"\n                },\n                \"dependencies\": [\n                    \"ThreadState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nThreadState* ThreadManager::GetFreeThreadState() {\n  ThreadState* gotten = free_anchor_->next_;\n  if (gotten == free_anchor_) {\n    ThreadState* new_thread_state = new ThreadState(this);\n    new_thread_state->AllocateSpace();\n    return new_thread_state;\n  }\n  return gotten;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FirstThreadStateInUse\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Gets the first ThreadState object in the list of archived threads.\",\n                \"logic\": \"Returns the next element of the in_use_anchor_ object, which acts as a start of the 'in use' linked list.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"ThreadState*\",\n                    \"description\": \"A pointer to the first ThreadState object in use, or nullptr if the list is empty.\"\n                },\n                \"dependencies\": [\n                    \"ThreadState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// Gets the first in the list of archived threads.\nThreadState* ThreadManager::FirstThreadStateInUse() {\n  return in_use_anchor_->Next();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Next\",\n                \"parent\": \"ThreadState\",\n                \"about\": \"Gets the next ThreadState object in the list.\",\n                \"logic\": \"Returns the next ThreadState in the list, or nullptr if the end of the list is reached.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"ThreadState*\",\n                    \"description\": \"A pointer to the next ThreadState object, or nullptr.\"\n                },\n                \"dependencies\": [\n                    \"ThreadManager\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nThreadState* ThreadState::Next() {\n  if (next_ == thread_manager_->in_use_anchor_) return nullptr;\n  return next_;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ThreadManager\",\n                \"about\": \"Manages threads and their associated state within an isolate.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"mutex_owner_\",\n                        \"type\": \"base::Atomic<ThreadId>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The ID of the thread that currently owns the mutex.\"\n                    },\n                    {\n                        \"name\": \"lazily_archived_thread_\",\n                        \"type\": \"ThreadId\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The ID of the thread that was lazily archived.\"\n                    },\n                    {\n                        \"name\": \"lazily_archived_thread_state_\",\n                        \"type\": \"ThreadState*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The ThreadState object for the lazily archived thread.\"\n                    },\n                    {\n                        \"name\": \"free_anchor_\",\n                        \"type\": \"ThreadState*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The anchor ThreadState object for the free list.\"\n                    },\n                    {\n                        \"name\": \"in_use_anchor_\",\n                        \"type\": \"ThreadState*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The anchor ThreadState object for the in-use list.\"\n                    },\n                    {\n                        \"name\": \"isolate_\",\n                        \"type\": \"Isolate*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The isolate to which this ThreadManager belongs.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ThreadId\",\n                    \"ThreadState\",\n                    \"Isolate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// Thread ids must start with 1, because in TLS having thread id 0 can't\n// be distinguished from not having a thread id at all (since NULL is\n// defined as 0.)\nThreadManager::ThreadManager(Isolate* isolate)\n    : mutex_owner_(ThreadId::Invalid()),\n      lazily_archived_thread_(ThreadId::Invalid()),\n      lazily_archived_thread_state_(nullptr),\n      free_anchor_(nullptr),\n      in_use_anchor_(nullptr),\n      isolate_(isolate) {\n  free_anchor_ = new ThreadState(this);\n  in_use_anchor_ = new ThreadState(this);\n}\n\nThreadManager::~ThreadManager() {\n  DeleteThreadStateList(free_anchor_);\n  DeleteThreadStateList(in_use_anchor_);\n}\n\nvoid ThreadManager::DeleteThreadStateList(ThreadState* anchor) {\n  // The list starts and ends with the anchor.\n  for (ThreadState* current = anchor->next_; current != anchor;) {\n    ThreadState* next = current->next_;\n    delete current;\n    current = next;\n  }\n  delete anchor;\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ArchiveThread\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Archives the current thread's state.\",\n                \"logic\": \"Gets a free ThreadState object, unlinks it from the free list, stores the current thread's ID and state in it, and marks the thread as lazily archived.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"GetFreeThreadState\",\n                    \"IsArchived\",\n                    \"IsLockedByCurrentThread\",\n                    \"ThreadState\",\n                    \"FindOrAllocatePerThreadDataForThisThread\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ThreadManager::ArchiveThread() {\n  DCHECK_EQ(lazily_archived_thread_, ThreadId::Invalid());\n  DCHECK(!IsArchived());\n  DCHECK(IsLockedByCurrentThread());\n  ThreadState* state = GetFreeThreadState();\n  state->Unlink();\n  Isolate::PerIsolateThreadData* per_thread =\n      isolate_->FindOrAllocatePerThreadDataForThisThread();\n  per_thread->set_thread_state(state);\n  lazily_archived_thread_ = ThreadId::Current();\n  lazily_archived_thread_state_ = state;\n  DCHECK_EQ(state->id(), ThreadId::Invalid());\n  state->set_id(CurrentId());\n  DCHECK_NE(state->id(), ThreadId::Invalid());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"EagerlyArchiveThread\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Eagerly archives a thread's state that was previously lazily archived.\",\n                \"logic\": \"Links the ThreadState to the in-use list and copies the thread's handle scope, isolate state, relocatable state, stack guard, debugger state, regexp stack, and bootstrapper state into the ThreadState's data buffer.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"IsLockedByCurrentThread\",\n                    \"HandleScopeImplementer::ArchiveThread\",\n                    \"Isolate::ArchiveThread\",\n                    \"Relocatable::ArchiveState\",\n                    \"stack_guard()->ArchiveStackGuard\",\n                    \"debug()->ArchiveDebug\",\n                    \"regexp_stack()->ArchiveStack\",\n                    \"bootstrapper()->ArchiveState\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ThreadManager::EagerlyArchiveThread() {\n  DCHECK(IsLockedByCurrentThread());\n  ThreadState* state = lazily_archived_thread_state_;\n  state->LinkInto(ThreadState::IN_USE_LIST);\n  char* to = state->data();\n  // Ensure that data containing GC roots are archived first, and handle them\n  // in ThreadManager::Iterate(RootVisitor*).\n  to = isolate_->handle_scope_implementer()->ArchiveThread(to);\n  to = isolate_->ArchiveThread(to);\n  to = Relocatable::ArchiveState(isolate_, to);\n  to = isolate_->stack_guard()->ArchiveStackGuard(to);\n  to = isolate_->debug()->ArchiveDebug(to);\n  to = isolate_->regexp_stack()->ArchiveStack(to);\n  to = isolate_->bootstrapper()->ArchiveState(to);\n  lazily_archived_thread_ = ThreadId::Invalid();\n  lazily_archived_thread_state_ = nullptr;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"FreeThreadResources\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Frees the thread-local resources associated with the current thread.\",\n                \"logic\": \"Frees the handle scope, isolate, debugger, stack guard, regexp stack, and bootstrapper resources.  Allows heap access due to potential cage base unsetting.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"handle_scope_implementer()->FreeThreadResources\",\n                    \"Isolate::FreeThreadResources\",\n                    \"debug()->FreeThreadResources\",\n                    \"stack_guard()->FreeThreadResources\",\n                    \"regexp_stack()->FreeThreadResources\",\n                    \"bootstrapper()->FreeThreadResources\",\n                    \"PtrComprCageAccessScope\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ThreadManager::FreeThreadResources() {\n  // This method might be called on a thread that's not bound to any Isolate\n  // and thus pointer compression schemes might have cage base value unset.\n  // So, allow heap access here to let the checks work.\n  PtrComprCageAccessScope ptr_compr_cage_access_scope(isolate_);\n\n  DCHECK(!isolate_->has_exception());\n  DCHECK_NULL(isolate_->try_catch_handler());\n  isolate_->handle_scope_implementer()->FreeThreadResources();\n  isolate_->FreeThreadResources();\n  isolate_->debug()->FreeThreadResources();\n  isolate_->stack_guard()->FreeThreadResources();\n  isolate_->regexp_stack()->FreeThreadResources();\n  isolate_->bootstrapper()->FreeThreadResources();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IsArchived\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Checks if the current thread has been archived.\",\n                \"logic\": \"Checks if the current thread has associated thread-local data and if that data includes a ThreadState object.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the thread is archived, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"FindPerThreadDataForThisThread\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool ThreadManager::IsArchived() {\n  Isolate::PerIsolateThreadData* data =\n      isolate_->FindPerThreadDataForThisThread();\n  return data != nullptr && data->thread_state() != nullptr;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Iterate\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Iterates over all archived threads and visits their GC roots.\",\n                \"logic\": \"Iterates through the list of in-use thread states and calls the iterate methods on the handle scope implementer, isolate, relocatable, stack guard, and debugger for each thread.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"v\",\n                        \"type\": \"RootVisitor*\",\n                        \"purpose\": \"The root visitor to use for iteration.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value\"\n                },\n                \"dependencies\": [\n                    \"FirstThreadStateInUse\",\n                    \"HandleScopeImplementer::Iterate\",\n                    \"Isolate::Iterate\",\n                    \"Relocatable::Iterate\",\n                    \"StackGuard::Iterate\",\n                    \"Debug::Iterate\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid ThreadManager::Iterate(RootVisitor* v) {\n  // Expecting no threads during serialization/deserialization\n  for (ThreadState* state = FirstThreadStateInUse(); state != nullptr;\n       state = state->Next()) {\n    char* data = state->data();\n    data = HandleScopeImplementer::Iterate(v, data);\n    data = isolate_->Iterate(v, data);\n    data = Relocatable::Iterate(v, data);\n    data = StackGuard::Iterate(v, data);\n    data = Debug::Iterate(v, data);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"IterateArchivedThreads\",\n                \"parent\": \"ThreadManager\",\n                \"about\": \"Iterates over archived threads and visits their thread-specific data.\",\n                \"logic\": \"Iterates through the list of in-use thread states and calls IterateThread on the isolate for each thread, starting after handle scope implementer's data.\",\n                \"parameters\": [\n                    {\n                        \"name\":"
}