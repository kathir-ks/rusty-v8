{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/arm/baseline-assembler-arm-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/arm/baseline-assembler-arm-inl.h\",\n        \"file_name\": \"baseline-assembler-arm-inl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides ARM-specific inline implementations for the BaselineAssembler class in V8's baseline compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for baseline assembler functionality, ARM code generation, interface descriptors, and literal objects.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/baseline/baseline-assembler.h\"\n#include \"src/codegen/arm/assembler-arm-inl.h\"\n#include \"src/codegen/interface-descriptors.h\"\n#include \"src/objects/literal-objects-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BaselineAssembler::ScratchRegisterScope\",\n            \"about\": \"Manages a scope for acquiring and releasing scratch registers within the BaselineAssembler.\",\n            \"attributes\": [\n                {\n                    \"name\": \"assembler_\",\n                    \"type\": \"BaselineAssembler*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the BaselineAssembler instance.\"\n                },\n                {\n                    \"name\": \"prev_scope_\",\n                    \"type\": \"ScratchRegisterScope*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the previous ScratchRegisterScope in the stack.\"\n                },\n                {\n                    \"name\": \"wrapped_scope_\",\n                    \"type\": \"UseScratchRegisterScope\",\n                    \"access\": \"private\",\n                    \"purpose\": \"An instance of UseScratchRegisterScope to manage scratch registers using the ARM assembler's scratch register mechanism.\"\n                }\n            ],\n            \"dependencies\": [\n                \"BaselineAssembler\",\n                \"UseScratchRegisterScope\",\n                \"Register\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass BaselineAssembler::ScratchRegisterScope {\n public:\n  explicit ScratchRegisterScope(BaselineAssembler* assembler)\n      : assembler_(assembler),\n        prev_scope_(assembler->scratch_register_scope_),\n        wrapped_scope_(assembler->masm()) {\n    if (!assembler_->scratch_register_scope_) {\n      // If we haven't opened a scratch scope yet, for the first one add a\n      // couple of extra registers.\n      DCHECK(wrapped_scope_.CanAcquire());\n      wrapped_scope_.Include(r8, r9);\n      wrapped_scope_.Include(kInterpreterBytecodeOffsetRegister);\n    }\n    assembler_->scratch_register_scope_ = this;\n  }\n  ~ScratchRegisterScope() { assembler_->scratch_register_scope_ = prev_scope_; }\n\n  Register AcquireScratch() { return wrapped_scope_.Acquire(); }\n\n private:\n  BaselineAssembler* assembler_;\n  ScratchRegisterScope* prev_scope_;\n  UseScratchRegisterScope wrapped_scope_;\n};\n        ]]></code>\n    </class>\n\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"detail\",\n            \"purpose\": \"Contains debugging utility functions.\"\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace detail {\n\n#ifdef DEBUG\ninline bool Clobbers(Register target, MemOperand op) {\n  return op.rn() == target || op.rm() == target;\n}\n#endif\n\n}  // namespace detail\n        ]]></code>\n    </namespace>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterFrameOperand\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Calculates the memory operand for accessing a register within the interpreter's register file on the stack frame.\",\n            \"logic\": \"Calculates the offset from the frame pointer (fp) based on the interpreter register index and the system pointer size.\",\n            \"parameters\": [\n                {\n                    \"name\": \"interpreter_register\",\n                    \"type\": \"interpreter::Register\",\n                    \"purpose\": \"The interpreter register to access.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"The memory operand representing the register's location in the frame.\"\n            },\n            \"dependencies\": [\n                \"interpreter::Register\",\n                \"kSystemPointerSize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::RegisterFrameOperand(\n    interpreter::Register interpreter_register) {\n  return MemOperand(fp, interpreter_register.ToOperand() * kSystemPointerSize);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RegisterFrameAddress\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Calculates the address for accessing a register within the interpreter's register file on the stack frame and stores it in rscratch.\",\n            \"parameters\": [\n                {\n                    \"name\": \"interpreter_register\",\n                    \"type\": \"interpreter::Register\",\n                    \"purpose\": \"The interpreter register to access.\"\n                },\n                {\n                    \"name\": \"rscratch\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register in which to store the calculated address.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"interpreter::Register\",\n                \"kSystemPointerSize\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::RegisterFrameAddress(\n    interpreter::Register interpreter_register, Register rscratch) {\n  return __ add(rscratch, fp,\n                Operand(interpreter_register.ToOperand() * kSystemPointerSize));\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FeedbackVectorOperand\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Calculates the memory operand for accessing the FeedbackVector in the stack frame.\",\n            \"logic\": \"Calculates the offset from the frame pointer (fp) based on BaselineFrameConstants::kFeedbackVectorFromFp.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"The memory operand representing the FeedbackVector's location in the frame.\"\n            },\n            \"dependencies\": [\n                \"BaselineFrameConstants\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackVectorOperand() {\n  return MemOperand(fp, BaselineFrameConstants::kFeedbackVectorFromFp);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"FeedbackCellOperand\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Calculates the memory operand for accessing the FeedbackCell in the stack frame.\",\n            \"logic\": \"Calculates the offset from the frame pointer (fp) based on BaselineFrameConstants::kFeedbackCellFromFp.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"MemOperand\",\n                \"description\": \"The memory operand representing the FeedbackCell's location in the frame.\"\n            },\n            \"dependencies\": [\n                \"BaselineFrameConstants\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nMemOperand BaselineAssembler::FeedbackCellOperand() {\n  return MemOperand(fp, BaselineFrameConstants::kFeedbackCellFromFp);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Bind\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Binds a label to the current code position.\",\n            \"parameters\": [\n                {\n                    \"name\": \"label\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to bind.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::Bind(Label* label) { __ bind(label); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpTarget\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Placeholder function on ARM. Does nothing.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpTarget() {\n  // NOP on arm.\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Jump\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Unconditional jump to a target label.\",\n            \"parameters\": [\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::Jump(Label* target, Label::Distance distance) {\n  __ b(target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfRoot\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register contains a specific root value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The root index to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfRoot(Register value, RootIndex index,\n                                   Label* target, Label::Distance) {\n  __ JumpIfRoot(value, index, target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfNotRoot\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register does not contain a specific root value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"RootIndex\",\n                    \"purpose\": \"The root index to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotRoot(Register value, RootIndex index,\n                                      Label* target, Label::Distance) {\n  __ JumpIfNotRoot(value, index, target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register contains a Smi (small integer).\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Register value, Label* target,\n                                  Label::Distance) {\n  __ JumpIfSmi(value, target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfImmediate\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register's value satisfies a condition when compared to an immediate value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"left\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"right\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The immediate value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfImmediate(Condition cc, Register left, int right,\n                                        Label* target,\n                                        Label::Distance distance) {\n  JumpIf(cc, left, Operand(right), target, distance);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfNotSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register does not contain a Smi (small integer).\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfNotSmi(Register value, Label* target,\n                                     Label::Distance) {\n  __ JumpIfNotSmi(value, target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TestAndBranch\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Performs a bitwise AND operation and jumps to a target label based on the result.\",\n            \"parameters\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to test.\"\n                },\n                {\n                    \"name\": \"mask\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The bitmask to apply.\"\n                },\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::TestAndBranch(Register value, int mask, Condition cc,\n                                      Label* target, Label::Distance) {\n  __ tst(value, Operand(mask));\n  __ b(cc, target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIf\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if the comparison between a register and an operand satisfies a condition.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The left-hand side register.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"Operand\",\n                    \"purpose\": \"The right-hand side operand.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIf(Condition cc, Register lhs, const Operand& rhs,\n                               Label* target, Label::Distance) {\n  __ cmp(lhs, Operand(rhs));\n  __ b(cc, target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfObjectTypeFast\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if an object's type satisfies a condition, using a scratch register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the object.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectTypeFast(Condition cc, Register object,\n                                             InstanceType instance_type,\n                                             Label* target,\n                                             Label::Distance distance) {\n  ScratchRegisterScope temps(this);\n  Register scratch = temps.AcquireScratch();\n  JumpIfObjectType(cc, object, instance_type, scratch, target, distance);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfObjectType\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if an object's type satisfies a condition.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the object.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type to compare against.\"\n                },\n                {\n                    \"name\": \"map\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to load the map into.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\",\n                \"Map\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfObjectType(Condition cc, Register object,\n                                         InstanceType instance_type,\n                                         Register map, Label* target,\n                                         Label::Distance) {\n  ScratchRegisterScope temps(this);\n  Register type = temps.AcquireScratch();\n  __ LoadMap(map, object);\n  __ ldrh(type, FieldMemOperand(map, Map::kInstanceTypeOffset));\n  JumpIf(cc, type, Operand(instance_type), target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfInstanceType\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if the instance type of a map satisfies a condition.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"map\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register containing the map.\"\n                },\n                {\n                    \"name\": \"instance_type\",\n                    \"type\": \"InstanceType\",\n                    \"purpose\": \"The instance type to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\",\n                \"Map\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfInstanceType(Condition cc, Register map,\n                                           InstanceType instance_type,\n                                           Label* target, Label::Distance) {\n  ScratchRegisterScope temps(this);\n  Register type = temps.AcquireScratch();\n  if (v8_flags.debug_code) {\n    __ AssertNotSmi(map);\n    __ CompareObjectType(map, type, type, MAP_TYPE);\n    __ Assert(eq, AbortReason::kUnexpectedValue);\n  }\n  __ ldrh(type, FieldMemOperand(map, Map::kInstanceTypeOffset));\n  JumpIf(cc, type, Operand(instance_type), target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfPointer\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register's value satisfies a condition when compared to a value loaded from memory.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"operand\",\n                    \"type\": \"MemOperand\",\n                    \"purpose\": \"The memory operand to load the comparison value from.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfPointer(Condition cc, Register value,\n                                      MemOperand operand, Label* target,\n                                      Label::Distance) {\n  ScratchRegisterScope temps(this);\n  Register tmp = temps.AcquireScratch();\n  __ ldr(tmp, operand);\n  JumpIf(cc, value, Operand(tmp), target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register contains a specific Smi (small integer) value.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to check.\"\n                },\n                {\n                    \"name\": \"smi\",\n                    \"type\": \"Tagged<Smi>\",\n                    \"purpose\": \"The Smi value to compare against.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Condition cc, Register value, Tagged<Smi> smi,\n                                  Label* target, Label::Distance) {\n  __ AssertSmi(value);\n  JumpIf(cc, value, Operand(smi), target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfSmi\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if two registers both contain Smi (small integer) values and satisfy a condition.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"lhs\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The left-hand side register.\"\n                },\n                {\n                    \"name\": \"rhs\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The right-hand side register.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfSmi(Condition cc, Register lhs, Register rhs,\n                                  Label* target, Label::Distance) {\n  __ AssertSmi(lhs);\n  __ AssertSmi(rhs);\n  JumpIf(cc, lhs, Operand(rhs), target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfTagged\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a register's value satisfies a condition when compared to a tagged value loaded from memory.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"operand\",\n                    \"type\": \"MemOperand\",\n                    \"purpose\": \"The memory operand to load the tagged comparison value from.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfTagged(Condition cc, Register value,\n                                     MemOperand operand, Label* target,\n                                     Label::Distance) {\n  ScratchRegisterScope temps(this);\n  Register tmp = temps.AcquireScratch();\n  __ ldr(tmp, operand);\n  JumpIf(cc, value, Operand(tmp), target);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"JumpIfTagged\",\n            \"parent\": \"BaselineAssembler\",\n            \"about\": \"Jumps to a target label if a memory operand's value satisfies a condition when compared to a tagged value in register.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cc\",\n                    \"type\": \"Condition\",\n                    \"purpose\": \"The condition to check.\"\n                },\n                {\n                    \"name\": \"operand\",\n                    \"type\": \"MemOperand\",\n                    \"purpose\": \"The memory operand to load the tagged comparison value from.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"Register\",\n                    \"purpose\": \"The register to compare.\"\n                },\n                {\n                    \"name\": \"target\",\n                    \"type\": \"Label*\",\n                    \"purpose\": \"The label to jump to.\"\n                },\n                {\n                    \"name\": \"distance\",\n                    \"type\": \"Label::Distance\",\n                    \"purpose\": \"The distance of the jump (near or far).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ScratchRegisterScope\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid BaselineAssembler::JumpIfTagged(Condition cc, MemOperand operand,\n                                     Register value, Label* target,\n                                     Label::"
}