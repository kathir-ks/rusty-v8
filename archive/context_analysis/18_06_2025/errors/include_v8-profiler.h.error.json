{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-profiler.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-profiler.h\",\n        \"file_name\": \"v8-profiler.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the API for the V8 profiler, which includes CPU and heap profiling capabilities.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ libraries and V8-specific headers needed for profiler functionality.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <limits.h>\n\n            #include <memory>\n            #include <unordered_set>\n            #include <vector>\n\n            #include \"cppgc/common.h\"          // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"       // NOLINT(build/include_directory)\n            #include \"v8-message.h\"            // NOLINT(build/include_directory)\n            #include \"v8-persistent-handle.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CpuProfileNode\",\n            \"about\": \"Represents a node in a call graph within a CPU profile.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Local<String>\",\n                \"CpuProfileDeoptInfo\",\n                \"Message\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT CpuProfileNode {\n            public:\n            struct LineTick {\n                /** The 1-based number of the source line where the function originates. */\n                int line;\n\n                /** The count of samples associated with the source line. */\n                unsigned int hit_count;\n            };\n\n            // An annotation hinting at the source of a CpuProfileNode.\n            enum SourceType {\n                // User-supplied script with associated resource information.\n                kScript = 0,\n                // Native scripts and provided builtins.\n                kBuiltin = 1,\n                // Callbacks into native code.\n                kCallback = 2,\n                // VM-internal functions or state.\n                kInternal = 3,\n                // A node that failed to symbolize.\n                kUnresolved = 4,\n            };\n\n            /** Returns function name (empty string for anonymous functions.) */\n            Local<String> GetFunctionName() const;\n\n            /**\n             * Returns function name (empty string for anonymous functions.)\n             * The string ownership is *not* passed to the caller. It stays valid until\n             * profile is deleted. The function is thread safe.\n             */\n            const char* GetFunctionNameStr() const;\n\n            /** Returns id of the script where function is located. */\n            int GetScriptId() const;\n\n            /** Returns resource name for script from where the function originates. */\n            Local<String> GetScriptResourceName() const;\n\n            /**\n             * Returns resource name for script from where the function originates.\n             * The string ownership is *not* passed to the caller. It stays valid until\n             * profile is deleted. The function is thread safe.\n             */\n            const char* GetScriptResourceNameStr() const;\n\n            /**\n             * Return true if the script from where the function originates is flagged as\n             * being shared cross-origin.\n             */\n            bool IsScriptSharedCrossOrigin() const;\n\n            /**\n             * Returns the number, 1-based, of the line where the function originates.\n             * kNoLineNumberInfo if no line number information is available.\n             */\n            int GetLineNumber() const;\n\n            /**\n             * Returns 1-based number of the column where the function originates.\n             * kNoColumnNumberInfo if no column number information is available.\n             */\n            int GetColumnNumber() const;\n\n            /**\n             * Returns the number of the function's source lines that collect the samples.\n             */\n            unsigned int GetHitLineCount() const;\n\n            /** Returns the set of source lines that collect the samples.\n             *  The caller allocates buffer and responsible for releasing it.\n             *  True if all available entries are copied, otherwise false.\n             *  The function copies nothing if buffer is not large enough.\n             */\n            bool GetLineTicks(LineTick* entries, unsigned int length) const;\n\n            /** Returns bailout reason for the function\n             * if the optimization was disabled for it.\n             */\n            const char* GetBailoutReason() const;\n\n            /**\n             * Returns the count of samples where the function was currently executing.\n             */\n            unsigned GetHitCount() const;\n\n            /** Returns id of the node. The id is unique within the tree */\n            unsigned GetNodeId() const;\n\n            /**\n             * Gets the type of the source which the node was captured from.\n             */\n            SourceType GetSourceType() const;\n\n            /** Returns child nodes count of the node. */\n            int GetChildrenCount() const;\n\n            /** Retrieves a child node by index. */\n            const CpuProfileNode* GetChild(int index) const;\n\n            /** Retrieves the ancestor node, or null if the root. */\n            const CpuProfileNode* GetParent() const;\n\n            /** Retrieves deopt infos for the node. */\n            const std::vector<CpuProfileDeoptInfo>& GetDeoptInfos() const;\n\n            static const int kNoLineNumberInfo = Message::kNoLineNumberInfo;\n            static const int kNoColumnNumberInfo = Message::kNoColumnInfo;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"OutputStream\",\n            \"about\": \"An interface for exporting data from V8, using a 'push' model.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"HeapStatsUpdate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT OutputStream {\n            public:\n                enum WriteResult { kContinue = 0, kAbort = 1 };\n                virtual ~OutputStream() = default;\n                /** Notify about the end of stream. */\n                virtual void EndOfStream() = 0;\n                /** Get preferred output chunk size. Called only once. */\n                virtual int GetChunkSize() { return 1024; }\n                /**\n                 * Writes the next chunk of snapshot data into the stream. Writing\n                 * can be stopped by returning kAbort as function result. EndOfStream\n                 * will not be called in case writing was aborted.\n                 */\n                virtual WriteResult WriteAsciiChunk(char* data, int size) = 0;\n                /**\n                 * Writes the next chunk of heap stats data into the stream. Writing\n                 * can be stopped by returning kAbort as function result. EndOfStream\n                 * will not be called in case writing was aborted.\n                 */\n                virtual WriteResult WriteHeapStatsChunk(HeapStatsUpdate* data, int count) {\n                    return kAbort;\n                }\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CpuProfile\",\n            \"about\": \"Contains a CPU profile in a form of top-down call tree.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Local<String>\",\n                \"CpuProfileNode\",\n                \"OutputStream\",\n                \"StateTag\",\n                \"EmbedderStateTag\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT CpuProfile {\n            public:\n                enum SerializationFormat {\n                    kJSON = 0  // See format description near 'Serialize' method.\n                };\n                /** Returns CPU profile title. */\n                Local<String> GetTitle() const;\n\n                /** Returns the root node of the top down call tree. */\n                const CpuProfileNode* GetTopDownRoot() const;\n\n                /**\n                 * Returns number of samples recorded. The samples are not recorded unless\n                 * |record_samples| parameter of CpuProfiler::StartCpuProfiling is true.\n                 */\n                int GetSamplesCount() const;\n\n                /**\n                 * Returns profile node corresponding to the top frame the sample at\n                 * the given index.\n                 */\n                const CpuProfileNode* GetSample(int index) const;\n\n                /**\n                 * Returns the timestamp of the sample. The timestamp is the number of\n                 * microseconds since some unspecified starting point.\n                 * The point is equal to the starting point used by GetStartTime.\n                 */\n                int64_t GetSampleTimestamp(int index) const;\n\n                /**\n                 * Returns time when the profile recording was started (in microseconds)\n                 * since some unspecified starting point.\n                 */\n                int64_t GetStartTime() const;\n\n                /**\n                 * Returns state of the vm when sample was captured.\n                 */\n                StateTag GetSampleState(int index) const;\n\n                /**\n                 * Returns state of the embedder when sample was captured.\n                 */\n                EmbedderStateTag GetSampleEmbedderState(int index) const;\n\n                /**\n                 * Returns time when the profile recording was stopped (in microseconds)\n                 * since some unspecified starting point.\n                 * The point is equal to the starting point used by GetStartTime.\n                 */\n                int64_t GetEndTime() const;\n\n                /**\n                 * Deletes the profile and removes it from CpuProfiler's list.\n                 * All pointers to nodes previously returned become invalid.\n                 */\n                void Delete();\n\n                /**\n                 * Prepare a serialized representation of the profile. The result\n                 * is written into the stream provided in chunks of specified size.\n                 *\n                 * For the JSON format, heap contents are represented as an object\n                 * with the following structure:\n                 *\n                 *  {\n                 *    nodes: [nodes array],\n                 *    startTime: number,\n                 *    endTime: number\n                 *    samples: [strings array]\n                 *    timeDeltas: [numbers array]\n                 *  }\n                 *\n                 */\n                void Serialize(OutputStream* stream,\n                                SerializationFormat format = kJSON) const;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"DiscardedSamplesDelegate\",\n            \"about\": \"Delegate for when max samples reached and samples are discarded.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT DiscardedSamplesDelegate {\n            public:\n                DiscardedSamplesDelegate() = default;\n\n                virtual ~DiscardedSamplesDelegate() = default;\n                virtual void Notify() = 0;\n\n                ProfilerId GetId() const { return profiler_id_; }\n\n            private:\n                friend internal::CpuProfile;\n\n                void SetId(ProfilerId id) { profiler_id_ = id; }\n\n                ProfilerId profiler_id_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CpuProfilingOptions\",\n            \"about\": \"Optional profiling attributes for CPU profiling.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Local<Context>\",\n                \"MaybeLocal<Context>\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT CpuProfilingOptions {\n            public:\n                // Indicates that the sample buffer size should not be explicitly limited.\n                static const unsigned kNoSampleLimit = UINT_MAX;\n\n                /**\n                 * \\param mode Type of computation of stack frame line numbers.\n                 * \\param max_samples The maximum number of samples that should be recorded by\n                 *                    the profiler. Samples obtained after this limit will be\n                 *                    discarded.\n                 * \\param sampling_interval_us controls the profile-specific target\n                 *                             sampling interval. The provided sampling\n                 *                             interval will be snapped to the next lowest\n                 *                             non-zero multiple of the profiler's sampling\n                 *                             interval, set via SetSamplingInterval(). If\n                 *                             zero, the sampling interval will be equal to\n                 *                             the profiler's sampling interval.\n                 * \\param filter_context If specified, profiles will only contain frames\n                 *                       using this context. Other frames will be elided.\n                 */\n                CpuProfilingOptions(\n                    CpuProfilingMode mode = kLeafNodeLineNumbers,\n                    unsigned max_samples = kNoSampleLimit, int sampling_interval_us = 0,\n                    MaybeLocal<Context> filter_context = MaybeLocal<Context>());\n\n                CpuProfilingOptions(CpuProfilingOptions&&) = default;\n                CpuProfilingOptions& operator=(CpuProfilingOptions&&) = default;\n\n                CpuProfilingMode mode() const { return mode_; }\n                unsigned max_samples() const { return max_samples_; }\n                int sampling_interval_us() const { return sampling_interval_us_; }\n\n            private:\n                friend class internal::CpuProfile;\n\n                bool has_filter_context() const { return !filter_context_.IsEmpty(); }\n                void* raw_filter_context() const;\n\n                CpuProfilingMode mode_;\n                unsigned max_samples_;\n                int sampling_interval_us_;\n                Global<Context> filter_context_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CpuProfiler\",\n            \"about\": \"Interface for controlling CPU profiling.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"Local<String>\",\n                \"CpuProfilingOptions\",\n                \"DiscardedSamplesDelegate\",\n                \"CpuProfile\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT CpuProfiler {\n            public:\n                /**\n                 * Creates a new CPU profiler for the |isolate|. The isolate must be\n                 * initialized. The profiler object must be disposed after use by calling\n                 * |Dispose| method.\n                 */\n                static CpuProfiler* New(Isolate* isolate,\n                                        CpuProfilingNamingMode = kDebugNaming,\n                                        CpuProfilingLoggingMode = kLazyLogging);\n\n                /**\n                 * Synchronously collect current stack sample in all profilers attached to\n                 * the |isolate|. The call does not affect number of ticks recorded for\n                 * the current top node.\n                 * |trace_id| is an optional identifier set to the collected sample.\n                 * this is useful to associate the sample with a trace event.\n                 */\n                static void CollectSample(\n                    Isolate* isolate, const std::optional<uint64_t> trace_id = std::nullopt);\n\n                /**\n                 * Disposes the CPU profiler object.\n                 */\n                void Dispose();\n\n                /**\n                 * Changes default CPU profiler sampling interval to the specified number\n                 * of microseconds. Default interval is 1000us. This method must be called\n                 * when there are no profiles being recorded.\n                 */\n                void SetSamplingInterval(int us);\n\n                /**\n                 * Sets whether or not the profiler should prioritize consistency of sample\n                 * periodicity on Windows. Disabling this can greatly reduce CPU usage, but\n                 * may result in greater variance in sample timings from the platform's\n                 * scheduler. Defaults to enabled. This method must be called when there are\n                 * no profiles being recorded.\n                 */\n                void SetUsePreciseSampling(bool);\n\n                /**\n                 * Starts collecting a CPU profile. Several profiles may be collected at once.\n                 * Generates an anonymous profiler, without a String identifier.\n                 */\n                CpuProfilingResult Start(\n                    CpuProfilingOptions options,\n                    std::unique_ptr<DiscardedSamplesDelegate> delegate = nullptr);\n\n                /**\n                 * Starts collecting a CPU profile. Title may be an empty string. Several\n                 * profiles may be collected at once. Attempts to start collecting several\n                 * profiles with the same title are silently ignored.\n                 */\n                CpuProfilingResult Start(\n                    Local<String> title, CpuProfilingOptions options,\n                    std::unique_ptr<DiscardedSamplesDelegate> delegate = nullptr);\n\n                /**\n                 * Starts profiling with the same semantics as above, except with expanded\n                 * parameters.\n                 *\n                 * |record_samples| parameter controls whether individual samples should\n                 * be recorded in addition to the aggregated tree.\n                 *\n                 * |max_samples| controls the maximum number of samples that should be\n                 * recorded by the profiler. Samples obtained after this limit will be\n                 * discarded.\n                 */\n                CpuProfilingResult Start(\n                    Local<String> title, CpuProfilingMode mode, bool record_samples = false,\n                    unsigned max_samples = CpuProfilingOptions::kNoSampleLimit);\n\n                /**\n                 * The same as StartProfiling above, but the CpuProfilingMode defaults to\n                 * kLeafNodeLineNumbers mode, which was the previous default behavior of the\n                 * profiler.\n                 */\n                CpuProfilingResult Start(Local<String> title, bool record_samples = false);\n\n                /**\n                 * Starts collecting a CPU profile. Title may be an empty string. Several\n                 * profiles may be collected at once. Attempts to start collecting several\n                 * profiles with the same title are silently ignored.\n                 */\n                CpuProfilingStatus StartProfiling(\n                    Local<String> title, CpuProfilingOptions options,\n                    std::unique_ptr<DiscardedSamplesDelegate> delegate = nullptr);\n\n                /**\n                 * Starts profiling with the same semantics as above, except with expanded\n                 * parameters.\n                 *\n                 * |record_samples| parameter controls whether individual samples should\n                 * be recorded in addition to the aggregated tree.\n                 *\n                 * |max_samples| controls the maximum number of samples that should be\n                 * recorded by the profiler. Samples obtained after this limit will be\n                 * discarded.\n                 */\n                CpuProfilingStatus StartProfiling(\n                    Local<String> title, CpuProfilingMode mode, bool record_samples = false,\n                    unsigned max_samples = CpuProfilingOptions::kNoSampleLimit);\n\n                /**\n                 * The same as StartProfiling above, but the CpuProfilingMode defaults to\n                 * kLeafNodeLineNumbers mode, which was the previous default behavior of the\n                 * profiler.\n                 */\n                CpuProfilingStatus StartProfiling(Local<String> title,\n                                                    bool record_samples = false);\n\n                /**\n                 * Stops collecting CPU profile with a given id and returns it.\n                 */\n                CpuProfile* Stop(ProfilerId id);\n\n                /**\n                 * Stops collecting CPU profile with a given title and returns it.\n                 * If the title given is empty, finishes the last profile started.\n                 */\n                CpuProfile* StopProfiling(Local<String> title);\n\n                /**\n                 * Generate more detailed source positions to code objects. This results in\n                 * better results when mapping profiling samples to script source.\n                 */\n                static void UseDetailedSourcePositionsForProfiling(Isolate* isolate);\n\n            private:\n                CpuProfiler();\n                ~CpuProfiler();\n                CpuProfiler(const CpuProfiler&);\n                CpuProfiler& operator=(const CpuProfiler&);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"HeapGraphEdge\",\n            \"about\": \"Represents a directed connection between heap graph nodes.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Local<Value>\",\n                \"HeapGraphNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT HeapGraphEdge {\n            public:\n                enum Type {\n                    kContextVariable = 0,  // A variable from a function context.\n                    kElement = 1,          // An element of an array.\n                    kProperty = 2,         // A named object property.\n                    kInternal = 3,         // A link that can't be accessed from JS,\n                                            // thus, its name isn't a real property name\n                                            // (e.g. parts of a ConsString).\n                    kHidden = 4,           // A link that is needed for proper sizes\n                                            // calculation, but may be hidden from user.\n                    kShortcut = 5,         // A link that must not be followed during\n                                            // sizes calculation.\n                    kWeak = 6              // A weak reference (ignored by the GC).\n                };\n\n                /** Returns edge type (see HeapGraphEdge::Type). */\n                Type GetType() const;\n\n                /**\n                 * Returns edge name. This can be a variable name, an element index, or\n                 * a property name.\n                 */\n                Local<Value> GetName() const;\n\n                /** Returns origin node. */\n                const HeapGraphNode* GetFromNode() const;\n\n                /** Returns destination node. */\n                const HeapGraphNode* GetToNode() const;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"HeapGraphNode\",\n            \"about\": \"Represents a node in a heap graph.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Local<String>\",\n                \"HeapGraphEdge\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT HeapGraphNode {\n            public:\n                enum Type {\n                    kHidden = 0,         // Hidden node, may be filtered when shown to user.\n                    kArray = 1,          // An array of elements.\n                    kString = 2,         // A string.\n                    kObject = 3,         // A JS object (except for arrays and strings).\n                    kCode = 4,           // Compiled code.\n                    kClosure = 5,        // Function closure.\n                    kRegExp = 6,         // RegExp.\n                    kHeapNumber = 7,     // Number stored in the heap.\n                    kNative = 8,         // Native object (not from V8 heap).\n                    kSynthetic = 9,      // Synthetic object, usually used for grouping\n                                            // snapshot items together.\n                    kConsString = 10,    // Concatenated string. A pair of pointers to strings.\n                    kSlicedString = 11,  // Sliced string. A fragment of another string.\n                    kSymbol = 12,        // A Symbol (ES6).\n                    kBigInt = 13,        // BigInt.\n                    kObjectShape = 14,   // Internal data used for tracking the shapes (or\n                                            // \"hidden classes\") of JS objects.\n                };\n\n                /** Returns node type (see HeapGraphNode::Type). */\n                Type GetType() const;\n\n                /**\n                 * Returns node name. Depending on node's type this can be the name\n                 * of the constructor (for objects), the name of the function (for\n                 * closures), string value, or an empty string (for compiled code).\n                 */\n                Local<String> GetName() const;\n\n                /**\n                 * Returns node id. For the same heap object, the id remains the same\n                 * across all snapshots.\n                 */\n                SnapshotObjectId GetId() const;\n\n                /** Returns node's own size, in bytes. */\n                size_t GetShallowSize() const;\n\n                /** Returns child nodes count of the node. */\n                int GetChildrenCount() const;\n\n                /** Retrieves a child by index. */\n                const HeapGraphEdge* GetChild(int index) const;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"HeapSnapshot\",\n            \"about\": \"Represents a heap snapshot, recording the state of the JS heap at some moment.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"HeapGraphNode\",\n                \"OutputStream\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT HeapSnapshot {\n            public:\n                enum SerializationFormat {\n                    kJSON = 0  // See format description near 'Serialize' method.\n                };\n\n                /** Returns the root node of the heap graph. */\n                const HeapGraphNode* GetRoot() const;\n\n                /** Returns a node by its id. */\n                const HeapGraphNode* GetNodeById(SnapshotObjectId id) const;\n\n                /** Returns total nodes count in the snapshot. */\n                int GetNodesCount() const;\n\n                /** Returns a node by index. */\n                const HeapGraphNode* GetNode(int index) const;\n\n                /** Returns a max seen JS object Id. */\n                SnapshotObjectId GetMaxSnapshotJSObjectId() const;\n\n                /**\n                 * Deletes the snapshot and removes it from HeapProfiler's list.\n                 * All pointers to nodes, edges and paths previously returned become\n                 * invalid.\n                 */\n                void Delete();\n\n                /**\n                 * Prepare a serialized representation of the snapshot. The result\n                 * is written into the stream provided in chunks of specified size.\n                 * The total length of the serialized snapshot is unknown in\n                 * advance, it can be roughly equal to JS heap size (that means,\n                 * it can be really big - tens of megabytes).\n                 *\n                 * For the JSON format, heap contents are represented as an object\n                 * with the following structure:\n                 *\n                 *  {\n                 *    snapshot: {\n                 *      title: \"...\",\n                 *      uid: nnn,\n                 *      meta: { meta-info },\n                 *      node_count: nnn,\n                 *      edge_count: nnn\n                 *    },\n                 *    nodes: [nodes array],\n                 *    edges: [edges array],\n                 *    strings: [strings array]\n                 *  }\n                 *\n                 * Nodes reference strings, other nodes, and edges by their indexes\n                 * in corresponding arrays.\n                 */\n                void Serialize(OutputStream* stream,\n                                SerializationFormat format = kJSON) const;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ActivityControl\",\n            \"about\": \"An interface for reporting progress and controlling long-running activities.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT ActivityControl {\n            public:\n                enum ControlOption {\n                    kContinue = 0,\n                    kAbort = 1\n                };\n                virtual ~ActivityControl() = default;\n                /**\n                 * Notify about current progress. The activity can be stopped by\n                 * returning kAbort as the callback result.\n                 */\n                virtual ControlOption ReportProgressValue(uint32_t done, uint32_t total) = 0;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AllocationProfile\",\n            \"about\": \"A sampled profile of allocations done by the program, structured as a call-graph.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Local<String>\",\n                \"Message\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT AllocationProfile {\n            public:\n                struct Allocation {\n                    /**\n                     * Size of the sampled allocation object.\n                     */\n                    size_t size;\n\n                    /**\n                     * The number of objects of such size that were sampled.\n                     */\n                    unsigned int count;\n                };\n\n                /**\n                 * Represents a node in the call-graph.\n                 */\n                struct Node {\n                    /**\n                     * Name of the function. May be empty for anonymous functions or if the\n                     * script corresponding to this function has been unloaded.\n                     */\n                    Local<String> name;\n\n                    /**\n                     * Name of the script containing the function. May be empty if the script\n                     * name is not available, or if the script has been unloaded.\n                     */\n                    Local<String> script_name;\n\n                    /**\n                     * id of the script where the function is located. May be equal to\n                     * v8::UnboundScript::kNoScriptId in cases where the script doesn't exist.\n                     */\n                    int script_id;\n\n                    /**\n                     * Start position of the function in the script.\n                     */\n                    int start_position;\n\n                    /**\n                     * 1-indexed line number where the function starts. May be\n                     * kNoLineNumberInfo if no line number information is available.\n                     */\n                    int line_number;\n\n                    /**\n                     * 1-indexed column number where the function starts. May be\n                     * kNoColumnNumberInfo if no column number information is available.\n                     */\n                    int column_number;\n\n                    /**\n                     * Unique id of the node.\n                     */\n                    uint32_t node_id;\n\n                    /**\n                     * List of callees called from this node for which we have sampled\n                     * allocations. The lifetime of the children is scoped to the containing\n                     * AllocationProfile.\n                     */\n                    std::vector<Node*> children;\n\n                    /**\n                     * List of self allocations done by this node in the call-graph.\n                     */\n                    std::vector<Allocation> allocations;\n                };\n\n                /**\n                 * Represent a single sample recorded for an allocation.\n                 */\n                struct Sample {\n                    /**\n                     * id of the node in the profile tree.\n                     */\n                    uint32_t node_id;\n\n                    /**\n                     * Size of the sampled allocation object.\n                     */\n                    size_t size;\n\n                    /**\n                     * The number of objects of such size that were sampled.\n                     */\n                    unsigned int count;\n\n                    /**\n                     * Unique time-ordered id of the allocation sample. Can be used to track\n                     * what samples were added or removed between two snapshots.\n                     */\n                    uint64_t sample_id;\n                };\n\n                /**\n                 * Returns the root node of the call-graph. The root node corresponds to an\n                 * empty JS call-stack. The lifetime of the returned Node* is scoped to the\n                 * containing AllocationProfile.\n                 */\n                virtual Node* GetRootNode() = 0;\n                virtual const std::vector<Sample>& GetSamples() = 0;\n\n                virtual ~AllocationProfile() = default;\n\n                static const int kNoLineNumberInfo = Message::kNoLineNumberInfo;\n                static const int kNoColumnNumberInfo = Message::kNoColumnInfo;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EmbedderGraph\",\n            \"about\": \"Represents an object graph consisting of embedder objects and V8 objects.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Local<Value>\",\n                \"Local<Data>\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT EmbedderGraph {\n            public:\n                class Node {\n                public:\n                    /**\n                     * Detachedness specifies whether an object is attached or detached from the\n                     * main application state. While unkown in general, there may be objects\n                     * that specifically know their state. V8 passes this information along in\n                     * the snapshot. Users of the snapshot may use it to annotate the object\n                     * graph.\n                     */\n                    enum class Detachedness : uint8_t {\n                        kUnknown = 0,\n                        kAttached = 1,\n                        kDetached = 2,\n                    };\n\n                    Node() = default;\n                    virtual ~Node() = default;\n                    virtual const char* Name() = 0;\n                    virtual size_t SizeInBytes() = 0;\n                    /**\n                     * The corresponding V8 wrapper node if not null.\n                     * During heap snapshot generation the embedder node and the V8 wrapper\n                     * node will be merged into one node to simplify retaining paths.\n                     */\n                    virtual Node* WrapperNode() { return nullptr; }\n                    virtual bool IsRootNode() { return false; }\n                    /** Must return true for non-V8 nodes. */\n                    virtual bool IsEmbedderNode() { return true; }\n                    /**\n                     * Optional name prefix. It is used in Chrome for tagging detached nodes.\n                     */\n                    virtual const char* NamePrefix() { return nullptr; }\n\n                    /**\n                     * Returns the NativeObject that can be used for querying the\n                     * |HeapSnapshot|.\n                     */\n                    virtual NativeObject GetNativeObject() { return nullptr; }\n\n                    /**\n                     * Detachedness state of a given object. While unkown in general, there may\n                     * be objects that specifically know their state. V8 passes this information\n                     * along in the snapshot. Users of the snapshot may use it to annotate the\n                     * object graph.\n                     */\n                    virtual Detachedness GetDetachedness() { return Detachedness::kUnknown; }\n\n                    /**\n                     * Returns the address of the object in the embedder heap, or nullptr to not\n                     * specify the address. If this address is provided, then V8 can generate\n                     * consistent IDs for objects across subsequent heap snapshots, which allows\n                     * devtools to determine which objects were retained from one snapshot to\n                     * the next. This value is used only if GetNativeObject returns nullptr.\n                     */\n                    virtual const void* GetAddress() { return nullptr; }\n\n                    Node(const Node&) = delete;\n                    Node& operator=(const Node&) = delete;\n                };\n\n                /**\n                 * Returns a node corresponding to the given V8 value. Ownership is not\n                 * transferred. The result pointer is valid while the graph is alive.\n                 *\n                 * For now the variant that takes v8::Data is not marked as abstract for\n                 * compatibility, but embedders who subclass EmbedderGraph are expected to\n                 * implement it. Then in the implementation of the variant that takes\n                 * v8::Value, they can simply forward the call to the one that takes\n                 * v8::Local<v8::Data>.\n                 */\n                virtual Node* V8Node(const v8::Local<v8::Value>& value) = 0;\n\n                /**\n                 * Returns a node corresponding to the given V8 value. Ownership is not\n                 * transferred. The result pointer is valid while the graph is alive.\n                 *\n                 * For API compatibility, this default implementation just checks that the\n                 * data is a v8::Value and forward it to the variant that takes v8::Value,\n                 * which is currently required to be implemented. In the future we'll remove\n                 * the v8::Value variant, and make this variant that takes v8::Data abstract\n                 * instead. If the embedder subclasses v8::EmbedderGraph and also use\n                 * v8::TracedReference<v8::Data>, they must"
}