{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/use-map.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 46, column 50",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/use-map.h\",\n        \"file_name\": \"use-map.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the UseMap class and related functionality for computing and accessing uses of operations in a Turboshaft graph.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes the Sidetable class definition.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turboshaft/sidetable.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"UseMap\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Computes uses of all operations of the given turboshaft graph. It provides a mapping from `OpIndex` to its `uses`.\",\n            \"attributes\": [\n                {\n                    \"name\": \"table_\",\n                    \"type\": \"FixedOpIndexSidetable<PerOperationUses>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the use information for each operation, indexed by OpIndex.\"\n                },\n                {\n                    \"name\": \"uses_\",\n                    \"type\": \"ZoneVector<OpIndex>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector of OpIndices representing the direct uses of an operation.  Used when the number of uses is small.\"\n                },\n                {\n                    \"name\": \"saturated_uses_\",\n                    \"type\": \"ZoneVector<ZoneVector<OpIndex>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A vector of ZoneVectors of OpIndices. Used when the number of uses exceeds the capacity of uses_.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Graph\",\n                \"Operation\",\n                \"OpIndex\",\n                \"Zone\",\n                \"ZoneVector\",\n                \"FixedOpIndexSidetable\",\n                \"base::Vector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass UseMap {\n  struct PerOperationUses {\n    // We encode offsets as follows:\n    // offset < 0: -offset-1 indexes into {saturated_uses_}.\n    // offset = 0: definition not visited yet.\n    // offset > 0: offset indexes into {uses_}.\n    int32_t offset = 0;\n    uint32_t count = 0;\n  };\n\n public:\n  UseMap(const Graph& graph, Zone* zone, FunctionType filter);\n\n  UseMap(const Graph& graph, Zone* zone)\n      : UseMap(graph, zone,\n               [](const Operation& op, Zone* zone) { return false; }) {}\n\n  base::Vector<const OpIndex> uses(OpIndex index) const;\n\n private:\n  void AddUse(const Graph* graph, OpIndex node, OpIndex use);\n\n  FixedOpIndexSidetable<PerOperationUses> table_;\n  ZoneVector<OpIndex> uses_;\n  ZoneVector<ZoneVector<OpIndex>> saturated_uses_;\n};\n        ]]></code>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"PerOperationUses\",\n                \"about\": \"Struct to hold offset and count of each operation's uses\",\n                \"attributes\":[\n                    {\n                        \"name\": \"offset\",\n                        \"type\": \"int32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the offset to find the uses of the operation\"\n                    },\n                    {\n                        \"name\": \"count\",\n                        \"type\": \"uint32_t\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Stores the number of uses\"\n                    }\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n                struct PerOperationUses {\n                    // We encode offsets as follows:\n                    // offset < 0: -offset-1 indexes into {saturated_uses_}.\n                    // offset = 0: definition not visited yet.\n                    // offset > 0: offset indexes into {uses_}.\n                    int32_t offset = 0;\n                    uint32_t count = 0;\n                };\n            ]]></code>\n        </class>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constructor\",\n                \"name\": \"UseMap\",\n                \"parent\": \"UseMap\",\n                \"about\": \"Constructor for UseMap that takes a filter function\",\n                \"parameters\": [\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const Graph&\",\n                        \"purpose\": \"The Turboshaft graph to analyze.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to use for allocations.\"\n                    },\n                    {\n                        \"name\": \"filter\",\n                        \"type\": \"FunctionType\",\n                        \"purpose\": \"A function pointer that filters which operations should be tracked.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Graph\",\n                    \"Zone\",\n                    \"FunctionType\",\n                    \"FixedOpIndexSidetable\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n  UseMap(const Graph& graph, Zone* zone, FunctionType filter);\n            ]]></code>\n        </func>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constructor\",\n                \"name\": \"UseMap\",\n                \"parent\": \"UseMap\",\n                \"about\": \"Constructor for UseMap that defaults the filter function to always return false\",\n                \"parameters\": [\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const Graph&\",\n                        \"purpose\": \"The Turboshaft graph to analyze.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to use for allocations.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Graph\",\n                    \"Zone\",\n                    \"FunctionType\",\n                    \"FixedOpIndexSidetable\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n  UseMap(const Graph& graph, Zone* zone)\n      : UseMap(graph, zone,\n               [](const Operation& op, Zone* zone) { return false; }) {}\n            ]]></code>\n        </func>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"uses\",\n                \"parent\": \"UseMap\",\n                \"about\": \"Returns a vector of OpIndices that use the operation at the given index.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"index\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The index of the operation to get uses for.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"base::Vector<const OpIndex>\",\n                    \"description\": \"A vector of OpIndices that use the operation at the given index.\"\n                },\n                \"dependencies\": [\n                    \"OpIndex\",\n                    \"base::Vector\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n  base::Vector<const OpIndex> uses(OpIndex index) const;\n            ]]></code>\n        </func>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddUse\",\n                \"parent\": \"UseMap\",\n                \"about\": \"Adds a use to the use map.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const Graph*\",\n                        \"purpose\": \"The Turboshaft graph.\"\n                    },\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The index of the operation being used.\"\n                    },\n                    {\n                        \"name\": \"use\",\n                        \"type\": \"OpIndex\",\n                        \"purpose\": \"The index of the operation that is using the node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Graph\",\n                    \"OpIndex\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n  void AddUse(const Graph* graph, OpIndex node, OpIndex use);\n            ]]></code>\n        </func>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimdUseMap\",\n            \"extends\": \"UseMap\",\n            \"implements\": [],\n            \"about\": \"Computes uses of SIMD operations of the given turboshaft graph and skip other operations.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"UseMap\",\n                \"Graph\",\n                \"Zone\",\n                \"Operation\",\n                \"RegisterRepresentation\",\n                \"MaybeRegisterRepresentation\",\n                \"ZoneVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass SimdUseMap : public UseMap, public NON_EXPORTED_BASE(ZoneObject) {\n public:\n  SimdUseMap(const Graph& graph, Zone* zone)\n      : UseMap(graph, zone, [](const Operation& op, Zone* zone) {\n          if (op.outputs_rep().size() == 1 &&\n              op.outputs_rep()[0] == RegisterRepresentation::Simd128()) {\n            return false;\n          }\n\n          ZoneVector<MaybeRegisterRepresentation> storage(zone);\n          for (auto rep : op.inputs_rep(storage)) {\n            if (rep == MaybeRegisterRepresentation::Simd128()) return false;\n          }\n          return true;\n        }) {}\n};\n        ]]></code>\n\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constructor\",\n                \"name\": \"SimdUseMap\",\n                \"parent\": \"SimdUseMap\",\n                \"about\": \"Constructor for SimdUseMap.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"const Graph&\",\n                        \"purpose\": \"The Turboshaft graph to analyze.\"\n                    },\n                    {\n                        \"name\": \"zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"The memory zone to use for allocations.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"N/A\"\n                },\n                \"dependencies\": [\n                    \"Graph\",\n                    \"Zone\",\n                    \"UseMap\",\n                    \"Operation\",\n                    \"RegisterRepresentation\",\n                    \"MaybeRegisterRepresentation\",\n                    \"ZoneVector\"\n                ]\n            }\n            </metadata>\n            <code><![CDATA[\n  SimdUseMap(const Graph& graph, Zone* zone)\n      : UseMap(graph, zone, [](const Operation& op, Zone* zone) {\n          if (op.outputs_rep().size() == 1 &&\n              op.outputs_rep()[0] == RegisterRepresentation::Simd128()) {\n            return false;\n          }\n\n          ZoneVector<MaybeRegisterRepresentation> storage(zone);\n          for (auto rep : op.inputs_rep(storage)) {\n            if (rep == MaybeRegisterRepresentation::Simd128()) return false;\n          }\n          return true;\n        }) {}\n            ]]></code>\n        </func>\n    </class>\n\n    <typedef>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"FunctionType\",\n            \"type\": \"bool (*)(const Operation& op, Zone* zone)\",\n            \"about\": \"Defines a function type for filtering operations.\",\n            \"dependencies\": [\n                \"Operation\",\n                \"Zone\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntypedef bool (*FunctionType)(const Operation& op, Zone* zone);\n        ]]></code>\n    </typedef>\n</file>\n```"
}