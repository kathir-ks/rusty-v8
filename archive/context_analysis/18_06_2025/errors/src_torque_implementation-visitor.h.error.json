{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/implementation-visitor.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/implementation-visitor.h\",\n            \"file_name\": \"implementation-visitor.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Defines the ImplementationVisitor class and related data structures used for traversing and processing the Torque AST to generate code.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes standard library headers and Torque-specific headers for memory management, optional types, string manipulation, AST traversal, control flow graph manipulation, C++ code building, declaration management, global context access, type information, and utility functions.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include <memory>\n            #include <optional>\n            #include <string>\n\n            #include \"src/base/macros.h\"\n            #include \"src/torque/ast.h\"\n            #include \"src/torque/cfg.h\"\n            #include \"src/torque/cpp-builder.h\"\n            #include \"src/torque/declarations.h\"\n            #include \"src/torque/global-context.h\"\n            #include \"src/torque/type-oracle.h\"\n            #include \"src/torque/types.h\"\n            #include \"src/torque/utils.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocationReference\",\n                \"about\": \"Represents an l-value (assignable value) or an unassignable temporary in Torque code. It can represent stack variables, field/element accesses, heap references, or bitfield accesses.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"variable_\",\n                        \"type\": \"std::optional<VisitResult>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the VisitResult for variable access.\"\n                    },\n                    {\n                        \"name\": \"temporary_\",\n                        \"type\": \"std::optional<VisitResult>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the VisitResult for temporary values.\"\n                    },\n                    {\n                        \"name\": \"temporary_description_\",\n                        \"type\": \"std::optional<std::string>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores a description of temporary values for error messages.\"\n                    },\n                    {\n                        \"name\": \"heap_reference_\",\n                        \"type\": \"std::optional<VisitResult>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the VisitResult for heap references (tagged value and offset).\"\n                    },\n                    {\n                        \"name\": \"heap_reference_synchronization_\",\n                        \"type\": \"FieldSynchronization\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the synchronization mode for heap references.\"\n                    },\n                    {\n                        \"name\": \"heap_slice_\",\n                        \"type\": \"std::optional<VisitResult>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the VisitResult for heap slices (array on the heap).\"\n                    },\n                    {\n                        \"name\": \"eval_function_\",\n                        \"type\": \"std::optional<std::string>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the name of the eval function for call access.\"\n                    },\n                    {\n                        \"name\": \"assign_function_\",\n                        \"type\": \"std::optional<std::string>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the name of the assign function for call access.\"\n                    },\n                    {\n                        \"name\": \"call_arguments_\",\n                        \"type\": \"VisitResultVector\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the arguments for call access.\"\n                    },\n                    {\n                        \"name\": \"binding_\",\n                        \"type\": \"std::optional<Binding<LocalValue>*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the binding for variable access.\"\n                    },\n                    {\n                        \"name\": \"bit_field_struct_\",\n                        \"type\": \"std::shared_ptr<const LocationReference>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the location of the struct for bitfield access.\"\n                    },\n                    {\n                        \"name\": \"bit_field_\",\n                        \"type\": \"std::optional<BitField>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the BitField for bitfield access.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"VisitResult\",\n                    \"Binding\",\n                    \"LocalValue\",\n                    \"FieldSynchronization\",\n                    \"TypeOracle\",\n                    \"Type\",\n                    \"BitField\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class LocationReference {\n            public:\n            // An assignable stack range.\n            static LocationReference VariableAccess(\n                VisitResult variable,\n                std::optional<Binding<LocalValue>*> binding = std::nullopt) {\n                DCHECK(variable.IsOnStack());\n                LocationReference result;\n                result.variable_ = std::move(variable);\n                result.binding_ = binding;\n                return result;\n            }\n            // An unassignable value. {description} is only used for error messages.\n            static LocationReference Temporary(VisitResult temporary,\n                                                std::string description) {\n                LocationReference result;\n                result.temporary_ = std::move(temporary);\n                result.temporary_description_ = std::move(description);\n                return result;\n            }\n            // A heap reference, that is, a tagged value and an offset to encode an inner\n            // pointer.\n            static LocationReference HeapReference(\n                VisitResult heap_reference,\n                FieldSynchronization synchronization = FieldSynchronization::kNone) {\n                LocationReference result;\n                DCHECK(TypeOracle::MatchReferenceGeneric(heap_reference.type()));\n                result.heap_reference_ = std::move(heap_reference);\n                result.heap_reference_synchronization_ = synchronization;\n                return result;\n            }\n            // A reference to an array on the heap. That is, a tagged value, an offset to\n            // encode an inner pointer, and the number of elements.\n            static LocationReference HeapSlice(VisitResult heap_slice) {\n                LocationReference result;\n                DCHECK(Type::MatchUnaryGeneric(heap_slice.type(),\n                                                TypeOracle::GetConstSliceGeneric()) ||\n                    Type::MatchUnaryGeneric(heap_slice.type(),\n                                                TypeOracle::GetMutableSliceGeneric()));\n                result.heap_slice_ = std::move(heap_slice);\n                return result;\n            }\n            static LocationReference ArrayAccess(VisitResult base, VisitResult offset) {\n                LocationReference result;\n                result.eval_function_ = std::string{\"[]\"};\n                result.assign_function_ = std::string{\"[]=\"};\n                result.call_arguments_ = {base, offset};\n                return result;\n            }\n            static LocationReference FieldAccess(VisitResult object,\n                                                std::string fieldname) {\n                LocationReference result;\n                result.eval_function_ = \".\" + fieldname;\n                result.assign_function_ = \".\" + fieldname + \"=\";\n                result.call_arguments_ = {object};\n                return result;\n            }\n            static LocationReference BitFieldAccess(const LocationReference& object,\n                                                BitField field) {\n                LocationReference result;\n                result.bit_field_struct_ = std::make_shared<LocationReference>(object);\n                result.bit_field_ = std::move(field);\n                return result;\n            }\n\n            bool IsConst() const {\n                if (IsHeapReference()) {\n                bool is_const;\n                bool success =\n                    TypeOracle::MatchReferenceGeneric(heap_reference().type(), &is_const)\n                        .has_value();\n                CHECK(success);\n                return is_const;\n                }\n                return IsTemporary();\n            }\n\n            bool IsVariableAccess() const { return variable_.has_value(); }\n            const VisitResult& variable() const {\n                DCHECK(IsVariableAccess());\n                return *variable_;\n            }\n            bool IsTemporary() const { return temporary_.has_value(); }\n            const VisitResult& temporary() const {\n                DCHECK(IsTemporary());\n                return *temporary_;\n            }\n            bool IsHeapReference() const { return heap_reference_.has_value(); }\n            const VisitResult& heap_reference() const {\n                DCHECK(IsHeapReference());\n                return *heap_reference_;\n            }\n            FieldSynchronization heap_reference_synchronization() const {\n                DCHECK(IsHeapReference());\n                return heap_reference_synchronization_;\n            }\n            bool IsHeapSlice() const { return heap_slice_.has_value(); }\n            const VisitResult& heap_slice() const {\n                DCHECK(IsHeapSlice());\n                return *heap_slice_;\n            }\n            bool IsBitFieldAccess() const {\n                bool is_bitfield_access = bit_field_struct_ != nullptr;\n                DCHECK_EQ(is_bitfield_access, bit_field_.has_value());\n                return is_bitfield_access;\n            }\n            const LocationReference& bit_field_struct_location() const {\n                DCHECK(IsBitFieldAccess());\n                return *bit_field_struct_;\n            }\n            const BitField& bit_field() const {\n                DCHECK(IsBitFieldAccess());\n                return *bit_field_;\n            }\n\n            std::optional<const Type*> ReferencedType() const {\n                if (IsHeapReference()) {\n                return *TypeOracle::MatchReferenceGeneric(heap_reference().type());\n                }\n                if (IsHeapSlice()) {\n                if (auto type = Type::MatchUnaryGeneric(\n                        heap_slice().type(), TypeOracle::GetMutableSliceGeneric())) {\n                    return *type;\n                }\n                return Type::MatchUnaryGeneric(heap_slice().type(),\n                                                TypeOracle::GetConstSliceGeneric());\n                }\n                if (IsBitFieldAccess()) {\n                return bit_field_->name_and_type.type;\n                }\n                if (IsVariableAccess() || IsHeapSlice() || IsTemporary()) {\n                return GetVisitResult().type();\n                }\n                return std::nullopt;\n            }\n\n            const VisitResult& GetVisitResult() const {\n                if (IsVariableAccess()) return variable();\n                if (IsHeapSlice()) return heap_slice();\n                DCHECK(IsTemporary());\n                return temporary();\n            }\n\n            // For error reporting.\n            const std::string& temporary_description() const {\n                DCHECK(IsTemporary());\n                return *temporary_description_;\n            }\n\n            bool IsCallAccess() const {\n                bool is_call_access = eval_function_.has_value();\n                DCHECK_EQ(is_call_access, assign_function_.has_value());\n                return is_call_access;\n            }\n            const VisitResultVector& call_arguments() const {\n                DCHECK(IsCallAccess());\n                return call_arguments_;\n            }\n            const std::string& eval_function() const {\n                DCHECK(IsCallAccess());\n                return *eval_function_;\n            }\n            const std::string& assign_function() const {\n                DCHECK(IsCallAccess());\n                return *assign_function_;\n            }\n            std::optional<Binding<LocalValue>*> binding() const {\n                DCHECK(IsVariableAccess());\n                return binding_;\n            }\n\n            private:\n            std::optional<VisitResult> variable_;\n            std::optional<VisitResult> temporary_;\n            std::optional<std::string> temporary_description_;\n            std::optional<VisitResult> heap_reference_;\n            FieldSynchronization heap_reference_synchronization_ =\n                FieldSynchronization::kNone;\n            std::optional<VisitResult> heap_slice_;\n            std::optional<std::string> eval_function_;\n            std::optional<std::string> assign_function_;\n            VisitResultVector call_arguments_;\n            std::optional<Binding<LocalValue>*> binding_;\n\n            // The location of the bitfield struct that contains this bitfield, if this\n            // reference is a bitfield access. Uses a shared_ptr so that LocationReference\n            // is copyable, allowing us to set this field equal to a copy of a\n            // stack-allocated LocationReference.\n            std::shared_ptr<const LocationReference> bit_field_struct_;\n            std::optional<BitField> bit_field_;\n\n            LocationReference() = default;\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"InitializerResults\",\n                \"about\": \"Stores the results of visiting initializers for classes and structs.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"names\",\n                        \"type\": \"std::vector<Identifier*>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"List of identifiers representing the names of the initialized fields.\"\n                    },\n                    {\n                        \"name\": \"field_value_map\",\n                        \"type\": \"std::map<std::string, VisitResult>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Mapping from field name to the VisitResult of its initializer expression.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Identifier\",\n                    \"VisitResult\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct InitializerResults {\n            std::vector<Identifier*> names;\n            std::map<std::string, VisitResult> field_value_map;\n            };\n        ]]></code>\n    </struct>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"LayoutForInitialization\",\n                \"about\": \"Stores the layout information needed for initializing class or struct fields, including array lengths, offsets, and total size.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"array_lengths\",\n                        \"type\": \"std::map<std::string, VisitResult>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Mapping from array field name to its length (VisitResult).\"\n                    },\n                    {\n                        \"name\": \"offsets\",\n                        \"type\": \"std::map<std::string, VisitResult>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Mapping from field name to its offset (VisitResult).\"\n                    },\n                    {\n                        \"name\": \"size\",\n                        \"type\": \"VisitResult\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Total size of the layout.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"VisitResult\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct LayoutForInitialization {\n            std::map<std::string, VisitResult> array_lengths;\n            std::map<std::string, VisitResult> offsets;\n            VisitResult size;\n            };\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"variable\",\n                \"name\": \"next_unique_binding_index\",\n                \"about\": \"Globally visible unique index counter for bindings.\",\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            extern uint64_t next_unique_binding_index;\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Binding\",\n                \"about\": \"Represents a binding of a name to a value of type T, managed by a BindingsManager. It handles linting for unused or unassigned variables.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"manager_\",\n                        \"type\": \"BindingsManager<T>*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the BindingsManager that manages this binding.\"\n                    },\n                    {\n                        \"name\": \"name_\",\n                        \"type\": \"const std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The name of the binding.\"\n                    },\n                    {\n                        \"name\": \"previous_binding_\",\n                        \"type\": \"std::optional<Binding*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the previous binding with the same name (for shadowing).\"\n                    },\n                    {\n                        \"name\": \"declaration_position_\",\n                        \"type\": \"SourcePosition\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The source code position where the binding was declared.\"\n                    },\n                    {\n                        \"name\": \"used_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the binding has been used.\"\n                    },\n                    {\n                        \"name\": \"written_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the binding has been written to.\"\n                    },\n                    {\n                        \"name\": \"unique_index_\",\n                        \"type\": \"uint64_t\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Unique index for the binding.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BindingsManager\",\n                    \"SourcePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            class Binding : public T {\n            public:\n            template <class... Args>\n            Binding(BindingsManager<T>* manager, const std::string& name, Args&&... args)\n                : T(std::forward<Args>(args)...),\n                manager_(manager),\n                name_(name),\n                previous_binding_(this),\n                used_(false),\n                written_(false),\n                unique_index_(next_unique_binding_index++) {\n                std::swap(previous_binding_, manager_->current_bindings_[name]);\n            }\n            template <class... Args>\n            Binding(BindingsManager<T>* manager, const Identifier* name, Args&&... args)\n                : Binding(manager, name->value, std::forward<Args>(args)...) {\n                declaration_position_ = name->pos;\n            }\n            ~Binding() {\n                if (!used_ && !SkipLintCheck()) {\n                Lint(BindingTypeString(), \"'\", name_,\n                    \"' is never used. Prefix with '_' if this is intentional.\")\n                    .Position(declaration_position_);\n                }\n\n                if (CheckWritten() && !written_ && !SkipLintCheck()) {\n                Lint(BindingTypeString(), \"'\", name_,\n                    \"' is never assigned to. Use 'const' instead of 'let'.\")\n                    .Position(declaration_position_);\n                }\n\n                manager_->current_bindings_[name_] = previous_binding_;\n            }\n            Binding(const Binding&) = delete;\n            Binding& operator=(const Binding&) = delete;\n\n            std::string BindingTypeString() const;\n            bool CheckWritten() const;\n\n            const std::string& name() const { return name_; }\n            SourcePosition declaration_position() const { return declaration_position_; }\n\n            bool Used() const { return used_; }\n            void SetUsed() { used_ = true; }\n\n            bool Written() const { return written_; }\n            void SetWritten() { written_ = true; }\n\n            uint64_t unique_index() const { return unique_index_; }\n\n            private:\n            bool SkipLintCheck() const { return name_.length() > 0 && name_[0] == '_'; }\n\n            BindingsManager<T>* manager_;\n            const std::string name_;\n            std::optional<Binding*> previous_binding_;\n            SourcePosition declaration_position_ = CurrentSourcePosition::Get();\n            bool used_;\n            bool written_;\n            uint64_t unique_index_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BindingsManager\",\n                \"about\": \"Manages a collection of Bindings of type T. Provides lookup functionality and tracks current bindings within a scope.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"current_bindings_\",\n                        \"type\": \"std::unordered_map<std::string, std::optional<Binding<T>*>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Maps names to their current binding within the scope.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Binding\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            class BindingsManager {\n            public:\n            std::optional<Binding<T>*> TryLookup(const std::string& name) {\n                if (StartsWithSingleUnderscore(name)) {\n                Error(\"Trying to reference '\", name, \"' which is marked as unused.\")\n                    .Throw();\n                }\n                auto binding = current_bindings_[name];\n                if (binding) {\n                (*binding)->SetUsed();\n                }\n                return binding;\n            }\n\n            private:\n            friend class Binding<T>;\n            std::unordered_map<std::string, std::optional<Binding<T>*>> current_bindings_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BlockBindings\",\n                \"about\": \"Manages a set of bindings within a specific block.  Ensures no redeclarations occur within the same block.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"manager_\",\n                        \"type\": \"BindingsManager<T>*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The BindingsManager that manages the bindings.\"\n                    },\n                    {\n                        \"name\": \"bindings_\",\n                        \"type\": \"std::vector<std::unique_ptr<Binding<T>>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Vector of unique pointers to the Bindings within this block.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"BindingsManager\",\n                    \"Binding\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <class T>\n            class BlockBindings {\n            public:\n            explicit BlockBindings(BindingsManager<T>* manager) : manager_(manager) {}\n            Binding<T>* Add(std::string name, T value, bool mark_as_used = false) {\n                ReportErrorIfAlreadyBound(name);\n                auto binding =\n                    std::make_unique<Binding<T>>(manager_, name, std::move(value));\n                Binding<T>* result = binding.get();\n                if (mark_as_used) binding->SetUsed();\n                bindings_.push_back(std::move(binding));\n                return result;\n            }\n\n            Binding<T>* Add(const Identifier* name, T value, bool mark_as_used = false) {\n                ReportErrorIfAlreadyBound(name->value);\n                auto binding =\n                    std::make_unique<Binding<T>>(manager_, name, std::move(value));\n                Binding<T>* result = binding.get();\n                if (mark_as_used) binding->SetUsed();\n                bindings_.push_back(std::move(binding));\n                return result;\n            }\n\n            std::vector<Binding<T>*> bindings() const {\n                std::vector<Binding<T>*> result;\n                result.reserve(bindings_.size());\n                for (auto& b : bindings_) {\n                result.push_back(b.get());\n                }\n                return result;\n            }\n\n            private:\n            void ReportErrorIfAlreadyBound(const std::string& name) {\n                for (const auto& binding : bindings_) {\n                if (binding->name() == name) {\n                    ReportError(\n                        \"redeclaration of name \\\"\", name,\n                        \"\\\" in the same block is illegal, previous declaration at: \",\n                        binding->declaration_position());\n                }\n                }\n            }\n\n            BindingsManager<T>* manager_;\n            std::vector<std::unique_ptr<Binding<T>>> bindings_;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"LocalValue\",\n                \"about\": \"Represents a local variable's value within a Torque function. It can hold a LocationReference, an error explanation, or a lazy initializer.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"std::optional<LocationReference>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The LocationReference of the local value, if accessible.\"\n                    },\n                    {\n                        \"name\": \"lazy\",\n                        \"type\": \"std::optional<std::function<LocationReference()>>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A lazy initializer function that returns a LocationReference.\"\n                    },\n                    {\n                        \"name\": \"inaccessible_explanation\",\n                        \"type\": \"std::string\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Explanation of why the value is inaccessible.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"LocationReference\",\n                    \"Binding\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class LocalValue {\n            public:\n            explicit LocalValue(LocationReference reference)\n                : value(std::move(reference)) {}\n            explicit LocalValue(std::string inaccessible_explanation)\n                : inaccessible_explanation(std::move(inaccessible_explanation)) {}\n            explicit LocalValue(std::function<LocationReference()> lazy)\n                : lazy(std::move(lazy)) {}\n\n            LocationReference GetLocationReference(Binding<LocalValue>* binding) {\n                if (value) {\n                const LocationReference& ref = *value;\n                if (ref.IsVariableAccess()) {\n                    // Attach the binding to enable the never-assigned-to lint check.\n                    return LocationReference::VariableAccess(ref.GetVisitResult(), binding);\n                }\n                return ref;\n                } else if (lazy) {\n                return (*lazy)();\n                } else {\n                Error(\"Cannot access \", binding->name(), \": \", inaccessible_explanation)\n                    .Throw();\n                }\n            }\n\n            bool IsAccessibleNonLazy() const { return value.has_value(); }\n\n            private:\n            std::optional<LocationReference> value;\n            std::optional<std::function<LocationReference()>> lazy;\n            std::string inaccessible_explanation;\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"LocalLabel\",\n                \"about\": \"Represents a local label within a Torque function, used for implementing goto statements and control flow.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"block\",\n                        \"type\": \"Block*\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The CFG block associated with this label.\"\n                    },\n                    {\n                        \"name\": \"parameter_types\",\n                        \"type\": \"std::vector<const Type*>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Types of the parameters passed to the label.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Block\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct LocalLabel {\n            Block* block;\n            std::vector<const Type*> parameter_types;\n\n            explicit LocalLabel(Block* block,\n                                std::vector<const Type*> parameter_types = {})\n                : block(block), parameter_types(std::move(parameter_types)) {}\n            };\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BindingTypeString\",\n                \"parent\": \"Binding<LocalValue>\",\n                \"about\": \"Specialization of BindingTypeString for LocalValue\",\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"Returns \\\"Variable \\\"\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            inline std::string Binding<LocalValue>::BindingTypeString() const {\n            return \"Variable \";\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CheckWritten\",\n                \"parent\": \"Binding<LocalValue>\",\n                \"about\": \"Specialization of CheckWritten for LocalValue to handle const and struct types\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"Returns whether written check should be applied.\"\n                },\n                \"dependencies\": [\n                    \"LocationReference\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            inline bool Binding<LocalValue>::CheckWritten() const {\n            // Do the check only for non-const variables and non struct types.\n            auto binding = *manager_->current_bindings_[name_];\n            if (!binding->IsAccessibleNonLazy()) return false;\n            const LocationReference& ref = binding->GetLocationReference(binding);\n            if (!ref.IsVariableAccess()) return false;\n            return !ref.GetVisitResult().type()->StructSupertype();\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"BindingTypeString\",\n                \"parent\": \"Binding<LocalLabel>\",\n                \"about\": \"Specialization of BindingTypeString for LocalLabel\",\n                \"return\": {\n                    \"type\": \"std::string\",\n                    \"description\": \"Returns \\\"Label \\\"\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            inline std::string Binding<LocalLabel>::BindingTypeString() const {\n            return \"Label \";\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CheckWritten\",\n                \"parent\": \"Binding<LocalLabel>\",\n                \"about\": \"Specialization of CheckWritten for LocalLabel\",\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"Always returns false as labels are not assigned to.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            template <>\n            inline bool Binding<LocalLabel>::CheckWritten() const {\n            return false;\n            }\n        ]]></code>\n    </func>\n    <struct>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"struct\",\n                \"name\": \"Arguments\",\n                \"about\": \"Represents the arguments passed to a callable (macro, builtin, method).\",\n                \"attributes\": [\n                    {\n                        \"name\": \"parameters\",\n                        \"type\": \"VisitResultVector\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Vector of VisitResults representing the parameter values.\"\n                    },\n                    {\n                        \"name\": \"labels\",\n                        \"type\": \"std::vector<Binding<LocalLabel>*>\",\n                        \"access\": \"public\",\n                        \"purpose\": \"Vector of bindings to LocalLabels representing label arguments.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"VisitResult\",\n                    \"Binding\",\n                    \"LocalLabel\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            struct Arguments {\n            VisitResultVector parameters;\n            std::vector<Binding<LocalLabel>*> labels;\n            };\n        ]]></code>\n    </struct>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsCompatibleSignature\",\n                \"about\": \"Determines if a callable's signature is compatible with a given set of types and label count, indicating a potential overload.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"sig\",\n                        \"type\": \"const Signature&\",\n                        \"purpose\": \"The signature of the callable.\"\n                    },\n                    {\n                        \"name\": \"types\",\n                        \"type\": \"const TypeVector&\",\n                        \"purpose\": \"The types of the arguments being passed.\"\n                    },\n                    {\n                        \"name\": \"label_count\",\n                        \"type\": \"size_t\",\n                        \"purpose\": \"The number of label arguments being passed.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the signature is compatible, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Signature\",\n                    \"TypeVector\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            // Determine if a callable should be considered as an overload.\n            bool IsCompatibleSignature(const Signature& sig, const TypeVector& types,\n                                    size_t label_count);\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ImplementationVisitor\",\n                \"about\": \"The main class responsible for traversing the Torque AST and generating code. It handles various tasks such as builtin definition generation, type checking, and code generation for different language backends.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"assembler_\",\n                        \"type\": \"std::optional<CfgAssembler>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Optional CfgAssembler instance used for code generation.\"\n                    },\n                    {\n                        \"name\": \"null_stream_\",\n                        \"type\": \"NullOStream\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A stream that discards all output.\"\n                    },\n                    {\n                        \"name\": \"is_dry_run_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Flag indicating whether the visitor is running in dry-run mode (no actual file writing).\"\n                    },\n                    {\n                        \"name\": \"bitfield_expressions_\",\n                        \"type\": \"std::unordered_map<const Expression*, const Identifier*>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Map to track bitfield expressions for warnings.\"\n                    },\n                    {\n                        \"name\": \"inlining_macros_\",\n                        \"type\": \"std::unordered_set<"
}