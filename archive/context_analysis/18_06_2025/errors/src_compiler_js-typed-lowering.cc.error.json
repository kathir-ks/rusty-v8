{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-typed-lowering.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/js-typed-lowering.cc\",\n        \"file_name\": \"js-typed-lowering.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Performs type-based lowering of JavaScript operators in the Turbofan compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary header files for compiler, AST, builtins, code generation, common utilities, and objects.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/js-typed-lowering.h\"\n\n#include <optional>\n\n#include \"src/ast/modules.h\"\n#include \"src/builtins/builtins-inl.h\"\n#include \"src/builtins/builtins-utils.h\"\n#include \"src/codegen/code-factory.h\"\n#include \"src/codegen/interface-descriptors-inl.h\"\n#include \"src/common/globals.h\"\n#include \"src/compiler/access-builder.h\"\n#include \"src/compiler/allocation-builder-inl.h\"\n#include \"src/compiler/allocation-builder.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/compilation-dependencies.h\"\n#include \"src/compiler/graph-assembler.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/linkage.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/compiler/turbofan-types.h\"\n#include \"src/compiler/type-cache.h\"\n#include \"src/deoptimizer/deoptimize-reason.h\"\n#include \"src/execution/protectors.h\"\n#include \"src/flags/flags.h\"\n#include \"src/objects/casting.h\"\n#include \"src/objects/heap-number.h\"\n#include \"src/objects/js-generator.h\"\n#include \"src/objects/module-inl.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/objects/objects.h\"\n#include \"src/objects/property-cell.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JSBinopReduction\",\n            \"about\": \"Helper class for reducing binary operations (binops) with JSOperators.\",\n            \"attributes\": [\n                {\n                    \"name\": \"lowering_\",\n                    \"type\": \"JSTypedLowering*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the containing JSTypedLowering instance.\"\n                },\n                {\n                    \"name\": \"node_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The original binop node being reduced.\"\n                }\n            ],\n            \"dependencies\": [\n                \"JSTypedLowering\",\n                \"Node\",\n                \"Type\",\n                \"CompareOperationHint\",\n                \"NumberOperationHint\",\n                \"BigIntOperationHint\",\n                \"HeapObjectBinopMatcher\",\n                \"JSHeapBroker\",\n                \"StringRef\",\n                \"ConsString\",\n                \"FeedbackSource\",\n                \"SimplifiedOperatorBuilder\",\n                \"TFGraph\",\n                \"JSGraph\",\n                \"Isolate\",\n                \"JSOperatorBuilder\",\n                \"CommonOperatorBuilder\",\n                \"Zone\",\n                \"FeedbackParameter\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass JSBinopReduction final {\n public:\n  JSBinopReduction(JSTypedLowering* lowering, Node* node)\n      : lowering_(lowering), node_(node) {}\n\n  bool GetCompareNumberOperationHint(NumberOperationHint* hint) {\n    DCHECK_EQ(1, node_->op()->EffectOutputCount());\n    switch (GetCompareOperationHint(node_)) {\n      case CompareOperationHint::kSignedSmall:\n        *hint = NumberOperationHint::kSignedSmall;\n        return true;\n      case CompareOperationHint::kNumber:\n        *hint = NumberOperationHint::kNumber;\n        return true;\n      case CompareOperationHint::kNumberOrBoolean:\n        *hint = NumberOperationHint::kNumberOrBoolean;\n        return true;\n      case CompareOperationHint::kNumberOrOddball:\n        *hint = NumberOperationHint::kNumberOrOddball;\n        return true;\n      case CompareOperationHint::kAny:\n      case CompareOperationHint::kNone:\n      case CompareOperationHint::kString:\n      case CompareOperationHint::kSymbol:\n      case CompareOperationHint::kBigInt:\n      case CompareOperationHint::kBigInt64:\n      case CompareOperationHint::kReceiver:\n      case CompareOperationHint::kReceiverOrNullOrUndefined:\n      case CompareOperationHint::kInternalizedString:\n        break;\n    }\n    return false;\n  }\n\n  bool GetCompareBigIntOperationHint(BigIntOperationHint* hint) {\n    DCHECK_EQ(1, node_->op()->EffectOutputCount());\n    switch (GetCompareOperationHint(node_)) {\n      case CompareOperationHint::kSignedSmall:\n      case CompareOperationHint::kNumber:\n      case CompareOperationHint::kNumberOrBoolean:\n      case CompareOperationHint::kNumberOrOddball:\n      case CompareOperationHint::kAny:\n      case CompareOperationHint::kNone:\n      case CompareOperationHint::kString:\n      case CompareOperationHint::kSymbol:\n      case CompareOperationHint::kReceiver:\n      case CompareOperationHint::kReceiverOrNullOrUndefined:\n      case CompareOperationHint::kInternalizedString:\n        return false;\n      case CompareOperationHint::kBigInt:\n        *hint = BigIntOperationHint::kBigInt;\n        return true;\n      case CompareOperationHint::kBigInt64:\n        *hint = BigIntOperationHint::kBigInt64;\n        return true;\n    }\n    UNREACHABLE();\n  }\n\n  bool IsInternalizedStringCompareOperation() {\n    DCHECK_EQ(1, node_->op()->EffectOutputCount());\n    return (GetCompareOperationHint(node_) ==\n            CompareOperationHint::kInternalizedString) &&\n           BothInputsMaybe(Type::InternalizedString());\n  }\n\n  bool IsReceiverCompareOperation() {\n    DCHECK_EQ(1, node_->op()->EffectOutputCount());\n    return (GetCompareOperationHint(node_) ==\n            CompareOperationHint::kReceiver) &&\n           BothInputsMaybe(Type::Receiver());\n  }\n\n  bool IsReceiverOrNullOrUndefinedCompareOperation() {\n    DCHECK_EQ(1, node_->op()->EffectOutputCount());\n    return (GetCompareOperationHint(node_) ==\n            CompareOperationHint::kReceiverOrNullOrUndefined) &&\n           BothInputsMaybe(Type::ReceiverOrNullOrUndefined());\n  }\n\n  bool IsStringCompareOperation() {\n    DCHECK_EQ(1, node_->op()->EffectOutputCount());\n    return (GetCompareOperationHint(node_) == CompareOperationHint::kString) &&\n           BothInputsMaybe(Type::String());\n  }\n\n  bool IsSymbolCompareOperation() {\n    DCHECK_EQ(1, node_->op()->EffectOutputCount());\n    return (GetCompareOperationHint(node_) == CompareOperationHint::kSymbol) &&\n           BothInputsMaybe(Type::Symbol());\n  }\n\n  // Check if a string addition will definitely result in creating a ConsString,\n  // i.e. if the combined length of the resulting string exceeds the ConsString\n  // minimum length.\n  bool ShouldCreateConsString() {\n    DCHECK_EQ(IrOpcode::kJSAdd, node_->opcode());\n    DCHECK(OneInputIs(Type::String()));\n    if (node_->InputAt(1)->opcode() == IrOpcode::kNewConsString) {\n      // If the right hand side is a ConsString, then we can create a\n      // ConsString. This doesn't work with the left hand side, since the right\n      // hand side of a ConsString cannot be the empty string except when the\n      // left hand side is a SeqString or External string, but we don't know\n      // that here.\n      return true;\n    }\n    if (BothInputsAre(Type::String()) ||\n        GetBinaryOperationHint(node_) == BinaryOperationHint::kString) {\n      HeapObjectBinopMatcher m(node_);\n      JSHeapBroker* broker = lowering_->broker();\n      if (m.right().HasResolvedValue() && m.right().Ref(broker).IsString()) {\n        StringRef right_string = m.right().Ref(broker).AsString();\n        if (right_string.length() >= ConsString::kMinLength) return true;\n      }\n      if (m.left().HasResolvedValue() && m.left().Ref(broker).IsString()) {\n        StringRef left_string = m.left().Ref(broker).AsString();\n        if (left_string.length() >= ConsString::kMinLength) {\n          // The invariant for ConsString requires the left hand side to be\n          // a sequential or external string if the right hand side is the\n          // empty string. Since we don't know anything about the right hand\n          // side here, we must ensure that the left hand side satisfy the\n          // constraints independent of the right hand side.\n          return left_string.IsSeqString() || left_string.IsExternalString();\n        }\n      }\n    }\n    return false;\n  }\n\n  // Inserts a CheckReceiver for the left input.\n  void CheckLeftInputToReceiver() {\n    Node* left_input = graph()->NewNode(simplified()->CheckReceiver(), left(),\n                                        effect(), control());\n    node_->ReplaceInput(0, left_input);\n    update_effect(left_input);\n  }\n\n  // Inserts a CheckReceiverOrNullOrUndefined for the left input.\n  void CheckLeftInputToReceiverOrNullOrUndefined() {\n    Node* left_input =\n        graph()->NewNode(simplified()->CheckReceiverOrNullOrUndefined(), left(),\n                         effect(), control());\n    node_->ReplaceInput(0, left_input);\n    update_effect(left_input);\n  }\n\n  // Checks that both inputs are Receiver, and if we don't know\n  // statically that one side is already a Receiver, insert a\n  // CheckReceiver node.\n  void CheckInputsToReceiver() {\n    if (!left_type().Is(Type::Receiver())) {\n      CheckLeftInputToReceiver();\n    }\n    if (!right_type().Is(Type::Receiver())) {\n      Node* right_input = graph()->NewNode(simplified()->CheckReceiver(),\n                                           right(), effect(), control());\n      node_->ReplaceInput(1, right_input);\n      update_effect(right_input);\n    }\n  }\n\n  // Checks that both inputs are Receiver, Null or Undefined and if\n  // we don't know statically that one side is already a Receiver,\n  // Null or Undefined, insert CheckReceiverOrNullOrUndefined nodes.\n  void CheckInputsToReceiverOrNullOrUndefined() {\n    if (!left_type().Is(Type::ReceiverOrNullOrUndefined())) {\n      CheckLeftInputToReceiverOrNullOrUndefined();\n    }\n    if (!right_type().Is(Type::ReceiverOrNullOrUndefined())) {\n      Node* right_input =\n          graph()->NewNode(simplified()->CheckReceiverOrNullOrUndefined(),\n                           right(), effect(), control());\n      node_->ReplaceInput(1, right_input);\n      update_effect(right_input);\n    }\n  }\n\n  // Inserts a CheckSymbol for the left input.\n  void CheckLeftInputToSymbol() {\n    Node* left_input = graph()->NewNode(simplified()->CheckSymbol(), left(),\n                                        effect(), control());\n    node_->ReplaceInput(0, left_input);\n    update_effect(left_input);\n  }\n\n  // Checks that both inputs are Symbol, and if we don't know\n  // statically that one side is already a Symbol, insert a\n  // CheckSymbol node.\n  void CheckInputsToSymbol() {\n    if (!left_type().Is(Type::Symbol())) {\n      CheckLeftInputToSymbol();\n    }\n    if (!right_type().Is(Type::Symbol())) {\n      Node* right_input = graph()->NewNode(simplified()->CheckSymbol(), right(),\n                                           effect(), control());\n      node_->ReplaceInput(1, right_input);\n      update_effect(right_input);\n    }\n  }\n\n  // Checks that both inputs are String, and if we don't know\n  // statically that one side is already a String, insert a\n  // CheckString node.\n  void CheckInputsToString() {\n    if (!left_type().Is(Type::String())) {\n      Node* left_input =\n          graph()->NewNode(simplified()->CheckString(FeedbackSource()), left(),\n                           effect(), control());\n      node_->ReplaceInput(0, left_input);\n      update_effect(left_input);\n    }\n    if (!right_type().Is(Type::String())) {\n      Node* right_input =\n          graph()->NewNode(simplified()->CheckString(FeedbackSource()), right(),\n                           effect(), control());\n      node_->ReplaceInput(1, right_input);\n      update_effect(right_input);\n    }\n  }\n\n  // Checks that both inputs are String or string wrapper, and if we don't know\n  // statically that one side is already a String or a string wrapper, insert a\n  // CheckStringOrStringWrapper node.\n  void CheckInputsToStringOrStringWrapper() {\n    if (!left_type().Is(Type::StringOrStringWrapper())) {\n      Node* left_input = graph()->NewNode(\n          simplified()->CheckStringOrStringWrapper(FeedbackSource()), left(),\n          effect(), control());\n      node_->ReplaceInput(0, left_input);\n      update_effect(left_input);\n    }\n    if (!right_type().Is(Type::StringOrStringWrapper())) {\n      Node* right_input = graph()->NewNode(\n          simplified()->CheckStringOrStringWrapper(FeedbackSource()), right(),\n          effect(), control());\n      node_->ReplaceInput(1, right_input);\n      update_effect(right_input);\n    }\n  }\n\n  // Checks that both inputs are InternalizedString, and if we don't know\n  // statically that one side is already an InternalizedString, insert a\n  // CheckInternalizedString node.\n  void CheckInputsToInternalizedString() {\n    if (!left_type().Is(Type::UniqueName())) {\n      Node* left_input = graph()->NewNode(\n          simplified()->CheckInternalizedString(), left(), effect(), control());\n      node_->ReplaceInput(0, left_input);\n      update_effect(left_input);\n    }\n    if (!right_type().Is(Type::UniqueName())) {\n      Node* right_input =\n          graph()->NewNode(simplified()->CheckInternalizedString(), right(),\n                           effect(), control());\n      node_->ReplaceInput(1, right_input);\n      update_effect(right_input);\n    }\n  }\n\n  void ConvertInputsToNumber() {\n    DCHECK(left_type().Is(Type::PlainPrimitive()));\n    DCHECK(right_type().Is(Type::PlainPrimitive()));\n    node_->ReplaceInput(0, ConvertPlainPrimitiveToNumber(left()));\n    node_->ReplaceInput(1, ConvertPlainPrimitiveToNumber(right()));\n  }\n\n  void ConvertInputsToUI32(Signedness left_signedness,\n                           Signedness right_signedness) {\n    node_->ReplaceInput(0, ConvertToUI32(left(), left_signedness));\n    node_->ReplaceInput(1, ConvertToUI32(right(), right_signedness));\n  }\n\n  void SwapInputs() {\n    Node* l = left();\n    Node* r = right();\n    node_->ReplaceInput(0, r);\n    node_->ReplaceInput(1, l);\n  }\n\n  // Remove all effect and control inputs and outputs to this node and change\n  // to the pure operator {op}.\n  Reduction ChangeToPureOperator(const Operator* op, Type type = Type::Any()) {\n    DCHECK_EQ(0, op->EffectInputCount());\n    DCHECK_EQ(false, OperatorProperties::HasContextInput(op));\n    DCHECK_EQ(0, op->ControlInputCount());\n    DCHECK_EQ(2, op->ValueInputCount());\n\n    // Remove the effects from the node, and update its effect/control usages.\n    if (node_->op()->EffectInputCount() > 0) {\n      lowering_->RelaxEffectsAndControls(node_);\n    }\n    // Remove the inputs corresponding to context, effect, and control.\n    NodeProperties::RemoveNonValueInputs(node_);\n    // Remove the feedback vector input, if applicable.\n    if (JSOperator::IsBinaryWithFeedback(node_->opcode())) {\n      node_->RemoveInput(JSBinaryOpNode::FeedbackVectorIndex());\n    }\n    // Finally, update the operator to the new one.\n    NodeProperties::ChangeOp(node_, op);\n\n    // TODO(jarin): Replace the explicit typing hack with a call to some method\n    // that encapsulates changing the operator and re-typing.\n    Type node_type = NodeProperties::GetType(node_);\n    NodeProperties::SetType(node_, Type::Intersect(node_type, type, zone()));\n\n    return lowering_->Changed(node_);\n  }\n\n  Reduction ChangeToSpeculativeOperator(const Operator* op, Type upper_bound) {\n    DCHECK_EQ(1, op->EffectInputCount());\n    DCHECK_EQ(1, op->EffectOutputCount());\n    DCHECK_EQ(false, OperatorProperties::HasContextInput(op));\n    DCHECK_EQ(1, op->ControlInputCount());\n    DCHECK_EQ(0, op->ControlOutputCount());\n    DCHECK_EQ(0, OperatorProperties::GetFrameStateInputCount(op));\n    DCHECK_EQ(2, op->ValueInputCount());\n\n    DCHECK_EQ(1, node_->op()->EffectInputCount());\n    DCHECK_EQ(1, node_->op()->EffectOutputCount());\n    DCHECK_EQ(1, node_->op()->ControlInputCount());\n\n    // Reconnect the control output to bypass the IfSuccess node and\n    // possibly disconnect from the IfException node.\n    lowering_->RelaxControls(node_);\n\n    // Remove the frame state and the context.\n    if (OperatorProperties::HasFrameStateInput(node_->op())) {\n      node_->RemoveInput(NodeProperties::FirstFrameStateIndex(node_));\n    }\n    node_->RemoveInput(NodeProperties::FirstContextIndex(node_));\n\n    // Remove the feedback vector input, if applicable.\n    if (JSOperator::IsBinaryWithFeedback(node_->opcode())) {\n      node_->RemoveInput(JSBinaryOpNode::FeedbackVectorIndex());\n    }\n    // Finally, update the operator to the new one.\n    NodeProperties::ChangeOp(node_, op);\n\n    // Update the type to number.\n    Type node_type = NodeProperties::GetType(node_);\n    NodeProperties::SetType(node_,\n                            Type::Intersect(node_type, upper_bound, zone()));\n\n    return lowering_->Changed(node_);\n  }\n\n  const Operator* NumberOp() {\n    switch (node_->opcode()) {\n      case IrOpcode::kJSAdd:\n        return simplified()->NumberAdd();\n      case IrOpcode::kJSSubtract:\n        return simplified()->NumberSubtract();\n      case IrOpcode::kJSMultiply:\n        return simplified()->NumberMultiply();\n      case IrOpcode::kJSDivide:\n        return simplified()->NumberDivide();\n      case IrOpcode::kJSModulus:\n        return simplified()->NumberModulus();\n      case IrOpcode::kJSExponentiate:\n        return simplified()->NumberPow();\n      case IrOpcode::kJSBitwiseAnd:\n        return simplified()->NumberBitwiseAnd();\n      case IrOpcode::kJSBitwiseOr:\n        return simplified()->NumberBitwiseOr();\n      case IrOpcode::kJSBitwiseXor:\n        return simplified()->NumberBitwiseXor();\n      case IrOpcode::kJSShiftLeft:\n        return simplified()->NumberShiftLeft();\n      case IrOpcode::kJSShiftRight:\n        return simplified()->NumberShiftRight();\n      case IrOpcode::kJSShiftRightLogical:\n        return simplified()->NumberShiftRightLogical();\n      default:\n        break;\n    }\n    UNREACHABLE();\n  }\n\n  bool LeftInputIs(Type t) { return left_type().Is(t); }\n\n  bool RightInputIs(Type t) { return right_type().Is(t); }\n\n  bool OneInputIs(Type t) { return LeftInputIs(t) || RightInputIs(t); }\n\n  bool BothInputsAre(Type t) { return LeftInputIs(t) && RightInputIs(t); }\n\n  bool BothInputsMaybe(Type t) {\n    return left_type().Maybe(t) && right_type().Maybe(t);\n  }\n\n  bool OneInputCannotBe(Type t) {\n    return !left_type().Maybe(t) || !right_type().Maybe(t);\n  }\n\n  bool NeitherInputCanBe(Type t) {\n    return !left_type().Maybe(t) && !right_type().Maybe(t);\n  }\n\n  BinaryOperationHint GetBinaryOperationHint(Node* node) const {\n    const FeedbackParameter& p = FeedbackParameterOf(node->op());\n    return lowering_->broker()->GetFeedbackForBinaryOperation(p.feedback());\n  }\n\n  Node* effect() { return NodeProperties::GetEffectInput(node_); }\n  Node* control() { return NodeProperties::GetControlInput(node_); }\n  Node* context() { return NodeProperties::GetContextInput(node_); }\n  Node* left() { return NodeProperties::GetValueInput(node_, 0); }\n  Node* right() { return NodeProperties::GetValueInput(node_, 1); }\n  Type left_type() { return NodeProperties::GetType(node_->InputAt(0)); }\n  Type right_type() { return NodeProperties::GetType(node_->InputAt(1)); }\n  Type type() { return NodeProperties::GetType(node_); }\n\n  SimplifiedOperatorBuilder* simplified() { return lowering_->simplified(); }\n  TFGraph* graph() const { return lowering_->graph(); }\n  JSGraph* jsgraph() { return lowering_->jsgraph(); }\n  Isolate* isolate() { return jsgraph()->isolate(); }\n  JSOperatorBuilder* javascript() { return lowering_->javascript(); }\n  CommonOperatorBuilder* common() { return jsgraph()->common(); }\n  Zone* zone() const { return graph()->zone(); }\n\n private:\n  JSTypedLowering* lowering_;  // The containing lowering instance.\n  Node* node_;                 // The original node.\n\n  Node* ConvertPlainPrimitiveToNumber(Node* node) {\n    DCHECK(NodeProperties::GetType(node).Is(Type::PlainPrimitive()));\n    // Avoid inserting too many eager ToNumber() operations.\n    Reduction const reduction = lowering_->ReduceJSToNumberInput(node);\n    if (reduction.Changed()) return reduction.replacement();\n    if (NodeProperties::GetType(node).Is(Type::Number())) {\n      return node;\n    }\n    return graph()->NewNode(simplified()->PlainPrimitiveToNumber(), node);\n  }\n\n  Node* ConvertToUI32(Node* node, Signedness signedness) {\n    // Avoid introducing too many eager NumberToXXnt32() operations.\n    Type type = NodeProperties::GetType(node);\n    if (signedness == kSigned) {\n      if (!type.Is(Type::Signed32())) {\n        node = graph()->NewNode(simplified()->NumberToInt32(), node);\n      }\n    } else {\n      DCHECK_EQ(kUnsigned, signedness);\n      if (!type.Is(Type::Unsigned32())) {\n        node = graph()->NewNode(simplified()->NumberToUint32(), node);\n      }\n    }\n    return node;\n  }\n\n  CompareOperationHint GetCompareOperationHint(Node* node) const {\n    const FeedbackParameter& p = FeedbackParameterOf(node->op());\n    return lowering_->broker()->GetFeedbackForCompareOperation(p.feedback());\n  }\n\n  void update_effect(Node* effect) {\n    NodeProperties::ReplaceEffectInput(node_, effect);\n  }\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JSTypedLowering\",\n            \"about\": \"The main class responsible for type-based lowering of JavaScript operators.\",\n            \"attributes\": [\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the JSGraph, providing access to the graph structure and JavaScript-specific helpers.\"\n                },\n                {\n                    \"name\": \"broker_\",\n                    \"type\": \"JSHeapBroker*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the JSHeapBroker, facilitating access to the JavaScript heap and object properties.\"\n                },\n                {\n                    \"name\": \"empty_string_type_\",\n                    \"type\": \"Type\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Represents the type of an empty string, used for specific optimizations.\"\n                },\n                {\n                    \"name\": \"pointer_comparable_type_\",\n                    \"type\": \"Type\",\n                    \"access\": \"private\",\n                    \"purpose\": \"A union type including boolean, null, undefined, Hole, Symbol, Receiver, and empty string.  Used for reference equality checks.\"\n                },\n                {\n                    \"name\": \"type_cache_\",\n                    \"type\": \"TypeCache&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Reference to the TypeCache, providing pre-computed types for efficient type comparisons.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Editor\",\n                \"JSGraph\",\n                \"JSHeapBroker\",\n                \"Zone\",\n                \"AdvancedReducer\",\n                \"Type\",\n                \"TypeCache\",\n                \"Node\",\n                \"FeedbackParameter\",\n                \"JSOperatorBuilder\",\n                \"SimplifiedOperatorBuilder\",\n                \"CommonOperatorBuilder\",\n                \"IrOpcode\",\n                \"HeapObjectMatcher\",\n                \"StringRef\",\n                \"Optional\",\n                \"Runtime\",\n                \"Builtins\",\n                \"CallDescriptor\",\n                \"Linkage\",\n                \"Operator\",\n                \"JSAddNode\",\n                \"StringAddFlags\",\n                \"MakeRef\",\n                \"PropertyCellRef\",\n                \"ConstructForwardVarargsParameters\",\n                \"CallForwardVarargsParameters\",\n                \"JSConstructNode\",\n                \"JSCallNode\",\n                \"CallParameters\",\n                \"JSCreateClosureNode\",\n                \"CreateClosureParameters\",\n                \"FeedbackCellRef\",\n                \"ConvertReceiverMode\",\n                \"SharedFunctionInfoRef\",\n                \"OptionalJSFunctionRef\",\n                \"NativeContextRef\",\n                \"JSForInNextNode\",\n                \"FrameState\",\n                \"Control\",\n                \"Effect\",\n                \"ForInMode\",\n                \"JSHasInPrototypeChain\"\n\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass JSTypedLowering final : public AdvancedReducer {\n public:\n  JSTypedLowering(Editor* editor, JSGraph* jsgraph,\n                                 JSHeapBroker* broker, Zone* zone)\n    : AdvancedReducer(editor),\n      jsgraph_(jsgraph),\n      broker_(broker),\n      empty_string_type_(\n          Type::Constant(broker, broker->empty_string(), graph()->zone())),\n      pointer_comparable_type_(\n          Type::Union(Type::Union(Type::BooleanOrNullOrUndefined(),\n                                  Type::Hole(), graph()->zone()),\n                      Type::Union(Type::SymbolOrReceiver(), empty_string_type_,\n                                  graph()->zone()),\n                      graph()->zone())),\n      type_cache_(TypeCache::Get()) {}\n\n  Reduction ReduceJSBitwiseNot(Node* node);\n  Reduction ReduceJSDecrement(Node* node);\n  Reduction ReduceJSIncrement(Node* node);\n  Reduction ReduceJSNegate(Node* node);\n  Reduction GenerateStringAddition(\n      Node* node, Node* left, Node* right, Node* context, Node* frame_state,\n      Node** effect, Node** control, bool should_create_cons_string);\n  Node* UnwrapStringWrapper(Node* string_or_wrapper,\n                            Node** effect, Node** control);\n  Reduction ReduceJSAdd(Node* node);\n  Reduction ReduceNumberBinop(Node* node);\n  Reduction ReduceInt32Binop(Node* node);\n  Reduction ReduceUI32Shift(Node* node, Signedness signedness);\n  Reduction ReduceJSComparison(Node* node);\n  Reduction ReduceJSEqual(Node* node);\n  Reduction ReduceJSStrictEqual(Node* node);\n  Reduction ReduceJSToName(Node* node);\n  Reduction ReduceJSToLength(Node* node);\n  Reduction ReduceJSToNumberInput(Node* input);\n  Reduction ReduceJSToNumber(Node* node);\n  Reduction ReduceJSToBigInt(Node* node);\n  Reduction ReduceJSToBigIntConvertNumber(Node* node);\n  Reduction ReduceJSToNumeric(Node* node);\n  Reduction ReduceJSToStringInput(Node* input);\n  Reduction ReduceJSToString(Node* node);\n  Reduction ReduceJSToObject(Node* node);\n  Reduction ReduceJSLoadNamed(Node* node);\n  Reduction ReduceJSHasInPrototypeChain(Node* node);\n  Reduction ReduceJSOrdinaryHasInstance(Node* node);\n  Reduction ReduceJSHasContextExtension(Node* node);\n  Reduction ReduceJSLoadContext(Node* node);\n  Reduction ReduceJSLoadScriptContext(Node* node);\n  Reduction ReduceJSStoreContext(Node* node);\n  Reduction ReduceJSStoreScriptContext(Node* node);\n  Node* BuildGetModuleCell(Node* node);\n  Reduction ReduceJSLoadModule(Node* node);\n  Reduction ReduceJSStoreModule(Node* node);\n  Reduction ReduceJSConstructForwardVarargs(Node* node);\n  Reduction ReduceJSConstruct(Node* node);\n  Reduction ReduceJSCallForwardVarargs(Node* node);\n  Reduction ReduceJSCall(Node* node);\n  Reduction ReduceJSForInNext(Node* node);\n\n  JSGraph* jsgraph() const { return jsgraph_; }\n  JSHeapBroker* broker() const { return broker_; }\n  SimplifiedOperatorBuilder* simplified() { return jsgraph_->simplified(); }\n  JSOperatorBuilder* javascript() { return jsgraph_->javascript(); }\n  TFGraph* graph() const { return jsgraph_->graph(); }\n  Isolate* isolate() { return jsgraph_->isolate(); }\n  CommonOperatorBuilder* common() { return jsgraph()->common(); }\n  TypeCache* type_cache() { return &type_cache_; }\n\n private:\n  JSGraph* const jsgraph_;\n  JSHeapBroker* const broker_;\n  Type const empty_string_type_;\n  Type const pointer_comparable_type_;\n  TypeCache& type_cache_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceJSBitwiseNot\",\n            \"parent\": \"JSTypedLowering\",\n            \"about\": \"Reduces a JSBitwiseNot node to a NumberBitwiseXor node if the input is a PlainPrimitive.\",\n            \"logic\": \"If the input type is PlainPrimitive, replace JSBitwiseNot with NumberBitwiseXor(ToInt32(x), -1).\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The JSBitwiseNot node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether the node was changed.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Type\",\n                \"NodeProperties\",\n                \"FeedbackParameter\",\n                \"javascript\",\n                \"JSBinopReduction\",\n                \"kSigned\",\n                \"Type::Signed32\",\n                \"SmiConstant\",\n                \"IrOpcode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nReduction JSTypedLowering::ReduceJSBitwiseNot(Node* node) {\n  Node* input = NodeProperties::GetValueInput(node, 0);\n  Type input_type = NodeProperties::GetType(input);\n  if (input_type.Is(Type::PlainPrimitive())) {\n    // JSBitwiseNot(x) => NumberBitwiseXor(ToInt32(x), -1)\n    const FeedbackParameter& p = FeedbackParameterOf(node->op());\n    node->InsertInput(graph()->zone(), 1, jsgraph()->SmiConstant(-1));\n    NodeProperties::ChangeOp(node, javascript()->BitwiseXor(p.feedback()));\n    JSBinopReduction r(this, node);\n    r.ConvertInputsToNumber();\n    r.ConvertInputsToUI32(kSigned, kSigned);\n    return r.ChangeToPureOperator(r.NumberOp(), Type::Signed32());\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReduceJSDecrement\",\n            \"parent\": \"JSTypedLowering\",\n            \"about\": \"Reduces a JSDecrement node to a NumberSubtract node if the input is a PlainPrimitive.\",\n            \"logic\": \"If the input type is PlainPrimitive, replace JSDecrement with NumberSubtract(ToNumber(x), 1).\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The JSDecrement node to be reduced.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Reduction\",\n                \"description\": \"A Reduction object indicating whether the node was changed.\"\n            },\n            \"dependencies\": [\n"
}