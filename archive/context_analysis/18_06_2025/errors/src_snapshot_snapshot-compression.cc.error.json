{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/snapshot-compression.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 168, column 55",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/snapshot-compression.cc\",\n        \"file_name\": \"snapshot-compression.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides compression and decompression functionalities for snapshot data using zlib.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for compression, data structures, and utilities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/snapshot/snapshot-compression.h\"\n\n            #include \"src/base/platform/elapsed-timer.h\"\n            #include \"src/utils/memcopy.h\"\n            #include \"src/utils/utils.h\"\n            #include \"third_party/zlib/google/compression_utils_portable.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetUncompressedSize\",\n            \"about\": \"Retrieves the uncompressed size of data from the beginning of the compressed data.\",\n            \"logic\": \"Copies the first 4 bytes (size of uint32_t) from the compressed data buffer to a size variable and returns it.\",\n            \"parameters\": [\n                {\n                    \"name\": \"compressed_data\",\n                    \"type\": \"const Bytef*\",\n                    \"purpose\": \"Pointer to the compressed data.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"uint32_t\",\n                \"description\": \"The uncompressed size.\"\n            },\n            \"dependencies\": [\n                \"MemCopy\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            uint32_t GetUncompressedSize(const Bytef* compressed_data) {\n              uint32_t size;\n              MemCopy(&size, compressed_data, sizeof(size));\n              return size;\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SnapshotCompression\",\n            \"about\": \"Provides static methods for compressing and decompressing snapshot data.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class SnapshotCompression {\n            public:\n                static SnapshotData Compress(const SnapshotData* uncompressed_data);\n                static SnapshotData Decompress(base::Vector<const uint8_t> compressed_data);\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Compress\",\n            \"parent\": \"SnapshotCompression\",\n            \"about\": \"Compresses the given snapshot data using zlib's raw compression.\",\n            \"logic\": \"1. Retrieves the size of the uncompressed data.\\n2. Allocates memory for the compressed data, including space for the uncompressed size.\\n3. Copies the uncompressed size to the beginning of the allocated buffer.\\n4. Compresses the data using zlib_internal::CompressHelper with ZRAW and Z_DEFAULT_COMPRESSION.\\n5. Resizes the allocated buffer to the actual size of the compressed data.\\n6. Returns the compressed SnapshotData.\",\n            \"parameters\": [\n                {\n                    \"name\": \"uncompressed_data\",\n                    \"type\": \"const SnapshotData*\",\n                    \"purpose\": \"Pointer to the uncompressed snapshot data.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"SnapshotData\",\n                \"description\": \"The compressed snapshot data.\"\n            },\n            \"dependencies\": [\n                \"SnapshotData\",\n                \"base::ElapsedTimer\",\n                \"v8_flags\",\n                \"compressBound\",\n                \"MemCopy\",\n                \"zlib_internal::CompressHelper\",\n                \"GetUncompressedSize\",\n                \"PrintF\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            SnapshotData SnapshotCompression::Compress(\n                const SnapshotData* uncompressed_data) {\n              SnapshotData snapshot_data;\n              base::ElapsedTimer timer;\n              if (v8_flags.profile_deserialization) timer.Start();\n\n              static_assert(sizeof(Bytef) == 1, \"\");\n              const uLongf input_size =\n                  static_cast<uLongf>(uncompressed_data->RawData().size());\n              uint32_t payload_length =\n                  static_cast<uint32_t>(uncompressed_data->RawData().size());\n\n              uLongf compressed_data_size = compressBound(input_size);\n\n              // Allocating >= the final amount we will need.\n              snapshot_data.AllocateData(\n                  static_cast<uint32_t>(sizeof(payload_length) + compressed_data_size));\n\n              uint8_t* compressed_data =\n                  const_cast<uint8_t*>(snapshot_data.RawData().begin());\n              // Since we are doing raw compression (no zlib or gzip headers), we need to\n              // manually store the uncompressed size.\n              MemCopy(compressed_data, &payload_length, sizeof(payload_length));\n\n              CHECK_EQ(\n                  zlib_internal::CompressHelper(\n                      zlib_internal::ZRAW, compressed_data + sizeof(payload_length),\n                      &compressed_data_size,\n                      reinterpret_cast<const Bytef*>(uncompressed_data->RawData().begin()),\n                      input_size, Z_DEFAULT_COMPRESSION, nullptr, nullptr),\n                  Z_OK);\n\n              // Reallocating to exactly the size we need.\n              snapshot_data.Resize(static_cast<uint32_t>(compressed_data_size) +\n                                   sizeof(payload_length));\n              DCHECK_EQ(payload_length,\n                        GetUncompressedSize(snapshot_data.RawData().begin()));\n\n              if (v8_flags.profile_deserialization) {\n                double ms = timer.Elapsed().InMillisecondsF();\n                PrintF(\"[Compressing %d bytes took %0.3f ms]\\n\", payload_length, ms);\n              }\n              return snapshot_data;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Decompress\",\n            \"parent\": \"SnapshotCompression\",\n            \"about\": \"Decompresses the given snapshot data using zlib's raw decompression.\",\n            \"logic\": \"1. Retrieves the uncompressed size from the beginning of the compressed data.\\n2. Allocates memory for the uncompressed data.\\n3. Decompresses the data using zlib_internal::UncompressHelper with ZRAW.\\n4. Returns the decompressed SnapshotData.\",\n            \"parameters\": [\n                {\n                    \"name\": \"compressed_data\",\n                    \"type\": \"base::Vector<const uint8_t>\",\n                    \"purpose\": \"The compressed snapshot data.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"SnapshotData\",\n                \"description\": \"The decompressed snapshot data.\"\n            },\n            \"dependencies\": [\n                \"SnapshotData\",\n                \"base::ElapsedTimer\",\n                \"v8_flags\",\n                \"GetUncompressedSize\",\n                \"zlib_internal::UncompressHelper\",\n                \"PrintF\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            SnapshotData SnapshotCompression::Decompress(\n                base::Vector<const uint8_t> compressed_data) {\n              SnapshotData snapshot_data;\n              base::ElapsedTimer timer;\n              if (v8_flags.profile_deserialization) timer.Start();\n\n              const Bytef* input_bytef =\n                  reinterpret_cast<const Bytef*>(compressed_data.begin());\n\n              // Since we are doing raw compression (no zlib or gzip headers), we need to\n              // manually retrieve the uncompressed size.\n              uint32_t uncompressed_payload_length = GetUncompressedSize(input_bytef);\n              input_bytef += sizeof(uncompressed_payload_length);\n\n              snapshot_data.AllocateData(uncompressed_payload_length);\n\n              uLongf uncompressed_size = uncompressed_payload_length;\n              CHECK_EQ(zlib_internal::UncompressHelper(\n                           zlib_internal::ZRAW,\n                           const_cast<Bytef*>(snapshot_data.RawData().begin()),\n                           &uncompressed_size, input_bytef,\n                           static_cast<uLong>(compressed_data.size() -\n                                              sizeof(uncompressed_payload_length))),\n                       Z_OK);\n\n              if (v8_flags.profile_deserialization) {\n                double ms = timer.Elapsed().InMillisecondsF();\n                PrintF(\"[Decompressing %d bytes took %0.3f ms]\\n\",\n                       uncompressed_payload_length, ms);\n              }\n              return snapshot_data;\n            }\n        ]]></code>\n    </func>\n</file>\n```"
}