{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-compiler.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/wasm-compiler.cc\",\n        \"file_name\": \"wasm-compiler.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Wasm compiler pipeline within the Turbofan compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for compiler, code generation, Wasm, and related functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/wasm-compiler.h\"\n\n            #include <memory>\n            #include <optional>\n\n            #include \"src/base/small-vector.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/codegen/assembler.h\"\n            #include \"src/codegen/compiler.h\"\n            #include \"src/codegen/interface-descriptors-inl.h\"\n            #include \"src/codegen/machine-type.h\"\n            #include \"src/codegen/optimized-compilation-info.h\"\n            #include \"src/compiler/access-builder.h\"\n            #include \"src/compiler/backend/code-generator.h\"\n            #include \"src/compiler/backend/instruction-selector.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/compiler-source-position-table.h\"\n            #include \"src/compiler/diamond.h\"\n            #include \"src/compiler/fast-api-calls.h\"\n            #include \"src/compiler/graph-assembler.h\"\n            #include \"src/compiler/int64-lowering.h\"\n            #include \"src/compiler/linkage.h\"\n            #include \"src/compiler/machine-operator.h\"\n            #include \"src/compiler/node-matchers.h\"\n            #include \"src/compiler/node-origin-table.h\"\n            #include \"src/compiler/node-properties.h\"\n            #include \"src/compiler/pipeline.h\"\n            #include \"src/compiler/turbofan-graph-visualizer.h\"\n            #include \"src/compiler/turbofan-graph.h\"\n            #include \"src/compiler/turboshaft/wasm-turboshaft-compiler.h\"\n            #include \"src/compiler/wasm-call-descriptors.h\"\n            #include \"src/compiler/wasm-compiler-definitions.h\"\n            #include \"src/compiler/wasm-graph-assembler.h\"\n            #include \"src/compiler/wasm-inlining-into-js.h\"\n            #include \"src/compiler/write-barrier-kind.h\"\n            #include \"src/execution/simulator-base.h\"\n            #include \"src/heap/factory.h\"\n            #include \"src/logging/counters.h\"\n            #include \"src/objects/code-kind.h\"\n            #include \"src/objects/heap-number.h\"\n            #include \"src/objects/instance-type.h\"\n            #include \"src/objects/name.h\"\n            #include \"src/objects/string.h\"\n            #include \"src/roots/roots.h\"\n            #include \"src/tracing/trace-event.h\"\n            #include \"src/trap-handler/trap-handler.h\"\n            #include \"src/wasm/code-space-access.h\"\n            #include \"src/wasm/compilation-environment-inl.h\"\n            #include \"src/wasm/function-compiler.h\"\n            #include \"src/wasm/jump-table-assembler.h\"\n            #include \"src/wasm/memory-tracing.h\"\n            #include \"src/wasm/object-access.h\"\n            #include \"src/wasm/wasm-code-manager.h\"\n            #include \"src/wasm/wasm-constants.h\"\n            #include \"src/wasm/wasm-engine.h\"\n            #include \"src/wasm/wasm-limits.h\"\n            #include \"src/wasm/wasm-linkage.h\"\n            #include \"src/wasm/wasm-module.h\"\n            #include \"src/wasm/wasm-objects-inl.h\"\n            #include \"src/wasm/wasm-opcodes-inl.h\"\n            #include \"src/wasm/wasm-subtyping.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ContainsSimd\",\n            \"about\": \"Checks if a given signature contains SIMD types (S128).\",\n            \"logic\": \"Iterates through all types in the signature and returns true if any of them is wasm::kWasmS128.\",\n            \"parameters\": [\n                {\n                    \"name\": \"sig\",\n                    \"type\": \"const Signature<T>*\",\n                    \"purpose\": \"The signature to check for SIMD types.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the signature contains SIMD types, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            bool ContainsSimd(const Signature<T>* sig) {\n            for (auto type : sig->all()) {\n                if (type == wasm::kWasmS128) return true;\n            }\n            return false;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"ContainsInt64\",\n            \"about\": \"Checks if a given canonical signature contains Int64 types (I64).\",\n            \"logic\": \"Iterates through all types in the signature and returns true if any of them is wasm::kWasmI64.\",\n            \"parameters\": [\n                {\n                    \"name\": \"sig\",\n                    \"type\": \"const wasm::CanonicalSig*\",\n                    \"purpose\": \"The signature to check for Int64 types.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the signature contains Int64 types, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            bool ContainsInt64(const wasm::CanonicalSig* sig) {\n            for (auto type : sig->all()) {\n                if (type == wasm::kWasmI64) return true;\n            }\n            return false;\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmGraphBuilder\",\n            \"about\": \"Builds a Turbofan graph for WebAssembly code.\",\n            \"attributes\": [\n                {\n                    \"name\": \"gasm_\",\n                    \"type\": \"std::unique_ptr<WasmGraphAssembler>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The graph assembler for building the Turbofan graph.\"\n                },\n                {\n                    \"name\": \"zone_\",\n                    \"type\": \"Zone*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The memory zone for allocating graph nodes.\"\n                },\n                {\n                    \"name\": \"mcgraph_\",\n                    \"type\": \"MachineGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The machine graph.\"\n                },\n                {\n                    \"name\": \"env_\",\n                    \"type\": \"wasm::CompilationEnv*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The WebAssembly compilation environment.\"\n                },\n                {\n                    \"name\": \"enabled_features_\",\n                    \"type\": \"wasm::WasmEnabledFeatures\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The set of enabled WebAssembly features.\"\n                },\n                {\n                    \"name\": \"has_simd_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the signature contains SIMD types.\"\n                },\n                {\n                    \"name\": \"function_sig_\",\n                    \"type\": \"const wasm::FunctionSig*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The function signature.\"\n                },\n                                {\n                    \"name\": \"wrapper_sig_\",\n                    \"type\": \"const wasm::CanonicalSig*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The wrapper signature.\"\n                },\n                {\n                    \"name\": \"source_position_table_\",\n                    \"type\": \"compiler::SourcePositionTable*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The source position table for debugging.\"\n                },\n                {\n                    \"name\": \"parameter_mode_\",\n                    \"type\": \"ParameterMode\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The mode for handling parameters (instance, imports, etc.).\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"null_check_strategy_\",\n                    \"type\": \"NullCheckStrategy\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The strategy for handling null checks.\"\n                },\n                {\n                    \"name\": \"parameters_\",\n                    \"type\": \"Node**\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Array of parameter nodes.\"\n                },\n                {\n                    \"name\": \"instance_data_node_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The node representing the instance data.\"\n                },\n                {\n                    \"name\": \"needs_stack_check_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag to indicate if a stack check is needed.\"\n                },\n                                {\n                    \"name\": \"inlining_id_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Identifier for inlining.\"\n                }\n            ],\n            \"dependencies\": [\n                \"WasmGraphAssembler\",\n                \"wasm::CompilationEnv\",\n                \"wasm::FunctionSig\",\n                \"compiler::SourcePositionTable\",\n                \"Isolate\",\n                \"wasm::WasmEnabledFeatures\",\n                \"wasm::CanonicalSig\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class WasmGraphBuilder {\n            public:\n            WasmGraphBuilder(\n                wasm::CompilationEnv* env, Zone* zone, MachineGraph* mcgraph,\n                const wasm::FunctionSig* sig,\n                compiler::SourcePositionTable* source_position_table,\n                ParameterMode parameter_mode, Isolate* isolate,\n                wasm::WasmEnabledFeatures enabled_features,\n                const wasm::CanonicalSig* wrapper_sig);\n\n            // Destructor define here where the definition of {WasmGraphAssembler} is\n            // available.\n            ~WasmGraphBuilder();\n\n            bool TryWasmInlining(int fct_index,\n                                wasm::NativeModule* native_module,\n                                int inlining_id);\n\n            void Start(unsigned params);\n            Node* Param(int index, const char* debug_name = nullptr);\n            void TerminateThrow(Node* effect, Node* control);\n            Node* NoContextConstant();\n            Node* BuildLoadIsolateRoot();\n            Node* Int32Constant(int32_t value);\n            Node* UndefinedValue();\n            TrapId GetTrapIdForTrap(wasm::TrapReason reason);\n            Node* Return(base::Vector<Node*> vals);\n            Node* IsNull(Node* object, wasm::ValueType type);\n            Node* effect();\n            Node* control();\n            Node* SetEffect(Node* node);\n            Node* SetControl(Node* node);\n            void SetEffectControl(Node* effect, Node* control);\n            Node* BuildCallNode(size_t param_count,\n                                base::Vector<Node*> args,\n                                wasm::WasmCodePosition position,\n                                Node* implicit_first_arg,\n                                const Operator* op, Node* frame_state);\n            template <typename T>\n            Node* BuildWasmCall(const Signature<T>* sig,\n                                base::Vector<Node*> args,\n                                base::Vector<Node*> rets,\n                                wasm::WasmCodePosition position,\n                                Node* implicit_first_arg, bool indirect,\n                                Node* frame_state);\n            Node* BuildCallToRuntimeWithContext(Runtime::FunctionId f,\n                                                Node* js_context,\n                                                Node** parameters,\n                                                int parameter_count);\n            Node* BuildCallToRuntime(Runtime::FunctionId f,\n                                    Node** parameters,\n                                    int parameter_count);\n            const Operator* GetSafeLoadOperator(\n                int offset, wasm::ValueTypeBase type);\n            Node* BuildSafeStore(int offset, wasm::ValueTypeBase type,\n                                Node* arg_buffer, Node* value,\n                                Node* effect, Node* control);\n            TFGraph* graph();\n            Zone* graph_zone();\n            void LowerInt64(Signature<MachineRepresentation>* sig);\n            void LowerInt64(wasm::CallOrigin origin);\n            Node* BuildChangeInt64ToBigInt(Node* input,\n                                            StubCallMode stub_mode);\n            void SetSourcePosition(Node* node,\n                                    wasm::WasmCodePosition position);\n            Node* TypeGuard(Node* value, wasm::ValueType type);\n            void BuildModifyThreadInWasmFlagHelper(\n                Node* thread_in_wasm_flag_address, bool new_value);\n            void BuildModifyThreadInWasmFlag(bool new_value);\n            void Assert(Node* condition, AbortReason abort_reason);\n            Node* SetType(Node* node, wasm::ValueType type);\n\n            private:\n            std::unique_ptr<WasmGraphAssembler> gasm_;\n            Zone* zone_;\n            MachineGraph* mcgraph_;\n            wasm::CompilationEnv* env_;\n            wasm::WasmEnabledFeatures enabled_features_;\n            bool has_simd_;\n            const wasm::FunctionSig* function_sig_;\n            const wasm::CanonicalSig* wrapper_sig_;\n            compiler::SourcePositionTable* source_position_table_;\n            ParameterMode parameter_mode_;\n            Isolate* isolate_;\n            NullCheckStrategy null_check_strategy_;\n            Node** parameters_ = nullptr;  // Allocated in Start().\n            Node* instance_data_node_ = nullptr;\n            bool needs_stack_check_ = false;\n            int inlining_id_ = 0; // TODO(leszeks): Propagate this id from the caller.\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CreateMachineSignature\",\n            \"about\": \"Creates a machine signature from a given signature.\",\n            \"logic\": \"Creates a MachineRepresentation signature by iterating through the input signature and adding corresponding machine representations.  If the origin is JS, then Tagged representation is used, otherwise the specific machine representation of the WebAssembly type is used.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone for allocating the signature.\"\n                },\n                {\n                    \"name\": \"sig\",\n                    \"type\": \"const Signature<T>*\",\n                    \"purpose\": \"The original signature to convert.\"\n                },\n                {\n                    \"name\": \"origin\",\n                    \"type\": \"wasm::CallOrigin\",\n                    \"purpose\": \"The origin of the call (e.g., from JS or Wasm).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Signature<MachineRepresentation>*\",\n                \"description\": \"The created machine signature.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            Signature<MachineRepresentation>* CreateMachineSignature(\n                Zone* zone, const Signature<T>* sig, wasm::CallOrigin origin) {\n            Signature<MachineRepresentation>::Builder builder(zone, sig->return_count(),\n                                                            sig->parameter_count());\n            for (auto ret : sig->returns()) {\n                if (origin == wasm::kCalledFromJS) {\n                builder.AddReturn(MachineRepresentation::kTagged);\n                } else {\n                builder.AddReturn(ret.machine_representation());\n                }\n            }\n\n            for (auto param : sig->parameters()) {\n                if (origin == wasm::kCalledFromJS) {\n                // Parameters coming from JavaScript are always tagged values. Especially\n                // when the signature says that it's an I64 value, then a BigInt object is\n                // provided by JavaScript, and not two 32-bit parameters.\n                builder.AddParam(MachineRepresentation::kTagged);\n                } else {\n                builder.AddParam(param.machine_representation());\n                }\n            }\n            return builder.Get();\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmWrapperGraphBuilder\",\n            \"extends\": \"WasmGraphBuilder\",\n            \"about\": \"Specialized WasmGraphBuilder for building wrapper functions.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"WasmGraphBuilder\",\n                \"wasm::CanonicalSig\",\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace {\n\n            // A non-null {isolate} signifies that the generated code is treated as being in\n            // a JS frame for functions like BuildLoadIsolateRoot().\n            class WasmWrapperGraphBuilder : public WasmGraphBuilder {\n            public:\n            WasmWrapperGraphBuilder(Zone* zone, MachineGraph* mcgraph,\n                                    const wasm::CanonicalSig* sig,\n                                    ParameterMode parameter_mode, Isolate* isolate,\n                                    compiler::SourcePositionTable* spt)\n                : WasmGraphBuilder(nullptr, zone, mcgraph, nullptr, spt, parameter_mode,\n                                Isolate, wasm::WasmEnabledFeatures::All(), sig) {}\n\n            class ModifyThreadInWasmFlagScope {\n            public:\n                ModifyThreadInWasmFlagScope(\n                    WasmWrapperGraphBuilder* wasm_wrapper_graph_builder,\n                    WasmGraphAssembler* gasm)\n                    : wasm_wrapper_graph_builder_(wasm_wrapper_graph_builder) {\n                if (!trap_handler::IsTrapHandlerEnabled()) return;\n                Node* isolate_root = wasm_wrapper_graph_builder_->BuildLoadIsolateRoot();\n\n                thread_in_wasm_flag_address_ =\n                    gasm->Load(MachineType::Pointer(), isolate_root,\n                                Isolate::thread_in_wasm_flag_address_offset());\n\n                wasm_wrapper_graph_builder_->BuildModifyThreadInWasmFlagHelper(\n                    thread_in_wasm_flag_address_, true);\n                }\n\n                ModifyThreadInWasmFlagScope(const ModifyThreadInWasmFlagScope&) = delete;\n\n                ~ModifyThreadInWasmFlagScope() {\n                if (!trap_handler::IsTrapHandlerEnabled()) return;\n\n                wasm_wrapper_graph_builder_->BuildModifyThreadInWasmFlagHelper(\n                    thread_in_wasm_flag_address_, false);\n                }\n\n            private:\n                WasmWrapperGraphBuilder* wasm_wrapper_graph_builder_;\n                Node* thread_in_wasm_flag_address_;\n            };\n\n            Node* BuildCallAndReturn(Node* js_context, Node* function_data,\n                                    base::SmallVector<Node*, 16> args, Node* frame_state,\n                                    bool set_in_wasm_flag);\n\n            void BuildJSToWasmWrapper(Node* frame_state = nullptr,\n                                    bool set_in_wasm_flag = true);\n\n            Node* BuildReceiverNode(Node* callable_node, Node* native_context,\n                                    Node* undefined_node);\n\n            void BuildJSFastApiCallWrapper(DirectHandle<JSReceiver> callable);\n\n            void BuildCWasmEntry();\n\n            private:\n            SetOncePointer<const Operator> int32_to_heapnumber_operator_;\n            SetOncePointer<const Operator> tagged_non_smi_to_int32_operator_;\n            SetOncePointer<const Operator> float32_to_number_operator_;\n            SetOncePointer<const Operator> float64_to_number_operator_;\n            SetOncePointer<const Operator> tagged_to_float64_operator_;\n            };\n\n            }  // namespace\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"BuildInlinedJSToWasmWrapper\",\n            \"about\": \"Builds an inlined JS to WebAssembly wrapper function.\",\n            \"logic\": \"Creates a `WasmWrapperGraphBuilder` and calls `BuildJSToWasmWrapper` to construct the graph for the inlined wrapper.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone.\"\n                },\n                {\n                    \"name\": \"mcgraph\",\n                    \"type\": \"MachineGraph*\",\n                    \"purpose\": \"The machine graph.\"\n                },\n                {\n                    \"name\": \"signature\",\n                    \"type\": \"const wasm::CanonicalSig*\",\n                    \"purpose\": \"The signature of the WebAssembly function.\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"spt\",\n                    \"type\": \"compiler::SourcePositionTable*\",\n                    \"purpose\": \"Source position table.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The frame state.\"\n                },\n                {\n                    \"name\": \"set_in_wasm_flag\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Flag to set the thread in wasm flag.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"WasmWrapperGraphBuilder\",\n                \"WasmGraphBuilder::kJSFunctionAbiMode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void BuildInlinedJSToWasmWrapper(Zone* zone, MachineGraph* mcgraph,\n                                            const wasm::CanonicalSig* signature,\n                                            Isolate* isolate,\n                                            compiler::SourcePositionTable* spt,\n                                            Node* frame_state, bool set_in_wasm_flag) {\n            WasmWrapperGraphBuilder builder(zone, mcgraph, signature,\n                                            WasmGraphBuilder::kJSFunctionAbiMode, isolate,\n                                            spt);\n            builder.BuildJSToWasmWrapper(frame_state, set_in_wasm_flag);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"NewJSToWasmCompilationJob\",\n            \"about\": \"Creates a new compilation job for JS to Wasm wrappers.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"sig\",\n                    \"type\": \"const wasm::CanonicalSig*\",\n                    \"purpose\": \"The signature.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<OptimizedCompilationJob>\",\n                \"description\": \"The created compilation job.\"\n            },\n            \"dependencies\": [\n                \"Pipeline\",\n                \"wasm::WrapperCompilationInfo\",\n                \"WasmExportedFunction::GetDebugName\",\n                \"WasmAssemblerOptions\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            std::unique_ptr<OptimizedCompilationJob> NewJSToWasmCompilationJob(\n                Isolate* isolate, const wasm::CanonicalSig* sig) {\n            return Pipeline::NewWasmTurboshaftWrapperCompilationJob(\n                isolate, sig, wasm::WrapperCompilationInfo{CodeKind::JS_TO_WASM_FUNCTION},\n                WasmExportedFunction::GetDebugName(sig), WasmAssemblerOptions());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CompileWasmImportCallWrapper\",\n            \"about\": \"Compiles a wrapper for calls from WebAssembly to JavaScript imports.\",\n            \"parameters\": [\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"wasm::ImportCallKind\",\n                    \"purpose\": \"The kind of import call.\"\n                },\n                {\n                    \"name\": \"sig\",\n                    \"type\": \"const wasm::CanonicalSig*\",\n                    \"purpose\": \"The signature of the import.\"\n                },\n                {\n                    \"name\": \"source_positions\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether to include source positions.\"\n                },\n                {\n                    \"name\": \"expected_arity\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The expected arity of the function.\"\n                },\n                                {\n                    \"name\": \"suspend\",\n                    \"type\": \"wasm::Suspend\",\n                    \"purpose\": \"Whether the execution can suspend.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"wasm::WasmCompilationResult\",\n                \"description\": \"The result of the compilation.\"\n            },\n            \"dependencies\": [\n                \"Pipeline::GenerateCodeForWasmNativeStubFromTurboshaft\",\n                \"wasm::WrapperCompilationInfo\",\n                \"PrintSignature\",\n                \"WasmStubAssemblerOptions\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            wasm::WasmCompilationResult CompileWasmImportCallWrapper(\n                wasm::ImportCallKind kind, const wasm::CanonicalSig* sig,\n                bool source_positions, int expected_arity, wasm::Suspend suspend) {\n            DCHECK_NE(wasm::ImportCallKind::kLinkError, kind);\n            DCHECK_NE(wasm::ImportCallKind::kWasmToWasm, kind);\n            DCHECK_NE(wasm::ImportCallKind::kWasmToJSFastApi, kind);\n\n            TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.wasm.detailed\"),\n                        \"wasm.CompileWasmImportCallWrapper\");\n            base::TimeTicks start_time;\n            if (V8_UNLIKELY(v8_flags.trace_wasm_compilation_times)) {\n                start_time = base::TimeTicks::Now();\n            }\n\n            // Build a name in the form \"wasm-to-js-<kind>-<signature>\".\n            constexpr size_t kMaxNameLen = 128;\n            char func_name[kMaxNameLen];\n            int name_prefix_len = SNPrintF(base::VectorOf(func_name, kMaxNameLen),\n                                            \"wasm-to-js-%d-\", static_cast<int>(kind));\n            PrintSignature(base::VectorOf(func_name, kMaxNameLen) + name_prefix_len, sig,\n                            '-');\n\n            auto result = Pipeline::GenerateCodeForWasmNativeStubFromTurboshaft(\n                sig,\n                wasm::WrapperCompilationInfo{CodeKind::WASM_TO_JS_FUNCTION, kind,\n                                            expected_arity, suspend},\n                func_name, WasmStubAssemblerOptions(), nullptr);\n\n            if (V8_UNLIKELY(v8_flags.trace_wasm_compilation_times)) {\n                base::TimeDelta time = base::TimeTicks::Now() - start_time;\n                int codesize = result.code_desc.body_size();\n                StdoutStream{} << \"Compiled WasmToJS wrapper \" << func_name << \", took \"\n                            << time.InMilliseconds() << \" ms; codesize \" << codesize\n                            << std::endl;\n            }\n\n            return result;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CompileWasmCapiCallWrapper\",\n            \"about\": \"Compiles a wrapper for calls from WebAssembly to C API functions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"sig\",\n                    \"type\": \"const wasm::CanonicalSig*\",\n                    \"purpose\": \"The signature of the C API function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"wasm::WasmCompilationResult\",\n                \"description\": \"The result of the compilation.\"\n            },\n            \"dependencies\": [\n                \"Pipeline::GenerateCodeForWasmNativeStubFromTurboshaft\",\n                \"wasm::WrapperCompilationInfo\",\n                \"WasmStubAssemblerOptions\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            wasm::WasmCompilationResult CompileWasmCapiCallWrapper(\n                const wasm::CanonicalSig* sig) {\n            TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.wasm.detailed\"),\n                        \"wasm.CompileWasmCapiFunction\");\n\n            return Pipeline::GenerateCodeForWasmNativeStubFromTurboshaft(\n                sig, wasm::WrapperCompilationInfo{CodeKind::WASM_TO_CAPI_FUNCTION},\n                \"WasmCapiCall\", WasmStubAssemblerOptions(), nullptr);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CompileWasmJSFastCallWrapper\",\n            \"about\": \"Compiles a wrapper for fast calls from WebAssembly to JavaScript functions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"sig\",\n                    \"type\": \"const wasm::CanonicalSig*\",\n                    \"purpose\": \"The signature of the JavaScript function.\"\n                },\n                {\n                    \"name\": \"callable\",\n                    \"type\": \"DirectHandle<JSReceiver>\",\n                    \"purpose\": \"A direct handle to the callable JSReceiver.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"wasm::WasmCompilationResult\",\n                \"description\": \"The result of the compilation.\"\n            },\n            \"dependencies\": [\n                \"WasmWrapperGraphBuilder\",\n                \"WasmGraphBuilder::kWasmImportDataMode\",\n                \"Pipeline::GenerateCodeForWasmNativeStub\",\n                \"GetWasmCallDescriptor\",\n                \"GetI32WasmCallDescriptor\",\n                \"fast_api_call::BuildFastApiCall\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            wasm::WasmCompilationResult CompileWasmJSFastCallWrapper(\n                const wasm::CanonicalSig* sig, DirectHandle<JSReceiver> callable) {\n            TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.wasm.detailed\"),\n                        \"wasm.CompileWasmJSFastCallWrapper\");\n\n            Zone zone(wasm::GetWasmEngine()->allocator(), ZONE_NAME, kCompressGraphZone);\n            SourcePositionTable* source_positions = nullptr;\n            MachineGraph* mcgraph = CreateCommonMachineGraph(&zone);\n\n            WasmWrapperGraphBuilder builder(&zone, mcgraph, sig,\n                                            WasmGraphBuilder::kWasmImportDataMode,\n                                            nullptr, source_positions);\n\n            // Set up the graph start.\n            int param_count = static_cast<int>(sig->parameter_count()) +\n                                1 /* offset for first parameter index being -1 */ +\n                                1 /* Wasm instance */ + 1 /* kExtraCallableParam */;\n            builder.Start(param_count);\n            builder.BuildJSFastApiCallWrapper(callable);\n\n            // Run the compiler pipeline to generate machine code.\n            CallDescriptor* call_descriptor =\n                GetWasmCallDescriptor(&zone, sig, WasmCallKind::kWasmImportWrapper);\n            if (mcgraph->machine()->Is32()) {\n                call_descriptor = GetI32WasmCallDescriptor(&zone, call_descriptor);\n            }\n\n            const char* debug_name = \"WasmJSFastApiCall\";\n            wasm::WasmCompilationResult result = Pipeline::GenerateCodeForWasmNativeStub(\n                call_descriptor, mcgraph, CodeKind::WASM_TO_JS_FUNCTION, debug_name,\n                WasmStubAssemblerOptions(), source_positions);\n            return result;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CompileCWasmEntry\",\n            \"about\": \"Compiles the C WebAssembly entry point.\",\n            \"logic\": \"Creates a WasmWrapperGraphBuilder, calls BuildCWasmEntry to construct the graph, and then compiles it.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"sig\",\n                    \"type\": \"const wasm::CanonicalSig*\",\n                    \"purpose\": \"The signature.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Handle<Code>\",\n                \"description\": \"A handle to the compiled code.\"\n            },\n            \"dependencies\": [\n                \"WasmWrapperGraphBuilder\",\n                \"WasmGraphBuilder::kNoSpecialParameterMode\",\n                \"Pipeline::NewWasmHeapStubCompilationJob\",\n                \"Linkage::GetSimplifiedCDescriptor\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Handle<Code> CompileCWasmEntry(Isolate* isolate,\n                                            const wasm::CanonicalSig* sig) {\n            DCHECK(!v8_flags.wasm_jitless);\n\n            std::unique_ptr<Zone> zone = std::make_unique<Zone>(\n                isolate->allocator(), ZONE_NAME, kCompressGraphZone);\n            TFGraph* graph"
}