{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turbofan-graph-visualizer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turbofan-graph-visualizer.cc\",\n        \"file_name\": \"turbofan-graph-visualizer.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides utilities for visualizing the Turbofan graph, including JSON and C1Visualizer formats.  Includes functionality to print source code with positions, inlining information, and live ranges for register allocation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard libraries and V8-specific headers for compiler, codegen, objects, and utils.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turbofan-graph-visualizer.h\"\n\n#include <memory>\n#include <optional>\n#include <regex>\n#include <sstream>\n#include <string>\n\n#include \"src/base/vector.h\"\n#include \"src/codegen/optimized-compilation-info.h\"\n#include \"src/codegen/source-position.h\"\n#include \"src/compiler/all-nodes.h\"\n#include \"src/compiler/backend/register-allocation.h\"\n#include \"src/compiler/backend/register-allocator.h\"\n#include \"src/compiler/compiler-source-position-table.h\"\n#include \"src/compiler/node-origin-table.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/operator.h\"\n#include \"src/compiler/schedule.h\"\n#include \"src/compiler/turbofan-graph.h\"\n#include \"src/objects/script-inl.h\"\n#include \"src/objects/shared-function-info.h\"\n#include \"src/utils/ostreams.h\"\n\n#if V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-disassembler.h\"\n#endif\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"get_cached_trace_turbo_filename\",\n            \"parent\": null,\n            \"about\": \"Retrieves the cached trace turbo filename from OptimizedCompilationInfo, or generates it if it doesn't exist.\",\n            \"logic\": \"Checks if the filename is already cached in the OptimizedCompilationInfo. If not, it generates a new filename using `GetVisualizerLogFileName` and caches it.  This avoids redundant filename generation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"OptimizedCompilationInfo*\",\n                    \"purpose\": \"Pointer to OptimizedCompilationInfo containing compilation details\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"const char*\",\n                \"description\": \"The cached trace turbo filename.\"\n            },\n            \"dependencies\": [\n                \"OptimizedCompilationInfo\",\n                \"GetVisualizerLogFileName\",\n                \"v8_flags\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nconst char* get_cached_trace_turbo_filename(OptimizedCompilationInfo* info) {\n  if (!info->trace_turbo_filename()) {\n    info->set_trace_turbo_filename(GetVisualizerLogFileName(\n        info, v8_flags.trace_turbo_path, nullptr, \"json\"));\n  }\n  return info->trace_turbo_filename();\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TurboJsonFile\",\n            \"extends\": \"std::ofstream\",\n            \"about\": \"A wrapper around std::ofstream that automatically opens and closes a file for Turbofan JSON output.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"OptimizedCompilationInfo\",\n                \"get_cached_trace_turbo_filename\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTurboJsonFile::TurboJsonFile(OptimizedCompilationInfo* info,\n                             std::ios_base::openmode mode)\n    : std::ofstream(get_cached_trace_turbo_filename(info), mode) {}\n\nTurboJsonFile::~TurboJsonFile() { flush(); }\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"TurboCfgFile\",\n            \"extends\": \"std::ofstream\",\n            \"about\": \"A wrapper around std::ofstream that automatically opens and closes a file for Turbofan CFG output.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTurboCfgFile::TurboCfgFile(Isolate* isolate)\n    : std::ofstream(Isolate::GetTurboCfgFileName(isolate).c_str(),\n                    std::ios_base::app) {}\n\nTurboCfgFile::~TurboCfgFile() { flush(); }\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SourcePositionAsJSON\",\n            \"about\": \"Helper class to print a SourcePosition as JSON.\",\n            \"attributes\": [\n                {\n                    \"name\": \"sp\",\n                    \"type\": \"SourcePosition\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The SourcePosition object to print.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SourcePosition\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& out,\n                         const SourcePositionAsJSON& asJSON) {\n  asJSON.sp.PrintJson(out);\n  return out;\n}\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"NodeOriginAsJSON\",\n            \"about\": \"Helper class to print a NodeOrigin as JSON.\",\n            \"attributes\": [\n                {\n                    \"name\": \"no\",\n                    \"type\": \"NodeOrigin\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The NodeOrigin object to print.\"\n                }\n            ],\n            \"dependencies\": [\n                \"NodeOrigin\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::ostream& operator<<(std::ostream& out, const NodeOriginAsJSON& asJSON) {\n  asJSON.no.PrintJson(out);\n  return out;\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"JsonPrintBytecodeSource\",\n            \"parent\": null,\n            \"about\": \"Prints bytecode source information as JSON, including source ID, function name, bytecode, and feedback vector.\",\n            \"logic\": \"Constructs a JSON object containing the source ID, function name, bytecode (printed using BytecodeArray::PrintJson), and feedback vector (printed using FeedbackVector::Print).  The feedback vector is escaped to handle newlines correctly in JSON.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream to write the JSON to\"\n                },\n                {\n                    \"name\": \"source_id\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The ID of the source\"\n                },\n                {\n                    \"name\": \"function_name\",\n                    \"type\": \"std::unique_ptr<char[]>\",\n                    \"purpose\": \"The name of the function as a C-style string\"\n                },\n                {\n                    \"name\": \"bytecode_array\",\n                    \"type\": \"DirectHandle<BytecodeArray>\",\n                    \"purpose\": \"Handle to the bytecode array\"\n                },\n                {\n                    \"name\": \"feedback_vector\",\n                    \"type\": \"Tagged<FeedbackVector>\",\n                    \"purpose\": \"Tagged pointer to the feedback vector\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"BytecodeArray\",\n                \"FeedbackVector\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid JsonPrintBytecodeSource(std::ostream& os, int source_id,\n                             std::unique_ptr<char[]> function_name,\n                             DirectHandle<BytecodeArray> bytecode_array,\n                             Tagged<FeedbackVector> feedback_vector) {\n  os << \"\\\"\" << source_id << \"\\\" : {\";\n  os << \"\\\"sourceId\\\": \" << source_id;\n  os << \", \\\"functionName\\\": \\\"\" << function_name.get() << \"\\\"\";\n  os << \", \\\"bytecodeSource\\\": \";\n  bytecode_array->PrintJson(os);\n  os << \", \\\"feedbackVector\\\": \\\"\";\n  if (!feedback_vector.is_null()) {\n    std::stringstream stream;\n    FeedbackVector::Print(feedback_vector, stream);\n    std::regex newlines_re(\"\\n+\");\n    os << std::regex_replace(stream.str(), newlines_re, \"\\\\n\");\n  }\n  os << \"\\\"}\";\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"JsonPrintFunctionSource\",\n            \"parent\": null,\n            \"about\": \"Prints function source information as JSON, including source ID, function name, source code, and position.\",\n            \"logic\": \"Constructs a JSON object containing the source ID, function name, source name, source text, start position, and end position.  It retrieves the source code from the script object, if available, and escapes it for JSON.  If WASM is enabled and the function is a WASM export, disassembles the WASM function.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream to write the JSON to\"\n                },\n                {\n                    \"name\": \"source_id\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The ID of the source\"\n                },\n                {\n                    \"name\": \"function_name\",\n                    \"type\": \"std::unique_ptr<char[]>\",\n                    \"purpose\": \"The name of the function as a C-style string\"\n                },\n                {\n                    \"name\": \"script\",\n                    \"type\": \"DirectHandle<Script>\",\n                    \"purpose\": \"Handle to the script object\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate\"\n                },\n                {\n                    \"name\": \"shared\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"Handle to the shared function info\"\n                },\n                {\n                    \"name\": \"with_key\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Whether to print the source ID as a key in the JSON object\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Script\",\n                \"SharedFunctionInfo\",\n                \"IsString\",\n                \"Cast\",\n                \"String\",\n                \"JSONEscaped\",\n                \"IsUndefined\",\n                \"SubStringRange\",\n                \"AsEscapedUC16ForJSON\",\n                \"WasmExportedFunctionData\",\n                \"wasm::NativeModule\",\n                \"wasm::WasmModule\",\n                \"wasm::DisassembleFunction\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid JsonPrintFunctionSource(std::ostream& os, int source_id,\n                             std::unique_ptr<char[]> function_name,\n                             DirectHandle<Script> script, Isolate* isolate,\n                             DirectHandle<SharedFunctionInfo> shared,\n                             bool with_key) {\n  if (with_key) os << \"\\\"\" << source_id << \"\\\" : \";\n\n  os << \"{ \";\n  os << \"\\\"sourceId\\\": \" << source_id;\n  os << \", \\\"functionName\\\": \\\"\" << function_name.get() << \"\\\" \";\n\n  int start = 0;\n  int end = 0;\n  if (!script.is_null() && !IsUndefined(*script, isolate) &&\n      !shared.is_null()) {\n    Tagged<Object> source_name = script->name();\n    os << \", \\\"sourceName\\\": \\\"\";\n    if (IsString(source_name)) {\n      std::ostringstream escaped_name;\n      escaped_name << Cast<String>(source_name)->ToCString().get();\n      os << JSONEscaped(escaped_name);\n    }\n    os << \"\\\"\";\n    {\n      start = shared->StartPosition();\n      end = shared->EndPosition();\n      os << \", \\\"sourceText\\\": \\\"\";\n      if (!IsUndefined(script->source())) {\n        DisallowGarbageCollection no_gc;\n        int len = shared->EndPosition() - start;\n        SubStringRange source(Cast<String>(script->source()), no_gc, start,\n                              len);\n        for (auto c : source) {\n          os << AsEscapedUC16ForJSON(c);\n        }\n#if V8_ENABLE_WEBASSEMBLY\n      } else if (shared->HasWasmExportedFunctionData()) {\n        Tagged<WasmExportedFunctionData> function_data =\n            shared->wasm_exported_function_data();\n        wasm::NativeModule* native_module =\n            function_data->instance_data()->native_module();\n        const wasm::WasmModule* module = native_module->module();\n        std::ostringstream str;\n        wasm::DisassembleFunction(module, function_data->function_index(),\n                                  native_module->wire_bytes(),\n                                  native_module->GetNamesProvider(), str);\n        os << JSONEscaped(str);\n#endif  // V8_ENABLE_WEBASSEMBLY\n      }\n      os << \"\\\"\";\n    }\n  } else {\n    os << \", \\\"sourceName\\\": \\\"\\\"\";\n    os << \", \\\"sourceText\\\": \\\"\\\"\";\n  }\n  os << \", \\\"startPosition\\\": \" << start;\n  os << \", \\\"endPosition\\\": \" << end;\n  os << \"}\";\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SourceIdAssigner\",\n            \"about\": \"Assigns unique IDs to SharedFunctionInfo objects to avoid printing duplicate source information.\",\n            \"attributes\": [\n                {\n                    \"name\": \"printed_\",\n                    \"type\": \"std::vector<Handle<SharedFunctionInfo>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the SharedFunctionInfo objects that have already been printed.\"\n                },\n                {\n                    \"name\": \"source_ids_\",\n                    \"type\": \"std::vector<int>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the assigned source IDs for each SharedFunctionInfo.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nint SourceIdAssigner::GetIdFor(Handle<SharedFunctionInfo> shared) {\n  for (unsigned i = 0; i < printed_.size(); i++) {\n    if (printed_.at(i).is_identical_to(shared)) {\n      source_ids_.push_back(i);\n      return i;\n    }\n  }\n  const int source_id = static_cast<int>(printed_.size());\n  printed_.push_back(shared);\n  source_ids_.push_back(source_id);\n  return source_id;\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"JsonPrintInlinedFunctionInfo\",\n            \"parent\": null,\n            \"about\": \"Prints inlined function information as JSON, including inlining ID, source ID, and inlining position.\",\n            \"logic\": \"Constructs a JSON object containing the inlining ID, source ID, and inlining position (printed using `AsJSON` if known).\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream to write the JSON to\"\n                },\n                {\n                    \"name\": \"source_id\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The ID of the source\"\n                },\n                {\n                    \"name\": \"inlining_id\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The ID of the inlining\"\n                },\n                {\n                    \"name\": \"h\",\n                    \"type\": \"const OptimizedCompilationInfo::InlinedFunctionHolder&\",\n                    \"purpose\": \"The inlined function holder\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"OptimizedCompilationInfo\",\n                \"SourcePosition\",\n                \"AsJSON\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nvoid JsonPrintInlinedFunctionInfo(\n    std::ostream& os, int source_id, int inlining_id,\n    const OptimizedCompilationInfo::InlinedFunctionHolder& h) {\n  os << \"\\\"\" << inlining_id << \"\\\" : \";\n  os << \"{ \\\"inliningId\\\" : \" << inlining_id;\n  os << \", \\\"sourceId\\\" : \" << source_id;\n  const SourcePosition position = h.position.position;\n  if (position.IsKnown()) {\n    os << \", \\\"inliningPosition\\\" : \" << AsJSON(position);\n  }\n  os << \"}\";\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"JsonPrintAllBytecodeSources\",\n            \"parent\": null,\n            \"about\": \"Prints all bytecode sources associated with a compilation info as JSON.\",\n            \"logic\": \"Prints the main bytecode source and then iterates through all inlined functions, printing their bytecode sources as well, using SourceIdAssigner to assign unique IDs.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream to write the JSON to\"\n                },\n                {\n                    \"name\": \"info\",\n                    \"type\": \"OptimizedCompilationInfo*\",\n                    \"purpose\": \"The compilation info\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"OptimizedCompilationInfo\",\n                \"JsonPrintBytecodeSource\",\n                \"SourceIdAssigner\",\n                \"SharedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid JsonPrintAllBytecodeSources(std::ostream& os,\n                                 OptimizedCompilationInfo* info) {\n  os << \"\\\"bytecodeSources\\\" : {\";\n\n  JsonPrintBytecodeSource(os, -1, info->shared_info()->DebugNameCStr(),\n                          info->bytecode_array(),\n                          info->closure()->feedback_vector());\n\n  const auto& inlined = info->inlined_functions();\n  SourceIdAssigner id_assigner(info->inlined_functions().size());\n\n  for (unsigned id = 0; id < inlined.size(); id++) {\n    Handle<SharedFunctionInfo> shared_info = inlined[id].shared_info;\n#if V8_ENABLE_WEBASSEMBLY\n    if (shared_info->HasWasmFunctionData()) {\n      continue;\n    }\n#endif  // V8_ENABLE_WEBASSEMBLY\n    os << \", \";\n    const int source_id = id_assigner.GetIdFor(shared_info);\n    // TODO(nicohartmann): We could print some feedback for the inlined\n    // functions, too.\n    JsonPrintBytecodeSource(os, source_id, shared_info->DebugNameCStr(),\n                            inlined[id].bytecode_array);\n  }\n\n  os << \"}\";\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"JsonPrintAllSourceWithPositions\",\n            \"parent\": null,\n            \"about\": \"Prints all function sources with positions as JSON, including the main function and all inlined functions.\",\n            \"logic\": \"Prints the main function source and then iterates through all inlined functions, printing their sources as well, using SourceIdAssigner to assign unique IDs. Also prints inlining information.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream to write the JSON to\"\n                },\n                {\n                    \"name\": \"info\",\n                    \"type\": \"OptimizedCompilationInfo*\",\n                    \"purpose\": \"The compilation info\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"OptimizedCompilationInfo\",\n                \"JsonPrintFunctionSource\",\n                \"SourceIdAssigner\",\n                \"SharedFunctionInfo\",\n                \"Script\",\n                \"JsonPrintInlinedFunctionInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid JsonPrintAllSourceWithPositions(std::ostream& os,\n                                     OptimizedCompilationInfo* info,\n                                     Isolate* isolate) {\n  os << \"\\\"sources\\\" : {\";\n  DirectHandle<Script> script =\n      (info->shared_info().is_null() ||\n       info->shared_info()->script() == Tagged<Object>())\n          ? DirectHandle<Script>()\n          : direct_handle(Cast<Script>(info->shared_info()->script()), isolate);\n  JsonPrintFunctionSource(os, -1,\n                          info->shared_info().is_null()\n                              ? std::unique_ptr<char[]>(new char[1]{0})\n                              : info->shared_info()->DebugNameCStr(),\n                          script, isolate, info->shared_info(), true);\n  const auto& inlined = info->inlined_functions();\n  SourceIdAssigner id_assigner(info->inlined_functions().size());\n  for (unsigned id = 0; id < inlined.size(); id++) {\n    os << \", \";\n    Handle<SharedFunctionInfo> shared = inlined[id].shared_info;\n    const int source_id = id_assigner.GetIdFor(shared);\n    JsonPrintFunctionSource(\n        os, source_id, shared->DebugNameCStr(),\n        direct_handle(Cast<Script>(shared->script()), isolate), isolate, shared,\n        true);\n  }\n  os << \"}, \";\n  os << \"\\\"inlinings\\\" : {\";\n  bool need_comma = false;\n  for (unsigned id = 0; id < inlined.size(); id++) {\n    if (need_comma) os << \", \";\n    const int source_id = id_assigner.GetIdAt(id);\n    JsonPrintInlinedFunctionInfo(os, source_id, id, inlined[id]);\n    need_comma = true;\n  }\n  os << \"}\";\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"JsonPrintAllSourceWithPositionsWasm\",\n            \"parent\": null,\n            \"about\": \"Prints all WASM function sources with positions as JSON, including inlined functions.\",\n            \"logic\": \"Iterates through the provided WASM inlining positions, deduplicates the function sources, and then prints the sources and inlining mappings as JSON.\",\n            \"parameters\": [\n                {\n                    \"name\": \"os\",\n                    \"type\": \"std::ostream&\",\n                    \"purpose\": \"Output stream to write the JSON to\"\n                },\n                {\n                    \"name\": \"module\",\n                    \"type\": \"const wasm::WasmModule*\",\n                    \"purpose\": \"The WASM module\"\n                },\n                {\n                    \"name\": \"wire_bytes\",\n                    \"type\": \"const wasm::WireBytesStorage*\",\n                    \"purpose\": \"The WASM wire bytes storage\"\n                },\n                {\n                    \"name\": \"positions\",\n                    \"type\": \"base::Vector<WasmInliningPosition>\",\n                    \"purpose\": \"Vector of WASM inlining positions\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"wasm::WasmModule\",\n                \"wasm::WireBytesStorage\",\n                \"WasmInliningPosition\",\n                \"wasm::WasmFunction\",\n                \"wasm::DisassembleFunction\",\n                \"SourcePosition\",\n                \"AsJSON\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n#if V8_ENABLE_WEBASSEMBLY\nvoid JsonPrintAllSourceWithPositionsWasm(\n    std::ostream& os, const wasm::WasmModule* module,\n    const wasm::WireBytesStorage* wire_bytes,\n    base::Vector<WasmInliningPosition> positions) {\n  // Filter out duplicate sources. (A single wasm function might be inlined more\n  // than once.)\n  std::vector<int /*function id*/> sources;\n  std::unordered_map<int /*function id*/, size_t /*source index*/> source_map;\n  for (WasmInliningPosition pos : positions) {\n    auto [_, inserted] =\n        source_map.emplace(pos.inlinee_func_index, sources.size());\n    if (inserted) {\n      // The function wasn't inlined yet. Add a new entry to the sources.\n      // The hashmap stores the index to the entry in the source map.\n      sources.push_back(pos.inlinee_func_index);\n    }\n    // Don't do anything if it was already inserted.\n  }\n\n  // Print inlining sources.\n  os << \"\\\"sources\\\": {\";\n  for (size_t i = 0; i < sources.size(); ++i) {\n    if (i != 0) os << \", \";\n    int function_id = sources[i];\n    const wasm::WasmFunction& fct = module->functions[function_id];\n    os << '\"' << i << \"\\\": {\\\"sourceId\\\": \" << i << \", \\\"functionName\\\": \\\"\"\n       << fct.func_index << \"\\\", \\\"sourceName\\\": \\\"\\\", \\\"sourceText\\\": \\\"\";\n    base::Vector<const uint8_t> module_bytes{nullptr, 0};\n    std::optional<wasm::ModuleWireBytes> maybe_wire_bytes =\n        wire_bytes->GetModuleBytes();\n    if (maybe_wire_bytes) module_bytes = maybe_wire_bytes->module_bytes();\n    std::ostringstream wasm_str;\n    wasm::DisassembleFunction(module, function_id,\n                              wire_bytes->GetCode(fct.code), module_bytes,\n                              fct.code.offset(), wasm_str);\n    os << JSONEscaped(wasm_str) << \"\\\"}\";\n  }\n  os << \"},\\n\";\n  // Print inlining mappings.\n  // This maps the inlining position to the deduplicated source in the sources\n  // object generated above.\n  os << \"\\\"inlinings\\\": {\";\n  for (size_t i = 0; i < positions.size(); ++i) {\n    if (i != 0) os << \", \";\n    DCHECK(source_map.contains(positions[i].inlinee_func_index));\n    size_t source_id = source_map.find(positions[i].inlinee_func_index)->second;\n    SourcePosition inlining_pos = positions[i].caller_pos;\n    os << '\"' << i << \"\\\": {\\\"inliningId\\\": \" << i\n       << \", \\\"sourceId\\\": \" << source_id\n       << \", \\\"inliningPosition\\\": \" << AsJSON(inlining_pos) << \"}\";\n  }\n}\n#endif\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetVisualizerLogFileName\",\n            \"parent\": null,\n            \"about\": \"Generates a filename for the visualizer log based on the compilation info, optional base directory, phase, and suffix.\",\n            \"logic\": \"Constructs a filename based on the debug name, shared info address, or a generic 'none' if neither is available. It then incorporates the source file name (if available and `trace_file_names` is enabled). The filename is constructed using SNPrintF, and replacements are performed to ensure the name is valid. Finally, a full path is generated by prepending an optional base directory.\",\n            \"parameters\": [\n                {\n                    \"name\": \"info\",\n                    \"type\": \"OptimizedCompilationInfo*\",\n                    \"purpose\": \"The compilation info\"\n                },\n                {\n                    \"name\": \"optional_base_dir\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"Optional base directory for the log file\"\n                },\n                {\n                    \"name\": \"phase\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"Optional phase name to include in the filename\"\n                },\n                {\n                    \"name\": \"suffix\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"Filename suffix (e.g., 'json')\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<char[]>\",\n                \"description\": \"A unique pointer to a dynamically allocated C-style string containing the filename.\"\n            },\n            \"dependencies\": [\n                \"OptimizedCompilationInfo\",\n                \"v8_flags\",\n                \"IsScript\",\n                \"Cast\",\n                \"String\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstd::unique_ptr<char[]> GetVisualizerLogFileName(OptimizedCompilationInfo* info,\n                                                 const char* optional_base_dir,\n                                                 const char* phase,\n                                                 const char* suffix) {\n  base::EmbeddedVector<char, 256> filename(0);\n  std::unique_ptr<char[]> debug_name = info->GetDebugName();\n  const char* file_prefix = v8_flags.trace_turbo_file_prefix.value();\n  int optimization_id = info->IsOptimizing() ? info->optimization_id() : 0;\n  if (strlen(debug_name.get()) > 0) {\n    if (strcmp(debug_name.get(), \"WasmJSFastApiCall\") == 0) {\n      // Don't clobber one wrapper's output with another's.\n      static int fast_call_wrappers_count = 0;\n      optimization_id = ++fast_call_wrappers_count;\n    }\n    SNPrintF(filename, \"%s-%s-%i\", file_prefix, debug_name.get(),\n             optimization_id);\n  } else if (info->has_shared_info()) {\n    SNPrintF(filename, \"%s-%p-%i\", file_prefix,\n             reinterpret_cast<void*>(info->shared_info()->address()),\n             optimization_id);\n  } else {\n    SNPrintF(filename, \"%s-none-%i\", file_prefix, optimization_id);\n  }\n  base::EmbeddedVector<char, 256> source_file(0);\n  bool source_available = false;\n  if (v8_flags.trace_file_names && info->has_shared_info() &&\n      IsScript(info->shared_info()->script())) {\n    Tagged<Object> source_name =\n        Cast<Script>(info->shared_info()->script())->name();\n    if (IsString(source_name)) {\n      Tagged<String> str = Cast<String>(source_name);\n      if (str->length() > 0) {\n        SNPrintF(source_file, \"%s\", str->ToCString().get());\n        std::replace(source_file.begin(),\n                     source_file.begin() + source_file.length(), '/', '_');\n        source_available = true;\n      }\n    }\n  }\n  std::replace(filename.begin(), filename.begin() + filename.length(), ' ',\n               '_');\n  std::replace(filename.begin(), filename.begin() + filename.length(), ':',\n               '-');\n\n  base::EmbeddedVector<char, 256> base_dir;\n  if (optional_base_dir != nullptr) {\n    SNPrintF(base_dir, \"%s%c\", optional_base_dir,\n             base::OS::DirectorySeparator());\n  } else {\n    base_dir[0] = '\\0';\n  }\n\n  base::EmbeddedVector<char, 256> full_filename;\n  if (phase == nullptr && !source_available) {\n    SNPrintF(full_filename, \"%s%s.%s\", base_dir.begin(), filename.begin(),\n             suffix);\n  } else if (phase != nullptr && !source_available) {\n    SNPrintF(full_filename, \"%s%s-%s.%s\", base_dir.begin(), filename.begin(),\n             phase, suffix);\n  } else if (phase == nullptr && source_available) {\n    SNPrintF(full_filename, \"%s%s_%s.%s\", base_dir.begin(), filename.begin(),\n             source_file.begin(), suffix);\n  } else {"
}