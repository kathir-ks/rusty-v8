{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/baseline/baseline-batch-compiler.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/baseline/baseline-batch-compiler.cc\",\n        \"file_name\": \"baseline-batch-compiler.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements batch compilation for the Baseline compiler in V8, enabling concurrent compilation of multiple functions to improve performance.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for batch compilation, data structures, concurrency, and V8 internals.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/baseline/baseline-batch-compiler.h\"\n\n#include <algorithm>\n\n#include \"src/base/fpu.h\"\n#include \"src/baseline/baseline-compiler.h\"\n#include \"src/codegen/compiler.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/handles/global-handles-inl.h\"\n#include \"src/heap/factory-inl.h\"\n#include \"src/heap/heap-inl.h\"\n#include \"src/heap/local-heap-inl.h\"\n#include \"src/heap/parked-scope.h\"\n#include \"src/objects/fixed-array-inl.h\"\n#include \"src/objects/js-function-inl.h\"\n#include \"src/utils/locked-queue-inl.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"CanCompileWithConcurrentBaseline\",\n            \"parent\": null,\n            \"about\": \"Checks if a shared function info can be compiled with concurrent baseline compilation.\",\n            \"logic\": \"Returns true if the shared function info doesn't have baseline code and can be compiled with baseline.\",\n            \"parameters\": [\n                {\n                    \"name\": \"shared\",\n                    \"type\": \"Tagged<SharedFunctionInfo>\",\n                    \"purpose\": \"The shared function info to check.\"\n                },\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the shared function info can be compiled concurrently, false otherwise.\"\n            },\n            \"dependencies\": [\n                \"CanCompileWithBaseline\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstatic bool CanCompileWithConcurrentBaseline(Tagged<SharedFunctionInfo> shared,\n                                             Isolate* isolate) {\n  return !shared->HasBaselineCode() && CanCompileWithBaseline(isolate, shared);\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BaselineCompilerTask\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents a task for compiling a single SharedFunctionInfo with the Baseline compiler in a background thread.\",\n            \"attributes\": [\n                {\n                    \"name\": \"shared_function_info_\",\n                    \"type\": \"IndirectHandle<SharedFunctionInfo>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Handle to the SharedFunctionInfo to compile.\"\n                },\n                {\n                    \"name\": \"bytecode_\",\n                    \"type\": \"IndirectHandle<BytecodeArray>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Handle to the bytecode array associated with the SharedFunctionInfo.\"\n                },\n                {\n                    \"name\": \"maybe_code_\",\n                    \"type\": \"MaybeIndirectHandle<Code>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Handle to the compiled Code object, if compilation succeeds.\"\n                },\n                {\n                    \"name\": \"time_taken_\",\n                    \"type\": \"base::TimeDelta\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores compilation time for logging.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SharedFunctionInfo\",\n                \"BytecodeArray\",\n                \"Code\",\n                \"BaselineCompiler\",\n                \"LocalIsolate\",\n                \"PersistentHandles\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass BaselineCompilerTask {\n public:\n  BaselineCompilerTask(Isolate* isolate, PersistentHandles* handles,\n                       Tagged<SharedFunctionInfo> sfi)\n      : shared_function_info_(handles->NewHandle(sfi)),\n        bytecode_(handles->NewHandle(sfi->GetBytecodeArray(isolate))) {\n    DCHECK(sfi->is_compiled());\n    shared_function_info_->set_is_sparkplug_compiling(true);\n  }\n\n  BaselineCompilerTask(const BaselineCompilerTask&) V8_NOEXCEPT = delete;\n  BaselineCompilerTask(BaselineCompilerTask&&) V8_NOEXCEPT = default;\n\n  // Executed in the background thread.\n  void Compile(LocalIsolate* local_isolate) {\n    RCS_SCOPE(local_isolate, RuntimeCallCounterId::kCompileBackgroundBaseline);\n    base::ScopedTimer timer(v8_flags.log_function_events ? &time_taken_\n                                                         : nullptr);\n    BaselineCompiler compiler(local_isolate, shared_function_info_, bytecode_);\n    compiler.GenerateCode();\n    maybe_code_ =\n        local_isolate->heap()->NewPersistentMaybeHandle(compiler.Build());\n  }\n\n  // Executed in the main thread.\n  void Install(Isolate* isolate) {\n    shared_function_info_->set_is_sparkplug_compiling(false);\n    Handle<Code> code;\n    if (!maybe_code_.ToHandle(&code)) return;\n    if (v8_flags.print_code) {\n      Print(*code);\n    }\n    // Don't install the code if the bytecode has been flushed or has\n    // already some baseline code installed.\n    if (!CanCompileWithConcurrentBaseline(*shared_function_info_, isolate)) {\n      return;\n    }\n\n    shared_function_info_->set_baseline_code(*code, kReleaseStore);\n    shared_function_info_->set_age(0);\n    if (v8_flags.trace_baseline) {\n      CodeTracer::Scope scope(isolate->GetCodeTracer());\n      std::stringstream ss;\n      ss << \"[Concurrent Sparkplug Off Thread] Function \";\n      ShortPrint(*shared_function_info_, ss);\n      ss << \" installed\\n\";\n      OFStream os(scope.file());\n      os << ss.str();\n    }\n    if (IsScript(shared_function_info_->script())) {\n      Compiler::LogFunctionCompilation(\n          isolate, LogEventListener::CodeTag::kFunction,\n          direct_handle(Cast<Script>(shared_function_info_->script()), isolate),\n          shared_function_info_, DirectHandle<FeedbackVector>(),\n          Cast<AbstractCode>(code), CodeKind::BASELINE,\n          time_taken_.InMillisecondsF());\n    }\n  }\n\n private:\n  IndirectHandle<SharedFunctionInfo> shared_function_info_;\n  IndirectHandle<BytecodeArray> bytecode_;\n  MaybeIndirectHandle<Code> maybe_code_;\n  base::TimeDelta time_taken_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BaselineBatchCompilerJob\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Represents a batch of BaselineCompilerTasks to be compiled concurrently.\",\n            \"attributes\": [\n                {\n                    \"name\": \"tasks_\",\n                    \"type\": \"std::vector<BaselineCompilerTask>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the individual compilation tasks.\"\n                },\n                {\n                    \"name\": \"handles_\",\n                    \"type\": \"std::unique_ptr<PersistentHandles>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Manages persistent handles for objects used in the tasks.\"\n                }\n            ],\n            \"dependencies\": [\n                \"BaselineCompilerTask\",\n                \"WeakFixedArray\",\n                \"SharedFunctionInfo\",\n                \"PersistentHandles\",\n                \"LocalIsolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass BaselineBatchCompilerJob {\n public:\n  BaselineBatchCompilerJob(Isolate* isolate,\n                           DirectHandle<WeakFixedArray> task_queue,\n                           int batch_size) {\n    handles_ = isolate->NewPersistentHandles();\n    tasks_.reserve(batch_size);\n    for (int i = 0; i < batch_size; i++) {\n      Tagged<MaybeObject> maybe_sfi = task_queue->get(i);\n      // TODO(victorgomes): Do I need to clear the value?\n      task_queue->set(i, ClearedValue(isolate));\n      Tagged<HeapObject> obj;\n      // Skip functions where weak reference is no longer valid.\n      if (!maybe_sfi.GetHeapObjectIfWeak(&obj)) continue;\n      // Skip functions where the bytecode has been flushed.\n      Tagged<SharedFunctionInfo> shared = Cast<SharedFunctionInfo>(obj);\n      if (!CanCompileWithConcurrentBaseline(shared, isolate)) continue;\n      // Skip functions that are already being compiled.\n      if (shared->is_sparkplug_compiling()) continue;\n      tasks_.emplace_back(isolate, handles_.get(), shared);\n    }\n    if (v8_flags.trace_baseline) {\n      CodeTracer::Scope scope(isolate->GetCodeTracer());\n      PrintF(scope.file(), \"[Concurrent Sparkplug] compiling %zu functions\\n\",\n             tasks_.size());\n    }\n  }\n\n  // Executed in the background thread.\n  void Compile(LocalIsolate* local_isolate) {\n    local_isolate->heap()->AttachPersistentHandles(std::move(handles_));\n    for (auto& task : tasks_) {\n      task.Compile(local_isolate);\n    }\n    // Get the handle back since we'd need them to install the code later.\n    handles_ = local_isolate->heap()->DetachPersistentHandles();\n  }\n\n  // Executed in the main thread.\n  void Install(Isolate* isolate) {\n    HandleScope local_scope(isolate);\n    for (auto& task : tasks_) {\n      task.Install(isolate);\n    }\n  }\n\n private:\n  std::vector<BaselineCompilerTask> tasks_;\n  std::unique_ptr<PersistentHandles> handles_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ConcurrentBaselineCompiler\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Manages the concurrent compilation of Baseline code using a job queue and background threads.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"job_handle_\",\n                    \"type\": \"std::unique_ptr<JobHandle>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Handle to the background compilation job.\"\n                },\n                {\n                    \"name\": \"incoming_queue_\",\n                    \"type\": \"LockedQueue<std::unique_ptr<BaselineBatchCompilerJob>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Queue of jobs to be compiled in the background.\"\n                },\n                {\n                    \"name\": \"outgoing_queue_\",\n                    \"type\": \"LockedQueue<std::unique_ptr<BaselineBatchCompilerJob>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Queue of compiled jobs ready to be installed.\"\n                }\n            ],\n            \"dependencies\": [\n                \"BaselineBatchCompilerJob\",\n                \"LockedQueue\",\n                \"JobHandle\",\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ConcurrentBaselineCompiler {\n public:\n  class JobDispatcher : public v8::JobTask {\n   public:\n    JobDispatcher(\n        Isolate* isolate,\n        LockedQueue<std::unique_ptr<BaselineBatchCompilerJob>>* incoming_queue,\n        LockedQueue<std::unique_ptr<BaselineBatchCompilerJob>>* outcoming_queue)\n        : isolate_(isolate),\n          incoming_queue_(incoming_queue),\n          outgoing_queue_(outcoming_queue) {}\n\n    void Run(JobDelegate* delegate) override {\n      base::FlushDenormalsScope flush_denormals_scope(\n          isolate_->flush_denormals());\n      LocalIsolate local_isolate(isolate_, ThreadKind::kBackground);\n      UnparkedScope unparked_scope(&local_isolate);\n      LocalHandleScope handle_scope(&local_isolate);\n\n      while (!incoming_queue_->IsEmpty() && !delegate->ShouldYield()) {\n        std::unique_ptr<BaselineBatchCompilerJob> job;\n        if (!incoming_queue_->Dequeue(&job)) break;\n        DCHECK_NOT_NULL(job);\n        job->Compile(&local_isolate);\n        outgoing_queue_->Enqueue(std::move(job));\n      }\n      isolate_->stack_guard()->RequestInstallBaselineCode();\n    }\n\n    size_t GetMaxConcurrency(size_t worker_count) const override {\n      size_t max_threads = v8_flags.concurrent_sparkplug_max_threads;\n      size_t num_tasks = incoming_queue_->size() + worker_count;\n      if (max_threads > 0) {\n        return std::min(max_threads, num_tasks);\n      }\n      return num_tasks;\n    }\n\n   private:\n    Isolate* isolate_;\n    LockedQueue<std::unique_ptr<BaselineBatchCompilerJob>>* incoming_queue_;\n    LockedQueue<std::unique_ptr<BaselineBatchCompilerJob>>* outgoing_queue_;\n  };\n\n  explicit ConcurrentBaselineCompiler(Isolate* isolate) : isolate_(isolate) {\n    if (v8_flags.concurrent_sparkplug) {\n      TaskPriority priority =\n          v8_flags.concurrent_sparkplug_high_priority_threads\n              ? TaskPriority::kUserBlocking\n              : TaskPriority::kUserVisible;\n      job_handle_ = V8::GetCurrentPlatform()->PostJob(\n          priority, std::make_unique<JobDispatcher>(isolate_, &incoming_queue_,\n                                                    &outgoing_queue_));\n    }\n  }\n\n  ~ConcurrentBaselineCompiler() {\n    if (job_handle_ && job_handle_->IsValid()) {\n      // Wait for the job handle to complete, so that we know the queue\n      // pointers are safe.\n      job_handle_->Cancel();\n    }\n  }\n\n  void CompileBatch(Handle<WeakFixedArray> task_queue, int batch_size) {\n    DCHECK(v8_flags.concurrent_sparkplug);\n    RCS_SCOPE(isolate_, RuntimeCallCounterId::kCompileBaseline);\n    incoming_queue_.Enqueue(std::make_unique<BaselineBatchCompilerJob>(\n        isolate_, task_queue, batch_size));\n    job_handle_->NotifyConcurrencyIncrease();\n  }\n\n  void InstallBatch() {\n    while (!outgoing_queue_.IsEmpty()) {\n      std::unique_ptr<BaselineBatchCompilerJob> job;\n      outgoing_queue_.Dequeue(&job);\n      job->Install(isolate_);\n    }\n  }\n\n private:\n  Isolate* isolate_;\n  std::unique_ptr<JobHandle> job_handle_ = nullptr;\n  LockedQueue<std::unique_ptr<BaselineBatchCompilerJob>> incoming_queue_;\n  LockedQueue<std::unique_ptr<BaselineBatchCompilerJob>> outgoing_queue_;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BaselineBatchCompiler\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Orchestrates batch compilation of Baseline code, deciding when to compile batches of functions and managing concurrent compilation if enabled.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"compilation_queue_\",\n                    \"type\": \"Handle<WeakFixedArray>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Queue of SharedFunctionInfos to be compiled in a batch.\"\n                },\n                {\n                    \"name\": \"last_index_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Index of the last element in the compilation queue.\"\n                },\n                {\n                    \"name\": \"estimated_instruction_size_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Estimated size of the instructions to be compiled in the current batch.\"\n                },\n                {\n                    \"name\": \"enabled_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if batch compilation is enabled.\"\n                },\n                {\n                    \"name\": \"concurrent_compiler_\",\n                    \"type\": \"std::unique_ptr<ConcurrentBaselineCompiler>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Manages the concurrent compilation process.\"\n                }\n            ],\n            \"dependencies\": [\n                \"SharedFunctionInfo\",\n                \"JSFunction\",\n                \"WeakFixedArray\",\n                \"ConcurrentBaselineCompiler\",\n                \"Compiler\",\n                \"BaselineCompiler\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass BaselineBatchCompiler {\n public:\n  BaselineBatchCompiler(Isolate* isolate)\n    : isolate_(isolate),\n      compilation_queue_(Handle<WeakFixedArray>::null()),\n      last_index_(0),\n      estimated_instruction_size_(0),\n      enabled_(true) {\n    if (v8_flags.concurrent_sparkplug) {\n      concurrent_compiler_ =\n        std::make_unique<ConcurrentBaselineCompiler>(isolate_);\n    }\n  }\n\n  BaselineBatchCompiler::~BaselineBatchCompiler() {\n    if (!compilation_queue_.is_null()) {\n      GlobalHandles::Destroy(compilation_queue_.location());\n      compilation_queue_ = Handle<WeakFixedArray>::null();\n    }\n  }\n\n  bool BaselineBatchCompiler::concurrent() const {\n    return v8_flags.concurrent_sparkplug &&\n           !isolate_->EfficiencyModeEnabledForTiering();\n  }\n\n  void EnqueueFunction(DirectHandle<JSFunction> function) {\n    DirectHandle<SharedFunctionInfo> shared(function->shared(), isolate_);\n    // Immediately compile the function if batch compilation is disabled.\n    if (!is_enabled()) {\n      IsCompiledScope is_compiled_scope(\n          function->shared()->is_compiled_scope(isolate_));\n      Compiler::CompileBaseline(isolate_, function, Compiler::CLEAR_EXCEPTION,\n                                &is_compiled_scope);\n      return;\n    }\n    if (ShouldCompileBatch(*shared)) {\n      if (concurrent()) {\n        CompileBatchConcurrent(*shared);\n      } else {\n        CompileBatch(function);\n      }\n    } else {\n      Enqueue(shared);\n    }\n  }\n\n  void EnqueueSFI(Tagged<SharedFunctionInfo> shared) {\n    if (!v8_flags.concurrent_sparkplug || !is_enabled()) return;\n    if (ShouldCompileBatch(shared)) {\n      CompileBatchConcurrent(shared);\n    } else {\n      Enqueue(DirectHandle<SharedFunctionInfo>(shared, isolate_));\n    }\n  }\n\n  void Enqueue(DirectHandle<SharedFunctionInfo> shared) {\n    EnsureQueueCapacity();\n    compilation_queue_->set(last_index_++, MakeWeak(*shared));\n  }\n\n  void InstallBatch() {\n    DCHECK(v8_flags.concurrent_sparkplug);\n    concurrent_compiler_->InstallBatch();\n  }\n\n  void EnsureQueueCapacity() {\n    if (compilation_queue_.is_null()) {\n      compilation_queue_ = isolate_->global_handles()->Create(\n          *isolate_->factory()->NewWeakFixedArray(kInitialQueueSize,\n                                                  AllocationType::kOld));\n      return;\n    }\n    if (last_index_ >= compilation_queue_->length()) {\n      DirectHandle<WeakFixedArray> new_queue =\n          isolate_->factory()->CopyWeakFixedArrayAndGrow(compilation_queue_,\n                                                         last_index_);\n      GlobalHandles::Destroy(compilation_queue_.location());\n      compilation_queue_ = isolate_->global_handles()->Create(*new_queue);\n    }\n  }\n\n  void CompileBatch(DirectHandle<JSFunction> function) {\n    {\n      IsCompiledScope is_compiled_scope(\n          function->shared()->is_compiled_scope(isolate_));\n      Compiler::CompileBaseline(isolate_, function, Compiler::CLEAR_EXCEPTION,\n                                &is_compiled_scope);\n    }\n    for (int i = 0; i < last_index_; i++) {\n      Tagged<MaybeObject> maybe_sfi = compilation_queue_->get(i);\n      MaybeCompileFunction(maybe_sfi);\n      compilation_queue_->set(i, ClearedValue(isolate_));\n    }\n    ClearBatch();\n  }\n\n  void CompileBatchConcurrent(\n      Tagged<SharedFunctionInfo> shared) {\n    Enqueue(DirectHandle<SharedFunctionInfo>(shared, isolate_));\n    concurrent_compiler_->CompileBatch(compilation_queue_, last_index_);\n    ClearBatch();\n  }\n\n  bool ShouldCompileBatch(\n      Tagged<SharedFunctionInfo> shared) {\n    // Early return if the function is compiled with baseline already or it is not\n    // suitable for baseline compilation.\n    if (shared->HasBaselineCode()) return false;\n    // If we're already compiling this function, return.\n    if (shared->is_sparkplug_compiling()) return false;\n    if (!CanCompileWithBaseline(isolate_, shared)) return false;\n\n    int estimated_size;\n    {\n      DisallowHeapAllocation no_gc;\n      estimated_size = BaselineCompiler::EstimateInstructionSize(\n          shared->GetBytecodeArray(isolate_));\n    }\n    estimated_instruction_size_ += estimated_size;\n    if (v8_flags.trace_baseline_batch_compilation) {\n      CodeTracer::Scope trace_scope(isolate_->GetCodeTracer());\n      PrintF(trace_scope.file(), \"[Baseline batch compilation] Enqueued SFI %s\",\n             shared->DebugNameCStr().get());\n      PrintF(trace_scope.file(),\n             \" with estimated size %d (current budget: %d/%d)\\n\", estimated_size,\n             estimated_instruction_size_,\n             v8_flags.baseline_batch_compilation_threshold.value());\n    }\n    if (estimated_instruction_size_ >=\n        v8_flags.baseline_batch_compilation_threshold) {\n      if (v8_flags.trace_baseline_batch_compilation) {\n        CodeTracer::Scope trace_scope(isolate_->GetCodeTracer());\n        PrintF(trace_scope.file(),\n               \"[Baseline batch compilation] Compiling current batch of %d \"\n               \"functions\\n\",\n               (last_index_ + 1));\n      }\n      return true;\n    }\n    return false;\n  }\n\n  bool MaybeCompileFunction(\n      Tagged<MaybeObject> maybe_sfi) {\n    Tagged<HeapObject> heapobj;\n    // Skip functions where the weak reference is no longer valid.\n    if (!maybe_sfi.GetHeapObjectIfWeak(&heapobj)) return false;\n    Handle<SharedFunctionInfo> shared =\n        handle(Cast<SharedFunctionInfo>(heapobj), isolate_);\n    // Skip functions where the bytecode has been flushed.\n    if (!shared->is_compiled()) return false;\n\n    IsCompiledScope is_compiled_scope(shared->is_compiled_scope(isolate_));\n    return Compiler::CompileSharedWithBaseline(\n        isolate_, shared, Compiler::CLEAR_EXCEPTION, &is_compiled_scope);\n  }\n\n  void ClearBatch() {\n    estimated_instruction_size_ = 0;\n    last_index_ = 0;\n  }\n\n private:\n  Isolate* isolate_;\n  Handle<WeakFixedArray> compilation_queue_;\n  int last_index_;\n  int estimated_instruction_size_;\n  bool enabled_;\n  std::unique_ptr<ConcurrentBaselineCompiler> concurrent_compiler_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"concurrent\",\n            \"parent\": \"BaselineBatchCompiler\",\n            \"about\": \"Determines if concurrent baseline compilation is enabled and should be used.\",\n            \"logic\": \"Returns true if the concurrent_sparkplug flag is enabled and efficiency mode for tiering is disabled.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if concurrent compilation is enabled, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  bool BaselineBatchCompiler::concurrent() const {\n    return v8_flags.concurrent_sparkplug &&\n           !isolate_->EfficiencyModeEnabledForTiering();\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EnqueueFunction\",\n            \"parent\": \"BaselineBatchCompiler\",\n            \"about\": \"Enqueues a JSFunction for baseline compilation, either immediately or as part of a batch.\",\n            \"logic\": \"If batch compilation is disabled, compiles immediately. Otherwise, checks if a batch should be compiled based on estimated instruction size. If a batch should be compiled, compiles concurrently if enabled or sequentially otherwise. If a batch shouldn't be compiled, enqueues the function to the compilation queue.\",\n            \"parameters\": [\n                {\n                    \"name\": \"function\",\n                    \"type\": \"DirectHandle<JSFunction>\",\n                    \"purpose\": \"The JSFunction to enqueue.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"SharedFunctionInfo\",\n                \"CompileBaseline\",\n                \"ShouldCompileBatch\",\n                \"CompileBatchConcurrent\",\n                \"CompileBatch\",\n                \"Enqueue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void BaselineBatchCompiler::EnqueueFunction(DirectHandle<JSFunction> function) {\n    DirectHandle<SharedFunctionInfo> shared(function->shared(), isolate_);\n    // Immediately compile the function if batch compilation is disabled.\n    if (!is_enabled()) {\n      IsCompiledScope is_compiled_scope(\n          function->shared()->is_compiled_scope(isolate_));\n      Compiler::CompileBaseline(isolate_, function, Compiler::CLEAR_EXCEPTION,\n                                &is_compiled_scope);\n      return;\n    }\n    if (ShouldCompileBatch(*shared)) {\n      if (concurrent()) {\n        CompileBatchConcurrent(*shared);\n      } else {\n        CompileBatch(function);\n      }\n    } else {\n      Enqueue(shared);\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EnqueueSFI\",\n            \"parent\": \"BaselineBatchCompiler\",\n            \"about\": \"Enqueues a SharedFunctionInfo for baseline compilation, either immediately or as part of a batch.\",\n            \"logic\": \"Similar to EnqueueFunction, but operates on SharedFunctionInfo directly.\",\n            \"parameters\": [\n                {\n                    \"name\": \"shared\",\n                    \"type\": \"Tagged<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo to enqueue.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ShouldCompileBatch\",\n                \"CompileBatchConcurrent\",\n                \"Enqueue\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void BaselineBatchCompiler::EnqueueSFI(Tagged<SharedFunctionInfo> shared) {\n    if (!v8_flags.concurrent_sparkplug || !is_enabled()) return;\n    if (ShouldCompileBatch(shared)) {\n      CompileBatchConcurrent(shared);\n    } else {\n      Enqueue(DirectHandle<SharedFunctionInfo>(shared, isolate_));\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Enqueue\",\n            \"parent\": \"BaselineBatchCompiler\",\n            \"about\": \"Adds a SharedFunctionInfo to the compilation queue.\",\n            \"logic\": \"Ensures there is enough capacity in the queue, then adds the SharedFunctionInfo to the queue as a weak reference.\",\n            \"parameters\": [\n                {\n                    \"name\": \"shared\",\n                    \"type\": \"DirectHandle<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo to add to the queue.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"EnsureQueueCapacity\",\n                \"MakeWeak\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void BaselineBatchCompiler::Enqueue(DirectHandle<SharedFunctionInfo> shared) {\n    EnsureQueueCapacity();\n    compilation_queue_->set(last_index_++, MakeWeak(*shared));\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InstallBatch\",\n            \"parent\": \"BaselineBatchCompiler\",\n            \"about\": \"Installs the compiled code from the concurrent compiler.\",\n            \"logic\": \"Calls InstallBatch on the concurrent compiler.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ConcurrentBaselineCompiler::InstallBatch\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void BaselineBatchCompiler::InstallBatch() {\n    DCHECK(v8_flags.concurrent_sparkplug);\n    concurrent_compiler_->InstallBatch();\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EnsureQueueCapacity\",\n            \"parent\": \"BaselineBatchCompiler\",\n            \"about\": \"Ensures that the compilation queue has enough capacity to enqueue more functions.\",\n            \"logic\": \"If the queue is null, creates a new one. If the queue is full, copies the existing queue to a larger one.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n  void BaselineBatchCompiler::EnsureQueueCapacity() {\n    if (compilation_queue_.is_null()) {\n      compilation_queue_ = isolate_->global_handles()->Create(\n          *isolate_->factory()->NewWeakFixedArray(kInitialQueueSize,\n                                                  AllocationType::kOld));\n      return;\n    }\n    if (last_index_ >= compilation_queue_->length()) {\n      DirectHandle<WeakFixedArray> new_queue =\n          isolate_->factory()->CopyWeakFixedArrayAndGrow(compilation_queue_,\n                                                         last_index_);\n      GlobalHandles::Destroy(compilation_queue_.location());\n      compilation_queue_ = isolate_->global_handles()->Create(*new_queue);\n    }\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CompileBatch\",\n            \"parent\": \"BaselineBatchCompiler\",\n            \"about\": \"Compiles a batch of functions sequentially.\",\n            \"logic\": \"Iterates through the compilation queue, compiling each function. Clears the queue after compilation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"function\",\n                    \"type\": \"DirectHandle<JSFunction>\",\n                    \"purpose\": \"A JSFunction to compile.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"CompileBaseline\",\n                \"MaybeCompileFunction\",\n                \"ClearBatch\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void BaselineBatchCompiler::CompileBatch(DirectHandle<JSFunction> function) {\n    {\n      IsCompiledScope is_compiled_scope(\n          function->shared()->is_compiled_scope(isolate_));\n      Compiler::CompileBaseline(isolate_, function, Compiler::CLEAR_EXCEPTION,\n                                &is_compiled_scope);\n    }\n    for (int i = 0; i < last_index_; i++) {\n      Tagged<MaybeObject> maybe_sfi = compilation_queue_->get(i);\n      MaybeCompileFunction(maybe_sfi);\n      compilation_queue_->set(i, ClearedValue(isolate_));\n    }\n    ClearBatch();\n  }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CompileBatchConcurrent\",\n            \"parent\": \"BaselineBatchCompiler\",\n            \"about\": \"Compiles a batch of functions concurrently.\",\n            \"logic\": \"Enqueues the given shared function info and compiles the whole queue concurrently using the concurrent compiler. Clears the queue after compilation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"shared\",\n                    \"type\": \"Tagged<SharedFunctionInfo>\",\n                    \"purpose\": \"The SharedFunctionInfo to compile.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Enqueue\",\n                \"ConcurrentBaselineCompiler::CompileBatch\",\n                \"ClearBatch\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  void BaselineBatchCompiler::CompileBatchConcurrent(\n      Tagged<SharedFunctionInfo> shared) {\n    Enqueue(DirectHandle<SharedFunctionInfo>(shared, isolate_));\n    "
}