{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/code-assembler.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/code-assembler.cc\",\n        \"file_name\": \"code-assembler.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the CodeAssembler class, which provides a higher-level interface for generating machine code using the Turbofan compiler framework in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for CodeAssembler functionality, standard library features, and V8 internals.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/code-assembler.h\"\n\n            #include <optional>\n            #include <ostream>\n            #include <thread>  // NOLINT(build/c++11) (for this_thread::yield())\n\n            #include \"src/builtins/builtins-inl.h\"\n            #include \"src/builtins/constants-table-builder.h\"\n            #include \"src/codegen/compiler.h\"\n            #include \"src/codegen/interface-descriptors-inl.h\"\n            #include \"src/codegen/machine-type.h\"\n            #include \"src/codegen/tnode.h\"\n            #include \"src/compiler-dispatcher/optimizing-compile-dispatcher.h\"\n            #include \"src/compiler/backend/instruction-selector.h\"\n            #include \"src/compiler/js-graph.h\"\n            #include \"src/compiler/linkage.h\"\n            #include \"src/compiler/node-matchers.h\"\n            #include \"src/compiler/pipeline.h\"\n            #include \"src/compiler/raw-machine-assembler.h\"\n            #include \"src/compiler/schedule.h\"\n            #include \"src/compiler/turbofan-graph.h\"\n            #include \"src/handles/handles-inl.h\"\n            #include \"src/heap/factory-inl.h\"\n            #include \"src/numbers/conversions-inl.h\"\n            #include \"src/objects/smi.h\"\n            #include \"src/utils/memcopy.h\"\n            #include \"src/zone/zone.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CodeAssemblerState\",\n            \"about\": \"Stores the state of the CodeAssembler, including the RawMachineAssembler, code kind, name, builtin, and various flags and data structures used during code generation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"raw_assembler_\",\n                    \"type\": \"std::unique_ptr<RawMachineAssembler>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Underlying assembler for generating machine code.\"\n                },\n                {\n                    \"name\": \"kind_\",\n                    \"type\": \"CodeKind\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The kind of code being generated (e.g., builtin, bytecode handler).\"\n                },\n                {\n                    \"name\": \"name_\",\n                    \"type\": \"const char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The name of the code being generated (for debugging).\"\n                },\n                {\n                    \"name\": \"builtin_\",\n                    \"type\": \"Builtin\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The Builtin id, if generating code for a builtin.\"\n                },\n                {\n                    \"name\": \"code_generated_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the code has been generated.\"\n                },\n                {\n                    \"name\": \"variables_\",\n                    \"type\": \"ZoneSet<CodeAssemblerVariable::Impl*, CodeAssemblerVariable::ImplComparator>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Keeps track of variables created during code generation.\"\n                },\n                {\n                    \"name\": \"jsgraph_\",\n                    \"type\": \"JSGraph*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"JSGraph instance for building the graph of JavaScript operations.\"\n                },\n                {\n                    \"name\": \"exception_handler_labels_\",\n                    \"type\": \"std::vector<CodeAssemblerExceptionHandlerLabel*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stack of exception handler labels for nested exception handling.\"\n                },\n                {\n                    \"name\": \"call_prologue_\",\n                    \"type\": \"CodeAssemblerCallback\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Callback function executed at the beginning of each call.\"\n                },\n                {\n                    \"name\": \"call_epilogue_\",\n                    \"type\": \"CodeAssemblerCallback\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Callback function executed at the end of each call.\"\n                },\n                 {\n                    \"name\": \"macro_call_stack_\",\n                    \"type\": \"std::vector<FileAndLine>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stack of file and line information for macro calls (debugging).\"\n                }\n            ],\n            \"dependencies\": [\n                \"RawMachineAssembler\",\n                \"CodeKind\",\n                \"Builtin\",\n                \"CallDescriptor\",\n                \"JSGraph\",\n                \"CallInterfaceDescriptor\",\n                \"AssemblerDebugInfo\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CodeAssemblerState {\n            public:\n                CodeAssemblerState(Isolate* isolate, Zone* zone, const CallInterfaceDescriptor& descriptor,\n                                CodeKind kind, const char* name, Builtin builtin);\n\n                CodeAssemblerState(Isolate* isolate, Zone* zone, CallDescriptor* call_descriptor,\n                                CodeKind kind, const char* name, Builtin builtin);\n\n                ~CodeAssemblerState();\n\n                int parameter_count() const;\n\n                RawMachineAssembler* raw_assembler() { return raw_assembler_.get(); }\n                CodeKind kind() const { return kind_; }\n                const char* name() const { return name_; }\n                Builtin builtin() const { return builtin_; }\n                bool code_generated() const { return code_generated_; }\n                void set_code_generated() { code_generated_ = true; }\n                JSGraph* jsgraph() { return jsgraph_; }\n\n                void PushExceptionHandler(CodeAssemblerExceptionHandlerLabel* label);\n                void PopExceptionHandler();\n\n                // Callbacks to support code generation around call sites.\n                using CodeAssemblerCallback = std::function<void()>;\n                CodeAssemblerCallback call_prologue() const { return call_prologue_; }\n                CodeAssemblerCallback call_epilogue() const { return call_epilogue_; }\n\n            #if DEBUG\n                void PrintCurrentBlock(std::ostream& os);\n            #endif\n\n                bool InsideBlock();\n\n                void SetInitialDebugInformation(const char* msg, const char* file, int line);\n\n                CodeAssemblerState::VariableId NextVariableId() { return next_variable_id_++; }\n\n                const std::vector<FileAndLine>& macro_call_stack() const {\n                    return macro_call_stack_;\n                }\n\n                void set_dynamic_js_parameter_count(Node* dynamic_js_parameter_count) {\n                    dynamic_js_parameter_count_ = dynamic_js_parameter_count;\n                }\n\n                Node* dynamic_js_parameter_count() const {\n                    return dynamic_js_parameter_count_;\n                }\n\n            private:\n                std::unique_ptr<RawMachineAssembler> raw_assembler_;\n                CodeKind kind_;\n                const char* name_;\n                Builtin builtin_;\n                bool code_generated_;\n                ZoneSet<CodeAssemblerVariable::Impl*, CodeAssemblerVariable::ImplComparator> variables_;\n                JSGraph* jsgraph_;\n                std::vector<CodeAssemblerExceptionHandlerLabel*> exception_handler_labels_;\n\n                CodeAssemblerCallback call_prologue_ = nullptr;\n                CodeAssemblerCallback call_epilogue_ = nullptr;\n                std::vector<FileAndLine> macro_call_stack_;\n\n                CodeAssemblerState::VariableId next_variable_id_ = 0;\n                Node* dynamic_js_parameter_count_ = nullptr;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CodeAssembler\",\n            \"about\": \"Provides a high-level interface for generating machine code using the Turbofan compiler framework. It encapsulates RawMachineAssembler and JSGraph.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CodeAssemblerState\",\n                \"RawMachineAssembler\",\n                \"JSGraph\",\n                \"Builtin\",\n                \"CallInterfaceDescriptor\",\n                \"CallDescriptor\",\n                \"Zone\",\n                \"Isolate\",\n                \"Handle\",\n                \"Smi\",\n                \"String\",\n                \"ExternalReference\",\n                \"Runtime\",\n                \"StubCallMode\",\n                \"MachineType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CodeAssembler {\n            public:\n                explicit CodeAssembler(CodeAssemblerState* state) : state_(state) {}\n                ~CodeAssembler();\n\n                Isolate* isolate() const;\n                Factory* factory() const;\n                Zone* zone() const;\n                CodeAssemblerState* state() const { return state_; }\n                RawMachineAssembler* raw_assembler() const;\n                JSGraph* jsgraph() const;\n\n                Builtin builtin();\n\n                // Breakpoints.\n                void BreakOnNode(int node_id);\n\n                // Callbacks.\n                void RegisterCallGenerationCallbacks(const CodeAssemblerState::CodeAssemblerCallback& call_prologue,\n                                                    const CodeAssemblerState::CodeAssemblerCallback& call_epilogue);\n                void UnregisterCallGenerationCallbacks();\n                void CallPrologue();\n                void CallEpilogue();\n\n                bool Word32ShiftIsSafe() const;\n\n                // Helper class to schedule builtins compilation on the main thread,\n                // potentially concurrently, and handle the finalization on the main\n                // thread.\n                class BuiltinCompilationScheduler {\n                public:\n                    BuiltinCompilationScheduler() = default;\n                    ~BuiltinCompilationScheduler();\n\n                    void CompileCode(Isolate* isolate, std::unique_ptr<TurbofanCompilationJob> job);\n\n                    void AwaitAndFinalizeCurrentBatch(Isolate* isolate);\n\n                private:\n                    void QueueJob(Isolate* isolate, std::unique_ptr<TurbofanCompilationJob> job);\n                    void FinalizeJobOnMainThread(Isolate* isolate, TurbofanCompilationJob* job);\n\n                    std::deque<std::unique_ptr<TurbofanCompilationJob>> main_thread_output_queue_;\n                    size_t current_batch_zone_size_ = 0;\n                    int builtins_installed_count_ = 0;\n                };\n\n                bool Is64() const;\n                bool Is32() const;\n\n                bool IsFloat64RoundUpSupported() const;\n                bool IsFloat64RoundDownSupported() const;\n                bool IsFloat64RoundTiesEvenSupported() const;\n                bool IsFloat64RoundTruncateSupported() const;\n                bool IsTruncateFloat64ToFloat16RawBitsSupported() const;\n                bool IsInt32AbsWithOverflowSupported() const;\n                bool IsInt64AbsWithOverflowSupported() const;\n                bool IsIntPtrAbsWithOverflowSupported() const;\n                bool IsWord32PopcntSupported() const;\n                bool IsWord64PopcntSupported() const;\n                bool IsWord32CtzSupported() const;\n                bool IsWord64CtzSupported() const;\n\n                // Constants\n                TNode<Int32T> UniqueInt32Constant(int32_t value);\n                TNode<Int32T> Int32Constant(int32_t value);\n                TNode<Int64T> UniqueInt64Constant(int64_t value);\n                TNode<Int64T> Int64Constant(int64_t value);\n                TNode<IntPtrT> UniqueIntPtrConstant(intptr_t value);\n                TNode<IntPtrT> IntPtrConstant(intptr_t value);\n                TNode<TaggedIndex> TaggedIndexConstant(intptr_t value);\n                TNode<Number> NumberConstant(double value);\n                TNode<Smi> SmiConstant(Tagged<Smi> value);\n                TNode<Smi> SmiConstant(int value);\n                TNode<HeapObject> UntypedHeapConstantNoHole(Handle<HeapObject> object);\n                TNode<HeapObject> UntypedHeapConstantMaybeHole(Handle<HeapObject> object);\n                TNode<HeapObject> UntypedHeapConstantHole(Handle<HeapObject> object);\n                TNode<String> StringConstant(const char* str);\n                TNode<Boolean> BooleanConstant(bool value);\n                TNode<ExternalReference> ExternalConstant(ExternalReference address);\n                TNode<ExternalReference> IsolateField(IsolateFieldId id);\n                TNode<Float32T> Float32Constant(double value);\n                TNode<Float64T> Float64Constant(double value);\n                TNode<AnyTaggedT> LoadRootMapWord(RootIndex root_index);\n\n                // Matchers.\n                bool IsMapOffsetConstant(Node* node);\n\n                // Try matchers.\n                bool TryToInt32Constant(TNode<IntegralT> node, int32_t* out_value);\n                bool TryToInt64Constant(TNode<IntegralT> node, int64_t* out_value);\n                bool TryToSmiConstant(TNode<Smi> tnode, Tagged<Smi>* out_value);\n                bool TryToSmiConstant(TNode<IntegralT> node, Tagged<Smi>* out_value);\n                bool TryToIntPtrConstant(TNode<Smi> tnode, intptr_t* out_value);\n                bool TryToIntPtrConstant(TNode<IntegralT> node, intptr_t* out_value);\n                bool IsUndefinedConstant(TNode<Object> node);\n                bool IsNullConstant(TNode<Object> node);\n\n                // Parameters\n                Node* UntypedParameter(int index);\n                template <class Type>\n                TNode<Type> Parameter(int index) {\n                    return UncheckedCast<Type>(UntypedParameter(index));\n                }\n\n                // JSFunctionCalls.\n                bool IsJSFunctionCall() const;\n                TNode<Context> GetJSContextParameter();\n                bool HasDynamicJSParameterCount();\n                TNode<Uint16T> DynamicJSParameterCount();\n                void SetDynamicJSParameterCount(TNode<Uint16T> parameter_count);\n\n                // Returns\n                void Return(TNode<Object> value);\n                void Return(TNode<Object> value1, TNode<Object> value2);\n                void Return(TNode<Object> value1, TNode<Object> value2,\n                            TNode<Object> value3);\n                void Return(TNode<Int32T> value);\n                void Return(TNode<Uint32T> value);\n                void Return(TNode<WordT> value);\n                void Return(TNode<Float32T> value);\n                void Return(TNode<Float64T> value);\n                void Return(TNode<WordT> value1, TNode<WordT> value2);\n                void Return(TNode<Word32T> value1, TNode<Word32T> value2);\n                void Return(TNode<WordT> value1, TNode<Object> value2);\n                void Return(TNode<Word32T> value1, TNode<Object> value2);\n                void PopAndReturn(Node* pop, Node* value);\n                void PopAndReturn(Node* pop, Node* value1, Node* value2,\n                                    Node* value3, Node* value4);\n                void ReturnIf(TNode<BoolT> condition, TNode<Object> value);\n\n                void AbortCSADcheck(Node* message);\n                void DebugBreak();\n                void Unreachable();\n                void EmitComment(std::string str);\n\n                // For testing the CSA static assert macro.\n                void StaticAssert(TNode<BoolT> value, const char* source);\n\n                // Source Positions.\n                void SetSourcePosition(const char* file, int line);\n                void PushSourcePosition();\n                void PopSourcePosition();\n                const std::vector<FileAndLine>& GetMacroSourcePositionStack() const;\n\n                // Labels\n                void Bind(Label* label);\n            #if DEBUG\n                void Bind(Label* label, AssemblerDebugInfo debug_info);\n            #endif  // DEBUG\n\n                // Memory.\n                TNode<RawPtrT> LoadFramePointer();\n                TNode<RawPtrT> LoadParentFramePointer();\n            #if V8_ENABLE_WEBASSEMBLY\n                TNode<RawPtrT> LoadStackPointer();\n                void SetStackPointer(TNode<RawPtrT> ptr);\n            #endif\n                TNode<RawPtrT> LoadPointerFromRootRegister(TNode<IntPtrT> offset);\n                TNode<Uint8T> LoadUint8FromRootRegister(TNode<IntPtrT> offset);\n\n                TNode<RawPtrT> StackSlotPtr(int size, int alignment);\n\n            #define DEFINE_CODE_ASSEMBLER_BINARY_OP(name, ResType, Arg1Type, Arg2Type)   \\\n                TNode<ResType> name(TNode<Arg1Type> a, TNode<Arg2Type> b);\n            CODE_ASSEMBLER_BINARY_OP_LIST(DEFINE_CODE_ASSEMBLER_BINARY_OP)\n            #undef DEFINE_CODE_ASSEMBLER_BINARY_OP\n\n                TNode<PairT<Word32T, Word32T>> Int32PairAdd(\n                    TNode<Word32T> lhs_lo_word, TNode<Word32T> lhs_hi_word,\n                    TNode<Word32T> rhs_lo_word, TNode<Word32T> rhs_hi_word);\n                TNode<PairT<Word32T, Word32T>> Int32PairSub(\n                    TNode<Word32T> lhs_lo_word, TNode<Word32T> lhs_hi_word,\n                    TNode<Word32T> rhs_lo_word, TNode<Word32T> rhs_hi_word);\n\n                TNode<WordT> WordShl(TNode<WordT> value, int shift);\n                TNode<WordT> WordShr(TNode<WordT> value, int shift);\n                TNode<WordT> WordSar(TNode<WordT> value, int shift);\n                TNode<Word32T> Word32Shr(TNode<Word32T> value, int shift);\n                TNode<Word32T> Word32Sar(TNode<Word32T> value, int shift);\n\n            #define CODE_ASSEMBLER_COMPARE(Name, ArgT, VarT, ToConstant, op)          \\\n                TNode<BoolT> Name(TNode<ArgT> left, TNode<ArgT> right);\n            CODE_ASSEMBLER_COMPARE(IntPtrEqual, WordT, intptr_t, TryToIntPtrConstant, ==)\n            CODE_ASSEMBLER_COMPARE(WordEqual, WordT, intptr_t, TryToIntPtrConstant, ==)\n            CODE_ASSEMBLER_COMPARE(WordNotEqual, WordT, intptr_t, TryToIntPtrConstant, !=)\n            CODE_ASSEMBLER_COMPARE(Word32Equal, Word32T, int32_t, TryToInt32Constant, ==)\n            CODE_ASSEMBLER_COMPARE(Word32NotEqual, Word32T, int32_t, TryToInt32Constant, !=)\n            CODE_ASSEMBLER_COMPARE(Word64Equal, Word64T, int64_t, TryToInt64Constant, ==)\n            CODE_ASSEMBLER_COMPARE(Word64NotEqual, Word64T, int64_t, TryToInt64Constant, !=)\n            #undef CODE_ASSEMBLER_COMPARE\n\n                TNode<UintPtrT> ChangeUint32ToWord(TNode<Word32T> value);\n                TNode<IntPtrT> ChangeInt32ToIntPtr(TNode<Word32T> value);\n                TNode<IntPtrT> ChangeFloat64ToIntPtr(TNode<Float64T> value);\n                TNode<UintPtrT> ChangeFloat64ToUintPtr(TNode<Float64T> value);\n                TNode<Float64T> ChangeUintPtrToFloat64(TNode<UintPtrT> value);\n                TNode<Float64T> RoundIntPtrToFloat64(Node* value);\n                TNode<Int32T> TruncateFloat32ToInt32(TNode<Float32T> value);\n                TNode<Int64T> TruncateFloat64ToInt64(TNode<Float64T> value);\n\n            #define DEFINE_CODE_ASSEMBLER_UNARY_OP(name, ResType, ArgType) \\\n                TNode<ResType> name(TNode<ArgType> a);\n            CODE_ASSEMBLER_UNARY_OP_LIST(DEFINE_CODE_ASSEMBLER_UNARY_OP)\n            #undef DEFINE_CODE_ASSEMBLER_UNARY_OP\n\n                Node* Load(MachineType type, Node* base);\n                Node* Load(MachineType type, Node* base, Node* offset);\n                TNode<Object> LoadFullTagged(Node* base);\n                TNode<Object> LoadFullTagged(Node* base, TNode<IntPtrT> offset);\n                Node* AtomicLoad(MachineType type, AtomicMemoryOrder order,\n                                TNode<RawPtrT> base, TNode<WordT> offset);\n                template <class Type>\n                TNode<Type> AtomicLoad64(AtomicMemoryOrder order, TNode<RawPtrT> base,\n                                        TNode<WordT> offset);\n                Node* LoadFromObject(MachineType type, TNode<Object> object,\n                                    TNode<IntPtrT> offset);\n                Node* LoadProtectedPointerFromObject(TNode<Object> object,\n                                                    TNode<IntPtrT> offset);\n            #ifdef V8_MAP_PACKING\n                Node* PackMapWord(Node* value);\n            #endif\n                TNode<Object> LoadRoot(RootIndex root_index);\n                Node* UnalignedLoad(MachineType type, TNode<RawPtrT> base,\n                                    TNode<WordT> offset);\n\n                void Store(Node* base, Node* value);\n                void StoreToObject(MachineRepresentation rep, TNode<Object> object,\n                                  TNode<IntPtrT> offset, Node* value,\n                                  StoreToObjectWriteBarrier write_barrier);\n                void OptimizedStoreField(MachineRepresentation rep,\n                                        TNode<HeapObject> object, int offset,\n                                        Node* value);\n                void OptimizedStoreIndirectPointerField(TNode<HeapObject> object,\n                                                       int offset,\n                                                       IndirectPointerTag tag,\n                                                       Node* value);\n                void OptimizedStoreIndirectPointerFieldNoWriteBarrier(\n                    TNode<HeapObject> object, int offset, IndirectPointerTag tag,\n                    Node* value);\n                void OptimizedStoreFieldAssertNoWriteBarrier(\n                    MachineRepresentation rep, TNode<HeapObject> object, int offset,\n                    Node* value);\n                void OptimizedStoreFieldUnsafeNoWriteBarrier(\n                    MachineRepresentation rep, TNode<HeapObject> object, int offset,\n                    Node* value);\n                void OptimizedStoreMap(TNode<HeapObject> object, TNode<Map> map);\n                void Store(Node* base, Node* offset, Node* value);\n                void StoreEphemeronKey(Node* base, Node* offset, Node* value);\n                void StoreNoWriteBarrier(MachineRepresentation rep, Node* base,\n                                        Node* value);\n                void StoreNoWriteBarrier(MachineRepresentation rep, Node* base,\n                                        Node* offset, Node* value);\n                void UnsafeStoreNoWriteBarrier(MachineRepresentation rep,\n                                              Node* base, Node* value);\n                void UnsafeStoreNoWriteBarrier(MachineRepresentation rep,\n                                              Node* base, Node* offset,\n                                              Node* value);\n                void StoreFullTaggedNoWriteBarrier(TNode<RawPtrT> base,\n                                                  TNode<Object> tagged_value);\n                void StoreFullTaggedNoWriteBarrier(TNode<RawPtrT> base,\n                                                  TNode<IntPtrT> offset,\n                                                  TNode<Object> tagged_value);\n                void AtomicStore(MachineRepresentation rep, AtomicMemoryOrder order,\n                                TNode<RawPtrT> base, TNode<WordT> offset,\n                                TNode<Word32T> value);\n                void AtomicStore64(AtomicMemoryOrder order, TNode<RawPtrT> base,\n                                  TNode<WordT> offset, TNode<UintPtrT> value,\n                                  TNode<UintPtrT> value_high);\n\n            #define ATOMIC_FUNCTION(name)                                                 \\\n                TNode<Word32T> Atomic##name(                                 \\\n                    MachineType type, TNode<RawPtrT> base, TNode<UintPtrT> offset,          \\\n                    TNode<Word32T> value);                                                 \\\n                template <class Type>                                                       \\\n                TNode<Type> Atomic##name##64(                                \\\n                    TNode<RawPtrT> base, TNode<UintPtrT> offset, TNode<UintPtrT> value,     \\\n                    TNode<UintPtrT> value_high);\n            ATOMIC_FUNCTION(Add)\n            ATOMIC_FUNCTION(Sub)\n            ATOMIC_FUNCTION(And)\n            ATOMIC_FUNCTION(Or)\n            ATOMIC_FUNCTION(Xor)\n            ATOMIC_FUNCTION(Exchange)\n            #undef ATOMIC_FUNCTION\n\n                TNode<Word32T> AtomicCompareExchange(MachineType type,\n                                                    TNode<RawPtrT> base,\n                                                    TNode<WordT> offset,\n                                                    TNode<Word32T> old_value,\n                                                    TNode<Word32T> new_value);\n                template <class Type>\n                TNode<Type> AtomicCompareExchange64(\n                    TNode<RawPtrT> base, TNode<WordT> offset, TNode<UintPtrT> old_value,\n                    TNode<UintPtrT> new_value, TNode<UintPtrT> old_value_high,\n                    TNode<UintPtrT> new_value_high);\n\n                void MemoryBarrier(AtomicMemoryOrder order);\n                void StoreRoot(RootIndex root_index, TNode<Object> value);\n\n                Node* Projection(int index, Node* value);\n\n                // Allocation.\n                TNode<HeapObject> OptimizedAllocate(TNode<IntPtrT> size,\n                                                   AllocationType allocation);\n\n                // Exception handling.\n                void HandleException(Node* node);\n                bool IsExceptionHandlerActive() const;\n\n                // Runtime Calls.\n                Node* CallRuntimeImpl(Runtime::FunctionId function, TNode<Object> context,\n                                    std::initializer_list<TNode<Object>> args);\n                void TailCallRuntimeImpl(Runtime::FunctionId function, TNode<Int32T> arity,\n                                        TNode<Object> context,\n                                        std::initializer_list<TNode<Object>> args);\n\n                // Stub Calls.\n                Node* CallStubN(StubCallMode call_mode,\n                                const CallInterfaceDescriptor& descriptor, int input_count,\n                                Node* const* inputs);\n                void TailCallStubImpl(const CallInterfaceDescriptor& descriptor,\n                                      TNode<Code> target, TNode<Object> context,\n                                      std::initializer_list<Node*> args);\n                Node* CallStubRImpl(StubCallMode call_mode,\n                                    const CallInterfaceDescriptor& descriptor,\n                                    TNode<Object> target, TNode<Object> context,\n                                    std::initializer_list<Node*> args);\n                Node* CallJSStubImpl(const CallInterfaceDescriptor& descriptor,\n                                    TNode<Object> target, TNode<Object> context,\n                                    TNode<Object> function,\n                                    std::optional<TNode<Object>> new_target,\n                                    TNode<Int32T> arity,\n                                    std::optional<TNode<JSDispatchHandleT>> dispatch_handle,\n                                    std::initializer_list<Node*> args);\n                void TailCallStubThenBytecodeDispatchImpl(\n                    const CallInterfaceDescriptor& descriptor, Node* target, Node* context,\n                    std::initializer_list<Node*> args);\n                template <class... TArgs>\n                void TailCallBytecodeDispatch(const CallInterfaceDescriptor& descriptor,\n                                            TNode<RawPtrT> target, TArgs... args);\n                void TailCallJSCode(TNode<Code> code, TNode<Context> context,\n                                    TNode<JSFunction> function, TNode<Object> new_target,\n                                    TNode<Int32T> arg_count,\n                                    TNode<JSDispatchHandleT> dispatch_handle);\n\n                // C Calls.\n                Node* CallCFunctionN(Signature<MachineType>* signature, int input_count,\n                                    Node* const* inputs);\n                Node* CallCFunction(Node* function, std::optional<MachineType> return_type,\n                                    std::initializer_list<CFunctionArg> args);\n                Node* CallCFunctionWithoutFunctionDescriptor(\n                    Node* function, MachineType return_type,\n                    std::initializer_list<CFunctionArg> args);\n                Node* CallCFunctionWithCallerSavedRegisters(\n                    Node* function, MachineType return_type, SaveFPRegsMode mode,\n                    std::initializer_list<CFunctionArg> args);\n\n                // Control flow.\n                void Goto(Label* label);\n                void GotoIf(TNode<IntegralT> condition, Label* true_label,\n                            GotoHint goto_hint = GotoHint::kNone);\n                void GotoIfNot(TNode<IntegralT> condition, Label* false_label,\n                                GotoHint goto_hint = GotoHint::kNone);\n                void Branch(TNode<IntegralT> condition, Label* true_label,\n                            Label* false_label,\n                            BranchHint branch_hint = BranchHint::kNone);\n                void Branch(TNode<BoolT> condition,\n                            const std::function<void()>& true_body,\n                            const std::function<void()>& false_body);\n                void Branch(TNode<BoolT> condition, Label* true_label,\n                            const std::function<void()>& false_body);\n                void Branch(TNode<BoolT> condition,\n                            const std::function<void()>& true_body,\n                            Label* false_label);\n                void Switch(Node* index, Label* default_label, const int32_t* case_values,\n                            Label** case_labels, size_t case_count);\n\n                // Unaligned Access\n                bool UnalignedLoadSupported(MachineRepresentation rep) const;\n                bool UnalignedStoreSupported(MachineRepresentation rep) const;\n\n            #if V8_ENABLE_WEBASSEMBLY\n                TNode<RawPtrT> SwitchToTheCentralStack();\n                void SwitchFromTheCentralStack(TNode<RawPtrT> old_sp);\n                TNode<RawPtrT> SwitchToTheCentralStackIfNeeded();\n            #endif\n\n            private:\n                // Helper function for root handles.\n                void CanonicalizeEmbeddedBuiltinsConstantIfNeeded(Handle<HeapObject> object);\n\n                TNode<HeapObject> HeapConstantNoHole(Handle<HeapObject> object) {\n                    return UntypedHeapConstantNoHole(object);\n                }\n                TNode<HeapObject> HeapConstantMaybeHole(Handle<HeapObject> object) {\n                    return UntypedHeapConstantMaybeHole(object);\n                }\n                TNode<HeapObject> HeapConstantHole(Handle<HeapObject> object) {\n                    return UntypedHeapConstantHole(object);\n                }\n\n                CodeAssemblerState* state_;\n\n                template <class Type>\n                friend class TypedCodeAssemblerVariable;\n\n                friend class CodeAssemblerLabel;\n                friend class CodeAssemblerExceptionHandlerLabel;\n                friend class ScopedExceptionHandler;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"BreakOnNodeDecorator\",\n            \"extends\": \"GraphDecorator\",\n            \"about\": \"A GraphDecorator that triggers a debug break when a specific node is processed by the compiler.\",\n            \"attributes\": [\n                {\n                    \"name\": \"node_id_\",\n                    \"type\": \"NodeId\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The ID of the node on which to break.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Node\",\n                \"NodeId\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class BreakOnNodeDecorator final : public GraphDecorator {\n            public:\n                explicit BreakOnNodeDecorator(NodeId node_id) : node_id_(node_id) {}\n\n                void Decorate(Node* node) final {\n                    if (node->id() == node_id_) {\n                    base::OS::DebugBreak();\n                    }\n                }\n\n            private:\n                NodeId node_id_;\n            };\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CodeAssemblerVariable::Impl\",\n            \"about\": \"Implementation detail for CodeAssemblerVariable, managing its state.\",\n            \"attributes\": [\n                {\n                    \"name\": \"value_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The current value of the variable.\"\n                },\n                {\n                    \"name\": \"rep_\",\n                    \"type\": \"MachineRepresentation\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The machine representation of the variable.\"\n                },\n                {\n                    \"name\": \"var_id_\",\n                    \"type\": \"CodeAssemblerState::VariableId\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Unique identifier for the variable.\"\n                }\n            ],\n            \"dependencies\": [\n"
}