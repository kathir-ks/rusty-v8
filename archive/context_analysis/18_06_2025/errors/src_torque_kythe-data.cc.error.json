{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/torque/kythe-data.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/torque/kythe-data.cc\",\n            \"file_name\": \"kythe-data.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Provides functionality to generate Kythe data for Torque files, enabling code indexing and analysis.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes the header file for Kythe data structures and declarations specific to Torque.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/torque/kythe-data.h\"\n        ]]></code>\n    </imports>\n\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::internal::torque\",\n                \"purpose\": \"Encapsulates Torque-related code within the V8 namespace.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace torque {\n        ]]></code>\n    </namespace>\n\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"anonymous\",\n                \"purpose\": \"Contains a utility function for converting SourcePosition to KythePosition.\"\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nKythePosition MakeKythePosition(const SourcePosition& pos) {\n  KythePosition p;\n  if (pos.source.IsValid()) {\n    p.file_path = SourceFileMap::PathFromV8Root(pos.source);\n  } else {\n    p.file_path = \"UNKNOWN\";\n  }\n  p.start_offset = pos.start.offset;\n  p.end_offset = pos.end.offset;\n  return p;\n}\n\n}  // namespace\n        ]]></code>\n    </namespace>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"KytheData\",\n                \"about\": \"Provides methods to add definitions, uses, and calls to a KytheConsumer for Torque code elements.\",\n                \"attributes\": [],\n                \"dependencies\": [\n                    \"Value\",\n                    \"SourcePosition\",\n                    \"Callable\",\n                    \"Field\",\n                    \"Binding\",\n                    \"LocalValue\",\n                    \"LocalLabel\",\n                    \"Declarable\",\n                    \"KytheConsumer\",\n                    \"KythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n// Constants\nkythe_entity_t KytheData::AddConstantDefinition(const Value* constant) {\n  DCHECK(constant->IsNamespaceConstant() || constant->IsExternConstant());\n  KytheData* that = &KytheData::Get();\n  // Check if we know the constant already.\n  auto it = that->constants_.find(constant);\n  if (it != that->constants_.end()) return it->second;\n\n  // Register this constant.\n  KythePosition pos = MakeKythePosition(constant->name()->pos);\n  kythe_entity_t constant_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::Constant, constant->name()->value, pos);\n  that->constants_.insert(it, std::make_pair(constant, constant_id));\n  return constant_id;\n}\n\nvoid KytheData::AddConstantUse(SourcePosition use_position,\n                               const Value* constant) {\n  DCHECK(constant->IsNamespaceConstant() || constant->IsExternConstant());\n  KytheData* that = &Get();\n  kythe_entity_t constant_id = AddConstantDefinition(constant);\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::Constant, constant_id, use_pos);\n}\n\n// Callables\nkythe_entity_t KytheData::AddFunctionDefinition(Callable* callable) {\n  KytheData* that = &KytheData::Get();\n  // Check if we know the caller already.\n  auto it = that->callables_.find(callable);\n  if (it != that->callables_.end()) return it->second;\n\n  // Register this callable.\n  auto ident_pos = callable->IdentifierPosition();\n  kythe_entity_t callable_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::Function, callable->ExternalName(),\n      MakeKythePosition(ident_pos));\n  that->callables_.insert(it, std::make_pair(callable, callable_id));\n  return callable_id;\n}\n\nvoid KytheData::AddCall(Callable* caller, SourcePosition call_position,\n                        Callable* callee) {\n  if (!caller) return;  // Ignore those for now.\n  DCHECK_NOT_NULL(caller);\n  DCHECK_NOT_NULL(callee);\n  KytheData* that = &Get();\n  if (call_position.source.IsValid()) {\n    kythe_entity_t caller_id = AddFunctionDefinition(caller);\n    kythe_entity_t callee_id = AddFunctionDefinition(callee);\n\n    KythePosition call_pos = MakeKythePosition(call_position);\n    that->consumer_->AddCall(KytheConsumer::Kind::Function, caller_id, call_pos,\n                             callee_id);\n  }\n}\n\n// Class fields\nkythe_entity_t KytheData::AddClassFieldDefinition(const Field* field) {\n  DCHECK(field);\n  KytheData* that = &KytheData::Get();\n  // Check if we know that field already.\n  auto it = that->class_fields_.find(field);\n  if (it != that->class_fields_.end()) return it->second;\n  // Register this field.\n  KythePosition pos = MakeKythePosition(field->pos);\n  kythe_entity_t field_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::ClassField, field->name_and_type.name, pos);\n  that->class_fields_.insert(it, std::make_pair(field, field_id));\n  return field_id;\n}\n\nvoid KytheData::AddClassFieldUse(SourcePosition use_position,\n                                 const Field* field) {\n  DCHECK(field);\n  KytheData* that = &KytheData::Get();\n  kythe_entity_t field_id = AddClassFieldDefinition(field);\n\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::ClassField, field_id, use_pos);\n}\n\n// Bindings\nkythe_entity_t KytheData::AddBindingDefinition(Binding<LocalValue>* binding) {\n  CHECK(binding);\n  const uint64_t binding_index = binding->unique_index();\n  return AddBindingDefinitionImpl(binding_index, binding->name(),\n                                  binding->declaration_position());\n}\n\nkythe_entity_t KytheData::AddBindingDefinition(Binding<LocalLabel>* binding) {\n  CHECK(binding);\n  const uint64_t binding_index = binding->unique_index();\n  return AddBindingDefinitionImpl(binding_index, binding->name(),\n                                  binding->declaration_position());\n}\n\nkythe_entity_t KytheData::AddBindingDefinitionImpl(\n    uint64_t binding_index, const std::string& name,\n    const SourcePosition& ident_pos) {\n  KytheData* that = &KytheData::Get();\n  // Check if we know the binding already.\n  auto it = that->local_bindings_.find(binding_index);\n  if (it != that->local_bindings_.end()) return it->second;\n  // Register this binding.\n  kythe_entity_t binding_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::Variable, name, MakeKythePosition(ident_pos));\n  that->local_bindings_.insert(it, std::make_pair(binding_index, binding_id));\n  return binding_id;\n}\n\nvoid KytheData::AddBindingUse(SourcePosition use_position,\n                              Binding<LocalValue>* binding) {\n  CHECK(binding);\n  KytheData* that = &KytheData::Get();\n  kythe_entity_t binding_id = AddBindingDefinition(binding);\n\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::Variable, binding_id, use_pos);\n}\n\nvoid KytheData::AddBindingUse(SourcePosition use_position,\n                              Binding<LocalLabel>* binding) {\n  CHECK(binding);\n  KytheData* that = &KytheData::Get();\n  kythe_entity_t binding_id = AddBindingDefinition(binding);\n\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::Variable, binding_id, use_pos);\n}\n\n// Types\nkythe_entity_t KytheData::AddTypeDefinition(const Declarable* type_decl) {\n  CHECK(type_decl);\n  KytheData* that = &KytheData::Get();\n  // Check if we know that type already.\n  auto it = that->types_.find(type_decl);\n  if (it != that->types_.end()) return it->second;\n  // Register this type.\n  KythePosition pos = MakeKythePosition(type_decl->IdentifierPosition());\n  kythe_entity_t type_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::Type, type_decl->type_name(), pos);\n  that->types_.insert(it, std::make_pair(type_decl, type_id));\n  return type_id;\n}\n\nvoid KytheData::AddTypeUse(SourcePosition use_position,\n                           const Declarable* type_decl) {\n  CHECK(type_decl);\n  KytheData* that = &KytheData::Get();\n  kythe_entity_t type_id = AddTypeDefinition(type_decl);\n\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::Type, type_id, use_pos);\n}\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"MakeKythePosition\",\n                \"about\": \"Converts a SourcePosition to a KythePosition.\",\n                \"logic\": \"If the source file is valid, it extracts the file path using SourceFileMap::PathFromV8Root. Otherwise, it sets the file path to 'UNKNOWN'. It then copies the start and end offsets.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"pos\",\n                        \"type\": \"const SourcePosition&\",\n                        \"purpose\": \"The source position to convert.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"KythePosition\",\n                    \"description\": \"The equivalent KythePosition.\"\n                },\n                \"dependencies\": [\n                    \"SourcePosition\",\n                    \"KythePosition\",\n                    \"SourceFileMap\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nKythePosition MakeKythePosition(const SourcePosition& pos) {\n  KythePosition p;\n  if (pos.source.IsValid()) {\n    p.file_path = SourceFileMap::PathFromV8Root(pos.source);\n  } else {\n    p.file_path = \"UNKNOWN\";\n  }\n  p.start_offset = pos.start.offset;\n  p.end_offset = pos.end.offset;\n  return p;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddConstantDefinition\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a constant definition to the Kythe data.\",\n                \"logic\": \"Checks if the constant is a namespace or extern constant. If already defined, returns the existing ID. Otherwise, it creates a new definition using the KytheConsumer and stores the mapping.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"constant\",\n                        \"type\": \"const Value*\",\n                        \"purpose\": \"The constant to define.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"kythe_entity_t\",\n                    \"description\": \"The Kythe entity ID of the constant.\"\n                },\n                \"dependencies\": [\n                    \"Value\",\n                    \"KythePosition\",\n                    \"KytheConsumer\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nkythe_entity_t KytheData::AddConstantDefinition(const Value* constant) {\n  DCHECK(constant->IsNamespaceConstant() || constant->IsExternConstant());\n  KytheData* that = &KytheData::Get();\n  // Check if we know the constant already.\n  auto it = that->constants_.find(constant);\n  if (it != that->constants_.end()) return it->second;\n\n  // Register this constant.\n  KythePosition pos = MakeKythePosition(constant->name()->pos);\n  kythe_entity_t constant_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::Constant, constant->name()->value, pos);\n  that->constants_.insert(it, std::make_pair(constant, constant_id));\n  return constant_id;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddConstantUse\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a constant use to the Kythe data.\",\n                \"logic\": \"Adds a constant definition if one doesn't already exist, then creates a use entry in the KytheConsumer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"use_position\",\n                        \"type\": \"SourcePosition\",\n                        \"purpose\": \"The location where the constant is used.\"\n                    },\n                    {\n                        \"name\": \"constant\",\n                        \"type\": \"const Value*\",\n                        \"purpose\": \"The constant being used.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Value\",\n                    \"KythePosition\",\n                    \"KytheConsumer\",\n                    \"AddConstantDefinition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid KytheData::AddConstantUse(SourcePosition use_position,\n                               const Value* constant) {\n  DCHECK(constant->IsNamespaceConstant() || constant->IsExternConstant());\n  KytheData* that = &Get();\n  kythe_entity_t constant_id = AddConstantDefinition(constant);\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::Constant, constant_id, use_pos);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddFunctionDefinition\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a function definition to the Kythe data.\",\n                \"logic\": \"Checks if the callable is already defined. If not, it adds a definition using the KytheConsumer and stores the mapping.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"callable\",\n                        \"type\": \"Callable*\",\n                        \"purpose\": \"The callable to define.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"kythe_entity_t\",\n                    \"description\": \"The Kythe entity ID of the callable.\"\n                },\n                \"dependencies\": [\n                    \"Callable\",\n                    \"KytheConsumer\",\n                    \"KythePosition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nkythe_entity_t KytheData::AddFunctionDefinition(Callable* callable) {\n  KytheData* that = &KytheData::Get();\n  // Check if we know the caller already.\n  auto it = that->callables_.find(callable);\n  if (it != that->callables_.end()) return it->second;\n\n  // Register this callable.\n  auto ident_pos = callable->IdentifierPosition();\n  kythe_entity_t callable_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::Function, callable->ExternalName(),\n      MakeKythePosition(ident_pos));\n  that->callables_.insert(it, std::make_pair(callable, callable_id));\n  return callable_id;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddCall\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a call relationship between two callables to the Kythe data.\",\n                \"logic\": \"Adds the caller and callee definitions if they don't already exist, then creates a call edge in the KytheConsumer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"caller\",\n                        \"type\": \"Callable*\",\n                        \"purpose\": \"The callable making the call.\"\n                    },\n                    {\n                        \"name\": \"call_position\",\n                        \"type\": \"SourcePosition\",\n                        \"purpose\": \"The location of the call.\"\n                    },\n                    {\n                        \"name\": \"callee\",\n                        \"type\": \"Callable*\",\n                        \"purpose\": \"The callable being called.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Callable\",\n                    \"KytheConsumer\",\n                    \"KythePosition\",\n                    \"AddFunctionDefinition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid KytheData::AddCall(Callable* caller, SourcePosition call_position,\n                        Callable* callee) {\n  if (!caller) return;  // Ignore those for now.\n  DCHECK_NOT_NULL(caller);\n  DCHECK_NOT_NULL(callee);\n  KytheData* that = &Get();\n  if (call_position.source.IsValid()) {\n    kythe_entity_t caller_id = AddFunctionDefinition(caller);\n    kythe_entity_t callee_id = AddFunctionDefinition(callee);\n\n    KythePosition call_pos = MakeKythePosition(call_position);\n    that->consumer_->AddCall(KytheConsumer::Kind::Function, caller_id, call_pos,\n                             callee_id);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddClassFieldDefinition\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a class field definition to the Kythe data.\",\n                \"logic\": \"Checks if the field is already defined. If not, it adds a definition using the KytheConsumer and stores the mapping.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"field\",\n                        \"type\": \"const Field*\",\n                        \"purpose\": \"The field to define.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"kythe_entity_t\",\n                    \"description\": \"The Kythe entity ID of the field.\"\n                },\n                \"dependencies\": [\n                    \"Field\",\n                    \"KytheConsumer\",\n                    \"KythePosition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nkythe_entity_t KytheData::AddClassFieldDefinition(const Field* field) {\n  DCHECK(field);\n  KytheData* that = &KytheData::Get();\n  // Check if we know that field already.\n  auto it = that->class_fields_.find(field);\n  if (it != that->class_fields_.end()) return it->second;\n  // Register this field.\n  KythePosition pos = MakeKythePosition(field->pos);\n  kythe_entity_t field_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::ClassField, field->name_and_type.name, pos);\n  that->class_fields_.insert(it, std::make_pair(field, field_id));\n  return field_id;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddClassFieldUse\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a class field use to the Kythe data.\",\n                \"logic\": \"Adds the field definition if it doesn't already exist and then creates a use entry in the KytheConsumer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"use_position\",\n                        \"type\": \"SourcePosition\",\n                        \"purpose\": \"The location where the field is used.\"\n                    },\n                    {\n                        \"name\": \"field\",\n                        \"type\": \"const Field*\",\n                        \"purpose\": \"The field being used.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Field\",\n                    \"KytheConsumer\",\n                    \"KythePosition\",\n                    \"AddClassFieldDefinition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid KytheData::AddClassFieldUse(SourcePosition use_position,\n                                 const Field* field) {\n  DCHECK(field);\n  KytheData* that = &KytheData::Get();\n  kythe_entity_t field_id = AddClassFieldDefinition(field);\n\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::ClassField, field_id, use_pos);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddBindingDefinition\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a binding definition for a LocalValue to the Kythe data.\",\n                \"logic\": \"Extracts the unique index and delegates to AddBindingDefinitionImpl to create the Kythe definition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"binding\",\n                        \"type\": \"Binding<LocalValue>*\",\n                        \"purpose\": \"The binding to define.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"kythe_entity_t\",\n                    \"description\": \"The Kythe entity ID of the binding.\"\n                },\n                \"dependencies\": [\n                    \"Binding\",\n                    \"LocalValue\",\n                    \"AddBindingDefinitionImpl\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nkythe_entity_t KytheData::AddBindingDefinition(Binding<LocalValue>* binding) {\n  CHECK(binding);\n  const uint64_t binding_index = binding->unique_index();\n  return AddBindingDefinitionImpl(binding_index, binding->name(),\n                                  binding->declaration_position());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddBindingDefinition\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a binding definition for a LocalLabel to the Kythe data.\",\n                \"logic\": \"Extracts the unique index and delegates to AddBindingDefinitionImpl to create the Kythe definition.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"binding\",\n                        \"type\": \"Binding<LocalLabel>*\",\n                        \"purpose\": \"The binding to define.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"kythe_entity_t\",\n                    \"description\": \"The Kythe entity ID of the binding.\"\n                },\n                \"dependencies\": [\n                    \"Binding\",\n                    \"LocalLabel\",\n                    \"AddBindingDefinitionImpl\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nkythe_entity_t KytheData::AddBindingDefinition(Binding<LocalLabel>* binding) {\n  CHECK(binding);\n  const uint64_t binding_index = binding->unique_index();\n  return AddBindingDefinitionImpl(binding_index, binding->name(),\n                                  binding->declaration_position());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddBindingDefinitionImpl\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a binding definition to the Kythe data (implementation).\",\n                \"logic\": \"Checks if the binding is already defined. If not, it adds a definition using the KytheConsumer and stores the mapping.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"binding_index\",\n                        \"type\": \"uint64_t\",\n                        \"purpose\": \"Unique identifier for the binding.\"\n                    },\n                    {\n                        \"name\": \"name\",\n                        \"type\": \"const std::string&\",\n                        \"purpose\": \"The name of the binding.\"\n                    },\n                    {\n                        \"name\": \"ident_pos\",\n                        \"type\": \"const SourcePosition&\",\n                        \"purpose\": \"The position of the binding's identifier.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"kythe_entity_t\",\n                    \"description\": \"The Kythe entity ID of the binding.\"\n                },\n                \"dependencies\": [\n                    \"KytheConsumer\",\n                    \"KythePosition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nkythe_entity_t KytheData::AddBindingDefinitionImpl(\n    uint64_t binding_index, const std::string& name,\n    const SourcePosition& ident_pos) {\n  KytheData* that = &KytheData::Get();\n  // Check if we know the binding already.\n  auto it = that->local_bindings_.find(binding_index);\n  if (it != that->local_bindings_.end()) return it->second;\n  // Register this binding.\n  kythe_entity_t binding_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::Variable, name, MakeKythePosition(ident_pos));\n  that->local_bindings_.insert(it, std::make_pair(binding_index, binding_id));\n  return binding_id;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddBindingUse\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a binding use for a LocalValue to the Kythe data.\",\n                \"logic\": \"Adds the binding definition if it doesn't already exist and then creates a use entry in the KytheConsumer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"use_position\",\n                        \"type\": \"SourcePosition\",\n                        \"purpose\": \"The location where the binding is used.\"\n                    },\n                    {\n                        \"name\": \"binding\",\n                        \"type\": \"Binding<LocalValue>*\",\n                        \"purpose\": \"The binding being used.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Binding\",\n                    \"LocalValue\",\n                    \"KytheConsumer\",\n                    \"KythePosition\",\n                    \"AddBindingDefinition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid KytheData::AddBindingUse(SourcePosition use_position,\n                              Binding<LocalValue>* binding) {\n  CHECK(binding);\n  KytheData* that = &KytheData::Get();\n  kythe_entity_t binding_id = AddBindingDefinition(binding);\n\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::Variable, binding_id, use_pos);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddBindingUse\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a binding use for a LocalLabel to the Kythe data.\",\n                \"logic\": \"Adds the binding definition if it doesn't already exist and then creates a use entry in the KytheConsumer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"use_position\",\n                        \"type\": \"SourcePosition\",\n                        \"purpose\": \"The location where the binding is used.\"\n                    },\n                    {\n                        \"name\": \"binding\",\n                        \"type\": \"Binding<LocalLabel>*\",\n                        \"purpose\": \"The binding being used.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Binding\",\n                    \"LocalLabel\",\n                    \"KytheConsumer\",\n                    \"KythePosition\",\n                    \"AddBindingDefinition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid KytheData::AddBindingUse(SourcePosition use_position,\n                              Binding<LocalLabel>* binding) {\n  CHECK(binding);\n  KytheData* that = &KytheData::Get();\n  kythe_entity_t binding_id = AddBindingDefinition(binding);\n\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::Variable, binding_id, use_pos);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddTypeDefinition\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a type definition to the Kythe data.\",\n                \"logic\": \"Checks if the type is already defined. If not, it adds a definition using the KytheConsumer and stores the mapping.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"type_decl\",\n                        \"type\": \"const Declarable*\",\n                        \"purpose\": \"The type declaration to define.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"kythe_entity_t\",\n                    \"description\": \"The Kythe entity ID of the type.\"\n                },\n                \"dependencies\": [\n                    \"Declarable\",\n                    \"KytheConsumer\",\n                    \"KythePosition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nkythe_entity_t KytheData::AddTypeDefinition(const Declarable* type_decl) {\n  CHECK(type_decl);\n  KytheData* that = &KytheData::Get();\n  // Check if we know that type already.\n  auto it = that->types_.find(type_decl);\n  if (it != that->types_.end()) return it->second;\n  // Register this type.\n  KythePosition pos = MakeKythePosition(type_decl->IdentifierPosition());\n  kythe_entity_t type_id = that->consumer_->AddDefinition(\n      KytheConsumer::Kind::Type, type_decl->type_name(), pos);\n  that->types_.insert(it, std::make_pair(type_decl, type_id));\n  return type_id;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"AddTypeUse\",\n                \"parent\": \"KytheData\",\n                \"about\": \"Adds a type use to the Kythe data.\",\n                \"logic\": \"Adds the type definition if it doesn't already exist and then creates a use entry in the KytheConsumer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"use_position\",\n                        \"type\": \"SourcePosition\",\n                        \"purpose\": \"The location where the type is used.\"\n                    },\n                    {\n                        \"name\": \"type_decl\",\n                        \"type\": \"const Declarable*\",\n                        \"purpose\": \"The type declaration being used.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Declarable\",\n                    \"KytheConsumer\",\n                    \"KythePosition\",\n                    \"AddTypeDefinition\",\n                    \"MakeKythePosition\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nvoid KytheData::AddTypeUse(SourcePosition use_position,\n                           const Declarable* type_decl) {\n  CHECK(type_decl);\n  KytheData* that = &KytheData::Get();\n  kythe_entity_t type_id = AddTypeDefinition(type_decl);\n\n  KythePosition use_pos = MakeKythePosition(use_position);\n  that->consumer_->AddUse(KytheConsumer::Kind::Type, type_id, use_pos);\n}\n        ]]></code>\n    </func>\n\n    <namespace>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"name\": \"v8::internal::torque\",\n                \"purpose\": \"Closes the v8::internal::torque namespace.\"\n            }\n        </metadata>\n        <code><![CDATA[\n}  // namespace torque\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </namespace>\n\n    <dependencies>\n        <class>\n            <metadata>\n"
}