{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-operator-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-operator-reducer.cc\",\n            \"file_name\": \"simplified-operator-reducer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Reduces simplified operators in the V8 compiler graph to simpler forms based on constant folding and other optimizations.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for compiler, graph, heap broker, machine operator, node matchers, opcodes, operator properties, simplified operator and number conversions.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/simplified-operator-reducer.h\"\n\n#include <optional>\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/js-graph.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/simplified-operator.h\"\n#include \"src/numbers/conversions-inl.h\"\n        ]]></code>\n    </imports>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DecideObjectIsSmi\",\n                \"about\": \"Determines if a given node represents a Smi (small integer) value.\",\n                \"logic\": \"Uses NumberMatcher to check if the input node has a resolved Smi value, or if it's produced by certain operations like ChangeInt31ToTaggedSigned.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"input\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Decision\",\n                    \"description\": \"kTrue if the object is definitely a Smi, kFalse if it's definitely not a Smi, kUnknown otherwise.\"\n                },\n                \"dependencies\": [\n                    \"NumberMatcher\",\n                    \"IsSmiDouble\",\n                    \"Decision\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nDecision DecideObjectIsSmi(Node* const input) {\n  NumberMatcher m(input);\n  if (m.HasResolvedValue()) {\n    return IsSmiDouble(m.ResolvedValue()) ? Decision::kTrue : Decision::kFalse;\n  }\n  if (m.IsAllocate()) return Decision::kFalse;\n  if (m.IsChangeBitToTagged()) return Decision::kFalse;\n  if (m.IsChangeInt31ToTaggedSigned()) return Decision::kTrue;\n  if (m.IsHeapConstant()) return Decision::kFalse;\n  return Decision::kUnknown;\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"SimplifiedOperatorReducer\",\n                \"about\": \"Reduces simplified operators in the compiler graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"jsgraph_\",\n                        \"type\": \"JSGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Provides access to the JavaScript graph.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Provides access to the JavaScript heap broker.\"\n                    },\n                    {\n                        \"name\": \"branch_semantics_\",\n                        \"type\": \"BranchSemantics\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Specifies the branch semantics (JS or speculative).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"JSGraph\",\n                    \"JSHeapBroker\",\n                    \"BranchSemantics\",\n                    \"Reduction\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nSimplifiedOperatorReducer::SimplifiedOperatorReducer(\n    Editor* editor, JSGraph* jsgraph, JSHeapBroker* broker,\n    BranchSemantics branch_semantics)\n    : AdvancedReducer(editor),\n      jsgraph_(jsgraph),\n      broker_(broker),\n      branch_semantics_(branch_semantics) {}\n\nSimplifiedOperatorReducer::~SimplifiedOperatorReducer() = default;\n\n\nReduction SimplifiedOperatorReducer::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kBooleanNot: {\n      HeapObjectMatcher m(node->InputAt(0));\n      if (m.Is(factory()->true_value())) return ReplaceBoolean(false);\n      if (m.Is(factory()->false_value())) return ReplaceBoolean(true);\n      if (m.IsBooleanNot()) return Replace(m.InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeBitToTagged: {\n      Int32Matcher m(node->InputAt(0));\n      if (m.Is(0)) return Replace(jsgraph()->FalseConstant());\n      if (m.Is(1)) return Replace(jsgraph()->TrueConstant());\n      if (m.IsChangeTaggedToBit()) return Replace(m.InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeTaggedToBit: {\n      HeapObjectMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue()) {\n        std::optional<bool> maybe_result =\n            m.Ref(broker()).TryGetBooleanValue(broker());\n        if (maybe_result.has_value()) return ReplaceInt32(*maybe_result);\n      }\n      if (m.IsChangeBitToTagged()) return Replace(m.InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeFloat64ToTagged: {\n      Float64Matcher m(node->InputAt(0));\n      if (m.HasResolvedValue()) return ReplaceNumber(m.ResolvedValue());\n      if (m.IsChangeTaggedToFloat64()) return Replace(m.node()->InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeInt31ToTaggedSigned:\n    case IrOpcode::kChangeInt32ToTagged: {\n      Int32Matcher m(node->InputAt(0));\n      if (m.HasResolvedValue()) return ReplaceNumber(m.ResolvedValue());\n      if (m.IsChangeTaggedSignedToInt32()) {\n        return Replace(m.InputAt(0));\n      }\n      break;\n    }\n    case IrOpcode::kChangeTaggedToFloat64:\n    case IrOpcode::kTruncateTaggedToFloat64: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue()) return ReplaceFloat64(m.ResolvedValue());\n      if (m.IsChangeFloat64ToTagged() || m.IsChangeFloat64ToTaggedPointer()) {\n        return Replace(m.node()->InputAt(0));\n      }\n      if (m.IsChangeInt31ToTaggedSigned() || m.IsChangeInt32ToTagged()) {\n        return Change(node, machine()->ChangeInt32ToFloat64(), m.InputAt(0));\n      }\n      if (m.IsChangeUint32ToTagged()) {\n        return Change(node, machine()->ChangeUint32ToFloat64(), m.InputAt(0));\n      }\n      break;\n    }\n    case IrOpcode::kChangeTaggedSignedToInt32:\n    case IrOpcode::kChangeTaggedToInt32: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceInt32(DoubleToInt32(m.ResolvedValue()));\n      if (m.IsChangeFloat64ToTagged() || m.IsChangeFloat64ToTaggedPointer()) {\n        return Change(node, machine()->ChangeFloat64ToInt32(), m.InputAt(0));\n      }\n      if (m.IsChangeInt31ToTaggedSigned() || m.IsChangeInt32ToTagged()) {\n        return Replace(m.InputAt(0));\n      }\n      break;\n    }\n    case IrOpcode::kChangeTaggedToUint32: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceUint32(DoubleToUint32(m.ResolvedValue()));\n      if (m.IsChangeFloat64ToTagged() || m.IsChangeFloat64ToTaggedPointer()) {\n        return Change(node, machine()->ChangeFloat64ToUint32(), m.InputAt(0));\n      }\n      if (m.IsChangeUint32ToTagged()) return Replace(m.InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeUint32ToTagged: {\n      Uint32Matcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceNumber(FastUI2D(m.ResolvedValue()));\n      break;\n    }\n    case IrOpcode::kTruncateTaggedToWord32: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceInt32(DoubleToInt32(m.ResolvedValue()));\n      if (m.IsChangeInt31ToTaggedSigned() || m.IsChangeInt32ToTagged() ||\n          m.IsChangeUint32ToTagged()) {\n        return Replace(m.InputAt(0));\n      }\n      if (m.IsChangeFloat64ToTagged() || m.IsChangeFloat64ToTaggedPointer()) {\n        return Change(node, machine()->TruncateFloat64ToWord32(), m.InputAt(0));\n      }\n      break;\n    }\n    case IrOpcode::kCheckedFloat64ToInt32: {\n      Float64Matcher m(node->InputAt(0));\n      if (m.HasResolvedValue() && IsInt32Double(m.ResolvedValue())) {\n        Node* value =\n            jsgraph()->Int32Constant(static_cast<int32_t>(m.ResolvedValue()));\n        ReplaceWithValue(node, value);\n        return Replace(value);\n      }\n      break;\n    }\n    case IrOpcode::kCheckedTaggedToArrayIndex:\n    case IrOpcode::kCheckedTaggedToInt32:\n    case IrOpcode::kCheckedTaggedSignedToInt32: {\n      NodeMatcher m(node->InputAt(0));\n      if (m.IsConvertTaggedHoleToUndefined()) {\n        node->ReplaceInput(0, m.InputAt(0));\n        return Changed(node);\n      }\n      break;\n    }\n    case IrOpcode::kCheckIf: {\n      HeapObjectMatcher m(node->InputAt(0));\n      if (m.Is(factory()->true_value())) {\n        Node* const effect = NodeProperties::GetEffectInput(node);\n        return Replace(effect);\n      }\n      break;\n    }\n    case IrOpcode::kCheckNumberFitsInt32:\n    case IrOpcode::kCheckNumber: {\n      NodeMatcher m(node->InputAt(0));\n      if (m.IsConvertTaggedHoleToUndefined()) {\n        node->ReplaceInput(0, m.InputAt(0));\n        return Changed(node);\n      }\n      break;\n    }\n    case IrOpcode::kCheckHeapObject: {\n      Node* const input = node->InputAt(0);\n      if (DecideObjectIsSmi(input) == Decision::kFalse) {\n        ReplaceWithValue(node, input);\n        return Replace(input);\n      }\n      NodeMatcher m(input);\n      if (m.IsCheckHeapObject()) {\n        ReplaceWithValue(node, input);\n        return Replace(input);\n      }\n      break;\n    }\n    case IrOpcode::kCheckSmi: {\n      Node* const input = node->InputAt(0);\n      if (DecideObjectIsSmi(input) == Decision::kTrue) {\n        ReplaceWithValue(node, input);\n        return Replace(input);\n      }\n      NodeMatcher m(input);\n      if (m.IsCheckSmi()) {\n        ReplaceWithValue(node, input);\n        return Replace(input);\n      } else if (m.IsConvertTaggedHoleToUndefined()) {\n        node->ReplaceInput(0, m.InputAt(0));\n        return Changed(node);\n      }\n      break;\n    }\n    case IrOpcode::kObjectIsSmi: {\n      Node* const input = node->InputAt(0);\n      switch (DecideObjectIsSmi(input)) {\n        case Decision::kTrue:\n          return ReplaceBoolean(true);\n        case Decision::kFalse:\n          return ReplaceBoolean(false);\n        case Decision::kUnknown:\n          break;\n      }\n      break;\n    }\n    case IrOpcode::kNumberAbs: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceNumber(std::fabs(m.ResolvedValue()));\n      break;\n    }\n    case IrOpcode::kReferenceEqual: {\n      HeapObjectBinopMatcher m(node);\n      if (m.left().node() == m.right().node()) return ReplaceBoolean(true);\n      break;\n    }\n    case IrOpcode::kCheckedInt32Add: {\n      // (x + a) + b => x + (a + b) where a and b are constants and have the\n      // same sign.\n      Int32BinopMatcher m(node);\n      if (m.right().HasResolvedValue()) {\n        Node* checked_int32_add = m.left().node();\n        if (checked_int32_add->opcode() == IrOpcode::kCheckedInt32Add) {\n          Int32BinopMatcher n(checked_int32_add);\n          if (n.right().HasResolvedValue() &&\n              (n.right().ResolvedValue() >= 0) ==\n                  (m.right().ResolvedValue() >= 0)) {\n            int32_t val;\n            bool overflow = base::bits::SignedAddOverflow32(\n                n.right().ResolvedValue(), m.right().ResolvedValue(), &val);\n            if (!overflow) {\n              bool has_no_other_uses = true;\n              for (Edge edge : checked_int32_add->use_edges()) {\n                if (!edge.from()->IsDead() && edge.from() != node) {\n                  has_no_other_uses = false;\n                  break;\n                }\n              }\n              if (has_no_other_uses) {\n                node->ReplaceInput(0, n.left().node());\n                node->ReplaceInput(1, jsgraph()->Int32Constant(val));\n                RelaxEffectsAndControls(checked_int32_add);\n                checked_int32_add->Kill();\n                return Changed(node);\n              }\n            }\n          }\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  return NoChange();\n}\n\nReduction SimplifiedOperatorReducer::Change(Node* node, const Operator* op,\n                                            Node* a) {\n  DCHECK_EQ(node->InputCount(), OperatorProperties::GetTotalInputCount(op));\n  DCHECK_LE(1, node->InputCount());\n  node->ReplaceInput(0, a);\n  NodeProperties::ChangeOp(node, op);\n  return Changed(node);\n}\n\nReduction SimplifiedOperatorReducer::ReplaceBoolean(bool value) {\n  if (branch_semantics_ == BranchSemantics::kJS) {\n    return Replace(jsgraph()->BooleanConstant(value));\n  } else {\n    return ReplaceInt32(value);\n  }\n}\n\nReduction SimplifiedOperatorReducer::ReplaceFloat64(double value) {\n  return Replace(jsgraph()->Float64Constant(value));\n}\n\n\nReduction SimplifiedOperatorReducer::ReplaceInt32(int32_t value) {\n  return Replace(jsgraph()->Int32Constant(value));\n}\n\n\nReduction SimplifiedOperatorReducer::ReplaceNumber(double value) {\n  return Replace(jsgraph()->ConstantNoHole(value));\n}\n\n\nReduction SimplifiedOperatorReducer::ReplaceNumber(int32_t value) {\n  return Replace(jsgraph()->ConstantNoHole(value));\n}\n\nFactory* SimplifiedOperatorReducer::factory() const {\n  return jsgraph()->isolate()->factory();\n}\n\nTFGraph* SimplifiedOperatorReducer::graph() const { return jsgraph()->graph(); }\n\nMachineOperatorBuilder* SimplifiedOperatorReducer::machine() const {\n  return jsgraph()->machine();\n}\n\nSimplifiedOperatorBuilder* SimplifiedOperatorReducer::simplified() const {\n  return jsgraph()->simplified();\n}\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reduce\",\n                \"parent\": \"SimplifiedOperatorReducer\",\n                \"about\": \"Reduces a given node based on its opcode.\",\n                \"logic\": \"Uses a switch statement to handle different opcodes. Each case attempts to simplify the node using pattern matching and constant folding.  Many cases involve checking the input type via NodeMatchers and replacing node with constant if possible.  Some cases change the opcode of the node using Change().\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction (NoChange, Replace, Changed).\"\n                },\n                \"dependencies\": [\n                    \"HeapObjectMatcher\",\n                    \"Int32Matcher\",\n                    \"Float64Matcher\",\n                    \"NumberMatcher\",\n                    \"Uint32Matcher\",\n                    \"NodeMatcher\",\n                    \"ReplaceBoolean\",\n                    \"ReplaceNumber\",\n                    \"ReplaceInt32\",\n                    \"ReplaceFloat64\",\n                    \"Change\",\n                    \"factory\",\n                    \"jsgraph\",\n                    \"machine\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction SimplifiedOperatorReducer::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kBooleanNot: {\n      HeapObjectMatcher m(node->InputAt(0));\n      if (m.Is(factory()->true_value())) return ReplaceBoolean(false);\n      if (m.Is(factory()->false_value())) return ReplaceBoolean(true);\n      if (m.IsBooleanNot()) return Replace(m.InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeBitToTagged: {\n      Int32Matcher m(node->InputAt(0));\n      if (m.Is(0)) return Replace(jsgraph()->FalseConstant());\n      if (m.Is(1)) return Replace(jsgraph()->TrueConstant());\n      if (m.IsChangeTaggedToBit()) return Replace(m.InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeTaggedToBit: {\n      HeapObjectMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue()) {\n        std::optional<bool> maybe_result =\n            m.Ref(broker()).TryGetBooleanValue(broker());\n        if (maybe_result.has_value()) return ReplaceInt32(*maybe_result);\n      }\n      if (m.IsChangeBitToTagged()) return Replace(m.InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeFloat64ToTagged: {\n      Float64Matcher m(node->InputAt(0));\n      if (m.HasResolvedValue()) return ReplaceNumber(m.ResolvedValue());\n      if (m.IsChangeTaggedToFloat64()) return Replace(m.node()->InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeInt31ToTaggedSigned:\n    case IrOpcode::kChangeInt32ToTagged: {\n      Int32Matcher m(node->InputAt(0));\n      if (m.HasResolvedValue()) return ReplaceNumber(m.ResolvedValue());\n      if (m.IsChangeTaggedSignedToInt32()) {\n        return Replace(m.InputAt(0));\n      }\n      break;\n    }\n    case IrOpcode::kChangeTaggedToFloat64:\n    case IrOpcode::kTruncateTaggedToFloat64: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue()) return ReplaceFloat64(m.ResolvedValue());\n      if (m.IsChangeFloat64ToTagged() || m.IsChangeFloat64ToTaggedPointer()) {\n        return Replace(m.node()->InputAt(0));\n      }\n      if (m.IsChangeInt31ToTaggedSigned() || m.IsChangeInt32ToTagged()) {\n        return Change(node, machine()->ChangeInt32ToFloat64(), m.InputAt(0));\n      }\n      if (m.IsChangeUint32ToTagged()) {\n        return Change(node, machine()->ChangeUint32ToFloat64(), m.InputAt(0));\n      }\n      break;\n    }\n    case IrOpcode::kChangeTaggedSignedToInt32:\n    case IrOpcode::kChangeTaggedToInt32: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceInt32(DoubleToInt32(m.ResolvedValue()));\n      if (m.IsChangeFloat64ToTagged() || m.IsChangeFloat64ToTaggedPointer()) {\n        return Change(node, machine()->ChangeFloat64ToInt32(), m.InputAt(0));\n      }\n      if (m.IsChangeInt31ToTaggedSigned() || m.IsChangeInt32ToTagged()) {\n        return Replace(m.InputAt(0));\n      }\n      break;\n    }\n    case IrOpcode::kChangeTaggedToUint32: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceUint32(DoubleToUint32(m.ResolvedValue()));\n      if (m.IsChangeFloat64ToTagged() || m.IsChangeFloat64ToTaggedPointer()) {\n        return Change(node, machine()->ChangeFloat64ToUint32(), m.InputAt(0));\n      }\n      if (m.IsChangeUint32ToTagged()) return Replace(m.InputAt(0));\n      break;\n    }\n    case IrOpcode::kChangeUint32ToTagged: {\n      Uint32Matcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceNumber(FastUI2D(m.ResolvedValue()));\n      break;\n    }\n    case IrOpcode::kTruncateTaggedToWord32: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceInt32(DoubleToInt32(m.ResolvedValue()));\n      if (m.IsChangeInt31ToTaggedSigned() || m.IsChangeInt32ToTagged() ||\n          m.IsChangeUint32ToTagged()) {\n        return Replace(m.InputAt(0));\n      }\n      if (m.IsChangeFloat64ToTagged() || m.IsChangeFloat64ToTaggedPointer()) {\n        return Change(node, machine()->TruncateFloat64ToWord32(), m.InputAt(0));\n      }\n      break;\n    }\n    case IrOpcode::kCheckedFloat64ToInt32: {\n      Float64Matcher m(node->InputAt(0));\n      if (m.HasResolvedValue() && IsInt32Double(m.ResolvedValue())) {\n        Node* value =\n            jsgraph()->Int32Constant(static_cast<int32_t>(m.ResolvedValue()));\n        ReplaceWithValue(node, value);\n        return Replace(value);\n      }\n      break;\n    }\n    case IrOpcode::kCheckedTaggedToArrayIndex:\n    case IrOpcode::kCheckedTaggedToInt32:\n    case IrOpcode::kCheckedTaggedSignedToInt32: {\n      NodeMatcher m(node->InputAt(0));\n      if (m.IsConvertTaggedHoleToUndefined()) {\n        node->ReplaceInput(0, m.InputAt(0));\n        return Changed(node);\n      }\n      break;\n    }\n    case IrOpcode::kCheckIf: {\n      HeapObjectMatcher m(node->InputAt(0));\n      if (m.Is(factory()->true_value())) {\n        Node* const effect = NodeProperties::GetEffectInput(node);\n        return Replace(effect);\n      }\n      break;\n    }\n    case IrOpcode::kCheckNumberFitsInt32:\n    case IrOpcode::kCheckNumber: {\n      NodeMatcher m(node->InputAt(0));\n      if (m.IsConvertTaggedHoleToUndefined()) {\n        node->ReplaceInput(0, m.InputAt(0));\n        return Changed(node);\n      }\n      break;\n    }\n    case IrOpcode::kCheckHeapObject: {\n      Node* const input = node->InputAt(0);\n      if (DecideObjectIsSmi(input) == Decision::kFalse) {\n        ReplaceWithValue(node, input);\n        return Replace(input);\n      }\n      NodeMatcher m(input);\n      if (m.IsCheckHeapObject()) {\n        ReplaceWithValue(node, input);\n        return Replace(input);\n      }\n      break;\n    }\n    case IrOpcode::kCheckSmi: {\n      Node* const input = node->InputAt(0);\n      if (DecideObjectIsSmi(input) == Decision::kTrue) {\n        ReplaceWithValue(node, input);\n        return Replace(input);\n      }\n      NodeMatcher m(input);\n      if (m.IsCheckSmi()) {\n        ReplaceWithValue(node, input);\n        return Replace(input);\n      } else if (m.IsConvertTaggedHoleToUndefined()) {\n        node->ReplaceInput(0, m.InputAt(0));\n        return Changed(node);\n      }\n      break;\n    }\n    case IrOpcode::kObjectIsSmi: {\n      Node* const input = node->InputAt(0);\n      switch (DecideObjectIsSmi(input)) {\n        case Decision::kTrue:\n          return ReplaceBoolean(true);\n        case Decision::kFalse:\n          return ReplaceBoolean(false);\n        case Decision::kUnknown:\n          break;\n      }\n      break;\n    }\n    case IrOpcode::kNumberAbs: {\n      NumberMatcher m(node->InputAt(0));\n      if (m.HasResolvedValue())\n        return ReplaceNumber(std::fabs(m.ResolvedValue()));\n      break;\n    }\n    case IrOpcode::kReferenceEqual: {\n      HeapObjectBinopMatcher m(node);\n      if (m.left().node() == m.right().node()) return ReplaceBoolean(true);\n      break;\n    }\n    case IrOpcode::kCheckedInt32Add: {\n      // (x + a) + b => x + (a + b) where a and b are constants and have the\n      // same sign.\n      Int32BinopMatcher m(node);\n      if (m.right().HasResolvedValue()) {\n        Node* checked_int32_add = m.left().node();\n        if (checked_int32_add->opcode() == IrOpcode::kCheckedInt32Add) {\n          Int32BinopMatcher n(checked_int32_add);\n          if (n.right().HasResolvedValue() &&\n              (n.right().ResolvedValue() >= 0) ==\n                  (m.right().ResolvedValue() >= 0)) {\n            int32_t val;\n            bool overflow = base::bits::SignedAddOverflow32(\n                n.right().ResolvedValue(), m.right().ResolvedValue(), &val);\n            if (!overflow) {\n              bool has_no_other_uses = true;\n              for (Edge edge : checked_int32_add->use_edges()) {\n                if (!edge.from()->IsDead() && edge.from() != node) {\n                  has_no_other_uses = false;\n                  break;\n                }\n              }\n              if (has_no_other_uses) {\n                node->ReplaceInput(0, n.left().node());\n                node->ReplaceInput(1, jsgraph()->Int32Constant(val));\n                RelaxEffectsAndControls(checked_int32_add);\n                checked_int32_add->Kill();\n                return Changed(node);\n              }\n            }\n          }\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Change\",\n                \"parent\": \"SimplifiedOperatorReducer\",\n                \"about\": \"Changes the operator of a node to a new operator, replacing the first input.\",\n                \"logic\": \"Replaces the first input of the node with the provided input 'a', and changes the operator of the node to the specified operator 'op'.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to change.\"\n                    },\n                    {\n                        \"name\": \"op\",\n                        \"type\": \"const Operator*\",\n                        \"purpose\": \"The new operator for the node.\"\n                    },\n                    {\n                        \"name\": \"a\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The new first input for the node.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction (Changed).\"\n                },\n                \"dependencies\": [\n                    \"NodeProperties\",\n                    \"OperatorProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction SimplifiedOperatorReducer::Change(Node* node, const Operator* op,\n                                            Node* a) {\n  DCHECK_EQ(node->InputCount(), OperatorProperties::GetTotalInputCount(op));\n  DCHECK_LE(1, node->InputCount());\n  node->ReplaceInput(0, a);\n  NodeProperties::ChangeOp(node, op);\n  return Changed(node);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReplaceBoolean\",\n                \"parent\": \"SimplifiedOperatorReducer\",\n                \"about\": \"Replaces a node with a boolean constant.\",\n                \"logic\": \"If branch semantics are JS, replaces with a JS boolean constant. Otherwise, replaces with an int32 constant.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"bool\",\n                        \"purpose\": \"The boolean value to replace with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction (Replace).\"\n                },\n                \"dependencies\": [\n                    \"jsgraph\",\n                    \"BooleanConstant\",\n                    \"ReplaceInt32\",\n                    \"BranchSemantics\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction SimplifiedOperatorReducer::ReplaceBoolean(bool value) {\n  if (branch_semantics_ == BranchSemantics::kJS) {\n    return Replace(jsgraph()->BooleanConstant(value));\n  } else {\n    return ReplaceInt32(value);\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReplaceFloat64\",\n                \"parent\": \"SimplifiedOperatorReducer\",\n                \"about\": \"Replaces a node with a float64 constant.\",\n                \"logic\": \"Replaces the node with a Float64Constant node from the JSGraph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The float64 value to replace with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction (Replace).\"\n                },\n                \"dependencies\": [\n                    \"jsgraph\",\n                    \"Float64Constant\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction SimplifiedOperatorReducer::ReplaceFloat64(double value) {\n  return Replace(jsgraph()->Float64Constant(value));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReplaceInt32\",\n                \"parent\": \"SimplifiedOperatorReducer\",\n                \"about\": \"Replaces a node with an int32 constant.\",\n                \"logic\": \"Replaces the node with an Int32Constant node from the JSGraph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"int32_t\",\n                        \"purpose\": \"The int32 value to replace with.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction (Replace).\"\n                },\n                \"dependencies\": [\n                    \"jsgraph\",\n                    \"Int32Constant\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction SimplifiedOperatorReducer::ReplaceInt32(int32_t value) {\n  return Replace(jsgraph()->Int32Constant(value));\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReplaceNumber\",\n                \"parent\": \"SimplifiedOperatorReducer\",\n                \"about\": \"Replaces a node with a number constant (double).\",\n                \"logic\": \"Replaces the node with a"
}