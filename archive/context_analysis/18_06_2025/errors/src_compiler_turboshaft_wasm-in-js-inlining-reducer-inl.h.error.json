{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-in-js-inlining-reducer-inl.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-in-js-inlining-reducer-inl.h\",\n        \"file_name\": \"wasm-in-js-inlining-reducer-inl.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines a reducer for inlining WebAssembly code within JavaScript in the Turboshaft compiler.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for compiler, Turboshaft, Wasm functionality.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/js-inlining.h\"\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/define-assembler-macros.inc\"\n#include \"src/compiler/turboshaft/index.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/wasm-assembler-helpers.h\"\n#include \"src/heap/factory-inl.h\"\n#include \"src/objects/instance-type-inl.h\"\n#include \"src/wasm/compilation-environment-inl.h\"\n#include \"src/wasm/decoder.h\"\n#include \"src/wasm/function-body-decoder-impl.h\"\n#include \"src/wasm/wasm-engine.h\"\n#include \"src/wasm/wasm-module.h\"\n#include \"src/wasm/wasm-objects.h\"\n#include \"src/wasm/wasm-opcodes-inl.h\"\n#include \"src/wasm/wasm-subtyping.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmInJSInliningReducer\",\n            \"extends\": \"Next\",\n            \"about\": \"Reducer class responsible for inlining Wasm calls within JS code in Turboshaft.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CallTarget\",\n                \"FrameState\",\n                \"OpIndex\",\n                \"TSCallDescriptor\",\n                \"OpEffects\",\n                \"wasm::WasmModule\",\n                \"wasm::NativeModule\",\n                \"JSInliner\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Next>\nclass WasmInJSInliningReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(WasmInJSInlining)\n\n  V<Any> REDUCE(Call)(V<CallTarget> callee,\n                      OptionalV<turboshaft::FrameState> frame_state,\n                      base::Vector<const OpIndex> arguments,\n                      const TSCallDescriptor* descriptor, OpEffects effects);\n\n private:\n  V<Any> TryInlineWasmCall(const wasm::WasmModule* module,\n                           wasm::NativeModule* native_module, uint32_t func_idx,\n                           base::Vector<const OpIndex> arguments);\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(Call)\",\n            \"parent\": \"WasmInJSInliningReducer\",\n            \"about\": \"Reduces a call operation, potentially inlining a Wasm function.\",\n            \"logic\": \"Checks if the call is a JS-to-Wasm call. If so, attempts to inline the Wasm function. If inlining fails, toggles the thread-in-Wasm flag before and after the call.\",\n            \"parameters\": [\n                {\n                    \"name\": \"callee\",\n                    \"type\": \"V<CallTarget>\",\n                    \"purpose\": \"The target of the call.\"\n                },\n                {\n                    \"name\": \"frame_state\",\n                    \"type\": \"OptionalV<turboshaft::FrameState>\",\n                    \"purpose\": \"The frame state at the call site.\"\n                },\n                {\n                    \"name\": \"arguments\",\n                    \"type\": \"base::Vector<const OpIndex>\",\n                    \"purpose\": \"The arguments passed to the call.\"\n                },\n                {\n                    \"name\": \"descriptor\",\n                    \"type\": \"const TSCallDescriptor*\",\n                    \"purpose\": \"The call descriptor providing information about the call.\"\n                },\n                {\n                    \"name\": \"effects\",\n                    \"type\": \"OpEffects\",\n                    \"purpose\": \"The effects of the call.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Any>\",\n                \"description\": \"The result of the call, either the inlined result or the result of the original call.\"\n            },\n            \"dependencies\": [\n                \"TryInlineWasmCall\",\n                \"LoadRootRegister\",\n                \"Load\",\n                \"Store\",\n                \"Word32Constant\",\n                \"Isolate\",\n                \"thread_in_wasm_flag_address_offset\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n  V<Any> WasmInJSInliningReducer<Next>::REDUCE(Call)(V<CallTarget> callee,\n                      OptionalV<turboshaft::FrameState> frame_state,\n                      base::Vector<const OpIndex> arguments,\n                      const TSCallDescriptor* descriptor, OpEffects effects) {\n    if (!descriptor->js_wasm_call_parameters) {\n      // Regular call, nothing to do with Wasm or inlining. Proceed untouched...\n      return Next::ReduceCall(callee, frame_state, arguments, descriptor,\n                              effects);\n    }\n\n    // We shouldn't have attached `JSWasmCallParameters` at this call, unless\n    // we have TS Wasm-in-JS inlining enabled.\n    CHECK(v8_flags.turboshaft_wasm_in_js_inlining);\n\n    const wasm::WasmModule* module =\n        descriptor->js_wasm_call_parameters->module();\n    wasm::NativeModule* native_module =\n        descriptor->js_wasm_call_parameters->native_module();\n    uint32_t func_idx = descriptor->js_wasm_call_parameters->function_index();\n\n    V<Any> result =\n        TryInlineWasmCall(module, native_module, func_idx, arguments);\n    if (result.valid()) {\n      return result;\n    } else {\n      // The JS-to-Wasm wrapper was already inlined by the earlier TurboFan\n      // phase, specifically `JSInliner::ReduceJSWasmCall`. However, it did\n      // not toggle the thread-in-Wasm flag, since we don't want to set it\n      // in the inline case above.\n      // For the non-inline case, we need to toggle the flag now.\n      // TODO(dlehmann,353475584): Reuse the code from\n      // `WasmGraphBuilderBase::BuildModifyThreadInWasmFlag`, but that\n      // requires a different assembler stack...\n      OpIndex isolate_root = __ LoadRootRegister();\n      V<WordPtr> thread_in_wasm_flag_address =\n          __ Load(isolate_root, LoadOp::Kind::RawAligned().Immutable(),\n                  MemoryRepresentation::UintPtr(),\n                  Isolate::thread_in_wasm_flag_address_offset());\n      __ Store(thread_in_wasm_flag_address, __ Word32Constant(1),\n               LoadOp::Kind::RawAligned(), MemoryRepresentation::Int32(),\n               compiler::kNoWriteBarrier);\n\n      result =\n          Next::ReduceCall(callee, frame_state, arguments, descriptor, effects);\n\n      __ Store(thread_in_wasm_flag_address, __ Word32Constant(0),\n               LoadOp::Kind::RawAligned(), MemoryRepresentation::Int32(),\n               compiler::kNoWriteBarrier);\n\n      return result;\n    }\n  }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TryInlineWasmCall\",\n            \"parent\": \"WasmInJSInliningReducer\",\n            \"about\": \"Attempts to inline a Wasm function call.\",\n            \"logic\": \"Checks various conditions to determine if the Wasm function can be inlined, such as not being an asm.js module, not being an imported function, and not being a shared function. If all conditions are met, it decodes the Wasm function body and emits the inlinee instructions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"module\",\n                    \"type\": \"const wasm::WasmModule*\",\n                    \"purpose\": \"The Wasm module.\"\n                },\n                {\n                    \"name\": \"native_module\",\n                    \"type\": \"wasm::NativeModule*\",\n                    \"purpose\": \"The native module.\"\n                },\n                {\n                    \"name\": \"func_idx\",\n                    \"type\": \"uint32_t\",\n                    \"purpose\": \"The index of the function to inline.\"\n                },\n                {\n                    \"name\": \"arguments\",\n                    \"type\": \"base::Vector<const OpIndex>\",\n                    \"purpose\": \"The arguments passed to the function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Any>\",\n                \"description\": \"The result of the inlined function, or an invalid OpIndex if inlining failed.\"\n            },\n            \"dependencies\": [\n                \"is_asmjs_module\",\n                \"JSInliner::WasmFunctionNameForTrace\",\n                \"wasm::FunctionBody\",\n                \"wasm::CompilationEnv::ForModule\",\n                \"wasm::WasmFullDecoder\",\n                \"NewBlock\",\n                \"Goto\",\n                \"Bind\",\n                \"WasmInJsInliningInterface\",\n                \"DCHECK_LE\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nV<Any> WasmInJSInliningReducer<Next>::TryInlineWasmCall(\n    const wasm::WasmModule* module, wasm::NativeModule* native_module,\n    uint32_t func_idx, base::Vector<const OpIndex> arguments) {\n  const wasm::WasmFunction& func = module->functions[func_idx];\n\n  TRACE(\"Considering wasm function [\"\n        << func_idx << \"] \"\n        << JSInliner::WasmFunctionNameForTrace(native_module, func_idx)\n        << \" of module \" << module << \" for inlining\");\n\n  if (wasm::is_asmjs_module(module)) {\n    TRACE(\"- not inlining: asm.js-in-JS inlining is not supported\");\n    return OpIndex::Invalid();\n  }\n\n  if (func_idx < module->num_imported_functions) {\n    TRACE(\"- not inlining: call to an imported function\");\n    return OpIndex::Invalid();\n  }\n  DCHECK_LT(func_idx - module->num_imported_functions,\n            module->num_declared_functions);\n\n  // TODO(42204563): Support shared-everything proposal (at some point, or\n  // possibly never).\n  bool is_shared = module->type(func.sig_index).is_shared;\n  if (is_shared) {\n    TRACE(\"- not inlining: shared everything is not supported\");\n    return OpIndex::Invalid();\n  }\n\n  base::Vector<const uint8_t> module_bytes = native_module->wire_bytes();\n  const uint8_t* start = module_bytes.begin() + func.code.offset();\n  const uint8_t* end = module_bytes.begin() + func.code.end_offset();\n\n  wasm::FunctionBody func_body{func.sig, func.code.offset(), start, end,\n                               is_shared};\n\n  auto env = wasm::CompilationEnv::ForModule(native_module);\n  wasm::WasmDetectedFeatures detected{};\n\n  // JS-to-Wasm wrapper inlining doesn't support multi-value at the moment,\n  // so we should never reach here with more than 1 return value.\n  DCHECK_LE(func.sig->return_count(), 1);\n  base::Vector<const OpIndex> arguments_without_instance =\n      arguments.SubVectorFrom(1);\n  V<WasmTrustedInstanceData> trusted_instance_data =\n      arguments[wasm::kWasmInstanceDataParameterIndex];\n\n  Block* inlinee_body_and_rest = __ NewBlock();\n  __ Goto(inlinee_body_and_rest);\n\n  // First pass: Decode Wasm body to see if we could inline or would bail out.\n  // Emit into an unreachable block. We are not interested in the operations at\n  // this point, only in the decoder status afterwards.\n  Block* unreachable = __ NewBlock();\n  __ Bind(unreachable);\n\n  using Interface = WasmInJsInliningInterface<Assembler<ReducerList>>;\n  using Decoder =\n      wasm::WasmFullDecoder<typename Interface::ValidationTag, Interface>;\n  Decoder can_inline_decoder(Asm().phase_zone(), env.module,\n                             env.enabled_features, &detected, func_body, Asm(),\n                             arguments_without_instance, trusted_instance_data);\n  DCHECK(env.module->function_was_validated(func_idx));\n  can_inline_decoder.Decode();\n\n  // The function was already validated, so decoding can only fail if we bailed\n  // out due to an unsupported instruction.\n  if (!can_inline_decoder.ok()) {\n    TRACE(\"- not inlining: \" << can_inline_decoder.error().message());\n    __ Bind(inlinee_body_and_rest);\n    return OpIndex::Invalid();\n  }\n\n  // Second pass: Actually emit the inlinee instructions now.\n  __ Bind(inlinee_body_and_rest);\n  Decoder emitting_decoder(Asm().phase_zone(), env.module, env.enabled_features,\n                           &detected, func_body, Asm(),\n                           arguments_without_instance, trusted_instance_data);\n  emitting_decoder.Decode();\n  DCHECK(emitting_decoder.ok());\n  DCHECK(emitting_decoder.interface().Result().valid());\n  TRACE(\"- inlining\");\n  return emitting_decoder.interface().Result();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"WasmInJsInliningInterface\",\n            \"about\": \"Interface class for decoding and inlining Wasm code.  Implements the wasm::Decoder::Delegate interface.\",\n            \"attributes\": [\n                {\n                    \"name\": \"asm_\",\n                    \"type\": \"Assembler&\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Reference to the assembler.\"\n                },\n                {\n                    \"name\": \"locals_\",\n                    \"type\": \"ZoneVector<OpIndex>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector to store local variables.\"\n                },\n                {\n                    \"name\": \"arguments_\",\n                    \"type\": \"base::Vector<const OpIndex>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Vector to store arguments passed to the wasm function.\"\n                },\n                {\n                    \"name\": \"trusted_instance_data_\",\n                    \"type\": \"V<WasmTrustedInstanceData>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Trusted instance data for wasm.\"\n                },\n                {\n                    \"name\": \"result_\",\n                    \"type\": \"V<Any>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Result of the inlined code.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ValidationTag\",\n                \"FullDecoder\",\n                \"Value\",\n                \"Control\",\n                \"kUsesPoppedArgs\",\n                \"Assembler\",\n                \"OpIndex\",\n                \"ValueType\",\n                \"RootIndex\",\n                \"WasmOpcode\",\n                \"Simd128Immediate\",\n                \"TagIndexImmediate\",\n                \"ArrayIndexImmediate\",\n                \"wasm::BranchTableImmediate\",\n                \"wasm::CallFunctionImmediate\",\n                \"wasm::CallIndirectImmediate\",\n                \"wasm::FieldImmediate\",\n                \"wasm::GlobalIndexImmediate\",\n                \"wasm::IndexImmediate\",\n                \"wasm::MemoryAccessImmediate\",\n                \"wasm::MemoryCopyImmediate\",\n                \"wasm::MemoryIndexImmediate\",\n                \"wasm::MemoryInitImmediate\",\n                \"wasm::SimdLaneImmediate\",\n                \"wasm::StringConstImmediate\",\n                \"wasm::StructIndexImmediate\",\n                \"wasm::TableCopyImmediate\",\n                \"wasm::TableIndexImmediate\",\n                \"wasm::TableInitImmediate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <class Assembler>\nclass WasmInJsInliningInterface {\n public:\n  using ValidationTag = wasm::Decoder::NoValidationTag;\n  using FullDecoder =\n      wasm::WasmFullDecoder<ValidationTag, WasmInJsInliningInterface>;\n  struct Value : public wasm::ValueBase<ValidationTag> {\n    OpIndex op = OpIndex::Invalid();\n    template <typename... Args>\n    explicit Value(Args&&... args) V8_NOEXCEPT\n        : ValueBase(std::forward<Args>(args)...) {}\n  };\n  // TODO(dlehmann,353475584): Introduce a proper `Control` struct/class, once\n  // we want to support control-flow in the inlinee.\n  using Control = wasm::ControlBase<Value, ValidationTag>;\n  static constexpr bool kUsesPoppedArgs = false;\n\n  WasmInJsInliningInterface(Assembler& assembler,\n                            base::Vector<const OpIndex> arguments,\n                            V<WasmTrustedInstanceData> trusted_instance_data)\n      : asm_(assembler),\n        locals_(assembler.phase_zone()),\n        arguments_(arguments),\n        trusted_instance_data_(trusted_instance_data) {}\n\n  V<Any> Result() { return result_; }\n\n  void OnFirstError(FullDecoder*) {}\n\n  void Bailout(FullDecoder* decoder) {\n    decoder->errorf(\"unsupported operation: %s\",\n                    decoder->SafeOpcodeNameAt(decoder->pc()));\n  }\n\n  void StartFunction(FullDecoder* decoder);\n  void StartFunctionBody(FullDecoder* decoder, Control* block) {}\n  void FinishFunction(FullDecoder* decoder) {}\n\n  void NextInstruction(FullDecoder* decoder, WasmOpcode);\n\n  void NopForTestingUnsupportedInLiftoff(FullDecoder* decoder) {\n    // This is just for testing bailouts in Liftoff, here it's just a nop.\n  }\n\n  void TraceInstruction(FullDecoder* decoder, uint32_t markid) {\n    Bailout(decoder);\n  }\n\n  void UnOp(FullDecoder* decoder, WasmOpcode opcode, const Value& value,\n            Value* result);\n  void BinOp(FullDecoder* decoder, WasmOpcode opcode, const Value& lhs,\n             const Value& rhs, Value* result);\n\n  OpIndex UnOpImpl(FullDecoder* decoder, WasmOpcode opcode, OpIndex arg,\n                   ValueType input_type /* for ref.is_null only*/);\n  OpIndex BinOpImpl(FullDecoder* decoder, WasmOpcode opcode, OpIndex lhs,\n                    OpIndex rhs);\n\n  void I32Const(FullDecoder* decoder, Value* result, int32_t value);\n\n  void I64Const(FullDecoder* decoder, Value* result, int64_t value);\n\n  void F32Const(FullDecoder* decoder, Value* result, float value);\n\n  void F64Const(FullDecoder* decoder, Value* result, double value);\n\n  void S128Const(FullDecoder* decoder, const Simd128Immediate& imm,\n                 Value* result);\n\n  void RefNull(FullDecoder* decoder, ValueType type, Value* result);\n\n  void RefFunc(FullDecoder* decoder, uint32_t function_index, Value* result);\n\n  void RefAsNonNull(FullDecoder* decoder, const Value& arg, Value* result) {\n    Bailout(decoder);\n  }\n\n  void Drop(FullDecoder* decoder) {}\n\n  void LocalGet(FullDecoder* decoder, Value* result,\n                const IndexImmediate& imm);\n\n  void LocalSet(FullDecoder* decoder, const Value& value,\n                const IndexImmediate& imm);\n\n  void LocalTee(FullDecoder* decoder, const Value& value, Value* result,\n                const IndexImmediate& imm);\n\n  void GlobalGet(FullDecoder* decoder, Value* result,\n                 const GlobalIndexImmediate& imm);\n\n  void GlobalSet(FullDecoder* decoder, const Value& value,\n                 const GlobalIndexImmediate& imm);\n\n  // TODO(dlehmann,353475584): Support control-flow in the inlinee.\n\n  void Block(FullDecoder* decoder, Control* block) { Bailout(decoder); }\n  void Loop(FullDecoder* decoder, Control* block) { Bailout(decoder); }\n  void If(FullDecoder* decoder, const Value& cond, Control* if_block) {\n    Bailout(decoder);\n  }\n  void Else(FullDecoder* decoder, Control* if_block) { Bailout(decoder); }\n  void BrOrRet(FullDecoder* decoder, uint32_t depth, uint32_t drop_values = 0) {\n    Bailout(decoder);\n  }\n  void BrIf(FullDecoder* decoder, const Value& cond, uint32_t depth) {\n    Bailout(decoder);\n  }\n  void BrTable(FullDecoder* decoder, const BranchTableImmediate& imm,\n               const Value& key) {\n    Bailout(decoder);\n  }\n\n  void FallThruTo(FullDecoder* decoder, Control* block) { Bailout(decoder); }\n  void PopControl(FullDecoder* decoder, Control* block) { Bailout(decoder); }\n  void DoReturn(FullDecoder* decoder, uint32_t drop_values);\n  void Select(FullDecoder* decoder, const Value& cond, const Value& fval,\n              const Value& tval, Value* result) {\n    Bailout(decoder);\n  }\n\n  // TODO(dlehmann,353475584): Support exceptions in the inlinee.\n\n  void Try(FullDecoder* decoder, Control* block) { Bailout(decoder); }\n  void Throw(FullDecoder* decoder, const TagIndexImmediate& imm,\n             const Value arg_values[]) {\n    Bailout(decoder);\n  }\n  void Rethrow(FullDecoder* decoder, Control* block) { Bailout(decoder); }\n  void CatchException(FullDecoder* decoder, const TagIndexImmediate& imm,\n                      Control* block, base::Vector<Value> values) {\n    Bailout(decoder);\n  }\n  void Delegate(FullDecoder* decoder, uint32_t depth, Control* block) {\n    Bailout(decoder);\n  }\n\n  void CatchAll(FullDecoder* decoder, Control* block) { Bailout(decoder); }\n  void TryTable(FullDecoder* decoder, Control* block) { Bailout(decoder); }\n  void CatchCase(FullDecoder* decoder, Control* block,\n                 const wasm::CatchCase& catch_case,\n                 base::Vector<Value> values) {\n    Bailout(decoder);\n  }\n  void ThrowRef(FullDecoder* decoder, Value* value) { Bailout(decoder); }\n\n  // TODO(dlehmann,353475584): Support traps in the inlinee.\n\n  void Trap(FullDecoder* decoder, wasm::TrapReason reason) { Bailout(decoder); }\n  void AssertNullTypecheck(FullDecoder* decoder, const Value& obj,\n                           Value* result) {\n    Bailout(decoder);\n  }\n\n  void AssertNotNullTypecheck(FullDecoder* decoder, const Value& obj,\n                              Value* result) {\n    Bailout(decoder);\n  }\n  void AtomicNotify(FullDecoder* decoder, const MemoryAccessImmediate& imm,\n                    OpIndex index, OpIndex num_waiters_to_wake, Value* result) {\n    Bailout(decoder);\n  }\n  void AtomicWait(FullDecoder* decoder, WasmOpcode opcode,\n                  const MemoryAccessImmediate& imm, OpIndex index,\n                  OpIndex expected, V<Word64> timeout, Value* result) {\n    Bailout(decoder);\n  }\n  void AtomicOp(FullDecoder* decoder, WasmOpcode opcode, const Value args[],\n                const size_t argc, const MemoryAccessImmediate& imm,\n                Value* result) {\n    Bailout(decoder);\n  }\n  void AtomicFence(FullDecoder* decoder) { Bailout(decoder); }\n\n  void MemoryInit(FullDecoder* decoder, const MemoryInitImmediate& imm,\n                  const Value& dst, const Value& src, const Value& size) {\n    Bailout(decoder);\n  }\n  void MemoryCopy(FullDecoder* decoder, const MemoryCopyImmediate& imm,\n                  const Value& dst, const Value& src, const Value& size) {\n    Bailout(decoder);\n  }\n  void MemoryFill(FullDecoder* decoder, const MemoryIndexImmediate& imm,\n                  const Value& dst, const Value& value, const Value& size) {\n    Bailout(decoder);\n  }\n  void DataDrop(FullDecoder* decoder, const IndexImmediate& imm) {\n    Bailout(decoder);\n  }\n\n  void TableGet(FullDecoder* decoder, const Value& index, Value* result,\n                const TableIndexImmediate& imm) {\n    Bailout(decoder);\n  }\n  void TableSet(FullDecoder* decoder, const Value& index, const Value& value,\n                const TableIndexImmediate& imm) {\n    Bailout(decoder);\n  }\n  void TableInit(FullDecoder* decoder, const TableInitImmediate& imm,\n                 const Value& dst_val, const Value& src_val,\n                 const Value& size_val) {\n    Bailout(decoder);\n  }\n  void TableCopy(FullDecoder* decoder, const TableCopyImmediate& imm,\n                 const Value& dst_val, const Value& src_val,\n                 const Value& size_val) {\n    Bailout(decoder);\n  }\n  void TableGrow(FullDecoder* decoder, const TableIndexImmediate& imm,\n                 const Value& value, const Value& delta, Value* result) {\n    Bailout(decoder);\n  }\n  void TableFill(FullDecoder* decoder, const TableIndexImmediate& imm,\n                 const Value& start, const Value& value, const Value& count) {\n    Bailout(decoder);\n  }\n  void TableSize(FullDecoder* decoder, const TableIndexImmediate& imm,\n                 Value* result) {\n    Bailout(decoder);\n  }\n\n  void ElemDrop(FullDecoder* decoder, const IndexImmediate& imm) {\n    Bailout(decoder);\n  }\n\n  void StructNew(FullDecoder* decoder, const StructIndexImmediate& imm,\n                 const Value args[], Value* result) {\n    Bailout(decoder);\n  }\n  void StructNewDefault(FullDecoder* decoder, const StructIndexImmediate& imm,\n                        Value* result) {\n    Bailout(decoder);\n  }\n  void StructGet(FullDecoder* decoder, const Value& struct_object,\n                 const FieldImmediate& field, bool is_signed, Value* result) {\n    Bailout(decoder);\n  }\n  void StructSet(FullDecoder* decoder, const Value& struct_object,\n                 const FieldImmediate& field, const Value& field_value) {\n    Bailout(decoder);\n  }\n  void ArrayNew(FullDecoder* decoder, const ArrayIndexImmediate& imm,\n                const Value& length, const Value& initial_value,\n                Value* result) {\n    Bailout(decoder);\n  }\n  void ArrayNewDefault(FullDecoder* decoder, const ArrayIndexImmediate& imm,\n                       const Value& length, Value* result) {\n    // TODO(dlehmann): This will pull in/cause a lot of code duplication wrt.\n    // the Wasm pipeline / `TurboshaftGraphBuildingInterface`.\n    // How to reduce duplication best? Common superclass? But both will have\n    // different Assemblers (reducer stacks), so I will have to templatize that.\n    Bailout(decoder);\n  }\n  void ArrayGet(FullDecoder* decoder, const Value& array_obj,\n                const ArrayIndexImmediate& imm, const Value& index,\n                bool is_signed, Value* result) {\n    Bailout(decoder);\n  }\n  void ArraySet(FullDecoder* decoder, const Value& array_obj,\n                const ArrayIndexImmediate& imm, const Value& index,\n                const Value& value) {\n    Bailout(decoder);\n  }\n  void ArrayLen(FullDecoder* decoder, const Value& array_obj, Value* result) {\n    Bailout(decoder);\n  }\n  void ArrayCopy(FullDecoder* decoder, const Value& dst, const Value& dst_index,\n                 const Value& src, const Value& src_index,\n                 const ArrayIndexImmediate& src_imm, const Value& length) {\n    Bailout(decoder);\n  }\n  void ArrayFill(FullDecoder* decoder, ArrayIndexImmediate& imm,\n                 const Value& array, const Value& index, const Value& value,\n                 const Value& length) {\n    Bailout(decoder);\n  }\n  void ArrayNewFixed(FullDecoder* decoder, const ArrayIndexImmediate& array_imm,\n                     const IndexImmediate& length_imm, const Value elements[],\n                     Value* result) {\n    Bailout(decoder);\n  }\n  void ArrayNewSegment(FullDecoder* decoder,\n                       const ArrayIndexImmediate& array_imm,\n                       const IndexImmediate& segment_imm, const Value& offset,\n                       const Value& length, Value* result) {\n    Bailout(decoder);\n  }\n  void ArrayInitSegment(FullDecoder* decoder,\n                        const ArrayIndexImmediate& array_imm,\n                        const IndexImmediate& segment_imm, const Value& array,\n                        const Value& array_index, const Value& segment_offset,\n                        const Value& length) {\n    Bailout(decoder);\n  }\n\n  void RefI31(FullDecoder* decoder, const Value& input, Value* result) {\n    Bailout(decoder);\n  }\n  void I31GetS(FullDecoder* decoder, const Value& input, Value* result) {\n    Bailout(decoder);\n  }\n\n  void I31GetU(FullDecoder* decoder, const Value& input, Value* result) {\n    Bailout(decoder);\n  }\n\n  void RefTest(FullDecoder* decoder, wasm::ModuleTypeIndex ref_index,\n               const Value& object, Value* result, bool null_succeeds) {\n    Bailout(decoder);\n  }\n  void RefTestAbstract(FullDecoder* decoder, const Value& object,\n                       wasm::HeapType type, Value* result, bool null_succeeds) {\n    Bailout(decoder);\n  }\n  void RefCast(FullDecoder* decoder, wasm::ModuleTypeIndex ref_index,\n               const Value& object, Value* result, bool null_succeeds) {\n    Bailout(decoder);\n  }\n  void RefCastAbstract(FullDecoder* decoder, const Value& object,\n                       wasm::HeapType type, Value* result, bool null_succeeds) {\n    Bailout(decoder);\n  }\n  void LoadMem(FullDecoder* decoder, wasm::LoadType type,\n               const MemoryAccessImmediate& imm, const Value& index,\n               Value* result) {\n    Bailout(decoder);\n  }\n  void LoadTransform(FullDecoder* decoder, wasm::LoadType type,\n                     wasm::LoadTransformationKind transform,\n                     const MemoryAccessImmediate& imm, const Value& index,\n                     Value* result) {\n    Bailout(decoder);\n  }\n  void LoadLane(FullDecoder* decoder, wasm::LoadType type, const Value& value,\n                const Value& index, const MemoryAccessImmediate& imm,\n                const uint8_t laneidx, Value* result) {\n    Bailout(decoder);\n  }\n\n  void StoreMem(FullDecoder* decoder, wasm::StoreType type,\n                const MemoryAccessImmediate& imm, const Value& index,\n                const Value& value) {\n    Bailout(decoder);\n  }\n\n  void StoreLane(FullDecoder* decoder, wasm::StoreType type,\n                 const MemoryAccessImmediate& imm, const Value& index,\n                 const Value& value, const uint8_t laneidx) {\n    Bailout(decoder);\n  }\n\n  void CurrentMemoryPages(FullDecoder* decoder, const MemoryIndexImmediate& imm,\n                          Value* result) {\n    Bailout(decoder);\n  }\n\n  void MemoryGrow(FullDecoder* decoder, const MemoryIndexImmediate& imm,\n                  const Value& value, Value* result) {\n    Bailout(decoder);\n  }\n\n  // TODO(dlehmann,353475584): Support non-leaf functions as the inlinee (i.e.,\n  // calls).\n\n  void CallDirect(FullDecoder* decoder, const CallFunctionImmediate& imm,\n                  const Value args[], Value returns[]) {\n    Bailout(decoder);\n  }\n  void ReturnCall(FullDecoder* decoder, const CallFunctionImmediate& imm,\n                  const Value args[]) {\n    Bailout(decoder);\n  }\n  void CallIndirect(FullDecoder* decoder, const Value& index,\n                    const CallIndirectImmediate& imm, const Value args[],\n                    Value returns[]) {\n    Bailout(decoder);\n  }\n  void ReturnCallIndirect(FullDecoder* decoder, const Value& index,\n                          const CallIndirectImmediate& imm,\n                          const Value args[]) {\n    Bailout(decoder);\n  }\n  void CallRef(FullDecoder* decoder, const Value& func_ref,\n               const wasm::FunctionSig* sig, const Value args[],\n               Value returns[]) {\n    Bailout(decoder);\n  }\n\n  void ReturnCallRef(FullDecoder* decoder, const Value& func_ref,\n                     const wasm::FunctionSig* sig, const Value args[]) {\n    Bailout(decoder);\n  }\n\n  void BrOnNull(FullDecoder* decoder, const Value& ref_object, uint32_t depth,\n                bool pass_null_along_branch, Value* result_on_fallthrough) {\n    Bailout(decoder);\n  }"
}