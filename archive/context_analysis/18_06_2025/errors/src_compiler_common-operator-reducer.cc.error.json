{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/common-operator-reducer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/common-operator-reducer.cc\",\n            \"file_name\": \"common-operator-reducer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the CommonOperatorReducer class, which performs common operator-based optimizations on the Turbofan graph.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for compiler, common operators, JS heap broker, machine operators, node matching, node properties, nodes, opcodes, and turbofan graph functionality.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/common-operator-reducer.h\"\n\n#include <algorithm>\n#include <optional>\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/compiler/machine-operator.h\"\n#include \"src/compiler/node-matchers.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/node.h\"\n#include \"src/compiler/opcodes.h\"\n#include \"src/compiler/turbofan-graph.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"CommonOperatorReducer\",\n                \"extends\": \"AdvancedReducer\",\n                \"about\": \"Reduces common operators in the Turbofan graph to simpler forms.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The Turbofan graph being optimized.\"\n                    },\n                    {\n                        \"name\": \"broker_\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Provides access to the JavaScript heap for constant folding.\"\n                    },\n                    {\n                        \"name\": \"common_\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builder for common operators.\"\n                    },\n                    {\n                        \"name\": \"machine_\",\n                        \"type\": \"MachineOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Builder for machine-level operators.\"\n                    },\n                    {\n                        \"name\": \"dead_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A node representing dead code.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A memory zone for temporary allocations.\"\n                    },\n                    {\n                        \"name\": \"default_branch_semantics_\",\n                        \"type\": \"BranchSemantics\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The default semantics to use for branches.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Editor\",\n                    \"TFGraph\",\n                    \"JSHeapBroker\",\n                    \"CommonOperatorBuilder\",\n                    \"MachineOperatorBuilder\",\n                    \"Zone\",\n                    \"AdvancedReducer\",\n                    \"BranchSemantics\",\n                    \"Type\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass CommonOperatorReducer : public AdvancedReducer {\n public:\n  CommonOperatorReducer(\n      Editor* editor, TFGraph* graph, JSHeapBroker* broker,\n      CommonOperatorBuilder* common, MachineOperatorBuilder* machine,\n      Zone* temp_zone, BranchSemantics default_branch_semantics)\n      : AdvancedReducer(editor),\n        graph_(graph),\n        broker_(broker),\n        common_(common),\n        machine_(machine),\n        dead_(graph->NewNode(common->Dead())),\n        zone_(temp_zone),\n        default_branch_semantics_(default_branch_semantics) {\n    NodeProperties::SetType(dead_, Type::None());\n  }\n\n  Reduction Reduce(Node* node) override;\n\n private:\n  enum class Decision { kUnknown, kTrue, kFalse };\n  Decision DecideCondition(Node* const cond, BranchSemantics branch_semantics);\n  Reduction ReduceBranch(Node* node);\n  Reduction ReduceDeoptimizeConditional(Node* node);\n  Reduction ReduceMerge(Node* node);\n  Reduction ReduceEffectPhi(Node* node);\n  Reduction ReducePhi(Node* node);\n  Reduction ReduceReturn(Node* node);\n  Reduction ReduceSelect(Node* node);\n  Reduction ReduceSwitch(Node* node);\n  Reduction ReduceStaticAssert(Node* node);\n  Reduction ReduceTrapConditional(Node* trap);\n\n  Reduction Change(Node* node, Operator const* op, Node* a);\n  Reduction Change(Node* node, Operator const* op, Node* a, Node* b);\n\n  TFGraph* const graph_;\n  JSHeapBroker* const broker_;\n  CommonOperatorBuilder* const common_;\n  MachineOperatorBuilder* const machine_;\n  Node* const dead_;\n  Zone* const zone_;\n  BranchSemantics const default_branch_semantics_;\n};\n\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"CommonOperatorReducer\",\n                \"parent\": \"CommonOperatorReducer\",\n                \"about\": \"Constructor for CommonOperatorReducer.\",\n                \"logic\": \"Initializes the CommonOperatorReducer with the given graph, broker, operator builders, and memory zone. Creates a 'dead' node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"editor\",\n                        \"type\": \"Editor*\",\n                        \"purpose\": \"The editor used to manipulate the graph.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The Turbofan graph to optimize.\"\n                    },\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker for accessing heap objects.\"\n                    },\n                    {\n                        \"name\": \"common\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"purpose\": \"Builder for common operators.\"\n                    },\n                    {\n                        \"name\": \"machine\",\n                        \"type\": \"MachineOperatorBuilder*\",\n                        \"purpose\": \"Builder for machine-level operators.\"\n                    },\n                    {\n                        \"name\": \"temp_zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"A temporary memory zone.\"\n                    },\n                    {\n                        \"name\": \"default_branch_semantics\",\n                        \"type\": \"BranchSemantics\",\n                        \"purpose\": \"The default branch semantics.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"AdvancedReducer\",\n                    \"graph->NewNode\",\n                    \"common->Dead\",\n                    \"NodeProperties::SetType\",\n                    \"Type::None\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nCommonOperatorReducer::CommonOperatorReducer(\n    Editor* editor, TFGraph* graph, JSHeapBroker* broker,\n    CommonOperatorBuilder* common, MachineOperatorBuilder* machine,\n    Zone* temp_zone, BranchSemantics default_branch_semantics)\n    : AdvancedReducer(editor),\n      graph_(graph),\n      broker_(broker),\n      common_(common),\n      machine_(machine),\n      dead_(graph->NewNode(common->Dead())),\n      zone_(temp_zone),\n      default_branch_semantics_(default_branch_semantics) {\n  NodeProperties::SetType(dead_, Type::None());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reduce\",\n                \"parent\": \"CommonOperatorReducer\",\n                \"about\": \"Reduces a node in the Turbofan graph based on its opcode.\",\n                \"logic\": \"This is the main reduction function. It switches on the opcode of the input node and calls the appropriate reduction method.  It also disables heap access if no broker is set.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A Reduction object indicating the result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"ReduceBranch\",\n                    \"ReduceDeoptimizeConditional\",\n                    \"ReduceMerge\",\n                    \"ReduceEffectPhi\",\n                    \"ReducePhi\",\n                    \"ReduceReturn\",\n                    \"ReduceSelect\",\n                    \"ReduceSwitch\",\n                    \"ReduceStaticAssert\",\n                    \"ReduceTrapConditional\",\n                    \"NoChange\",\n                    \"IrOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction CommonOperatorReducer::Reduce(Node* node) {\n  DisallowHeapAccessIf no_heap_access(broker() == nullptr);\n  switch (node->opcode()) {\n    case IrOpcode::kBranch:\n      return ReduceBranch(node);\n    case IrOpcode::kDeoptimizeIf:\n    case IrOpcode::kDeoptimizeUnless:\n      return ReduceDeoptimizeConditional(node);\n    case IrOpcode::kMerge:\n      return ReduceMerge(node);\n    case IrOpcode::kEffectPhi:\n      return ReduceEffectPhi(node);\n    case IrOpcode::kPhi:\n      return ReducePhi(node);\n    case IrOpcode::kReturn:\n      return ReduceReturn(node);\n    case IrOpcode::kSelect:\n      return ReduceSelect(node);\n    case IrOpcode::kSwitch:\n      return ReduceSwitch(node);\n    case IrOpcode::kStaticAssert:\n      return ReduceStaticAssert(node);\n    case IrOpcode::kTrapIf:\n    case IrOpcode::kTrapUnless:\n      return ReduceTrapConditional(node);\n    default:\n      break;\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DecideCondition\",\n                \"parent\": \"CommonOperatorReducer\",\n                \"about\": \"Determines the truthiness of a condition node.\",\n                \"logic\": \"Attempts to resolve the condition node to a boolean value.  Handles Int32Constant and HeapConstant nodes.  For HeapConstant nodes it uses the broker to try and determine the boolean value.  It skips ValueIdentities nodes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"cond\",\n                        \"type\": \"Node* const\",\n                        \"purpose\": \"The condition node to evaluate.\"\n                    },\n                    {\n                        \"name\": \"branch_semantics\",\n                        \"type\": \"BranchSemantics\",\n                        \"purpose\": \"The branch semantics.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Decision\",\n                    \"description\": \"kTrue, kFalse, or kUnknown depending on whether the condition can be resolved.\"\n                },\n                \"dependencies\": [\n                    \"SkipValueIdentities\",\n                    \"IrOpcode\",\n                    \"Int32Matcher\",\n                    \"HeapObjectMatcher\",\n                    \"broker_\",\n                    \"Decision\",\n                    \"BranchSemantics\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDecision CommonOperatorReducer::DecideCondition(\n    Node* const cond, BranchSemantics branch_semantics) {\n  Node* unwrapped = SkipValueIdentities(cond);\n  switch (unwrapped->opcode()) {\n    case IrOpcode::kInt32Constant: {\n      DCHECK_EQ(branch_semantics, BranchSemantics::kMachine);\n      Int32Matcher m(unwrapped);\n      return m.ResolvedValue() ? Decision::kTrue : Decision::kFalse;\n    }\n    case IrOpcode::kHeapConstant: {\n      if (branch_semantics == BranchSemantics::kMachine) {\n        return Decision::kTrue;\n      }\n      HeapObjectMatcher m(unwrapped);\n      std::optional<bool> maybe_result =\n          m.Ref(broker_).TryGetBooleanValue(broker());\n      if (!maybe_result.has_value()) return Decision::kUnknown;\n      return *maybe_result ? Decision::kTrue : Decision::kFalse;\n    }\n    default:\n      return Decision::kUnknown;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceBranch\",\n                \"parent\": \"CommonOperatorReducer\",\n                \"about\": \"Reduces a Branch node based on the condition.\",\n                \"logic\": \"If the condition is a BooleanNot, swaps the IfTrue/IfFalse projections and uses the input to BooleanNot as the new condition. If the condition can be decided, replaces IfTrue/IfFalse projections with either the control or the dead node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Branch node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A Reduction object indicating the result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"BranchSemanticsOf\",\n                    \"Node::InputAt\",\n                    \"Node::uses\",\n                    \"NodeProperties::ChangeOp\",\n                    \"common->IfFalse\",\n                    \"common->IfTrue\",\n                    \"node->ReplaceInput\",\n                    \"common->Branch\",\n                    \"NegateBranchHint\",\n                    \"BranchHintOf\",\n                    \"DecideCondition\",\n                    \"dead\",\n                    \"Replace\",\n                    \"Decision\",\n                    \"Changed\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction CommonOperatorReducer::ReduceBranch(Node* node) {\n  DCHECK_EQ(IrOpcode::kBranch, node->opcode());\n  BranchSemantics branch_semantics = BranchSemanticsOf(node);\n  Node* const cond = node->InputAt(0);\n  // Swap IfTrue/IfFalse on {branch} if {cond} is a BooleanNot and use the input\n  // to BooleanNot as new condition for {branch}. Note we assume that {cond} was\n  // already properly optimized before we get here (as guaranteed by the graph\n  // reduction logic). The same applies if {cond} is a Select acting as boolean\n  // not (i.e. true being returned in the false case and vice versa).\n  if (cond->opcode() == IrOpcode::kBooleanNot ||\n      (cond->opcode() == IrOpcode::kSelect &&\n       DecideCondition(cond->InputAt(1), branch_semantics) ==\n           Decision::kFalse &&\n       DecideCondition(cond->InputAt(2), branch_semantics) ==\n           Decision::kTrue)) {\n    for (Node* const use : node->uses()) {\n      switch (use->opcode()) {\n        case IrOpcode::kIfTrue:\n          NodeProperties::ChangeOp(use, common()->IfFalse());\n          break;\n        case IrOpcode::kIfFalse:\n          NodeProperties::ChangeOp(use, common()->IfTrue());\n          break;\n        default:\n          UNREACHABLE();\n      }\n    }\n    // Update the condition of {branch}. No need to mark the uses for revisit,\n    // since we tell the graph reducer that the {branch} was changed and the\n    // graph reduction logic will ensure that the uses are revisited properly.\n    node->ReplaceInput(0, cond->InputAt(0));\n    // Negate the hint for {branch}.\n    NodeProperties::ChangeOp(\n        node, common()->Branch(NegateBranchHint(BranchHintOf(node->op()))));\n    return Changed(node);\n  }\n  Decision const decision = DecideCondition(cond, branch_semantics);\n  if (decision == Decision::kUnknown) return NoChange();\n  Node* const control = node->InputAt(1);\n  for (Node* const use : node->uses()) {\n    switch (use->opcode()) {\n      case IrOpcode::kIfTrue:\n        Replace(use, (decision == Decision::kTrue) ? control : dead());\n        break;\n      case IrOpcode::kIfFalse:\n        Replace(use, (decision == Decision::kFalse) ? control : dead());\n        break;\n      default:\n        UNREACHABLE();\n    }\n  }\n  return Replace(dead());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceDeoptimizeConditional\",\n                \"parent\": \"CommonOperatorReducer\",\n                \"about\": \"Reduces a DeoptimizeIf or DeoptimizeUnless node based on the condition.\",\n                \"logic\": \"If the condition is a BooleanNot, swaps the DeoptimizeIf/DeoptimizeUnless. If the condition can be decided, either replaces the node with dead or inserts a Deoptimize node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The DeoptimizeIf or DeoptimizeUnless node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A Reduction object indicating the result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"DeoptimizeParametersOf\",\n                    \"NodeProperties::GetValueInput\",\n                    \"NodeProperties::GetEffectInput\",\n                    \"NodeProperties::GetControlInput\",\n                    \"NodeProperties::ReplaceValueInput\",\n                    \"NodeProperties::ChangeOp\",\n                    \"common->DeoptimizeIf\",\n                    \"common->DeoptimizeUnless\",\n                    \"DecideCondition\",\n                    \"default_branch_semantics_\",\n                    \"ReplaceWithValue\",\n                    \"dead\",\n                    \"graph->NewNode\",\n                    \"common->Deoptimize\",\n                    \"MergeControlToEnd\",\n                    \"graph\",\n                    \"common\",\n                    \"Changed\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction CommonOperatorReducer::ReduceDeoptimizeConditional(Node* node) {\n  DCHECK(node->opcode() == IrOpcode::kDeoptimizeIf ||\n         node->opcode() == IrOpcode::kDeoptimizeUnless);\n  bool condition_is_true = node->opcode() == IrOpcode::kDeoptimizeUnless;\n  DeoptimizeParameters p = DeoptimizeParametersOf(node->op());\n  Node* condition = NodeProperties::GetValueInput(node, 0);\n  Node* frame_state = NodeProperties::GetValueInput(node, 1);\n  Node* effect = NodeProperties::GetEffectInput(node);\n  Node* control = NodeProperties::GetControlInput(node);\n  // Swap DeoptimizeIf/DeoptimizeUnless on {node} if {cond} is a BooleaNot\n  // and use the input to BooleanNot as new condition for {node}.  Note we\n  // assume that {cond} was already properly optimized before we get here\n  // (as guaranteed by the graph reduction logic).\n  if (condition->opcode() == IrOpcode::kBooleanNot) {\n    NodeProperties::ReplaceValueInput(node, condition->InputAt(0), 0);\n    NodeProperties::ChangeOp(\n        node, condition_is_true\n                  ? common()->DeoptimizeIf(p.reason(), p.feedback())\n                  : common()->DeoptimizeUnless(p.reason(), p.feedback()));\n    return Changed(node);\n  }\n  Decision const decision =\n      DecideCondition(condition, default_branch_semantics_);\n  if (decision == Decision::kUnknown) return NoChange();\n  if (condition_is_true == (decision == Decision::kTrue)) {\n    ReplaceWithValue(node, dead(), effect, control);\n  } else {\n    control = graph()->NewNode(common()->Deoptimize(p.reason(), p.feedback()),\n                               frame_state, effect, control);\n    MergeControlToEnd(graph(), common(), control);\n  }\n  return Replace(dead());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceMerge\",\n                \"parent\": \"CommonOperatorReducer\",\n                \"about\": \"Reduces a Merge node, specifically identifying and removing unused diamond shapes in the control flow graph.\",\n                \"logic\": \"Checks if a Merge node is part of an unused diamond pattern (IfTrue, IfFalse, Branch). If so, removes the diamond and replaces the Merge with the control node from the Branch.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Merge node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A Reduction object indicating the result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"IrOpcode::IsPhiOpcode\",\n                    \"Node::InputAt\",\n                    \"Node::uses\",\n                    \"OwnedBy\",\n                    \"NodeProperties::ChangeOp\",\n                    \"common->Dead\",\n                    \"Replace\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction CommonOperatorReducer::ReduceMerge(Node* node) {\n  DCHECK_EQ(IrOpcode::kMerge, node->opcode());\n  //\n  // Check if this is a merge that belongs to an unused diamond, which means\n  // that:\n  //\n  //  a) the {Merge} has no {Phi} or {EffectPhi} uses, and\n  //  b) the {Merge} has two inputs, one {IfTrue} and one {IfFalse}, which are\n  //     both owned by the Merge, and\n  //  c) and the {IfTrue} and {IfFalse} nodes point to the same {Branch}.\n  //\n  if (node->InputCount() == 2) {\n    for (Node* const use : node->uses()) {\n      if (IrOpcode::IsPhiOpcode(use->opcode())) return NoChange();\n    }\n    Node* if_true = node->InputAt(0);\n    Node* if_false = node->InputAt(1);\n    if (if_true->opcode() != IrOpcode::kIfTrue) std::swap(if_true, if_false);\n    if (if_true->opcode() == IrOpcode::kIfTrue &&\n        if_false->opcode() == IrOpcode::kIfFalse &&\n        if_true->InputAt(0) == if_false->InputAt(0) && if_true->OwnedBy(node) &&\n        if_false->OwnedBy(node)) {\n      Node* const branch = if_true->InputAt(0);\n      DCHECK_EQ(IrOpcode::kBranch, branch->opcode());\n      DCHECK(branch->OwnedBy(if_true, if_false));\n      Node* const control = branch->InputAt(1);\n      // Mark the {branch} as {Dead}.\n      branch->TrimInputCount(0);\n      NodeProperties::ChangeOp(branch, common()->Dead());\n      return Replace(control);\n    }\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceEffectPhi\",\n                \"parent\": \"CommonOperatorReducer\",\n                \"about\": \"Reduces an EffectPhi node if all inputs are the same.\",\n                \"logic\": \"If all effect inputs to the EffectPhi are the same, replaces the EffectPhi with that single effect input. Revisit the merge node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The EffectPhi node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A Reduction object indicating the result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"IrOpcode::IsMergeOpcode\",\n                    \"Revisit\",\n                    \"Replace\",\n                    \"Node::inputs\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction CommonOperatorReducer::ReduceEffectPhi(Node* node) {\n  DCHECK_EQ(IrOpcode::kEffectPhi, node->opcode());\n  Node::Inputs inputs = node->inputs();\n  int const effect_input_count = inputs.count() - 1;\n  DCHECK_LE(1, effect_input_count);\n  Node* const merge = inputs[effect_input_count];\n  DCHECK(IrOpcode::IsMergeOpcode(merge->opcode()));\n  DCHECK_EQ(effect_input_count, merge->InputCount());\n  Node* const effect = inputs[0];\n  DCHECK_NE(node, effect);\n  for (int i = 1; i < effect_input_count; ++i) {\n    Node* const input = inputs[i];\n    if (input == node) {\n      // Ignore redundant inputs.\n      DCHECK_EQ(IrOpcode::kLoop, merge->opcode());\n      continue;\n    }\n    if (input != effect) return NoChange();\n  }\n  // We might now be able to further reduce the {merge} node.\n  Revisit(merge);\n  return Replace(effect);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReducePhi\",\n                \"parent\": \"CommonOperatorReducer\",\n                \"about\": \"Reduces a Phi node if all inputs are the same, or optimizes specific patterns like fabs(v).\",\n                \"logic\": \"If all value inputs to the Phi are the same, replaces the Phi with that single value input. Also attempts to recognize and optimize the pattern for fabs(v), or uses Word32Select if supported. Revisit the merge node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Phi node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A Reduction object indicating the result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"IrOpcode::IsMergeOpcode\",\n                    \"Revisit\",\n                    \"Replace\",\n                    \"Node::inputs\",\n                    \"Float32BinopMatcher\",\n                    \"Float64BinopMatcher\",\n                    \"Int32BinopMatcher\",\n                    \"machine->Float32Abs\",\n                    \"machine->Float64Abs\",\n                    \"machine->Word32Select\",\n                    \"graph->NewNode\",\n                    \"common->Int32Constant\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction CommonOperatorReducer::ReducePhi(Node* node) {\n  DCHECK_EQ(IrOpcode::kPhi, node->opcode());\n  Node::Inputs inputs = node->inputs();\n  int const value_input_count = inputs.count() - 1;\n  DCHECK_LE(1, value_input_count);\n  Node* const merge = inputs[value_input_count];\n  DCHECK(IrOpcode::IsMergeOpcode(merge->opcode()));\n  DCHECK_EQ(value_input_count, merge->InputCount());\n  if (value_input_count == 2) {\n    // The following optimization tries to match `0 < v ? v : 0 - v`, which\n    // corresponds in Turbofan to something like:\n    //\n    //       Branch(0 < v)\n    //         /      \\\n    //        /        \\\n    //       v        0 - v\n    //        \\        /\n    //         \\      /\n    //        phi(v, 0-v)\n    //\n    // And replace it by `fabs(v)`.\n    // TODO(dmercadier): it seems that these optimizations never kick in. While\n    // keeping them doesn't cost too much, we could consider removing them to\n    // simplify the code and not maintain unused pieces of code.\n    Node* vtrue = inputs[0];\n    Node* vfalse = inputs[1];\n    Node::Inputs merge_inputs = merge->inputs();\n    Node* if_true = merge_inputs[0];\n    Node* if_false = merge_inputs[1];\n    if (if_true->opcode() != IrOpcode::kIfTrue) {\n      std::swap(if_true, if_false);\n      std::swap(vtrue, vfalse);\n    }\n    if (if_true->opcode() == IrOpcode::kIfTrue &&\n        if_false->opcode() == IrOpcode::kIfFalse &&\n        if_true->InputAt(0) == if_false->InputAt(0)) {\n      Node* const branch = if_true->InputAt(0);\n      // Check that the branch is not dead already.\n      if (branch->opcode() != IrOpcode::kBranch) return NoChange();\n      Node* const cond = branch->InputAt(0);\n      if (cond->opcode() == IrOpcode::kFloat32LessThan) {\n        Float32BinopMatcher mcond(cond);\n        if (mcond.left().Is(0.0) && mcond.right().Equals(vtrue) &&\n            vfalse->opcode() == IrOpcode::kFloat32Sub) {\n          Float32BinopMatcher mvfalse(vfalse);\n          if (mvfalse.left().IsZero() && mvfalse.right().Equals(vtrue)) {\n            // We might now be able to further reduce the {merge} node.\n            Revisit(merge);\n            return Change(node, machine()->Float32Abs(), vtrue);\n          }\n        }\n      } else if (cond->opcode() == IrOpcode::kFloat64LessThan) {\n        Float64BinopMatcher mcond(cond);\n        if (mcond.left().Is(0.0) && mcond.right().Equals(vtrue) &&\n            vfalse->opcode() == IrOpcode::kFloat64Sub) {\n          Float64BinopMatcher mvfalse(vfalse);\n          if (mvfalse.left().IsZero() && mvfalse.right().Equals(vtrue)) {\n            // We might now be able to further reduce the {merge} node.\n            Revisit(merge);\n            return Change(node, machine()->Float64Abs(), vtrue);\n          }\n        }\n      } else if (cond->opcode() == IrOpcode::kInt32LessThan) {\n        Int32BinopMatcher mcond(cond);\n        if (mcond.left().Is(0) && mcond.right().Equals(vtrue) &&\n            (vfalse->opcode() == IrOpcode::kInt32Sub)) {\n          Int32BinopMatcher mvfalse(vfalse);\n          if (mvfalse.left().Is(0) && mvfalse.right().Equals(vtrue)) {\n            // We might now be able to further reduce the {merge} node.\n            Revisit(merge);\n\n            if (machine()->Word32Select().IsSupported()) {\n              // Select positive value with conditional move if is supported.\n              Node* abs = graph()->NewNode(machine()->Word32Select().op(), cond,\n                                           vtrue, vfalse);\n              return Replace(abs);\n            } else {\n              // Generate absolute integer value.\n              //\n              //    let sign = input >> 31 in\n              //    (input ^ sign) - sign\n              Node* sign = graph()->NewNode(\n                  machine()->Word32Sar(), vtrue,\n                  graph()->NewNode(common()->Int32Constant(31)));\n              Node* abs = graph()->NewNode(\n                  machine()->Int32Sub(),\n                  graph()->NewNode(machine()->Word32Xor(), vtrue, sign), sign);\n              return Replace(abs);\n            }\n          }\n        }\n      }\n    }\n  }\n  Node* const value = inputs[0];\n  DCHECK_NE(node, value);\n  for (int i = 1; i < value_input_count; ++i) {\n    Node* const input = inputs[i];\n    if (input == node) {\n      // Ignore redundant inputs.\n      DCHECK_EQ(IrOpcode::kLoop, merge->opcode());\n      continue;\n    }\n    if (input != value) return NoChange();\n  }\n  // We might now be able to further reduce the {merge} node.\n  Revisit(merge);\n  return Replace(value);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceReturn\",\n                \"parent\": \"CommonOperatorReducer\",\n                \"about\": \"Reduces a Return node by removing Checkpoint nodes or pushing the Return through merges.\",\n                \"logic\": \"Removes Checkpoint nodes from the effect chain of the Return node. If the Return node's value input is a Phi and the control input is a Merge, pushes the Return through the Merge, creating new Return nodes for each branch of the merge.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Return node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"A Reduction object indicating the result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"NodeProperties::GetEffectInput\",\n                    \"NodeProperties::ReplaceEffectInput\",\n                    \"ValueInputCountOfReturn\",\n                    \"NodeProperties::GetValueInput\",\n                    \"NodeProperties::GetControlInput\",\n                    \"Replace\",\n                    \"dead\",\n                    \"graph->end\",\n                    \"MergeControlToEnd\",\n                    \"graph\",\n                    \"common\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction CommonOperatorReducer::ReduceReturn(Node* node) {\n  DCHECK_EQ(IrOpcode::kReturn, node->opcode());\n  Node* effect = NodeProperties::GetEffectInput(node);\n  // TODO(mslekova): Port this to Turboshaft.\n  if (effect->opcode() == IrOpcode::kCheckpoint) {\n    // Any {Return} node can never be used to insert a deoptimization point,\n    // hence checkpoints can be cut out of the effect chain flowing into it.\n    "
}