{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/tasks/cancelable-task.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 56, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/tasks/cancelable-task.cc\",\n        \"file_name\": \"cancelable-task.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements cancelable tasks and a task manager for the V8 JavaScript engine.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for cancelable tasks and task management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/tasks/cancelable-task.h\"\n\n            #include \"src/execution/isolate.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Cancelable\",\n            \"about\": \"Base class for tasks that can be canceled.\",\n            \"attributes\": [\n                {\n                    \"name\": \"parent_\",\n                    \"type\": \"CancelableTaskManager*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the task manager that owns this task.\"\n                },\n                {\n                    \"name\": \"id_\",\n                    \"type\": \"CancelableTaskManager::Id\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Unique ID of this task within the task manager.\"\n                },\n                {\n                    \"name\": \"status_\",\n                    \"type\": \"std::atomic<Status>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Atomic status flag for task lifecycle management (pending, running, canceled, finished).\"\n                }\n            ],\n            \"dependencies\": [\n                \"CancelableTaskManager\",\n                \"Status\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class Cancelable {\n            public:\n                enum Status { kPending, kRunning, kCanceled, kFinished };\n                using Id = CancelableTaskManager::Id;\n                Cancelable(CancelableTaskManager* parent) : parent_(parent), id_(parent->Register(this)), status_(kPending) {}\n                virtual ~Cancelable();\n\n                virtual void Run() = 0;\n\n                bool Cancel() {\n                    Status previous = kPending;\n                    return status_.compare_exchange_strong(previous, kCanceled);\n                }\n\n                bool TryRun(Status* previous_status) {\n                    Status previous = kPending;\n                    if (status_.compare_exchange_strong(previous, kRunning)) {\n                        Run();\n                        status_.store(kFinished);\n                        if (previous_status) *previous_status = kPending;\n                        return true;\n                    } else {\n                        if (previous_status) *previous_status = previous;\n                        return false;\n                    }\n                }\n\n            protected:\n                CancelableTaskManager* parent_;\n                Id id_;\n                std::atomic<Status> status_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"~Cancelable\",\n            \"parent\": \"Cancelable\",\n            \"about\": \"Destructor for the Cancelable class.\",\n            \"logic\": \"Removes the finished task from the task manager, avoiding issues if the manager is already terminated.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            Cancelable::~Cancelable() {\n            // The following check is needed to avoid calling an already terminated\n            // manager object. This happens when the manager cancels all pending tasks\n            // in {CancelAndWait} only before destroying the manager object.\n            Status previous;\n            if (TryRun(&previous) || previous == kRunning) {\n                parent_->RemoveFinishedTask(id_);\n            }\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CancelableTaskManager\",\n            \"about\": \"Manages a set of cancelable tasks, allowing for cancellation and waiting.\",\n            \"attributes\": [\n                {\n                    \"name\": \"task_id_counter_\",\n                    \"type\": \"Id\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Counter for generating unique task IDs.\"\n                },\n                {\n                    \"name\": \"canceled_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Flag indicating whether the task manager has been canceled.\"\n                },\n                {\n                    \"name\": \"cancelable_tasks_\",\n                    \"type\": \"std::unordered_map<Id, Cancelable*>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Map of task IDs to Cancelable tasks.\"\n                },\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mutex to protect access to the task list.\"\n                },\n                {\n                    \"name\": \"cancelable_tasks_barrier_\",\n                    \"type\": \"base::Barrier\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Barrier to wait for running tasks to finish during cancellation.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Cancelable\",\n                \"Id\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CancelableTaskManager {\n            public:\n                using Id = size_t;  // Task identifier.\n\n                CancelableTaskManager();\n                ~CancelableTaskManager();\n\n                Id Register(Cancelable* task);\n                void RemoveFinishedTask(Id id);\n                TryAbortResult TryAbort(Id id);\n                void CancelAndWait();\n                TryAbortResult TryAbortAll();\n\n            private:\n                static constexpr Id kInvalidTaskId = 0;\n\n                Id task_id_counter_;\n                bool canceled_;\n                std::unordered_map<Id, Cancelable*> cancelable_tasks_;\n                base::Mutex mutex_;\n                base::Barrier cancelable_tasks_barrier_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"CancelableTaskManager\",\n            \"parent\": \"CancelableTaskManager\",\n            \"about\": \"Constructor for the CancelableTaskManager class.\",\n            \"logic\": \"Initializes the task ID counter and the canceled flag.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            CancelableTaskManager::CancelableTaskManager()\n                : task_id_counter_(kInvalidTaskId), canceled_(false) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"destructor\",\n            \"name\": \"~CancelableTaskManager\",\n            \"parent\": \"CancelableTaskManager\",\n            \"about\": \"Destructor for the CancelableTaskManager class.\",\n            \"logic\": \"Checks that CancelAndWait has been called before the manager is destroyed.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            CancelableTaskManager::~CancelableTaskManager() {\n            // It is required that {CancelAndWait} is called before the manager object is\n            // destroyed. This guarantees that all tasks managed by this\n            // {CancelableTaskManager} are either canceled or finished their execution\n            // when the {CancelableTaskManager} dies.\n            CHECK(canceled_);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Register\",\n            \"parent\": \"CancelableTaskManager\",\n            \"about\": \"Registers a cancelable task with the task manager.\",\n            \"logic\": \"Assigns a unique ID to the task and adds it to the task list. If the task manager is already canceled, the task is immediately canceled.\",\n            \"parameters\": [\n                {\n                    \"name\": \"task\",\n                    \"type\": \"Cancelable*\",\n                    \"purpose\": \"The task to register.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"CancelableTaskManager::Id\",\n                \"description\": \"The ID of the registered task.\"\n            },\n            \"dependencies\": [\n                \"Cancelable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            CancelableTaskManager::Id CancelableTaskManager::Register(Cancelable* task) {\n            base::MutexGuard guard(&mutex_);\n            if (canceled_) {\n                // The CancelableTaskManager has already been canceled. Therefore we mark\n                // the new task immediately as canceled so that it does not get executed.\n                task->Cancel();\n                return kInvalidTaskId;\n            }\n            CancelableTaskManager::Id id = ++task_id_counter_;\n            // Id overflows are not supported.\n            CHECK_NE(kInvalidTaskId, id);\n            CHECK(!canceled_);\n            cancelable_tasks_[id] = task;\n            return id;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RemoveFinishedTask\",\n            \"parent\": \"CancelableTaskManager\",\n            \"about\": \"Removes a finished task from the task manager.\",\n            \"logic\": \"Removes the task from the task list and notifies the barrier.\",\n            \"parameters\": [\n                {\n                    \"name\": \"id\",\n                    \"type\": \"CancelableTaskManager::Id\",\n                    \"purpose\": \"The ID of the task to remove.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void CancelableTaskManager::RemoveFinishedTask(CancelableTaskManager::Id id) {\n            CHECK_NE(kInvalidTaskId, id);\n            base::MutexGuard guard(&mutex_);\n            size_t removed = cancelable_tasks_.erase(id);\n            USE(removed);\n            DCHECK_NE(0u, removed);\n            cancelable_tasks_barrier_.NotifyOne();\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"TryAbortResult\",\n            \"about\": \"Enum for the result of TryAbort and TryAbortAll calls\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            enum class TryAbortResult { kTaskAborted, kTaskRunning, kTaskRemoved };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TryAbort\",\n            \"parent\": \"CancelableTaskManager\",\n            \"about\": \"Attempts to abort a specific task.\",\n            \"logic\": \"If the task exists and is pending, it is canceled.  Returns an enum indicating whether the task was aborted, is running, or was already removed.\",\n            \"parameters\": [\n                {\n                    \"name\": \"id\",\n                    \"type\": \"CancelableTaskManager::Id\",\n                    \"purpose\": \"The ID of the task to abort.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"TryAbortResult\",\n                \"description\": \"Result of the abort attempt.\"\n            },\n            \"dependencies\": [\n                \"Cancelable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            TryAbortResult CancelableTaskManager::TryAbort(CancelableTaskManager::Id id) {\n            CHECK_NE(kInvalidTaskId, id);\n            base::MutexGuard guard(&mutex_);\n            auto entry = cancelable_tasks_.find(id);\n            if (entry != cancelable_tasks_.end()) {\n                Cancelable* value = entry->second;\n                if (value->Cancel()) {\n                    // Cannot call RemoveFinishedTask here because of recursive locking.\n                    cancelable_tasks_.erase(entry);\n                    cancelable_tasks_barrier_.NotifyOne();\n                    return TryAbortResult::kTaskAborted;\n                } else {\n                    return TryAbortResult::kTaskRunning;\n                }\n            }\n            return TryAbortResult::kTaskRemoved;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CancelAndWait\",\n            \"parent\": \"CancelableTaskManager\",\n            \"about\": \"Cancels all registered tasks and waits for them to finish.\",\n            \"logic\": \"Iterates through the task list, canceling tasks. Waits for running tasks to finish using a barrier.  Repeats until all tasks are removed.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Cancelable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CancelableTaskManager::CancelAndWait() {\n            // Clean up all cancelable fore- and background tasks. Tasks are canceled on\n            // the way if possible, i.e., if they have not started yet.  After each round\n            // of canceling we wait for the background tasks that have already been\n            // started.\n            base::MutexGuard guard(&mutex_);\n            canceled_ = true;\n\n            // Cancelable tasks could be running or could potentially register new\n            // tasks, requiring a loop here.\n            while (!cancelable_tasks_.empty()) {\n                for (auto it = cancelable_tasks_.begin(); it != cancelable_tasks_.end();) {\n                auto current = it;\n                // We need to get to the next element before erasing the current.\n                ++it;\n                if (current->second->Cancel()) {\n                    cancelable_tasks_.erase(current);\n                }\n                }\n                // Wait for already running background tasks.\n                if (!cancelable_tasks_.empty()) {\n                cancelable_tasks_barrier_.Wait(&mutex_);\n                }\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TryAbortAll\",\n            \"parent\": \"CancelableTaskManager\",\n            \"about\": \"Attempts to abort all registered tasks.\",\n            \"logic\": \"Iterates through the task list, canceling tasks. Returns an enum indicating whether all tasks were aborted, or if some are still running.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"TryAbortResult\",\n                \"description\": \"Result of the abort attempt.\"\n            },\n            \"dependencies\": [\n                \"Cancelable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            TryAbortResult CancelableTaskManager::TryAbortAll() {\n            // Clean up all cancelable fore- and background tasks. Tasks are canceled on\n            // the way if possible, i.e., if they have not started yet.\n            base::MutexGuard guard(&mutex_);\n\n            if (cancelable_tasks_.empty()) return TryAbortResult::kTaskRemoved;\n\n            for (auto it = cancelable_tasks_.begin(); it != cancelable_tasks_.end();) {\n                if (it->second->Cancel()) {\n                it = cancelable_tasks_.erase(it);\n                } else {\n                ++it;\n                }\n            }\n\n            return cancelable_tasks_.empty() ? TryAbortResult::kTaskAborted\n                                            : TryAbortResult::kTaskRunning;\n            }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CancelableTask\",\n            \"extends\": \"Cancelable\",\n            \"about\": \"A simple cancelable task that takes an Isolate pointer in the constructor.\",\n            \"dependencies\": [\n                \"Cancelable\",\n                \"Isolate\",\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CancelableTask : public Cancelable {\n            public:\n                explicit CancelableTask(Isolate* isolate);\n                explicit CancelableTask(CancelableTaskManager* manager);\n\n            private:\n                void Run() override = delete;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"CancelableTask\",\n            \"parent\": \"CancelableTask\",\n            \"about\": \"Constructor for CancelableTask that takes an Isolate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to associate with the task.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            CancelableTask::CancelableTask(Isolate* isolate)\n                : CancelableTask(isolate->cancelable_task_manager()) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"CancelableTask\",\n            \"parent\": \"CancelableTask\",\n            \"about\": \"Constructor for CancelableTask that takes a CancelableTaskManager.\",\n            \"parameters\": [\n                {\n                    \"name\": \"manager\",\n                    \"type\": \"CancelableTaskManager*\",\n                    \"purpose\": \"The task manager to associate with the task.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            CancelableTask::CancelableTask(CancelableTaskManager* manager)\n                : Cancelable(manager) {}\n        ]]></code>\n    </func>\n    \n        <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CancelableIdleTask\",\n            \"extends\": \"Cancelable\",\n            \"about\": \"A simple cancelable idle task that takes an Isolate pointer in the constructor.\",\n            \"dependencies\": [\n                \"Cancelable\",\n                \"Isolate\",\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CancelableIdleTask : public Cancelable {\n            public:\n                explicit CancelableIdleTask(Isolate* isolate);\n                explicit CancelableIdleTask(CancelableTaskManager* manager);\n\n            private:\n                void Run() override = delete;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"CancelableIdleTask\",\n            \"parent\": \"CancelableIdleTask\",\n            \"about\": \"Constructor for CancelableIdleTask that takes an Isolate.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to associate with the task.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            CancelableIdleTask::CancelableIdleTask(Isolate* isolate)\n                : CancelableIdleTask(isolate->cancelable_task_manager()) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"constructor\",\n            \"name\": \"CancelableIdleTask\",\n            \"parent\": \"CancelableIdleTask\",\n            \"about\": \"Constructor for CancelableIdleTask that takes a CancelableTaskManager.\",\n            \"parameters\": [\n                {\n                    \"name\": \"manager\",\n                    \"type\": \"CancelableTaskManager*\",\n                    \"purpose\": \"The task manager to associate with the task.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value\"\n            },\n            \"dependencies\": [\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            CancelableIdleTask::CancelableIdleTask(CancelableTaskManager* manager)\n                : Cancelable(manager) {}\n        ]]></code>\n    </func>\n</file>\n```"
}