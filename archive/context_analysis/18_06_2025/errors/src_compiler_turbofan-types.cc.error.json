{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turbofan-types.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turbofan-types.cc\",\n            \"file_name\": \"turbofan-types.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the type system used in the Turbofan compiler, defining various type representations and operations such as intersection, union, and subtyping checks.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Include necessary headers for compiler types, standard library features, heap objects, and other V8 internals.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/turbofan-types.h\"\n\n#include <iomanip>\n\n#include \"src/compiler/js-heap-broker.h\"\n#include \"src/numbers/conversions-inl.h\"\n#include \"src/objects/elements-kind.h\"\n#include \"src/objects/instance-type.h\"\n#include \"src/objects/turbofan-types.h\"\n#include \"src/utils/ostreams.h\"\n\n#ifdef V8_ENABLE_WEBASSEMBLY\n#include \"src/wasm/wasm-subtyping.h\"\n#endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RangeType::Limits\",\n                \"about\": \"Represents the limits (min and max) of a numeric range.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"min\",\n                        \"type\": \"double\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The minimum value of the range.\"\n                    },\n                    {\n                        \"name\": \"max\",\n                        \"type\": \"double\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The maximum value of the range.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool RangeType::Limits::IsEmpty() { return this->min > this->max; }\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RangeType::Limits::Intersect\",\n                \"parent\": \"RangeType::Limits\",\n                \"about\": \"Calculates the intersection of two Limits objects, returning a new Limits object representing the overlapping range.\",\n                \"logic\": \"Determines the overlapping range by comparing the min and max values of both input ranges.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Limits\",\n                        \"purpose\": \"The first Limits object.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"Limits\",\n                        \"purpose\": \"The second Limits object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Limits\",\n                    \"description\": \"A new Limits object representing the intersection of the input ranges.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nRangeType::Limits RangeType::Limits::Intersect(Limits lhs, Limits rhs) {\n  DisallowGarbageCollection no_gc;\n  Limits result(lhs);\n  if (lhs.min < rhs.min) result.min = rhs.min;\n  if (lhs.max > rhs.max) result.max = rhs.max;\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"RangeType::Limits::Union\",\n                \"parent\": \"RangeType::Limits\",\n                \"about\": \"Calculates the union of two Limits objects, returning a new Limits object representing the combined range.\",\n                \"logic\": \"Determines the combined range by comparing the min and max values of both input ranges.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"Limits\",\n                        \"purpose\": \"The first Limits object.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"Limits\",\n                        \"purpose\": \"The second Limits object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Limits\",\n                    \"description\": \"A new Limits object representing the union of the input ranges.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nRangeType::Limits RangeType::Limits::Union(Limits lhs, Limits rhs) {\n  DisallowGarbageCollection no_gc;\n  if (lhs.IsEmpty()) return rhs;\n  if (rhs.IsEmpty()) return lhs;\n  Limits result(lhs);\n  if (lhs.min > rhs.min) result.min = rhs.min;\n  if (lhs.max < rhs.max) result.max = rhs.max;\n  return result;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Type::Overlap\",\n                \"parent\": \"Type\",\n                \"about\": \"Checks if two RangeType objects overlap.\",\n                \"logic\": \"Uses RangeType::Limits::Intersect to determine if the ranges have any intersection.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"const RangeType*\",\n                        \"purpose\": \"The first RangeType object.\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"const RangeType*\",\n                        \"purpose\": \"The second RangeType object.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the ranges overlap, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"RangeType::Limits::Intersect\",\n                    \"RangeType::Limits::IsEmpty\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool Type::Overlap(const RangeType* lhs, const RangeType* rhs) {\n  DisallowGarbageCollection no_gc;\n  return !RangeType::Limits::Intersect(RangeType::Limits(lhs),\n                                       RangeType::Limits(rhs))\n              .IsEmpty();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"Type::Contains\",\n                \"parent\": \"Type\",\n                \"about\": \"Checks if one RangeType object contains another.\",\n                \"logic\": \"Determines if the lhs RangeType's min and max values encompass the rhs RangeType's min and max values.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"lhs\",\n                        \"type\": \"const RangeType*\",\n                        \"purpose\": \"The first RangeType object (the container).\"\n                    },\n                    {\n                        \"name\": \"rhs\",\n                        \"type\": \"const RangeType*\",\n                        \"purpose\": \"The second RangeType object (the contained).\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the lhs range contains the rhs range, false otherwise.\"\n                },\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nbool Type::Contains(const RangeType* lhs, const RangeType* rhs) {\n  DisallowGarbageCollection no_gc;\n  return lhs->Min() <= rhs->Min() && rhs->Max() <= lhs->Max();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Type::Min\",\n                \"parent\": \"Type\",\n                \"about\": \"Computes the minimum value represented by the type.\",\n                \"logic\": \"Handles different type representations (Bitset, Union, Range, OtherNumberConstant) to determine the minimum value. For Union types, it iterates through the elements to find the overall minimum.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"double\",\n                    \"description\": \"The minimum value represented by the type.\"\n                },\n                \"dependencies\": [\n                    \"BitsetType::Min\",\n                    \"Type::AsUnion\",\n                    \"Type::AsRange\",\n                    \"Type::AsOtherNumberConstant\",\n                    \"Type::Value\",\n                    \"Type::Get\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ndouble Type::Min() const {\n  DCHECK(this->Is(Number()));\n  DCHECK(!this->Is(NaN()));\n  if (this->IsBitset()) return BitsetType::Min(this->AsBitset());\n  if (this->IsUnion()) {\n    double min = +V8_INFINITY;\n    for (int i = 1, n = AsUnion()->Length(); i < n; ++i) {\n      min = std::min(min, AsUnion()->Get(i).Min());\n    }\n    Type bitset = AsUnion()->Get(0);\n    if (!bitset.Is(NaN())) min = std::min(min, bitset.Min());\n    return min;\n  }\n  if (this->IsRange()) return this->AsRange()->Min();\n  DCHECK(this->IsOtherNumberConstant());\n  return this->AsOtherNumberConstant()->Value();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Type::Max\",\n                \"parent\": \"Type\",\n                \"about\": \"Computes the maximum value represented by the type.\",\n                \"logic\": \"Handles different type representations (Bitset, Union, Range, OtherNumberConstant) to determine the maximum value.  For Union types, it iterates through the elements to find the overall maximum.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"double\",\n                    \"description\": \"The maximum value represented by the type.\"\n                },\n                \"dependencies\": [\n                    \"BitsetType::Max\",\n                    \"Type::AsUnion\",\n                    \"Type::AsRange\",\n                    \"Type::AsOtherNumberConstant\",\n                    \"Type::Value\",\n                    \"Type::Get\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ndouble Type::Max() const {\n  DCHECK(this->Is(Number()));\n  DCHECK(!this->Is(NaN()));\n  if (this->IsBitset()) return BitsetType::Max(this->AsBitset());\n  if (this->IsUnion()) {\n    double max = -V8_INFINITY;\n    for (int i = 1, n = this->AsUnion()->Length(); i < n; ++i) {\n      max = std::max(max, this->AsUnion()->Get(i).Max());\n    }\n    Type bitset = this->AsUnion()->Get(0);\n    if (!bitset.Is(NaN())) max = std::max(max, bitset.Max());\n    return max;\n  }\n  if (this->IsRange()) return this->AsRange()->Max();\n  DCHECK(this->IsOtherNumberConstant());\n  return this->AsOtherNumberConstant()->Value();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Type::BitsetGlb\",\n                \"parent\": \"Type\",\n                \"about\": \"Computes the greatest lower bound bitset (Glb) of the type.\",\n                \"logic\": \"Determines the largest bitset that is subsumed by the type.  Handles Bitset, Union, and Range types.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Type::bitset\",\n                    \"description\": \"The greatest lower bound bitset.\"\n                },\n                \"dependencies\": [\n                    \"Type::IsBitset\",\n                    \"Type::IsUnion\",\n                    \"Type::IsRange\",\n                    \"Type::AsBitset\",\n                    \"Type::AsUnion\",\n                    \"Type::AsRange\",\n                    \"BitsetType::Glb\",\n                    \"Type::Get\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nType::bitset Type::BitsetGlb() const {\n  DisallowGarbageCollection no_gc;\n  // Fast case.\n  if (IsBitset()) {\n    return AsBitset();\n  } else if (IsUnion()) {\n    SLOW_DCHECK(AsUnion()->Wellformed());\n    return AsUnion()->Get(0).BitsetGlb() |\n           AsUnion()->Get(1).BitsetGlb();  // Shortcut.\n  } else if (IsRange()) {\n    bitset glb = BitsetType::Glb(AsRange()->Min(), AsRange()->Max());\n    return glb;\n  } else {\n    return BitsetType::kNone;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Type::BitsetLub\",\n                \"parent\": \"Type\",\n                \"about\": \"Computes the least upper bound bitset (Lub) of the type.\",\n                \"logic\": \"Determines the smallest bitset that subsumes the type. Handles Bitset, Union, HeapConstant, OtherNumberConstant and Range Types.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"Type::bitset\",\n                    \"description\": \"The least upper bound bitset.\"\n                },\n                \"dependencies\": [\n                    \"Type::IsBitset\",\n                    \"Type::IsUnion\",\n                    \"Type::IsHeapConstant\",\n                    \"Type::IsOtherNumberConstant\",\n                    \"Type::IsRange\",\n                    \"Type::IsTuple\",\n                    \"Type::AsBitset\",\n                    \"Type::AsUnion\",\n                    \"Type::AsHeapConstant\",\n                    \"Type::AsOtherNumberConstant\",\n                    \"Type::AsRange\",\n                    \"HeapConstantType::Lub\",\n                    \"OtherNumberConstantType::Lub\",\n                    \"BitsetType::kOtherInternal\",\n                    \"Type::Get\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nType::bitset Type::BitsetLub() const {\n  DisallowGarbageCollection no_gc;\n  if (IsBitset()) return AsBitset();\n  if (IsUnion()) {\n    // Take the representation from the first element, which is always\n    // a bitset.\n    bitset lub = AsUnion()->Get(0).BitsetLub();\n    for (int i = 0, n = AsUnion()->Length(); i < n; ++i) {\n      // Other elements only contribute their semantic part.\n      lub |= AsUnion()->Get(i).BitsetLub();\n    }\n    return lub;\n  }\n  if (IsHeapConstant()) return AsHeapConstant()->Lub();\n  if (IsOtherNumberConstant()) {\n    return AsOtherNumberConstant()->Lub();\n  }\n  if (IsRange()) return AsRange()->Lub();\n  if (IsTuple()) return BitsetType::kOtherInternal;\n#if V8_ENABLE_WEBASSEMBLY\n  if (IsWasm()) return static_cast<const WasmType*>(ToTypeBase())->Lub();\n#endif\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitsetType::Lub\",\n                \"about\": \"Computes the least upper bound bitset for a given map object.\",\n                \"logic\": \"Uses a switch statement based on the instance type of the map to determine the appropriate bitset.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"map\",\n                        \"type\": \"MapRefLike\",\n                        \"purpose\": \"The map object.\"\n                    },\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"The JSHeapBroker used for accessing heap object properties.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type::bitset\",\n                    \"description\": \"The least upper bound bitset.\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"MapRefLike\",\n                    \"ElementsKind\",\n                    \"OddballType\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename MapRefLike>\nType::bitset BitsetType::Lub(MapRefLike map, JSHeapBroker* broker) {\n  switch (map.instance_type()) {\n    case CONS_TWO_BYTE_STRING_TYPE:\n    case CONS_ONE_BYTE_STRING_TYPE:\n    case THIN_TWO_BYTE_STRING_TYPE:\n    case THIN_ONE_BYTE_STRING_TYPE:\n    case SLICED_TWO_BYTE_STRING_TYPE:\n    case SLICED_ONE_BYTE_STRING_TYPE:\n    case EXTERNAL_TWO_BYTE_STRING_TYPE:\n    case EXTERNAL_ONE_BYTE_STRING_TYPE:\n    case UNCACHED_EXTERNAL_TWO_BYTE_STRING_TYPE:\n    case UNCACHED_EXTERNAL_ONE_BYTE_STRING_TYPE:\n    case SEQ_TWO_BYTE_STRING_TYPE:\n    case SEQ_ONE_BYTE_STRING_TYPE:\n    case SHARED_SEQ_TWO_BYTE_STRING_TYPE:\n    case SHARED_SEQ_ONE_BYTE_STRING_TYPE:\n    case SHARED_EXTERNAL_TWO_BYTE_STRING_TYPE:\n    case SHARED_EXTERNAL_ONE_BYTE_STRING_TYPE:\n    case SHARED_UNCACHED_EXTERNAL_TWO_BYTE_STRING_TYPE:\n    case SHARED_UNCACHED_EXTERNAL_ONE_BYTE_STRING_TYPE:\n      return kString;\n    case EXTERNAL_INTERNALIZED_TWO_BYTE_STRING_TYPE:\n    case EXTERNAL_INTERNALIZED_ONE_BYTE_STRING_TYPE:\n    case UNCACHED_EXTERNAL_INTERNALIZED_TWO_BYTE_STRING_TYPE:\n    case UNCACHED_EXTERNAL_INTERNALIZED_ONE_BYTE_STRING_TYPE:\n    case INTERNALIZED_TWO_BYTE_STRING_TYPE:\n    case INTERNALIZED_ONE_BYTE_STRING_TYPE:\n      return kInternalizedString;\n    case SYMBOL_TYPE:\n      return kSymbol;\n    case BIGINT_TYPE:\n      return kBigInt;\n    case ODDBALL_TYPE:\n      switch (map.oddball_type(broker)) {\n        case OddballType::kNone:\n          break;\n        case OddballType::kBoolean:\n          return kBoolean;\n        case OddballType::kNull:\n          return kNull;\n        case OddballType::kUndefined:\n          return kUndefined;\n      }\n      UNREACHABLE();\n    case HOLE_TYPE:\n      // Holes have a single map and we should have distinguished them earlier\n      // by pointer comparison on the value.\n      UNREACHABLE();\n    case HEAP_NUMBER_TYPE:\n      return kNumber;\n    case JS_ARRAY_ITERATOR_PROTOTYPE_TYPE:\n    case JS_ITERATOR_PROTOTYPE_TYPE:\n    case JS_MAP_ITERATOR_PROTOTYPE_TYPE:\n    case JS_OBJECT_PROTOTYPE_TYPE:\n    case JS_OBJECT_TYPE:\n    case JS_PROMISE_PROTOTYPE_TYPE:\n    case JS_REG_EXP_PROTOTYPE_TYPE:\n    case JS_SET_ITERATOR_PROTOTYPE_TYPE:\n    case JS_SET_PROTOTYPE_TYPE:\n    case JS_STRING_ITERATOR_PROTOTYPE_TYPE:\n    case JS_ARGUMENTS_OBJECT_TYPE:\n    case JS_ERROR_TYPE:\n    case JS_EXTERNAL_OBJECT_TYPE:\n    case JS_GLOBAL_OBJECT_TYPE:\n    case JS_GLOBAL_PROXY_TYPE:\n    case JS_API_OBJECT_TYPE:\n    case JS_SPECIAL_API_OBJECT_TYPE:\n    case JS_TYPED_ARRAY_PROTOTYPE_TYPE:\n      if (map.is_undetectable()) {\n        // Currently we assume that every undetectable receiver is also\n        // callable, which is what we need to support document.all.  We\n        // could add another Type bit to support other use cases in the\n        // future if necessary.\n        DCHECK(map.is_callable());\n        return kOtherUndetectable;\n      }\n      if (map.is_callable()) {\n        return kOtherCallable;\n      }\n      return kOtherObject;\n    case JS_ARRAY_TYPE:\n      return kArray;\n    case JS_PRIMITIVE_WRAPPER_TYPE: {\n      DCHECK(!map.is_callable());\n      DCHECK(!map.is_undetectable());\n      auto elements_kind = map.elements_kind();\n      if (elements_kind == ElementsKind::FAST_STRING_WRAPPER_ELEMENTS ||\n          elements_kind == ElementsKind::SLOW_STRING_WRAPPER_ELEMENTS) {\n        return kStringWrapper;\n      }\n      return kOtherObject;\n    }\n    case JS_MESSAGE_OBJECT_TYPE:\n    case JS_DATE_TYPE:\n#ifdef V8_INTL_SUPPORT\n    case JS_V8_BREAK_ITERATOR_TYPE:\n    case JS_COLLATOR_TYPE:\n    case JS_DATE_TIME_FORMAT_TYPE:\n    case JS_DISPLAY_NAMES_TYPE:\n    case JS_DURATION_FORMAT_TYPE:\n    case JS_LIST_FORMAT_TYPE:\n    case JS_LOCALE_TYPE:\n    case JS_NUMBER_FORMAT_TYPE:\n    case JS_PLURAL_RULES_TYPE:\n    case JS_RELATIVE_TIME_FORMAT_TYPE:\n    case JS_SEGMENT_ITERATOR_TYPE:\n    case JS_SEGMENTER_TYPE:\n    case JS_SEGMENTS_TYPE:\n#endif  // V8_INTL_SUPPORT\n    case JS_CONTEXT_EXTENSION_OBJECT_TYPE:\n    case JS_DISPOSABLE_STACK_BASE_TYPE:\n    case JS_ASYNC_DISPOSABLE_STACK_TYPE:\n    case JS_SYNC_DISPOSABLE_STACK_TYPE:\n    case JS_GENERATOR_OBJECT_TYPE:\n    case JS_ASYNC_FUNCTION_OBJECT_TYPE:\n    case JS_ASYNC_GENERATOR_OBJECT_TYPE:\n    case JS_MODULE_NAMESPACE_TYPE:\n    case JS_ARRAY_BUFFER_TYPE:\n    case JS_ARRAY_ITERATOR_TYPE:\n    case JS_REG_EXP_TYPE:\n    case JS_REG_EXP_STRING_ITERATOR_TYPE:\n    case JS_DATA_VIEW_TYPE:\n    case JS_RAB_GSAB_DATA_VIEW_TYPE:\n    case JS_SET_TYPE:\n    case JS_MAP_TYPE:\n    case JS_SET_KEY_VALUE_ITERATOR_TYPE:\n    case JS_SET_VALUE_ITERATOR_TYPE:\n    case JS_MAP_KEY_ITERATOR_TYPE:\n    case JS_MAP_KEY_VALUE_ITERATOR_TYPE:\n    case JS_MAP_VALUE_ITERATOR_TYPE:\n    case JS_STRING_ITERATOR_TYPE:\n    case JS_ASYNC_FROM_SYNC_ITERATOR_TYPE:\n    case JS_ITERATOR_MAP_HELPER_TYPE:\n    case JS_ITERATOR_FILTER_HELPER_TYPE:\n    case JS_ITERATOR_TAKE_HELPER_TYPE:\n    case JS_ITERATOR_DROP_HELPER_TYPE:\n    case JS_ITERATOR_FLAT_MAP_HELPER_TYPE:\n    case JS_VALID_ITERATOR_WRAPPER_TYPE:\n    case JS_FINALIZATION_REGISTRY_TYPE:\n    case JS_WEAK_MAP_TYPE:\n    case JS_WEAK_REF_TYPE:\n    case JS_WEAK_SET_TYPE:\n    case JS_PROMISE_TYPE:\n    case JS_SHADOW_REALM_TYPE:\n    case JS_SHARED_ARRAY_TYPE:\n    case JS_SHARED_STRUCT_TYPE:\n    case JS_ATOMICS_CONDITION_TYPE:\n    case JS_ATOMICS_MUTEX_TYPE:\n    case JS_TEMPORAL_CALENDAR_TYPE:\n    case JS_TEMPORAL_DURATION_TYPE:\n    case JS_TEMPORAL_INSTANT_TYPE:\n    case JS_TEMPORAL_PLAIN_DATE_TYPE:\n    case JS_TEMPORAL_PLAIN_DATE_TIME_TYPE:\n    case JS_TEMPORAL_PLAIN_MONTH_DAY_TYPE:\n    case JS_TEMPORAL_PLAIN_TIME_TYPE:\n    case JS_TEMPORAL_PLAIN_YEAR_MONTH_TYPE:\n    case JS_TEMPORAL_TIME_ZONE_TYPE:\n    case JS_TEMPORAL_ZONED_DATE_TIME_TYPE:\n    case JS_RAW_JSON_TYPE:\n#if V8_ENABLE_WEBASSEMBLY\n    case WASM_GLOBAL_OBJECT_TYPE:\n    case WASM_INSTANCE_OBJECT_TYPE:\n    case WASM_MEMORY_OBJECT_TYPE:\n    case WASM_MODULE_OBJECT_TYPE:\n    case WASM_SUSPENDER_OBJECT_TYPE:\n    case WASM_SUSPENDING_OBJECT_TYPE:\n    case WASM_TABLE_OBJECT_TYPE:\n    case WASM_TAG_OBJECT_TYPE:\n    case WASM_EXCEPTION_PACKAGE_TYPE:\n    case WASM_VALUE_OBJECT_TYPE:\n#endif  // V8_ENABLE_WEBASSEMBLY\n    case WEAK_CELL_TYPE:\n      DCHECK(!map.is_callable());\n      DCHECK(!map.is_undetectable());\n      return kOtherObject;\n#if V8_ENABLE_WEBASSEMBLY\n    case WASM_STRUCT_TYPE:\n    case WASM_ARRAY_TYPE:\n      return kWasmObject;\n#endif  // V8_ENABLE_WEBASSEMBLY\n    case JS_BOUND_FUNCTION_TYPE:\n      DCHECK(!map.is_undetectable());\n      return kBoundFunction;\n    case JS_WRAPPED_FUNCTION_TYPE:\n      DCHECK(!map.is_undetectable());\n      return kOtherCallable;\n    case JS_FUNCTION_TYPE:\n    case JS_PROMISE_CONSTRUCTOR_TYPE:\n    case JS_REG_EXP_CONSTRUCTOR_TYPE:\n    case JS_ARRAY_CONSTRUCTOR_TYPE:\n#define TYPED_ARRAY_CONSTRUCTORS_SWITCH(Type, type, TYPE, Ctype) \\\n  case TYPE##_TYPED_ARRAY_CONSTRUCTOR_TYPE:\n      TYPED_ARRAYS(TYPED_ARRAY_CONSTRUCTORS_SWITCH)\n#undef TYPED_ARRAY_CONSTRUCTORS_SWITCH\n      DCHECK(!map.is_undetectable());\n      return kCallableFunction;\n    case JS_TYPED_ARRAY_TYPE:\n      DCHECK(!map.is_callable());\n      DCHECK(!map.is_undetectable());\n      return kTypedArray;\n    case JS_CLASS_CONSTRUCTOR_TYPE:\n      return kClassConstructor;\n    case JS_PROXY_TYPE:\n      DCHECK(!map.is_undetectable());\n      if (map.is_callable()) return kCallableProxy;\n      return kOtherProxy;\n    case MAP_TYPE:\n    case ALLOCATION_SITE_TYPE:\n    case ACCESSOR_INFO_TYPE:\n    case SHARED_FUNCTION_INFO_TYPE:\n    case FUNCTION_TEMPLATE_INFO_TYPE:\n    case FUNCTION_TEMPLATE_RARE_DATA_TYPE:\n    case ACCESSOR_PAIR_TYPE:\n    case EMBEDDER_DATA_ARRAY_TYPE:\n    case FIXED_ARRAY_TYPE:\n    case CLASS_BOILERPLATE_TYPE:\n    case PROPERTY_DESCRIPTOR_OBJECT_TYPE:\n    case HASH_TABLE_TYPE:\n    case ORDERED_HASH_MAP_TYPE:\n    case ORDERED_HASH_SET_TYPE:\n    case ORDERED_NAME_DICTIONARY_TYPE:\n    case NAME_DICTIONARY_TYPE:\n    case GLOBAL_DICTIONARY_TYPE:\n    case NUMBER_DICTIONARY_TYPE:\n    case SIMPLE_NUMBER_DICTIONARY_TYPE:\n    case EPHEMERON_HASH_TABLE_TYPE:\n    case WEAK_FIXED_ARRAY_TYPE:\n    case WEAK_ARRAY_LIST_TYPE:\n    case FIXED_DOUBLE_ARRAY_TYPE:\n    case FEEDBACK_METADATA_TYPE:\n    case BYTE_ARRAY_TYPE:\n    case BYTECODE_ARRAY_TYPE:\n    case OBJECT_BOILERPLATE_DESCRIPTION_TYPE:\n    case ARRAY_BOILERPLATE_DESCRIPTION_TYPE:\n    case REG_EXP_BOILERPLATE_DESCRIPTION_TYPE:\n    case TRANSITION_ARRAY_TYPE:\n    case FEEDBACK_CELL_TYPE:\n    case CLOSURE_FEEDBACK_CELL_ARRAY_TYPE:\n    case FEEDBACK_VECTOR_TYPE:\n    case PROPERTY_ARRAY_TYPE:\n    case FOREIGN_TYPE:\n    case SCOPE_INFO_TYPE:\n    case SCRIPT_CONTEXT_TABLE_TYPE:\n    case AWAIT_CONTEXT_TYPE:\n    case BLOCK_CONTEXT_TYPE:\n    case CATCH_CONTEXT_TYPE:\n    case DEBUG_EVALUATE_CONTEXT_TYPE:\n    case EVAL_CONTEXT_TYPE:\n    case FUNCTION_CONTEXT_TYPE:\n    case MODULE_CONTEXT_TYPE:\n    case MODULE_REQUEST_TYPE:\n    case NATIVE_CONTEXT_TYPE:\n    case SCRIPT_CONTEXT_TYPE:\n    case WITH_CONTEXT_TYPE:\n    case SCRIPT_TYPE:\n    case INSTRUCTION_STREAM_TYPE:\n    case CODE_TYPE:\n    case PROPERTY_CELL_TYPE:\n    case CONTEXT_SIDE_PROPERTY_CELL_TYPE:\n    case SOURCE_TEXT_MODULE_TYPE:\n    case SOURCE_TEXT_MODULE_INFO_ENTRY_TYPE:\n    case SYNTHETIC_MODULE_TYPE:\n    case CELL_TYPE:\n    case PREPARSE_DATA_TYPE:\n    case UNCOMPILED_DATA_WITHOUT_PREPARSE_DATA_TYPE:\n    case UNCOMPILED_DATA_WITH_PREPARSE_DATA_TYPE:\n    case COVERAGE_INFO_TYPE:\n    case REG_EXP_DATA_TYPE:\n    case ATOM_REG_EXP_DATA_TYPE:\n    case IR_REG_EXP_DATA_TYPE:\n#if V8_ENABLE_WEBASSEMBLY\n    case WASM_TYPE_INFO_TYPE:\n#endif  // V8_ENABLE_WEBASSEMBLY\n      return kOtherInternal;\n\n    // Remaining instance types are unsupported for now. If any of them do\n    // require bit set types, they should get kOtherInternal.\n    default:\n      UNREACHABLE();\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitsetType::Lub\",\n                \"about\": \"Computes the least upper bound bitset for a given double value.\",\n                \"logic\": \"Checks for special double values like MinusZero and NaN, otherwise uses a helper Lub function for general double values.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"value\",\n                        \"type\": \"double\",\n                        \"purpose\": \"The double value.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type::bitset\",\n                    \"description\": \"The least upper bound bitset.\"\n                },\n                \"dependencies\": [\n                    \"IsMinusZero\",\n                    \"std::isnan\",\n                    \"IsUint32Double\",\n                    \"IsInt32Double\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nType::bitset BitsetType::Lub(double value) {\n  DisallowGarbageCollection no_gc;\n  if (IsMinusZero(value)) return kMinusZero;\n  if (std::isnan(value)) return kNaN;\n  if (IsUint32Double(value) || IsInt32Double(value)) return Lub(value, value);\n  return kOtherNumber;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"BitsetType::Boundary\",\n                \"about\": \"Represents a boundary between different numeric bitsets.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"internal\",\n                        \"type\": \"Type::bitset\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The internal bitset.\"\n                    },\n                    {\n                        \"name\": \"external\",\n                        \"type\": \"Type::bitset\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The external bitset.\"\n                    },\n                    {\n                        \"name\": \"min\",\n                        \"type\": \"double\",\n                        \"access\": \"public\",\n                        \"purpose\": \"The minimum value for this boundary.\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\nconst BitsetType::Boundary BitsetType::BoundariesArray[] = {\n    {kOtherNumber, kPlainNumber, -V8_INFINITY},\n    {kOtherSigned32, kNegative32, kMinInt},\n    {kNegative31, kNegative31, -0x40000000},\n    {kUnsigned30, kUnsigned30, 0},\n    {kOtherUnsigned31, kUnsigned31, 0x40000000},\n    {kOtherUnsigned32, kUnsigned32, 0x80000000},\n    {kOtherNumber, kPlainNumber, static_cast<double>(kMaxUInt32) + 1}};\n\nconst BitsetType::Boundary* BitsetType::Boundaries() { return BoundariesArray; }\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"BitsetType::ExpandInternals\",\n                \"about\": \"Expands internal bitsets to include their corresponding external bitsets.\",\n                \"logic\": \"Iterates through the boundaries and sets the external bit if the internal bit is set.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"bits\",\n                        \"type\": \"Type::bitset\",\n                        \"purpose\": \"The input bitset.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Type::bitset\",\n                    \"description\": \"The expanded bitset.\"\n                },\n                \"dependencies\": [\n                    \"BitsetType::Is\",\n                    \"BitsetType::Boundaries"
}