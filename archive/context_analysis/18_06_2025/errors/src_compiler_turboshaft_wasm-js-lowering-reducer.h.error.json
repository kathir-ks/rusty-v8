{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-js-lowering-reducer.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 177, column 6",
  "raw_response": "```xml\n<file>\n  <metadata>\n    {\n      \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/wasm-js-lowering-reducer.h\",\n      \"file_name\": \"wasm-js-lowering-reducer.h\",\n      \"language\": \"cpp\",\n      \"purpose\": \"Defines a Turboshaft reducer that lowers WebAssembly nodes in the JavaScript pipeline by replacing TrapIf nodes with conditional gotos to trap builtins.\"\n    }\n  </metadata>\n  <imports>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"purpose\": \"Includes necessary headers for assembler, operations, phases, and Wasm graph assembly.\"\n      }\n    </metadata>\n    <code><![CDATA[\n#include \"src/compiler/turboshaft/assembler.h\"\n#include \"src/compiler/turboshaft/operations.h\"\n#include \"src/compiler/turboshaft/phase.h\"\n#include \"src/compiler/wasm-graph-assembler.h\"\n    ]]></code>\n  </imports>\n  <class>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"class\",\n        \"name\": \"WasmJSLoweringReducer\",\n        \"extends\": \"Next\",\n        \"about\": \"A Turboshaft reducer that lowers WebAssembly nodes in the JavaScript pipeline.\",\n        \"attributes\": [\n          {\n            \"name\": \"isolate_\",\n            \"type\": \"Isolate*\",\n            \"access\": \"private\",\n            \"purpose\": \"Pointer to the Isolate object (V8's global context).\"\n          },\n          {\n            \"name\": \"source_positions_\",\n            \"type\": \"SourcePositionTable*\",\n            \"access\": \"private\",\n            \"purpose\": \"Pointer to the source position table.\"\n          }\n        ],\n        \"dependencies\": [\n          \"TrapIf\",\n          \"FrameState\",\n          \"Word32\",\n          \"None\",\n          \"OptionalV\",\n          \"FrameState\",\n          \"Builtin\",\n          \"CallDescriptor\",\n          \"TSCallDescriptor\",\n          \"FrameStateOp\",\n          \"FrameStateData\",\n          \"FrameStateInfo\",\n          \"AnyOrNone\",\n          \"Isolate\",\n          \"SourcePositionTable\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\ntemplate <class Next>\nclass WasmJSLoweringReducer : public Next {\n public:\n  TURBOSHAFT_REDUCER_BOILERPLATE(WasmJSLowering)\n\n  V<None> REDUCE(TrapIf)(V<Word32> condition, OptionalV<FrameState> frame_state,\n                         bool negated, TrapId trap_id) {\n    // All TrapIf nodes in JS need to have a FrameState.\n    DCHECK(frame_state.valid());\n    Builtin trap = static_cast<Builtin>(trap_id);\n    // The call is not marked as Operator::kNoDeopt. While it cannot actually\n    // deopt, deopt info based on the provided FrameState is required for stack\n    // trace creation of the wasm trap.\n    const bool needs_frame_state = true;\n    const CallDescriptor* tf_descriptor = GetBuiltinCallDescriptor(\n        trap, Asm().graph_zone(), StubCallMode::kCallBuiltinPointer,\n        needs_frame_state, Operator::kNoProperties);\n    const TSCallDescriptor* ts_descriptor =\n        TSCallDescriptor::Create(tf_descriptor, CanThrow::kYes,\n                                 LazyDeoptOnThrow::kNo, Asm().graph_zone());\n\n    V<FrameState> new_frame_state =\n        CreateFrameStateWithUpdatedBailoutId(frame_state.value());\n    V<Word32> should_trap = negated ? __ Word32Equal(condition, 0) : condition;\n    IF (UNLIKELY(should_trap)) {\n      OpIndex call_target = __ NumberConstant(static_cast<int>(trap));\n      __ Call(call_target, new_frame_state, {}, ts_descriptor);\n      __ Unreachable();  // The trap builtin never returns.\n    }\n\n    return V<None>::Invalid();\n  }\n\n private:\n  OpIndex CreateFrameStateWithUpdatedBailoutId(V<FrameState> frame_state) {\n    // Create new FrameState with the correct source position (the position of\n    // the trap location).\n    const FrameStateOp& frame_state_op =\n        Asm().output_graph().Get(frame_state).template Cast<FrameStateOp>();\n    const FrameStateData* data = frame_state_op.data;\n    const FrameStateInfo& info = data->frame_state_info;\n\n    V<AnyOrNone> origin = Asm().current_operation_origin();\n    DCHECK(origin.valid());\n    int offset = __ input_graph().source_positions()[origin].ScriptOffset();\n\n    const FrameStateInfo* new_info =\n        Asm().graph_zone()->template New<FrameStateInfo>(\n            BytecodeOffset(offset), info.state_combine(), info.function_info());\n    FrameStateData* new_data = Asm().graph_zone()->template New<FrameStateData>(\n        FrameStateData{*new_info, data->instructions, data->machine_types,\n                       data->int_operands});\n    return __ FrameState(frame_state_op.inputs(), frame_state_op.inlined,\n                         new_data);\n  }\n\n  Isolate* isolate_ = __ data() -> isolate();\n  SourcePositionTable* source_positions_ = __ data() -> source_positions();\n};\n    ]]></code>\n  </class>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"REDUCE(TrapIf)\",\n        \"parent\": \"WasmJSLoweringReducer\",\n        \"about\": \"Reduces a TrapIf node by replacing it with a conditional goto to a trap builtin.\",\n        \"logic\": \"The reducer checks the condition of the TrapIf node. If the condition is true (or false if negated), it calls the corresponding trap builtin with the appropriate FrameState.  It creates a new FrameState with the correct source position (the position of the trap location).\",\n        \"parameters\": [\n          {\n            \"name\": \"condition\",\n            \"type\": \"V<Word32>\",\n            \"purpose\": \"The condition to check for the trap.\"\n          },\n          {\n            \"name\": \"frame_state\",\n            \"type\": \"OptionalV<FrameState>\",\n            \"purpose\": \"The FrameState associated with the trap.\"\n          },\n          {\n            \"name\": \"negated\",\n            \"type\": \"bool\",\n            \"purpose\": \"Indicates whether the condition is negated.\"\n          },\n          {\n            \"name\": \"trap_id\",\n            \"type\": \"TrapId\",\n            \"purpose\": \"The ID of the trap to call.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"V<None>\",\n          \"description\": \"Invalid V<None> if the trap is not taken, otherwise it does not return (Unreachable).\"\n        },\n        \"dependencies\": [\n          \"FrameState\",\n          \"Word32\",\n          \"None\",\n          \"Builtin\",\n          \"CallDescriptor\",\n          \"TSCallDescriptor\",\n          \"CreateFrameStateWithUpdatedBailoutId\",\n          \"Word32Equal\",\n          \"UNLIKELY\",\n          \"NumberConstant\",\n          \"Call\",\n          \"Unreachable\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n  V<None> REDUCE(TrapIf)(V<Word32> condition, OptionalV<FrameState> frame_state,\n                         bool negated, TrapId trap_id) {\n    // All TrapIf nodes in JS need to have a FrameState.\n    DCHECK(frame_state.valid());\n    Builtin trap = static_cast<Builtin>(trap_id);\n    // The call is not marked as Operator::kNoDeopt. While it cannot actually\n    // deopt, deopt info based on the provided FrameState is required for stack\n    // trace creation of the wasm trap.\n    const bool needs_frame_state = true;\n    const CallDescriptor* tf_descriptor = GetBuiltinCallDescriptor(\n        trap, Asm().graph_zone(), StubCallMode::kCallBuiltinPointer,\n        needs_frame_state, Operator::kNoProperties);\n    const TSCallDescriptor* ts_descriptor =\n        TSCallDescriptor::Create(tf_descriptor, CanThrow::kYes,\n                                 LazyDeoptOnThrow::kNo, Asm().graph_zone());\n\n    V<FrameState> new_frame_state =\n        CreateFrameStateWithUpdatedBailoutId(frame_state.value());\n    V<Word32> should_trap = negated ? __ Word32Equal(condition, 0) : condition;\n    IF (UNLIKELY(should_trap)) {\n      OpIndex call_target = __ NumberConstant(static_cast<int>(trap));\n      __ Call(call_target, new_frame_state, {}, ts_descriptor);\n      __ Unreachable();  // The trap builtin never returns.\n    }\n\n    return V<None>::Invalid();\n  }\n    ]]></code>\n  </func>\n  <func>\n    <metadata>\n      {\n        \"language\": \"cpp\",\n        \"type\": \"method\",\n        \"name\": \"CreateFrameStateWithUpdatedBailoutId\",\n        \"parent\": \"WasmJSLoweringReducer\",\n        \"about\": \"Creates a new FrameState with the correct source position (the position of the trap location).\",\n        \"logic\": \"Gets the FrameStateOp from the input graph, extracts the FrameStateData and FrameStateInfo.  Gets the current operation origin and its script offset from the source position table.  Creates a new FrameStateInfo and FrameStateData with the updated script offset.  Finally, creates a new FrameState.\",\n        \"parameters\": [\n          {\n            \"name\": \"frame_state\",\n            \"type\": \"V<FrameState>\",\n            \"purpose\": \"The original FrameState.\"\n          }\n        ],\n        \"return\": {\n          \"type\": \"OpIndex\",\n          \"description\": \"The index of the newly created FrameState operation.\"\n        },\n        \"dependencies\": [\n          \"FrameState\",\n          \"FrameStateOp\",\n          \"FrameStateData\",\n          \"FrameStateInfo\",\n          \"AnyOrNone\",\n          \"BytecodeOffset\",\n          \"New\",\n          \"FrameStateData\",\n          \"FrameState\"\n        ]\n      }\n    </metadata>\n    <code><![CDATA[\n  OpIndex CreateFrameStateWithUpdatedBailoutId(V<FrameState> frame_state) {\n    // Create new FrameState with the correct source position (the position of\n    // the trap location).\n    const FrameStateOp& frame_state_op =\n        Asm().output_graph().Get(frame_state).template Cast<FrameStateOp>();\n    const FrameStateData* data = frame_state_op.data;\n    const FrameStateInfo& info = data->frame_state_info;\n\n    V<AnyOrNone> origin = Asm().current_operation_origin();\n    DCHECK(origin.valid());\n    int offset = __ input_graph().source_positions()[origin].ScriptOffset();\n\n    const FrameStateInfo* new_info =\n        Asm().graph_zone()->template New<FrameStateInfo>(\n            BytecodeOffset(offset), info.state_combine(), info.function_info());\n    FrameStateData* new_data = Asm().graph_zone()->template New<FrameStateData>(\n        FrameStateData{*new_info, data->instructions, data->machine_types,\n                       data->int_operands});\n    return __ FrameState(frame_state_op.inputs(), frame_state_op.inlined,\n                         new_data);\n  }\n    ]]></code>\n  </func>\n</file>\n```"
}