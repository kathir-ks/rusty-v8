{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/frame.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 468, column 60",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/frame.h\",\n            \"file_name\": \"frame.h\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Declares classes for stack frame management in the compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for bit manipulation, aligned memory allocation, frame constants, and bit vector operations.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/base/bits.h\"\n            #include \"src/codegen/aligned-slot-allocator.h\"\n            #include \"src/execution/frame-constants.h\"\n            #include \"src/utils/bit-vector.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Frame\",\n                \"extends\": \"ZoneObject\",\n                \"about\": \"Collects frame slot requirements for a compiled function. Manages spill slots, callee-saved registers, and return value scratch area.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"fixed_slot_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the size of the fixed header in slots.\"\n                    },\n                    {\n                        \"name\": \"spill_slot_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the number of spill slots allocated.\"\n                    },\n                    {\n                        \"name\": \"return_slot_count_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the number of slots reserved for return values.\"\n                    },\n                    {\n                        \"name\": \"slot_allocator_\",\n                        \"type\": \"AlignedSlotAllocator\",\n                        \"access\": \"private\",\n                        \"purpose\": \"An allocator for managing slots within the frame, ensuring proper alignment.\"\n                    },\n                    {\n                        \"name\": \"allocated_registers_\",\n                        \"type\": \"BitVector*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the registers allocated for the frame. Can be null if no registers are allocated yet.\"\n                    },\n                     {\n                        \"name\": \"allocated_double_registers_\",\n                        \"type\": \"BitVector*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the double registers allocated for the frame. Can be null if no registers are allocated yet.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A memory zone used for allocating memory associated with the frame.\"\n                    },\n                    {\n                        \"name\": \"tagged_slots_bits_\",\n                        \"type\": \"GrowableBitVector\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores information about which slots in the frame contain tagged values (pointers).\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneObject\",\n                    \"AlignedSlotAllocator\",\n                    \"BitVector\",\n                    \"GrowableBitVector\",\n                    \"base::bits\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT_PRIVATE Frame : public ZoneObject {\n            public:\n            explicit Frame(int fixed_frame_size_in_slots, Zone* zone);\n            Frame(const Frame&) = delete;\n            Frame& operator=(const Frame&) = delete;\n\n            inline int GetTotalFrameSlotCount() const {\n                return slot_allocator_.Size() + return_slot_count_;\n            }\n            inline int GetFixedSlotCount() const { return fixed_slot_count_; }\n            inline int GetSpillSlotCount() const { return spill_slot_count_; }\n            inline int GetReturnSlotCount() const { return return_slot_count_; }\n\n            void SetAllocatedRegisters(BitVector* regs) {\n                DCHECK_NULL(allocated_registers_);\n                allocated_registers_ = regs;\n            }\n\n            void SetAllocatedDoubleRegisters(BitVector* regs) {\n                DCHECK_NULL(allocated_double_registers_);\n                allocated_double_registers_ = regs;\n            }\n\n            bool DidAllocateDoubleRegisters() const {\n                return !allocated_double_registers_->IsEmpty();\n            }\n\n            void AlignSavedCalleeRegisterSlots(int alignment = kDoubleSize) {\n                DCHECK(!frame_aligned_);\n            #if DEBUG\n                spill_slots_finished_ = true;\n            #endif\n                DCHECK(base::bits::IsPowerOfTwo(alignment));\n                DCHECK_LE(alignment, kSimd128Size);\n                int alignment_in_slots = AlignedSlotAllocator::NumSlotsForWidth(alignment);\n                int padding = slot_allocator_.Align(alignment_in_slots);\n                spill_slot_count_ += padding;\n            }\n\n            void AllocateSavedCalleeRegisterSlots(int count) {\n                DCHECK(!frame_aligned_);\n            #if DEBUG\n                spill_slots_finished_ = true;\n            #endif\n                slot_allocator_.AllocateUnaligned(count);\n            }\n\n            int AllocateSpillSlot(int width, int alignment = 0, bool is_tagged = false) {\n                DCHECK_EQ(GetTotalFrameSlotCount(),\n                        fixed_slot_count_ + spill_slot_count_ + return_slot_count_);\n                DCHECK_IMPLIES(is_tagged, width == sizeof(uintptr_t));\n                DCHECK_IMPLIES(is_tagged, alignment == sizeof(uintptr_t));\n                // Never allocate spill slots after the callee-saved slots are defined.\n                DCHECK(!spill_slots_finished_);\n                DCHECK(!frame_aligned_);\n                int actual_width = std::max({width, AlignedSlotAllocator::kSlotSize});\n                int actual_alignment =\n                    std::max({alignment, AlignedSlotAllocator::kSlotSize});\n                int slots = AlignedSlotAllocator::NumSlotsForWidth(actual_width);\n                int old_end = slot_allocator_.Size();\n                int slot;\n                if (actual_width == actual_alignment) {\n                // Simple allocation, alignment equal to width.\n                slot = slot_allocator_.Allocate(slots);\n                } else {\n                // Complex allocation, alignment different from width.\n                if (actual_alignment > AlignedSlotAllocator::kSlotSize) {\n                    // Alignment required.\n                    int alignment_in_slots =\n                        AlignedSlotAllocator::NumSlotsForWidth(actual_alignment);\n                    slot_allocator_.Align(alignment_in_slots);\n                }\n                slot = slot_allocator_.AllocateUnaligned(slots);\n                }\n                int end = slot_allocator_.Size();\n\n                spill_slot_count_ += end - old_end;\n                int result_slot = slot + slots - 1;\n                if (is_tagged) tagged_slots_bits_.Add(result_slot, zone_);\n                return result_slot;\n            }\n\n            void EnsureReturnSlots(int count) {\n                DCHECK(!frame_aligned_);\n                return_slot_count_ = std::max(return_slot_count_, count);\n            }\n\n            void AlignFrame(int alignment = kDoubleSize);\n\n            int ReserveSpillSlots(size_t slot_count) {\n                DCHECK_EQ(0, spill_slot_count_);\n                DCHECK(!frame_aligned_);\n                spill_slot_count_ += static_cast<int>(slot_count);\n                slot_allocator_.AllocateUnaligned(static_cast<int>(slot_count));\n                return slot_allocator_.Size() - 1;\n            }\n\n            const GrowableBitVector& tagged_slots() const { return tagged_slots_bits_; }\n\n            private:\n            int fixed_slot_count_;\n            int spill_slot_count_ = 0;\n            // Account for return slots separately. Conceptually, they follow all\n            // allocated spill slots.\n            int return_slot_count_ = 0;\n            AlignedSlotAllocator slot_allocator_;\n            BitVector* allocated_registers_;\n            BitVector* allocated_double_registers_;\n            Zone* zone_;\n            GrowableBitVector tagged_slots_bits_;\n            #if DEBUG\n            bool spill_slots_finished_ = false;\n            bool frame_aligned_ = false;\n            #endif\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FrameOffset\",\n                \"about\": \"Represents an offset from either the stack pointer or frame pointer.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"offset_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Stores the offset value and encodes whether it's from the stack pointer (SP) or frame pointer (FP).\"\n                    }\n                ],\n                \"dependencies\": []\n            }\n        </metadata>\n        <code><![CDATA[\n            class FrameOffset {\n            public:\n            inline bool from_stack_pointer() { return (offset_ & 1) == kFromSp; }\n            inline bool from_frame_pointer() { return (offset_ & 1) == kFromFp; }\n            inline int offset() { return offset_ & ~1; }\n\n            inline static FrameOffset FromStackPointer(int offset) {\n                DCHECK_EQ(0, offset & 1);\n                return FrameOffset(offset | kFromSp);\n            }\n\n            inline static FrameOffset FromFramePointer(int offset) {\n                DCHECK_EQ(0, offset & 1);\n                return FrameOffset(offset | kFromFp);\n            }\n\n            private:\n            explicit FrameOffset(int offset) : offset_(offset) {}\n\n            int offset_;  // Encodes SP or FP in the low order bit.\n\n            static const int kFromSp = 1;\n            static const int kFromFp = 0;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"FrameAccessState\",\n                \"extends\": \"ZoneObject\",\n                \"about\": \"Encapsulates the mutable state maintained during code generation about the current function's frame.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"frame_\",\n                        \"type\": \"const Frame* const\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the immutable Frame object.\"\n                    },\n                    {\n                        \"name\": \"access_frame_with_fp_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether the frame is accessed using the frame pointer (FP).\"\n                    },\n                    {\n                        \"name\": \"fp_relative_only_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether frame access is only relative to the frame pointer.\"\n                    },\n                    {\n                        \"name\": \"sp_delta_\",\n                        \"type\": \"int\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Tracks the delta between the stack pointer (SP) and the expected SP at the start of the frame.\"\n                    },\n                    {\n                        \"name\": \"has_frame_\",\n                        \"type\": \"bool\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Indicates whether a frame is present at the current stage of code generation.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"ZoneObject\",\n                    \"Frame\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class FrameAccessState : public ZoneObject {\n            public:\n            explicit FrameAccessState(const Frame* const frame)\n                : frame_(frame),\n                access_frame_with_fp_(false),\n                fp_relative_only_(false),\n                sp_delta_(0),\n                has_frame_(false) {}\n\n            const Frame* frame() const { return frame_; }\n            V8_EXPORT_PRIVATE void MarkHasFrame(bool state);\n            void SetFPRelativeOnly(bool state);\n            bool FPRelativeOnly() { return fp_relative_only_; }\n\n            int sp_delta() const { return sp_delta_; }\n            void ClearSPDelta() { sp_delta_ = 0; }\n            void IncreaseSPDelta(int amount) { sp_delta_ += amount; }\n\n            bool access_frame_with_fp() const { return access_frame_with_fp_; }\n\n            // Regardless of how we access slots on the stack - using sp or fp - do we\n            // have a frame, at the current stage in code generation.\n            bool has_frame() const { return has_frame_; }\n\n            void SetFrameAccessToDefault();\n            void SetFrameAccessToFP() { access_frame_with_fp_ = true; }\n            void SetFrameAccessToSP() { access_frame_with_fp_ = false; }\n\n            int GetSPToFPSlotCount() const {\n                int frame_slot_count =\n                    (has_frame() ? frame()->GetTotalFrameSlotCount() : kElidedFrameSlots) -\n                    StandardFrameConstants::kFixedSlotCountAboveFp;\n                return frame_slot_count + sp_delta();\n            }\n            int GetSPToFPOffset() const {\n                return GetSPToFPSlotCount() * kSystemPointerSize;\n            }\n\n            // Get the frame offset for a given spill slot. The location depends on the\n            // calling convention and the specific frame layout, and may thus be\n            // architecture-specific. Negative spill slots indicate arguments on the\n            // caller's frame.\n            FrameOffset GetFrameOffset(int spill_slot) const;\n\n            private:\n            const Frame* const frame_;\n            bool access_frame_with_fp_;\n            bool fp_relative_only_;\n            int sp_delta_;\n            bool has_frame_;\n            };\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"ZoneObject\",\n                    \"about\": \"Base class for objects allocated in a Zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class ZoneObject {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"AlignedSlotAllocator\",\n                    \"about\": \"Manages aligned memory allocation in slots.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class AlignedSlotAllocator {\n                public:\n                    static const int kSlotSize = 8;\n                    static int NumSlotsForWidth(int width);\n                    int Align(int slot_count);\n                    int Size() const;\n                    int Allocate(int slots);\n                    int AllocateUnaligned(int slots);\n                };\n                const int kDoubleSize = 8;\n                const int kSimd128Size = 16;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"BitVector\",\n                    \"about\": \"Represents a bit vector.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class BitVector {\n                public:\n                    bool IsEmpty() const;\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"GrowableBitVector\",\n                    \"about\": \"A bit vector that can grow in size.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class GrowableBitVector {\n                public:\n                    void Add(int bit, Zone* zone);\n                };\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n                {\n                    \"language\": \"cpp\",\n                    \"type\": \"class\",\n                    \"name\": \"Zone\",\n                    \"about\": \"A memory allocation zone.\"\n                }\n            </metadata>\n            <code><![CDATA[\n                class Zone {};\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DCHECK\",\n                \"about\": \"Assertion macro, enabled in debug mode.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define DCHECK(condition)\n            ]]></code>\n        </func>\n         <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DCHECK_NULL\",\n                \"about\": \"Assertion macro that checks if a pointer is NULL, enabled in debug mode.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define DCHECK_NULL(ptr)\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DCHECK_LE\",\n                \"about\": \"Assertion macro that checks if a <= b, enabled in debug mode.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define DCHECK_LE(a, b)\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DCHECK_EQ\",\n                \"about\": \"Assertion macro that checks if a == b, enabled in debug mode.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define DCHECK_EQ(a, b)\n            ]]></code>\n        </func>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"DCHECK_IMPLIES\",\n                \"about\": \"Assertion macro that checks if a implies b, enabled in debug mode.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                #define DCHECK_IMPLIES(a, b)\n            ]]></code>\n        </func>\n    </dependencies>\n</file>\n```"
}