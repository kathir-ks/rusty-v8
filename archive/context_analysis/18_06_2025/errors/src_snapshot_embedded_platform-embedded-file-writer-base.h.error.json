{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/platform-embedded-file-writer-base.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 141, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/embedded/platform-embedded-file-writer-base.h\",\n        \"file_name\": \"platform-embedded-file-writer-base.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the base class for platform-specific embedded file writers used for generating assembly code for embedded snapshots.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers for integer types, file I/O, and memory management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <cinttypes>\n            #include <cstdio>  // For FILE.\n            #include <memory>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes the string header when V8_ENABLE_DRUMBRAKE is defined.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #if V8_ENABLE_DRUMBRAKE\n            #include <string>\n            #endif  // V8_ENABLE_DRUMBRAKE\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"PlatformEmbeddedFileWriterBase\",\n            \"about\": \"Abstract base class for platform-specific file writers. Provides an interface for generating assembly code for embedded snapshots.\",\n            \"attributes\": [\n                {\n                    \"name\": \"fp_\",\n                    \"type\": \"FILE*\",\n                    \"access\": \"protected\",\n                    \"purpose\": \"File pointer for writing the assembly code.\"\n                }\n            ],\n            \"dependencies\": [\n                \"EmbeddedData\",\n                \"DataDirective\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        class PlatformEmbeddedFileWriterBase {\n        public:\n          virtual ~PlatformEmbeddedFileWriterBase() = default;\n\n          void SetFile(FILE* fp) { fp_ = fp; }\n          FILE* fp() const { return fp_; }\n\n          virtual void SectionText() = 0;\n          virtual void SectionRoData() = 0;\n\n          virtual void AlignToCodeAlignment() = 0;\n          virtual void AlignToPageSizeIfNeeded() {}\n          virtual void AlignToDataAlignment() = 0;\n\n          virtual void DeclareUint32(const char* name, uint32_t value) = 0;\n\n          virtual void DeclareSymbolGlobal(const char* name) = 0;\n          virtual void DeclareLabel(const char* name) = 0;\n          virtual void DeclareLabelProlog(const char* name) {}\n          virtual void DeclareLabelEpilogue() {}\n\n          virtual void SourceInfo(int fileid, const char* filename, int line) = 0;\n          virtual void DeclareFunctionBegin(const char* name, uint32_t size) = 0;\n          virtual void DeclareFunctionEnd(const char* name) = 0;\n\n          // Returns the number of printed characters.\n          virtual int HexLiteral(uint64_t value);\n\n          virtual void Comment(const char* string) = 0;\n          virtual void Newline() { fprintf(fp_, \"\\n\"); }\n\n          virtual void FilePrologue() = 0;\n          virtual void DeclareExternalFilename(int fileid, const char* filename) = 0;\n          virtual void FileEpilogue() = 0;\n\n          virtual int IndentedDataDirective(DataDirective directive) = 0;\n\n          virtual DataDirective ByteChunkDataDirective() const { return kOcta; }\n          virtual int WriteByteChunk(const uint8_t* data);\n\n          // This awkward interface works around the fact that unwind data emission\n          // is both high-level and platform-dependent. The former implies it should\n          // live in EmbeddedFileWriter, but code there should be platform-independent.\n          //\n          // Emits unwinding data on x64 Windows, and does nothing otherwise.\n          virtual void MaybeEmitUnwindData(const char* unwind_info_symbol,\n                                           const char* embedded_blob_data_symbol,\n                                           const EmbeddedData* blob,\n                                           const void* unwind_infos) {}\n\n         protected:\n          FILE* fp_ = nullptr;\n        };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"NewPlatformEmbeddedFileWriter\",\n            \"about\": \"Factory function to create platform specific PlatformEmbeddedFileWriterBase\",\n            \"logic\": \"Creates and returns a unique pointer to the appropriate platform-specific instance of PlatformEmbeddedFileWriterBase.\",\n            \"parameters\": [\n                {\n                    \"name\": \"target_arch\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"String representing the target architecture.\"\n                },\n                {\n                    \"name\": \"target_os\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"String representing the target operating system.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"std::unique_ptr<PlatformEmbeddedFileWriterBase>\",\n                \"description\": \"A unique pointer to the created PlatformEmbeddedFileWriterBase object.\"\n            },\n            \"dependencies\": [\n                \"PlatformEmbeddedFileWriterBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        std::unique_ptr<PlatformEmbeddedFileWriterBase> NewPlatformEmbeddedFileWriter(\n            const char* target_arch, const char* target_os);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsDrumBrakeInstructionHandler\",\n            \"about\": \"Checks if a given name corresponds to a DrumBrake instruction handler.\",\n            \"logic\": \"Checks if the given name starts with one of the prefixes 'Builtins_r2r_', 'Builtins_r2s_', 'Builtins_s2r_', or 'Builtins_s2s_'.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The name to check.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the name corresponds to a DrumBrake instruction handler, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        #if V8_ENABLE_DRUMBRAKE\n        inline bool IsDrumBrakeInstructionHandler(const char* name) {\n          std::string builtin_name(name);\n          return builtin_name.find(\"Builtins_r2r_\") == 0 ||\n                 builtin_name.find(\"Builtins_r2s_\") == 0 ||\n                 builtin_name.find(\"Builtins_s2r_\") == 0 ||\n                 builtin_name.find(\"Builtins_s2s_\") == 0;\n        }\n        #endif  // V8_ENABLE_DRUMBRAKE\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"PointerSizeDirective\",\n            \"about\": \"Returns the DataDirective corresponding to the size of a pointer on the target architecture.\",\n            \"return\": {\n                \"type\": \"DataDirective\",\n                \"description\": \"The data directive representing the pointer size.\"\n            },\n            \"dependencies\": [\n                \"DataDirective\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        DataDirective PointerSizeDirective();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"DataDirectiveSize\",\n            \"about\": \"Returns the size in bytes of a given DataDirective.\",\n            \"parameters\": [\n                {\n                    \"name\": \"directive\",\n                    \"type\": \"DataDirective\",\n                    \"purpose\": \"The data directive to get the size of.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The size of the data directive in bytes.\"\n            },\n            \"dependencies\": [\n                \"DataDirective\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n        int DataDirectiveSize(DataDirective directive);\n        ]]></code>\n    </func>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum\",\n            \"name\": \"DataDirective\",\n            \"about\": \"Enumerates different data directives for specifying data sizes in assembly code.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        enum DataDirective {\n          kByte,\n          kLong,\n          kQuad,\n          kOcta,\n        };\n        ]]></code>\n    </enum>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"EmbeddedTargetOs\",\n            \"about\": \"Enumerates the supported target operating systems for embedded snapshots.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        enum class EmbeddedTargetOs {\n          kAIX,\n          kChromeOS,\n          kFuchsia,\n          kMac,\n          kWin,\n          kStarboard,\n          kZOS,\n          kGeneric,  // Everything not covered above falls in here.\n        };\n        ]]></code>\n    </enum>\n    <enum>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"enum class\",\n            \"name\": \"EmbeddedTargetArch\",\n            \"about\": \"Enumerates the supported target architectures for embedded snapshots.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n        enum class EmbeddedTargetArch {\n          kArm,\n          kArm64,\n          kIA32,\n          kX64,\n          kGeneric,  // Everything not covered above falls in here.\n        };\n        ]]></code>\n    </enum>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"EmbeddedData\",\n            \"about\": \"Forward declaration of the EmbeddedData class.  Likely holds the actual embedded data.\"\n        }\n        </metadata>\n        <code><![CDATA[\n        class EmbeddedData;\n        ]]></code>\n    </class>\n</file>\n```"
}