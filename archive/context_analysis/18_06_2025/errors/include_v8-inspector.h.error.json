{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-inspector.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 125, column 42",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-inspector.h\",\n        \"file_name\": \"v8-inspector.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Declares the V8 Inspector API for debugging V8 JavaScript environments.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers and V8 headers necessary for the Inspector API.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <stdint.h>\n\n            #include <cctype>\n            #include <memory>\n\n            #include \"v8-isolate.h\"       // NOLINT(build/include_directory)\n            #include \"v8-local-handle.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StringView\",\n            \"about\": \"Represents a string as a view, allowing access to either 8-bit or 16-bit character data without copying.\",\n            \"attributes\": [\n                {\n                    \"name\": \"m_is8Bit\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the string is encoded as 8-bit or 16-bit characters.\"\n                },\n                {\n                    \"name\": \"m_length\",\n                    \"type\": \"size_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the length of the string.\"\n                },\n                {\n                    \"name\": \"m_characters8\",\n                    \"type\": \"const uint8_t*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the 8-bit character data (if m_is8Bit is true).\"\n                },\n                {\n                    \"name\": \"m_characters16\",\n                    \"type\": \"const uint16_t*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the 16-bit character data (if m_is8Bit is false).\"\n                }\n            ],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT StringView {\n            public:\n            StringView() : m_is8Bit(true), m_length(0), m_characters8(nullptr) {}\n\n            StringView(const uint8_t* characters, size_t length)\n                : m_is8Bit(true), m_length(length), m_characters8(characters) {}\n\n            StringView(const uint16_t* characters, size_t length)\n                : m_is8Bit(false), m_length(length), m_characters16(characters) {}\n\n            bool is8Bit() const { return m_is8Bit; }\n            size_t length() const { return m_length; }\n\n            // TODO(dgozman): add DCHECK(m_is8Bit) to accessors once platform can be used\n            // here.\n            const uint8_t* characters8() const { return m_characters8; }\n            const uint16_t* characters16() const { return m_characters16; }\n\n            private:\n            bool m_is8Bit;\n            size_t m_length;\n            union {\n                const uint8_t* m_characters8;\n                const uint16_t* m_characters16;\n            };\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StringBuffer\",\n            \"about\": \"Abstract base class for string buffers used in the Inspector API.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"StringView\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT StringBuffer {\n            public:\n            virtual ~StringBuffer() = default;\n            virtual StringView string() const = 0;\n            // This method copies contents.\n            static std::unique_ptr<StringBuffer> create(StringView);\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"V8ContextInfo\",\n            \"about\": \"Provides information about a V8 context for the Inspector.\",\n            \"attributes\": [\n                {\n                    \"name\": \"context\",\n                    \"type\": \"v8::Local<v8::Context>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The V8 context.\"\n                },\n                {\n                    \"name\": \"contextGroupId\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The ID of the context group the context belongs to.\"\n                },\n                {\n                    \"name\": \"humanReadableName\",\n                    \"type\": \"StringView\",\n                    \"access\": \"public\",\n                    \"purpose\": \"A human-readable name for the context.\"\n                },\n                {\n                    \"name\": \"origin\",\n                    \"type\": \"StringView\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The origin of the context.\"\n                },\n                {\n                    \"name\": \"auxData\",\n                    \"type\": \"StringView\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Auxiliary data associated with the context.\"\n                },\n                {\n                    \"name\": \"hasMemoryOnConsole\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates whether the context has memory information displayed on the console.\"\n                }\n            ],\n            \"dependencies\": [\n                \"StringView\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8ContextInfo {\n            public:\n            V8ContextInfo(v8::Local<v8::Context> context, int contextGroupId,\n                            StringView humanReadableName)\n                : context(context),\n                contextGroupId(contextGroupId),\n                humanReadableName(humanReadableName),\n                hasMemoryOnConsole(false) {}\n\n            v8::Local<v8::Context> context;\n            // Each v8::Context is a part of a group. The group id must be non-zero.\n            int contextGroupId;\n            StringView humanReadableName;\n            StringView origin;\n            StringView auxData;\n            bool hasMemoryOnConsole;\n\n            static int executionContextId(v8::Local<v8::Context> context);\n\n            // Disallow copying and allocating this one.\n            enum NotNullTagEnum { NotNullLiteral };\n            void* operator new(size_t) = delete;\n            void* operator new(size_t, NotNullTagEnum, void*) = delete;\n            void* operator new(size_t, void*) = delete;\n            V8ContextInfo(const V8ContextInfo&) = delete;\n            V8ContextInfo& operator=(const V8ContextInfo&) = delete;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"V8DebuggerId\",\n            \"about\": \"Represents a unique identifier for a debugger instance.\",\n            \"attributes\": [\n                {\n                    \"name\": \"m_first\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"First part of the debugger ID.\"\n                },\n                {\n                    \"name\": \"m_second\",\n                    \"type\": \"int64_t\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Second part of the debugger ID.\"\n                }\n            ],\n            \"dependencies\": [\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8DebuggerId {\n            public:\n            V8DebuggerId() = default;\n            V8DebuggerId(const V8DebuggerId&) = default;\n            V8DebuggerId& operator=(const V8DebuggerId&) = default;\n\n            std::unique_ptr<StringBuffer> toString() const;\n            bool isValid() const;\n            std::pair<int64_t, int64_t> pair() const;\n\n            private:\n            friend class internal::V8DebuggerId;\n            explicit V8DebuggerId(std::pair<int64_t, int64_t>);\n\n            int64_t m_first = 0;\n            int64_t m_second = 0;\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"V8StackFrame\",\n            \"about\": \"Represents a stack frame in a V8 stack trace.\",\n            \"attributes\": [\n                {\n                    \"name\": \"sourceURL\",\n                    \"type\": \"StringView\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The URL of the source file.\"\n                },\n                {\n                    \"name\": \"functionName\",\n                    \"type\": \"StringView\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The name of the function.\"\n                },\n                {\n                    \"name\": \"lineNumber\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The line number in the source file.\"\n                },\n                {\n                    \"name\": \"columnNumber\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The column number in the source file.\"\n                },\n                {\n                    \"name\": \"scriptId\",\n                    \"type\": \"int\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The ID of the script.\"\n                }\n            ],\n            \"dependencies\": [\n                \"StringView\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct V8_EXPORT V8StackFrame {\n            StringView sourceURL;\n            StringView functionName;\n            int lineNumber;\n            int columnNumber;\n            int scriptId;\n            };\n        ]]></code>\n    </struct>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"V8StackTrace\",\n            \"about\": \"Abstract base class for V8 stack traces.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"StringView\",\n                \"protocol::Runtime::API::StackTrace\",\n                \"V8StackFrame\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8StackTrace {\n            public:\n            virtual StringView firstNonEmptySourceURL() const = 0;\n            virtual bool isEmpty() const = 0;\n            virtual StringView topSourceURL() const = 0;\n            virtual int topLineNumber() const = 0;\n            virtual int topColumnNumber() const = 0;\n            virtual int topScriptId() const = 0;\n            virtual StringView topFunctionName() const = 0;\n\n            virtual ~V8StackTrace() = default;\n            virtual std::unique_ptr<protocol::Runtime::API::StackTrace>\n            buildInspectorObject(int maxAsyncDepth) const = 0;\n            virtual std::unique_ptr<StringBuffer> toString() const = 0;\n\n            // Safe to pass between threads, drops async chain.\n            virtual std::unique_ptr<V8StackTrace> clone() = 0;\n\n            virtual std::vector<V8StackFrame> frames() const = 0;\n            };\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"V8InspectorSession\",\n            \"about\": \"Represents a debugging session with the V8 Inspector.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"StringView\",\n                \"protocol::Schema::API::Domain\",\n                \"protocol::Debugger::API::SearchMatch\",\n                \"protocol::Runtime::API::RemoteObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8InspectorSession {\n            public:\n            virtual ~V8InspectorSession() = default;\n\n            // Cross-context inspectable values (DOM nodes in different worlds, etc.).\n            class V8_EXPORT Inspectable {\n            public:\n                virtual v8::Local<v8::Value> get(v8::Local<v8::Context>) = 0;\n                virtual ~Inspectable() = default;\n            };\n            virtual void addInspectedObject(std::unique_ptr<Inspectable>) = 0;\n\n            // Dispatching protocol messages.\n            static bool canDispatchMethod(StringView method);\n            virtual void dispatchProtocolMessage(StringView message) = 0;\n            virtual std::vector<uint8_t> state() = 0;\n            virtual std::vector<std::unique_ptr<protocol::Schema::API::Domain>>\n            supportedDomains() = 0;\n\n            // Debugger actions.\n            virtual void schedulePauseOnNextStatement(StringView breakReason,\n                                                        StringView breakDetails) = 0;\n            virtual void cancelPauseOnNextStatement() = 0;\n            virtual void breakProgram(StringView breakReason,\n                                        StringView breakDetails) = 0;\n            virtual void setSkipAllPauses(bool) = 0;\n            virtual void resume(bool setTerminateOnResume = false);\n            virtual void stepOver() = 0;\n            virtual std::vector<std::unique_ptr<protocol::Debugger::API::SearchMatch>>\n            searchInTextByLines(StringView text, StringView query, bool caseSensitive,\n                                bool isRegex) = 0;\n\n            // Remote objects.\n            virtual std::unique_ptr<protocol::Runtime::API::RemoteObject> wrapObject(\n                v8::Local<v8::Context>, v8::Local<v8::Value>, StringView groupName,\n                bool generatePreview) = 0;\n\n            virtual bool unwrapObject(std::unique_ptr<StringBuffer>* error,\n                                        StringView objectId, v8::Local<v8::Value>*,\n                                        v8::Local<v8::Context>*,\n                                        std::unique_ptr<StringBuffer>* objectGroup) = 0;\n            virtual void releaseObjectGroup(StringView) = 0;\n            virtual void triggerPreciseCoverageDeltaUpdate(StringView occasion) = 0;\n\n            struct V8_EXPORT EvaluateResult {\n            enum class ResultType {\n                kNotRun,\n                kSuccess,\n                kException,\n            };\n\n            ResultType type;\n            v8::Local<v8::Value> value;\n            };\n            // Evalaute 'expression' in the provided context. Does the same as\n            // Runtime#evaluate under-the-hood but exposed on the C++ side.\n            virtual EvaluateResult evaluate(v8::Local<v8::Context> context,\n                                            StringView expression,\n                                            bool includeCommandLineAPI = false) = 0;\n\n            // Prepare for shutdown (disables debugger pausing, etc.).\n            virtual void stop() = 0;\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"DeepSerializedValue\",\n            \"about\": \"Represents a deeply serialized value for the Inspector.\",\n            \"attributes\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"std::unique_ptr<StringBuffer>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The type of the serialized value.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"v8::MaybeLocal<v8::Value>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The serialized value itself.\"\n                }\n            ],\n            \"dependencies\": [\n                \"StringBuffer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct V8_EXPORT DeepSerializedValue {\n            explicit DeepSerializedValue(std::unique_ptr<StringBuffer> type,\n                                        v8::MaybeLocal<v8::Value> value = {})\n                : type(std::move(type)), value(value) {}\n            std::unique_ptr<StringBuffer> type;\n            v8::MaybeLocal<v8::Value> value;\n            };\n        ]]></code>\n    </struct>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"DeepSerializationResult\",\n            \"about\": \"Represents the result of a deep serialization operation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"serializedValue\",\n                    \"type\": \"std::unique_ptr<DeepSerializedValue>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The serialized value if the operation was successful.\"\n                },\n                {\n                    \"name\": \"errorMessage\",\n                    \"type\": \"std::unique_ptr<StringBuffer>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The error message if the operation failed.\"\n                },\n                {\n                    \"name\": \"isSuccess\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Indicates whether the serialization was successful.\"\n                }\n            ],\n            \"dependencies\": [\n                \"DeepSerializedValue\",\n                \"StringBuffer\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct V8_EXPORT DeepSerializationResult {\n            explicit DeepSerializationResult(\n                std::unique_ptr<DeepSerializedValue> serializedValue)\n                : serializedValue(std::move(serializedValue)), isSuccess(true) {}\n            explicit DeepSerializationResult(std::unique_ptr<StringBuffer> errorMessage)\n                : errorMessage(std::move(errorMessage)), isSuccess(false) {}\n\n            // Use std::variant when available.\n            std::unique_ptr<DeepSerializedValue> serializedValue;\n            std::unique_ptr<StringBuffer> errorMessage;\n            bool isSuccess;\n            };\n        ]]></code>\n    </struct>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"V8InspectorClient\",\n            \"about\": \"Abstract base class for clients of the V8 Inspector.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"DeepSerializationResult\",\n                \"StringBuffer\",\n                \"StringView\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8InspectorClient {\n            public:\n            virtual ~V8InspectorClient() = default;\n\n            virtual void runMessageLoopOnPause(int contextGroupId) {}\n            virtual void runMessageLoopOnInstrumentationPause(int contextGroupId) {\n                runMessageLoopOnPause(contextGroupId);\n            }\n            virtual void quitMessageLoopOnPause() {}\n            virtual void runIfWaitingForDebugger(int contextGroupId) {}\n\n            virtual void muteMetrics(int contextGroupId) {}\n            virtual void unmuteMetrics(int contextGroupId) {}\n\n            virtual void beginUserGesture() {}\n            virtual void endUserGesture() {}\n\n            virtual std::unique_ptr<DeepSerializationResult> deepSerialize(\n                v8::Local<v8::Value> v8Value, int maxDepth,\n                v8::Local<v8::Object> additionalParameters) {\n                return nullptr;\n            }\n            virtual std::unique_ptr<StringBuffer> valueSubtype(v8::Local<v8::Value>) {\n                return nullptr;\n            }\n            virtual std::unique_ptr<StringBuffer> descriptionForValueSubtype(\n                v8::Local<v8::Context>, v8::Local<v8::Value>) {\n                return nullptr;\n            }\n            virtual bool isInspectableHeapObject(v8::Local<v8::Object>) { return true; }\n\n            virtual v8::Local<v8::Context> ensureDefaultContextInGroup(\n                int contextGroupId) {\n                return v8::Local<v8::Context>();\n            }\n            virtual void beginEnsureAllContextsInGroup(int contextGroupId) {}\n            virtual void endEnsureAllContextsInGroup(int contextGroupId) {}\n\n            virtual void installAdditionalCommandLineAPI(v8::Local<v8::Context>,\n                                                        v8::Local<v8::Object>) {}\n            virtual void consoleAPIMessage(int contextGroupId,\n                                            v8::Isolate::MessageErrorLevel level,\n                                            const StringView& message,\n                                            const StringView& url, unsigned lineNumber,\n                                            unsigned columnNumber, V8StackTrace*) {}\n            virtual v8::MaybeLocal<v8::Value> memoryInfo(v8::Isolate*,\n                                                        v8::Local<v8::Context>) {\n                return v8::MaybeLocal<v8::Value>();\n            }\n\n            virtual void consoleTime(v8::Isolate* isolate, v8::Local<v8::String> label) {}\n            virtual void consoleTimeEnd(v8::Isolate* isolate,\n                                        v8::Local<v8::String> label) {}\n            virtual void consoleTimeStamp(v8::Isolate* isolate,\n                                            v8::Local<v8::String> label) {}\n            virtual void consoleTimeStampWithArgs(\n                v8::Isolate* isolate, v8::Local<v8::String> label,\n                const v8::LocalVector<v8::Value>& args) {}\n            virtual void consoleClear(int contextGroupId) {}\n            virtual double currentTimeMS() { return 0; }\n            typedef void (*TimerCallback)(void*);\n            virtual void startRepeatingTimer(double, TimerCallback, void* data) {}\n            virtual void cancelTimer(void* data) {}\n\n            // TODO(dgozman): this was added to support service worker shadow page. We\n            // should not connect at all.\n            virtual bool canExecuteScripts(int contextGroupId) { return true; }\n\n            virtual void maxAsyncCallStackDepthChanged(int depth) {}\n\n            virtual std::unique_ptr<StringBuffer> resourceNameToUrl(\n                const StringView& resourceName) {\n                return nullptr;\n            }\n\n            // The caller would defer to generating a random 64 bit integer if\n            // this method returns 0.\n            virtual int64_t generateUniqueId() { return 0; }\n\n            virtual void dispatchError(v8::Local<v8::Context>, v8::Local<v8::Message>,\n                                    v8::Local<v8::Value>) {}\n            };\n        ]]></code>\n    </class>\n    <struct>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"V8StackTraceId\",\n            \"about\": \"Represents an identifier for a stack trace, used for cross-debugger communication.\",\n            \"attributes\": [\n                {\n                    \"name\": \"id\",\n                    \"type\": \"uintptr_t\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The unique ID of the stack trace.\"\n                },\n                {\n                    \"name\": \"debugger_id\",\n                    \"type\": \"std::pair<int64_t, int64_t>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The ID of the debugger instance that created the stack trace.\"\n                },\n                {\n                    \"name\": \"should_pause\",\n                    \"type\": \"bool\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Flag indicating whether the debugger should pause when this stack trace is encountered.\"\n                }\n            ],\n            \"dependencies\": [\n                \"StringView\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct V8_EXPORT V8StackTraceId {\n            uintptr_t id;\n            std::pair<int64_t, int64_t> debugger_id;\n            bool should_pause = false;\n\n            V8StackTraceId();\n            V8StackTraceId(const V8StackTraceId&) = default;\n            V8StackTraceId(uintptr_t id, const std::pair<int64_t, int64_t> debugger_id);\n            V8StackTraceId(uintptr_t id, const std::pair<int64_t, int64_t> debugger_id,\n                            bool should_pause);\n            explicit V8StackTraceId(StringView);\n            V8StackTraceId& operator=(const V8StackTraceId&) = default;\n            V8StackTraceId& operator=(V8StackTraceId&&) noexcept = default;\n            ~V8StackTraceId() = default;\n\n            bool IsInvalid() const;\n            std::unique_ptr<StringBuffer> ToString();\n            };\n        ]]></code>\n    </struct>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"V8Inspector\",\n            \"about\": \"The main class for the V8 Inspector API.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"StringView\",\n                \"V8ContextInfo\",\n                \"V8DebuggerId\",\n                \"V8StackTraceId\",\n                \"V8StackTrace\",\n                \"V8InspectorClient\",\n                \"V8InspectorSession\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT V8Inspector {\n            public:\n            static std::unique_ptr<V8Inspector> create(v8::Isolate*, V8InspectorClient*);\n            virtual ~V8Inspector() = default;\n\n            // Contexts instrumentation.\n            virtual void contextCreated(const V8ContextInfo&) = 0;\n            virtual void contextDestroyed(v8::Local<v8::Context>) = 0;\n            virtual void resetContextGroup(int contextGroupId) = 0;\n            virtual v8::MaybeLocal<v8::Context> contextById(int contextId) = 0;\n            virtual V8DebuggerId uniqueDebuggerId(int contextId) = 0;\n            virtual uint64_t isolateId() = 0;\n\n            // Various instrumentation.\n            virtual void idleStarted() = 0;\n            virtual void idleFinished() = 0;\n\n            // Async stack traces instrumentation.\n            virtual void asyncTaskScheduled(StringView taskName, void* task,\n                                            bool recurring) = 0;\n            virtual void asyncTaskCanceled(void* task) = 0;\n            virtual void asyncTaskStarted(void* task) = 0;\n            virtual void asyncTaskFinished(void* task) = 0;\n            virtual void allAsyncTasksCanceled() = 0;\n\n            virtual V8StackTraceId storeCurrentStackTrace(StringView description) = 0;\n            virtual void externalAsyncTaskStarted(const V8StackTraceId& parent) = 0;\n            virtual void externalAsyncTaskFinished(const V8StackTraceId& parent) = 0;\n\n            // Exceptions instrumentation.\n            virtual unsigned exceptionThrown(v8::Local<v8::Context>, StringView message,\n                                            v8::Local<v8::Value> exception,\n                                            StringView detailedMessage, StringView url,\n                                            unsigned lineNumber, unsigned columnNumber,\n                                            std::unique_ptr<V8StackTrace>,\n                                            int scriptId) = 0;\n            virtual void exceptionRevoked(v8::Local<v8::Context>, unsigned exceptionId,\n                                            StringView message) = 0;\n            virtual bool associateExceptionData(v8::Local<v8::Context>,\n                                                v8::Local<v8::Value> exception,\n                                                v8::Local<v8::Name> key,\n                                                v8::Local<v8::Value> value) = 0;\n\n            // Connection.\n            class V8_EXPORT Channel {\n            public:\n                virtual ~Channel() = default;\n                virtual void sendResponse(int callId,\n                                            std::unique_ptr<StringBuffer> message) = 0;\n                virtual void sendNotification(std::unique_ptr<StringBuffer> message) = 0;\n                virtual void flushProtocolNotifications() = 0;\n            };\n            enum ClientTrustLevel { kUntrusted, kFullyTrusted };\n            enum SessionPauseState { kWaitingForDebugger, kNotWaitingForDebugger };\n            // TODO(chromium:1352175): remove default value once downstream change lands.\n            virtual std::unique_ptr<V8InspectorSession> connect(\n                int contextGroupId, Channel*, StringView state,\n                ClientTrustLevel client_trust_level,\n                SessionPauseState = kNotWaitingForDebugger) {\n                return nullptr;\n            }\n\n            // API methods.\n            virtual std::unique_ptr<V8StackTrace> createStackTrace(\n                v8::Local<v8::StackTrace>) = 0;\n            virtual std::unique_ptr<V8StackTrace> captureStackTrace(bool fullStack) = 0;\n            };\n        ]]></code>\n    </class>\n</file>\n```"
}