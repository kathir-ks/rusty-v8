{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/static-roots-gen.cc",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 44, column 46",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/snapshot/static-roots-gen.cc\",\n        \"file_name\": \"static-roots-gen.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Generates a C++ header file (static-roots.h) containing static read-only roots for the V8 JavaScript engine.  This is done during build time to optimize access to frequently used objects in the read-only heap.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for file I/O, data structures, V8 internals, and root indexing.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/snapshot/static-roots-gen.h\"\n\n#include <fstream>\n\n#include \"src/common/globals.h\"\n#include \"src/common/ptr-compr-inl.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/objects/instance-type-inl.h\"\n#include \"src/objects/instance-type.h\"\n#include \"src/objects/objects-definitions.h\"\n#include \"src/objects/visitors.h\"\n#include \"src/roots/roots-inl.h\"\n#include \"src/roots/roots.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"StaticRootsTableGenImpl\",\n            \"about\": \"Collects and sorts read-only roots from the V8 isolate for static root generation.\",\n            \"attributes\": [\n                {\n                    \"name\": \"sorted_roots_\",\n                    \"type\": \"std::map<Tagged_t, std::list<RootIndex>>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the read-only roots sorted by their compressed pointer value.\"\n                },\n                {\n                    \"name\": \"camel_names_\",\n                    \"type\": \"std::unordered_map<RootIndex, std::string>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the camel case name of each root index.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"ReadOnlyRoots\",\n                \"RootIndex\",\n                \"V8HeapCompressionScheme\",\n                \"Tagged_t\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass StaticRootsTableGenImpl {\n public:\n  explicit StaticRootsTableGenImpl(Isolate* isolate) {\n    // Collect all roots\n    ReadOnlyRoots ro_roots(isolate);\n    {\n      RootIndex pos = RootIndex::kFirstReadOnlyRoot;\n#define ADD_ROOT(_, value, CamelName)                       \\\n  {                                                         \\\n    Tagged_t ptr = V8HeapCompressionScheme::CompressObject( \\\n        ro_roots.unchecked_##value().ptr());                \\\n    sorted_roots_[ptr].push_back(pos);                      \\\n    camel_names_[RootIndex::k##CamelName] = #CamelName;     \\\n    ++pos;                                                  \\\n  }\n      READ_ONLY_ROOT_LIST(ADD_ROOT)\n#undef ADD_ROOT\n    }\n  }\n\n  const std::map<Tagged_t, std::list<RootIndex>>& sorted_roots() {\n    return sorted_roots_;\n  }\n\n  const std::string& camel_name(RootIndex idx) { return camel_names_.at(idx); }\n\n private:\n  std::map<Tagged_t, std::list<RootIndex>> sorted_roots_;\n  std::unordered_map<RootIndex, std::string> camel_names_;\n};\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"write\",\n            \"parent\": \"StaticRootsTableGen\",\n            \"about\": \"Generates the static-roots.h file containing definitions for the read-only roots.\",\n            \"logic\": \"This function opens a file for writing, generates a header with copyright and auto-generation warnings, then iterates through the sorted roots collected by StaticRootsTableGenImpl. For each root, it writes a 'static constexpr' definition with the compressed pointer value. Finally, it generates a static array containing all root pointers in the order defined by the RootIndex enum.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate containing the heap and read-only roots.\"\n                },\n                {\n                    \"name\": \"file\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The path to the output file (static-roots.h).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Isolate\",\n                \"RootIndex\",\n                \"StaticRootsTableGenImpl\",\n                \"Tagged_t\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid StaticRootsTableGen::write(Isolate* isolate, const char* file) {\n  CHECK_WITH_MSG(!V8_STATIC_ROOTS_BOOL,\n                 \"Re-generating the table of roots is only supported in builds \"\n                 \"with v8_enable_static_roots disabled\");\n  CHECK(V8_STATIC_ROOTS_GENERATION_BOOL);\n  CHECK(file);\n  static_assert(static_cast<int>(RootIndex::kFirstReadOnlyRoot) == 0);\n\n  std::ofstream out(file, std::ios::binary);\n\n  out << \"// Copyright 2022 the V8 project authors. All rights reserved.\\n\"\n      << \"// Use of this source code is governed by a BSD-style license \"\n         \"that can be\\n\"\n      << \"// found in the LICENSE file.\\n\"\n      << \"\\n\"\n      << \"// This file is automatically generated by \"\n         \"`tools/dev/gen-static-roots.py`. Do\\n// not edit manually.\\n\"\n      << \"\\n\"\n      << \"#ifndef V8_ROOTS_STATIC_ROOTS_H_\\n\"\n      << \"#define V8_ROOTS_STATIC_ROOTS_H_\\n\"\n      << \"\\n\"\n      << \"#include \\\"src/common/globals.h\\\"\\n\"\n      << \"\\n\"\n      << \"#if V8_STATIC_ROOTS_BOOL\\n\"\n      << \"\\n\"\n      << \"#include \\\"src/roots/roots.h\\\"\\n\"\n      << \"\\n\"\n      << \"// Disabling Wasm or Intl invalidates the contents of \"\n         \"static-roots.h.\\n\"\n      << \"// TODO(olivf): To support static roots for multiple build \"\n         \"configurations we\\n\"\n      << \"//              will need to generate target specific versions of \"\n         \"this file.\\n\"\n      << \"static_assert(V8_ENABLE_WEBASSEMBLY);\\n\"\n      << \"static_assert(V8_INTL_SUPPORT);\\n\"\n      << \"\\n\"\n      << \"namespace v8 {\\n\"\n      << \"namespace internal {\\n\"\n      << \"\\n\"\n      << \"struct StaticReadOnlyRoot {\\n\";\n\n  // Output a symbol for every root. Ordered by ptr to make it easier to see the\n  // memory layout of the read only page.\n  const auto size = static_cast<int>(RootIndex::kReadOnlyRootsCount);\n  StaticRootsTableGenImpl gen(isolate);\n\n  for (auto& entry : gen.sorted_roots()) {\n    Tagged_t ptr = entry.first;\n    CHECK_LT(ptr, kRegularPageSize);\n    const std::list<RootIndex>& roots = entry.second;\n\n    for (RootIndex root : roots) {\n      static const char* kPreString = \"  static constexpr Tagged_t k\";\n      const std::string& name = gen.camel_name(root);\n      size_t ptr_len = ceil(log2(ptr) / 4.0);\n      // Full line is: \"kPreString|name = 0x.....;\"\n      size_t len = strlen(kPreString) + name.length() + 5 + ptr_len + 1;\n      out << kPreString << name << \" =\";\n      if (len > 80) out << \"\\n     \";\n      out << \" 0x\" << std::hex << ptr << std::dec << \";\\n\";\n    }\n  }\n\n  out << \"\\n\";\n  out << \"  static constexpr Tagged_t kFirstAllocatedRoot = 0x\" << std::hex\n      << gen.sorted_roots().cbegin()->first << std::dec << \";\\n\";\n  out << \"  static constexpr Tagged_t kLastAllocatedRoot = 0x\" << std::hex\n      << gen.sorted_roots().crbegin()->first << std::dec << \";\\n\";\n  out << \"};\\n\";\n\n  // Output in order of roots table\n  out << \"\\nstatic constexpr std::array<Tagged_t, \" << size\n      << \"> StaticReadOnlyRootsPointerTable = {\\n\";\n\n  {\n#define ENTRY(_1, _2, CamelName) \\\n  out << \"    StaticReadOnlyRoot::k\" << #CamelName << \",\\n\";\n    READ_ONLY_ROOT_LIST(ENTRY)\n#undef ENTRY\n    out << \"};\\n\";\n  }\n  out << \"\\n\"\n      << \"}  // namespace internal\\n\"\n      << \"}  // namespace v8\\n\"\n      << \"#endif  // V8_STATIC_ROOTS_BOOL\\n\"\n      << \"#endif  // V8_ROOTS_STATIC_ROOTS_H_\\n\";\n}\n        ]]></code>\n    </func>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"The main V8 isolate class.  Represents an isolated instance of the V8 engine.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n            class Isolate;\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ReadOnlyRoots\",\n                \"about\": \"Provides access to the read-only roots in the V8 heap.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n            class ReadOnlyRoots;\n            ]]></code>\n        </class>\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"RootIndex\",\n                \"about\": \"Enumerates the indices of the read-only roots.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n            enum class RootIndex;\n            ]]></code>\n        </enum>\n        <typedef>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"Tagged_t\",\n                \"about\": \"A tagged pointer type representing a V8 object.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n            typedef uintptr_t Tagged_t;\n            ]]></code>\n        </typedef>\n        <namespace>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"namespace\",\n                \"name\": \"V8HeapCompressionScheme\",\n                \"about\": \"Provides functions for compressing and decompressing heap pointers.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n            namespace V8HeapCompressionScheme {\n                Tagged_t CompressObject(void* ptr);\n            }\n            ]]></code>\n        </namespace>\n        <variable>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"kRegularPageSize\",\n                \"about\": \"The size of a regular page in the V8 heap.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n            const size_t kRegularPageSize = 2048; // Placeholder value, actual value defined elsewhere\n            ]]></code>\n        </variable>\n        <macro>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"macro\",\n                \"name\": \"READ_ONLY_ROOT_LIST\",\n                \"about\": \"A macro used to iterate over the list of read-only roots.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n            #define READ_ONLY_ROOT_LIST(V) \\\n                V(_, undefined_value, UndefinedValue)\n            ]]></code>\n        </macro>\n    </dependencies>\n</file>\n```"
}