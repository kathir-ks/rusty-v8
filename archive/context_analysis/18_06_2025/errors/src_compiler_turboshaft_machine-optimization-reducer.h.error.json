{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/machine-optimization-reducer.h",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turboshaft/machine-optimization-reducer.h\",\n        \"file_name\": \"machine-optimization-reducer.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the MachineOptimizationReducer class for Turboshaft compiler, which performs peephole optimizations on low-level machine operations.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and V8-specific headers for various functionalities like algorithms, math, memory management, and compiler phases.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <algorithm>\n            #include <cmath>\n            #include <cstring>\n            #include <limits>\n            #include <optional>\n            #include <type_traits>\n\n            #include \"include/v8-internal.h\"\n            #include \"src/base/bits.h\"\n            #include \"src/base/division-by-constant.h\"\n            #include \"src/base/hashing.h\"\n            #include \"src/base/ieee754.h\"\n            #include \"src/base/logging.h\"\n            #include \"src/base/macros.h\"\n            #include \"src/base/overflowing-math.h\"\n            #include \"src/base/small-vector.h\"\n            #include \"src/base/template-utils.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/builtins/builtins.h\"\n            #include \"src/codegen/machine-type.h\"\n            #include \"src/compiler/backend/instruction.h\"\n            #include \"src/compiler/compilation-dependencies.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/machine-operator-reducer.h\"\n            #include \"src/compiler/turboshaft/assembler.h\"\n            #include \"src/compiler/turboshaft/index.h\"\n            #include \"src/compiler/turboshaft/operations.h\"\n            #include \"src/compiler/turboshaft/opmasks.h\"\n            #include \"src/compiler/turboshaft/phase.h\"\n            #include \"src/compiler/turboshaft/reducer-traits.h\"\n            #include \"src/compiler/turboshaft/representations.h\"\n            #include \"src/handles/handles.h\"\n            #include \"src/numbers/conversions.h\"\n            #include \"src/numbers/ieee754.h\"\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #include \"src/wasm/simd-shuffle.h\"\n            #endif\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"MachineOptimizationReducer\",\n            \"about\": \"Performs basic optimizations on low-level operations in the Turboshaft compiler.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Next\",\n                \"VariableReducer\",\n                \"GraphVisitor\",\n                \"OperationMatcher\",\n                \"Assembler\",\n                \"Word\",\n                \"Float\",\n                \"Untagged\",\n                \"FloatUnaryOp\",\n                \"FloatBinopOp\",\n                \"WordBinopOp\",\n                \"ComparisonOp\",\n                \"OverflowCheckedBinopOp\",\n                \"ShiftOp\",\n                \"BranchHint\",\n                \"DeoptimizeParameters\",\n                \"Simd128ExtractLaneOp\",\n                \"Tuple\",\n                \"PhiOp\",\n                \"LoadOp\",\n                \"ConstantOp\",\n                \"HeapObject\",\n                \"Smi\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <class Next>\n            class MachineOptimizationReducer : public Next {\n            public:\n              TURBOSHAFT_REDUCER_BOILERPLATE(MachineOptimization)\n            #if defined(__clang__)\n              // TODO(dmercadier): this static_assert ensures that the stack contains a\n              // VariableReducer. It is currently not very clean, because when GraphVisitor\n              // is on the stack, it implicitly adds a VariableReducer that isn't detected\n              // by reducer_list_contains. It would be cleaner to have a single \"reducer\n              // list contains VariableReducer\" check that sees the VariableReducer\n              // introduced by GraphVisitor.\n              static_assert(reducer_list_contains<ReducerList, VariableReducer>::value ||\n                            reducer_list_contains<ReducerList, GraphVisitor>::value);\n            #endif\n\n              // TODO(mslekova): Implement ReduceSelect and ReducePhi,\n              // by reducing `(f > 0) ? f : -f` to `fabs(f)`.\n\n              V<Untagged> REDUCE(Change)(V<Untagged> input, ChangeOp::Kind kind,\n                                         ChangeOp::Assumption assumption,\n                                         RegisterRepresentation from,\n                                         RegisterRepresentation to);\n\n              V<Float64> REDUCE(BitcastWord32PairToFloat64)(V<Word32> hi_word32,\n                                                            V<Word32> lo_word32);\n\n              V<Any> REDUCE(TaggedBitcast)(V<Any> input, RegisterRepresentation from,\n                                           RegisterRepresentation to,\n                                           TaggedBitcastOp::Kind kind);\n\n              V<Float> REDUCE(FloatUnary)(V<Float> input, FloatUnaryOp::Kind kind,\n                                          FloatRepresentation rep);\n\n              V<Word> REDUCE(WordUnary)(V<Word> input, WordUnaryOp::Kind kind,\n                                        WordRepresentation rep);\n\n              V<Float> REDUCE(FloatBinop)(V<Float> lhs, V<Float> rhs,\n                                          FloatBinopOp::Kind kind,\n                                          FloatRepresentation rep);\n\n              V<Word> REDUCE(WordBinop)(V<Word> left, V<Word> right, WordBinopOp::Kind kind,\n                                        WordRepresentation rep);\n\n              bool TryMatchHeapObject(V<Any> idx, int depth = 0);\n\n              std::optional<V<Word>> TryReduceToRor(V<Word> left, V<Word> right,\n                                                    WordBinopOp::Kind kind,\n                                                    WordRepresentation rep);\n\n              V<Tuple<Word, Word32>> REDUCE(OverflowCheckedBinop)(\n                  V<Word> left, V<Word> right, OverflowCheckedBinopOp::Kind kind,\n                  WordRepresentation rep);\n\n              V<Word32> REDUCE(Comparison)(V<Any> left, V<Any> right,\n                                          ComparisonOp::Kind kind,\n                                          RegisterRepresentation rep);\n\n              V<Word> REDUCE(Shift)(V<Word> left, V<Word32> right, ShiftOp::Kind kind,\n                                    WordRepresentation rep);\n\n              V<None> REDUCE(Branch)(OpIndex condition, Block* if_true, Block* if_false,\n                                   BranchHint hint);\n\n              V<None> REDUCE(DeoptimizeIf)(V<Word32> condition, V<FrameState> frame_state,\n                                           bool negated,\n                                           const DeoptimizeParameters* parameters);\n\n            #if V8_ENABLE_WEBASSEMBLY\n              V<None> REDUCE(TrapIf)(V<Word32> condition, OptionalV<FrameState> frame_state,\n                                     bool negated, TrapId trap_id);\n            #endif  // V8_ENABLE_WEBASSEMBLY\n\n              V<Any> REDUCE(Select)(V<Word32> cond, V<Any> vtrue, V<Any> vfalse,\n                                  RegisterRepresentation rep, BranchHint hint,\n                                  SelectOp::Implementation implem);\n\n              V<None> REDUCE(StaticAssert)(V<Word32> condition, const char* source);\n\n              V<None> REDUCE(Switch)(V<Word32> input, base::Vector<SwitchOp::Case> cases,\n                                   Block* default_case, BranchHint default_hint);\n\n              V<None> REDUCE(Store)(OpIndex base_idx, OptionalOpIndex index, OpIndex value,\n                                    StoreOp::Kind kind, MemoryRepresentation stored_rep,\n                                    WriteBarrierKind write_barrier, int32_t offset,\n                                    uint8_t element_scale,\n                                    bool maybe_initializing_or_transitioning,\n                                    IndirectPointerTag maybe_indirect_pointer_tag);\n\n              OpIndex REDUCE(Load)(OpIndex base_idx, OptionalOpIndex index,\n                                   LoadOp::Kind kind, MemoryRepresentation loaded_rep,\n                                   RegisterRepresentation result_rep, int32_t offset,\n                                   uint8_t element_scale);\n\n            #if V8_ENABLE_WEBASSEMBLY\n            #ifdef V8_TARGET_ARCH_ARM64\n              V<Any> REDUCE(Simd128ExtractLane)(V<Simd128> input,\n                                                Simd128ExtractLaneOp::Kind kind,\n                                                uint8_t lane);\n            #endif  // V8_TARGET_ARCH_ARM64\n            #endif  // V8_ENABLE_WEBASSEMBLY\n\n             private:\n              V<Word32> ReduceCompareEqual(V<Any> left, V<Any> right,\n                                          RegisterRepresentation rep);\n\n              // Try to match a constant and add it to `offset`. Return `true` if\n              // successful.\n              bool TryAdjustOffset(int32_t* offset, const Operation& maybe_constant,\n                                   uint8_t element_scale, bool tagged_base);\n\n              bool TryAdjustIndex(int32_t offset, OpIndex* index,\n                                  const Operation& maybe_constant, uint8_t element_scale);\n\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(Change)\",\n            \"parent\": \"MachineOptimizationReducer\",\n            \"about\": \"Reduces Change operations by constant folding and other transformations.\",\n            \"logic\": \"Attempts to simplify Change operations by constant folding and removing unnecessary conversions. Handles conversions between different register representations (Word32, Word64, Float32, Float64). If the input is a constant, the function returns a new constant with the target representation. It can also remove reversible conversions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"input\",\n                    \"type\": \"V<Untagged>\",\n                    \"purpose\": \"The input value to the Change operation.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"ChangeOp::Kind\",\n                    \"purpose\": \"The kind of Change operation (e.g., kSignExtend, kZeroExtend, kBitcast).\"\n                },\n                {\n                    \"name\": \"assumption\",\n                    \"type\": \"ChangeOp::Assumption\",\n                    \"purpose\": \"Assumption about the change operation.\"\n                },\n                {\n                    \"name\": \"from\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The original register representation.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The target register representation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Untagged>\",\n                \"description\": \"The reduced value.\"\n            },\n            \"dependencies\": [\n                \"multi\",\n                \"Word64Constant\",\n                \"Float32Constant\",\n                \"Float64Constant\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V<Untagged> MachineOptimizationReducer<Next>::REDUCE(Change)(V<Untagged> input, ChangeOp::Kind kind,\n                                                       ChangeOp::Assumption assumption,\n                                                       RegisterRepresentation from,\n                                                       RegisterRepresentation to) {\n              if (ShouldSkipOptimizationStep()) {\n                return Next::ReduceChange(input, kind, assumption, from, to);\n              }\n              using Kind = ChangeOp::Kind;\n              if (from == WordRepresentation::Word32()) {\n                input = TryRemoveWord32ToWord64Conversion(V<Word64>::Cast(input));\n              }\n              if (uint64_t value;\n                  from.IsWord() && matcher_.MatchIntegralWordConstant(\n                                       input, WordRepresentation(from), &value)) {\n                using Rep = RegisterRepresentation;\n                switch (multi(kind, from, to)) {\n                  case multi(Kind::kSignExtend, Rep::Word32(), Rep::Word64()):\n                    return __ Word64Constant(int64_t{static_cast<int32_t>(value)});\n                  case multi(Kind::kZeroExtend, Rep::Word32(), Rep::Word64()):\n                  case multi(Kind::kBitcast, Rep::Word32(), Rep::Word64()):\n                    return __ Word64Constant(uint64_t{static_cast<uint32_t>(value)});\n                  case multi(Kind::kBitcast, Rep::Word32(), Rep::Float32()):\n                    return __ Float32Constant(\n                        i::Float32::FromBits(static_cast<uint32_t>(value)));\n                  case multi(Kind::kBitcast, Rep::Word64(), Rep::Float64()):\n                    return __ Float64Constant(i::Float64::FromBits(value));\n                  case multi(Kind::kSignedToFloat, Rep::Word32(), Rep::Float64()):\n                    return __ Float64Constant(\n                        static_cast<double>(static_cast<int32_t>(value)));\n                  case multi(Kind::kSignedToFloat, Rep::Word64(), Rep::Float64()):\n                    return __ Float64Constant(\n                        static_cast<double>(static_cast<int64_t>(value)));\n                  case multi(Kind::kUnsignedToFloat, Rep::Word32(), Rep::Float64()):\n                    return __ Float64Constant(\n                        static_cast<double>(static_cast<uint32_t>(value)));\n                  case multi(Kind::kTruncate, Rep::Word64(), Rep::Word32()):\n                    return __ Word32Constant(static_cast<uint32_t>(value));\n                  default:\n                    break;\n                }\n              }\n              if (i::Float32 value; from == RegisterRepresentation::Float32() &&\n                                    matcher_.MatchFloat32Constant(input, &value)) {\n                if (kind == Kind::kFloatConversion &&\n                    to == RegisterRepresentation::Float64()) {\n                  return __ Float64Constant(value.get_scalar());\n                }\n                if (kind == Kind::kBitcast && to == WordRepresentation::Word32()) {\n                  return __ Word32Constant(value.get_bits());\n                }\n              }\n              if (i::Float64 value; from == RegisterRepresentation::Float64() &&\n                                    matcher_.MatchFloat64Constant(input, &value)) {\n                if (kind == Kind::kFloatConversion &&\n                    to == RegisterRepresentation::Float32()) {\n                  return __ Float32Constant(DoubleToFloat32_NoInline(value.get_scalar()));\n                }\n                if (kind == Kind::kBitcast && to == WordRepresentation::Word64()) {\n                  return __ Word64Constant(base::bit_cast<uint64_t>(value));\n                }\n                if (kind == Kind::kSignedFloatTruncateOverflowToMin) {\n                  double truncated = std::trunc(value.get_scalar());\n                  if (to == WordRepresentation::Word64()) {\n                    int64_t result = std::numeric_limits<int64_t>::min();\n                    if (truncated >= std::numeric_limits<int64_t>::min() &&\n                        truncated <= kMaxDoubleRepresentableInt64) {\n                      result = static_cast<int64_t>(truncated);\n                    }\n                    return __ Word64Constant(result);\n                  }\n                  if (to == WordRepresentation::Word32()) {\n                    int32_t result = std::numeric_limits<int32_t>::min();\n                    if (truncated >= std::numeric_limits<int32_t>::min() &&\n                        truncated <= std::numeric_limits<int32_t>::max()) {\n                      result = static_cast<int32_t>(truncated);\n                    }\n                    return __ Word32Constant(result);\n                  }\n                }\n                if (kind == Kind::kJSFloatTruncate &&\n                    to == WordRepresentation::Word32()) {\n                  return __ Word32Constant(DoubleToInt32_NoInline(value.get_scalar()));\n                }\n                if (kind == Kind::kExtractHighHalf) {\n                  DCHECK_EQ(to, RegisterRepresentation::Word32());\n                  return __ Word32Constant(static_cast<uint32_t>(value.get_bits() >> 32));\n                }\n                if (kind == Kind::kExtractLowHalf) {\n                  DCHECK_EQ(to, RegisterRepresentation::Word32());\n                  return __ Word32Constant(static_cast<uint32_t>(value.get_bits()));\n                }\n              }\n              if (float value; from == RegisterRepresentation::Float32() &&\n                               matcher_.MatchFloat32Constant(input, &value)) {\n                if (kind == Kind::kFloatConversion &&\n                    to == RegisterRepresentation::Float64()) {\n                  return __ Float64Constant(value);\n                }\n              }\n\n              const Operation& input_op = matcher_.Get(input);\n              if (const ChangeOp* change_op = input_op.TryCast<ChangeOp>()) {\n                if (change_op->from == to && change_op->to == from &&\n                    change_op->IsReversibleBy(kind, signalling_nan_possible)) {\n                  return change_op->input();\n                }\n              }\n              return Next::ReduceChange(input, kind, assumption, from, to);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(BitcastWord32PairToFloat64)\",\n            \"parent\": \"MachineOptimizationReducer\",\n            \"about\": \"Reduces BitcastWord32PairToFloat64 operations by constant folding.\",\n            \"logic\": \"If both input Word32 values are constants, the function combines them into a 64-bit value and returns the corresponding Float64 constant.\",\n            \"parameters\": [\n                {\n                    \"name\": \"hi_word32\",\n                    \"type\": \"V<Word32>\",\n                    \"purpose\": \"The high 32 bits of the Float64 value.\"\n                },\n                {\n                    \"name\": \"lo_word32\",\n                    \"type\": \"V<Word32>\",\n                    \"purpose\": \"The low 32 bits of the Float64 value.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Float64>\",\n                \"description\": \"The reduced Float64 value.\"\n            },\n            \"dependencies\": [\n                \"Float64Constant\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V<Float64> MachineOptimizationReducer<Next>::REDUCE(BitcastWord32PairToFloat64)(V<Word32> hi_word32,\n                                                                 V<Word32> lo_word32) {\n              if (ShouldSkipOptimizationStep()) {\n                return Next::ReduceBitcastWord32PairToFloat64(hi_word32, lo_word32);\n              }\n              uint32_t lo, hi;\n              if (matcher_.MatchIntegralWord32Constant(hi_word32, &hi) &&\n                  matcher_.MatchIntegralWord32Constant(lo_word32, &lo)) {\n                return __ Float64Constant(\n                    base::bit_cast<double>(uint64_t{hi} << 32 | uint64_t{lo}));\n              }\n              return Next::ReduceBitcastWord32PairToFloat64(hi_word32, lo_word32);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(TaggedBitcast)\",\n            \"parent\": \"MachineOptimizationReducer\",\n            \"about\": \"Reduces TaggedBitcast operations by constant folding and shortcutting.\",\n            \"logic\": \"Attempts to simplify TaggedBitcast operations by constant folding, removing unnecessary casts, and applying bitcast optimizations.\",\n            \"parameters\": [\n                {\n                    \"name\": \"input\",\n                    \"type\": \"V<Any>\",\n                    \"purpose\": \"The input value to the TaggedBitcast operation.\"\n                },\n                {\n                    \"name\": \"from\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The original register representation.\"\n                },\n                {\n                    \"name\": \"to\",\n                    \"type\": \"RegisterRepresentation\",\n                    \"purpose\": \"The target register representation.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"TaggedBitcastOp::Kind\",\n                    \"purpose\": \"The kind of TaggedBitcast operation.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Any>\",\n                \"description\": \"The reduced value.\"\n            },\n            \"dependencies\": [\n                \"TaggedBitcastOp\",\n                \"ConstantOp\",\n                \"SmiConstant\",\n                \"BitcastWord32ToWord64\",\n                \"TruncateWord64ToWord32\",\n                \"Word64Constant\",\n                \"Word32Constant\",\n                \"Smi\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V<Any> MachineOptimizationReducer<Next>::REDUCE(TaggedBitcast)(V<Any> input, RegisterRepresentation from,\n                                                         RegisterRepresentation to,\n                                                         TaggedBitcastOp::Kind kind) {\n              if (ShouldSkipOptimizationStep()) {\n                return Next::ReduceTaggedBitcast(input, from, to, kind);\n              }\n              // A Tagged -> Untagged -> Tagged sequence can be short-cut.\n              // An Untagged -> Tagged -> Untagged sequence however cannot be removed,\n              // because the GC might have modified the pointer.\n              if (auto* input_bitcast = matcher_.TryCast<TaggedBitcastOp>(input)) {\n                if (all_of(input_bitcast->to, from) ==\n                        RegisterRepresentation::WordPtr() &&\n                    all_of(input_bitcast->from, to) == RegisterRepresentation::Tagged()) {\n                  return input_bitcast->input();\n                }\n              }\n              // An Untagged -> Smi -> Untagged sequence can be short-cut.\n              if (auto* input_bitcast = matcher_.TryCast<TaggedBitcastOp>(input);\n                  input_bitcast && to.IsWord() &&\n                  (kind == TaggedBitcastOp::Kind::kSmi ||\n                   input_bitcast->kind == TaggedBitcastOp::Kind::kSmi)) {\n                if (input_bitcast->from == to) return input_bitcast->input();\n                if (input_bitcast->from == RegisterRepresentation::Word32()) {\n                  DCHECK_EQ(to, RegisterRepresentation::Word64());\n                  return __ BitcastWord32ToWord64(input_bitcast->input());\n                }\n                DCHECK(input_bitcast->from == RegisterRepresentation::Word64() &&\n                       to == RegisterRepresentation::Word32());\n                return __ TruncateWord64ToWord32(input_bitcast->input());\n              }\n              // Try to constant-fold TaggedBitcast from Word Constant to Word.\n              if (to.IsWord()) {\n                if (const ConstantOp* cst = matcher_.TryCast<ConstantOp>(input)) {\n                  if (cst->kind == ConstantOp::Kind::kWord32 ||\n                      cst->kind == ConstantOp::Kind::kWord64) {\n                    if (to == RegisterRepresentation::Word64()) {\n                      return __ Word64Constant(cst->integral());\n                    } else {\n                      DCHECK_EQ(to, RegisterRepresentation::Word32());\n                      return __ Word32Constant(static_cast<uint32_t>(cst->integral()));\n                    }\n                  }\n                }\n              }\n              if (const ConstantOp* cst = matcher_.TryCast<ConstantOp>(input)) {\n                // Try to constant-fold Word constant -> Tagged (Smi).\n                if (cst->IsIntegral() && to == RegisterRepresentation::Tagged()) {\n                  if (Smi::IsValid(cst->integral())) {\n                    return __ SmiConstant(\n                        i::Tagged<Smi>(static_cast<intptr_t>(cst->integral())));\n                  }\n                }\n                // Try to constant-fold Smi -> Untagged.\n                if (cst->kind == ConstantOp::Kind::kSmi) {\n                  if (to == RegisterRepresentation::Word32()) {\n                    return __ Word32Constant(static_cast<uint32_t>(cst->smi().ptr()));\n                  } else if (to == RegisterRepresentation::Word64()) {\n                    return __ Word64Constant(static_cast<uint64_t>(cst->smi().ptr()));\n                  }\n                }\n              }\n              return Next::ReduceTaggedBitcast(input, from, to, kind);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"REDUCE(FloatUnary)\",\n            \"parent\": \"MachineOptimizationReducer\",\n            \"about\": \"Reduces FloatUnary operations by constant folding.\",\n            \"logic\": \"If the input is a constant, the function computes the result of the unary operation and returns a new constant with the result. Handles various float unary operations (abs, negate, silenceNaN, round, log, sqrt, exp, sin, cos, etc.).\",\n            \"parameters\": [\n                {\n                    \"name\": \"input\",\n                    \"type\": \"V<Float>\",\n                    \"purpose\": \"The input value to the FloatUnary operation.\"\n                },\n                {\n                    \"name\": \"kind\",\n                    \"type\": \"FloatUnaryOp::Kind\",\n                    \"purpose\": \"The kind of FloatUnary operation (e.g., kAbs, kNegate, kSqrt).\"\n                },\n                {\n                    \"name\": \"rep\",\n                    \"type\": \"FloatRepresentation\",\n                    \"purpose\": \"The float representation (Float32 or Float64).\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"V<Float>\",\n                \"description\": \"The reduced value.\"\n            },\n            \"dependencies\": [\n                \"FloatUnaryOp\",\n                \"Float32Constant\",\n                \"Float64Constant\",\n                \"SIN_IMPL\",\n                \"COS_IMPL\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V<Float> MachineOptimizationReducer<Next>::REDUCE(FloatUnary)(V<Float> input, FloatUnaryOp::Kind kind,\n                                                     FloatRepresentation rep) {\n              if (ShouldSkipOptimizationStep()) {\n                return Next::ReduceFloatUnary(input, kind, rep);\n              }\n              if (float f32_k; rep == FloatRepresentation::Float32() &&\n                               matcher_.MatchFloat32Constant(input, &f32_k)) {\n                if (std::isnan(f32_k) && !signalling_nan_possible) {\n                  return __ Float32Constant(std::numeric_limits<float>::quiet_NaN());\n                }\n                switch (kind) {\n                  case FloatUnaryOp::Kind::kAbs:\n                    return __ Float32Constant(std::abs(f32_k));\n                  case FloatUnaryOp::Kind::kNegate:\n                    return __ Float32Constant(-f32_k);\n                  case FloatUnaryOp::Kind::kSilenceNaN:\n                    DCHECK(!std::isnan(f32_k));\n                    return __ Float32Constant(f32_k);\n                  case FloatUnaryOp::Kind::kRoundDown:\n                    return __ Float32Constant(std::floor(f32_k));\n                  case FloatUnaryOp::Kind::kRoundUp:\n                    return __ Float32Constant(std::ceil(f32_k));\n                  case FloatUnaryOp::Kind::kRoundToZero:\n                    return __ Float32Constant(std::trunc(f32_k));\n                  case FloatUnaryOp::Kind::kRoundTiesEven:\n                    DCHECK_EQ(std::nearbyint(1.5), 2);\n                    DCHECK_EQ(std::nearbyint(2.5), 2);\n                    return __ Float32Constant(std::nearbyint(f32_k));\n                  case FloatUnaryOp::Kind::kLog:\n                    return __ Float32Constant(base::ieee754::log(f32_k));\n                  case FloatUnaryOp::Kind::kSqrt:\n                    return __ Float32Constant(std::sqrt(f32_k));\n                  case FloatUnaryOp::Kind::kExp:\n                    return __ Float32Constant(base::ieee754::exp(f32_k));\n                  case FloatUnaryOp::Kind::kExpm1:\n                    return __ Float32Constant(base::ieee754::expm1(f32_k));\n                  case FloatUnaryOp::Kind::kSin:\n                    return __ Float32Constant(SIN_IMPL(f32_k));\n                  case FloatUnaryOp::Kind::kCos:\n                    return __ Float32Constant(COS_IMPL(f32_k));\n                  case FloatUnaryOp::Kind::kSinh:\n                    return __ Float32Constant(base::ieee754::sinh(f32_k));\n                  case FloatUnaryOp::Kind::kCosh:\n                    return __ Float32Constant(base::ieee754::cosh(f32_k));\n                  case FloatUnaryOp::Kind::kAcos:\n                    return __ Float32Constant(base::ieee754::acos(f32_k));\n                  case FloatUnaryOp::Kind::kAsin:\n                    return __ Float32Constant(base::ieee754::asin(f32_k));\n                  case FloatUnaryOp::Kind::kAsinh:\n                    return __ Float32Constant(base::ieee754::asinh(f32_k));\n                  case FloatUnaryOp::Kind::kAcosh:\n                    return __ Float32Constant(base::ieee754::acosh(f32_k));\n                  case FloatUnaryOp::Kind::kTan:\n                    return __ Float32Constant(base::ieee754::tan(f32_k));\n                  case FloatUnaryOp::Kind::kTanh:\n                    return __ Float32Constant(base::ieee754::tanh(f32_k));\n                  case FloatUnaryOp::Kind::kLog2:\n                    return __ Float32Constant(base::ieee754::log2(f32_k));\n                  case FloatUnaryOp::Kind::kLog10:\n                    return __ Float32Constant(base::ieee754::log10(f32_k));\n                  case FloatUnaryOp::Kind::kLog1p:\n                    return __ Float32Constant(base::ieee754::log1p(f32_k));\n                  case FloatUnaryOp::Kind::kCbrt:\n                    return __ Float32Constant(base::ieee754::cbrt(f32_k));\n                  case FloatUnaryOp::Kind::kAtan:\n                    return __ Float32Constant(base::ieee754::atan(f32_k));\n                  case FloatUnaryOp::Kind::kAtanh:\n                    return __ Float32Constant(base::ieee754::atanh(f32_k));\n                }\n              } else if (double f64_k; rep == FloatRepresentation::Float64() &&\n                                       matcher_.MatchFloat64Constant(input, &f64_k)) {\n                if (std::isnan(f64_k) && !signalling_nan_possible) {\n                  return __ Float64Constant(std::numeric_limits<double>::quiet_NaN());\n                }\n                switch (kind) {\n                  case FloatUnaryOp::Kind::kAbs:\n                    return __ Float64Constant(std::abs(f64_k));\n                  case FloatUnaryOp::Kind::kNegate:\n                    return __ Float64Constant(-f64_k);\n                  case FloatUnaryOp::Kind::kSilenceNaN:\n                    DCHECK(!std::isnan(f64_k));\n                    return __ Float64Constant(f64_k);\n                  case FloatUnaryOp::Kind::kRoundDown:\n                    return __ Float64Constant(std::floor(f64_k));\n                  case FloatUnaryOp::Kind::kRoundUp:\n                    return __ Float64Constant(std::ceil(f64_k));\n                  case FloatUnaryOp::Kind::kRoundToZero:\n                    return __ Float64Constant(std::trunc(f64_k));\n                  case FloatUnaryOp::Kind::kRoundTiesEven:\n                    DCHECK_EQ(std::nearbyint(1.5), 2);\n                    DCHECK_EQ(std::nearbyint(2.5), 2);\n                    return __ Float64Constant(std::nearbyint(f64_k));\n                  case FloatUnaryOp::Kind::kLog:\n                    return __ Float64Constant(base::ieee754::log(f64_k));\n                  case FloatUnaryOp::Kind::kSqrt:\n                    return __ Float64Constant(std::sqrt(f64_k));\n                  case FloatUnaryOp::Kind::kExp:\n                    return __ Float64Constant(base::ieee754::exp(f64_k));\n                  case FloatUnaryOp::Kind::kExpm1:\n                    return __ Float64Constant(base::ieee754::expm1(f64_k));\n                  case FloatUnaryOp::Kind::kSin:\n                    return __ Float64Constant(SIN_IMPL(f64_k));\n                  "
}