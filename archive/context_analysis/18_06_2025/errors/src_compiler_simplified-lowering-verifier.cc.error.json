{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-lowering-verifier.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/simplified-lowering-verifier.cc\",\n        \"file_name\": \"simplified-lowering-verifier.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Verifies the type and truncation properties of nodes in the graph during simplified lowering.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary header files for compiler components, backend instructions, common operators, operation typing, and type caching.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/simplified-lowering-verifier.h\"\n\n#include \"src/compiler/backend/instruction-codes.h\"\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/operation-typer.h\"\n#include \"src/compiler/type-cache.h\"\n        ]]></code>\n    </imports>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"IsNonTruncatingMachineTypeFor\",\n            \"parent\": null,\n            \"about\": \"Checks if a given MachineType is non-truncating for a specific Type.\",\n            \"logic\": \"This function determines if a machine type `mt` can represent a given type `type` without truncation. It handles specific cases like BigInt and Boolean and defaults to true for other cases.  It's crucial for ensuring data integrity during type conversions.\",\n            \"parameters\": [\n                {\n                    \"name\": \"mt\",\n                    \"type\": \"const MachineType&\",\n                    \"purpose\": \"The machine type to check.\"\n                },\n                {\n                    \"name\": \"type\",\n                    \"type\": \"const Type&\",\n                    \"purpose\": \"The type to check against the machine type.\"\n                },\n                {\n                    \"name\": \"graph_zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The memory zone to use for type operations.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the machine type is non-truncating for the type, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nbool IsNonTruncatingMachineTypeFor(const MachineType& mt, const Type& type,\n                                   Zone* graph_zone) {\n  if (type.IsNone()) return true;\n  // TODO(nicohartmann@): Add more cases here.\n  if (type.Is(Type::BigInt())) {\n    if (mt.representation() == MachineRepresentation::kWord64) {\n      return type.Is(Type::SignedBigInt64()) ||\n             type.Is(Type::UnsignedBigInt64());\n    }\n    return mt.representation() == MachineRepresentation::kTaggedPointer ||\n           mt.representation() == MachineRepresentation::kTagged;\n  }\n  switch (mt.representation()) {\n    case MachineRepresentation::kBit:\n      CHECK(mt.semantic() == MachineSemantic::kBool ||\n            mt.semantic() == MachineSemantic::kAny);\n      return type.Is(Type::Boolean()) || type.Is(Type::Range(0, 1, graph_zone));\n    default:\n      return true;\n  }\n}\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"SimplifiedLoweringVerifier\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Verifies type and truncation information during simplified lowering.\",\n            \"attributes\": [],\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nvoid SimplifiedLoweringVerifier::CheckType(Node* node, const Type& type) {\n  CHECK(NodeProperties::IsTyped(node));\n  Type node_type = NodeProperties::GetType(node);\n  if (!type.Is(node_type)) {\n    std::ostringstream type_str;\n    type.PrintTo(type_str);\n    std::ostringstream node_type_str;\n    node_type.PrintTo(node_type_str);\n\n    FATAL(\n        \"SimplifiedLoweringVerifierError: verified type %s of node #%d:%s \"\n        \"does not match with type %s assigned during lowering\",\n        type_str.str().c_str(), node->id(), node->op()->mnemonic(),\n        node_type_str.str().c_str());\n  }\n}\n\nvoid SimplifiedLoweringVerifier::CheckAndSet(Node* node, const Type& type,\n                                             const Truncation& trunc) {\n  DCHECK(!type.IsInvalid());\n\n  if (NodeProperties::IsTyped(node)) {\n    CheckType(node, type);\n  } else {\n    // We store the type inferred by the verification pass. We do not update\n    // the node's type directly, because following phases might encounter\n    // unsound types as long as the verification is not complete.\n    SetType(node, type);\n  }\n  SetTruncation(node, GeneralizeTruncation(trunc, type));\n}\n\nvoid SimplifiedLoweringVerifier::ReportInvalidTypeCombination(\n    Node* node, const std::vector<Type>& types) {\n  std::ostringstream types_str;\n  for (size_t i = 0; i < types.size(); ++i) {\n    if (i != 0) types_str << \", \";\n    types[i].PrintTo(types_str);\n  }\n  std::ostringstream graph_str;\n  node->Print(graph_str, 2);\n  FATAL(\n      \"SimplifiedLoweringVerifierError: invalid combination of input types %s \"\n      \" for node #%d:%s.\\n\\nGraph is: %s\",\n      types_str.str().c_str(), node->id(), node->op()->mnemonic(),\n      graph_str.str().c_str());\n}\n\nbool IsModuloTruncation(const Truncation& truncation) {\n  return truncation.IsUsedAsWord32() ||\n         (Is64() && truncation.IsUsedAsWord64()) ||\n         Truncation::Any().IsLessGeneralThan(truncation);\n}\n\nTruncation SimplifiedLoweringVerifier::GeneralizeTruncation(\n    const Truncation& truncation, const Type& type) const {\n  IdentifyZeros identify_zeros = truncation.identify_zeros();\n  if (!type.Maybe(Type::MinusZero())) {\n    identify_zeros = IdentifyZeros::kDistinguishZeros;\n  }\n\n  switch (truncation.kind()) {\n    case Truncation::TruncationKind::kAny: {\n      return Truncation::Any(identify_zeros);\n    }\n    case Truncation::TruncationKind::kBool: {\n      if (type.Is(Type::Boolean())) return Truncation::Any();\n      return Truncation(Truncation::TruncationKind::kBool, identify_zeros);\n    }\n    case Truncation::TruncationKind::kWord32: {\n      if (type.Is(Type::Signed32OrMinusZero()) ||\n          type.Is(Type::Unsigned32OrMinusZero())) {\n        return Truncation::Any(identify_zeros);\n      }\n      return Truncation(Truncation::TruncationKind::kWord32, identify_zeros);\n    }\n    case Truncation::TruncationKind::kWord64: {\n      if (type.Is(Type::BigInt())) {\n        DCHECK_EQ(identify_zeros, IdentifyZeros::kDistinguishZeros);\n        if (type.Is(Type::SignedBigInt64()) ||\n            type.Is(Type::UnsignedBigInt64())) {\n          return Truncation::Any(IdentifyZeros::kDistinguishZeros);\n        }\n      } else if (type.Is(TypeCache::Get()->kSafeIntegerOrMinusZero)) {\n        return Truncation::Any(identify_zeros);\n      }\n      return Truncation(Truncation::TruncationKind::kWord64, identify_zeros);\n    }\n\n    default:\n      // TODO(nicohartmann): Support remaining truncations.\n      UNREACHABLE();\n  }\n}\n\nTruncation SimplifiedLoweringVerifier::JoinTruncation(const Truncation& t1,\n                                                      const Truncation& t2) {\n  Truncation::TruncationKind kind;\n  if (Truncation::LessGeneral(t1.kind(), t2.kind())) {\n    kind = t1.kind();\n  } else {\n    CHECK(Truncation::LessGeneral(t2.kind(), t1.kind()));\n    kind = t2.kind();\n  }\n  IdentifyZeros identify_zeros = Truncation::LessGeneralIdentifyZeros(\n                                     t1.identify_zeros(), t2.identify_zeros())\n                                     ? t1.identify_zeros()\n                                     : t2.identify_zeros();\n  return Truncation(kind, identify_zeros);\n}\n\nvoid SimplifiedLoweringVerifier::VisitNode(Node* node,\n                                           OperationTyper& op_typer) {\n  switch (node->opcode()) {\n    case IrOpcode::kStart:\n    case IrOpcode::kIfTrue:\n    case IrOpcode::kIfFalse:\n    case IrOpcode::kMerge:\n    case IrOpcode::kEnd:\n    case IrOpcode::kEffectPhi:\n    case IrOpcode::kCheckpoint:\n    case IrOpcode::kFrameState:\n    case IrOpcode::kJSStackCheck:\n      break;\n    case IrOpcode::kInt32Constant: {\n      // NOTE: Constants require special handling as they are shared between\n      // machine graphs and non-machine graphs lowered during SL. The former\n      // might have assigned Type::Machine() to the constant, but to be able\n      // to provide a different type for uses of constants that don't come\n      // from machine graphs, the machine-uses of Int32Constants have been\n      // put behind additional SLVerifierHints to provide the required\n      // Type::Machine() to them, such that we can treat constants here as\n      // having JS types to satisfy their non-machine uses.\n      int32_t value = OpParameter<int32_t>(node->op());\n      Type type = Type::Constant(value, graph_zone());\n      SetType(node, type);\n      SetTruncation(node, GeneralizeTruncation(Truncation::Word32(), type));\n      break;\n    }\n    case IrOpcode::kInt64Constant:\n    case IrOpcode::kFloat64Constant: {\n      // Constants might be untyped, because they are cached in the graph and\n      // used in different contexts such that no single type can be assigned.\n      // Their type is provided by an introduced TypeGuard where necessary.\n      break;\n    }\n    case IrOpcode::kHeapConstant:\n      break;\n    case IrOpcode::kCheckedFloat64ToInt32: {\n      Type input_type = InputType(node, 0);\n      DCHECK(input_type.Is(Type::Number()));\n\n      const auto& p = CheckMinusZeroParametersOf(node->op());\n      if (p.mode() == CheckForMinusZeroMode::kCheckForMinusZero) {\n        // Remove -0 from input_type.\n        input_type =\n            Type::Intersect(input_type, Type::Signed32(), graph_zone());\n      } else {\n        input_type = Type::Intersect(input_type, Type::Signed32OrMinusZero(),\n                                     graph_zone());\n      }\n      CheckAndSet(node, input_type, Truncation::Word32());\n      break;\n    }\n    case IrOpcode::kCheckedTaggedToTaggedSigned: {\n      Type input_type = InputType(node, 0);\n      Type output_type =\n          Type::Intersect(input_type, Type::SignedSmall(), graph_zone());\n      Truncation output_trunc = InputTruncation(node, 0);\n      CheckAndSet(node, output_type, output_trunc);\n      break;\n    }\n    case IrOpcode::kCheckedTaggedToTaggedPointer:\n      CheckAndSet(node, InputType(node, 0), InputTruncation(node, 0));\n      break;\n    case IrOpcode::kTruncateTaggedToBit: {\n      Type input_type = InputType(node, 0);\n      Truncation input_trunc = InputTruncation(node, 0);\n      // Cannot have other truncation here, because identified values lead to\n      // different results when converted to bit.\n      CHECK(input_trunc == Truncation::Bool() ||\n            input_trunc == Truncation::Any());\n      Type output_type = op_typer.ToBoolean(input_type);\n      CheckAndSet(node, output_type, Truncation::Bool());\n      break;\n    }\n    case IrOpcode::kInt32Add: {\n      Type left_type = InputType(node, 0);\n      Type right_type = InputType(node, 1);\n      Type output_type;\n      if (left_type.IsNone() && right_type.IsNone()) {\n        output_type = Type::None();\n      } else if (left_type.Is(Type::Machine()) &&\n                 right_type.Is(Type::Machine())) {\n        output_type = Type::Machine();\n      } else if (left_type.Is(Type::NumberOrOddball()) &&\n                 right_type.Is(Type::NumberOrOddball())) {\n        left_type = op_typer.ToNumber(left_type);\n        right_type = op_typer.ToNumber(right_type);\n        output_type = op_typer.NumberAdd(left_type, right_type);\n      } else {\n        ReportInvalidTypeCombination(node, {left_type, right_type});\n      }\n      Truncation output_trunc =\n          JoinTruncation(InputTruncation(node, 0), InputTruncation(node, 1),\n                         Truncation::Word32());\n      CHECK(IsModuloTruncation(output_trunc));\n      CheckAndSet(node, output_type, output_trunc);\n      break;\n    }\n    case IrOpcode::kInt32Sub: {\n      Type left_type = InputType(node, 0);\n      Type right_type = InputType(node, 1);\n      Type output_type;\n      if (left_type.IsNone() && right_type.IsNone()) {\n        output_type = Type::None();\n      } else if (left_type.Is(Type::Machine()) &&\n                 right_type.Is(Type::Machine())) {\n        output_type = Type::Machine();\n      } else if (left_type.Is(Type::NumberOrOddball()) &&\n                 right_type.Is(Type::NumberOrOddball())) {\n        left_type = op_typer.ToNumber(left_type);\n        right_type = op_typer.ToNumber(right_type);\n        output_type = op_typer.NumberSubtract(left_type, right_type);\n      } else {\n        ReportInvalidTypeCombination(node, {left_type, right_type});\n      }\n      Truncation output_trunc =\n          JoinTruncation(InputTruncation(node, 0), InputTruncation(node, 1),\n                         Truncation::Word32());\n      CHECK(IsModuloTruncation(output_trunc));\n      CheckAndSet(node, output_type, output_trunc);\n      break;\n    }\n    case IrOpcode::kChangeInt31ToTaggedSigned:\n    case IrOpcode::kChangeInt32ToTagged:\n    case IrOpcode::kChangeFloat32ToFloat64:\n    case IrOpcode::kChangeInt32ToInt64:\n    case IrOpcode::kChangeUint32ToUint64:\n    case IrOpcode::kChangeUint64ToTagged: {\n      // These change operators do not truncate any values and can simply\n      // forward input type and truncation.\n      CheckAndSet(node, InputType(node, 0), InputTruncation(node, 0));\n      break;\n    }\n    case IrOpcode::kChangeFloat64ToInt64: {\n      Truncation output_trunc =\n          JoinTruncation(InputTruncation(node, 0), Truncation::Word64());\n      CheckAndSet(node, InputType(node, 0), output_trunc);\n      break;\n    }\n    case IrOpcode::kInt64Add: {\n      Type left_type = InputType(node, 0);\n      Type right_type = InputType(node, 1);\n      Type output_type;\n      if (left_type.IsNone() && right_type.IsNone()) {\n        // None x None -> None\n        output_type = Type::None();\n      } else if (left_type.Is(Type::Machine()) &&\n                 right_type.Is(Type::Machine())) {\n        // Machine x Machine -> Machine\n        output_type = Type::Machine();\n      } else if (left_type.Is(Type::BigInt()) &&\n                 right_type.Is(Type::BigInt())) {\n        // BigInt x BigInt -> BigInt\n        output_type = op_typer.BigIntAdd(left_type, right_type);\n      } else if (left_type.Is(Type::NumberOrOddball()) &&\n                 right_type.Is(Type::NumberOrOddball())) {\n        // Number x Number -> Number\n        left_type = op_typer.ToNumber(left_type);\n        right_type = op_typer.ToNumber(right_type);\n        output_type = op_typer.NumberAdd(left_type, right_type);\n      } else {\n        // Invalid type combination.\n        ReportInvalidTypeCombination(node, {left_type, right_type});\n      }\n      Truncation output_trunc =\n          JoinTruncation(InputTruncation(node, 0), InputTruncation(node, 1),\n                         Truncation::Word64());\n      CHECK(IsModuloTruncation(output_trunc));\n      CheckAndSet(node, output_type, output_trunc);\n      break;\n    }\n    case IrOpcode::kInt64Sub: {\n      Type left_type = InputType(node, 0);\n      Type right_type = InputType(node, 1);\n      Type output_type;\n      if (left_type.IsNone() && right_type.IsNone()) {\n        // None x None -> None\n        output_type = Type::None();\n      } else if (left_type.Is(Type::Machine()) &&\n                 right_type.Is(Type::Machine())) {\n        // Machine x Machine -> Machine\n        output_type = Type::Machine();\n      } else if (left_type.Is(Type::BigInt()) &&\n                 right_type.Is(Type::BigInt())) {\n        // BigInt x BigInt -> BigInt\n        output_type = op_typer.BigIntSubtract(left_type, right_type);\n      } else if (left_type.Is(Type::NumberOrOddball()) &&\n                 right_type.Is(Type::NumberOrOddball())) {\n        // Number x Number -> Number\n        left_type = op_typer.ToNumber(left_type);\n        right_type = op_typer.ToNumber(right_type);\n        output_type = op_typer.NumberSubtract(left_type, right_type);\n      } else {\n        // Invalid type combination.\n        ReportInvalidTypeCombination(node, {left_type, right_type});\n      }\n      Truncation output_trunc =\n          JoinTruncation(InputTruncation(node, 0), InputTruncation(node, 1),\n                         Truncation::Word64());\n      CHECK(IsModuloTruncation(output_trunc));\n      CheckAndSet(node, output_type, output_trunc);\n      break;\n    }\n    case IrOpcode::kDeadValue: {\n      CheckAndSet(node, Type::None(), Truncation::Any());\n      break;\n    }\n    case IrOpcode::kTypeGuard: {\n      Type output_type = op_typer.TypeTypeGuard(node->op(), InputType(node, 0));\n      // TypeGuard has no effect on trunction, but the restricted type may help\n      // generalize it.\n      CheckAndSet(node, output_type, InputTruncation(node, 0));\n      break;\n    }\n    case IrOpcode::kTruncateBigIntToWord64: {\n      Type input_type = InputType(node, 0);\n      CHECK(input_type.Is(Type::BigInt()));\n      CHECK(Truncation::Word64().IsLessGeneralThan(InputTruncation(node, 0)));\n      CheckAndSet(node, input_type, Truncation::Word64());\n      break;\n    }\n    case IrOpcode::kChangeTaggedSignedToInt64: {\n      Type input_type = InputType(node, 0);\n      CHECK(input_type.Is(Type::Number()));\n      Truncation output_trunc =\n          JoinTruncation(InputTruncation(node, 0), Truncation::Word64());\n      CheckAndSet(node, input_type, output_trunc);\n      break;\n    }\n    case IrOpcode::kCheckBigInt: {\n      Type input_type = InputType(node, 0);\n      input_type = Type::Intersect(input_type, Type::BigInt(), graph_zone());\n      CheckAndSet(node, input_type, InputTruncation(node, 0));\n      break;\n    }\n    case IrOpcode::kCheckedBigIntToBigInt64: {\n      Type input_type = InputType(node, 0);\n      CHECK(input_type.Is(Type::BigInt()));\n      input_type =\n          Type::Intersect(input_type, Type::SignedBigInt64(), graph_zone());\n      CheckAndSet(node, input_type, InputTruncation(node, 0));\n      break;\n    }\n    case IrOpcode::kReturn: {\n      const int return_value_count = ValueInputCountOfReturn(node->op());\n      for (int i = 0; i < return_value_count; ++i) {\n        Type input_type = InputType(node, 1 + i);\n        Truncation input_trunc = InputTruncation(node, 1 + i);\n        input_trunc = GeneralizeTruncation(input_trunc, input_type);\n        // No values must be lost due to truncation.\n        CHECK_EQ(input_trunc, Truncation::Any());\n      }\n      break;\n    }\n    case IrOpcode::kSLVerifierHint: {\n      Type output_type = InputType(node, 0);\n      Truncation output_trunc = InputTruncation(node, 0);\n      const auto& p = SLVerifierHintParametersOf(node->op());\n\n      if (const Operator* semantics = p.semantics()) {\n        switch (semantics->opcode()) {\n          case IrOpcode::kPlainPrimitiveToNumber:\n            output_type = op_typer.ToNumber(output_type);\n            break;\n          default:\n            UNREACHABLE();\n        }\n      }\n\n      if (p.override_output_type()) {\n        output_type = *p.override_output_type();\n      }\n\n      SetType(node, output_type);\n      SetTruncation(node, GeneralizeTruncation(output_trunc, output_type));\n      break;\n    }\n    case IrOpcode::kBranch: {\n      CHECK_EQ(BranchParametersOf(node->op()).semantics(),\n               BranchSemantics::kMachine);\n      Type input_type = InputType(node, 0);\n      CHECK(input_type.Is(Type::Boolean()) || input_type.Is(Type::Machine()));\n      break;\n    }\n    case IrOpcode::kTypedStateValues: {\n      const ZoneVector<MachineType>* machine_types = MachineTypesOf(node->op());\n      for (int i = 0; i < static_cast<int>(machine_types->size()); ++i) {\n        // Inputs must not be truncated.\n        CHECK_EQ(InputTruncation(node, i), Truncation::Any());\n        CHECK(IsNonTruncatingMachineTypeFor(machine_types->at(i),\n                                            InputType(node, i), graph_zone()));\n      }\n      break;\n    }\n    case IrOpcode::kParameter: {\n      CHECK(NodeProperties::IsTyped(node));\n      SetTruncation(node, Truncation::Any());\n      break;\n    }\n    case IrOpcode::kEnterMachineGraph:\n    case IrOpcode::kExitMachineGraph: {\n      // Eliminated during lowering.\n      UNREACHABLE();\n    }\n\n#define CASE(code, ...) case IrOpcode::k##code:\n      // Control operators\n      CASE(Loop)\n      CASE(Switch)\n      CASE(IfSuccess)\n      CASE(IfException)\n      CASE(IfValue)\n      CASE(IfDefault)\n      CASE(Deoptimize)\n      CASE(DeoptimizeIf)\n      CASE(DeoptimizeUnless)\n      CASE(TrapIf)\n      CASE(TrapUnless)\n      CASE(Assert)\n      CASE(TailCall)\n      CASE(Terminate)\n      CASE(Throw)\n      CASE(TraceInstruction)\n      // Constant operators\n      CASE(TaggedIndexConstant)\n      CASE(Float32Constant)\n      CASE(ExternalConstant)\n      CASE(NumberConstant)\n      CASE(PointerConstant)\n      CASE(CompressedHeapConstant)\n      CASE(TrustedHeapConstant)\n      CASE(RelocatableInt32Constant)\n      CASE(RelocatableInt64Constant)\n      // Inner operators\n      CASE(Select)\n      CASE(Phi)\n      CASE(InductionVariablePhi)\n      CASE(BeginRegion)\n      CASE(FinishRegion)\n      CASE(StateValues)\n      CASE(ArgumentsElementsState)\n      CASE(ArgumentsLengthState)\n      CASE(ObjectState)\n      CASE(ObjectId)\n      CASE(TypedObjectState)\n      CASE(Call)\n      CASE(OsrValue)\n      CASE(LoopExit)\n      CASE(LoopExitValue)\n      CASE(LoopExitEffect)\n      CASE(Projection)\n      CASE(Retain)\n      CASE(MapGuard)\n      CASE(Unreachable)\n      CASE(Dead)\n      CASE(Plug)\n      CASE(StaticAssert)\n      // Simplified change operators\n      CASE(ChangeTaggedSignedToInt32)\n      CASE(ChangeTaggedToInt32)\n      CASE(ChangeTaggedToInt64)\n      CASE(ChangeTaggedToUint32)\n      CASE(ChangeTaggedToFloat64)\n      CASE(ChangeTaggedToTaggedSigned)\n      CASE(ChangeInt64ToTagged)\n      CASE(ChangeUint32ToTagged)\n      CASE(ChangeFloat64ToTagged)\n      CASE(ChangeFloat64ToTaggedPointer)\n      CASE(ChangeTaggedToBit)\n      CASE(ChangeBitToTagged)\n      CASE(ChangeInt64ToBigInt)\n      CASE(ChangeUint64ToBigInt)\n      CASE(TruncateTaggedToWord32)\n      CASE(TruncateTaggedToFloat64)\n      CASE(TruncateTaggedPointerToBit)\n      // Simplified checked operators\n      CASE(CheckedInt32Add)\n      CASE(CheckedInt32Sub)\n      CASE(CheckedInt32Div)\n      CASE(CheckedInt32Mod)\n      CASE(CheckedUint32Div)\n      CASE(CheckedUint32Mod)\n      CASE(CheckedInt32Mul)\n      CASE(CheckedAdditiveSafeIntegerAdd)\n      CASE(CheckedAdditiveSafeIntegerSub)\n      CASE(CheckedInt64Add)\n      CASE(CheckedInt64Sub)\n      CASE(CheckedInt64Mul)\n      CASE(CheckedInt64Div)\n      CASE(CheckedInt64Mod)\n      CASE(CheckedInt32ToTaggedSigned)\n      CASE(CheckedInt64ToInt32)\n      CASE(CheckedInt64ToTaggedSigned)\n      CASE(CheckedUint32Bounds)\n      CASE(CheckedUint32ToInt32)\n      CASE(CheckedUint32ToTaggedSigned)\n      CASE(CheckedUint64Bounds)\n      CASE(CheckedUint64ToInt32)\n      CASE(CheckedUint64ToInt64)\n      CASE(CheckedUint64ToTaggedSigned)\n      CASE(CheckedFloat64ToAdditiveSafeInteger)\n      CASE(CheckedFloat64ToInt64)\n      CASE(CheckedTaggedSignedToInt32)\n      CASE(CheckedTaggedToInt32)\n      CASE(CheckedTaggedToArrayIndex)\n      CASE(CheckedTruncateTaggedToWord32)\n      CASE(CheckedTaggedToFloat64)\n      CASE(CheckedTaggedToAdditiveSafeInteger)\n      CASE(CheckedTaggedToInt64)\n      SIMPLIFIED_COMPARE_BINOP_LIST(CASE)\n      SIMPLIFIED_NUMBER_BINOP_LIST(CASE)\n      SIMPLIFIED_BIGINT_BINOP_LIST(CASE)\n      SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(CASE)\n      SIMPLIFIED_NUMBER_UNOP_LIST(CASE)\n      // Simplified unary bigint operators\n      CASE(BigIntNegate)\n      SIMPLIFIED_SPECULATIVE_NUMBER_UNOP_LIST(CASE)\n      SIMPLIFIED_SPECULATIVE_BIGINT_UNOP_LIST(CASE)\n      SIMPLIFIED_SPECULATIVE_BIGINT_BINOP_LIST(CASE)\n      SIMPLIFIED_OTHER_OP_LIST(CASE)\n      MACHINE_COMPARE_BINOP_LIST(CASE)\n      MACHINE_UNOP_32_LIST(CASE)\n      // Binary 32bit machine operators\n      CASE(Word32And)\n      CASE(Word32Or)\n      CASE(Word32Xor)\n      CASE(Word32Shl)\n      CASE(Word32Shr)\n      CASE(Word32Sar)\n      CASE(Word32Rol)\n      CASE(Word32Ror)\n      CASE(Int32AddWithOverflow)\n      CASE(Int32SubWithOverflow)\n      CASE(Int32Mul)\n      CASE(Int32MulWithOverflow)\n      CASE(Int32MulHigh)\n      CASE(Int32Div)\n      CASE(Int32Mod)\n      CASE(Uint32Div)\n      CASE(Uint32Mod)\n      CASE(Uint32MulHigh)\n      // Binary 64bit machine operators\n      CASE(Word64And)\n      CASE(Word64Or)\n      CASE(Word64Xor)\n      CASE(Word64Shl)\n      CASE(Word64Shr)\n      CASE(Word64Sar)\n      CASE(Word64Rol)\n      CASE(Word64Ror)\n      CASE(Word64RolLowerable)\n      CASE(Word64RorLowerable)\n      CASE(Int64AddWithOverflow)\n      CASE(Int64SubWithOverflow)\n      CASE(Int64Mul)\n      CASE(Int64MulHigh)\n      CASE(Uint64MulHigh)\n      CASE(Int64MulWithOverflow)\n      CASE(Int64Div)\n      CASE(Int64Mod)\n      CASE(Uint64Div)\n      CASE(Uint64Mod)\n      MACHINE_FLOAT32_UNOP_LIST(CASE)\n      MACHINE_FLOAT32_BINOP_LIST(CASE)\n      MACHINE_FLOAT64_UNOP_LIST(CASE)\n      MACHINE_FLOAT64_BINOP_LIST(CASE)\n      MACHINE_ATOMIC_OP_LIST(CASE)\n      CASE(AbortCSADcheck)\n      CASE(DebugBreak)\n      CASE(Comment)\n      CASE(Load)\n      CASE(LoadImmutable)\n      CASE(Store)\n      CASE(StorePair)\n      CASE(StoreIndirectPointer)\n      CASE(StackSlot)\n      CASE(Word32Popcnt)\n      CASE(Word64Popcnt)\n      CASE(Word64Clz)\n      CASE(Word64Ctz)\n      CASE(Word64ClzLowerable)\n      CASE(Word64CtzLowerable)\n      CASE(Word64ReverseBits)\n      CASE(Word64ReverseBytes)\n      CASE(Simd128ReverseBytes)\n      CASE(Int64AbsWithOverflow)\n      CASE(BitcastTaggedToWord)\n      CASE(BitcastTaggedToWordForTagAndSmiBits)\n      CASE(BitcastWordToTagged)\n      CASE(BitcastWordToTaggedSigned)\n      CASE(TruncateFloat64ToWord32)\n      CASE(ChangeFloat64ToInt32)\n      CASE(ChangeFloat64ToUint32)\n      CASE(ChangeFloat64ToUint64)\n      CASE(Float64SilenceNaN)\n      CASE(TruncateFloat64ToInt64)\n      CASE(TruncateFloat64ToUint32)\n      CASE(TruncateFloat32ToInt32)\n      CASE(TruncateFloat32ToUint32)\n      CASE(TryTruncateFloat32ToInt64)\n      CASE(TryTruncateFloat64ToInt64)\n      CASE(TryTruncateFloat32ToUint64)\n      CASE(TryTruncateFloat64ToUint64)\n      CASE(TryTruncateFloat64ToInt32)\n      CASE(TryTruncateFloat64ToUint32)\n      CASE(ChangeInt32ToFloat64)\n      CASE(BitcastWord32ToWord64)\n      CASE(ChangeInt64ToFloat64)\n      CASE(ChangeUint32ToFloat64)\n      CASE(ChangeFloat16RawBitsToFloat64)\n      CASE(TruncateFloat64ToFloat32)\n      CASE(TruncateFloat64ToFloat16RawBits)\n      CASE(TruncateInt64ToInt32)\n      CASE(RoundFloat64ToInt32)\n      CASE(RoundInt32ToFloat32)\n      CASE(RoundInt64ToFloat32)\n      CASE(RoundInt64ToFloat64)\n      CASE(RoundUint32ToFloat32)\n      CASE(RoundUint64ToFloat32)\n      CASE(RoundUint64ToFloat64)\n      CASE(BitcastFloat32ToInt32)\n      CASE(BitcastFloat64ToInt64)\n      CASE(BitcastInt32ToFloat32)"
}