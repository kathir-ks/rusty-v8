{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/ast/prettyprinter.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/ast/prettyprinter.cc\",\n        \"file_name\": \"prettyprinter.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides functionality to print AST nodes for debugging and error reporting purposes, specifically for call stack inspection.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Include necessary headers for AST node definitions, standard library functions, string manipulation, and other V8 specific functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/ast/prettyprinter.h\"\n\n            #include <stdarg.h>\n\n            #include \"src/ast/ast-value-factory.h\"\n            #include \"src/ast/scopes.h\"\n            #include \"src/base/strings.h\"\n            #include \"src/base/vector.h\"\n            #include \"src/common/globals.h\"\n            #include \"src/objects/objects-inl.h\"\n            #include \"src/regexp/regexp-flags.h\"\n            #include \"src/strings/string-builder-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CallPrinter\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Prints function calls in a human-readable format for debugging, focusing on the point where an error occurred.\",\n            \"attributes\": [\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the V8 isolate.\"\n                },\n                {\n                    \"name\": \"builder_\",\n                    \"type\": \"StringBuilder\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Used to build the string representation of the function call.\"\n                },\n                {\n                    \"name\": \"position_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The position in the source code where the call should be printed.\"\n                },\n                {\n                    \"name\": \"num_prints_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Tracks the number of print operations performed.\"\n                },\n                {\n                    \"name\": \"found_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the target call position has been found.\"\n                },\n                {\n                    \"name\": \"done_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if printing is complete.\"\n                },\n                {\n                    \"name\": \"is_call_error_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the error is related to a function call.\"\n                },\n                {\n                    \"name\": \"is_iterator_error_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the error is related to an iterator.\"\n                },\n                {\n                    \"name\": \"is_async_iterator_error_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates if the error is related to an async iterator.\"\n                },\n                {\n                    \"name\": \"destructuring_prop_\",\n                    \"type\": \"ObjectLiteralProperty*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the property of a destructuring object literal.\"\n                },\n                {\n                    \"name\": \"destructuring_assignment_\",\n                    \"type\": \"Assignment*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the destructuring assignment node.\"\n                },\n                {\n                    \"name\": \"is_user_js_\",\n                    \"type\": \"bool\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates whether the code is user JavaScript or internal.\"\n                },\n                {\n                    \"name\": \"error_in_spread_args_\",\n                    \"type\": \"SpreadErrorInArgsHint\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Indicates the error location in spread arguments\"\n                },\n                {\n                    \"name\": \"spread_arg_\",\n                    \"type\": \"Expression*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the expression of the spread argument\"\n                },\n                {\n                    \"name\": \"function_kind_\",\n                    \"type\": \"FunctionKind\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The kind of function being printed\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"StringBuilder\",\n                \"AstNode\",\n                \"FunctionLiteral\",\n                \"String\",\n                \"Block\",\n                \"VariableDeclaration\",\n                \"FunctionDeclaration\",\n                \"ExpressionStatement\",\n                \"EmptyStatement\",\n                \"SloppyBlockFunctionStatement\",\n                \"IfStatement\",\n                \"ContinueStatement\",\n                \"BreakStatement\",\n                \"ReturnStatement\",\n                \"WithStatement\",\n                \"SwitchStatement\",\n                \"CaseClause\",\n                \"DoWhileStatement\",\n                \"WhileStatement\",\n                \"ForStatement\",\n                \"ForInStatement\",\n                \"ForOfStatement\",\n                \"TryCatchStatement\",\n                \"TryFinallyStatement\",\n                \"DebuggerStatement\",\n                \"ClassLiteral\",\n                \"NativeFunctionLiteral\",\n                \"ConditionalChain\",\n                \"Conditional\",\n                \"Literal\",\n                \"RegExpLiteral\",\n                \"ObjectLiteral\",\n                \"ArrayLiteral\",\n                \"VariableProxy\",\n                \"Assignment\",\n                \"CompoundAssignment\",\n                \"Yield\",\n                \"YieldStar\",\n                \"Await\",\n                \"Throw\",\n                \"Property\",\n                \"Call\",\n                \"CallNew\",\n                \"CallRuntime\",\n                \"SuperCallForwardArgs\",\n                \"UnaryOperation\",\n                \"CountOperation\",\n                \"BinaryOperation\",\n                \"CompareOperation\",\n                \"Spread\",\n                \"EmptyParentheses\",\n                \"GetTemplateObject\",\n                \"TemplateLiteral\",\n                \"ImportCallExpression\",\n                \"ThisExpression\",\n                \"SuperPropertyReference\",\n                \"SuperCallReference\",\n                \"ZonePtrList\",\n                \"Statement\",\n                \"Expression\",\n                \"ObjectLiteralProperty\",\n                \"FunctionKind\",\n                \"InitializeClassMembersStatement\",\n                \"InitializeClassStaticElementsStatement\",\n                \"AutoAccessorGetterBody\",\n                \"AutoAccessorSetterBody\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class CallPrinter : public AstVisitor<CallPrinter> {\n            public:\n              enum class ErrorHint {\n                kNone,\n                kCallAndNormalIterator,\n                kCallAndAsyncIterator,\n                kNormalIterator,\n                kAsyncIterator,\n              };\n\n              CallPrinter(Isolate* isolate, bool is_user_js,\n                         SpreadErrorInArgsHint error_in_spread_args);\n              ~CallPrinter() override;\n\n              DirectHandle<String> Print(FunctionLiteral* program, int position);\n\n              ErrorHint GetErrorHint() const;\n\n            private:\n              void Find(AstNode* node, bool print = false);\n              void Print(char c);\n              void Print(const char* str);\n              void Print(DirectHandle<String> str);\n              void PrintLiteral(DirectHandle<Object> value, bool quote);\n              void PrintLiteral(const AstRawString* value, bool quote);\n              void FindStatements(const ZonePtrList<Statement>* statements);\n              void FindArguments(const ZonePtrList<Expression>* arguments);\n              Isolate* isolate_;\n              StringBuilder builder_;\n              int position_;\n              int num_prints_;\n              bool found_;\n              bool done_;\n              bool is_call_error_;\n              bool is_iterator_error_;\n              bool is_async_iterator_error_;\n              ObjectLiteralProperty* destructuring_prop_;\n              Assignment* destructuring_assignment_;\n              bool is_user_js_;\n              SpreadErrorInArgsHint error_in_spread_args_;\n              Expression* spread_arg_;\n              FunctionKind function_kind_;\n\n              // AstVisitor overrides\n              void VisitBlock(Block* node) override;\n              void VisitVariableDeclaration(VariableDeclaration* node) override;\n              void VisitFunctionDeclaration(FunctionDeclaration* node) override;\n              void VisitExpressionStatement(ExpressionStatement* node) override;\n              void VisitEmptyStatement(EmptyStatement* node) override;\n              void VisitSloppyBlockFunctionStatement(\n                  SloppyBlockFunctionStatement* node) override;\n              void VisitIfStatement(IfStatement* node) override;\n              void VisitContinueStatement(ContinueStatement* node) override;\n              void VisitBreakStatement(BreakStatement* node) override;\n              void VisitReturnStatement(ReturnStatement* node) override;\n              void VisitWithStatement(WithStatement* node) override;\n              void VisitSwitchStatement(SwitchStatement* node) override;\n              void VisitDoWhileStatement(DoWhileStatement* node) override;\n              void VisitWhileStatement(WhileStatement* node) override;\n              void VisitForStatement(ForStatement* node) override;\n              void VisitForInStatement(ForInStatement* node) override;\n              void VisitForOfStatement(ForOfStatement* node) override;\n              void VisitTryCatchStatement(TryCatchStatement* node) override;\n              void VisitTryFinallyStatement(TryFinallyStatement* node) override;\n              void VisitDebuggerStatement(DebuggerStatement* node) override;\n              void VisitFunctionLiteral(FunctionLiteral* node) override;\n              void VisitClassLiteral(ClassLiteral* node) override;\n              void VisitInitializeClassMembersStatement(\n                  InitializeClassMembersStatement* node) override;\n              void VisitInitializeClassStaticElementsStatement(\n                  InitializeClassStaticElementsStatement* node) override;\n              void VisitAutoAccessorGetterBody(AutoAccessorGetterBody* node) override;\n              void VisitAutoAccessorSetterBody(AutoAccessorSetterBody* node) override;\n              void VisitNativeFunctionLiteral(NativeFunctionLiteral* node) override;\n              void VisitConditionalChain(ConditionalChain* node) override;\n              void VisitConditional(Conditional* node) override;\n              void VisitLiteral(Literal* node) override;\n              void VisitRegExpLiteral(RegExpLiteral* node) override;\n              void VisitObjectLiteral(ObjectLiteral* node) override;\n              void VisitArrayLiteral(ArrayLiteral* node) override;\n              void VisitVariableProxy(VariableProxy* node) override;\n              void VisitAssignment(Assignment* node) override;\n              void VisitCompoundAssignment(CompoundAssignment* node) override;\n              void VisitYield(Yield* node) override;\n              void VisitYieldStar(YieldStar* node) override;\n              void VisitAwait(Await* node) override;\n              void VisitThrow(Throw* node) override;\n              void VisitOptionalChain(OptionalChain* node) override;\n              void VisitProperty(Property* node) override;\n              void VisitCall(Call* node) override;\n              void VisitCallNew(CallNew* node) override;\n              void VisitCallRuntime(CallRuntime* node) override;\n              void VisitSuperCallForwardArgs(SuperCallForwardArgs* node) override;\n              void VisitUnaryOperation(UnaryOperation* node) override;\n              void VisitCountOperation(CountOperation* node) override;\n              void VisitBinaryOperation(BinaryOperation* node) override;\n              void VisitNaryOperation(NaryOperation* node) override;\n              void VisitCompareOperation(CompareOperation* node) override;\n              void VisitSpread(Spread* node) override;\n              void VisitEmptyParentheses(EmptyParentheses* node) override;\n              void VisitGetTemplateObject(GetTemplateObject* node) override;\n              void VisitTemplateLiteral(TemplateLiteral* node) override;\n              void VisitImportCallExpression(ImportCallExpression* node) override;\n              void VisitThisExpression(ThisExpression* node) override;\n              void VisitSuperPropertyReference(SuperPropertyReference* node) override;\n              void VisitSuperCallReference(SuperCallReference* node) override;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CallPrinter\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Constructor for the CallPrinter class.\",\n            \"logic\": \"Initializes the CallPrinter with the isolate, user code flag, and spread arguments hint.  Sets up the string builder and other internal state.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The V8 isolate.\"\n                },\n                {\n                    \"name\": \"is_user_js\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Flag indicating if the code being printed is user code.\"\n                },\n                {\n                    \"name\": \"error_in_spread_args\",\n                    \"type\": \"SpreadErrorInArgsHint\",\n                    \"purpose\": \"Hint to indicate where an error occurred in spread arguments.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StringBuilder\",\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            CallPrinter::CallPrinter(Isolate* isolate, bool is_user_js,\n                                     SpreadErrorInArgsHint error_in_spread_args)\n                : builder_(isolate) {\n              isolate_ = isolate;\n              position_ = 0;\n              num_prints_ = 0;\n              found_ = false;\n              done_ = false;\n              is_call_error_ = false;\n              is_iterator_error_ = false;\n              is_async_iterator_error_ = false;\n              destructuring_prop_ = nullptr;\n              destructuring_assignment_ = nullptr;\n              is_user_js_ = is_user_js;\n              error_in_spread_args_ = error_in_spread_args;\n              spread_arg_ = nullptr;\n              function_kind_ = FunctionKind::kNormalFunction;\n              InitializeAstVisitor(isolate);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"~CallPrinter\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Destructor for the CallPrinter class.\",\n            \"logic\": \"The destructor does nothing explicitly, but the `= default` ensures proper cleanup of member variables.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            CallPrinter::~CallPrinter() = default;\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetErrorHint\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Determines the error hint based on internal flags.\",\n            \"logic\": \"Checks the `is_call_error_`, `is_iterator_error_`, and `is_async_iterator_error_` flags and returns the appropriate ErrorHint enum value.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"ErrorHint\",\n                \"description\": \"The appropriate error hint based on the internal state.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            CallPrinter::ErrorHint CallPrinter::GetErrorHint() const {\n              if (is_call_error_) {\n                if (is_iterator_error_) return ErrorHint::kCallAndNormalIterator;\n                if (is_async_iterator_error_) return ErrorHint::kCallAndAsyncIterator;\n              } else {\n                if (is_iterator_error_) return ErrorHint::kNormalIterator;\n                if (is_async_iterator_error_) return ErrorHint::kAsyncIterator;\n              }\n              return ErrorHint::kNone;\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Print\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Prints the function call stack information for a given function literal and position.\",\n            \"logic\": \"Resets the internal state, sets the position, calls the Find method to traverse the AST and print, and returns the finished string.\",\n            \"parameters\": [\n                {\n                    \"name\": \"program\",\n                    \"type\": \"FunctionLiteral*\",\n                    \"purpose\": \"The function literal to print.\"\n                },\n                {\n                    \"name\": \"position\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The position in the source code to focus on.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"DirectHandle<String>\",\n                \"description\": \"The string representation of the function call.\"\n            },\n            \"dependencies\": [\n                \"FunctionLiteral\",\n                \"Find\",\n                \"StringBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            DirectHandle<String> CallPrinter::Print(FunctionLiteral* program,\n                                                  int position) {\n              num_prints_ = 0;\n              position_ = position;\n              Find(program);\n              return builder_.Finish().ToHandleChecked();\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Find\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Traverses the AST to find the node at the specified position and prints the surrounding code.\",\n            \"logic\": \"If the target position has been found, it visits the node, printing if necessary. Otherwise, it simply visits the node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"AstNode*\",\n                    \"purpose\": \"The AST node to visit.\"\n                },\n                {\n                    \"name\": \"print\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Flag indicating whether to print the node.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"AstNode\",\n                \"Visit\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::Find(AstNode* node, bool print) {\n              if (found_) {\n                if (print) {\n                  int prev_num_prints = num_prints_;\n                  Visit(node);\n                  if (prev_num_prints != num_prints_) return;\n                }\n                Print(\"(intermediate value)\");\n              } else {\n                Visit(node);\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Print\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Prints a single character to the output.\",\n            \"logic\": \"Appends the character to the string builder if the target position has been found and printing is not done.\",\n            \"parameters\": [\n                {\n                    \"name\": \"c\",\n                    \"type\": \"char\",\n                    \"purpose\": \"The character to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StringBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::Print(char c) {\n              if (!found_ || done_) return;\n              num_prints_++;\n              builder_.AppendCharacter(c);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Print\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Prints a C-style string to the output.\",\n            \"logic\": \"Appends the C-style string to the string builder if the target position has been found and printing is not done.\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"const char*\",\n                    \"purpose\": \"The string to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StringBuilder\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::Print(const char* str) {\n              if (!found_ || done_) return;\n              num_prints_++;\n              builder_.AppendCString(str);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Print\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Prints a V8 String object to the output.\",\n            \"logic\": \"Appends the V8 String object to the string builder if the target position has been found and printing is not done.\",\n            \"parameters\": [\n                {\n                    \"name\": \"str\",\n                    \"type\": \"DirectHandle<String>\",\n                    \"purpose\": \"The string to print.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"StringBuilder\",\n                \"String\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::Print(DirectHandle<String> str) {\n              if (!found_ || done_) return;\n              num_prints_++;\n              builder_.AppendString(str);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitBlock\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a Block node in the AST.\",\n            \"logic\": \"Calls FindStatements to traverse the statements within the block.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"Block*\",\n                    \"purpose\": \"The Block node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Block\",\n                \"FindStatements\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitBlock(Block* node) {\n              FindStatements(node->statements());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitVariableDeclaration\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a VariableDeclaration node in the AST (does nothing).\",\n            \"logic\": \"This method currently performs no action.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"VariableDeclaration*\",\n                    \"purpose\": \"The VariableDeclaration node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"VariableDeclaration\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitVariableDeclaration(VariableDeclaration* node) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitFunctionDeclaration\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a FunctionDeclaration node in the AST (does nothing).\",\n            \"logic\": \"This method currently performs no action.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"FunctionDeclaration*\",\n                    \"purpose\": \"The FunctionDeclaration node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FunctionDeclaration\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitFunctionDeclaration(FunctionDeclaration* node) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitExpressionStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits an ExpressionStatement node in the AST.\",\n            \"logic\": \"Calls Find to visit the expression within the statement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"ExpressionStatement*\",\n                    \"purpose\": \"The ExpressionStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ExpressionStatement\",\n                \"Find\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitExpressionStatement(ExpressionStatement* node) {\n              Find(node->expression());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitEmptyStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits an EmptyStatement node in the AST (does nothing).\",\n            \"logic\": \"This method currently performs no action.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"EmptyStatement*\",\n                    \"purpose\": \"The EmptyStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"EmptyStatement\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitEmptyStatement(EmptyStatement* node) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitSloppyBlockFunctionStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a SloppyBlockFunctionStatement node in the AST.\",\n            \"logic\": \"Calls Find to visit the statement within the node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"SloppyBlockFunctionStatement*\",\n                    \"purpose\": \"The SloppyBlockFunctionStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"SloppyBlockFunctionStatement\",\n                \"Find\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitSloppyBlockFunctionStatement(\n                SloppyBlockFunctionStatement* node) {\n              Find(node->statement());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitIfStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits an IfStatement node in the AST.\",\n            \"logic\": \"Calls Find to visit the condition, then statement, and else statement (if present).\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"IfStatement*\",\n                    \"purpose\": \"The IfStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"IfStatement\",\n                \"Find\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitIfStatement(IfStatement* node) {\n              Find(node->condition());\n              Find(node->then_statement());\n              if (node->HasElseStatement()) {\n                Find(node->else_statement());\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitContinueStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a ContinueStatement node in the AST (does nothing).\",\n            \"logic\": \"This method currently performs no action.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"ContinueStatement*\",\n                    \"purpose\": \"The ContinueStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ContinueStatement\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitContinueStatement(ContinueStatement* node) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitBreakStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a BreakStatement node in the AST (does nothing).\",\n            \"logic\": \"This method currently performs no action.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"BreakStatement*\",\n                    \"purpose\": \"The BreakStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"BreakStatement\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitBreakStatement(BreakStatement* node) {}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitReturnStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a ReturnStatement node in the AST.\",\n            \"logic\": \"Calls Find to visit the expression being returned.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"ReturnStatement*\",\n                    \"purpose\": \"The ReturnStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ReturnStatement\",\n                \"Find\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitReturnStatement(ReturnStatement* node) {\n              Find(node->expression());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitWithStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a WithStatement node in the AST.\",\n            \"logic\": \"Calls Find to visit the expression and the statement within the with statement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"WithStatement*\",\n                    \"purpose\": \"The WithStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"WithStatement\",\n                \"Find\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitWithStatement(WithStatement* node) {\n              Find(node->expression());\n              Find(node->statement());\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitSwitchStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a SwitchStatement node in the AST.\",\n            \"logic\": \"Calls Find to visit the tag and then iterates through each case clause, visiting the label (if not default) and the statements.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"SwitchStatement*\",\n                    \"purpose\": \"The SwitchStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"SwitchStatement\",\n                \"Find\",\n                \"CaseClause\",\n                \"FindStatements\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitSwitchStatement(SwitchStatement* node) {\n              Find(node->tag());\n              for (CaseClause* clause : *node->cases()) {\n                if (!clause->is_default()) Find(clause->label());\n                FindStatements(clause->statements());\n              }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"VisitDoWhileStatement\",\n            \"parent\": \"CallPrinter\",\n            \"about\": \"Visits a DoWhileStatement node in the AST.\",\n            \"logic\": \"Calls Find to visit the body and the condition of the do-while loop.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"DoWhileStatement*\",\n                    \"purpose\": \"The DoWhileStatement node to visit.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"DoWhileStatement\",\n                \"Find\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void CallPrinter::VisitDoWhileStatement(DoWhileStatement* node) {\n              Find(node->body());\n              Find(node->cond());\n"
}