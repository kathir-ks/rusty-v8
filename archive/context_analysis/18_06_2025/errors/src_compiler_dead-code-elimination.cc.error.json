{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/dead-code-elimination.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/dead-code-elimination.cc\",\n            \"file_name\": \"dead-code-elimination.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements dead code elimination optimization in the Turbofan compiler.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary headers for dead code elimination, common operators, node properties, and the Turbofan graph.\"\n            }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/dead-code-elimination.h\"\n\n#include \"src/compiler/common-operator.h\"\n#include \"src/compiler/node-properties.h\"\n#include \"src/compiler/operator-properties.h\"\n#include \"src/compiler/turbofan-graph.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"DeadCodeElimination\",\n                \"extends\": \"AdvancedReducer\",\n                \"about\": \"Performs dead code elimination on the Turbofan graph.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"graph_\",\n                        \"type\": \"TFGraph*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The Turbofan graph to optimize.\"\n                    },\n                    {\n                        \"name\": \"common_\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"The common operator builder.\"\n                    },\n                    {\n                        \"name\": \"dead_\",\n                        \"type\": \"Node*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A node representing dead code.\"\n                    },\n                    {\n                        \"name\": \"zone_\",\n                        \"type\": \"Zone*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"A temporary zone for allocations.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Editor\",\n                    \"TFGraph\",\n                    \"CommonOperatorBuilder\",\n                    \"Zone\",\n                    \"AdvancedReducer\",\n                    \"NodeProperties\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nclass DeadCodeElimination : public AdvancedReducer {\n public:\n  DeadCodeElimination(Editor* editor, TFGraph* graph,\n                                         CommonOperatorBuilder* common,\n                                         Zone* temp_zone);\n\n  Reduction Reduce(Node* node) override;\n\n private:\n  Reduction PropagateDeadControl(Node* node);\n  Reduction ReduceEnd(Node* node);\n  Reduction ReduceLoopOrMerge(Node* node);\n  Reduction RemoveLoopExit(Node* node);\n  Reduction ReduceNode(Node* node);\n  Reduction ReducePhi(Node* node);\n  Reduction ReduceEffectPhi(Node* node);\n  Reduction ReducePureNode(Node* node);\n  Reduction ReduceUnreachableOrIfException(Node* node);\n  Reduction ReduceEffectNode(Node* node);\n  Reduction ReduceDeoptimizeOrReturnOrTerminateOrTailCall(Node* node);\n  Reduction ReduceLoopExit(Node* node);\n  Reduction ReduceBranchOrSwitch(Node* node);\n\n  void TrimMergeOrPhi(Node* node, int size);\n  Node* DeadValue(Node* node, MachineRepresentation rep = MachineRepresentation::kNone);\n\n  TFGraph* graph_;\n  CommonOperatorBuilder* common_;\n  Node* dead_;\n  Zone* zone_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"DeadCodeElimination\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Constructor for the DeadCodeElimination class.\",\n                \"logic\": \"Initializes the dead code elimination reducer with the editor, graph, common operator builder, and a temporary zone.  Also creates a 'dead' node and sets its type to None.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"editor\",\n                        \"type\": \"Editor*\",\n                        \"purpose\": \"The editor used for graph modifications.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The Turbofan graph to optimize.\"\n                    },\n                    {\n                        \"name\": \"common\",\n                        \"type\": \"CommonOperatorBuilder*\",\n                        \"purpose\": \"The common operator builder.\"\n                    },\n                    {\n                        \"name\": \"temp_zone\",\n                        \"type\": \"Zone*\",\n                        \"purpose\": \"A temporary zone for allocations.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Editor\",\n                    \"TFGraph\",\n                    \"CommonOperatorBuilder\",\n                    \"Zone\",\n                    \"CommonOperatorBuilder::Dead\",\n                    \"graph::NewNode\",\n                    \"NodeProperties::SetType\",\n                    \"Type::None\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nDeadCodeElimination::DeadCodeElimination(Editor* editor, TFGraph* graph,\n                                         CommonOperatorBuilder* common,\n                                         Zone* temp_zone)\n    : AdvancedReducer(editor),\n      graph_(graph),\n      common_(common),\n      dead_(graph->NewNode(common->Dead())),\n      zone_(temp_zone) {\n  NodeProperties::SetType(dead_, Type::None());\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"NoReturn\",\n                \"parent\": null,\n                \"about\": \"Determines if a node will never produce a value or effect.\",\n                \"logic\": \"Checks if the node's opcode is kDead, kUnreachable, or kDeadValue, or if the node's type is None.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to check.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"bool\",\n                    \"description\": \"True if the node will never produce a value or effect, false otherwise.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"NodeProperties\",\n                    \"Type\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nbool NoReturn(Node* node) {\n  return node->opcode() == IrOpcode::kDead ||\n         node->opcode() == IrOpcode::kUnreachable ||\n         node->opcode() == IrOpcode::kDeadValue ||\n         NodeProperties::GetTypeOrAny(node).IsNone();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"FindDeadInput\",\n                \"parent\": null,\n                \"about\": \"Finds a dead input node.\",\n                \"logic\": \"Iterates through the inputs of a node and returns the first input that is considered 'dead' (NoReturn returns true).\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node whose inputs are to be checked.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Node*\",\n                    \"description\": \"A pointer to the first dead input node, or nullptr if no dead input is found.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"NoReturn\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nNode* FindDeadInput(Node* node) {\n  for (Node* input : node->inputs()) {\n    if (NoReturn(input)) return input;\n  }\n  return nullptr;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Reduce\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces a node in the graph based on its opcode.\",\n                \"logic\": \"This is the main dispatch function of the dead code elimination. It switches on the opcode of the given node and calls the appropriate reduction function.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"ReduceEnd\",\n                    \"ReduceLoopOrMerge\",\n                    \"ReduceLoopExit\",\n                    \"ReduceUnreachableOrIfException\",\n                    \"ReducePhi\",\n                    \"ReduceEffectPhi\",\n                    \"ReduceDeoptimizeOrReturnOrTerminateOrTailCall\",\n                    \"PropagateDeadControl\",\n                    \"ReduceBranchOrSwitch\",\n                    \"ReduceNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::Reduce(Node* node) {\n  switch (node->opcode()) {\n    case IrOpcode::kEnd:\n      return ReduceEnd(node);\n    case IrOpcode::kLoop:\n    case IrOpcode::kMerge:\n      return ReduceLoopOrMerge(node);\n    case IrOpcode::kLoopExit:\n      return ReduceLoopExit(node);\n    case IrOpcode::kUnreachable:\n    case IrOpcode::kIfException:\n      return ReduceUnreachableOrIfException(node);\n    case IrOpcode::kPhi:\n      return ReducePhi(node);\n    case IrOpcode::kEffectPhi:\n      return ReduceEffectPhi(node);\n    case IrOpcode::kDeoptimize:\n    case IrOpcode::kReturn:\n    case IrOpcode::kTerminate:\n    case IrOpcode::kTailCall:\n      return ReduceDeoptimizeOrReturnOrTerminateOrTailCall(node);\n    case IrOpcode::kThrow:\n      return PropagateDeadControl(node);\n    case IrOpcode::kBranch:\n    case IrOpcode::kSwitch:\n      return ReduceBranchOrSwitch(node);\n    default:\n      return ReduceNode(node);\n  }\n  UNREACHABLE();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"PropagateDeadControl\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Propagates dead control to a node.\",\n                \"logic\": \"If the control input of the node is dead, replace the node with the dead control input.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to propagate dead control to.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"NodeProperties\",\n                    \"IrOpcode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::PropagateDeadControl(Node* node) {\n  DCHECK_EQ(1, node->op()->ControlInputCount());\n  Node* control = NodeProperties::GetControlInput(node);\n  if (control->opcode() == IrOpcode::kDead) return Replace(control);\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceEnd\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces an End node by removing dead inputs.\",\n                \"logic\": \"Iterates through the inputs of the End node, removes dead inputs, and compacts the live inputs. If all inputs are dead, replace the End node with a dead node. If some inputs were removed, trim the input count of the node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The End node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"dead\",\n                    \"Replace\",\n                    \"NodeProperties\",\n                    \"common\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::ReduceEnd(Node* node) {\n  DCHECK_EQ(IrOpcode::kEnd, node->opcode());\n  Node::Inputs inputs = node->inputs();\n  DCHECK_LE(1, inputs.count());\n  int live_input_count = 0;\n  for (int i = 0; i < inputs.count(); ++i) {\n    Node* const input = inputs[i];\n    // Skip dead inputs.\n    if (input->opcode() == IrOpcode::kDead) continue;\n    // Compact live inputs.\n    if (i != live_input_count) node->ReplaceInput(live_input_count, input);\n    ++live_input_count;\n  }\n  if (live_input_count == 0) {\n    return Replace(dead());\n  } else if (live_input_count < inputs.count()) {\n    node->TrimInputCount(live_input_count);\n    NodeProperties::ChangeOp(node, common()->End(live_input_count));\n    return Changed(node);\n  }\n  DCHECK_EQ(inputs.count(), live_input_count);\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceLoopOrMerge\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces a Loop or Merge node by removing dead inputs and simplifying if possible.\",\n                \"logic\": \"Iterates through the inputs of the Loop or Merge node, removing dead inputs and compacting the live inputs. If all inputs are dead, replace the node with a dead node. If only one input is live, replace the node with that input, and also handle associated Phi and LoopExit nodes. If inputs were removed, trim the input count of the node and associated Phi nodes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Loop or Merge node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"dead\",\n                    \"Replace\",\n                    \"NodeProperties\",\n                    \"NodeProperties::IsPhi\",\n                    \"Node::uses\",\n                    \"Node::InputAt\",\n                    \"Zone\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::ReduceLoopOrMerge(Node* node) {\n  DCHECK(IrOpcode::IsMergeOpcode(node->opcode()));\n  Node::Inputs inputs = node->inputs();\n  DCHECK_LE(1, inputs.count());\n  // Count the number of live inputs to {node} and compact them on the fly, also\n  // compacting the inputs of the associated {Phi} and {EffectPhi} uses at the\n  // same time.  We consider {Loop}s dead even if only the first control input\n  // is dead.\n  int live_input_count = 0;\n  if (node->opcode() != IrOpcode::kLoop ||\n      node->InputAt(0)->opcode() != IrOpcode::kDead) {\n    for (int i = 0; i < inputs.count(); ++i) {\n      Node* const input = inputs[i];\n      // Skip dead inputs.\n      if (input->opcode() == IrOpcode::kDead) continue;\n      // Compact live inputs.\n      if (live_input_count != i) {\n        node->ReplaceInput(live_input_count, input);\n        for (Node* const use : node->uses()) {\n          if (NodeProperties::IsPhi(use)) {\n            DCHECK_EQ(inputs.count() + 1, use->InputCount());\n            use->ReplaceInput(live_input_count, use->InputAt(i));\n          }\n        }\n      }\n      ++live_input_count;\n    }\n  }\n  if (live_input_count == 0) {\n    return Replace(dead());\n  } else if (live_input_count == 1) {\n    NodeVector loop_exits(zone_);\n    // Due to compaction above, the live input is at offset 0.\n    for (Node* const use : node->uses()) {\n      if (NodeProperties::IsPhi(use)) {\n        Replace(use, use->InputAt(0));\n      } else if (use->opcode() == IrOpcode::kLoopExit &&\n                 use->InputAt(1) == node) {\n        // Remember the loop exits so that we can mark their loop input dead.\n        // This has to be done after the use list iteration so that we do\n        // not mutate the use list while it is being iterated.\n        loop_exits.push_back(use);\n      } else if (use->opcode() == IrOpcode::kTerminate) {\n        DCHECK_EQ(IrOpcode::kLoop, node->opcode());\n        Replace(use, dead());\n      }\n    }\n    for (Node* loop_exit : loop_exits) {\n      loop_exit->ReplaceInput(1, dead());\n      Revisit(loop_exit);\n    }\n    return Replace(node->InputAt(0));\n  }\n  DCHECK_LE(2, live_input_count);\n  DCHECK_LE(live_input_count, inputs.count());\n  // Trim input count for the {Merge} or {Loop} node.\n  if (live_input_count < inputs.count()) {\n    // Trim input counts for all phi uses and revisit them.\n    for (Node* const use : node->uses()) {\n      if (NodeProperties::IsPhi(use)) {\n        use->ReplaceInput(live_input_count, node);\n        TrimMergeOrPhi(use, live_input_count);\n        Revisit(use);\n      }\n    }\n    TrimMergeOrPhi(node, live_input_count);\n    return Changed(node);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"RemoveLoopExit\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Removes a LoopExit node by replacing its uses with its input and replacing the node with its control input.\",\n                \"logic\": \"Replaces LoopExitValue and LoopExitEffect uses of the LoopExit node with the LoopExit node's input. Then, replaces the LoopExit node itself with its control input.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The LoopExit node to remove.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"Replace\",\n                    \"Node::uses\",\n                    \"NodeProperties\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::RemoveLoopExit(Node* node) {\n  DCHECK_EQ(IrOpcode::kLoopExit, node->opcode());\n  for (Node* const use : node->uses()) {\n    if (use->opcode() == IrOpcode::kLoopExitValue ||\n        use->opcode() == IrOpcode::kLoopExitEffect) {\n      Replace(use, use->InputAt(0));\n    }\n  }\n  Node* control = NodeProperties::GetControlInput(node, 0);\n  Replace(node, control);\n  return Replace(control);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceNode\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces a generic node based on its effect and control inputs.\",\n                \"logic\": \"If the node has a control input, propagate dead control. If the node is pure (no effect inputs or control outputs), reduce it as a pure node. If the node has effect inputs, reduce it as an effect node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"PropagateDeadControl\",\n                    \"ReducePureNode\",\n                    \"ReduceEffectNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::ReduceNode(Node* node) {\n  DCHECK(!IrOpcode::IsGraphTerminator(node->opcode()));\n  int const effect_input_count = node->op()->EffectInputCount();\n  int const control_input_count = node->op()->ControlInputCount();\n  DCHECK_LE(control_input_count, 1);\n  if (control_input_count == 1) {\n    Reduction reduction = PropagateDeadControl(node);\n    if (reduction.Changed()) return reduction;\n  }\n  if (effect_input_count == 0 &&\n      (control_input_count == 0 || node->op()->ControlOutputCount() == 0)) {\n    return ReducePureNode(node);\n  }\n  if (effect_input_count > 0) {\n    return ReduceEffectNode(node);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReducePhi\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces a Phi node by propagating dead control and handling DeadValue inputs.\",\n                \"logic\": \"If the Phi node's control input is dead, propagate dead control. If the Phi node's representation is None or its type is None, replace it with a DeadValue node. If any of the Phi node's value inputs are DeadValue nodes with different representations, replace them with DeadValue nodes with the correct representation.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Phi node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"PropagateDeadControl\",\n                    \"PhiRepresentationOf\",\n                    \"NodeProperties\",\n                    \"DeadValue\",\n                    \"DeadValueRepresentationOf\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::ReducePhi(Node* node) {\n  DCHECK_EQ(IrOpcode::kPhi, node->opcode());\n  Reduction reduction = PropagateDeadControl(node);\n  if (reduction.Changed()) return reduction;\n  MachineRepresentation rep = PhiRepresentationOf(node->op());\n  if (rep == MachineRepresentation::kNone ||\n      NodeProperties::GetTypeOrAny(node).IsNone()) {\n    return Replace(DeadValue(node, rep));\n  }\n  int input_count = node->op()->ValueInputCount();\n  for (int i = 0; i < input_count; ++i) {\n    Node* input = NodeProperties::GetValueInput(node, i);\n    if (input->opcode() == IrOpcode::kDeadValue &&\n        DeadValueRepresentationOf(input->op()) != rep) {\n      NodeProperties::ReplaceValueInput(node, DeadValue(input, rep), i);\n    }\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceEffectPhi\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces an EffectPhi node by propagating dead control and handling Unreachable inputs.\",\n                \"logic\": \"If the EffectPhi node's control input is dead, propagate dead control. If any of the EffectPhi node's effect inputs are Unreachable, connect the effect chain to the graph end with a Throw node, and remove the corresponding inputs from the merge and phi nodes.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The EffectPhi node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"PropagateDeadControl\",\n                    \"NodeProperties\",\n                    \"dead_\",\n                    \"graph_\",\n                    \"common_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::ReduceEffectPhi(Node* node) {\n  DCHECK_EQ(IrOpcode::kEffectPhi, node->opcode());\n  Reduction reduction = PropagateDeadControl(node);\n  if (reduction.Changed()) return reduction;\n\n  Node* merge = NodeProperties::GetControlInput(node);\n  DCHECK(merge->opcode() == IrOpcode::kMerge ||\n         merge->opcode() == IrOpcode::kLoop);\n  int input_count = node->op()->EffectInputCount();\n  for (int i = 0; i < input_count; ++i) {\n    Node* effect = NodeProperties::GetEffectInput(node, i);\n    if (effect->opcode() == IrOpcode::kUnreachable) {\n      // If Unreachable hits an effect phi, we can re-connect the effect chain\n      // to the graph end and delete the corresponding inputs from the merge and\n      // phi nodes.\n      Node* control = NodeProperties::GetControlInput(merge, i);\n      Node* throw_node = graph_->NewNode(common_->Throw(), effect, control);\n      MergeControlToEnd(graph_, common_, throw_node);\n      NodeProperties::ReplaceEffectInput(node, dead_, i);\n      NodeProperties::ReplaceControlInput(merge, dead_, i);\n      Revisit(merge);\n      reduction = Changed(node);\n    }\n  }\n  return reduction;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReducePureNode\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces a pure node (no effect inputs).\",\n                \"logic\": \"If the node is a DeadValue, do nothing. Otherwise, if any of the node's inputs are dead, replace the node with a DeadValue node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The pure node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"DeadValue\",\n                    \"FindDeadInput\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::ReducePureNode(Node* node) {\n  DCHECK_EQ(0, node->op()->EffectInputCount());\n  if (node->opcode() == IrOpcode::kDeadValue) return NoChange();\n  if (Node* input = FindDeadInput(node)) {\n    return Replace(DeadValue(input));\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceUnreachableOrIfException\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces an Unreachable or IfException node.\",\n                \"logic\": \"If the node's control input is dead, propagate dead control. If the node's effect input is Dead or Unreachable, replace the node with the effect input.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The Unreachable or IfException node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"PropagateDeadControl\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::ReduceUnreachableOrIfException(Node* node) {\n  DCHECK(node->opcode() == IrOpcode::kUnreachable ||\n         node->opcode() == IrOpcode::kIfException);\n  Reduction reduction = PropagateDeadControl(node);\n  if (reduction.Changed()) return reduction;\n  Node* effect = NodeProperties::GetEffectInput(node, 0);\n  if (effect->opcode() == IrOpcode::kDead) {\n    return Replace(effect);\n  }\n  if (effect->opcode() == IrOpcode::kUnreachable) {\n    return Replace(effect);\n  }\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceEffectNode\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces a node with effect inputs.\",\n                \"logic\": \"If the node's effect input is Dead, replace the node with the effect input. If any of the node's inputs are dead, and the effect input is Unreachable, relax effects and controls and replace the node with DeadValue. Otherwise, create an Unreachable node and replace the node with DeadValue.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"DeadValue\",\n                    \"FindDeadInput\",\n                    \"RelaxEffectsAndControls\",\n                    \"graph_\",\n                    \"common_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::ReduceEffectNode(Node* node) {\n  DCHECK_EQ(1, node->op()->EffectInputCount());\n  Node* effect = NodeProperties::GetEffectInput(node, 0);\n  if (effect->opcode() == IrOpcode::kDead) {\n    return Replace(effect);\n  }\n  if (Node* input = FindDeadInput(node)) {\n    if (effect->opcode() == IrOpcode::kUnreachable) {\n      RelaxEffectsAndControls(node);\n      return Replace(DeadValue(input));\n    }\n\n    Node* control = node->op()->ControlInputCount() == 1\n                        ? NodeProperties::GetControlInput(node, 0)\n                        : graph()->start();\n    Node* unreachable =\n        graph()->NewNode(common()->Unreachable(), effect, control);\n    NodeProperties::SetType(unreachable, Type::None());\n    ReplaceWithValue(node, DeadValue(input), node, control);\n    return Replace(unreachable);\n  }\n\n  return NoChange();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"ReduceDeoptimizeOrReturnOrTerminateOrTailCall\",\n                \"parent\": \"DeadCodeElimination\",\n                \"about\": \"Reduces a Deoptimize, Return, Terminate, or TailCall node.\",\n                \"logic\": \"If the node's control input is dead, propagate dead control. If any of the node's inputs are dead, create an Unreachable effect and replace the node with a Throw node.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to reduce.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"Reduction\",\n                    \"description\": \"The result of the reduction.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"IrOpcode\",\n                    \"PropagateDeadControl\",\n                    \"FindDeadInput\",\n                    \"graph_\",\n                    \"common_\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\nReduction DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall(\n    Node* node) {\n  DCHECK(node->opcode() == IrOpcode::kDeoptimize ||\n         node->opcode() == IrOpcode::kReturn ||\n         node->opcode() == IrOpcode::kTerminate ||\n         node->opcode() == IrOpcode::kTailCall);\n  Reduction reduction = PropagateDeadControl(node);\n  if (reduction.Changed()) return reduction;\n  // Terminate nodes are not part of actual control flow, so they should never\n  // be replaced with Throw.\n  if (node->opcode() != IrOpcode::kTerminate &&\n      FindDeadInput(node) != nullptr) {\n    Node* effect = NodeProperties::GetEffectInput(node, 0);\n    Node* control = NodeProperties::GetControlInput(node, 0);\n    if (effect->opcode() != IrOpcode::kUnreachable) {\n"
}