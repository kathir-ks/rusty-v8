{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/v8threads.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "mismatched tag: line 204, column 10",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/v8threads.h\",\n        \"file_name\": \"v8threads.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines classes for managing threads within the V8 JavaScript engine, including thread state, visiting threads, and thread management.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for atomic operations and the Isolate class.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <atomic>\n\n#include \"src/execution/isolate.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ThreadState\",\n            \"about\": \"Represents the state of a thread within the V8 engine.\",\n            \"attributes\": [\n                {\n                    \"name\": \"id_\",\n                    \"type\": \"ThreadId\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Stores the ID of the thread.\"\n                },\n                {\n                    \"name\": \"data_\",\n                    \"type\": \"char*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to data area for archiving the thread.\"\n                },\n                {\n                    \"name\": \"next_\",\n                    \"type\": \"ThreadState*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the next ThreadState in a linked list.\"\n                },\n                {\n                    \"name\": \"previous_\",\n                    \"type\": \"ThreadState*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the previous ThreadState in a linked list.\"\n                },\n                {\n                    \"name\": \"thread_manager_\",\n                    \"type\": \"ThreadManager*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the ThreadManager that owns this ThreadState.\"\n                }\n            ],\n            \"dependencies\": [\n                \"ThreadManager\",\n                \"ThreadId\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ThreadState {\n public:\n  // Returns nullptr after the last one.\n  ThreadState* Next();\n\n  enum List { FREE_LIST, IN_USE_LIST };\n\n  void LinkInto(List list);\n  void Unlink();\n\n  // Id of thread.\n  void set_id(ThreadId id) { id_ = id; }\n  ThreadId id() { return id_; }\n\n  // Get data area for archiving a thread.\n  char* data() { return data_; }\n\n private:\n  explicit ThreadState(ThreadManager* thread_manager);\n  ~ThreadState();\n\n  void AllocateSpace();\n\n  ThreadId id_;\n  char* data_;\n  ThreadState* next_;\n  ThreadState* previous_;\n\n  ThreadManager* thread_manager_;\n\n  friend class ThreadManager;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ThreadVisitor\",\n            \"about\": \"Abstract class for visiting threads.\",\n            \"methods\": [\n                {\n                    \"name\": \"VisitThread\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"isolate\",\n                            \"type\": \"Isolate*\"\n                        },\n                        {\n                            \"name\": \"top\",\n                            \"type\": \"ThreadLocalTop*\"\n                        }\n                    ],\n                    \"return\": \"void\",\n                    \"purpose\": \"Visits a thread, providing access to the Isolate and ThreadLocalTop.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Isolate\",\n                \"ThreadLocalTop\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ThreadVisitor {\n public:\n  // ThreadLocalTop may be only available during this call.\n  virtual void VisitThread(Isolate* isolate, ThreadLocalTop* top) = 0;\n\n protected:\n  virtual ~ThreadVisitor() = default;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ThreadManager\",\n            \"about\": \"Manages threads within the V8 engine, including locking, archiving, and iterating.\",\n            \"attributes\": [\n                {\n                    \"name\": \"mutex_\",\n                    \"type\": \"base::Mutex\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Mutex for protecting thread management operations.\"\n                },\n                {\n                    \"name\": \"mutex_owner_\",\n                    \"type\": \"std::atomic<ThreadId>\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Atomic variable storing the ID of the thread that owns the mutex.\"\n                },\n                {\n                    \"name\": \"lazily_archived_thread_\",\n                    \"type\": \"ThreadId\",\n                    \"access\": \"private\",\n                    \"purpose\": \"ThreadId of the lazily archived thread.\"\n                },\n                {\n                    \"name\": \"lazily_archived_thread_state_\",\n                    \"type\": \"ThreadState*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"ThreadState of the lazily archived thread.\"\n                },\n                {\n                    \"name\": \"free_anchor_\",\n                    \"type\": \"ThreadState*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Anchor for the linked list of free ThreadStates.\"\n                },\n                {\n                    \"name\": \"in_use_anchor_\",\n                    \"type\": \"ThreadState*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Anchor for the linked list of in-use ThreadStates.\"\n                },\n                {\n                    \"name\": \"isolate_\",\n                    \"type\": \"Isolate*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the Isolate this ThreadManager belongs to.\"\n                }\n            ],\n            \"dependencies\": [\n                \"RootVisitor\",\n                \"ThreadVisitor\",\n                \"Isolate\",\n                \"ThreadState\",\n                \"ThreadId\",\n                \"ExecutionAccess\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ThreadManager {\n public:\n  void Lock();\n  V8_EXPORT_PRIVATE void Unlock();\n\n  void InitThread(const ExecutionAccess&);\n  void ArchiveThread();\n  bool RestoreThread();\n  void FreeThreadResources();\n  bool IsArchived();\n\n  void Iterate(RootVisitor* v);\n  void IterateArchivedThreads(ThreadVisitor* v);\n  bool IsLockedByCurrentThread() const {\n    return mutex_owner_.load(std::memory_order_relaxed) == ThreadId::Current();\n  }\n  bool IsLockedByThread(ThreadId id) const {\n    return mutex_owner_.load(std::memory_order_relaxed) == id;\n  }\n\n  ThreadId CurrentId();\n\n  // Iterate over in-use states.\n  ThreadState* FirstThreadStateInUse();\n  ThreadState* GetFreeThreadState();\n\n private:\n  explicit ThreadManager(Isolate* isolate);\n  ~ThreadManager();\n\n  void DeleteThreadStateList(ThreadState* anchor);\n\n  void EagerlyArchiveThread();\n\n  base::Mutex mutex_;\n  // {ThreadId} must be trivially copyable to be stored in {std::atomic}.\n  ASSERT_TRIVIALLY_COPYABLE(i::ThreadId);\n  std::atomic<ThreadId> mutex_owner_;\n  ThreadId lazily_archived_thread_;\n  ThreadState* lazily_archived_thread_state_;\n\n  // In the following two lists there is always at least one object on the list.\n  // The first object is a flying anchor that is only there to simplify linking\n  // and unlinking.\n  // Head of linked list of free states.\n  ThreadState* free_anchor_;\n  // Head of linked list of states in use.\n  ThreadState* in_use_anchor_;\n\n  Isolate* isolate_;\n\n  friend class Isolate;\n  friend class ThreadState;\n};\n        ]]></code>\n    </class>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Isolate\",\n                \"about\": \"Represents an isolated instance of the V8 JavaScript engine.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class Isolate {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ThreadLocalTop\",\n                \"about\": \"Represents the top of the thread-local stack.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ThreadLocalTop {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"RootVisitor\",\n                \"about\": \"Abstract class for visiting roots in the V8 heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class RootVisitor {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ExecutionAccess\",\n                \"about\": \"Manages access to executable memory.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ExecutionAccess {};\n            ]]></code>\n        </class>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"ThreadId\",\n                \"about\": \"Represents the ID of a thread.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class ThreadId {\n                    public:\n                        static ThreadId Current();\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n</file>\n```"
}