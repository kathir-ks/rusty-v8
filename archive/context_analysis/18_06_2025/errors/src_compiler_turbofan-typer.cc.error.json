{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turbofan-typer.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n        {\n            \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/turbofan-typer.cc\",\n            \"file_name\": \"turbofan-typer.cc\",\n            \"language\": \"cpp\",\n            \"purpose\": \"Implements the Typer class for Turbofan, which infers types for nodes in the graph.\"\n        }\n    </metadata>\n    <imports>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"purpose\": \"Includes necessary header files for compiler, codegen, and base functionalities.\"\n            }\n        </metadata>\n        <code><![CDATA[\n            #include \"src/compiler/turbofan-typer.h\"\n\n            #include <iomanip>\n\n            #include \"src/base/flags.h\"\n            #include \"src/codegen/tick-counter.h\"\n            #include \"src/compiler/common-operator.h\"\n            #include \"src/compiler/graph-reducer.h\"\n            #include \"src/compiler/js-heap-broker.h\"\n            #include \"src/compiler/js-operator.h\"\n            #include \"src/compiler/linkage.h\"\n            #include \"src/compiler/loop-variable-optimizer.h\"\n            #include \"src/compiler/node-properties.h\"\n            #include \"src/compiler/node.h\"\n            #include \"src/compiler/opcodes.h\"\n            #include \"src/compiler/operation-typer.h\"\n            #include \"src/compiler/simplified-operator.h\"\n            #include \"src/compiler/type-cache.h\"\n            #include \"src/objects/objects-inl.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Typer::Decorator\",\n                \"extends\": \"GraphDecorator\",\n                \"about\": \"A decorator class that decorates the graph with types.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"typer_\",\n                        \"type\": \"Typer*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the parent Typer object.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Typer\",\n                    \"GraphDecorator\",\n                    \"Node\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class Typer::Decorator final : public GraphDecorator {\n            public:\n                explicit Decorator(Typer* typer) : typer_(typer) {}\n                void Decorate(Node* node) final;\n\n            private:\n                Typer* const typer_;\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Decorate\",\n                \"parent\": \"Typer::Decorator\",\n                \"about\": \"Decorates a node with its type, inferring if necessary.\",\n                \"logic\": \"If all value inputs of the node are typed (or the node is already typed), infers the node's type using TypeNode and sets it.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"node\",\n                        \"type\": \"Node*\",\n                        \"purpose\": \"The node to decorate.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"Node\",\n                    \"NodeProperties\",\n                    \"Typer::Visitor\",\n                    \"Type\",\n                    \"TypeNode\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void Typer::Decorator::Decorate(Node* node) {\n            if (node->op()->ValueOutputCount() > 0) {\n                // Only eagerly type-decorate nodes with known input types.\n                // Other cases will generally require a proper fixpoint iteration with Run.\n                bool is_typed = NodeProperties::IsTyped(node);\n                if (is_typed || NodeProperties::AllValueInputsAreTyped(node)) {\n                    Visitor typing(typer_, nullptr);\n                    Type type = typing.TypeNode(node);\n                    if (is_typed) {\n                        type = Type::Intersect(type, NodeProperties::GetType(node),\n                                               typer_->zone());\n                    }\n                    NodeProperties::SetType(node, type);\n                }\n            }\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"constructor\",\n                \"name\": \"Typer\",\n                \"about\": \"Constructs a Typer object.\",\n                \"logic\": \"Initializes the Typer with dependencies like JSHeapBroker, flags, the graph, and the tick counter. Also initializes singleton types and adds the decorator to the graph.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"broker\",\n                        \"type\": \"JSHeapBroker*\",\n                        \"purpose\": \"Provides access to the JavaScript heap.\"\n                    },\n                    {\n                        \"name\": \"flags\",\n                        \"type\": \"Flags\",\n                        \"purpose\": \"Configuration flags for the typer.\"\n                    },\n                    {\n                        \"name\": \"graph\",\n                        \"type\": \"TFGraph*\",\n                        \"purpose\": \"The Turbofan graph being typed.\"\n                    },\n                    {\n                        \"name\": \"tick_counter\",\n                        \"type\": \"TickCounter*\",\n                        \"purpose\": \"Used for tracking execution time.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"JSHeapBroker\",\n                    \"TFGraph\",\n                    \"TickCounter\",\n                    \"TypeCache\",\n                    \"OperationTyper\",\n                    \"Decorator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Typer::Typer(JSHeapBroker* broker, Flags flags, TFGraph* graph,\n                         TickCounter* tick_counter)\n                : flags_(flags),\n                  graph_(graph),\n                  decorator_(nullptr),\n                  cache_(TypeCache::Get()),\n                  broker_(broker),\n                  operation_typer_(broker, zone()),\n                  tick_counter_(tick_counter) {\n              singleton_false_ = operation_typer_.singleton_false();\n              singleton_true_ = operation_typer_.singleton_true();\n\n              decorator_ = zone()->New<Decorator>(this);\n              graph_->AddDecorator(decorator_);\n            }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"destructor\",\n                \"name\": \"~Typer\",\n                \"about\": \"Destroys a Typer object.\",\n                \"logic\": \"Removes the decorator from the graph.\",\n                \"parameters\": [],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"TFGraph\",\n                    \"Decorator\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            Typer::~Typer() { graph_->RemoveDecorator(decorator_); }\n        ]]></code>\n    </func>\n\n    <class>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"Typer::Visitor\",\n                \"extends\": \"Reducer\",\n                \"about\": \"A visitor class for traversing the graph and updating node types.\",\n                \"attributes\": [\n                    {\n                        \"name\": \"typer_\",\n                        \"type\": \"Typer*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the parent Typer object.\"\n                    },\n                    {\n                        \"name\": \"induction_vars_\",\n                        \"type\": \"LoopVariableOptimizer*\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Pointer to the LoopVariableOptimizer.\"\n                    },\n                    {\n                        \"name\": \"weakened_nodes_\",\n                        \"type\": \"ZoneSet<NodeId>\",\n                        \"access\": \"private\",\n                        \"purpose\": \"Set of node IDs that have been weakened.\"\n                    }\n                ],\n                \"dependencies\": [\n                    \"Typer\",\n                    \"Reducer\",\n                    \"Node\",\n                    \"Type\",\n                    \"LoopVariableOptimizer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            class Typer::Visitor : public Reducer {\n            public:\n                explicit Visitor(Typer* typer, LoopVariableOptimizer* induction_vars)\n                    : typer_(typer),\n                      induction_vars_(induction_vars),\n                      weakened_nodes_(typer->zone()) {}\n\n                const char* reducer_name() const override { return \"Typer\"; }\n\n                Reduction Reduce(Node* node) override {\n                    if (node->op()->ValueOutputCount() == 0) return NoChange();\n                    return UpdateType(node, TypeNode(node));\n                }\n\n                Type TypeNode(Node* node) {\n                    switch (node->opcode()) {\n        #define DECLARE_UNARY_CASE(x, ...) \\\n          case IrOpcode::k##x:             \\\n            return Type##x(Operand(node, 0));\n                      JS_SIMPLE_UNOP_LIST(DECLARE_UNARY_CASE)\n                      SIMPLIFIED_NUMBER_UNOP_LIST(DECLARE_UNARY_CASE)\n                      SIMPLIFIED_BIGINT_UNOP_LIST(DECLARE_UNARY_CASE)\n                      SIMPLIFIED_SPECULATIVE_NUMBER_UNOP_LIST(DECLARE_UNARY_CASE)\n                      SIMPLIFIED_SPECULATIVE_BIGINT_UNOP_LIST(DECLARE_UNARY_CASE)\n                      DECLARE_UNARY_CASE(ChangeUint32ToUint64)\n        #undef DECLARE_UNARY_CASE\n        #define DECLARE_BINARY_CASE(x, ...) \\\n          case IrOpcode::k##x:              \\\n            return Type##x(Operand(node, 0), Operand(node, 1));\n                      JS_SIMPLE_BINOP_LIST(DECLARE_BINARY_CASE)\n                      SIMPLIFIED_NUMBER_BINOP_LIST(DECLARE_BINARY_CASE)\n                      SIMPLIFIED_BIGINT_BINOP_LIST(DECLARE_BINARY_CASE)\n                      SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(DECLARE_BINARY_CASE)\n                      SIMPLIFIED_SPECULATIVE_BIGINT_BINOP_LIST(DECLARE_BINARY_CASE)\n                      TYPER_SUPPORTED_MACHINE_BINOP_LIST(DECLARE_BINARY_CASE)\n        #undef DECLARE_BINARY_CASE\n        #define DECLARE_OTHER_CASE(x, ...) \\\n          case IrOpcode::k##x:             \\\n            return Type##x(node);\n                      DECLARE_OTHER_CASE(Start)\n                      DECLARE_OTHER_CASE(IfException)\n                      COMMON_OP_LIST(DECLARE_OTHER_CASE)\n                      SIMPLIFIED_COMPARE_BINOP_LIST(DECLARE_OTHER_CASE)\n                      SIMPLIFIED_OTHER_OP_LIST(DECLARE_OTHER_CASE)\n                      JS_OBJECT_OP_LIST(DECLARE_OTHER_CASE)\n                      JS_CONTEXT_OP_LIST(DECLARE_OTHER_CASE)\n                      JS_OTHER_OP_LIST(DECLARE_OTHER_CASE)\n        #undef DECLARE_OTHER_CASE\n        #define DECLARE_IMPOSSIBLE_CASE(x, ...) case IrOpcode::k##x:\n                      DECLARE_IMPOSSIBLE_CASE(Loop)\n                      DECLARE_IMPOSSIBLE_CASE(Branch)\n                      DECLARE_IMPOSSIBLE_CASE(IfTrue)\n                      DECLARE_IMPOSSIBLE_CASE(IfFalse)\n                      DECLARE_IMPOSSIBLE_CASE(IfSuccess)\n                      DECLARE_IMPOSSIBLE_CASE(Switch)\n                      DECLARE_IMPOSSIBLE_CASE(IfValue)\n                      DECLARE_IMPOSSIBLE_CASE(IfDefault)\n                      DECLARE_IMPOSSIBLE_CASE(Merge)\n                      DECLARE_IMPOSSIBLE_CASE(Deoptimize)\n                      DECLARE_IMPOSSIBLE_CASE(DeoptimizeIf)\n                      DECLARE_IMPOSSIBLE_CASE(DeoptimizeUnless)\n                      DECLARE_IMPOSSIBLE_CASE(TrapIf)\n                      DECLARE_IMPOSSIBLE_CASE(TrapUnless)\n                      DECLARE_IMPOSSIBLE_CASE(Assert)\n                      DECLARE_IMPOSSIBLE_CASE(Return)\n                      DECLARE_IMPOSSIBLE_CASE(TailCall)\n                      DECLARE_IMPOSSIBLE_CASE(Terminate)\n                      DECLARE_IMPOSSIBLE_CASE(Throw)\n                      DECLARE_IMPOSSIBLE_CASE(End)\n                      SIMPLIFIED_CHANGE_OP_LIST(DECLARE_IMPOSSIBLE_CASE)\n                      SIMPLIFIED_CHECKED_OP_LIST(DECLARE_IMPOSSIBLE_CASE)\n                      IF_WASM(SIMPLIFIED_WASM_OP_LIST, DECLARE_IMPOSSIBLE_CASE)\n                      MACHINE_SIMD128_OP_LIST(DECLARE_IMPOSSIBLE_CASE)\n                      IF_WASM(MACHINE_SIMD256_OP_LIST, DECLARE_IMPOSSIBLE_CASE)\n                      MACHINE_UNOP_32_LIST(DECLARE_IMPOSSIBLE_CASE)\n                      DECLARE_IMPOSSIBLE_CASE(Word32Xor)\n                      DECLARE_IMPOSSIBLE_CASE(Word32Sar)\n                      DECLARE_IMPOSSIBLE_CASE(Word32Rol)\n                      DECLARE_IMPOSSIBLE_CASE(Word32Ror)\n                      DECLARE_IMPOSSIBLE_CASE(Int32AddWithOverflow)\n                      DECLARE_IMPOSSIBLE_CASE(Int32SubWithOverflow)\n                      DECLARE_IMPOSSIBLE_CASE(Int32Mul)\n                      DECLARE_IMPOSSIBLE_CASE(Int32MulWithOverflow)\n                      DECLARE_IMPOSSIBLE_CASE(Int32MulHigh)\n                      DECLARE_IMPOSSIBLE_CASE(Int32Div)\n                      DECLARE_IMPOSSIBLE_CASE(Int32Mod)\n                      DECLARE_IMPOSSIBLE_CASE(Uint32Mod)\n                      DECLARE_IMPOSSIBLE_CASE(Uint32MulHigh)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Or)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Xor)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Sar)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Rol)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Ror)\n                      DECLARE_IMPOSSIBLE_CASE(Word64RolLowerable)\n                      DECLARE_IMPOSSIBLE_CASE(Word64RorLowerable)\n                      DECLARE_IMPOSSIBLE_CASE(Int64AddWithOverflow)\n                      DECLARE_IMPOSSIBLE_CASE(Int64SubWithOverflow)\n                      DECLARE_IMPOSSIBLE_CASE(Int64Mul)\n                      DECLARE_IMPOSSIBLE_CASE(Int64MulHigh)\n                      DECLARE_IMPOSSIBLE_CASE(Int64MulWithOverflow)\n                      DECLARE_IMPOSSIBLE_CASE(Int64Div)\n                      DECLARE_IMPOSSIBLE_CASE(Int64Mod)\n                      DECLARE_IMPOSSIBLE_CASE(Uint64Mod)\n                      DECLARE_IMPOSSIBLE_CASE(Uint64MulHigh)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Equal)\n                      DECLARE_IMPOSSIBLE_CASE(Int32LessThan)\n                      DECLARE_IMPOSSIBLE_CASE(Int64LessThan)\n                      DECLARE_IMPOSSIBLE_CASE(Int64LessThanOrEqual)\n                      DECLARE_IMPOSSIBLE_CASE(Float32Equal)\n                      DECLARE_IMPOSSIBLE_CASE(Float32LessThan)\n                      DECLARE_IMPOSSIBLE_CASE(Float32LessThanOrEqual)\n                      DECLARE_IMPOSSIBLE_CASE(Float64Equal)\n                      DECLARE_IMPOSSIBLE_CASE(Float64LessThan)\n                      DECLARE_IMPOSSIBLE_CASE(Float64LessThanOrEqual)\n                      MACHINE_FLOAT32_BINOP_LIST(DECLARE_IMPOSSIBLE_CASE)\n                      MACHINE_FLOAT32_UNOP_LIST(DECLARE_IMPOSSIBLE_CASE)\n                      MACHINE_FLOAT64_BINOP_LIST(DECLARE_IMPOSSIBLE_CASE)\n                      MACHINE_FLOAT64_UNOP_LIST(DECLARE_IMPOSSIBLE_CASE)\n                      MACHINE_ATOMIC_OP_LIST(DECLARE_IMPOSSIBLE_CASE)\n                      DECLARE_IMPOSSIBLE_CASE(AbortCSADcheck)\n                      DECLARE_IMPOSSIBLE_CASE(DebugBreak)\n                      DECLARE_IMPOSSIBLE_CASE(Comment)\n                      DECLARE_IMPOSSIBLE_CASE(LoadImmutable)\n                      DECLARE_IMPOSSIBLE_CASE(StorePair)\n                      DECLARE_IMPOSSIBLE_CASE(Store)\n                      DECLARE_IMPOSSIBLE_CASE(StoreIndirectPointer)\n                      DECLARE_IMPOSSIBLE_CASE(StackSlot)\n                      DECLARE_IMPOSSIBLE_CASE(Word32Popcnt)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Popcnt)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Clz)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Ctz)\n                      DECLARE_IMPOSSIBLE_CASE(Word64ClzLowerable)\n                      DECLARE_IMPOSSIBLE_CASE(Word64CtzLowerable)\n                      DECLARE_IMPOSSIBLE_CASE(Word64ReverseBits)\n                      DECLARE_IMPOSSIBLE_CASE(Word64ReverseBytes)\n                      DECLARE_IMPOSSIBLE_CASE(Simd128ReverseBytes)\n                      DECLARE_IMPOSSIBLE_CASE(Int64AbsWithOverflow)\n                      DECLARE_IMPOSSIBLE_CASE(BitcastTaggedToWord)\n                      DECLARE_IMPOSSIBLE_CASE(BitcastTaggedToWordForTagAndSmiBits)\n                      DECLARE_IMPOSSIBLE_CASE(BitcastWordToTagged)\n                      DECLARE_IMPOSSIBLE_CASE(BitcastWordToTaggedSigned)\n                      DECLARE_IMPOSSIBLE_CASE(TruncateFloat64ToWord32)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeFloat32ToFloat64)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeFloat64ToInt32)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeFloat64ToInt64)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeFloat64ToUint32)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeFloat64ToUint64)\n                      DECLARE_IMPOSSIBLE_CASE(Float64SilenceNaN)\n                      DECLARE_IMPOSSIBLE_CASE(TruncateFloat64ToInt64)\n                      DECLARE_IMPOSSIBLE_CASE(TruncateFloat64ToUint32)\n                      DECLARE_IMPOSSIBLE_CASE(TruncateFloat32ToInt32)\n                      DECLARE_IMPOSSIBLE_CASE(TruncateFloat32ToUint32)\n                      DECLARE_IMPOSSIBLE_CASE(TryTruncateFloat32ToInt64)\n                      DECLARE_IMPOSSIBLE_CASE(TryTruncateFloat64ToInt64)\n                      DECLARE_IMPOSSIBLE_CASE(TryTruncateFloat32ToUint64)\n                      DECLARE_IMPOSSIBLE_CASE(TryTruncateFloat64ToUint64)\n                      DECLARE_IMPOSSIBLE_CASE(TryTruncateFloat64ToInt32)\n                      DECLARE_IMPOSSIBLE_CASE(TryTruncateFloat64ToUint32)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeInt32ToFloat64)\n                      DECLARE_IMPOSSIBLE_CASE(BitcastWord32ToWord64)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeInt32ToInt64)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeInt64ToFloat64)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeUint32ToFloat64)\n                      DECLARE_IMPOSSIBLE_CASE(ChangeFloat16RawBitsToFloat64)\n                      DECLARE_IMPOSSIBLE_CASE(TruncateFloat64ToFloat32)\n                      DECLARE_IMPOSSIBLE_CASE(TruncateFloat64ToFloat16RawBits)\n                      DECLARE_IMPOSSIBLE_CASE(TruncateInt64ToInt32)\n                      DECLARE_IMPOSSIBLE_CASE(RoundFloat64ToInt32)\n                      DECLARE_IMPOSSIBLE_CASE(RoundInt32ToFloat32)\n                      DECLARE_IMPOSSIBLE_CASE(RoundInt64ToFloat32)\n                      DECLARE_IMPOSSIBLE_CASE(RoundInt64ToFloat64)\n                      DECLARE_IMPOSSIBLE_CASE(RoundUint32ToFloat32)\n                      DECLARE_IMPOSSIBLE_CASE(RoundUint64ToFloat32)\n                      DECLARE_IMPOSSIBLE_CASE(RoundUint64ToFloat64)\n                      DECLARE_IMPOSSIBLE_CASE(BitcastFloat32ToInt32)\n                      DECLARE_IMPOSSIBLE_CASE(BitcastFloat64ToInt64)\n                      DECLARE_IMPOSSIBLE_CASE(BitcastInt32ToFloat32)\n                      DECLARE_IMPOSSIBLE_CASE(BitcastInt64ToFloat64)\n                      DECLARE_IMPOSSIBLE_CASE(Float64ExtractLowWord32)\n                      DECLARE_IMPOSSIBLE_CASE(Float64ExtractHighWord32)\n                      DECLARE_IMPOSSIBLE_CASE(Float64InsertLowWord32)\n                      DECLARE_IMPOSSIBLE_CASE(Float64InsertHighWord32)\n                      DECLARE_IMPOSSIBLE_CASE(Word32Select)\n                      DECLARE_IMPOSSIBLE_CASE(Word64Select)\n                      DECLARE_IMPOSSIBLE_CASE(Float32Select)\n                      DECLARE_IMPOSSIBLE_CASE(Float64Select)\n                      DECLARE_IMPOSSIBLE_CASE(LoadStackCheckOffset)\n                      DECLARE_IMPOSSIBLE_CASE(LoadFramePointer)\n                      IF_WASM(DECLARE_IMPOSSIBLE_CASE, LoadStackPointer)\n                      IF_WASM(DECLARE_IMPOSSIBLE_CASE, SetStackPointer)\n                      DECLARE_IMPOSSIBLE_CASE(LoadParentFramePointer)\n                      DECLARE_IMPOSSIBLE_CASE(LoadRootRegister)\n                      DECLARE_IMPOSSIBLE_CASE(UnalignedLoad)\n                      DECLARE_IMPOSSIBLE_CASE(UnalignedStore)\n                      DECLARE_IMPOSSIBLE_CASE(Int32PairAdd)\n                      DECLARE_IMPOSSIBLE_CASE(Int32PairSub)\n                      DECLARE_IMPOSSIBLE_CASE(Int32PairMul)\n                      DECLARE_IMPOSSIBLE_CASE(Word32PairShl)\n                      DECLARE_IMPOSSIBLE_CASE(Word32PairShr)\n                      DECLARE_IMPOSSIBLE_CASE(Word32PairSar)\n                      DECLARE_IMPOSSIBLE_CASE(ProtectedLoad)\n                      DECLARE_IMPOSSIBLE_CASE(ProtectedStore)\n                      DECLARE_IMPOSSIBLE_CASE(LoadTrapOnNull)\n                      DECLARE_IMPOSSIBLE_CASE(StoreTrapOnNull)\n                      DECLARE_IMPOSSIBLE_CASE(MemoryBarrier)\n                      DECLARE_IMPOSSIBLE_CASE(SignExtendWord8ToInt32)\n                      DECLARE_IMPOSSIBLE_CASE(SignExtendWord16ToInt32)\n                      DECLARE_IMPOSSIBLE_CASE(SignExtendWord8ToInt64)\n                      DECLARE_IMPOSSIBLE_CASE(SignExtendWord16ToInt64)\n                      DECLARE_IMPOSSIBLE_CASE(SignExtendWord32ToInt64)\n                      DECLARE_IMPOSSIBLE_CASE(StackPointerGreaterThan)\n                      DECLARE_IMPOSSIBLE_CASE(TraceInstruction)\n\n        #undef DECLARE_IMPOSSIBLE_CASE\n                      UNREACHABLE();\n                    }\n                }\n\n                Type TypeConstant(Handle<Object> value);\n\n                bool InductionVariablePhiTypeIsPrefixedPoint(\n                    InductionVariable* induction_var);\n\n             private:\n                Typer* typer_;\n                LoopVariableOptimizer* induction_vars_;\n                ZoneSet<NodeId> weakened_nodes_;\n\n        #define DECLARE_METHOD(x, ...) inline Type Type##x(Node* node);\n                DECLARE_METHOD(Start)\n                DECLARE_METHOD(IfException)\n                COMMON_OP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_COMPARE_BINOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_OTHER_OP_LIST(DECLARE_METHOD)\n                JS_OBJECT_OP_LIST(DECLARE_METHOD)\n                JS_CONTEXT_OP_LIST(DECLARE_METHOD)\n                JS_OTHER_OP_LIST(DECLARE_METHOD)\n        #undef DECLARE_METHOD\n        #define DECLARE_METHOD(x, ...) inline Type Type##x(Type input);\n                JS_SIMPLE_UNOP_LIST(DECLARE_METHOD)\n        #undef DECLARE_METHOD\n\n                Type TypeOrNone(Node* node) {\n                    return NodeProperties::IsTyped(node) ? NodeProperties::GetType(node)\n                                                         : Type::None();\n                }\n\n                Type Operand(Node* node, int i) {\n                    Node* operand_node = NodeProperties::GetValueInput(node, i);\n                    return TypeOrNone(operand_node);\n                }\n\n                Type Weaken(Node* node, Type current_type, Type previous_type);\n\n                Zone* zone() { return typer_->zone(); }\n                TFGraph* graph() { return typer_->graph(); }\n                JSHeapBroker* broker() { return typer_->broker(); }\n\n                void SetWeakened(NodeId node_id) { weakened_nodes_.insert(node_id); }\n                bool IsWeakened(NodeId node_id) {\n                    return weakened_nodes_.find(node_id) != weakened_nodes_.end();\n                }\n\n                using UnaryTyperFun = Type (*)(Type, Typer* t);\n                using BinaryTyperFun = Type (*)(Type, Type, Typer* t);\n\n                inline Type TypeUnaryOp(Node* node, UnaryTyperFun);\n                inline Type TypeBinaryOp(Node* node, BinaryTyperFun);\n                inline Type TypeUnaryOp(Type input, UnaryTyperFun);\n                inline Type TypeBinaryOp(Type left, Type right, BinaryTyperFun);\n\n                static Type BinaryNumberOpTyper(Type lhs, Type rhs, Typer* t,\n                                                      BinaryTyperFun f);\n\n                enum ComparisonOutcomeFlags {\n                    kComparisonTrue = 1,\n                    kComparisonFalse = 2,\n                    kComparisonUndefined = 4\n                };\n                using ComparisonOutcome = base::Flags<ComparisonOutcomeFlags>;\n\n                static ComparisonOutcome Invert(ComparisonOutcome, Typer*);\n                static Type FalsifyUndefined(ComparisonOutcome, Typer*);\n\n                static Type BitwiseNot(Type, Typer*);\n                static Type Decrement(Type, Typer*);\n                static Type Increment(Type, Typer*);\n                static Type Negate(Type, Typer*);\n\n                static Type ToPrimitive(Type, Typer*);\n                static Type ToBoolean(Type, Typer*);\n                static Type ToInteger(Type, Typer*);\n                static Type ToLength(Type, Typer*);\n                static Type ToName(Type, Typer*);\n                static Type ToNumber(Type, Typer*);\n                static Type ToNumberConvertBigInt(Type, Typer*);\n                static Type ToBigInt(Type, Typer*);\n                static Type ToBigIntConvertNumber(Type, Typer*);\n                static Type ToNumeric(Type, Typer*);\n                static Type ToObject(Type, Typer*);\n                static Type ToString(Type, Typer*);\n        #define DECLARE_METHOD(Name)               \\\n          static Type Name(Type type, Typer* t) {  \\\n            return t->operation_typer_.Name(type); \\\n          }\n                SIMPLIFIED_NUMBER_UNOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_BIGINT_UNOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_SPECULATIVE_NUMBER_UNOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_SPECULATIVE_BIGINT_UNOP_LIST(DECLARE_METHOD)\n                DECLARE_METHOD(ChangeUint32ToUint64)\n        #undef DECLARE_METHOD\n        #define DECLARE_METHOD(Name)                       \\\n          static Type Name(Type lhs, Type rhs, Typer* t) { \\\n            return t->operation_typer_.Name(lhs, rhs);     \\\n          }\n                SIMPLIFIED_NUMBER_BINOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_BIGINT_BINOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_SPECULATIVE_BIGINT_BINOP_LIST(DECLARE_METHOD)\n                TYPER_SUPPORTED_MACHINE_BINOP_LIST(DECLARE_METHOD)\n        #undef DECLARE_METHOD\n        #define DECLARE_METHOD(Name, ...)                  \\\n          inline Type Type##Name(Type left, Type right) {  \\\n            return TypeBinaryOp(left, right, Name##Typer); \\\n          }\n                JS_SIMPLE_BINOP_LIST(DECLARE_METHOD)\n        #undef DECLARE_METHOD\n        #define DECLARE_METHOD(Name, ...)                 \\\n          inline Type Type##Name(Type left, Type right) { \\\n            return TypeBinaryOp(left, right, Name);       \\\n          }\n                SIMPLIFIED_NUMBER_BINOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_BIGINT_BINOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_SPECULATIVE_NUMBER_BINOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_SPECULATIVE_BIGINT_BINOP_LIST(DECLARE_METHOD)\n                TYPER_SUPPORTED_MACHINE_BINOP_LIST(DECLARE_METHOD)\n        #undef DECLARE_METHOD\n        #define DECLARE_METHOD(Name, ...) \\\n          inline Type Type##Name(Type input) { return TypeUnaryOp(input, Name); }\n                SIMPLIFIED_NUMBER_UNOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_BIGINT_UNOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_SPECULATIVE_NUMBER_UNOP_LIST(DECLARE_METHOD)\n                SIMPLIFIED_SPECULATIVE_BIGINT_UNOP_LIST(DECLARE_METHOD)\n                DECLARE_METHOD(ChangeUint32ToUint64)\n        #undef DECLARE_METHOD\n                static Type ObjectIsArrayBufferView(Type, Typer*);\n                static Type ObjectIsBigInt(Type, Typer*);\n                static Type ObjectIsCallable(Type, Typer*);\n                static Type ObjectIsConstructor(Type, Typer*);\n                static Type ObjectIsDetectableCallable(Type, Typer*);\n                static Type ObjectIsMinusZero(Type, Typer*);\n                static Type NumberIsMinusZero(Type, Typer*);\n                static Type ObjectIsNaN(Type, Typer*);\n                static Type NumberIsNaN(Type, Typer*);\n                static Type ObjectIsNonCallable(Type, Typer*);\n                static Type ObjectIsNumber(Type, Typer*);\n                static Type ObjectIsReceiver(Type, Typer*);\n                static Type ObjectIsSmi(Type, Typer*);\n                static Type ObjectIsString(Type, Typer*);\n                static Type ObjectIsSymbol(Type, Typer*);\n                static Type ObjectIsUndetectable(Type, Typer*);\n\n                static ComparisonOutcome JSCompareTyper(Type, Type, Typer*);\n                static ComparisonOutcome NumberCompareTyper(Type, Type, Typer*);\n\n        #define DECLARE_METHOD(x, ...) static Type x##Typer(Type, Type, Typer*);\n                JS_SIMPLE_BINOP_LIST(DECLARE_METHOD)\n        #undef DECLARE_METHOD\n\n                static Type JSCallTyper(Type, Typer*);\n\n                static Type NumberEqualTyper(Type, Type, Typer*);\n                static Type NumberLessThanTyper(Type, Type, Typer*);\n                static Type NumberLessThanOrEqualTyper(Type, Type, Typer*);\n                static Type BigIntCompareTyper(Type, Type, Typer*);\n                static Type ReferenceEqualTyper(Type, Type, Typer*);\n                static Type SameValueTyper(Type, Type, Typer*);\n                static Type SameValueNumbersOnlyTyper(Type, Type, Typer*);\n                static Type StringFromSingleCharCodeTyper(Type, Typer*);\n                static Type StringFromSingleCodePointTyper(Type, Typer*);\n\n                Reduction UpdateType(Node* node, Type current) {\n                    if (NodeProperties::IsTyped(node)) {\n                      // Widen the type of a previously typed node.\n                      Type previous = NodeProperties::GetType(node);\n                      if (node->opcode() == IrOpcode::kPhi ||\n                          node->opcode() == IrOpcode::kInductionVariablePhi) {\n                        // Speed up termination in the presence of range types:\n                        current = Weaken(node, current, previous);\n                      }\n\n                      if (V8_UNLIKELY(!previous.Is(current))) {\n                        AllowHandleDereference allow;\n                        std::ostringstream ostream;\n                        node->Print(ostream);\n                        FATAL(\"UpdateType error for node %s\", ostream.str().c_str());\n                      }\n\n                      NodeProperties::SetType(node, current);\n                      if (!current.Is(previous)) {\n                        // If something changed, revisit all uses.\n                        return Changed(node);\n                      }\n                      return NoChange();\n                    } else {\n                      // No previous type, simply update the type.\n                      NodeProperties::SetType(node, current);\n                      return Changed(node);\n                    }\n                }\n            };\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"method\",\n                \"name\": \"Run\",\n                \"parent\": \"Typer\",\n                \"about\": \"Runs the typer on the graph, inferring types for all nodes.\",\n                \"logic\": \"Creates a Visitor and GraphReducer to traverse the graph and update node types. Optionally runs the LoopVariableOptimizer.\",\n                \"parameters\": [\n                    {\n                        \"name\": \"roots\",\n                        \"type\": \"const NodeVector&\",\n                        \"purpose\": \"Vector of root nodes to start the typing from.\"\n                    },\n                    {\n                        \"name\": \"induction_vars\",\n                        \"type\": \"LoopVariableOptimizer*\",\n                        \"purpose\": \"Optional LoopVariableOptimizer.\"\n                    }\n                ],\n                \"return\": {\n                    \"type\": \"void\",\n                    \"description\": \"No return value.\"\n                },\n                \"dependencies\": [\n                    \"NodeVector\",\n                    \"LoopVariableOptimizer\",\n                    \"Visitor\",\n                    \"GraphReducer\"\n                ]\n            }\n        </metadata>\n        <code><![CDATA[\n            void Typer::Run() { Run(NodeVector(zone()), nullptr); }\n\n            void Typer::Run(const NodeVector& roots,\n                            LoopVariableOptimizer* induction_vars) {\n              if (induction_vars != nullptr) {\n                induction_vars->ChangeToInductionVariablePhis();\n              }\n              Visitor visitor(this, induction_vars);\n              GraphReducer graph_reducer(zone(), graph(), tick_counter_, broker());\n              graph_reducer.AddReducer(&visitor);\n              for (Node* const root : roots) graph_reducer.ReduceNode(root);\n              graph_reducer.ReduceGraph();\n\n              if (induction_vars != nullptr)"
}