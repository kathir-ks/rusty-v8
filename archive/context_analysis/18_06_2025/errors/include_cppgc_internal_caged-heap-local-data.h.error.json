{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/internal/caged-heap-local-data.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 365, column 44",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/internal/caged-heap-local-data.h\",\n        \"file_name\": \"caged-heap-local-data.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines structures for managing local data within the CagedHeap, specifically the AgeTable for young generation garbage collection.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard library headers and cppgc internal headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <array>\n            #include <cstddef>\n            #include <cstdint>\n\n            #include \"cppgc/internal/api-constants.h\"\n            #include \"cppgc/internal/caged-heap.h\"\n            #include \"cppgc/internal/logging.h\"\n            #include \"cppgc/platform.h\"\n            #include \"v8config.h\"  // NOLINT(build/include_directory)\n\n            #if __cpp_lib_bitopts\n            #include <bit>\n            #endif  // __cpp_lib_bitopts\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AgeTable\",\n            \"about\": \"Represents a bytemap that tracks the age (generation) of objects within the CagedHeap. Each entry corresponds to a card (4KB memory region).\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"api_constants\",\n                \"CagedHeapBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            class V8_EXPORT AgeTable final {\n            static constexpr size_t kRequiredSize = 1 * api_constants::kMB;\n            static constexpr size_t kAllocationGranularity =\n                api_constants::kAllocationGranularity;\n\n            public:\n            // Represents age of the objects living on a single card.\n            enum class Age : uint8_t { kOld, kYoung, kMixed };\n            // When setting age for a range, consider or ignore ages of the adjacent\n            // cards.\n            enum class AdjacentCardsPolicy : uint8_t { kConsider, kIgnore };\n\n            static constexpr size_t kCardSizeInBytes =\n                api_constants::kCagedHeapDefaultReservationSize / kRequiredSize;\n\n            static constexpr size_t CalculateAgeTableSizeForHeapSize(size_t heap_size) {\n                return heap_size / kCardSizeInBytes;\n            }\n\n            void SetAge(uintptr_t cage_offset, Age age) {\n                table_[card(cage_offset)] = age;\n            }\n\n            V8_INLINE Age GetAge(uintptr_t cage_offset) const {\n                return table_[card(cage_offset)];\n            }\n\n            void SetAgeForRange(uintptr_t cage_offset_begin, uintptr_t cage_offset_end,\n                                Age age, AdjacentCardsPolicy adjacent_cards_policy);\n\n            Age GetAgeForRange(uintptr_t cage_offset_begin,\n                                uintptr_t cage_offset_end) const;\n\n            void ResetForTesting();\n\n            private:\n            V8_INLINE size_t card(uintptr_t offset) const {\n                constexpr size_t kGranularityBits =\n            #if __cpp_lib_bitopts\n                std::countr_zero(static_cast<uint32_t>(kCardSizeInBytes));\n            #elif V8_HAS_BUILTIN_CTZ\n                __builtin_ctz(static_cast<uint32_t>(kCardSizeInBytes));\n            #else   //! V8_HAS_BUILTIN_CTZ\n                // Hardcode and check with assert.\n                12;\n            #endif  // !V8_HAS_BUILTIN_CTZ\n                static_assert((1 << kGranularityBits) == kCardSizeInBytes);\n                const size_t entry = offset >> kGranularityBits;\n                CPPGC_DCHECK(CagedHeapBase::GetAgeTableSize() > entry);\n                return entry;\n            }\n\n            #if defined(V8_CC_GNU)\n            // gcc disallows flexible arrays in otherwise empty classes.\n            Age table_[0];\n            #else   // !defined(V8_CC_GNU)\n            Age table_[];\n            #endif  // !defined(V8_CC_GNU)\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetAgeForRange\",\n            \"parent\": \"AgeTable\",\n            \"about\": \"Sets the age for a range of memory within the age table.\",\n            \"logic\": \"The implementation is not provided in the header file, but it likely iterates over the cards within the given range and sets their age accordingly. The adjacent_cards_policy parameter probably controls whether the age of cards adjacent to the range should be considered when setting the age for the range.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cage_offset_begin\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"Starting address of the memory range.\"\n                },\n                {\n                    \"name\": \"cage_offset_end\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"Ending address of the memory range.\"\n                },\n                {\n                    \"name\": \"age\",\n                    \"type\": \"Age\",\n                    \"purpose\": \"The age to set for the memory range.\"\n                },\n                {\n                    \"name\": \"adjacent_cards_policy\",\n                    \"type\": \"AdjacentCardsPolicy\",\n                    \"purpose\": \"Policy for handling ages of adjacent cards.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void AgeTable::SetAgeForRange(uintptr_t cage_offset_begin, uintptr_t cage_offset_end,\n                                Age age, AdjacentCardsPolicy adjacent_cards_policy);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetAgeForRange\",\n            \"parent\": \"AgeTable\",\n            \"about\": \"Gets the age for a range of memory within the age table.\",\n            \"logic\": \"The implementation is not provided in the header file, but it likely iterates over the cards within the given range and determines the combined age of the range. The logic for determining the combined age (e.g. if any card is 'young', the whole range is 'young') would be in the implementation.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cage_offset_begin\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"Starting address of the memory range.\"\n                },\n                {\n                    \"name\": \"cage_offset_end\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"Ending address of the memory range.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Age\",\n                \"description\": \"The combined age of the memory range.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            Age AgeTable::GetAgeForRange(uintptr_t cage_offset_begin,\n                                 uintptr_t cage_offset_end) const;\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ResetForTesting\",\n            \"parent\": \"AgeTable\",\n            \"about\": \"Resets the age table, likely setting all entries to a default value.\",\n            \"logic\": \"The implementation is not provided in the header file. Likely iterates through the `table_` and sets all values to a default state.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            void AgeTable::ResetForTesting();\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"SetAge\",\n            \"parent\": \"AgeTable\",\n            \"about\": \"Sets the age of a single card in the age table.\",\n            \"logic\": \"Calculates the index of the card based on the offset and then sets the corresponding entry in the `table_` array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cage_offset\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"The offset within the CagedHeap.\"\n                },\n                {\n                    \"name\": \"age\",\n                    \"type\": \"AgeTable::Age\",\n                    \"purpose\": \"The age to set for the card.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"card\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            void AgeTable::SetAge(uintptr_t cage_offset, Age age) {\n                table_[card(cage_offset)] = age;\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"GetAge\",\n            \"parent\": \"AgeTable\",\n            \"about\": \"Gets the age of a single card in the age table.\",\n            \"logic\": \"Calculates the index of the card based on the offset and then retrieves the corresponding entry from the `table_` array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"cage_offset\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"The offset within the CagedHeap.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"AgeTable::Age\",\n                \"description\": \"The age of the card.\"\n            },\n            \"dependencies\": [\n                \"card\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE Age AgeTable::GetAge(uintptr_t cage_offset) const {\n                return table_[card(cage_offset)];\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"card\",\n            \"parent\": \"AgeTable\",\n            \"about\": \"Calculates the card index for a given offset within the CagedHeap.\",\n            \"logic\": \"Calculates the card index by right-shifting the offset by the number of bits representing the card size. It also performs a DCHECK to ensure that the calculated entry is within the bounds of the AgeTable.\",\n            \"parameters\": [\n                {\n                    \"name\": \"offset\",\n                    \"type\": \"uintptr_t\",\n                    \"purpose\": \"The offset within the CagedHeap.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The card index.\"\n            },\n            \"dependencies\": [\n                \"CagedHeapBase\",\n                \"CPPGC_DCHECK\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE size_t AgeTable::card(uintptr_t offset) const {\n                constexpr size_t kGranularityBits =\n            #if __cpp_lib_bitopts\n                std::countr_zero(static_cast<uint32_t>(kCardSizeInBytes));\n            #elif V8_HAS_BUILTIN_CTZ\n                __builtin_ctz(static_cast<uint32_t>(kCardSizeInBytes));\n            #else   //! V8_HAS_BUILTIN_CTZ\n                // Hardcode and check with assert.\n                12;\n            #endif  // !V8_HAS_BUILTIN_CTZ\n                static_assert((1 << kGranularityBits) == kCardSizeInBytes);\n                const size_t entry = offset >> kGranularityBits;\n                CPPGC_DCHECK(CagedHeapBase::GetAgeTableSize() > entry);\n                return entry;\n            }\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"struct\",\n            \"name\": \"CagedHeapLocalData\",\n            \"about\": \"A structure that holds local data for the CagedHeap, including the AgeTable.\",\n            \"attributes\": [\n                {\n                    \"name\": \"age_table\",\n                    \"type\": \"AgeTable\",\n                    \"access\": \"public\",\n                    \"purpose\": \"The AgeTable instance for tracking object ages.\"\n                }\n            ],\n            \"dependencies\": [\n                \"AgeTable\",\n                \"CagedHeapBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            struct CagedHeapLocalData final {\n            V8_INLINE static CagedHeapLocalData& Get() {\n                return *reinterpret_cast<CagedHeapLocalData*>(CagedHeapBase::GetBase());\n            }\n\n            static constexpr size_t CalculateLocalDataSizeForHeapSize(size_t heap_size) {\n                return AgeTable::CalculateAgeTableSizeForHeapSize(heap_size);\n            }\n\n            #if defined(CPPGC_YOUNG_GENERATION)\n            AgeTable age_table;\n            #endif\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Get\",\n            \"parent\": \"CagedHeapLocalData\",\n            \"about\": \"Returns a reference to the CagedHeapLocalData instance. Uses a reinterpret_cast to get the data from the base of the CagedHeap.\",\n            \"logic\": \"This function assumes that the CagedHeapLocalData is located at the base address of the CagedHeap. This is achieved through memory layout within the CagedHeap implementation.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"CagedHeapLocalData&\",\n                \"description\": \"A reference to the CagedHeapLocalData instance.\"\n            },\n            \"dependencies\": [\n                \"CagedHeapBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_INLINE static CagedHeapLocalData& CagedHeapLocalData::Get() {\n                return *reinterpret_cast<CagedHeapLocalData*>(CagedHeapBase::GetBase());\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CalculateLocalDataSizeForHeapSize\",\n            \"parent\": \"CagedHeapLocalData\",\n            \"about\": \"Calculates the required size for the local data based on the heap size.\",\n            \"logic\": \"Calculates the size needed for the AgeTable based on the provided heap size.\",\n            \"parameters\": [\n                {\n                    \"name\": \"heap_size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The size of the heap.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"size_t\",\n                \"description\": \"The required size for the local data.\"\n            },\n            \"dependencies\": [\n                \"AgeTable\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            static constexpr size_t CagedHeapLocalData::CalculateLocalDataSizeForHeapSize(size_t heap_size) {\n                return AgeTable::CalculateAgeTableSizeForHeapSize(heap_size);\n            }\n        ]]></code>\n    </func>\n</file>\n```"
}