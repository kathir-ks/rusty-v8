{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/explicit-management.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 145, column 40",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/cppgc/explicit-management.h\",\n        \"file_name\": \"explicit-management.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Provides APIs for explicit management of garbage collected objects, including immediate reclamation and resizing.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ header for size_t type definition\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include <cstddef>\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes cppgc allocation functionalities\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"cppgc/allocation.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes internal logging functionalities for cppgc\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"cppgc/internal/logging.h\"\n        ]]></code>\n    </imports>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes type traits functionalities for cppgc\"\n        }\n        </metadata>\n        <code><![CDATA[\n            #include \"cppgc/type-traits.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"HeapHandle\",\n            \"about\": \"Forward declaration of the HeapHandle class.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class HeapHandle;\n        ]]></code>\n    </class>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"subtle\",\n            \"purpose\": \"Namespace containing subtle APIs for explicit memory management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace subtle {\n\n            template <typename T>\n            void FreeUnreferencedObject(HeapHandle& heap_handle, T& object);\n            template <typename T>\n            bool Resize(T& object, AdditionalBytes additional_bytes);\n\n            }  // namespace subtle\n        ]]></code>\n    </namespace>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"internal\",\n            \"purpose\": \"Namespace containing internal implementation details for explicit memory management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace internal {\n\n            class ExplicitManagementImpl final {\n            private:\n              V8_EXPORT static void FreeUnreferencedObject(HeapHandle&, void*);\n              V8_EXPORT static bool Resize(void*, size_t);\n\n              template <typename T>\n              friend void subtle::FreeUnreferencedObject(HeapHandle&, T&);\n              template <typename T>\n              friend bool subtle::Resize(T&, AdditionalBytes);\n            };\n            }  // namespace internal\n        ]]></code>\n    </namespace>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ExplicitManagementImpl\",\n            \"about\": \"Internal implementation class for explicit memory management.\",\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            class ExplicitManagementImpl final {\n            private:\n              V8_EXPORT static void FreeUnreferencedObject(HeapHandle&, void*);\n              V8_EXPORT static bool Resize(void*, size_t);\n\n              template <typename T>\n              friend void subtle::FreeUnreferencedObject(HeapHandle&, T&);\n              template <typename T>\n              friend bool subtle::Resize(T&, AdditionalBytes);\n            };\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FreeUnreferencedObject\",\n            \"parent\": \"ExplicitManagementImpl\",\n            \"about\": \"Static method to free an unreferenced object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"heap_handle\",\n                    \"type\": \"HeapHandle&\",\n                    \"purpose\": \"The heap handle associated with the object.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"void*\",\n                    \"purpose\": \"Pointer to the object to be freed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"HeapHandle\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT static void FreeUnreferencedObject(HeapHandle&, void*);\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Resize\",\n            \"parent\": \"ExplicitManagementImpl\",\n            \"about\": \"Static method to resize an object.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"void*\",\n                    \"purpose\": \"Pointer to the object to be resized.\"\n                },\n                {\n                    \"name\": \"size\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The new size of the object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if resizing was successful, false otherwise.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\n            V8_EXPORT static bool Resize(void*, size_t);\n        ]]></code>\n    </func>\n    <namespace>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"name\": \"subtle\",\n            \"purpose\": \"Namespace containing subtle APIs for explicit memory management.\"\n        }\n        </metadata>\n        <code><![CDATA[\n            namespace subtle {\n\n            /**\n             * Informs the garbage collector that `object` can be immediately reclaimed. The\n             * destructor may not be invoked immediately but only on next garbage\n             * collection.\n             *\n             * It is up to the embedder to guarantee that no other object holds a reference\n             * to `object` after calling `FreeUnreferencedObject()`. In case such a\n             * reference exists, it's use results in a use-after-free.\n             *\n             * To aid in using the API, `FreeUnreferencedObject()` may be called from\n             * destructors on objects that would be reclaimed in the same garbage collection\n             * cycle.\n             *\n             * \\param heap_handle The corresponding heap.\n             * \\param object Reference to an object that is of type `GarbageCollected` and\n             *   should be immediately reclaimed.\n             */\n            template <typename T>\n            void FreeUnreferencedObject(HeapHandle& heap_handle, T& object) {\n              static_assert(IsGarbageCollectedTypeV<T>,\n                            \"Object must be of type GarbageCollected.\");\n              internal::ExplicitManagementImpl::FreeUnreferencedObject(heap_handle,\n                                                                      &object);\n            }\n\n            /**\n             * Tries to resize `object` of type `T` with additional bytes on top of\n             * sizeof(T). Resizing is only useful with trailing inlined storage, see e.g.\n             * `MakeGarbageCollected(AllocationHandle&, AdditionalBytes)`.\n             *\n             * `Resize()` performs growing or shrinking as needed and may skip the operation\n             * for internal reasons, see return value.\n             *\n             * It is up to the embedder to guarantee that in case of shrinking a larger\n             * object down, the reclaimed area is not used anymore. Any subsequent use\n             * results in a use-after-free.\n             *\n             * The `object` must be live when calling `Resize()`.\n             *\n             * \\param object Reference to an object that is of type `GarbageCollected` and\n             *   should be resized.\n             * \\param additional_bytes Bytes in addition to sizeof(T) that the object should\n             *   provide.\n             * \\returns true when the operation was successful and the result can be relied\n             *   on, and false otherwise.\n             */\n            template <typename T>\n            bool Resize(T& object, AdditionalBytes additional_bytes) {\n              static_assert(IsGarbageCollectedTypeV<T>,\n                            \"Object must be of type GarbageCollected.\");\n              return internal::ExplicitManagementImpl::Resize(\n                  &object, sizeof(T) + additional_bytes.value);\n            }\n\n            }  // namespace subtle\n        ]]></code>\n    </namespace>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"FreeUnreferencedObject\",\n            \"parent\": \"subtle\",\n            \"about\": \"Informs the garbage collector that `object` can be immediately reclaimed.\",\n            \"logic\": \"Calls the internal implementation of FreeUnreferencedObject.\",\n            \"parameters\": [\n                {\n                    \"name\": \"heap_handle\",\n                    \"type\": \"HeapHandle&\",\n                    \"purpose\": \"The corresponding heap.\"\n                },\n                {\n                    \"name\": \"object\",\n                    \"type\": \"T&\",\n                    \"purpose\": \"Reference to an object that is of type `GarbageCollected` and should be immediately reclaimed.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"HeapHandle\",\n                \"IsGarbageCollectedTypeV\",\n                \"internal::ExplicitManagementImpl::FreeUnreferencedObject\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            void FreeUnreferencedObject(HeapHandle& heap_handle, T& object) {\n              static_assert(IsGarbageCollectedTypeV<T>,\n                            \"Object must be of type GarbageCollected.\");\n              internal::ExplicitManagementImpl::FreeUnreferencedObject(heap_handle,\n                                                                      &object);\n            }\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Resize\",\n            \"parent\": \"subtle\",\n            \"about\": \"Tries to resize `object` of type `T` with additional bytes.\",\n            \"logic\": \"Calls the internal implementation of Resize after asserting that object is GarbageCollectedType.\",\n            \"parameters\": [\n                {\n                    \"name\": \"object\",\n                    \"type\": \"T&\",\n                    \"purpose\": \"Reference to an object that is of type `GarbageCollected` and should be resized.\"\n                },\n                {\n                    \"name\": \"additional_bytes\",\n                    \"type\": \"AdditionalBytes\",\n                    \"purpose\": \"Bytes in addition to sizeof(T) that the object should provide.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True when the operation was successful, and false otherwise.\"\n            },\n            \"dependencies\": [\n                \"IsGarbageCollectedTypeV\",\n                \"internal::ExplicitManagementImpl::Resize\",\n                \"AdditionalBytes\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\n            template <typename T>\n            bool Resize(T& object, AdditionalBytes additional_bytes) {\n              static_assert(IsGarbageCollectedTypeV<T>,\n                            \"Object must be of type GarbageCollected.\");\n              return internal::ExplicitManagementImpl::Resize(\n                  &object, sizeof(T) + additional_bytes.value);\n            }\n        ]]></code>\n    </func>\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"AdditionalBytes\",\n                \"about\": \"Represents additional bytes for allocation.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                class AdditionalBytes {\n                public:\n                    size_t value;\n                };\n            ]]></code>\n        </class>\n        <func>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"function\",\n                \"name\": \"IsGarbageCollectedTypeV\",\n                \"about\": \"Checks if a type is garbage collected.\",\n                \"dependencies\": []\n            }\n            </metadata>\n            <code><![CDATA[\n                template <typename T>\n                constexpr bool IsGarbageCollectedTypeV = false;\n            ]]></code>\n        </func>\n    </dependencies>\n</file>\n```"
}