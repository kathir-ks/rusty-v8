{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/include/v8-cppgc.h",
  "error": "JSON and XML parsing failed",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "xml_error": "not well-formed (invalid token): line 44, column 45",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/include/v8-cppgc.h\",\n        \"file_name\": \"v8-cppgc.h\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Defines the CppHeap class and related interfaces for garbage-collected C++ objects in V8.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes standard C++ headers and V8-specific headers for memory management, platform integration, and traced references.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include <cstdint>\n#include <memory>\n#include <vector>\n\n#include \"cppgc/common.h\"\n#include \"cppgc/custom-space.h\"\n#include \"cppgc/heap-statistics.h\"\n#include \"cppgc/visitor.h\"\n#include \"v8-internal.h\"       // NOLINT(build/include_directory)\n#include \"v8-platform.h\"       // NOLINT(build/include_directory)\n#include \"v8-traced-handle.h\"  // NOLINT(build/include_directory)\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CppHeapCreateParams\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Structure for passing parameters to the CppHeap::Create method, including custom spaces and GC support types.\",\n            \"attributes\": [\n                {\n                    \"name\": \"custom_spaces\",\n                    \"type\": \"std::vector<std::unique_ptr<cppgc::CustomSpaceBase>>\",\n                    \"access\": \"public\",\n                    \"purpose\": \"A vector of unique pointers to custom memory spaces.\"\n                },\n                {\n                    \"name\": \"marking_support\",\n                    \"type\": \"cppgc::Heap::MarkingType\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Specifies the marking support type for the heap (incremental, concurrent).\"\n                },\n                {\n                    \"name\": \"sweeping_support\",\n                    \"type\": \"cppgc::Heap::SweepingType\",\n                    \"access\": \"public\",\n                    \"purpose\": \"Specifies the sweeping support type for the heap (incremental, concurrent).\"\n                }\n            ],\n            \"dependencies\": [\n                \"cppgc::CustomSpaceBase\",\n                \"cppgc::Heap::MarkingType\",\n                \"cppgc::Heap::SweepingType\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nstruct V8_EXPORT CppHeapCreateParams {\n  explicit CppHeapCreateParams(\n      std::vector<std::unique_ptr<cppgc::CustomSpaceBase>> custom_spaces)\n      : custom_spaces(std::move(custom_spaces)) {}\n\n  CppHeapCreateParams(const CppHeapCreateParams&) = delete;\n  CppHeapCreateParams& operator=(const CppHeapCreateParams&) = delete;\n\n  std::vector<std::unique_ptr<cppgc::CustomSpaceBase>> custom_spaces;\n  /**\n   * Specifies which kind of marking are supported by the heap. The type may be\n   * further reduced via runtime flags when attaching the heap to an Isolate.\n   */\n  cppgc::Heap::MarkingType marking_support =\n      cppgc::Heap::MarkingType::kIncrementalAndConcurrent;\n  /**\n   * Specifies which kind of sweeping is supported by the heap. The type may be\n   * further reduced via runtime flags when attaching the heap to an Isolate.\n   */\n  cppgc::Heap::SweepingType sweeping_support =\n      cppgc::Heap::SweepingType::kIncrementalAndConcurrent;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CppHeap\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Manages a heap for allocating garbage-collected C++ objects in V8.  Similar to v8::Isolate, accessed from one thread at a time.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"v8::Platform\",\n                \"CppHeapCreateParams\",\n                \"cppgc::AllocationHandle\",\n                \"cppgc::HeapHandle\",\n                \"cppgc::HeapStatistics\",\n                \"cppgc::CustomSpaceIndex\",\n                \"CustomSpaceStatisticsReceiver\",\n                \"cppgc::EmbedderStackState\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass V8_EXPORT CppHeap {\n public:\n  static std::unique_ptr<CppHeap> Create(v8::Platform* platform,\n                                         const CppHeapCreateParams& params);\n\n  virtual ~CppHeap() = default;\n\n  /**\n   * \\returns the opaque handle for allocating objects using\n   * `MakeGarbageCollected()`.\n   */\n  cppgc::AllocationHandle& GetAllocationHandle();\n\n  /**\n   * \\returns the opaque heap handle which may be used to refer to this heap in\n   *   other APIs. Valid as long as the underlying `CppHeap` is alive.\n   */\n  cppgc::HeapHandle& GetHeapHandle();\n\n  /**\n   * Terminate clears all roots and performs multiple garbage collections to\n   * reclaim potentially newly created objects in destructors.\n   *\n   * After this call, object allocation is prohibited.\n   */\n  V8_DEPRECATED(\"Terminate gets automatically called in the CppHeap destructor\")\n  void Terminate();\n\n  /**\n   * \\param detail_level specifies whether should return detailed\n   *   statistics or only brief summary statistics.\n   * \\returns current CppHeap statistics regarding memory consumption\n   *   and utilization.\n   */\n  cppgc::HeapStatistics CollectStatistics(\n      cppgc::HeapStatistics::DetailLevel detail_level);\n\n  /**\n   * Collects statistics for the given spaces and reports them to the receiver.\n   *\n   * \\param custom_spaces a collection of custom space indices.\n   * \\param receiver an object that gets the results.\n   */\n  void CollectCustomSpaceStatisticsAtLastGC(\n      std::vector<cppgc::CustomSpaceIndex> custom_spaces,\n      std::unique_ptr<CustomSpaceStatisticsReceiver> receiver);\n\n  /**\n   * Enables a detached mode that allows testing garbage collection using\n   * `cppgc::testing` APIs. Once used, the heap cannot be attached to an\n   * `Isolate` anymore.\n   */\n  void EnableDetachedGarbageCollectionsForTesting();\n\n  /**\n   * Performs a stop-the-world garbage collection for testing purposes.\n   *\n   * \\param stack_state The stack state to assume for the garbage collection.\n   */\n  void CollectGarbageForTesting(cppgc::EmbedderStackState stack_state);\n\n  /**\n   * Performs a stop-the-world minor garbage collection for testing purposes.\n   *\n   * \\param stack_state The stack state to assume for the garbage collection.\n   */\n  void CollectGarbageInYoungGenerationForTesting(\n      cppgc::EmbedderStackState stack_state);\n\n private:\n  CppHeap() = default;\n\n  friend class internal::CppHeap;\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"JSVisitor\",\n            \"extends\": \"cppgc::Visitor\",\n            \"implements\": [],\n            \"about\": \"A custom visitor class used for tracing JavaScript objects during garbage collection.  Extends cppgc::Visitor.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"cppgc::Visitor\",\n                \"TracedReferenceBase\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass JSVisitor : public cppgc::Visitor {\n public:\n  explicit JSVisitor(cppgc::Visitor::Key key) : cppgc::Visitor(key) {}\n  ~JSVisitor() override = default;\n\n  void Trace(const TracedReferenceBase& ref) {\n    if (ref.IsEmptyThreadSafe()) return;\n    Visit(ref);\n  }\n\n protected:\n  using cppgc::Visitor::Visit;\n\n  virtual void Visit(const TracedReferenceBase& ref) {}\n};\n        ]]></code>\n    </class>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"CustomSpaceStatisticsReceiver\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"An abstract class/interface for receiving custom space statistics after a garbage collection.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"cppgc::CustomSpaceIndex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass CustomSpaceStatisticsReceiver {\n public:\n  virtual ~CustomSpaceStatisticsReceiver() = default;\n  /**\n   * Reports the size of a space at the last GC. It is called for each space\n   * that was requested in `CollectCustomSpaceStatisticsAtLastGC()`.\n   *\n   * \\param space_index The index of the space.\n   * \\param bytes The total size of live objects in the space at the last GC.\n   *    It is zero if there was no GC yet.\n   */\n  virtual void AllocatedBytes(cppgc::CustomSpaceIndex space_index,\n                              size_t bytes) = 0;\n};\n        ]]></code>\n    </class>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"TracedReferenceBase\",\n                \"about\": \"Base class for traced references in V8.  Used in JSVisitor.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                class TracedReferenceBase {\n                public:\n                    bool IsEmptyThreadSafe() const;\n                };\n            ]]></code>\n        </class>\n    </dependencies>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"v8::Platform\",\n                \"about\": \"Abstract interface for platform integration in V8.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 {\n                    class Platform {};\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::Visitor\",\n                \"about\": \"Base class for visitors used in garbage collection in cppgc.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    class Visitor {\n                        public:\n                            using Key = int;\n                            Visitor(Key key);\n                            virtual ~Visitor() = 0;\n                            void Visit(const TracedReferenceBase& ref);\n                    };\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"v8::TracedReference\",\n                \"about\": \"A traced reference to a garbage collected object in V8.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace v8 {\n                    template <typename T>\n                    class TracedReference {};\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::CustomSpaceBase\",\n                \"about\": \"Base class for custom memory spaces managed by cppgc.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    class CustomSpaceBase {};\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n\n    <dependencies>\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"cppgc::Heap::MarkingType\",\n                \"about\": \"Enum defining the types of marking supported by the heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    class Heap {\n                        public:\n                            enum class MarkingType {\n                                kIncrementalAndConcurrent\n                            };\n                    };\n                }\n            ]]></code>\n        </enum>\n    </dependencies>\n\n    <dependencies>\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"cppgc::Heap::SweepingType\",\n                \"about\": \"Enum defining the types of sweeping supported by the heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    class Heap {\n                        public:\n                            enum class SweepingType {\n                                kIncrementalAndConcurrent\n                            };\n                    };\n                }\n            ]]></code>\n        </enum>\n    </dependencies>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::AllocationHandle\",\n                \"about\": \"Handle for allocating objects using MakeGarbageCollected.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    class AllocationHandle {};\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::HeapHandle\",\n                \"about\": \"Opaque handle to a cppgc heap.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    class HeapHandle {};\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n\n    <dependencies>\n        <class>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"class\",\n                \"name\": \"cppgc::HeapStatistics\",\n                \"about\": \"Structure holding heap statistics.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    class HeapStatistics {\n                        public:\n                            enum class DetailLevel {\n                                kDetailed,\n                                kBrief\n                            };\n                    };\n                }\n            ]]></code>\n        </class>\n    </dependencies>\n\n    <dependencies>\n        <typedef>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"typedef\",\n                \"name\": \"cppgc::CustomSpaceIndex\",\n                \"about\": \"Type alias for a custom space index.\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    using CustomSpaceIndex = size_t;\n                }\n            ]]></code>\n        </typedef>\n    </dependencies>\n\n        <dependencies>\n        <enum>\n            <metadata>\n            {\n                \"language\": \"cpp\",\n                \"type\": \"enum\",\n                \"name\": \"cppgc::EmbedderStackState\",\n                \"about\": \"Enum defining possible states of the stack during garbage collection\"\n            }\n            </metadata>\n            <code><![CDATA[\n                namespace cppgc {\n                    enum class EmbedderStackState {\n                        kNoHeapPointersOnStack,\n                        kMayContainHeapPointers\n                    };\n                }\n            ]]></code>\n        </enum>\n    </dependencies>\n</file>\n```"
}