{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/execution/futex-emulation.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/execution/futex-emulation.cc\",\n        \"file_name\": \"futex-emulation.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements futex emulation for synchronization primitives (Atomics.wait/wake) when native futex support is unavailable.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for futex emulation, including standard library headers and V8-specific headers.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/execution/futex-emulation.h\"\n\n#include <limits>\n\n#include \"src/api/api-inl.h\"\n#include \"src/base/lazy-instance.h\"\n#include \"src/base/logging.h\"\n#include \"src/base/macros.h\"\n#include \"src/base/small-map.h\"\n#include \"src/execution/isolate.h\"\n#include \"src/execution/vm-state-inl.h\"\n#include \"src/handles/handles-inl.h\"\n#include \"src/numbers/conversions.h\"\n#include \"src/objects/js-array-buffer-inl.h\"\n#include \"src/objects/js-promise-inl.h\"\n#include \"src/objects/objects-inl.h\"\n#include \"src/tasks/cancelable-task.h\"\n        ]]></code>\n    </imports>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"FutexWaitList\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"Manages all contexts waiting (synchronously or asynchronously) on any address.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"base::Mutex\",\n                \"base::SmallMap\",\n                \"JSArrayBuffer\",\n                \"FutexWaitListNode\",\n                \"Isolate\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass FutexWaitList {\n public:\n  FutexWaitList() = default;\n  FutexWaitList(const FutexWaitList&) = delete;\n  FutexWaitList& operator=(const FutexWaitList&) = delete;\n\n  void AddNode(FutexWaitListNode* node);\n  void RemoveNode(FutexWaitListNode* node);\n\n  static void* ToWaitLocation(Tagged<JSArrayBuffer> array_buffer, size_t addr) {\n    DCHECK_LT(addr, array_buffer->GetByteLength());\n    // Use the cheaper JSArrayBuffer::backing_store() accessor, but DCHECK that\n    // it matches the start of the JSArrayBuffer::GetBackingStore().\n    DCHECK_EQ(array_buffer->backing_store(),\n              array_buffer->GetBackingStore()->buffer_start());\n    return static_cast<uint8_t*>(array_buffer->backing_store()) + addr;\n  }\n\n  // Deletes \"node\" and returns the next node of its list.\n  static FutexWaitListNode* DeleteAsyncWaiterNode(FutexWaitListNode* node) {\n    DCHECK(node->IsAsync());\n    DCHECK_NOT_NULL(node->async_state_->isolate_for_async_waiters);\n    FutexWaitListNode* next = node->next_;\n    if (node->prev_ != nullptr) {\n      node->prev_->next_ = next;\n    }\n    if (next != nullptr) {\n      next->prev_ = node->prev_;\n    }\n    delete node;\n    return next;\n  }\n\n  static void DeleteNodesForIsolate(Isolate* isolate, FutexWaitListNode** head,\n                                    FutexWaitListNode** tail) {\n    // For updating head & tail once we've iterated all nodes.\n    FutexWaitListNode* new_head = nullptr;\n    FutexWaitListNode* new_tail = nullptr;\n    for (FutexWaitListNode* node = *head; node;) {\n      if (node->IsAsync() &&\n          node->async_state_->isolate_for_async_waiters == isolate) {\n        node->async_state_->timeout_task_id =\n            CancelableTaskManager::kInvalidTaskId;\n        node = DeleteAsyncWaiterNode(node);\n      } else {\n        if (new_head == nullptr) {\n          new_head = node;\n        }\n        new_tail = node;\n        node = node->next_;\n      }\n    }\n    *head = new_head;\n    *tail = new_tail;\n  }\n\n  // For checking the internal consistency of the FutexWaitList.\n  void Verify() const;\n  // Returns true if |node| is on the linked list starting with |head|.\n  static bool NodeIsOnList(FutexWaitListNode* node, FutexWaitListNode* head);\n\n  base::Mutex* mutex() { return &mutex_; }\n\n private:\n  friend class FutexEmulation;\n\n  struct HeadAndTail {\n    FutexWaitListNode* head;\n    FutexWaitListNode* tail;\n  };\n\n  // `mutex` protects the composition of the fields below (i.e. no elements may\n  // be added or removed without holding this mutex), as well as the `waiting_`\n  // and `interrupted_` fields for each individual list node that is currently\n  // part of the list. It must be the mutex used together with the `cond_`\n  // condition variable of such nodes.\n  base::Mutex mutex_;\n\n  // Location inside a shared buffer -> linked list of Nodes waiting on that\n  // location.\n  // As long as the map does not grow beyond 16 entries, there is no dynamic\n  // allocation and deallocation happening in wait or wake, which reduces the\n  // time spend in the critical section.\n  base::SmallMap<std::map<void*, HeadAndTail>, 16> location_lists_;\n\n  // Isolate* -> linked list of Nodes which are waiting for their Promises to\n  // be resolved.\n  base::SmallMap<std::map<Isolate*, HeadAndTail>> isolate_promises_to_resolve_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"GetWaitList\",\n            \"parent\": null,\n            \"about\": \"Returns the lazily initialized global wait list.\",\n            \"logic\": \"Uses a lazy leaky object getter to ensure the FutexWaitList is initialized only once and its pointer is globally accessible.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"FutexWaitList*\",\n                \"description\": \"Pointer to the global FutexWaitList instance.\"\n            },\n            \"dependencies\": [\n                \"FutexWaitList\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\n// {GetWaitList} returns the lazily initialized global wait list.\nDEFINE_LAZY_LEAKY_OBJECT_GETTER(FutexWaitList, GetWaitList)\n\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"CancelTimeoutTask\",\n            \"parent\": \"FutexWaitListNode\",\n            \"about\": \"Cancels the timeout task associated with an asynchronous waiter.\",\n            \"logic\": \"Checks if a timeout task is associated with the node. If so, tries to abort the task using the CancelableTaskManager and returns true if the task was successfully aborted or was not running. Returns false if the task is running and could not be aborted.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"bool\",\n                \"description\": \"True if the timeout task was canceled or didn't exist, false if the task is running.\"\n            },\n            \"dependencies\": [\n                \"CancelableTaskManager\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nbool FutexWaitListNode::CancelTimeoutTask() {\n  DCHECK(IsAsync());\n  if (async_state_->timeout_task_id == CancelableTaskManager::kInvalidTaskId) {\n    return true;\n  }\n  auto* cancelable_task_manager =\n      async_state_->isolate_for_async_waiters->cancelable_task_manager();\n  TryAbortResult return_value =\n      cancelable_task_manager->TryAbort(async_state_->timeout_task_id);\n  async_state_->timeout_task_id = CancelableTaskManager::kInvalidTaskId;\n  return return_value != TryAbortResult::kTaskRunning;\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NotifyWake\",\n            \"parent\": \"FutexWaitListNode\",\n            \"about\": \"Notifies a synchronous waiter that it has been woken up.\",\n            \"logic\": \"Acquires the FutexWaitList mutex, sets the interrupted_ flag to true, and notifies the condition variable associated with the node.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FutexWaitList\",\n                \"base::Mutex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid FutexWaitListNode::NotifyWake() {\n  DCHECK(!IsAsync());\n  // Lock the FutexEmulation mutex before notifying. We know that the mutex\n  // will have been unlocked if we are currently waiting on the condition\n  // variable. The mutex will not be locked if FutexEmulation::Wait hasn't\n  // locked it yet. In that case, we set the interrupted_\n  // flag to true, which will be tested after the mutex locked by a future wait.\n  FutexWaitList* wait_list = GetWaitList();\n  NoGarbageCollectionMutexGuard lock_guard(wait_list->mutex());\n\n  // if not waiting, this will not have any effect.\n  cond_.NotifyOne();\n  interrupted_ = true;\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"ResolveAsyncWaiterPromisesTask\",\n            \"extends\": \"CancelableTask\",\n            \"implements\": [],\n            \"about\": \"A task that resolves promises for asynchronous waiters.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CancelableTask\",\n                \"Isolate\",\n                \"FutexEmulation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass ResolveAsyncWaiterPromisesTask : public CancelableTask {\n public:\n  ResolveAsyncWaiterPromisesTask(Isolate* isolate)\n      : CancelableTask(isolate), isolate_(isolate) {}\n\n  void RunInternal() override {\n    FutexEmulation::ResolveAsyncWaiterPromises(isolate_);\n  }\n\n private:\n  Isolate* isolate_;\n};\n        ]]></code>\n    </class>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AsyncWaiterTimeoutTask\",\n            \"extends\": \"CancelableTask\",\n            \"implements\": [],\n            \"about\": \"A task that handles timeouts for asynchronous waiters.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"CancelableTask\",\n                \"CancelableTaskManager\",\n                \"FutexWaitListNode\",\n                \"FutexEmulation\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass AsyncWaiterTimeoutTask : public CancelableTask {\n public:\n  AsyncWaiterTimeoutTask(CancelableTaskManager* cancelable_task_manager,\n                         FutexWaitListNode* node)\n      : CancelableTask(cancelable_task_manager), node_(node) {}\n\n  void RunInternal() override {\n    FutexEmulation::HandleAsyncWaiterTimeout(node_);\n  }\n\n private:\n  FutexWaitListNode* node_;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NotifyAsyncWaiter\",\n            \"parent\": \"FutexEmulation\",\n            \"about\": \"Notifies an asynchronous waiter that it has been woken up.\",\n            \"logic\": \"Removes the node from the FutexWaitList and schedules a task to resolve the promise associated with the node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"FutexWaitListNode*\",\n                    \"purpose\": \"The node representing the waiter to be notified.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FutexWaitList\",\n                \"FutexWaitListNode\",\n                \"ResolveAsyncWaiterPromisesTask\",\n                \"base::Mutex\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid FutexEmulation::NotifyAsyncWaiter(FutexWaitListNode* node) {\n  DCHECK(node->IsAsync());\n  // This function can run in any thread.\n\n  FutexWaitList* wait_list = GetWaitList();\n  wait_list->mutex()->AssertHeld();\n\n  // Nullify the timeout time; this distinguishes timed out waiters from\n  // woken up ones.\n  node->async_state_->timeout_time = base::TimeTicks();\n\n  wait_list->RemoveNode(node);\n\n  // Schedule a task for resolving the Promise. It's still possible that the\n  // timeout task runs before the promise resolving task. In that case, the\n  // timeout task will just ignore the node.\n  auto& isolate_map = wait_list->isolate_promises_to_resolve_;\n  auto it = isolate_map.find(node->async_state_->isolate_for_async_waiters);\n  if (it == isolate_map.end()) {\n    // This Isolate doesn't have other Promises to resolve at the moment.\n    isolate_map.insert(\n        std::make_pair(node->async_state_->isolate_for_async_waiters,\n                       FutexWaitList::HeadAndTail{node, node}));\n    auto task = std::make_unique<ResolveAsyncWaiterPromisesTask>(\n        node->async_state_->isolate_for_async_waiters);\n    node->async_state_->task_runner->PostNonNestableTask(std::move(task));\n  } else {\n    // Add this Node into the existing list.\n    node->prev_ = it->second.tail;\n    it->second.tail->next_ = node;\n    it->second.tail = node;\n  }\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AddNode\",\n            \"parent\": \"FutexWaitList\",\n            \"about\": \"Adds a node to the wait list for a specific memory location.\",\n            \"logic\": \"Inserts the node into the linked list associated with the wait location. If the list doesn't exist, it creates a new list. Maintains a doubly-linked list for efficient removal.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"FutexWaitListNode*\",\n                    \"purpose\": \"The node to add to the wait list.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FutexWaitListNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid FutexWaitList::AddNode(FutexWaitListNode* node) {\n  DCHECK_NULL(node->prev_);\n  DCHECK_NULL(node->next_);\n  auto [it, inserted] =\n      location_lists_.insert({node->wait_location_, HeadAndTail{node, node}});\n  if (!inserted) {\n    it->second.tail->next_ = node;\n    node->prev_ = it->second.tail;\n    it->second.tail = node;\n  }\n\n  Verify();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RemoveNode\",\n            \"parent\": \"FutexWaitList\",\n            \"about\": \"Removes a node from the wait list.\",\n            \"logic\": \"Removes the node from the doubly-linked list associated with its wait location.  Handles cases where the node is the head, tail, or in the middle of the list. If the list becomes empty, it removes the entire list.\",\n            \"parameters\": [\n                {\n                    \"name\": \"node\",\n                    \"type\": \"FutexWaitListNode*\",\n                    \"purpose\": \"The node to remove from the wait list.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FutexWaitListNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid FutexWaitList::RemoveNode(FutexWaitListNode* node) {\n  if (!node->prev_ && !node->next_) {\n    // If the node was the last one on its list, delete the whole list.\n    size_t erased = location_lists_.erase(node->wait_location_);\n    DCHECK_EQ(1, erased);\n    USE(erased);\n  } else if (node->prev_ && node->next_) {\n    // If we have both a successor and a predecessor, skip the lookup in the\n    // list and just update those two nodes directly.\n    node->prev_->next_ = node->next_;\n    node->next_->prev_ = node->prev_;\n    node->prev_ = node->next_ = nullptr;\n  } else {\n    // Otherwise we have to lookup in the list to find the head and tail\n    // pointers.\n    auto it = location_lists_.find(node->wait_location_);\n    DCHECK_NE(location_lists_.end(), it);\n    DCHECK(NodeIsOnList(node, it->second.head));\n\n    if (node->prev_) {\n      DCHECK(!node->next_);\n      node->prev_->next_ = nullptr;\n      DCHECK_EQ(node, it->second.tail);\n      it->second.tail = node->prev_;\n      node->prev_ = nullptr;\n    } else {\n      DCHECK_EQ(node, it->second.head);\n      it->second.head = node->next_;\n      DCHECK(node->next_);\n      node->next_->prev_ = nullptr;\n      node->next_ = nullptr;\n    }\n  }\n\n  Verify();\n}\n        ]]></code>\n    </func>\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"AtomicsWaitWakeHandle\",\n            \"extends\": null,\n            \"implements\": [],\n            \"about\": \"A handle used to stop a synchronous Atomics.wait operation from the API callback.\",\n            \"attributes\": [],\n            \"dependencies\": [\n                \"Isolate\",\n                \"FutexWaitListNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nclass AtomicsWaitWakeHandle {\n public:\n  AtomicsWaitWakeHandle(Isolate* isolate) : isolate_(isolate) {}\n  void Wake();\n  bool has_stopped() const {\n    base::MutexGuard lock_guard(&mutex_);\n    return stopped_;\n  }\n\n private:\n  Isolate* isolate_;\n  base::Mutex mutex_;\n  bool stopped_ = false;\n};\n        ]]></code>\n    </class>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Wake\",\n            \"parent\": \"AtomicsWaitWakeHandle\",\n            \"about\": \"Wakes up a synchronous waiter associated with this handle.\",\n            \"logic\": \"Sets the stopped_ flag to true and notifies the FutexWaitListNode associated with the isolate.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"FutexWaitList\",\n                \"base::Mutex\",\n                \"FutexWaitListNode\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid AtomicsWaitWakeHandle::Wake() {\n  // Adding a separate `NotifyWake()` variant that doesn't acquire the lock\n  // itself would likely just add unnecessary complexity..\n  // The split lock by itself isn\u2019t an issue, as long as the caller properly\n  // synchronizes this with the closing `AtomicsWaitCallback`.\n  FutexWaitList* wait_list = GetWaitList();\n  {\n    NoGarbageCollectionMutexGuard lock_guard(wait_list->mutex());\n    stopped_ = true;\n  }\n  isolate_->futex_wait_list_node()->NotifyWake();\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"WaitJsTranslateReturn\",\n            \"parent\": null,\n            \"about\": \"Translates the return value of the Wait function into a JavaScript-compatible string.\",\n            \"logic\": \"Converts integer return codes from the Wait function (kOk, kNotEqualValue, kTimedOut) into corresponding string values ('ok', 'not-equal', 'timed-out') that can be used in JavaScript.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate for which to get read-only roots.\"\n                },\n                {\n                    \"name\": \"res\",\n                    \"type\": \"Tagged<Object>\",\n                    \"purpose\": \"The return value from the Wait function.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Object>\",\n                \"description\": \"The translated return value as a string.\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace {\n\nenum WaitReturnValue : int { kOk = 0, kNotEqualValue = 1, kTimedOut = 2 };\n\nTagged<Object> WaitJsTranslateReturn(Isolate* isolate, Tagged<Object> res) {\n  if (IsSmi(res)) {\n    int val = Smi::ToInt(res);\n    switch (val) {\n      case WaitReturnValue::kOk:\n        return ReadOnlyRoots(isolate).ok_string();\n      case WaitReturnValue::kNotEqualValue:\n        return ReadOnlyRoots(isolate).not_equal_string();\n      case WaitReturnValue::kTimedOut:\n        return ReadOnlyRoots(isolate).timed_out_string();\n      default:\n        UNREACHABLE();\n    }\n  }\n  return res;\n}\n\n}  // namespace\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WaitJs32\",\n            \"parent\": \"FutexEmulation\",\n            \"about\": \"Wraps the Wait function for 32-bit integers, translating the return value for JavaScript.\",\n            \"logic\": \"Calls the Wait function with a 32-bit integer value and then translates the return value using WaitJsTranslateReturn.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to use.\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"WaitMode\",\n                    \"purpose\": \"The wait mode (sync or async).\"\n                },\n                {\n                    \"name\": \"array_buffer\",\n                    \"type\": \"DirectHandle<JSArrayBuffer>\",\n                    \"purpose\": \"The shared array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"addr\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The address within the array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int32_t\",\n                    \"purpose\": \"The expected value to wait for.\"\n                },\n                {\n                    \"name\": \"rel_timeout_ms\",\n                    \"type\": \"double\",\n                    \"purpose\": \"The relative timeout in milliseconds.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Object>\",\n                \"description\": \"The translated return value as a string.\"\n            },\n            \"dependencies\": [\n                \"FutexEmulation::Wait\",\n                \"WaitJsTranslateReturn\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTagged<Object> FutexEmulation::WaitJs32(\n    Isolate* isolate, WaitMode mode, DirectHandle<JSArrayBuffer> array_buffer,\n    size_t addr, int32_t value, double rel_timeout_ms) {\n  Tagged<Object> res =\n      Wait<int32_t>(isolate, mode, array_buffer, addr, value, rel_timeout_ms);\n  return WaitJsTranslateReturn(isolate, res);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WaitJs64\",\n            \"parent\": \"FutexEmulation\",\n            \"about\": \"Wraps the Wait function for 64-bit integers, translating the return value for JavaScript.\",\n            \"logic\": \"Calls the Wait function with a 64-bit integer value and then translates the return value using WaitJsTranslateReturn.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to use.\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"WaitMode\",\n                    \"purpose\": \"The wait mode (sync or async).\"\n                },\n                {\n                    \"name\": \"array_buffer\",\n                    \"type\": \"DirectHandle<JSArrayBuffer>\",\n                    \"purpose\": \"The shared array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"addr\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The address within the array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The expected value to wait for.\"\n                },\n                {\n                    \"name\": \"rel_timeout_ms\",\n                    \"type\": \"double\",\n                    \"purpose\": \"The relative timeout in milliseconds.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Object>\",\n                \"description\": \"The translated return value as a string.\"\n            },\n            \"dependencies\": [\n                \"FutexEmulation::Wait\",\n                \"WaitJsTranslateReturn\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTagged<Object> FutexEmulation::WaitJs64(\n    Isolate* isolate, WaitMode mode, DirectHandle<JSArrayBuffer> array_buffer,\n    size_t addr, int64_t value, double rel_timeout_ms) {\n  Tagged<Object> res =\n      Wait<int64_t>(isolate, mode, array_buffer, addr, value, rel_timeout_ms);\n  return WaitJsTranslateReturn(isolate, res);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WaitWasm32\",\n            \"parent\": \"FutexEmulation\",\n            \"about\": \"Wraps the Wait function for 32-bit integers in WebAssembly, using synchronous waiting.\",\n            \"logic\": \"Calls the Wait function with a 32-bit integer value, forcing synchronous wait and converting the timeout to a boolean and nanoseconds.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to use.\"\n                },\n                {\n                    \"name\": \"array_buffer\",\n                    \"type\": \"DirectHandle<JSArrayBuffer>\",\n                    \"purpose\": \"The shared array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"addr\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The address within the array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int32_t\",\n                    \"purpose\": \"The expected value to wait for.\"\n                },\n                {\n                    \"name\": \"rel_timeout_ns\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The relative timeout in nanoseconds.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Object>\",\n                \"description\": \"The return value from the Wait function.\"\n            },\n            \"dependencies\": [\n                \"FutexEmulation::Wait\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTagged<Object> FutexEmulation::WaitWasm32(\n    Isolate* isolate, DirectHandle<JSArrayBuffer> array_buffer, size_t addr,\n    int32_t value, int64_t rel_timeout_ns) {\n  return Wait<int32_t>(isolate, WaitMode::kSync, array_buffer, addr, value,\n                       rel_timeout_ns >= 0, rel_timeout_ns, CallType::kIsWasm);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"WaitWasm64\",\n            \"parent\": \"FutexEmulation\",\n            \"about\": \"Wraps the Wait function for 64-bit integers in WebAssembly, using synchronous waiting.\",\n            \"logic\": \"Calls the Wait function with a 64-bit integer value, forcing synchronous wait and converting the timeout to a boolean and nanoseconds.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to use.\"\n                },\n                {\n                    \"name\": \"array_buffer\",\n                    \"type\": \"DirectHandle<JSArrayBuffer>\",\n                    \"purpose\": \"The shared array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"addr\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The address within the array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The expected value to wait for.\"\n                },\n                {\n                    \"name\": \"rel_timeout_ns\",\n                    \"type\": \"int64_t\",\n                    \"purpose\": \"The relative timeout in nanoseconds.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Object>\",\n                \"description\": \"The return value from the Wait function.\"\n            },\n            \"dependencies\": [\n                \"FutexEmulation::Wait\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nTagged<Object> FutexEmulation::WaitWasm64(\n    Isolate* isolate, DirectHandle<JSArrayBuffer> array_buffer, size_t addr,\n    int64_t value, int64_t rel_timeout_ns) {\n  return Wait<int64_t>(isolate, WaitMode::kSync, array_buffer, addr, value,\n                       rel_timeout_ns >= 0, rel_timeout_ns, CallType::kIsWasm);\n}\n        ]]></code>\n    </func>\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Wait\",\n            \"parent\": \"FutexEmulation\",\n            \"about\": \"Generic template function for waiting on a shared array buffer.\",\n            \"logic\": \"Determines whether to use a timeout, converts the timeout to nanoseconds, and then calls either WaitSync or WaitAsync depending on the wait mode.\",\n            \"parameters\": [\n                {\n                    \"name\": \"isolate\",\n                    \"type\": \"Isolate*\",\n                    \"purpose\": \"The isolate to use.\"\n                },\n                {\n                    \"name\": \"mode\",\n                    \"type\": \"WaitMode\",\n                    \"purpose\": \"The wait mode (sync or async).\"\n                },\n                {\n                    \"name\": \"array_buffer\",\n                    \"type\": \"DirectHandle<JSArrayBuffer>\",\n                    \"purpose\": \"The shared array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"addr\",\n                    \"type\": \"size_t\",\n                    \"purpose\": \"The address within the array buffer to wait on.\"\n                },\n                {\n                    \"name\": \"value\",\n                    \"type\": \"T\",\n                    \"purpose\": \"The expected value to wait for.\"\n                },\n                {\n                    \"name\": \"rel_timeout_ms\",\n                    \"type\": \"double\",\n                    \"purpose\": \"The relative timeout in milliseconds.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Tagged<Object>\",\n                \"description\": \"The return value from either WaitSync or WaitAsync.\"\n            },\n            \"dependencies\": [\n                \"FutexEmulation::WaitSync\",\n                \"FutexEmulation::WaitAsync\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename T>\nTagged<Object> FutexEmulation::Wait(Isolate* isolate, WaitMode mode,\n                                    DirectHandle<JSArrayBuffer> array_buffer,\n                                    size_t addr, T value,\n                                    double rel_timeout_ms) {\n  DCHECK_LT(addr, array_buffer->GetByteLength());\n\n  bool use_timeout = rel_timeout_ms != V8_INFINITY;\n  int64_t rel_timeout_ns = -1;\n\n  if (use_timeout) {\n    // Convert to nanoseconds.\n    double timeout_ns = rel_timeout_ms *\n                        base::Time::kNanosecondsPerMicrosecond *\n                        "
}