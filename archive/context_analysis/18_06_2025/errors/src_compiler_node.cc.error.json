{
  "file_path": "/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node.cc",
  "error": "Response not JSON and not XML-like after cleanup",
  "json_error_if_any": "Skipped JSON parsing for whole response due to presence of XML tags; XML is primary.",
  "raw_response": "```xml\n<file>\n    <metadata>\n    {\n        \"path\": \"/home/kathirks_gc/v8_go/archive/codebase/src/compiler/node.cc\",\n        \"file_name\": \"node.cc\",\n        \"language\": \"cpp\",\n        \"purpose\": \"Implements the Node class, which represents a node in the compiler's graph representation.\"\n    }\n    </metadata>\n    <imports>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"purpose\": \"Includes necessary headers for Node class definition and related functionalities.\"\n        }\n        </metadata>\n        <code><![CDATA[\n#include \"src/compiler/node.h\"\n        ]]></code>\n    </imports>\n\n    <class>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"class\",\n            \"name\": \"Node::OutOfLineInputs\",\n            \"about\": \"Represents the out-of-line storage for Node inputs when the number of inputs exceeds the inline capacity.\",\n            \"attributes\": [\n                {\n                    \"name\": \"capacity_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The maximum number of inputs this out-of-line storage can hold.\"\n                },\n                {\n                    \"name\": \"count_\",\n                    \"type\": \"int\",\n                    \"access\": \"private\",\n                    \"purpose\": \"The current number of inputs stored in this out-of-line storage.\"\n                },\n                {\n                    \"name\": \"node_\",\n                    \"type\": \"Node*\",\n                    \"access\": \"private\",\n                    \"purpose\": \"Pointer to the node that owns this out-of-line inputs storage.\"\n                }\n            ],\n            \"dependencies\": [\n                \"Zone\",\n                \"Node\",\n                \"Use\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nnamespace v8 {\nnamespace internal {\nnamespace compiler {\n\nclass Node {\n public:\n  struct OutOfLineInputs {\n    Node* node_;\n    int capacity_;\n    int count_;\n  };\n};\n}  // namespace compiler\n}  // namespace internal\n}  // namespace v8\n        ]]></code>\n    </class>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"New\",\n            \"parent\": \"Node::OutOfLineInputs\",\n            \"about\": \"Creates a new OutOfLineInputs object in the specified zone.\",\n            \"logic\": \"Allocates memory for the OutOfLineInputs object and its associated arrays for Node pointers and Use objects. Initializes the capacity and count.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"capacity\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The capacity of the OutOfLineInputs object.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node::OutOfLineInputs*\",\n                \"description\": \"A pointer to the newly created OutOfLineInputs object.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"Node\",\n                \"Use\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode::OutOfLineInputs* Node::OutOfLineInputs::New(Zone* zone, int capacity) {\n  size_t size =\n      sizeof(OutOfLineInputs) + capacity * (sizeof(Node*) + sizeof(Use));\n  intptr_t raw_buffer =\n      reinterpret_cast<intptr_t>(zone->Allocate<Node::OutOfLineInputs>(size));\n  Node::OutOfLineInputs* outline =\n      reinterpret_cast<OutOfLineInputs*>(raw_buffer + capacity * sizeof(Use));\n  outline->capacity_ = capacity;\n  outline->count_ = 0;\n  return outline;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ExtractFrom\",\n            \"parent\": \"Node::OutOfLineInputs\",\n            \"about\": \"Extracts inputs from old use and input pointers and copies them to the out-of-line storage.\",\n            \"logic\": \"Iterates through the specified number of inputs, copying the Node pointers and Use objects from the old locations to the new out-of-line storage. Updates the Use objects to reflect the new storage location and update node use lists.\",\n            \"parameters\": [\n                {\n                    \"name\": \"old_use_ptr\",\n                    \"type\": \"Use*\",\n                    \"purpose\": \"Pointer to the old Use object.\"\n                },\n                {\n                    \"name\": \"old_input_ptr\",\n                    \"type\": \"ZoneNodePtr*\",\n                    \"purpose\": \"Pointer to the old input Node pointer.\"\n                },\n                {\n                    \"name\": \"count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of inputs to extract.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"ZoneNodePtr\",\n                \"Node\",\n                \"Use\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::OutOfLineInputs::ExtractFrom(Use* old_use_ptr,\n                                        ZoneNodePtr* old_input_ptr, int count) {\n  DCHECK_GE(count, 0);\n  // Extract the inputs from the old use and input pointers and copy them\n  // to this out-of-line-storage.\n  Use* new_use_ptr = reinterpret_cast<Use*>(this) - 1;\n  ZoneNodePtr* new_input_ptr = inputs();\n  CHECK_IMPLIES(count > 0, Use::InputIndexField::is_valid(count - 1));\n  for (int current = 0; current < count; current++) {\n    new_use_ptr->bit_field_ =\n        Use::InputIndexField::encode(current) | Use::InlineField::encode(false);\n    DCHECK_EQ(old_input_ptr, old_use_ptr->input_ptr());\n    DCHECK_EQ(new_input_ptr, new_use_ptr->input_ptr());\n    Node* old_to = *old_input_ptr;\n    if (old_to) {\n      *old_input_ptr = nullptr;\n      old_to->RemoveUse(old_use_ptr);\n      *new_input_ptr = old_to;\n      old_to->AppendUse(new_use_ptr);\n    } else {\n      *new_input_ptr = nullptr;\n    }\n    old_input_ptr++;\n    new_input_ptr++;\n    old_use_ptr--;\n    new_use_ptr--;\n  }\n  this->count_ = count;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"NewImpl\",\n            \"about\": \"Implements the creation of a new Node object, handling both inline and out-of-line inputs.\",\n            \"logic\": \"Determines whether to use inline or out-of-line storage for the node's inputs based on the input count. Allocates memory for the node and its inputs. Initializes the input pointers and Use objects. Appends the Use objects to the input nodes.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"id\",\n                    \"type\": \"NodeId\",\n                    \"purpose\": \"The ID of the node.\"\n                },\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const Operator*\",\n                    \"purpose\": \"The operator associated with the node.\"\n                },\n                {\n                    \"name\": \"input_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of inputs to the node.\"\n                },\n                {\n                    \"name\": \"inputs\",\n                    \"type\": \"NodePtrT const*\",\n                    \"purpose\": \"An array of input Node pointers.\"\n                },\n                {\n                    \"name\": \"has_extensible_inputs\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the node can have additional inputs added later.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"A pointer to the newly created Node object.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"Node\",\n                \"Operator\",\n                \"OutOfLineInputs\",\n                \"Use\",\n                \"ZoneNodePtr\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\ntemplate <typename NodePtrT>\nNode* Node::NewImpl(Zone* zone, NodeId id, const Operator* op, int input_count,\n                    NodePtrT const* inputs, bool has_extensible_inputs) {\n  // Node uses compressed pointers, so zone must support pointer compression.\n  DCHECK_IMPLIES(kCompressGraphZone, zone->supports_compression());\n  DCHECK_GE(input_count, 0);\n\n  ZoneNodePtr* input_ptr;\n  Use* use_ptr;\n  Node* node;\n  bool is_inline;\n\n  // Verify that none of the inputs are {nullptr}.\n  for (int i = 0; i < input_count; i++) {\n    if (inputs[i] == nullptr) {\n      FATAL(\"Node::New() Error: #%d:%s[%d] is nullptr\", static_cast<int>(id),\n            op->mnemonic(), i);\n    }\n  }\n\n  if (input_count > kMaxInlineCapacity) {\n    // Allocate out-of-line inputs.\n    int capacity =\n        has_extensible_inputs ? input_count + kMaxInlineCapacity : input_count;\n    OutOfLineInputs* outline = OutOfLineInputs::New(zone, capacity);\n\n    // Allocate node, with space for OutOfLineInputs pointer.\n    void* node_buffer = zone->Allocate<NodeWithOutOfLineInputs>(\n        sizeof(Node) + sizeof(ZoneOutOfLineInputsPtr));\n    node = new (node_buffer) Node(id, op, kOutlineMarker, 0);\n    node->set_outline_inputs(outline);\n\n    outline->node_ = node;\n    outline->count_ = input_count;\n\n    input_ptr = outline->inputs();\n    use_ptr = reinterpret_cast<Use*>(outline);\n    is_inline = false;\n  } else {\n    // Allocate node with inline inputs. Capacity must be at least 1 so that\n    // an OutOfLineInputs pointer can be stored when inputs are added later.\n    int capacity = std::max(1, input_count);\n    if (has_extensible_inputs) {\n      const int max = kMaxInlineCapacity;\n      capacity = std::min(input_count + 3, max);\n    }\n\n    size_t size = sizeof(Node) + capacity * (sizeof(ZoneNodePtr) + sizeof(Use));\n    intptr_t raw_buffer =\n        reinterpret_cast<intptr_t>(zone->Allocate<NodeWithInLineInputs>(size));\n    void* node_buffer =\n        reinterpret_cast<void*>(raw_buffer + capacity * sizeof(Use));\n\n    node = new (node_buffer) Node(id, op, input_count, capacity);\n    input_ptr = node->inline_inputs();\n    use_ptr = reinterpret_cast<Use*>(node);\n    is_inline = true;\n  }\n\n  // Initialize the input pointers and the uses.\n  CHECK_IMPLIES(input_count > 0,\n                Use::InputIndexField::is_valid(input_count - 1));\n  for (int current = 0; current < input_count; ++current) {\n    Node* to = *inputs++;\n    input_ptr[current] = to;\n    Use* use = use_ptr - 1 - current;\n    use->bit_field_ = Use::InputIndexField::encode(current) |\n                      Use::InlineField::encode(is_inline);\n    to->AppendUse(use);\n  }\n  node->Verify();\n  return node;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"New\",\n            \"about\": \"Creates a new Node object.\",\n            \"logic\": \"Calls the NewImpl template function with the appropriate type for the input array.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"id\",\n                    \"type\": \"NodeId\",\n                    \"purpose\": \"The ID of the node.\"\n                },\n                {\n                    \"name\": \"op\",\n                    \"type\": \"const Operator*\",\n                    \"purpose\": \"The operator associated with the node.\"\n                },\n                {\n                    \"name\": \"input_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of inputs to the node.\"\n                },\n                {\n                    \"name\": \"inputs\",\n                    \"type\": \"Node* const*\",\n                    \"purpose\": \"An array of input Node pointers.\"\n                },\n                {\n                    \"name\": \"has_extensible_inputs\",\n                    \"type\": \"bool\",\n                    \"purpose\": \"Indicates whether the node can have additional inputs added later.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"A pointer to the newly created Node object.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"Node\",\n                \"Operator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* Node::New(Zone* zone, NodeId id, const Operator* op, int input_count,\n                Node* const* inputs, bool has_extensible_inputs) {\n  return NewImpl(zone, id, op, input_count, inputs, has_extensible_inputs);\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"function\",\n            \"name\": \"Clone\",\n            \"about\": \"Clones an existing Node object.\",\n            \"logic\": \"Creates a new Node object with the same operator and inputs as the original node. Copies the type information from the original node to the clone.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"id\",\n                    \"type\": \"NodeId\",\n                    \"purpose\": \"The ID of the new node.\"\n                },\n                {\n                    \"name\": \"node\",\n                    \"type\": \"const Node*\",\n                    \"purpose\": \"The node to clone.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"A pointer to the cloned Node object.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"Node\",\n                \"Operator\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* Node::Clone(Zone* zone, NodeId id, const Node* node) {\n  int const input_count = node->InputCount();\n  ZoneNodePtr const* const inputs = node->has_inline_inputs()\n                                        ? node->inline_inputs()\n                                        : node->outline_inputs()->inputs();\n  Node* const clone = NewImpl(zone, id, node->op(), input_count, inputs, false);\n  clone->set_type(node->type());\n  return clone;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"Kill\",\n            \"parent\": \"Node\",\n            \"about\": \"Removes a node from the graph.\",\n            \"logic\": \"Nulls all inputs of the node and removes all uses of the node.\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::Kill() {\n  DCHECK_NOT_NULL(op());\n  NullAllInputs();\n  DCHECK(uses().empty());\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"AppendInput\",\n            \"parent\": \"Node\",\n            \"about\": \"Appends a new input to the node.\",\n            \"logic\": \"If the node has space for inline inputs, the new input is added to the inline storage. Otherwise, the node switches to out-of-line storage or expands the existing out-of-line storage. The Use object for the new input is appended to the input node's use list.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"new_to\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to add as an input.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"Node\",\n                \"OutOfLineInputs\",\n                \"Use\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::AppendInput(Zone* zone, Node* new_to) {\n  DCHECK_NOT_NULL(zone);\n  DCHECK_NOT_NULL(new_to);\n\n  int const inline_count = InlineCountField::decode(bit_field_);\n  int const inline_capacity = InlineCapacityField::decode(bit_field_);\n  if (inline_count < inline_capacity) {\n    // Append inline input.\n    bit_field_ = InlineCountField::update(bit_field_, inline_count + 1);\n    *GetInputPtr(inline_count) = new_to;\n    Use* use = GetUsePtr(inline_count);\n    static_assert(InlineCapacityField::kMax <= Use::InputIndexField::kMax);\n    use->bit_field_ = Use::InputIndexField::encode(inline_count) |\n                      Use::InlineField::encode(true);\n    new_to->AppendUse(use);\n  } else {\n    // Append out-of-line input.\n    int const input_count = InputCount();\n    OutOfLineInputs* outline = nullptr;\n    if (inline_count != kOutlineMarker) {\n      // switch to out of line inputs.\n      outline = OutOfLineInputs::New(zone, input_count * 2 + 3);\n      outline->node_ = this;\n      outline->ExtractFrom(GetUsePtr(0), GetInputPtr(0), input_count);\n      bit_field_ = InlineCountField::update(bit_field_, kOutlineMarker);\n      set_outline_inputs(outline);\n    } else {\n      // use current out of line inputs.\n      outline = outline_inputs();\n      if (input_count >= outline->capacity_) {\n        // out of space in out-of-line inputs.\n        outline = OutOfLineInputs::New(zone, input_count * 2 + 3);\n        outline->node_ = this;\n        outline->ExtractFrom(GetUsePtr(0), GetInputPtr(0), input_count);\n        set_outline_inputs(outline);\n      }\n    }\n    outline->count_++;\n    *GetInputPtr(input_count) = new_to;\n    Use* use = GetUsePtr(input_count);\n    CHECK(Use::InputIndexField::is_valid(input_count));\n    use->bit_field_ = Use::InputIndexField::encode(input_count) |\n                      Use::InlineField::encode(false);\n    new_to->AppendUse(use);\n  }\n  Verify();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InsertInput\",\n            \"parent\": \"Node\",\n            \"about\": \"Inserts a new input at a specific index in the node's input list.\",\n            \"logic\": \"Appends the last input to the input list and shifts the inputs from the insertion point to the end of the list by one position. Replaces the input at the specified index with the new input.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index at which to insert the new input.\"\n                },\n                {\n                    \"name\": \"new_to\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to insert as an input.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::InsertInput(Zone* zone, int index, Node* new_to) {\n  DCHECK_NOT_NULL(zone);\n  DCHECK_LE(0, index);\n  DCHECK_LT(index, InputCount());\n  AppendInput(zone, InputAt(InputCount() - 1));\n  for (int i = InputCount() - 1; i > index; --i) {\n    ReplaceInput(i, InputAt(i - 1));\n  }\n  ReplaceInput(index, new_to);\n  Verify();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"InsertInputs\",\n            \"parent\": \"Node\",\n            \"about\": \"Inserts multiple null inputs at a specific index in the node's input list.\",\n            \"logic\": \"Appends 'count' inputs to the end and replaces them with null values\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index at which to insert the new inputs.\"\n                },\n                {\n                    \"name\": \"count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of inputs to insert.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::InsertInputs(Zone* zone, int index, int count) {\n  DCHECK_NOT_NULL(zone);\n  DCHECK_LE(0, index);\n  DCHECK_LT(0, count);\n  DCHECK_LT(index, InputCount());\n  for (int i = 0; i < count; i++) {\n    AppendInput(zone, InputAt(std::max(InputCount() - count, 0)));\n  }\n  for (int i = InputCount() - count - 1; i >= std::max(index, count); --i) {\n    ReplaceInput(i, InputAt(i - count));\n  }\n  for (int i = 0; i < count; i++) {\n    ReplaceInput(index + i, nullptr);\n  }\n  Verify();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"RemoveInput\",\n            \"parent\": \"Node\",\n            \"about\": \"Removes an input from the node's input list at the specified index.\",\n            \"logic\": \"Shifts the inputs after the removed input to fill the gap. Trims the input count to reflect the removal.\",\n            \"parameters\": [\n                {\n                    \"name\": \"index\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the input to remove.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"Node*\",\n                \"description\": \"The node that was removed from the input list.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nNode* Node::RemoveInput(int index) {\n  DCHECK_LE(0, index);\n  DCHECK_LT(index, InputCount());\n  Node* result = InputAt(index);\n  for (; index < InputCount() - 1; ++index) {\n    ReplaceInput(index, InputAt(index + 1));\n  }\n  TrimInputCount(InputCount() - 1);\n  Verify();\n  return result;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ClearInputs\",\n            \"parent\": \"Node\",\n            \"about\": \"Clears a range of inputs from the node's input list.\",\n            \"logic\": \"Iterates through the specified range of inputs, setting each input to null and removing the corresponding Use object from the input node's use list.\",\n            \"parameters\": [\n                {\n                    \"name\": \"start\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The index of the first input to clear.\"\n                },\n                {\n                    \"name\": \"count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The number of inputs to clear.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Use\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::ClearInputs(int start, int count) {\n  ZoneNodePtr* input_ptr = GetInputPtr(start);\n  Use* use_ptr = GetUsePtr(start);\n  while (count-- > 0) {\n    DCHECK_EQ(input_ptr, use_ptr->input_ptr());\n    Node* input = *input_ptr;\n    *input_ptr = nullptr;\n    if (input) input->RemoveUse(use_ptr);\n    input_ptr++;\n    use_ptr--;\n  }\n  Verify();\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"NullAllInputs\",\n            \"parent\": \"Node\",\n            \"about\": \"Clears all inputs of the node.\",\n            \"logic\": \"Calls ClearInputs to clear all inputs from index 0 to InputCount().\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::NullAllInputs() { ClearInputs(0, InputCount()); }\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"TrimInputCount\",\n            \"parent\": \"Node\",\n            \"about\": \"Reduces the input count of the node.\",\n            \"logic\": \"If the node has inline inputs, the InlineCountField is updated. Otherwise, the count_ field of the out-of-line inputs is updated.\",\n            \"parameters\": [\n                {\n                    \"name\": \"new_input_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The new input count.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::TrimInputCount(int new_input_count) {\n  int current_count = InputCount();\n  DCHECK_LE(new_input_count, current_count);\n  if (new_input_count == current_count) return;  // Nothing to do.\n  ClearInputs(new_input_count, current_count - new_input_count);\n  if (has_inline_inputs()) {\n    bit_field_ = InlineCountField::update(bit_field_, new_input_count);\n  } else {\n    outline_inputs()->count_ = new_input_count;\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"EnsureInputCount\",\n            \"parent\": \"Node\",\n            \"about\": \"Ensures that the node has the specified number of inputs.\",\n            \"logic\": \"If the node has fewer inputs than the specified count, dummy inputs are appended until the count is reached.\",\n            \"parameters\": [\n                {\n                    \"name\": \"zone\",\n                    \"type\": \"Zone*\",\n                    \"purpose\": \"The zone to allocate memory from.\"\n                },\n                {\n                    \"name\": \"new_input_count\",\n                    \"type\": \"int\",\n                    \"purpose\": \"The desired input count.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Zone\",\n                \"Node\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::EnsureInputCount(Zone* zone, int new_input_count) {\n  int current_count = InputCount();\n  DCHECK_NE(current_count, 0);\n  if (current_count > new_input_count) {\n    TrimInputCount(new_input_count);\n  } else if (current_count < new_input_count) {\n    Node* dummy = InputAt(current_count - 1);\n    do {\n      AppendInput(zone, dummy);\n      current_count++;\n    } while (current_count < new_input_count);\n  }\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"UseCount\",\n            \"parent\": \"Node\",\n            \"about\": \"Calculates number of uses of this node.\",\n            \"logic\": \"Loops over 'first_use_' linked list to calculate the number of uses\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The number of uses of this node\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nint Node::UseCount() const {\n  int use_count = 0;\n  for (const Use* use = first_use_; use; use = use->next) {\n    ++use_count;\n  }\n  return use_count;\n}\n        ]]></code>\n    </func>\n\n        <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"BranchUseCount\",\n            \"parent\": \"Node\",\n            \"about\": \"Calculates number of uses of this node that are kBranch nodes.\",\n            \"logic\": \"Loops over 'first_use_' linked list to calculate the number of uses, checking if each 'from()' node is kBranch\",\n            \"parameters\": [],\n            \"return\": {\n                \"type\": \"int\",\n                \"description\": \"The number of uses of this node from kBranch nodes\"\n            },\n            \"dependencies\": []\n        }\n        </metadata>\n        <code><![CDATA[\nint Node::BranchUseCount() const {\n  int use_count = 0;\n  for (Use* use = first_use_; use; use = use->next) {\n    if (use->from()->opcode() == IrOpcode::kBranch) {\n      ++use_count;\n    }\n  }\n  return use_count;\n}\n        ]]></code>\n    </func>\n\n    <func>\n        <metadata>\n        {\n            \"language\": \"cpp\",\n            \"type\": \"method\",\n            \"name\": \"ReplaceUses\",\n            \"parent\": \"Node\",\n            \"about\": \"Replaces all uses of this node with another node.\",\n            \"logic\": \"Iterates through the uses of this node and updates the input pointers of the using nodes to point to the replacement node.\",\n            \"parameters\": [\n                {\n                    \"name\": \"that\",\n                    \"type\": \"Node*\",\n                    \"purpose\": \"The node to replace this node with.\"\n                }\n            ],\n            \"return\": {\n                \"type\": \"void\",\n                \"description\": \"No return value.\"\n            },\n            \"dependencies\": [\n                \"Node\",\n                \"Use\"\n            ]\n        }\n        </metadata>\n        <code><![CDATA[\nvoid Node::ReplaceUses(Node* that) {\n  DCHECK(this->first_use_ == nullptr || this->first_use_->prev == nullptr);\n  DCHECK(that->first_use_ == nullptr || that->first_use_->prev == nullptr);\n\n  // Update the pointers to {this} to point to {that}.\n  Use* last_use = nullptr;\n  for (Use* use = this->first_use_; use; use = use->next) {\n    *use->input_ptr() = that;\n    last_use = use;\n  }\n  if (last_use) {\n    // Concat the use list"
}